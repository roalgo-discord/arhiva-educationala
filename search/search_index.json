{"config":{"lang":["ro"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Bun venit la Arhiva Educationala RoAlgo","text":"<p>Aici g\u0103si\u021bi Arhiva Educa\u021bional\u0103 creat\u0103 de comunitatea RoAlgo, centrat\u0103 \u00een jurul serverului de Discord cu acela\u0219i nume.</p> <p>Scopul acestui proiect este de a crea cea mai complet\u0103 arhiv\u0103 educa\u021bional\u0103 pentru un student interesat de programarea competitiv\u0103, concentr\u00e2ndu-se, de asemenea, pe subiectele care apar frecvent \u00een s\u0103lile de clas\u0103, concursurile \u0219i olimpiadele de informatic\u0103 din Rom\u00e2nia.</p>"},{"location":"#ce-este-arhiva-educationala","title":"Ce este arhiva educa\u021bional\u0103?","text":"<p>Arhiva educa\u021bional\u0103 RoAlgo este f\u0103cut\u0103 cu scopul realiz\u0103ri unei surse de calitate despre algoritmi care s\u0103 fie folositori pentru toate nivelurile, fie c\u0103 e vorba de aprofundarea lor pentru orele de la clas\u0103, pentru examenele de bacalaureat \u0219i admitere, pentru participarea \u0219i ob\u021binerea de premii la olimpiada de informatic\u0103 \u0219i \u00een general pentru oricine e pasionat \u0219i vrea s\u0103 \u00eenve\u021be mai multe despre algoritmic\u0103, un domeniu tot mai important \u00een via\u021ba de zi cu zi, aici e locul potrivit pentru tine. </p>"},{"location":"#ce-ne-propunem-sa-facem","title":"Ce ne propunem s\u0103 facem?","text":"<p>Acest proiect este unul care va fi mereu \u00een curs de \u00eembun\u0103t\u0103\u021bire, pe m\u0103sur\u0103 ce ajungem s\u0103 avem tot mai multe articole mai detaliate pentru o audien\u021b\u0103 tot mai mare, scopul nostru fiind acela de a ajunge la c\u00e2t mai multe persoane.</p> <p>Sper\u0103m c\u0103 \u00eentr-o zi, poate chiar \u0219i cu ajutorul t\u0103u, s\u0103 avem o serie de resurse \u00een limba rom\u00e2n\u0103, care s\u0103 fie la nivelul altor resurse de top f\u0103cute de pasiona\u021bi din alte \u021b\u0103ri, astfel ajut\u00e2nd \u0219i profesorii \u00een munca pe care o depun cu elevii lor. </p>"},{"location":"#de-ce-sa-contribui","title":"De ce s\u0103 contribui?","text":"<p>\u00cen primul r\u00e2nd, la fel ca toate celelalte proiecte ale noastre, suntem deschi\u0219i oric\u0103rei persoane care vrea s\u0103 ne ajute \u00een munca noastr\u0103 de a ajuta \u021bara noastr\u0103 s\u0103 r\u0103m\u00e2n\u0103 unul din juc\u0103torii importan\u021bi \u00een informatica european\u0103 \u0219i mondial\u0103. </p> <p>Contribu\u021bia ta va r\u0103m\u00e2ne important\u0103 pentru genera\u021biile viitoare \u0219i vei putea folosi efortul t\u0103u de aici pentru a-\u021bi certifica calit\u0103\u021bile tale \u00een acest domeniu, indiferent c\u0103 e vorba de o experien\u021b\u0103 de voluntariat, o viitoare carier\u0103 \u00een domeniu sau chiar \u00een educa\u021bie. </p> <p>Vei cunoa\u0219te o mul\u021bime de oameni minuna\u021bi, mul\u021bi dintre ei fiind chiar cei care c\u00e2\u0219tig\u0103 medalii an de an la competi\u021biile interna\u021bionale din partea Rom\u00e2niei. </p>"},{"location":"#cum-poti-contribui","title":"Cum po\u021bi contribui?","text":"<p>Dac\u0103 vrei s\u0103 contribui la arhiva noastr\u0103 educa\u021bional\u0103, o po\u021bi face f\u0103c\u00e2nd un fork care s\u0103 plece din repo-ul nostru principal sau al\u0103tur\u00e2ndu-te serverului de Discord al arhivei noastre, \u00een cazul \u00een care \u00eent\u00e2mpini orice dificultate.</p> <p>Pentru cei curio\u0219i, aici pute\u021bi g\u0103si o list\u0103 cu articolele pe care le-am f\u0103cut, \u00eempreun\u0103 cu oameni care s-au asignat pe ele. </p> <p>Pe l\u00e2ng\u0103 articole noi, suntem mereu \u00een c\u0103utare de probleme interesante pe care s\u0103 le ad\u0103ug\u0103m \u00een articolele noastre \u0219i de \u00eembun\u0103t\u0103\u021biri ce se pot face la articolele existente. </p> <p>\u00centr-un viitor, ne propunem s\u0103 avem \u0219i sec\u021biuni cu solu\u021bii explicate la problemele \u0219i concursurile care nu au indica\u021bii detaliate, pe care s\u0103 le folosim cu scopul de a \u00eembun\u0103t\u0103\u021bi lista de resurse prezent\u0103 \u00een repo-ul nostru \u00een care am colectat solu\u021biile de la olimpiadele \u0219i concursurile rom\u00e2ne\u0219ti. </p>"},{"location":"licenta/","title":"Licen\u021b\u0103","text":"<p>Con\u021binutul acestui proiect este licen\u021biat sub Creative Commons Attribution-NonCommercial-ShareAlike (CC BY-NC-SA). Pute\u021bi copia, distribui \u0219i modifica materialul nostru at\u00e2ta timp c\u00e2t ne men\u021biona\u021bi ca surs\u0103, nu folosi\u021bi materialul \u00een scopuri comerciale \u0219i distribui\u021bi lucr\u0103rile derivate sub aceea\u0219i licen\u021b\u0103. Pentru detalii, consulta\u021bi licen\u021ba complet\u0103 aici.</p> <p>Codul scris pentru acest proiect este licen\u021biat sub European Union Public License versiunea 1.2 (EUPL v1.2). Aceasta v\u0103 permite s\u0103 folosi\u021bi, modifica\u021bi \u0219i distribui\u021bi codul, cu condi\u021bia ca orice lucrare derivat\u0103 s\u0103 fie distribuit\u0103 sub aceea\u0219i licen\u021b\u0103. Pentru detalii, consulta\u021bi licen\u021ba complet\u0103 aici.</p>"},{"location":"cppintro/","title":"Introducere \u00een C++","text":"<p>Autor: \u0218tefan-Iulian Alecu, \u0218tefan-Cosmin D\u0103sc\u0103lescu</p> <p>Bine ai venit! Sunt \u0218tefan \u0219i te voi asista \u00een c\u0103l\u0103toria ta de a \u00eenv\u0103\u021ba C++. Acest curs a fost g\u00e2ndit de la bun \u00eenceput s\u0103 fie practic \u0219i adaptat la limbajul C++ modern (C++11 \u0219i mai \u00eencolo).</p>"},{"location":"cppintro/#compilator-si-editor-local","title":"Compilator \u0219i editor local","text":"<p>Pentru a putea \u00eencepe, avem nevoie de un compilator. Un compilator este un program care traduce codul surs\u0103 scris \u00eentr-un limbaj (\u00een cazul nostru, C++) \u00een alt limbaj. Limbajul \u021bint\u0103 este cod ma\u0219in\u0103, adic\u0103 limbajul pe care \u00eel poate \u00een\u021belege \u0219i rula \u00een consecin\u021b\u0103 procesorul. Compilatorul va fi cel mai bun prieten al t\u0103u, a\u0219a c\u0103 este esen\u021bial s\u0103 instal\u0103m un compilator bun.</p> <p>Pentru \u00eenceput, ce sistem de operare folose\u0219ti?</p> <ul> <li> <p> Folosesc Windows 10/11</p> <p> Vezi instruc\u021biuni</p> </li> <li> <p> Folosesc macOS (10.15+)</p> <p> Vezi instruc\u021biuni</p> </li> <li> <p> Folosesc Linux</p> <p> Vezi instruc\u021biuni</p> </li> </ul> <p>Pentru alte op\u021biuni, recomand\u0103m acest articol. </p>"},{"location":"cppintro/#editoare-online","title":"Editoare online","text":"<p>Observa\u021bie</p> <p>Aceast\u0103 solu\u021bie trebuie s\u0103 fie una strict temporar\u0103. Niciun programator serios nu se bazeaz\u0103 strict pe editoare online, editoarele locale au multe avantaje comparativ cu cele online. </p> <p>Totu\u0219i, dac\u0103 dore\u0219ti s\u0103 nu lucrezi folosind un compilator \u0219i un editor, exist\u0103 solu\u021bii online pentru a scrie cod \u00een limbajul C++. O asemenea op\u021biune pe care autorii arhivei o recomand\u0103 este USACO Guide IDE. </p> <p>Pentru alte op\u021biuni, recomand\u0103m acest articol. </p>"},{"location":"cppintro/#concluzii","title":"Concluzii","text":"<p>Editoarele locale sunt mult mai folositoare dec\u00e2t cele online, deoarece permit o varietate de op\u021biuni \u0219i sunt mult mai versatile, fiind \u0219i folosite la concursurile reale de programare competitiv\u0103, inclusiv olimpiad\u0103. </p> <p>Dup\u0103 \u021bi-ai instalat compilatorul \u0219i editorul dorit, te invit\u0103m s\u0103 explorezi facilit\u0103\u021bile limbajului C++, \u00eencep\u00e2nd cu acest articol. </p>"},{"location":"cppintro/intro/","title":"Introducere","text":"<p>Autor: \u0218tefan-Cosmin D\u0103sc\u0103lescu</p> <p>Observa\u021bie</p> <p>Dac\u0103 nu \u021bi-ai instalat un compilator sau un editor, te invit\u0103m s\u0103 accesezi mai \u00eent\u00e2i acest articol pentru a putea scrie cod \u00eentr-o manier\u0103 clar\u0103 \u0219i f\u0103r\u0103 probleme ulterior.</p> <p>\u00cen cele ce urmeaz\u0103, vom prezenta c\u00e2teva dintre aspectele introductive ale limbajului de programare C++. </p>","tags":["C++","introducere"]},{"location":"cppintro/intro/#ce-este-un-limbaj-de-programare","title":"Ce este un limbaj de programare?","text":"<p>Limbajele de programare reprezint\u0103 un sistem de nota\u021bii pe care \u00eel folosim pentru a scrie programe folosite de calculatoare, acestea fiind mijlocul prin care oamenii pot comunica cu calculatoarele \u00eentr-o manier\u0103 asem\u0103n\u0103toare cu limbajul uman. </p> <p>Exist\u0103 foarte multe limbaje de programare, care pot fi \u00eemp\u0103r\u021bite \u00een multe categorii \u00een func\u021bie de modul \u00een care le utiliz\u0103m, sau modul \u00een care ajung s\u0103 comunice cu procesorul sau multe alte criterii.</p> <p>Unul din cele mai populare moduri de a \u00eemp\u0103r\u021bi limbajele de programare este \u00een func\u021bie de modul \u00een care interac\u021bioneaz\u0103 cu procesorul, aici putem vorbi de limbaje care au nevoie de un compilator care s\u0103 comunice cu procesorul (de exemplu, C, C++, Pascal etc.), respectiv de limbaje care au nevoie de un interpretor pentru acest lucru (de exemplu, Python, Java, JavaScript etc.). </p> <p>O alt\u0103 metod\u0103 de a clasifica limbajele de programare este \u00een func\u021bie de modul principal \u00een care oper\u0103m cu ele, put\u00e2nd vorbi astfel de limbaje imperative, func\u021bionale, logice \u0219i orientate pe obiecte. </p> <p>Observa\u021bie</p> <p>Pe parcursul studiului informaticii, fie c\u0103 ve\u021bi studia doar la liceu sau ve\u021bi ajunge s\u0103 ave\u021bi o carier\u0103, mai lung\u0103 sau mai scurt\u0103 \u00een domeniu, ve\u021bi avea de-a face cu foarte multe limbaje de programare, iar de\u0219i arhiva noastr\u0103 se concentreaz\u0103 pe limbajul C++ datorit\u0103 avantajelor sale \u00een ceea ce prive\u0219te algoritmica, nu exist\u0103 vreun limbaj de programare care s\u0103 fie \u00een totalitate inutil. </p> <ul> <li>Un limbaj imperativ (de exemplu, C++) este folosit pentru a implementa algoritmi \u00eentr-o ordine dat\u0103, cu alte cuvinte ele fac ceea ce le spunem s\u0103 fac\u0103.</li> <li>Un limbaj func\u021bional (de exemplu, Haskell) se caracterizeaz\u0103 prin aplicarea unor func\u021bii succesive pentru a rezolva cerin\u021bele programului dat. </li> <li>Un limbaj logic (de exemplu, Prolog) se caracterizeaz\u0103 prin faptul c\u0103 aplica\u021bia, \u0219i nu programatorul decide ordinea \u00een care sunt executate instruc\u021biunile. </li> <li>Un limbaj orientat pe obiecte (de exemplu, Java) are drept caracteristici principale folosirea claselor pentru abstractizarea, \u00eencapsularea, polimorfismul \u0219i mo\u0219tenirea datelor, aceste facilit\u0103\u021bi fiind incorporate \u0219i \u00een majoritatea limbajelor imperative \u0219i func\u021bionale. </li> </ul>","tags":["C++","introducere"]},{"location":"cppintro/intro/#limbajul-de-programare-c","title":"Limbajul de programare C++","text":"<p>Toate articolele pe care le vom avea \u00een aceast\u0103 arhiv\u0103 vor avea la baz\u0103 limbajul de programare C++, drept pentru care se impune introducerea cititorilor \u00een acest limbaj de programare. </p> <p>Limbajul C++</p> <p>Limbajul C++ a fost inventat de c\u0103tre Bjarne Stroustrup \u00een 1979, ca o extindere a limbajului C. Limbajul C a fost inventat \u00een 1969-1973 de c\u0103tre Dennis Ritchie pentru a realiza sistemul de operare Unix. </p> <p>Observa\u021bie</p> <p>Astfel, aproape toate programele scrise \u00een C pot fi compilate \u00een C++, eventual cu foarte pu\u021bine modific\u0103ri.</p>","tags":["C++","introducere"]},{"location":"cppintro/intro/#primul-program-in-c","title":"Primul program \u00een C++","text":"<p>Pentru a explica cum func\u021bioneaz\u0103 limbajul C++, voi \u00eencepe prin a scrie un program \u0219i v\u0103 voi ghida pe parcurs prin cele mai simple func\u021bionalit\u0103\u021bi, \u00eencep\u00e2nd cu sintaxa \u0219i termin\u00e2nd cu instruc\u021biunile \u0219i modul de operare cu ele.</p> <p>Pe scurt, acest program va prelua un num\u0103r natural \\(n\\) de la tastatur\u0103 \u0219i va implementa conjectura lui Collatz. </p> <p>Observa\u021bie</p> <p>Scopul acestui articol este acela de a v\u0103 ajuta s\u0103 fi\u021bi capabili s\u0103 \u00een\u021belege\u021bi \u0219i s\u0103 reproduce\u021bi programe similare folosind cuno\u0219tin\u021bele pe care le ve\u021bi acumula mai jos.</p> <p>Comentarii</p> <p>Pentru a explica diverse p\u0103r\u021bi din cod, vom folosi de-a lungul arhivei comentariile, acestea fiind o instruc\u021biune din limbajul C++. Pentru a pune un comentariu pe un singur r\u00e2nd, vom folosi <code>//</code>, iar pentru a comenta mai multe r\u00e2nduri, vom folosi perechea <code>/*</code> <code>*/</code>.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int n;\n    cin &gt;&gt; n;\n\n    while (n &gt; 1) {\n        cout &lt;&lt; n &lt;&lt; \" \";\n        if (n % 2 == 0) {\n            n = n / 2;\n        }\n        else {\n            n = n * 3 + 1;\n        }\n    }\n\n    cout &lt;&lt; n &lt;&lt; '\\n';\n    return 0; // instruc\u021biune ce se pune la finalul codurilor\n} \n</code></pre>","tags":["C++","introducere"]},{"location":"cppintro/intro/#elemente-de-baza-ale-sintaxei-c","title":"Elemente de baz\u0103 ale sintaxei C++","text":"<p>A\u0219a cum se poate observa \u00een programul de mai sus \u0219i \u00een exemplele ulterioare, majoritatea liniilor de cod se termin\u0103 cu un ; (punct \u0219i virgul\u0103 / semicolon). Excep\u021bie fac liniile \u00een care declar\u0103m biblioteci, func\u021bii, structuri alternative \u0219i repetitive.</p> <p>De asemenea, se poate remarca prezen\u021ba acoladelor pentru a separa blocuri de cod, acestea fiind folosite pentru a face codul mai u\u0219or de citit \u0219i \u00een cazul structurilor alternative \u0219i repetitive, a marca instruc\u021biunile subordonate acestora. </p> <p>Un alt element foarte important, care de\u0219i nu e obligatoriu, este foarte util \u0219i face scrierea codurilor mult mai u\u0219oar\u0103, reprezint\u0103 spa\u021bierea instruc\u021biunilor. Chiar dac\u0103 vom intra ulterior \u00een detaliu \u00een ceea ce prive\u0219te coding style-ul, acesta este un element de baz\u0103 pentru a scrie coduri c\u00e2t mai de calitate, obicei care dac\u0103 \u00eel deprinde\u021bi de la \u00eenceput, v\u0103 va fi mult mai u\u0219or s\u0103 \u00eel adapta\u021bi oric\u0103rui limbaj de programare pe care \u00eel ve\u021bi folosi.</p>","tags":["C++","introducere"]},{"location":"cppintro/intro/#compilarea-programului","title":"Compilarea programului","text":"<p>Dup\u0103 ce termina\u021bi de scris programul, dac\u0103 programul este corect din punct de vedere sintactic, programul va putea fi rulat, iar \u00een caz contrar, editorul v\u0103 va specifica erorile de compilare, \u00eempreun\u0103 cu locul \u00een care acestea apar. </p> <p>Dac\u0103 programul este corect \u0219i nu are vreo eroare, se va genera un cod obiect (programul pe care \u00eel g\u0103si\u021bi cu extensia .o \u00een acela\u0219i loc cu programul C++ pe care l-a\u021bi scris)</p> <p>Pentru a rula programul, va trebui s\u0103 rula\u021bi executabilul generat (programul cu extensia .exe), s\u0103 introduce\u021bi eventual datele \u0219i apoi s\u0103 vede\u021bi outputul generat.</p> <p>Observa\u021bie</p> <p>Pentru a vedea modific\u0103rile la r\u0103spunsurile generate, trebuie s\u0103 compila\u021bi \u0219i s\u0103 rula\u021bi din nou executabilul, \u00een caz contrar datele vor fi afi\u0219ate conform cu versiunea anterioar\u0103 a programului. </p>","tags":["C++","introducere"]},{"location":"cppintro/intro/#initializarea-programului","title":"Ini\u021bializarea programului","text":"<p>Prima linie, <code>#include &lt;iostream&gt;</code> reprezint\u0103 ceea ce vom numi o bibliotec\u0103, aceasta fiind o colec\u021bie de func\u021bii, clase \u0219i metode ce pot fi reutilizate f\u0103r\u0103 a fi nevoie s\u0103 scriem \u00eentreag\u0103 defini\u021bie de m\u00e2n\u0103. Un echivalent \u00een via\u021ba de zi reprezint\u0103 utilizarea unei c\u0103r\u021bi de re\u021bete pentru prepararea unui fel de m\u00e2ncare, astfel noi putem folosi acele metode f\u0103r\u0103 a fi nevoie s\u0103 le reinvent\u0103m. Toate bibliotecile vor avea sintaxa <code>#include &lt;NUME&gt;</code>, exemple ar fi <code>#include &lt;fstream&gt;</code>, <code>#include &lt;cmath&gt;</code>, <code>#include &lt;vector&gt;</code>, <code>#include &lt;cstring&gt;</code> etc.</p> <p>Urm\u0103toarea linie, <code>using namespace std;</code> ne indic\u0103 faptul c\u0103 putem utiliza toate defini\u021biile incluse \u00een namespace-ul standard. Un namespace reprezint\u0103 o regiune de declar\u0103ri care confer\u0103 un scop identificatorilor (numelor func\u021biilor, variabilelor, tipurilor de date etc.) din acesta, fiind folosite pentru a grupa codul \u00een grupe logice \u0219i pentru a preveni coliziunile de nume care pot ap\u0103rea \u00een special \u00een situa\u021bia \u00een care programul nostru include multiple biblioteci. </p> <p>Observa\u021bie</p> <p>Aproape toate programele scrise \u00een limbajul C++ vor avea aceste dou\u0103 linii, eventual \u00eempreun\u0103 cu alte biblioteci \u0219i namespace-uri, detalii pe care le vom l\u0103sa ulterior pe m\u0103sur\u0103 ce v\u0103 ve\u021bi obi\u0219nui mai bine cu limbajul \u00een sine. </p>","tags":["C++","introducere"]},{"location":"cppintro/intro/#functia-main","title":"Func\u021bia main()","text":"<p>Defini\u021bie</p> <p><code>int main()</code> este o func\u021bie care apare \u00een fiecare program C++, aceasta fiind func\u021bia principal\u0103 a oric\u0103rui program scris \u00een acest limbaj, fiind \u0219i func\u021bia apelat\u0103 mai \u00eent\u00e2i de orice compilator. </p> <p>Aceast\u0103 func\u021bie este cea \u00een care vom scrie toate instruc\u021biunile, inclusiv a\u0219a cum ve\u021bi vedea \u00eentr-un articol ulterior, cele care vor fi folosite pentru a apela func\u021bii auxiliare. </p> <p>De asemenea, aici vom avea toate instruc\u021biunile \u0219i structurile de care avem nevoie pentru a citi \u0219i afi\u0219a datele, prelucrarea lor, precum \u0219i multe alte facilit\u0103\u021bi specifice, precum manipularea lor folosind structuri logice, alternative \u0219i repetitive.</p> <p>\u00cen cele ce urmeaz\u0103, vom prezenta aceste p\u0103r\u021bi componente ale fiec\u0103rui program, pe parcurs intr\u00e2nd \u0219i \u00een lucruri mai specifice, \u00een articolele ulterioare. </p>","tags":["C++","introducere"]},{"location":"cppintro/intro/#citirea-si-afisarea-datelor","title":"Citirea \u0219i afi\u0219area datelor","text":"<p>Datele pot fi citite \u0219i afi\u0219ate fie prin intrarea \u0219i ie\u0219irea standard (numite colocvial \"de la tastatur\u0103\", respectiv \"pe ecran\"), fie folosind fi\u0219iere auxiliare, prelu\u00e2nd datele dintr-un fi\u0219ier \u0219i afi\u0219\u00e2ndu-le \u00een alt fi\u0219ier. </p> <p>Aceste metode pot fi folosite \u0219i \u00eentr-o manier\u0103 hibrid, fiind foarte multe exemple de probleme \u00een care se dau datele \u00eentr-un fi\u0219ier de intrare \u0219i se afi\u0219eaz\u0103 pe ecran.</p>","tags":["C++","introducere"]},{"location":"cppintro/intro/#intrarea-si-iesirea-standard","title":"Intrarea \u0219i ie\u0219irea standard","text":"<p>Pentru a folosi intrarea \u0219i ie\u0219irea standard (a citi \"de la tastatur\u0103\", respectiv a afi\u0219a \"pe ecran\"), vom avea nevoie de biblioteca <code>#include &lt;iostream&gt;</code>.</p> <p>Citirea datelor se face folosind instruc\u021biunea cin, iar afi\u0219area datelor se face folosind instruc\u021biunea cout, c\u00e2teva exemple fiind reg\u0103site mai jos. </p> <p>Observa\u021bie</p> <p>Aceasta nu este singura metod\u0103 de a citi \u0219i afi\u0219a datele, putem citi \u0219i afi\u0219a datele \u0219i folosind metodele specifice limbajului C (instruc\u021biunile scanf \u0219i printf). Totu\u0219i, metodele native limbajului C++ sunt cele mai intuitive \u0219i mai simplu de utilizat.</p> <p>Atunci c\u00e2nd folosi\u021bi intrarea \u0219i ie\u0219irea standard, dup\u0103 ce compila\u021bi programul \u0219i nu apare nicio eroare, va trebui s\u0103 rula\u021bi executabilul generat \u0219i s\u0103 introduce\u021bi datele de intrare conform descrierii problemei \u0219i a programului scris de voi anterior. \u00cen cazul \u00een care a\u021bi procedat cum trebuie, ve\u021bi ob\u021bine un r\u0103spuns conform cu ceea ce a\u021bi scris. \u00cen caz contrar, va trebui s\u0103 verifica\u021bi ce a\u021bi scris \u0219i eventual, s\u0103 modifica\u021bi programul. </p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main () {\n    // mai intai, declaram variabilele folosite\n    int n, a, b;\n\n    // citim o singura valoare\n    cin &gt;&gt; n; \n\n    // citim doua valori separate prin spatiu \n    cin &gt;&gt; a &gt;&gt; b; \n\n    /* alternativ, putem sa citim toate cele 3 variabile pe acelasi rand\n    cin &gt;&gt; n &gt;&gt; a &gt;&gt; b;\n    */\n\n    // afisam o singura valoare\n    cout &lt;&lt; n; \n\n    // afisam doua valori separate prin spatiu, urmate de o linie noua \n    cout &lt;&lt; a &lt;&lt; \" \" &lt;&lt; b &lt;&lt; '\\n'; \n\n    // afisam din nou n, urmat de o linie noua\n    cout &lt;&lt; n &lt;&lt; endl;\n\n    return 0;\n}\n</code></pre> <p>Dac\u0103 \\(n = 9\\), \\(a = 11\\) \u0219i \\(b = 14\\), programul va afi\u0219a urm\u0103toarele date:</p> <pre><code>911 14\n9\n</code></pre> <p>endl vs '\\n'</p> <p>Probabil c\u0103 a\u021bi observat c\u0103 pentru a afi\u0219a o linie nou\u0103, am folosit pe de o parte <code>'\\n'</code> \u0219i pe de alt\u0103 parte, <code>endl</code>. De\u0219i aceste instruc\u021biuni par identice \u00een rol, nu pot fi mai diferite. Se remarc\u0103 faptul c\u0103 instruc\u021biunea <code>endl</code>, pe l\u00e2ng\u0103 rolul de a marca trecerea la o linie nou\u0103, cur\u0103\u021b\u0103 bufferul (un loc \u00een care sunt stocate datele temporar) de datele deja afi\u0219ate, ceea ce face aceast\u0103 instruc\u021biune mult mai \u00eenceat\u0103 dec\u00e2t <code>'\\n'</code>, lucru ce se poate dovedi important atunci c\u00e2nd lucr\u0103m cu un volum de date foarte mare. </p>","tags":["C++","introducere"]},{"location":"cppintro/intro/#citirea-si-afisarea-folosind-fisiere","title":"Citirea \u0219i afi\u0219area folosind fi\u0219iere","text":"<p>Pentru a citi \u0219i afi\u0219a din fi\u0219iere, vom avea nevoie de biblioteca <code>#include &lt;fstream&gt;</code>.</p> <p>Mai \u00eent\u00e2i, trebuie s\u0103 specific\u0103m programului de unde s\u0103 preia datele \u0219i de unde s\u0103 le afi\u0219eze. </p> <pre><code>ifstream fin(\"date.in\");\nofstream fout(\"date.out\");\n</code></pre> <p>Numele fi\u0219ierelor</p> <p>De\u0219i aici am folosit fin \u0219i fout pentru a putea men\u021biona aceste streamuri de date, putem folosi orice nume vrem at\u00e2ta timp c\u00e2t nu avem \u0219i alte variabile numite astfel. \u00cen mod particular, putem numi acestea chiar \u0219i cin, respectiv cout at\u00e2ta timp c\u00e2t nu avem inclus\u0103 biblioteca iostream.</p> <p>Programul de mai sus va fi identic, singura diferen\u021b\u0103 fiind ad\u0103ugarea facilit\u0103\u021bilor care ne permit s\u0103 citim datele din fi\u0219iere. </p> <pre><code>#include &lt;fstream&gt;\nusing namespace std;\n\nifstream fin(\"date.in\");\nofstream fout(\"date.out\");\n\nint main () {\n    // mai intai, declaram variabilele folosite\n    int n, a, b;\n\n    // citim o singura valoare\n    fin &gt;&gt; n; \n\n    // citim doua valori separate prin spatiu \n    fin &gt;&gt; a &gt;&gt; b; \n\n    /* alternativ, putem sa citim toate cele 3 variabile pe acelasi rand\n    fin &gt;&gt; n &gt;&gt; a &gt;&gt; b;\n    */\n\n    // afisam o singura valoare\n    fout &lt;&lt; n; \n\n    // afisam doua valori separate prin spatiu, urmate de o linie noua \n    fout &lt;&lt; a &lt;&lt; \" \" &lt;&lt; b &lt;&lt; '\\n'; \n\n    // afisam din nou n, urmat de o linie noua\n    fout &lt;&lt; n &lt;&lt; endl;\n\n    return 0;\n}\n</code></pre>","tags":["C++","introducere"]},{"location":"cppintro/intro/#variabile","title":"Variabile","text":"<p>O variabil\u0103 reprezint\u0103 o loca\u021bie de memorie unde se afl\u0103 o valoare de un anumit tip. Orice variabil\u0103 este caracterizat\u0103 de:</p> <ul> <li>adresa variabilei (unde se afl\u0103 variabila stocat\u0103 \u00een memorie), nu lucr\u0103m cu ea \u00een timpul programelor dar uneori \u00een cazul unor afi\u0219\u0103ri gre\u0219ite, o putem detecta, aceasta fiind reprezentat\u0103 cu un num\u0103r \u00een baza 16 (de exemplu, 0x6dfed4).</li> <li>identificatorul variabilei \u2013 reprezint\u0103 un nume pentru variabil\u0103 \u2013 leg\u0103tura dintre variabil\u0103 si adresa ei. Identificatorul respect\u0103 urm\u0103toarele reguli:<ul> <li>con\u021bine litere mari, mici ale alfabetului englez cifre \u0219i caracterul de subliniere '_' \u2013 underline. Literele mari sunt considerate diferite de cele mici, astfel c\u0103 Raspuns, raspuns \u0219i RASPUNS reprezint\u0103 identificatori diferi\u021bi.</li> <li>primul caracter nu poate fi cifr\u0103.</li> <li>identificatorul nu poate face parte din lista cuvintelor rezervate (de regul\u0103, numele unor func\u021bii, tipuri, structuri etc.)</li> </ul> </li> <li>tipul variabilei \u2013 stabile\u0219te ce fel de valori poate s\u0103 ia variabila, aceasta determin\u00e2nd \u0219i limitele valorilor ce pot fi luate de ea.</li> <li>domeniul de vizibilitate \u2013 reprezint\u0103 zona din program \u00een care variabila exist\u0103 \u0219i poate fi utilizat\u0103. Variabilele pot fi globale sau locale.</li> </ul> <p>\u00cen C/C++, variabilele trebuie declarate, preciz\u00e2nd tipul \u0219i identificatorul. Sintaxa este:</p> <pre><code>Tip_de_date Lista_identificatori;\n</code></pre> <p>unde Tip_de_date reprezint\u0103 tipul de date pe care \u00eel folosim (de exemplu, int, long long, double, bool, string etc.) \u0219i Lista_identificatori reprezint\u0103 lista variabilelor pe care le declar\u0103m cu acest tip. </p> <p>Un exemplu \u00een codul de mai sus este <code>int n, a, b;</code>.</p>","tags":["C++","introducere"]},{"location":"cppintro/intro/#structura-alternativa","title":"Structura alternativ\u0103","text":"<p>Defini\u021bie</p> <p>O structur\u0103 alternativ\u0103 este o structur\u0103 pe care o folosim pentru a coordona programul s\u0103 ia decizii diferite \u00een func\u021bie de rezultatul unei expresii logice. </p> <p>\u00cen limbajul C++, structura alternativ\u0103 este reprezentat\u0103 de blocul if..else, astfel \u00eenc\u00e2t putem s\u0103 direc\u021bion\u0103m programul \u00een func\u021bie de rezultatele expresiilor logice men\u021bionate. </p> <p>Pe l\u00e2ng\u0103 if..else, exist\u0103 \u0219i instruc\u021biunea switch-case, care func\u021bioneaz\u0103 \u00eentr-o manier\u0103 similar\u0103, trec\u00e2nd prin fiecare caz pe r\u00e2nd f\u0103r\u0103 a mai fi nevoie de if-uri \u0219i else-uri</p>","tags":["C++","introducere"]},{"location":"cppintro/intro/#operatori-logici","title":"Operatori logici","text":"<p>De cele mai multe ori, ve\u021bi vedea c\u0103 expresiile logice apar grupate folosind operatorii logici. Operatorii logici sunt de trei feluri, dup\u0103 cum urmeaz\u0103:</p> <ul> <li>Nega\u021bia - notat\u0103 cu <code>!</code>, inverseaz\u0103 valoarea de adev\u0103r a unei expresii.</li> </ul> <pre><code>int x = 10;\ncout &lt;&lt; !(x == 10); // 0: x == 10 este adev\u0103rat (1), 1 negat este 0\ncout &lt;&lt; !x == 10; // tot 0, dar se efectueaz\u0103 mai \u00eent\u00e2i !x, adic\u0103 !10, cu rezultat 0, apoi 0 == 10, cu rezultat fals, adic\u0103 0\ncout &lt;&lt; !(x &lt; 5); // 1: x &lt; 5 este fals, adic\u0103 0, 0 negat este 1\n</code></pre> <ul> <li>Conjunc\u021bia - notat\u0103 cu <code>&amp;&amp;</code>, reprezint\u0103 compunerea a dou\u0103 sau mai multe expresii prin operatorul \u0218I, cu alte cuvinte, pentru ca o expresie compus\u0103 s\u0103 fie adev\u0103rat\u0103, to\u021bi membrii ei trebuie s\u0103 fie adev\u0103ra\u021bi, altfel, \u00eentreaga expresie este fals\u0103.</li> </ul> <pre><code>cout &lt;&lt; (1 &lt; 2 &amp;&amp; 2 == 1 + 1); // 1; ADEV\u0102RAT \u0218I ADEV\u0102RAT este ADEV\u0102RAT\ncout &lt;&lt; (1 &lt; 2 &amp;&amp; 2 != 1 + 1); // 0; ADEV\u0102RAT \u0218I FALS este FALS\ncout &lt;&lt; (1 == 2 &amp;&amp; 2 == 1 + 1); // 0; FALS \u0218I ADEV\u0102RAT este FALS\ncout &lt;&lt; (1 == 2 &amp;&amp; 2 != 1 + 1); // 0; FALS \u0218I FALS este FALS\n</code></pre> <ul> <li>Disjunc\u021bia - notat\u0103 cu <code>||</code>, reprezint\u0103 compunerea a dou\u0103 sau mai multe expresii prin operatorul SAU, cu alte cuvinte, pentru ca o expresie compus\u0103 s\u0103 fie adev\u0103rat\u0103, cel pu\u021bin unul dintre membrii ei trebuie s\u0103 fie adev\u0103ra\u021bi, altfel, \u00eentreaga expresie este fals\u0103.</li> </ul> <pre><code>cout &lt;&lt; (1 &lt; 2 || 2 == 1 + 1); // 1; ADEV\u0102RAT SAU ADEV\u0102RAT este ADEV\u0102RAT\ncout &lt;&lt; (1 &lt; 2 || 2 != 1 + 1); // 1; ADEV\u0102RAT SAU FALS este ADEV\u0102RAT\ncout &lt;&lt; (1 == 2 || 2 == 1 + 1); // 1; FALS SAU ADEV\u0102RAT este ADEV\u0102RAT\ncout &lt;&lt; (1 == 2 || 2 != 1 + 1); // 0; FALS SAU FALS este FALS\n</code></pre>","tags":["C++","introducere"]},{"location":"cppintro/intro/#exemplu","title":"Exemplu","text":"<p>Mai jos pute\u021bi g\u0103si un asemenea exemplu, \u00een care rezolv\u0103m problema cumparaturi1 de pe pbinfo folosind diverse if-uri \u0219i else-uri. O solu\u021bie alternativ\u0103 folose\u0219te switch-case.</p> if-elseswitch-case <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int s, c, n;\n    cin &gt;&gt; s &gt;&gt; c &gt;&gt; n;\n\n    if (s % n == 0 &amp;&amp; s % c == 0) { // daca ambele conditii sunt indeplinite\n        cout &lt;&lt; \"CN\" &lt;&lt; '\\n';\n    }\n    else {\n        if (s % n == 0) { // daca prima conditie este indeplinita\n            cout &lt;&lt; \"N\" &lt;&lt; '\\n';\n        }\n        else {\n            if (s % c == 0) { // daca cea de-a doua conditie este indeplinita\n                cout &lt;&lt; \"C\" &lt;&lt; '\\n';\n            }\n            else { // daca nicio conditie nu este indeplinita\n                cout &lt;&lt; \"nimic\" &lt;&lt; '\\n';\n            }\n        }\n    }\n    return 0;\n}\n</code></pre> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int s, c, n;\n    cin &gt;&gt; s &gt;&gt; c &gt;&gt; n;\n\n    // Combinam conditia intr-o singura valoare\n    int condition = (s % n == 0) * 1 + (s % c == 0) * 2;\n\n    switch (condition) {\n        case 3: // daca ambele conditii sunt indeplinite (s % n == 0 &amp;&amp; s % c == 0)\n            cout &lt;&lt; \"CN\" &lt;&lt; '\\n';\n            break;\n        case 1: // daca prima conditie este indeplinita (s % n == 0)\n            cout &lt;&lt; \"N\" &lt;&lt; '\\n';\n            break;\n        case 2: // daca cea de-a doua conditie este indeplinita (s % c == 0)\n            cout &lt;&lt; \"C\" &lt;&lt; '\\n';\n            break;\n        default: // daca nicio conditie nu este indeplinita\n            cout &lt;&lt; \"nimic\" &lt;&lt; '\\n';\n            break;\n    }\n\n    return 0;\n}\n</code></pre>","tags":["C++","introducere"]},{"location":"cppintro/intro/#structura-repetitiva","title":"Structura repetitiv\u0103","text":"<p>Defini\u021bie</p> <p>O structur\u0103 repetitiv\u0103 este o structur\u0103 pe care o folosim pentru a coordona programul s\u0103 ia acelea\u0219i decizii de mai multe ori, at\u00e2ta timp c\u00e2t o anumit\u0103 condi\u021bie este \u00eendeplinit\u0103. Acest lucru se poate \u00eent\u00e2mpla de un num\u0103r fixat de ori sau de un num\u0103r variat de ori. </p> <p>Cele trei structuri repetitive din C++ sunt while, do..while \u0219i for. De\u0219i acestea au \u00een mare parte acela\u0219i rol, func\u021bioneaz\u0103 \u00eentr-un mod diferit \u0219i trebuie \u0219tiute pentru a putea folosi cea mai potrivit\u0103 variant\u0103 \u00een func\u021bie de ce ne cere problema. De\u0219i majoritatea programelor pot fi scrise folosind toate cele trei structuri repetitive, sunt situa\u021bii \u00een care nu este practic s\u0103 folosim anumite structuri, deci ne vom concentra pe a ar\u0103ta cele mai potrivite exemple \u00een func\u021bie de situa\u021bie.</p>","tags":["C++","introducere"]},{"location":"cppintro/intro/#structura-while","title":"Structura while","text":"<p>Defini\u021bie</p> <p>Structura repetitiv\u0103 while este o structur\u0103 repetitiv\u0103 cu test ini\u021bial \u0219i num\u0103r necunoscut de pa\u0219i pe care o folosim pentru a coordona programul s\u0103 ia acelea\u0219i decizii at\u00e2ta timp c\u00e2t o anumit\u0103 condi\u021bie este \u00eendeplinit\u0103 \u0219i nu \u0219tim num\u0103rul de pa\u0219i pe care vrem s\u0103-l facem.</p> <p>Sintaxa while-ului este de regul\u0103, urm\u0103toarea:</p> <pre><code>while (conditie) {\n    // instructiuni\n}\n</code></pre>","tags":["C++","introducere"]},{"location":"cppintro/intro/#structura-dowhile","title":"Structura do..while","text":"<p>Defini\u021bie</p> <p>Structura repetitiv\u0103 do-while este o structur\u0103 repetitiv\u0103 cu test final \u0219i num\u0103r necunoscut de pa\u0219i pe care o folosim pentru a coordona programul s\u0103 ia acelea\u0219i decizii at\u00e2ta timp c\u00e2t o anumit\u0103 condi\u021bie este \u00eendeplinit\u0103 \u0219i nu \u0219tim num\u0103rul de pa\u0219i pe care vrem s\u0103-l facem, dar vrem s\u0103 rul\u0103m instruc\u021biunile m\u0103car o dat\u0103.</p> <p>Sintaxa do..while-ului este de regul\u0103, urm\u0103toarea:</p> <pre><code>do {\n    // instructiuni\n}while (conditie);\n</code></pre>","tags":["C++","introducere"]},{"location":"cppintro/intro/#structura-for","title":"Structura for","text":"<p>Defini\u021bie</p> <p>Structura repetitiv\u0103 for este o structur\u0103 repetitiv\u0103 cu test ini\u021bial \u0219i num\u0103r cunoscut de pa\u0219i pe care o folosim pentru a coordona programul s\u0103 ia acelea\u0219i decizii c\u00e2nd \u0219tim num\u0103rul de pa\u0219i pe care vrem s\u0103-l facem. De\u0219i for se poate scrie \u0219i folosind rigorile while-ului, av\u00e2nd num\u0103r necunoscut de pa\u0219i, se prefer\u0103 folosirea for-ului c\u00e2nd \u0219tim c\u00e2\u021bi pa\u0219i vrem s\u0103 facem, respectiv a while-ului \u00een caz contrar.</p> <pre><code>for (instructiune_initiala; conditie; actualizare) {\n    // instructiuni\n}\n</code></pre> <p>Un astfel de exemplu ar fi </p> <pre><code>int s = 0;\nfor (int i = 1; i &lt;= n; i++) {\n    s = s + i;\n}\n</code></pre>","tags":["C++","introducere"]},{"location":"cppintro/intro/#exemplu_1","title":"Exemplu","text":"<p>Mai jos pute\u021bi g\u0103si un asemenea exemplu, \u00een care rezolv\u0103m problema AfisareNumerePare de pe pbinfo folosind diverse structuri repetitive.</p> whilefordo..while <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int n;\n    cin &gt;&gt; n;\n\n    int x = 1;\n    while (x &lt;= n) {\n        cout &lt;&lt; x * 2 &lt;&lt; \" \";\n        x++;\n    }\n    return 0;\n}\n</code></pre> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int n;\n    cin &gt;&gt; n;\n\n    for (int i = 1; i &lt;= n; i++) {\n        cout &lt;&lt; i*2 &lt;&lt; \" \";\n    }\n    return 0;\n}\n</code></pre> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int n;\n    cin &gt;&gt; n;\n\n    int x = 1;\n    do{\n        cout &lt;&lt; x * 2 &lt;&lt; \" \";\n        x++;\n    }while (x &lt;= n);\n    return 0;\n}\n</code></pre>","tags":["C++","introducere"]},{"location":"cppintro/intro/#concluzii","title":"Concluzii","text":"<p>Chiar dac\u0103 acest articol con\u021bine foarte mult\u0103 informa\u021bie, recomand\u0103m familiarizarea cu conceptele men\u021bionate mai sus \u00een ordinea de mai sus, rezolv\u00e2nd aplica\u021bii simple care s\u0103 cuprind\u0103 aceste concepte. De asemenea, cu c\u00e2t scrie\u021bi mai multe programe, cu at\u00e2t ve\u021bi fi mai obi\u0219nui\u021bi cu aceste instruc\u021biuni \u0219i le ve\u021bi folosi corect \u0219i eficient. </p> <p>\u00cen articolele ulterioare, vom insista pe formarea unui coding style, alte facilit\u0103\u021bi ale limbajului C++ \u0219i alte informa\u021bii utile pe m\u0103sur\u0103 ce v\u0103 obi\u0219nui\u021bi cu limbajul \u00een sine. </p>","tags":["C++","introducere"]},{"location":"cppintro/intro/#resurse-suplimentare","title":"Resurse suplimentare","text":"<ul> <li>Sectiunile Elemente de baz\u0103 ale limbajului C++ si Structuri de control de pe pbinfo</li> <li>Linkurile de pe w3schools</li> </ul>","tags":["C++","introducere"]},{"location":"cppintro/intro/#probleme-suplimentare","title":"Probleme suplimentare","text":"<ul> <li>Probleme usoare si medii din capitolul Operatori \u0219i expresii</li> <li>Probleme usoare si medii din capitolul Structura de decizie</li> <li>Probleme usoare si medii din capitolul Structuri repetitive</li> </ul>","tags":["C++","introducere"]},{"location":"cppintro/linux/","title":"Linux","text":"<p>\u00cenainte de a instala un editor/IDE, avem nevoie de un compilator. Pe Linux, cele mai populare op\u021biuni sunt:</p> <ul> <li> <p> GCC</p> <p>GCC (GNU Compiler Collection) este o suit\u0103 de compilatoare libere \u0219i gratuite. Este standardul de facto pentru dezvoltarea C++ pe Linux. GCC este disponibil \u00een majoritatea distribu\u021biilor Linux \u0219i poate fi instalat direct din managerul de pachete al sistemului.</p> <p> Vezi instruc\u021biuni pentru GCC</p> </li> <li> <p> Clang</p> <p>Clang este un compilator rapid \u0219i modular, parte a proiectului LLVM. Este o alternativ\u0103 popular\u0103 la GCC, oferind uneori mesaje de eroare mai clare \u0219i o compatibilitate excelent\u0103 cu standardele moderne C++.</p> <p> Vezi instruc\u021biuni pentru Clang</p> </li> </ul> <p>Dac\u0103 ai deja un compilator instalat pe sistem, aici ai unele op\u021biuni de editoare pentru a \u00eencepe s\u0103 dezvol\u021bi \u00een C++:</p> <p>Vezi op\u021biuni de editoare </p>"},{"location":"cppintro/windows/","title":"Windows 10/11","text":"<p>\u00cenainte de a instala un editor/IDE, avem nevoie de un compilator. Exist\u0103 urm\u0103toarele op\u021biuni:</p> <ul> <li> <p> MSVC</p> <p>MSVC (Microsoft Visual C++) este un compilator proprietar f\u0103cut de Microsoft \u0219i este parte din IDE-ul Visual Studio 2022.</p> <p>Dac\u0103 e\u0219ti sigur(\u0103) c\u0103 vrei s\u0103 folose\u0219ti acest IDE \u00een particular, alege aceast\u0103 op\u021biune. Dac\u0103 l-ai instalat deja, atunci alege aceast\u0103 op\u021biune, deoarece articolul include \u0219i ni\u0219te sfaturi de performan\u021b\u0103.</p> <p> Vezi instruc\u021biuni pentru Visual Studio</p> </li> <li> <p> GCC (MinGW)</p> <p>GCC (GNU Compiler Collection) este o suit\u0103 de compilatoare libere \u0219i gratuite. Cel mai folosit compilator din aceast\u0103 suit\u0103 este GCC (GNU C Compiler).</p> <p>Pe Windows, cea mai u\u0219oar\u0103 metod\u0103 de a instala compilatorul GCC este folosind MinGW-w64. \u00cen caz c\u0103 nu folose\u0219ti Visual Studio 2022, ci alt editor (de pild\u0103, Code::Blocks sau Visual Studio Code), alege aceast\u0103 op\u021biune.</p> <p> Vezi instruc\u021biuni pentru MinGW</p> </li> </ul> <p>Dac\u0103 ai deja un compilator instalat pe sistem (fie MSVC, fie GCC prin MinGW), atunci aici ai unele op\u021biuni de editoare:</p> <p>Vezi op\u021biuni de editoare </p>"},{"location":"cppintro/compilers/linux/clang/","title":"Clang","text":"<p>TODO</p>"},{"location":"cppintro/compilers/linux/gcc/","title":"GCC","text":"<p>TODO</p>"},{"location":"cppintro/compilers/windows/mingw64/","title":"Compilatorul GCC (MinGW-w64)","text":"<p>Proiectul MinGW-w64 este continuarea proiectului MinGW (Minimalist GNU for Windows), f\u0103cut ca s\u0103 suporte compilatorul GCC pe Windows, cu suport pentru 64 de bi\u021bi (ceea ce este cel mai probabil ce folose\u0219ti acum). Acest compilator poate fi folosit inclusiv pe Linux pentru a compila binare pentru Windows.</p> <p>Pentru a instala MinGW-w64, avem urm\u0103torii pa\u0219i:</p> <ol> <li> <p>Deschide pagina https://winlibs.com/. Aceast\u0103 pagin\u0103 ofer\u0103 binare    executabile pre-compilate pentru GCC \u0219i optimizate pentru a crea executabile    native pe Windows.</p> <p>Deschide pagina </p> </li> <li> <p>D\u0103 scroll p\u00e2n\u0103 c\u00e2nd o s\u0103 vezi versiunile de GCC. Alegem varianta cu UCRT    (Universal C Runtime) pentru c\u0103 este f\u0103cut\u0103 de la zero pentru Windows 10 \u0219i    11 \u0219i este g\u00e2ndit\u0103 s\u0103 aib\u0103 suport mai bun pentru standardul de C \u0219i C++.</p> </li> <li> <p>Dintre lista de op\u021biuni pe care o ai pentru UCRT runtime, ne intereseaz\u0103    ultima versiune (la data scrierii, versiunea este GCC 14.1.0).</p> </li> <li> <p>Selecteaz\u0103 din prima op\u021biune (cea care scrie POSIX threads) fie Win64 (dac\u0103    ai un sistem pe 64 de bi\u021bi, care este cam orice calculator lansat \u00een ultimul    deceniu \u0219i jum\u0103tate), fie Win32, \u00een formatul t\u0103u de preferin\u021b\u0103 (7-Zip are    nevoie de programul cu acela\u0219i nume, dar are executabile mai mici, \u00een timp ce    Zip poate fi deschis din Explorer). La data scrierii, asta este arhiva    potrivit\u0103:</p> <p>Descarc\u0103 GCC 14.1.0 </p> <p> </p> </li> <li> <p>Dup\u0103 ce s-a terminat de desc\u0103rcat arhiva, deschide-o \u0219i extrage directorul     <code>mingw64</code> \u00eentr-un loc u\u0219or accesibil (de preferin\u021b\u0103 \u00een <code>C:\\</code>). \u021aine minte     aceast\u0103 loca\u021bie! O s\u0103 m\u0103 refer la aceast\u0103 loca\u021bie \u00een text ca <code>$MINGW</code> (de pild\u0103,     dac\u0103 ai dezarhivat \u00een <code>C:\\</code>, atunci <code>$MINGW = C:\\mingw64</code>). O s\u0103 ia ceva timp s\u0103     se dezarhiveze tot, deoarece are peste 1GB. Indiferent unde s-a dezarhivat,     con\u021binutul directorului <code>$MINGW</code> ar trebui s\u0103 arate astfel:</p> <p></p> <p></p> </li> <li> <p>Acum avem un compilator de C++ \u00een sistem. Pentru a-l face disponibil global,     trebuie s\u0103 ad\u0103ug\u0103m \u00een calea sistemului ca s\u0103 poat\u0103 recunoa\u0219te executabilele.     Pentru acest lucru:</p> <ol> <li>Apas\u0103 Win+R \u0219i scrie <code>sysdm.cpl</code> \u0219i apas\u0103 OK. Dac\u0103 totul a fost cu    succes, o s\u0103 vezi o fereastr\u0103 de genul:     </li> <li>Navigheaz\u0103 c\u0103tre tab-ul Complex \u0219i apas\u0103 pe ultimul buton (Environment    variables sau Variabile de mediu):     </li> <li>Apas\u0103 dublu clic pe variabila <code>Path</code> de la sec\u021biunea cu variabile de    utilizator (partea de sus).     </li> <li> <p>Apas\u0103 pe \"Navigare...\" (aten\u021bie, f\u0103r\u0103 s\u0103 ai vreo cale selectat\u0103 deja,    apas\u0103 oriunde \u00eentr-un spa\u021biu gol din list\u0103) \u0219i caut\u0103 calea <code>$MINGW\\bin</code>    (unde <code>$MINGW</code> e locul unde ai instalat MinGW). \u00cen cazul meu, calea va fi    <code>C:\\mingw64\\bin</code>. Dac\u0103 totul a decurs cum trebuie, ar trebui s\u0103 fie o    cale \u00een plus \u00een list\u0103:     </p> </li> <li> <p>Apas\u0103 OK p\u00e2n\u0103 c\u00e2nd se \u00eenchid toate ferestrele.</p> </li> </ol> </li> <li> <p>Pentru a face sistemul s\u0103 recunoasc\u0103 noile noastre executabile,     deconecteaz\u0103-te \u0219i conecteaz\u0103-te \u00eenapoi la utilizatorul curent. Felicit\u0103ri!</p> </li> </ol> <p>Acum navigheaz\u0103 aici pentru a vedea ce editoare ai la dispozi\u021bie:</p> <p>Vezi op\u021biuni de editoare </p>"},{"location":"cppintro/editors/linux/editoare-text/","title":"Op\u021biuni de editoare text (Linux)","text":"<p>La capitolul editoare de text, exist\u0103 multe op\u021biuni. Totu\u0219i, dorim urm\u0103toarele calit\u0103\u021bi de la un editor de text pentru C++:</p> <ul> <li>Syntax highlighting (eviden\u021bierea sintaxei), pentru a putea distinge u\u0219or   cuvintele cheie \u0219i a putea citi codul mai u\u0219or;</li> <li>Completare automat\u0103 (\u0219i sugestii) pentru a putea completa rapid \u0219i   eficient codul;</li> <li>Indentare automat\u0103 (\u0219i formatare), pentru a p\u0103stra un stil   consistent;</li> <li>Func\u021bii de c\u0103utare \u0219i \u00eenlocuire;</li> <li>Num\u0103rarea liniilor \u0219i coloanelor;</li> <li>Suport pentru extensii;</li> <li>S\u0103 fie u\u0219or de folosit \u0219i s\u0103 consume pu\u021bine resurse.</li> </ul> <p>Urm\u0103toarele editoare \u00eendeplinesc criteriile de mai sus:</p> <ul> <li> <p>Visual Studio Code</p> <p>Visual Studio Code este un editor de cod gratuit \u0219i open-source, dezvoltat de Microsoft. Este extrem de popular datorit\u0103 integr\u0103rii sale cu multe instrumente de dezvoltare \u0219i suportului pentru extensii, oferind o experien\u021b\u0103 de codare puternic\u0103 \u0219i flexibil\u0103.</p> <p> Instalare \u0219i configurare</p> </li> <li> <p>Sublime Text 4</p> <p>Sublime Text 4 este un editor de text rapid \u0219i versatil, cunoscut pentru interfa\u021ba sa curat\u0103 \u0219i performan\u021ba excelent\u0103. Este ideal pentru dezvoltatori datorit\u0103 func\u021biilor avansate precum eviden\u021bierea sintaxei \u0219i completarea automat\u0103, al\u0103turi de un sistem robust de plugin-uri.</p> <p> Instalare \u0219i configurare</p> </li> <li> <p>Kate</p> <p>Kate este un editor de text puternic, parte a KDE. Este extensibil prin plugin-uri \u0219i suport\u0103 o gam\u0103 larg\u0103 de limbaje de programare, incluz\u00e2nd C++. Este rapid \u0219i u\u0219or de utilizat, fiind o alegere popular\u0103 pentru utilizatorii de Linux care folosesc KDE \u0219i nu numai.</p> <p> Instalare \u0219i configurare</p> </li> <li> <p>Geany</p> <p>Geany este un editor de text u\u0219or \u0219i puternic, care ofer\u0103 un echilibru excelent \u00eentre func\u021bionalitate \u0219i performan\u021b\u0103. Este proiectat s\u0103 fie rapid \u0219i s\u0103 consume pu\u021bine resurse, fiind ideal pentru dezvoltarea de aplica\u021bii C++. Geany ofer\u0103 suport pentru eviden\u021bierea sintaxei, completarea automat\u0103 \u0219i un terminal integrat. Este foarte potrivit pentru dezvoltatorii care doresc un editor simplu, dar capabil, care poate fi folosit f\u0103r\u0103 a instala multe extensii.</p> <p> Instalare \u0219i configurare</p> </li> </ul> <p>Not\u0103</p> <p>\u00cen afar\u0103 de aceste editoare, mai exist\u0103 \u0219i altele, precum eternele Vim/Neovim \u0219i Emacs. De\u0219i autorul folose\u0219te ambele editoare (Emacs \u00eendeosebi), procesul de a le configura este mai anevoios \u0219i sunt \u00een afara scopului acestui articol introductiv.</p>"},{"location":"cppintro/editors/linux/ide/","title":"Op\u021biuni de IDE-uri (Linux)","text":"<p>La capitolul IDE-uri, nu avem a\u0219a de multe op\u021biuni, pentru c\u0103 un IDE este fundamental mai complex. Totu\u0219i, cele mai bune op\u021biuni sunt:</p> <ul> <li> <p>Code::Blocks</p> <p>Code::Blocks este un IDE gratuit \u0219i open-source, dedicat dezvolt\u0103rii de aplica\u021bii \u00een limbajul C \u0219i C++. Este cunoscut pentru flexibilitatea sa, fiind extensibil prin plugin-uri \u0219i suport\u00e2nd diverse compilatoare. Interfa\u021ba sa prietenoas\u0103 \u0219i u\u0219urin\u021ba de utilizare \u00eel fac o alegere popular\u0103 printre programatorii C/C++. \u00cen plus, acesta este editorul implicit pentru olimpiad\u0103. Ruleaz\u0103 pe Windows, macOS, Linux, FreeBSD \u0219i OpenBSD.</p> <p> Instalare \u0219i configurare</p> </li> <li> <p>Qt Creator</p> <p>Qt Creator este un IDE cross-platform dezvoltat de Qt Company, perfect pentru dezvoltarea \u00een C++. Acesta ofer\u0103 integrare complet\u0103 cu Qt Framework, un designer vizual pentru interfe\u021be grafice \u0219i suport pentru sistemele de build CMake \u0219i QMake. Qt Creator vine cu instrumente avansate de navigare \u0219i refactorizare a codului, un debugger integrat \u0219i instrumente de profilare pentru identificarea \u0219i rezolvarea problemelor de performan\u021b\u0103. De asemenea, este foarte flexibil \u0219i poate fi extins prin plugin-uri, f\u0103c\u00e2ndu-l potrivit pentru diverse nevoi ale dezvoltatorilor. Ruleaz\u0103 pe Windows, macOS, Linux, FreeBSD, OpenBSD \u0219i NetBSD.</p> <p> Instalare \u0219i configurare</p> </li> <li> <p>CLion</p> <p>CLion este un IDE dezvoltat de JetBrains, specializat \u00een dezvoltarea de aplica\u021bii \u00een C \u0219i C++. Acesta ofer\u0103 o gam\u0103 larg\u0103 de func\u021bionalit\u0103\u021bi avansate, cum ar fi refactorizarea codului, navigarea inteligent\u0103 \u0219i suportul pentru CMake. CLion include un debugger integrat \u0219i instrumente de analiz\u0103 a codului care ajut\u0103 la men\u021binerea unui cod curat \u0219i eficient. Este apreciat pentru productivitatea pe care o ofer\u0103 dezvoltatorilor, datorit\u0103 instrumentelor sale avansate \u0219i integr\u0103rii cu diverse sisteme de control al versiunilor. Ruleaz\u0103 pe Windows, macOS \u0219i Linux.</p> <p> Instalare \u0219i configurare</p> </li> </ul> <p>Aten\u021bie</p> <p>CLion, spre deosebire de celelalte op\u021biuni, nu este gratis. Totu\u0219i, dac\u0103 e\u0219ti eligibil, po\u021bi avea un cont de student ceea ce \u00ee\u021bi ofer\u0103 acces la CLion, precum \u0219i la alte produse marca JetBrains.</p>"},{"location":"cppintro/editors/linux/optiuni-editoare/","title":"Op\u021biuni de editoare (Linux)","text":"<p>Exist\u0103 dou\u0103 tipuri de editoare folosite pentru a scrie cod (nu doar \u00een C++):</p> <ul> <li> <p> Editoare de text</p> <p>Un editor de text este un program simplu folosit pentru scrierea \u0219i editarea codului surs\u0103 C++. Exemple de astfel de editoare includ Vim, Emacs, Geany, Kate, Sublime Text, \u0219i Visual Studio Code, printre altele. Acestea sunt ideale pentru editarea de fi\u0219iere de cod C++ simple, oferind func\u021bionalit\u0103\u021bi de baz\u0103 precum eviden\u021bierea sintaxei \u0219i completarea automat\u0103.</p> <p>Editoarele de text consum\u0103 mai pu\u021bin\u0103 memorie dec\u00e2t un IDE, \u00eens\u0103 trebuie s\u0103 fie configurate pentru a putea suporta C++ la un nivel satisf\u0103c\u0103tor.</p> <p> Vezi op\u021biuni</p> </li> <li> <p> IDE</p> <p>Un mediu de dezvoltare integrat (IDE) pentru C++ este un software complex care ofer\u0103 dezvoltatorilor un set complet de instrumente pentru scrierea, compilarea, testarea \u0219i depanarea codului C++. Exemple de IDE-uri pentru C++ includ CLion, Qt Creator \u0219i Code::Blocks. Acestea includ func\u021bionalit\u0103\u021bi avansate precum depanare interactiv\u0103, integrare cu sisteme de control al versiunilor, instrumente de profilare \u0219i optimizare a codului, \u0219i multe alte instrumente care faciliteaz\u0103 dezvoltarea de aplica\u021bii complexe \u00een C++. Fiind programe mai complexe, ele consum\u0103 mai mult\u0103 memorie \u0219i mai mult spa\u021biu, \u00eens\u0103 ofer\u0103 toate uneltele necesare.</p> <p> Vezi op\u021biuni</p> </li> </ul>"},{"location":"cppintro/editors/windows/clion/","title":"CLion (Windows)","text":"<p>TODO</p>"},{"location":"cppintro/editors/windows/codeblocks/","title":"Code::Blocks (Windows)","text":""},{"location":"cppintro/editors/windows/codeblocks/#instalare","title":"Instalare","text":"<p>Pentru a instala Code::Blocks:</p> <ol> <li> <p>Mergi pe site-ul oficial, la sec\u021biunea Downloads \u0219i apoi apas\u0103 \"Download the     binary release\".</p> <p>Link direct </p> </li> <li> <p>Alege <code>codeblocks-20.03-setup.exe</code>. Ambele mirror-uri sunt bune, \u00eens\u0103     recomand Sourceforge. Dac\u0103 vrei s\u0103 ai o instalare portabil\u0103, alege     <code>codeblocks-20.03-nosetup.zip</code>.</p> <p>Descarc\u0103 Code::Blocks 20.03 </p> <p>Aten\u021bie</p> <p>Nu alege variantele cu MinGW. Acele installere vin cu o versiune \u00eenvechit\u0103 de MinGW (vin cu GCC 8.1, mai precis). Pentru cea mai bun\u0103 experien\u021b\u0103, avem nevoie de cel mai nou compilator. Vezi instruc\u021biuni aici  pentru cum po\u021bi instala ultima versiune de GCC.</p> </li> <li> <p>Dup\u0103 ce s-a desc\u0103rcat, ruleaz\u0103 installerul (care ar trebui s\u0103 fie numit     <code>codeblocks-20.03-setup.exe</code>). Procesul nu dureaz\u0103 mult, de cele mai multe     ori este un minut. Set\u0103rile implicite sunt bune, a\u0219a c\u0103 po\u021bi ap\u0103sa Next p\u00e2n\u0103     c\u00e2nd s-a terminat de instalat.</p> </li> </ol>"},{"location":"cppintro/editors/windows/codeblocks/#configurare-si-utilizare","title":"Configurare \u0219i utilizare","text":"<p>De fiecare dat\u0103 c\u00e2nd vei deschide Code::Blocks, vei vedea asta:</p> <p>Selecteaz\u0103 GNU GCC Compiler (care ar trebui s\u0103 fie implicit), apas\u0103 pe Set as default \u0219i apoi apas\u0103 OK.</p> <p>Prima dat\u0103 c\u00e2nd deschizi acest editor, aceast\u0103 fereastr\u0103 va ap\u0103rea:</p> <p>Selecteaz\u0103 \"Yes, associate Code::Blocks with C/C++ file types\", care \u00eenseamn\u0103 faptul c\u0103 fiecare fi\u0219ier C++ se va deschide \u00een Code::Blocks. Apoi apas\u0103 OK.</p> <p>E\u0219ti \u00eent\u00e2mpinat de aceast\u0103 fereastr\u0103 alb\u0103 orbitoare:</p> <p>Pa\u0219ii pentru a crea un proiect sunt:</p> <ol> <li>Fie te po\u021bi duce \u00een bara de meniu \u0219i s\u0103 alegi File &gt; New &gt; Project, fie po\u021bi     din Start here (prima fereastr\u0103 care apare) \u0219i apoi apas\u0103 Create a new     project.</li> <li>Indiferent de metoda aleas\u0103, ajungi la aceast\u0103 fereastr\u0103:           Alege prin dublu clic Console application (engl. Aplica\u021bie \u00een consol\u0103).</li> <li>\u00cen acest stadiu, vei fi \u00eent\u00e2mpinat de \"wizard\". Acesta te va ghida \u00een     crearea unei aplica\u021bii noi. A\u0219a arat\u0103:           Apas\u0103 Next.</li> <li>De aici, alege C++ (este o introducere de C++, la urma urmei) \u0219i apas\u0103 Next.      </li> <li> <p>Aici este pasul unde alegi titlul proiectului, precum \u0219i folderul     proiectului.      </p> <p>Sfat</p> <p>F\u0103 numele proiectului sugestiv, chiar numele problemei la care lucrezi acum, pentru c\u0103 nu este prea dr\u0103gu\u021b s\u0103 umpli printr-o mare de proiecte care au nume similare cu \"fsdjkfdkjdfsjhsdaf\".</p> <p>De asemenea, recomand s\u0103 grupezi toate proiectele \u00eentr-un folder special. Este mult mai u\u0219or s\u0103 g\u0103se\u0219ti un proiect dac\u0103 se afl\u0103 \u00eentr-un singur loc. Numele sugestive ajut\u0103 \u0219i ele aici.</p> <p>\u00cen cazul meu, eu am completat astfel:  </p> </li> <li> <p>Aici este pasul unde alegem compilatorul. Dac\u0103 ai instalat GCC \u0219i \u00eel recunoa\u0219te corespunz\u0103tor, atunci prima op\u021biune va fi GNU GCC Compiler. Las\u0103 tot bifat a\u0219a cum e implicit \u0219i apas\u0103 Next \u0219i apoi Finish la urm\u0103torul ecran.</p> </li> </ol> <p>Dac\u0103 ai f\u0103cut totul corect, fereastra ta ar trebui s\u0103 arate astfel:</p> <p>Pentru a vedea dac\u0103 totul merge, apas\u0103 pe <code>main.cpp</code> din bara lateral\u0103. Ar trebui s\u0103 vezi urm\u0103torul cod \u00een editor:</p> <pre><code>#include &lt;iostream&gt;\n\nusing namespace std;\n\nint main()\n{\n    cout &lt;&lt; \"Hello world!\" &lt;&lt; endl;\n    return 0;\n}\n</code></pre> <p>Apas\u0103 pe F9 (sau Build &gt; Build and Run din bara de meniu). Acest pas va compila \u0219i rula programul t\u0103u, \u0219i este o tast\u0103 foarte folosit\u0103 de c\u0103tre tine \u00een viitor. Dac\u0103 ai un compilator func\u021bional \u0219i nu ai erori, o s\u0103 vezi urm\u0103toarea fereastr\u0103:</p> <p>Felicit\u0103ri! Compilatorul GCC func\u021bioneaz\u0103 \u0219i ai rulat primul t\u0103u program de C++.</p> <p>Acum a venit timpul s\u0103 configur\u0103m Code::Blocks. \u00cen primul r\u00e2nd, vrem s\u0103 facem experien\u021ba de editat mai bun\u0103. Pentru acest lucru, mergem la Settings &gt; Editor din bara de mediu.</p> <ol> <li> <p>Courier New nu este un font prea legibil, a\u0219a c\u0103 recomand s\u0103 \u00eel schimbi,    ap\u0103s\u00e2nd pe butonul Choose, \u00een Cascadia Mono, Cascadia Code (adaug\u0103 ligaturi,    dar \u00een rest este identic cu Cascadia Mono) sau Consolas. Po\u021bi seta de    asemenea \u0219i m\u0103rimea implicit\u0103 (10 este mult prea pu\u021bin, chiar \u0219i dac\u0103 ai pe    un monitor mare, ar trebui 12 minim).</p> </li> <li> <p>\u00cen acela\u0219i loc, la Indent Options bifeaz\u0103 Show indentation guides. Setarea    aceasta face ca fiecare nivel de indentare s\u0103 fie marcat cu o linie gri    vertical\u0103, deci este mai u\u0219or s\u0103 vezi unde \u00eencepe \u0219i se termin\u0103 o acolad\u0103.</p> </li> <li> <p>Bifeaz\u0103 \u0219i \"Ensure consistent EOLs\", ca s\u0103 nu se amestece sf\u00e2r\u0219iturile de    linii.</p> </li> </ol> <p>\u00cen total, a\u0219a ar trebui s\u0103 arate momentan pagina:      </p> <p>Acum ne mut\u0103m pe tab-ul cu Other editor settings. Aici vom configura urm\u0103toarele chestii:</p> <ol> <li>Bifeaz\u0103 Word Wrap. Aceast\u0103 func\u021bie \u00eencadreaz\u0103 textul automat \u00een caz c\u0103 este    prea lung.</li> <li>Este op\u021bional, \u00eens\u0103 po\u021bi bifa Highlight line under caret, care eviden\u021biaz\u0103    linia pe care e\u0219ti \u00een momentul de fa\u021b\u0103.</li> <li>Acest lucru este preferin\u021b\u0103 personal\u0103, \u00eens\u0103 po\u021bi face fontul s\u0103 se randeze    mai bine pe ecran. La Technology alege DirectWrite, \u0219i la Font quality alege    LCD optimized (m\u0103 \u00eendoiesc c\u0103 ai un monitor cu tub ca pe vremuri).</li> </ol> <p>Acum mergem la Margins and caret, unde vom face dou\u0103 schimb\u0103ri:</p> <ol> <li>Activ\u0103m Dynamic setting, deoarece bara care arat\u0103 num\u0103rul de linie este mult    prea groas\u0103.</li> <li>La Right margin hint, selecteaz\u0103 Visible line. La a 80-a coloan\u0103, arat\u0103 o    linie vertical\u0103. Dac\u0103 nu treci de acea linie, atunci codul t\u0103u va fi mai u\u0219or    de citit, pentru c\u0103 nu vei avea linii kilometrice.</li> </ol> <p>Un aspect foarte disputat la Code::Blocks este tema sa implicit\u0103, cu albul orbitor. Din p\u0103cate, Code::Blocks nu vine cu o tem\u0103 \u00eentunecat\u0103, mai prietenoas\u0103 cu ochii noaptea (de fapt, nu vine cu alte teme \u00een afar\u0103 de cea standard). Din motive tehnice care nu sunt \u00een controlul proiectului Code::Blocks, nu o s\u0103 avem vreodat\u0103 interfa\u021ba cu tem\u0103 \u00eentunecat\u0103 (pe alte platforme \u00eens\u0103 se poate), dar putem schimba tema editorului. Pentru a rezolva aceast\u0103 problem\u0103:</p> <ol> <li>Mergi la     aceast\u0103 pagin\u0103 arhivat\u0103.     Acolo o s\u0103 vezi mai multe teme.</li> <li> <p>Descarc\u0103 urm\u0103torul fi\u0219ier de configurare (care este exact cel de pe site,     \u00eens\u0103 prezervat pentru convenien\u021ba cititorului):</p> <p>colour_themes.conf </p> </li> <li> <p>\u00cenchide Code::Blocks. Acest pas este critic, deci asigur\u0103-te c\u0103 nu ai     vreo fereastr\u0103 ascuns\u0103.</p> </li> <li>Caut\u0103 loca\u021bia unde este instalat Code::Blocks \u0219i deschide folderul     corespunz\u0103tor. Ar trebui s\u0103 fie \u00een <code>C:\\Program Files\\CodeBlocks</code>.</li> <li>Ai un executabil numit <code>cb_share_config.exe</code>. Ruleaz\u0103-l.</li> <li>\u00cen st\u00e2nga (la surs\u0103), selecteaz\u0103 fi\u0219ierul <code>colour_themes.conf</code> pe care l-ai     desc\u0103rcat mai \u00eenainte. \u00cen dreapta, alege fi\u0219ierul implicit. Acesta se afl\u0103 la     <code>C:\\Users\\{nume utilizator}\\AppData\\Roaming\\CodeBlocks\\default.conf</code>.</li> <li>\u00cen partea st\u00e2ng\u0103, bifeaz\u0103 tot din list\u0103. Asigur\u0103-te c\u0103 fereastra ta arat\u0103     a\u0219a:      </li> <li>Apas\u0103 Transfer \u0219i r\u0103spunde cu Yes c\u00e2nd \u021bi se cere.</li> <li>Apas\u0103 pe Save.</li> <li>\u00cenchide programul \u0219i deschide Code::Blocks \u00eenapoi.</li> <li>Alege o tem\u0103 din Settings &gt; Editor &gt; Syntax highlighting. Eu personal     folosesc Son of Obsidian, dar asta r\u0103m\u00e2ne la latitudinea ta.</li> </ol> <p>Dup\u0103 to\u021bi ace\u0219ti pa\u0219i, a\u0219a arat\u0103 editorul cu tema Son of Obsidian:</p> <p>Este mai pu\u021bin alb, chiar dac\u0103 nu este tem\u0103 \u00eentunecat\u0103 peste tot.</p> <p>Legat de scurt\u0103turi, putem vedea scurt\u0103turile curente pentru tot editorul, dac\u0103 mergem la Settings &gt; Editor &gt; Keyboard Shortcuts. Unele din scurt\u0103turile pe care le vei folosi mai mult sau mai pu\u021bin sunt:</p> <ul> <li>La loc de cinste se afl\u0103 F9, de care am mai zis, care compileaz\u0103 \u0219i   ruleaz\u0103 codul t\u0103u.</li> <li>Pentru a crea un fi\u0219ier gol, apas\u0103 Ctrl+Shift+N (File &gt; New &gt; Empty   file);</li> <li>Ctrl+O pentru a deschide un fi\u0219ier;</li> <li>Ctrl+S pentru a salva fi\u0219ierul curent, \u0219i Ctrl+Shift+S pentru a salva   tot;</li> <li>Ctrl+W pentru a \u00eenchide fi\u0219ierul curent \u0219i Ctrl+Shift+W pentru a   \u00eenchide toate fi\u0219ierele;</li> <li>Clasicele Ctrl+Z pentru a reversa o schimbare \u0219i Ctrl+Shift+Z pentru a   face invers, precum \u0219i Ctrl+C \u0219i Ctrl+V care nu au nevoie de   introducere;</li> <li>Ctrl \u0219i roti\u021ba de la mouse m\u0103resc sau mic\u0219oreaz\u0103 fontul, \u00een func\u021bie de   mi\u0219care;</li> <li>Shift+Enter ca s\u0103 inserezi o linie nou\u0103 sub linia curent\u0103 (ceea ce este   diferit de a ap\u0103sa Enter) \u0219i Ctrl+Enter pentru a te duce la cap\u0103tul   unei linii;</li> <li>Ctrl+Shift+C pentru a comenta \u0219i Ctrl+Shift+X pentru a decomenta;</li> <li>Ctrl+Space pentru a completa codul (ceva ce folosesc tot timpul);</li> <li>Alt+N pentru a redenumi simboluri (nu subestima aceast\u0103 scurt\u0103tur\u0103, c\u0103ci   va fi extrem de util\u0103 dac\u0103 vrei s\u0103 redenume\u0219ti o variabil\u0103 sau o func\u021bie);</li> <li>Dac\u0103 ai selectat un text, Ctrl+E selecteaz\u0103 urm\u0103toarea apari\u021bie a   selec\u021biei;</li> <li>F2 pentru a ascunde log-urile (ce se afl\u0103 \u00een partea de jos) \u0219i   Shift+F2 pentru a ascunde managerul (bara lateral\u0103). Po\u021bi ap\u0103sa acelea\u0219i   scurt\u0103turi pentru a le aduce \u00eenapoi. Dac\u0103 nu \u0219tii unde s-a dus managerul,   apas\u0103 Shift+F2;</li> <li>Shift+F11 dac\u0103 vrei s\u0103 m\u0103re\u0219ti pe tot ecranul \u0219i s\u0103 reduci distragerile;</li> <li>Uneori, \u00eenchizi un tab din gre\u0219eal\u0103. Nicio problem\u0103, apas\u0103 Ctrl+Shift+T \u0219i   revine ca prin magie la via\u021b\u0103;</li> <li>Ctrl+Tab pentru a te plimba prin tab-uri;</li> <li>Ctrl+F (\u0219i Ctrl+Shift+F) pentru a c\u0103uta textul \u00een fi\u0219ierul curent,   respectiv \u00een toate fi\u0219ierele;</li> <li>Ctrl+R (\u0219i Ctrl+Shift+R) pentru a \u00eenlocui textul \u00een fi\u0219ierul curent,   respectiv \u00een toate fi\u0219ierele.</li> </ul> <p>Totu\u0219i, exist\u0103 c\u00e2teva scurt\u0103turi pe care le vom seta noi:</p> <ul> <li>\u00cen Settings &gt; Editor &gt; Keyboard shortcuts, mergem la Edit, apoi la Toggle   comment \u0219i ad\u0103ug\u0103m scurt\u0103tura Ctrl+/. Practic ne scute\u0219te din a \u021bine   minte Ctrl+Shift+C \u0219i Ctrl+Shift+X;</li> <li>Tot aici, mergem la Plugins &gt; Source code formatter (AStyle) \u0219i punem   scurt\u0103tura Shift+Alt+F5 (sau ceva care \u00ee\u021bi este convenabil, dar care nu   mai este folosit de altceva).</li> </ul> <p>Aten\u021bie</p> <p>Dac\u0103 exist\u0103 dou\u0103 scurt\u0103turi pe care vreau s\u0103 le \u021bii minte, \u00een afar\u0103 de chestiile tipice pentru salvat, deschis fi\u0219iere etc., acestea sunt:</p> <ul> <li>F9 pentru a compila \u0219i rula codul;</li> <li>Shift+Alt+F5 (sau ce \u021bi-ai setat) pentru a formata codul. Chiar insist   pe aceast\u0103 scurt\u0103tur\u0103, \u0219i ar trebui s\u0103 o rulezi la fiecare schimbare.   \u00cen majoritatea timpului tu vei ajunge s\u0103 cite\u0219ti codul t\u0103u sau codul altora,   deci este esen\u021bial s\u0103 ai un stil consistent \u0219i u\u0219or de citit. Nimeni nu st\u0103   s\u0103 ajusteze acolade, deci po\u021bi l\u0103sa Code::Blocks s\u0103 \u00ee\u0219i fac\u0103 treaba. Nu pot   sublinia destul importan\u021ba acestui lucru.</li> </ul>"},{"location":"cppintro/editors/windows/codeblocks/#formatare","title":"Formatare","text":"<p>Ce urmeaz\u0103 aici este strict p\u0103rere personal\u0103, \u00eens\u0103 consider c\u0103 ofer\u0103 un stil lizibil. Voi explica ra\u021bionamentul pentru fiecare alegere. Mergem la Settings &gt; Editor &gt; Source formatter.</p> <p>La tab-ul Style, alegem 1TBS (One True Brace Style). Acest stil arat\u0103 astfel:</p> <pre><code>int Foo(bool isBar)\n{\n    if (isFoo) {\n        bar();\n        return 1;\n    } else {\n        return 0;\n    }\n}\n</code></pre> <p>Ca s\u0103 nu zic prea multe (deoarece se intersecteaz\u0103 cu lec\u021bia viitoare), motivul pentru care aleg 1TBS este s\u0103 evit\u0103m urm\u0103toarea situa\u021bie:</p> <pre><code>if (isFoo)\n  bar();\n  return 1;\n</code></pre> <p>Acel <code>return 1;</code> nu este asociat cu linia de dinaintea ei sau cu <code>if</code>, deci este un dezastru care o s\u0103 se \u00eent\u00e2mple la un moment dat. Prin ad\u0103ugarea acoladelor, suntem explici\u021bi, \u0219i este mai u\u0219or de extins codul.</p> <p>Pentru consisten\u021b\u0103 la acolade cu stilul nostru (1TBS), select\u0103m toate op\u021biunile de la Brackets.</p> <p>La Indentation, nu avem de schimbat multe. Set\u0103m Indentation size la 4 (nu recomand un num\u0103r sub 4, \u00een mod special 2, \u0219i nici 8). Activ\u0103m doar Indent C++ comments beginning in column one. Este util pentru a alinia comentariile care se afl\u0103 \u00een prima coloan\u0103.</p> <pre><code>void Foo()\n{\n// comentariu\n    if (isFoo)\n        bar();\n}\n</code></pre> <p>devine</p> <pre><code>void Foo()\n{\n    // comentariu\n    if (isFoo) {\n        bar();\n    }\n}\n</code></pre> <p>La Formatting schimb\u0103m urm\u0103toarele set\u0103ri:</p> <ol> <li> <p>Select\u0103m \"Break one-line headers\". Un \"header\" \u00een acest context este orice     instruc\u021biune (<code>if</code>, <code>while</code>, <code>else</code> etc.). Cu aceast\u0103 op\u021biune, \u0219i cele pe     care le-am setat mai \u00eenainte, transform\u0103m:</p> <pre><code>void Foo(bool isFoo)\n{\n    if (isFoo1) bar1();\n\n    if (isFoo2) { bar2(); }\n}\n</code></pre> <p>\u00een</p> <pre><code>void Foo(bool isFoo)\n{\n    if (isFoo1) {\n        bar1();\n    }\n\n    if (isFoo2) {\n        bar2();\n    }\n}\n</code></pre> <p>Acoladele fac inten\u021bia noastr\u0103 mai clar\u0103 \u0219i ne permit s\u0103 ad\u0103ug\u0103m mai multe instruc\u021biuni \u00een viitor f\u0103r\u0103 mult efort. \u00cen plus, este mai uniform.</p> </li> <li> <p>Select\u0103m \"Closes whitespace in the angle brackets of template definitions\".     Pe vremuri, din cauza unui defect \u00een standard \u0219i \u00een compilatoare, nu puteai     scrie asta:</p> <pre><code>Stack&lt;int, List&lt;int&gt;&gt; stack1;\n</code></pre> <p>\u0219i trebuia \u00een schimb:</p> <pre><code>Stack&lt; int, List&lt;int&gt; &gt; stack1;\n</code></pre> <p>Acum toate compilatoarele au evoluat, deci este sigur s\u0103 activezi op\u021biunea asta. 2. Activeaz\u0103 \"Enable line breaking\". Acest lucru garanteaz\u0103 faptul c\u0103 o linie va fi \u00eemp\u0103r\u021bit\u0103 dac\u0103 trece de o lungime anume. Eu setez valoarea la 80 de obicei, \u00eens\u0103 120 este acceptabil dac\u0103 ai mai mult spa\u021biu orizontal.</p> </li> </ol> <p>La Padding select\u0103m:</p> <ol> <li> <p>Pad empty lines around header blocks (e.g. 'if', 'while'...). Ce face     setarea pe scurt este c\u0103 \u00eenconjoar\u0103 cu o linie nou\u0103 \u00eenainte de \u0219i dup\u0103     fiecare header. Transform\u0103:</p> <pre><code>isFoo = true;\nif (isFoo) {\n    bar();\n} else {\n    anotherBar();\n}\nisBar = false;\n</code></pre> <p>\u00een</p> <pre><code>isFoo = true;\n\nif (isFoo) {\n    bar();\n} else {\n    anotherBar();\n}\n\nisBar = false;\n</code></pre> </li> <li> <p>Insert space padding around operators. A\u0219a cum zice \u0219i numele, pune spa\u021bii     \u00een jurul operatorilor. \u00cen loc de <code>1+1</code>, devine <code>1 + 1</code>.</p> </li> <li>Insert space padding between a header and the following paren. Dac\u0103 activ\u0103m     asta, \"dezlipim\" paranteza de <code>if</code>/<code>while</code>/...</li> <li>Remove extra space padding around parentheses. Combinat cu ultima setare,     avem un singur spa\u021biu. Ele transform\u0103:     <pre><code>if ( isFoo( ( a+2 ), b ) ) {\n    bar ( a, b );\n}\n</code></pre>     \u00een     <pre><code>if (isFoo((a + 2), b)) {\n    bar(a, b);\n}\n</code></pre>     Aceast\u0103 op\u021biune nu va \u0219terge spa\u021biile \u00een plus \u00een jurul operatorilor, din     p\u0103cate. Exist\u0103 op\u021biunea \u00een versiunile beta de Code::Blocks, \u00eens\u0103 nu sunt     stabile.</li> <li>Set\u0103m Pointer alignment \u0219i Reference alignment la Name. S-au purtat r\u0103zboaie     seculare pe aceast\u0103 tem\u0103, \u00eens\u0103 le prefer pe c\u00e2t posibil s\u0103 fie la fel,     indiferent de alinierea aleas\u0103.</li> </ol> <p>Acum c\u0103 am f\u0103cut aceste set\u0103ri, acest exemplu:</p> <pre><code>#include &lt;iostream&gt;\n#include &lt;cmath&gt;\nint main(){\n    int v[10];\n    for(int i=0;i&lt;10;++i) v[i]=i*sin(i);\n     for(int i=0;i&lt;10;++i) std::cout&lt;&lt;v[i]&lt;&lt;\" \"; std::cout&lt;&lt;\"\\n\";\n    bool sortat; do{\n        sortat=true;\n      for(int i=0;i&lt;9;++i){\n      if(v[i]&gt;v[i+1]){\n        int aux=v[i];\n        v[i]=v[i+1];\n        v[i+1]=aux;\n        sortat=false;\n      }}\n    } while(!sortat);\n    for(int i=0;i&lt;10;++i) std::cout&lt;&lt;v[i]&lt;&lt;\" \";  std::cout&lt;&lt;\"\\n\";\n    return 0;\n}\n</code></pre> <p>se va transforma \u00een:</p> <pre><code>#include &lt;iostream&gt;\n#include &lt;cmath&gt;\nint main()\n{\n    int v[10];\n\n    for (int i = 0; i &lt; 10; ++i) {\n        v[i] = i * sin(i);\n    }\n\n    for (int i = 0; i &lt; 10; ++i) {\n        std::cout &lt;&lt; v[i] &lt;&lt; \" \";\n    }\n\n    std::cout &lt;&lt; \"\\n\";\n    bool sortat;\n\n    do {\n        sortat = true;\n\n        for (int i = 0; i &lt; 9; ++i) {\n            if (v[i] &gt; v[i + 1]) {\n                int aux = v[i];\n                v[i] = v[i + 1];\n                v[i + 1] = aux;\n                sortat = false;\n            }\n        }\n    } while (!sortat);\n\n    for (int i = 0; i &lt; 10; ++i) {\n        std::cout &lt;&lt; v[i] &lt;&lt; \" \";\n    }\n\n    std::cout &lt;&lt; \"\\n\";\n    return 0;\n}\n</code></pre>"},{"location":"cppintro/editors/windows/codeblocks/#alte-configurari","title":"Alte configur\u0103ri","text":"<p>\u00cen primul r\u00e2nd, recomand s\u0103 activezi func\u021bia de Autosave. A\u0219a cum zice \u0219i numele, salveaz\u0103 automat proiectele la un interval anume, ca s\u0103 nu pierzi toat\u0103 munca depus\u0103 la o problem\u0103. Pentru a activa asta, du-te la Settings, apoi la Environment \u0219i la Autosave bifeaz\u0103 ambele c\u0103su\u021be. 1 minut este mai mult dec\u00e2t suficient.</p> <p>Pentru a ad\u0103uga op\u021biuni pentru compilator, mergem la Settings &gt; Compiler &gt; Other compiler options (deoarece Code::Blocks 20.03 din motive tehnice dubioase nu afi\u0219eaz\u0103 toate op\u021biunile pe care GCC le suport\u0103) \u0219i ad\u0103ug\u0103m urm\u0103toarele op\u021biuni:</p> <pre><code>-std=c++20 -Wall -Wextra -Wpedantic\n</code></pre> <p>Aceste op\u021biuni zic compilatorului s\u0103 suporte o versiune mai nou\u0103 de C++ \u0219i activ\u0103m majoritatea avertiz\u0103rilor, pentru a prinde poten\u021biale erori din timp.</p> <p>Asta este tot cu configurarea. Po\u021bi acum s\u0103 mergi c\u0103tre urm\u0103torul articol:</p> <p>Mergi la introducere</p>"},{"location":"cppintro/editors/windows/editoare-text/","title":"Op\u021biuni de editoare text (Windows)","text":"<p>La capitolul editoare de text, exist\u0103 multe op\u021biuni. Totu\u0219i, dorim urm\u0103toarele calit\u0103\u021bi de la un editor de text pentru C++:</p> <ul> <li>Syntax highlighting (eviden\u021bierea sintaxei), pentru a putea distinge u\u0219or   cuvintele cheie \u0219i a putea citi codul mai u\u0219or;</li> <li>Completare automat\u0103 (\u0219i sugestii) pentru a putea completa rapid \u0219i   eficient codul;</li> <li>Indentare automat\u0103 (\u0219i formatare), pentru a p\u0103stra un stil   consistent;</li> <li>Func\u021bii de c\u0103utare \u0219i \u00eenlocuire;</li> <li>Num\u0103rarea liniilor \u0219i coloanelor;</li> <li>Suport pentru extensii;</li> <li>S\u0103 fie u\u0219or de folosit \u0219i s\u0103 consume pu\u021bine resurse.</li> </ul> <p>Urm\u0103toarele editoare \u00eendeplinesc criteriile de mai sus:</p> <ul> <li> <p>Visual Studio Code</p> <p>Visual Studio Code este un editor de cod gratuit \u0219i open-source, dezvoltat de Microsoft. Este extrem de popular datorit\u0103 integr\u0103rii sale cu multe instrumente de dezvoltare \u0219i suportului pentru extensii, oferind o experien\u021b\u0103 de codare puternic\u0103 \u0219i flexibil\u0103.</p> <p> Instalare \u0219i configurare</p> </li> <li> <p>Sublime Text 4</p> <p>Sublime Text 4 este un editor de text rapid \u0219i versatil, cunoscut pentru interfa\u021ba sa curat\u0103 \u0219i performan\u021ba excelent\u0103. Este ideal pentru dezvoltatori datorit\u0103 func\u021biilor avansate precum eviden\u021bierea sintaxei \u0219i completarea automat\u0103, al\u0103turi de un sistem robust de plugin-uri.</p> <p> Instalare \u0219i configurare</p> </li> <li> <p>Notepad++</p> <p>Notepad++ este un editor de text gratuit \u0219i open-source, renumit pentru viteza \u0219i u\u0219urin\u021ba sa de utilizare. Ofer\u0103 eviden\u021bierea sintaxei pentru o gam\u0103 larg\u0103 de limbaje de programare \u0219i suport pentru plugin-uri, fiind o alegere excelent\u0103 pentru dezvoltatorii care au nevoie de un editor eficient \u0219i u\u0219or de folosit.</p> <p> Instalare \u0219i configurare</p> </li> </ul> <p>Not\u0103</p> <p>\u00cen afar\u0103 de aceste editoare, mai exist\u0103 \u0219i altele, precum Netbeans \u0219i eternele Vim/Neovim \u0219i Emacs. De\u0219i autorul le folose\u0219te pe ultimele dou\u0103 (Emacs \u00eendeosebi), procesul de a le configura este mai anevoios \u0219i nu sunt cele mai bune pe Windows \u0219i sunt \u00een afara scopului acestui articol introductiv. De asemenea, exist\u0103 Kate \u0219i Geany, ambele cu suport bun pentru C++ \u0219i alternative solide pentru Notepad++, pe care autorul le recomand\u0103.</p>"},{"location":"cppintro/editors/windows/ide/","title":"Op\u021biuni de IDE-uri (Windows)","text":"<p>La capitolul IDE-uri, nu avem a\u0219a de multe op\u021biuni, pentru c\u0103 un IDE este fundamental mai complex. Totu\u0219i, cele mai bune op\u021biuni sunt:</p> <ul> <li> <p>Code::Blocks</p> <p>Code::Blocks este un IDE gratuit \u0219i open-source, dedicat dezvolt\u0103rii de aplica\u021bii \u00een limbajul C \u0219i C++. Este cunoscut pentru flexibilitatea sa, fiind extensibil prin plugin-uri \u0219i suport\u00e2nd diverse compilatoare. Interfa\u021ba sa prietenoas\u0103 \u0219i u\u0219urin\u021ba de utilizare \u00eel fac o alegere popular\u0103 printre programatorii C/C++. \u00cen plus, acesta este editorul implicit pentru olimpiad\u0103. Ruleaz\u0103 pe Windows, macOS, Linux, FreeBSD \u0219i OpenBSD.</p> <p> Instalare \u0219i configurare</p> </li> <li> <p>Visual Studio</p> <p>Visual Studio este un mediu de dezvoltare integrat (IDE) puternic \u0219i extensibil, dezvoltat de Microsoft. Acesta suport\u0103 o gam\u0103 larg\u0103 de limbaje de programare \u0219i tehnologii, fiind folosit pe scar\u0103 larg\u0103 pentru dezvoltarea aplica\u021biilor desktop, web \u0219i mobile. Printre caracteristicile sale se num\u0103r\u0103 un editor de cod avansat, debuger integrat, suport pentru controlul versiunilor \u0219i multe altele. Ruleaz\u0103 doar pe Windows.</p> <p> Instalare \u0219i configurare</p> </li> </ul>"},{"location":"cppintro/editors/windows/notepadpp/","title":"Notepad++","text":""},{"location":"cppintro/editors/windows/notepadpp/#instalare","title":"Instalare","text":"<p>Pentru a instala Notepad++:</p> <ol> <li> <p>Mergem pe site-ul oficial la sec\u021biunea de Downloads:</p> <p>Deschide pagina </p> <p>Alegem ultima versiune (la momentul scrierii, Notepad++ 8.6.9). Aici este link direct c\u0103tre installerul de 64 de bi\u021bi, pentru convenien\u021ba ta:</p> <p>Descarc\u0103 Notepad++ 8.6.9 </p> </li> <li> <p>Ruleaz\u0103 installerul. Procesul de instalare este simplu \u0219i set\u0103rile implicite    sunt de ajuns pentru toat\u0103 lumea, deci po\u021bi da Next \u00een continuare p\u00e2n\u0103 c\u00e2nd    se termin\u0103 procesul.</p> </li> </ol>"},{"location":"cppintro/editors/windows/notepadpp/#configurare","title":"Configurare","text":"<p>Acum vremea s\u0103-l configur\u0103m, pentru c\u0103 nu ne este prea utilizabil \u00een acest moment.</p> <ol> <li>Fontul implicit, Courier New... nu este prea bun. Pentru a schimba fontul,    mergem la Set\u0103ri \u0219i apoi la Configurator de stiluri. De acolo, putem modifica    orice legat de tema curent\u0103. Notepad++ are mai multe teme din care po\u021bi    alege, a\u0219a c\u0103 po\u021bi experimenta cu asta. Selecteaz\u0103 tema Default    (stylers.xml), \u0219i la stil font alege fontul Cascadia Mono sau Consolas (sau    alt font monospa\u021biat, dac\u0103 ai alte preferin\u021be). Po\u021bi cre\u0219te m\u0103rimea fontului    (eu \u021bin la 12, consider c\u0103 10 este o m\u0103rime prea mic\u0103). Dup\u0103 ce ai f\u0103cut    aceste lucruri, bifeaz\u0103 Activare global\u0103 font \u0219i Activare global\u0103 m\u0103rime    font. F\u0103 acela\u0219i set\u0103ri pentru tema DarkModeDefault (sau ce alt\u0103 tem\u0103 dore\u0219ti    s\u0103 ai).</li> <li>Acum vom vedea set\u0103rile din Set\u0103ri &gt; Preferin\u021be. Un prim lucru pe care \u00eel    putem face este s\u0103 avem ni\u0219te icoane mai moderne. Selecteaz\u0103 din Generale    op\u021biunea UI fluent umplut: mic (de\u0219i po\u021bi experimenta cu icoanele).</li> <li>Ca s\u0103 nu fim orbi\u021bi, mergi la Modul \u00eentunecat \u0219i alege fie Modul \u00eentunecat,    fie Urmarea ferestrelor, care ajusteaz\u0103 modul \u00een func\u021bie de set\u0103rile globale    din Windows. Po\u021bi s\u0103 personalizezi \u0219i culoarea temei, dar \"Negru\" arat\u0103 cel    mai bine, dup\u0103 p\u0103rerea mea.</li> <li>Implicit, Notepad++ indenteaz\u0103 folosind tab-uri. Pentru a schimba acest    comportament, mergem la Limbaje \u0219i alegem Indenteaz\u0103 folosind: Caracter(e)    spa\u021biu. Recomand indentare cu 4 spa\u021bii (setarea implicit\u0103), \u00eens\u0103 alte valori    comune includ 2, 3 \u0219i 8 (nu recomand ultima op\u021biune). At\u00e2ta timp c\u00e2t este o    valoare peste 1, este \u00een regul\u0103.</li> <li>Acum ajust\u0103m autocompletarea (rudimentar\u0103 \u00een Notepad++, dar exist\u0103 cel    pu\u021bin). Implicit ofer\u0103 sugestii pentru func\u021bii \u0219i cuvinte. Recomand s\u0103 bifezi    tot ce se afl\u0103 la autoinserare (fiecare grup de paranteze \u0219i ghilimele)    pentru c\u0103 \u00een marea majoritate a cazurilor le vei g\u0103si \u00een perechi \u0219i    economise\u0219te ceva timp.</li> </ol> <p>Dup\u0103 toate aceste schimb\u0103ri, editorul ar trebui s\u0103 arate astfel:</p> <p>\u00cen acest moment, Notepad++ este doar un editor simplu \u0219i nu este potrivit program\u0103rii \u00een C++, deci mai trebuie s\u0103 facem configur\u0103ri. Trebuie s\u0103 instal\u0103m ni\u0219te module \u00eenainte. Pentru asta, mergem la Module &gt; Administrare module. De acolo, select\u0103m urm\u0103toarele module:</p> <ul> <li>AutoSave, pentru a salva automat fi\u0219ierele;</li> <li>BracketsCheck, pentru a verifica dac\u0103 am balansat acoladele sau parantezele   (riscul ar trebui s\u0103 fie minimizat de autocompletarea parantezelor, dar nu se   \u0219tie);</li> <li>CodeAlignment, \u00een caz c\u0103 vrei s\u0103 aliniezi codul dup\u0103 semnele de egal   (op\u021bional, dar dr\u0103gu\u021b de avut);</li> <li>Comment Toggler \u0219i CommentWrap pentru comentarii, face lucrul cu acestea mai   u\u0219or;</li> <li>ComparePlus, folosit pentru a compara dou\u0103 fi\u0219iere (mai puternic dec\u00e2t s\u0103 tot   schimbi \u00eentre tab-uri pentru a vedea diferen\u021ba dintre dou\u0103 fi\u0219iere);</li> <li>Discord Rich Presence, dac\u0103 sim\u021bi nevoia s\u0103 te lauzi pe Discord c\u0103 ai   Notepad++ (nu \u0219tiu de ce ai face asta);</li> <li>MenuIcons, dac\u0103 vrei s\u0103 ai icoane \u0219i \u00een meniuri (op\u021bional, dar recomandat);</li> <li>Cel mai important modul, NppExec, care ne permite s\u0103 execut\u0103m script-uri   f\u0103r\u0103 s\u0103 p\u0103r\u0103sim Notepad++. Cu asta vom compila \u0219i executa C++;</li> <li>Pentru cei care doresc, exist\u0103 NppOpenAI, ca s\u0103-l conectezi la ChatGPT.</li> </ul> <p>Dup\u0103 ce ai selectat acele module, apas\u0103 butonul de Instalare (dac\u0103 totu\u0219i ie\u0219i accidental, selec\u021bia va r\u0103m\u00e2ne). Notepad++ se va \u00eenchide pentru a-\u0219i putea instala modulele. Acum pentru a configura fiecare modul. Fiecare setare se afl\u0103 \u00een Module, sub numele fiec\u0103rui modul.</p> <ol> <li>Pentru AutoSave, select\u0103m Notepad++ loses focus (\u00een caz c\u0103 dai Alt+Tab)    \u0219i At timed intervals every 10 minutes. Po\u021bi configura ultima op\u021biune s\u0103 fie    c\u00e2t de des vrei tu. Este la alegerea ta dac\u0103 vrei s\u0103 se autosalveze \u0219i c\u00e2nd    schimbi tab-ul (File tab changes) sau c\u00e2nd \u00eenchizi programul (Notepad++    exists).</li> <li>Pentru CodeAlignment, cea mai util\u0103 scurt\u0103tur\u0103 este Ctrl+Shift+=,    care te las\u0103 s\u0103 aliniezi selec\u021bia dup\u0103 ce vrei tu (de obicei o vei folosi    pentru egaluri sau virgule);</li> <li>Pentru Comment Toggler, po\u021bi folosi scurt\u0103tura Ctrl+Q pentru a comenta    sau decomenta selec\u021bia curent\u0103. Po\u021bi explora ce face Comment Wrap \u0219i chiar s\u0103    adaugi propriile tale scurt\u0103turi pentru fiecare func\u021bionalitate;</li> <li> <p>Cel mai complicat pas va fi la NppExec, pentru c\u0103 acesta va compila    propriu-zis codul nostru. Du-te la Module &gt; NppExec &gt; Execute NppExec Script    (alternativ, F6, scurt\u0103tur\u0103 pe care o vei folosi mult) \u0219i scrie    urm\u0103toarea comand\u0103 (voi explica fiecare pas imediat):</p> <pre><code>npp_save\ng++ -std=c++20 -O2 \"$(FULL_CURRENT_PATH)\" -o \"$(CURRENT_DIRECTORY)\\$(NAME_PART).exe\"\ncmd /c start cmd /c \"$(CURRENT_DIRECTORY)\\$(NAME_PART).exe &amp; pause\"\n</code></pre> <ol> <li>Prima linie salveaz\u0103 fi\u0219ierul curent;</li> <li>A doua linie folose\u0219te g++, pe care l-am instalat la sec\u021biunea cu GCC    (MinGW). Compileaz\u0103 folosind standardul C++20 \u0219i optimizat pentru    performan\u021b\u0103. Ia fi\u0219ierul curent (<code>calea/catre/nume.cpp</code>) \u0219i creeaz\u0103 un    executabil numit <code>nume.exe</code> \u00een directorul curent.</li> <li>A treia linie pur \u0219i simplu porne\u0219te un terminal extern, ca s\u0103 putem    interac\u021biona cu programul. Din p\u0103cate, Windows Defender scaneaz\u0103    executabilul nostru, deci va \u00eenghe\u021ba timp de c\u00e2teva secunde. Po\u021bi ad\u0103uga    o excep\u021bie din Windows Defender (ca s\u0103 nu faci 100 de directoare pentru    fiecare proiect, adaug\u0103 tot \u00eentr-un director \u0219i adaug\u0103-l pe \u0103la ca    excep\u021bie).</li> </ol> <p>Acum tot ce trebuie s\u0103 faci este s\u0103 ape\u0219i Save \u0219i d\u0103-i numele C++. Dup\u0103 aceea, po\u021bi s\u0103 ape\u0219i secven\u021ba F6+Enter ca s\u0103 compilezi \u0219i rulezi codul.</p> </li> </ol> <p>Ai tot ce trebuie pentru a putea compila C++. Nu este o experien\u021b\u0103 la fel de bun\u0103 ca pe alte editoare, din moment ce ai autocompletare rudimentar\u0103, dar este suficient \u00een majoritatea cazurilor dac\u0103 \u0219tii ce faci. Legat de proiecte, nu prea ai propriu-zis conceptul \u0103sta, a\u0219a c\u0103 doar creezi un fi\u0219ier cu extensia <code>.cpp</code>, eventual \u0219i alte fi\u0219iere de care ai nevoie, \u0219i compilezi direct.</p> <p>Asta este tot cu configurarea. Po\u021bi acum s\u0103 mergi c\u0103tre urm\u0103torul articol:</p> <p>Mergi la introducere</p>"},{"location":"cppintro/editors/windows/optiuni-editoare/","title":"Op\u021biuni de editoare (Windows)","text":"<p>Exist\u0103 dou\u0103 tipuri de editoare folosite pentru a scrie cod (nu doar \u00een C++):</p> <ul> <li> <p> Editoare de text</p> <p>Un editor de text este un program simplu folosit pentru scrierea \u0219i editarea codului surs\u0103 C++. Exemple de astfel de editoare includ Vim, Emacs, Notepad++, Geany, Kate, Sublime Text, \u0219i Visual Studio Code, printre altele. Acestea sunt ideale pentru editarea de fi\u0219iere de cod C++ simple, oferind func\u021bionalit\u0103\u021bi de baz\u0103 precum eviden\u021bierea sintaxei \u0219i completarea automat\u0103.</p> <p>Editoarele de text consum\u0103 mai pu\u021bin\u0103 memorie dec\u00e2t un IDE, \u00eens\u0103 trebuie s\u0103 fie configurate pentru a putea suporta C++ la un nivel satisf\u0103c\u0103tor.</p> <p> Vezi op\u021biuni</p> </li> <li> <p> IDE</p> <p>Un mediu de dezvoltare integrat (IDE) pentru C++ este un software complex care ofer\u0103 dezvoltatorilor un set complet de instrumente pentru scrierea, compilarea, testarea \u0219i depanarea codului C++. Exemple de IDE-uri pentru C++ includ Visual Studio 2022, CLion, Qt Creator \u0219i Code::Blocks. Acestea includ func\u021bionalit\u0103\u021bi avansate precum depanare interactiv\u0103, integrare cu sisteme de control al versiunilor, instrumente de profilare \u0219i optimizare a codului, \u0219i multe alte instrumente care faciliteaz\u0103 dezvoltarea de aplica\u021bii complexe \u00een C++. Fiind programe mai complexe, ele consum\u0103 mai mult\u0103 memorie \u0219i mai mult spa\u021biu, \u00eens\u0103 ofer\u0103 toate uneltele necesare.</p> <p> Vezi op\u021biuni</p> </li> </ul>"},{"location":"cppintro/editors/windows/qt-creator/","title":"Qt Creator (Windows)","text":"<p>TODO</p>"},{"location":"cppintro/editors/windows/sublime-text-4/","title":"Sublime Text 4 (Windows)","text":""},{"location":"cppintro/editors/windows/sublime-text-4/#instalare","title":"Instalare","text":"<p>Procesul de instalare este unul foarte simplu:</p> <ol> <li> <p>Descarc\u0103 installerul de Sublime Text 4:</p> <p>Link direct </p> </li> <li> <p>Dup\u0103 ce s-a desc\u0103rcat, ruleaz\u0103 installerul (care ar trebui s\u0103 fie numit     <code>sublime_text_build_{versiune}_x64_setup.exe</code>) \u0219i urm\u0103re\u0219te pa\u0219ii de pe     ecran.</p> </li> </ol> <p>Alternativ, po\u021bi desc\u0103rca varianta portabil\u0103 de aici. Ea este util\u0103 de pild\u0103 la \u0219coal\u0103, unde nu ai drepturi de administrator pentru a putea instala Sublime Text 4 \u00een mod normal.</p> <p>Descarc\u0103 arhiva .zip </p>"},{"location":"cppintro/editors/windows/sublime-text-4/#configurare-si-utilizare","title":"Configurare \u0219i utilizare","text":"<p>Ca orice editor de text, Sublime Text 4 nu vine implicit cu suport de C++, \u00eens\u0103 putem s\u0103 configur\u0103m editorul folosind pachetele pe care le avem la dispozi\u021bie. Pachetele se g\u0103sesc prin Package Control. Pentru a instala suportul de pachete, ap\u0103s\u0103m Ctrl+Shift+P (Tools &gt; Command Palette) \u0219i tast\u0103m \"ipc\" (Install Package Control) \u0219i ap\u0103s\u0103m Enter. Dac\u0103 apare un pop-up care zice \"Package Control was successfully installed\", atunci s-a instalat cu succes.</p> <p>Command Palette ne va fi de folos \u00een majoritatea timpului nostru pe ST4, deci este bine s\u0103 te obi\u0219nuie\u0219ti cu el. Din Command Palette, tast\u0103m \"pip\" (Package Control: Install Package) \u0219i ap\u0103s\u0103m Enter. Avem nevoie de urm\u0103toarele pachete:</p> <ol> <li>SideBarEnhancements, care adaug\u0103 mai multe op\u021biuni pentru manipularea    fi\u0219ierelor din bara lateral\u0103 (vizibil\u0103 cu Ctrl+K, Ctrl+B). \u00cen esen\u021b\u0103,    face bara lateral\u0103 s\u0103 fie mult mai util\u0103;</li> <li>LSP, care transform\u0103 ST4 \u00eentr-un editor mult mai avansat. Interfa\u021beaz\u0103    \u00eentre diverse servere pentru a putea oferi autocompletare, redenumirea    simbolurilor etc. De acolo, instal\u0103m \u0219i LSP-clangd, care ofer\u0103 suport    pentru serverul <code>clangd</code>;</li> <li>BracketHighlighter, care are scopul de a eviden\u021bia perechile de paranteze    (<code>()</code>, <code>[]</code>, <code>&lt;&gt;</code>, <code>{}</code>);</li> <li>Terminus, care ofer\u0103 un terminal real \u00een ST4;</li> <li>A File Icon, care ofer\u0103 icoane mai bune. Este ceva mai mult estetic;</li> <li>SublimeLinter, care ofer\u0103 suport pentru linting. Ce \u00eenseamn\u0103 asta,    mai pe larg, este c\u0103 pachetul acesta \u00ee\u021bi permite s\u0103 vezi erorile \u0219i    avertiz\u0103rile de la compilator \u0219i \u00ee\u021bi verific\u0103 sintaxa. Pentru C++, mai    trebuie s\u0103 instal\u0103m    \u0219i SublimeLinter-contrib-clang, SublimeLinter-contrib-clang-tidy \u0219i SublimeLinter-contrib-cppcheck;</li> <li>CMakeBuilder, pentru a putea compila \u0219i rula codul mai u\u0219or;</li> <li>CppFastOlympicCoding, care este f\u0103cut pentru a optimiza ST4 pentru concursuri    \u0219i olimpiade. Este op\u021bional, \u00eens\u0103 \u00eel recomand pe viitor.</li> </ol> <p>Acum c\u0103 avem toate aceste pachete, s\u0103 le configur\u0103m.</p> <p>Pentru <code>clangd</code>, <code>clang-tidy</code>, <code>cmake</code> \u0219i <code>clang-format</code>, dac\u0103 ai instalat compilatorul MinGW cum am indicat \u00een articolul trecut \u0219i nu ai exclus LLVM, nu trebuie s\u0103 faci nimic pentru a instala aceste programe. Pentru <code>cppcheck</code>, alege installerul de pe aceast\u0103 pagin\u0103 \u0219i urm\u0103re\u0219te instruc\u021biunile de pe ecran.</p> <p>Pentru a configura <code>clangd</code>, mergem la Preferences &gt; Package Settings &gt; LSP &gt; Servers &gt; LSP-clangd (sau Preferences: LSP-clangd settings din Command Palette). Se va deschide o nou\u0103 fereastr\u0103 \u00eemp\u0103r\u021bit\u0103 \u00een dou\u0103. Pe partea st\u00e2ng\u0103 se afl\u0103 toate configur\u0103rile pe care le avem la dispozi\u021bie, iar pe partea dreapt\u0103 se afl\u0103 configurarea utilizatorului, adic\u0103 set\u0103rile pe care vrem s\u0103 le aplic\u0103m. Eu folosesc aceste set\u0103ri: <pre><code>{\n   \"initializationOptions\": {\n      \"clangd.compile-commands-dir\": \"build\",\n      \"clangd.background-index\": true,\n      \"clangd.clang-tidy\": true,\n      \"clangd.completion-style\": \"detailed\",\n      \"clangd.function-arg-placeholders\": true,\n      \"clangd.header-insertion\": \"iwyu\",\n      \"clangd.header-insertion-decorators\": true,\n      \"clangd.malloc-trim\": true,\n   }\n}\n</code></pre></p> <p>Mai trebuie s\u0103 configur\u0103m \u0219i plugin-ul LSP. Pentru acest lucru, mergem la Preferences: LSP settings din Command Palette. <pre><code>{\n   \"lsp_format_on_save\": true,\n}\n</code></pre></p> <p>Urmeaz\u0103 s\u0103 configur\u0103m \u0219i formatarea codului. Dup\u0103 p\u0103rerea mea, stilul implicit pe care \u00eel are <code>clangd</code> mai mult \u00eencurc\u0103. Pentru a schimba stilul, putem l\u0103sa un fi\u0219ier \u00een fiecare proiect pe care \u00eel avem numit <code>.clang-format</code> (numit exact a\u0219a!). Stilul arhivei (\u0219i un stil pe care \u00eel recomand, de altfel) este acesta: <pre><code>---\nBasedOnStyle: Google\nAccessModifierOffset: -4\nAlignArrayOfStructures: Left\nAlignOperands: AlignAfterOperator\nAllowShortBlocksOnASingleLine: Empty\nAllowShortIfStatementsOnASingleLine: AllIfsAndElse\nAllowShortLoopsOnASingleLine: false\nBreakBeforeBinaryOperators: NonAssignment\nIndentCaseLabels: false\nIndentPPDirectives: BeforeHash\nIndentWidth: 4\nInsertBraces: true\nPointerAlignment: Right\nQualifierAlignment: Left\nSortIncludes: CaseInsensitive\nTabWidth: 4\n</code></pre></p> <p>Aten\u021bie</p> <p><code>clang-format</code> trebuie s\u0103 fie cel pu\u021bin la versiunea 15. Po\u021bi vedea acest lucru cu <code>clang-format --version</code> \u00eentr-un terminal. Dac\u0103 ai instalat compilatorul de pe Winlibs, el se afl\u0103 curent la versiunea 18, deci este totul \u00een regul\u0103.</p> <p>Ca s\u0103 func\u021bioneze optim, avem nevoie s\u0103 facem un proiect CMake. Din fericire, este un proces simplu. Avem nevoie doar de dou\u0103 fi\u0219iere \u00eentr-un folder: <code>main.cpp</code> (unde vei scrie codul) \u0219i <code>CMakeLists.txt</code> (numele trebuie s\u0103 fie exact acesta!).</p> <p>Ca s\u0103 te duci la un folder, du-te la File &gt; Open Folder. Dac\u0103 nu l-ai creat deja, acum ar fi momentul. Apas\u0103 Ctrl+N pentru a crea un fi\u0219ier \u0219i copiaz\u0103 urm\u0103torul con\u021binut (eu schimb doar <code>PROJECT_NAME</code> s\u0103 reflecte proiectul curent/problema curent\u0103): <pre><code>cmake_minimum_required(VERSION 3.10..3.99)\n\nset(PROJECT_NAME \"problema_interesanta\")\n\nproject(${PROJECT_NAME}\n   VERSION 0.1.0\n   LANGUAGES CXX)\n\nset(CMAKE_CXX_STANDARD 20)\nset(CMAKE_CXX_STANDARD_REQUIRED ON)\nset(CMAKE_CXX_EXTENSIONS OFF)\n\nset(CMAKE_EXPORT_COMPILE_COMMANDS ON)\n\nadd_executable(${PROJECT_NAME} main.cpp)\n\nset_target_properties(${PROJECT_NAME} PROPERTIES\n    RUNTIME_OUTPUT_DIRECTORY \"${CMAKE_BINARY_DIR}/bin\"\n)\n</code></pre></p> <p>Aten\u021bie</p> <p><code>PROJECT_NAME</code> nu poate s\u0103 con\u021bin\u0103 spa\u021bii. \u00cenlocuie\u0219te-le cu bar\u0103 jos (<code>_</code>) ca \u00een exemplu sau <code>-</code>.</p> <p>Salveaz\u0103-l \u00een <code>CMakeLists.txt</code> (trebuie s\u0103 fie exact acest nume!).</p> <p>Adaug\u0103 asta \u00een <code>main.cpp</code>: <pre><code>#include &lt;iostream&gt;\n\nint main() {\n    std::cout &lt;&lt; \"Hello, world!\" &lt;&lt; std::endl;\n    return 0;\n}\n</code></pre></p> <p>Din Command Palette, execut\u0103 \"CMakeBuilder: Configure\". Dac\u0103 apare ceva \u00een josul ecranului care are un mesaj similar cu: <pre><code>-- Configuring done\n-- Generating done\n-- Build files have been written to: ...\n[Finished in 64ms]\n</code></pre> atunci procesul a reu\u0219it.</p> <p>Acum te po\u021bi duce pe <code>main.cpp</code> \u0219i s\u0103 rulezi \"LSP: Enable Language Server Globally\" (sau In Project) din Command Palette \u0219i selecteaz\u0103 clangd. Dac\u0103 totul merge cum trebuie, ar trebui ca <code>iostream</code> s\u0103 fie subliniat \u0219i \u00een bara de status (cea de jos) s\u0103 scrie <code>clangd</code>.</p> <p>Pentru a rula proiectul, apas\u0103 pe Ctrl+Shift+B \u0219i alege op\u021biunea \"Default: Run - ...\" (unde ... este numele proiectului (ales la <code>PROJECT_NAME</code>)). Dup\u0103 asta, apas\u0103 Enter (nu avem argumente) \u0219i, dac\u0103 totul a mers \u00een regul\u0103, vei vedea un ecran similar cu acesta:</p> <pre><code>[ 50%] Building CXX object CMakeFiles/testspatii.dir/main.cpp.o\n[100%] Linking CXX executable bin/problema_interesanta\n[100%] Built target problema_interesanta\nHello, world!\nprocess is terminated with return code 0.\n</code></pre> <p>Prima linie poate s\u0103 difere.</p> <p>\u00cen momentul de fa\u021b\u0103, ai o experien\u021b\u0103 acceptabil\u0103 \u0219i po\u021bi s\u0103 continui mai departe, \u00eens\u0103 o s\u0103 \u00eembun\u0103t\u0103\u021bim experien\u021ba \u0219i mai mult.</p> <p>Deschide Preferences: Settings din Command Palette. Aici se afl\u0103 preferin\u021bele globale ale utilizatorului, \u0219i acestea sunt cele care ne intereseaz\u0103 momentan. Tot ce vom scrie se va afla \u00eentre acolade, la fel ca la celelalte set\u0103ri.</p> <ol> <li>Vom schimba m\u0103rimea fontului, deoarece ea este prea mic\u0103 \u00een mod normal:    <pre><code>\"font_size\": 12,\n</code></pre></li> <li>A\u0219a cum putem schimba m\u0103rimea fontului, putem schimba \u0219i fontul \u00een sine.    Recomand Cascadia Code/Mono sau Consolas, de\u0219i po\u021bi g\u0103si alte fonturi care    \u00ee\u021bi plac pe internet:    <pre><code>\"font_face\": \"Cascadia Code\",\n</code></pre></li> <li>Cel mai probabil nu vei tr\u0103i \u00een Sublime Text 4 pentru totdeauna, deci va    trebui s\u0103 schimbi tabul sau fereastra. Setarea <code>save_on_focus_lost</code> salveaz\u0103    fi\u0219ierul automat, ca s\u0103 nu pierzi progresul \u00een cazul \u00een care \u00eenchizi din gre\u0219eal\u0103    editorul:    <pre><code>\"save_on_focus_lost\": true,\n</code></pre></li> <li>Setarea <code>highlight_line</code> va eviden\u021bia linia curent\u0103, ceea ce poate fi util dac\u0103 nu vezi    unde ai cursorul:    <pre><code>\"highlight_line\": true,\n</code></pre></li> <li>Implicit, totul este cam \u00eengr\u0103m\u0103dit, a\u0219a c\u0103 putem l\u0103sa editorul s\u0103 respire pu\u021bin:    <pre><code>\"line_padding_bottom\": 4,\n\"line_padding_top\": 4,\n</code></pre>    Evident, po\u021bi ajusta dac\u0103 \u021bi se pare prea mult, \u00eens\u0103 consider c\u0103 4 este o setare adecvat\u0103.</li> <li>ST4 arat\u0103 destul de modern, \u00eens\u0103 putem s\u0103 \u00eembun\u0103t\u0103\u021bim tema \u0219i mai mult.    Pentru interfa\u021b\u0103, prefer s\u0103 \u00eel \u021bin pe Adaptive, deoarece se integreaz\u0103 mai    bine cu bara de meniu \u0219i cu restul interfe\u021bei:    <pre><code>\"theme\": \"Adaptive.sublime-theme\",\n</code></pre></li> </ol> <p>Pentru editor, aici este o decizie personal\u0103 \u0219i au avut loc b\u0103t\u0103lii    seculare (bine, nu la fel de mari ca la Vim vs Emacs), a\u0219a c\u0103 vom instala    pachetul Colorsublime, pentru a vedea \u00een timp real cum va ar\u0103ta interfa\u021ba.    Acesta are \u0219i un site (https://colorsublime.github.io) unde po\u021bi vedea    aceste teme \u00een timp real. Dup\u0103 ce ai instalat pachetul, ruleaz\u0103    Colorsublime: Install Theme din Command Palette \u0219i deruleaz\u0103 prin zecile    de teme pe care le ai la dispozi\u021bie. 7. Urm\u0103toarele set\u0103ri au de-a face cu spa\u021biile albe:    <pre><code>\"translate_tabs_to_spaces\": true,\n\"trim_trailing_white_space_on_save\": \"all\",\n</code></pre> 8. Pentru a avea \u00een vedere limita de 80 caractere setat\u0103 la sec\u021biunea de formatare,    putem ad\u0103uga urm\u0103toarea setare:    <pre><code>\"rulers\": [80],\n</code></pre></p> <p>\u00cen final, configurarea ta ar trebui s\u0103 arate similar cu asta: <pre><code>{\n   \"font_size\": 12,\n   \"font_face\": \"Cascadia Code\",\n   \"save_on_focus_lost\": true,\n   \"highlight_line\": true,\n   \"line_padding_bottom\": 4,\n   \"line_padding_top\": 4,\n   \"theme\": \"Adaptive.sublime-theme\",\n   \"color_scheme\": \"Packages/Colorsublime - Themes/Tomorrow_Night.tmTheme\",\n   \"translate_tabs_to_spaces\": true,\n   \"trim_trailing_white_space_on_save\": \"all\",\n   \"rulers\": [80],\n}\n</code></pre></p> <p>Asta este tot cu configurarea. Po\u021bi acum s\u0103 mergi c\u0103tre urm\u0103torul articol:</p> <p>Mergi la introducere</p>"},{"location":"cppintro/editors/windows/visual-studio-2022/","title":"Visual Studio 2022","text":""},{"location":"cppintro/editors/windows/visual-studio-2022/#instalare","title":"Instalare","text":"<p>Pentru a instala:</p> <ol> <li> <p>Descarc\u0103 executabilul de setup de aici (Visual Studio 2022 Community, este    varianta gratuit\u0103 \u0219i arhisuficient\u0103 pentru nevoile tale):</p> <p>Descarc\u0103 Visual Studio 2022 Community </p> </li> <li> <p>Ruleaz\u0103 executabilul. La prima fereastr\u0103 cu titlul Visual Studio Installer,    apas\u0103 pe butonul Continue. Dup\u0103 ce se descarc\u0103 installer-ul oficial, o s\u0103 ai    o fereastr\u0103 similar\u0103 cu asta:</p> <p> </p> </li> <li> <p>Visual Studio 2022 are conceptul de workload. Fiecare workload este    specializat pe un anumit domeniu sau limbaj \u0219i instaleaz\u0103 un set anume de    componente. Majoritatea workload-urilor sunt \u021bintate c\u0103tre cei pe C#, \u00eens\u0103 pe    noi ne intereseaz\u0103 workload-ul Desktop development with C++. A\u0219a ar    trebui s\u0103 arate fereastra ta dup\u0103 ce ai selectat op\u021biunea asta:</p> <p> </p> </li> <li> <p>Apas\u0103 butonul de install \u0219i a\u0219teapt\u0103 s\u0103 se instaleze. Dup\u0103 cum se poate vedea    \u00een ultima poz\u0103, este destul de mare Visual Studio. Totu\u0219i, dup\u0103 ce se termin\u0103    de instalat, se deschide singur. La aceast\u0103 fereastr\u0103, ori te po\u021bi loga cu    contul de GitHub sau Microsoft, ori po\u021bi s\u0103 dai skip, nu e necesar s\u0103 ai un    cont pentru a putea folosi Visual Studio.</p> <p> </p> </li> <li> <p>La urm\u0103toarea fereastr\u0103, po\u021bi s\u0103 la\u0219i set\u0103rile implicite sau s\u0103 schimbi tema.    Tot ce mai r\u0103m\u00e2ne s\u0103 faci este s\u0103 ape\u0219i pe \"Start Visual Studio\" \u0219i s\u0103    a\u0219tep\u021bi pu\u021bin \u00een timp ce se configureaz\u0103. Dac\u0103 tot procesul a mers cum    trebuie, se va deschide aceast\u0103 fereastr\u0103:</p> <p> </p> </li> </ol>"},{"location":"cppintro/editors/windows/visual-studio-2022/#configurare-si-utilizare","title":"Configurare \u0219i utilizare","text":"<p>Felicit\u0103ri! Ai instalat Visual Studio 2022. Acum vremea s\u0103 \u00eel configur\u0103m \u0219i folosim.</p> <p>Pentru a crea un proiect C++, facem urm\u0103torii pa\u0219i:</p> <ol> <li>La fereastra de mai sus (care apare \u00een momentul \u00een care deschizi Visual    Studio 2022), apas\u0103 pe \"Create a new project\".</li> <li> <p>O s\u0103 fii \u00eent\u00e2mpinat de mai multe \u0219abloane pe care le po\u021bi folosi:</p> <p> </p> </li> <li> <p>Avem dou\u0103 \u0219abloane care ni-s utile:</p> <ol> <li>Console App, care gestioneaz\u0103 proiectul folosind MSBuild \u0219i este specific    Visual Studio;</li> <li>CMake Project, care poate rula pe mai multe platforme (oriunde este    suportat CMake, inclusiv Linux \u0219i *BSD) \u0219i nu este limitat de Visual    Studio.</li> </ol> <p>Dac\u0103 nu ai nevoie s\u0103 editezi proiectul \u0219i cu alte editoare/IDE-uri sau pe alte platforme, Console App este suficient, a\u0219a c\u0103 asta vom folosi \u0219i noi acum. D\u0103 dublu click pe Console App (sau selecteaz\u0103-l, apoi apas\u0103 Next).</p> </li> <li> <p>Ajungem la aceast\u0103 fereastr\u0103:</p> <p> </p> <p>\u00cen primul r\u00e2nd, avem numele proiectului.</p> <p>Sfat</p> <p>F\u0103 numele proiectului sugestiv, chiar numele problemei la care lucrezi acum, pentru c\u0103 nu este prea dr\u0103gu\u021b s\u0103 umpli printr-o mare de proiecte care \u00eencep cu ConsoleApplication.</p> <p>Apoi avem loca\u021bia acestuia. Calea implicit\u0103 este <code>$USER\\source\\repos</code>, dar po\u021bi s\u0103-l pui undeva separat (recomand acest lucru). Dup\u0103 loca\u021bie avem numele solu\u021biei. O solu\u021bie este un container pentru unul sau mai multe proiecte. Po\u021bi selecta \u0219i dac\u0103 vrei s\u0103 fie solu\u021bia \u0219i proiectul \u00een acela\u0219i director (caz \u00een care numele proiectului este acela\u0219i cu cel al solu\u021biei).</p> <p>Aten\u021bie</p> <p>Nu exist\u0103 solu\u021bii dac\u0103 alegi \u0219ablonul cu CMake. Exist\u0103 moduri prin care po\u021bi emula acest lucru, dar cea mai simpl\u0103 cale (f\u0103r\u0103 integrarea de care ai parte cu Console App) este s\u0103 pui \u00een directoare separate (de fapt, asta face \u0219i o solu\u021bie).</p> <p>Sfat</p> <p>Nu este obligatoriu, \u00eens\u0103 dac\u0103 lucrezi de pe un site (e.g. Kilonova) sau faci probleme de la un concurs, recomand s\u0103 le grupezi \u00eentr-o solu\u021bie. Zece solu\u021bii sunt mult mai u\u0219or de gestionat dec\u00e2t 40 de proiecte, dac\u0103 este nevoie s\u0103 cau\u021bi pe viitor rezolv\u0103rile la o problem\u0103.</p> <p>De dragul exemplului, voi numi proiectul \"ConsoleApplication1\" sub loca\u021bia implicit\u0103 \u0219i pun proiectul \u00een acela\u0219i loc cu solu\u021bia. Dac\u0103 totul a mers cum trebuie, vei vedea o fereastr\u0103 similar\u0103 cu asta:</p> <p> </p> </li> </ol> <p>Po\u021bi acum s\u0103 ape\u0219i Ctrl+F5 (Start without Debugging) \u0219i vei vedea c\u0103 ruleaz\u0103 programul \u0219i afi\u0219eaz\u0103 Hello World. Asta \u00eenseamn\u0103 \u0219i c\u0103 ai compilatorul MSVC func\u021bional.</p> <p>Sfat</p> <p>Obi\u0219nuie\u0219te-te cu aceast\u0103 scurt\u0103tur\u0103 (Ctrl+F5), o s\u0103 o folose\u0219ti foarte des. \u00cen timp, uit\u0103-te prin meniuri \u0219i \u00eenva\u021b\u0103 ni\u0219te scurt\u0103turi comune pentru ac\u021biunile pe care le faci cele mai des, a\u0219a vei deveni mai rapid \u0219i mai fluid la a folosi Visual Studio. Vezi aceast\u0103 pagin\u0103 care este cheatsheet de la Microsoft cu cele mai comune scurt\u0103turi specifice VS. Scurt\u0103turile generale gen Ctrl+C, Ctrl+V, Ctrl+S etc. le po\u021bi g\u0103si \u0219i din VS \u0219i sunt \u00een mare parte general valabile.</p> <p>Acum, timpul pentru ni\u0219te chestii pe care le po\u021bi face ca s\u0103 \u00eembun\u0103t\u0103\u021be\u0219ti performan\u021ba (VS este un program mare \u0219i ia mult\u0103 memorie, deci poate fi uneori \u00eencet):</p> <ol> <li> <p>Visual Studio deschide automat fi\u0219ierele care au fost deschise \u00een vechea    sesiune. Din aceast\u0103 pricin\u0103, o solu\u021bie poate lua mai mult s\u0103 se deschid\u0103,    pentru c\u0103 toate fi\u0219ierele sunt analizate \u00een paralel. Pentru a dezactiva acest    comportament:</p> <ol> <li>Apas\u0103 \u00een meniu pe Tools, apoi Options (ultima din dropdown, cea cu o    roti\u021b\u0103 zim\u021bat\u0103);</li> <li> <p>Du-te la Projects and Solutions, apoi la General \u0219i dezactiveaz\u0103 \"Reopen    documents on solution load\". \u00cen final, ar trebui s\u0103 arate similar cu    asta:</p> <p> </p> </li> </ol> <p>\u00cen schimb, putem s\u0103 ne folosim de ce se afl\u0103 la Edit &gt; Go To. Aici se afl\u0103 toate op\u021biunile:</p> <p> </p> <p>Cea mai important\u0103 din ele este Ctrl+T care func\u021bioneaz\u0103 ca un Go To generalizat. Pentru fi\u0219iere recente avem Ctrl+1, Ctrl+R, \u0219i pentru fi\u0219iere \u00een general avem Ctrl+Shift+T. Ocazional folosesc \u0219i Ctrl+1, Ctrl+S ca s\u0103 caut un simbol (o func\u021bie, o variabil\u0103 etc.), ceea ce se poate dovedi util la fi\u0219iere mari.</p> </li> <li> <p>Dac\u0103 instalezi extensii, acestea sunt activate c\u00e2nd este nevoie. Problema la    aceast\u0103 abordare este c\u0103 dac\u0103 ai una sau mai multe extensii care ruleaz\u0103    imediat la pornire, atunci programul se va \u00eencetini. Po\u021bi folosi Help &gt;    Visual Studio Performance Manager pentru a inspecta de ce VS este \u00eencet.</p> </li> <li> <p>Visual Studio \u00ee\u0219i ajusteaz\u0103 efectele bazat pe performan\u021ba clientului, \u00eens\u0103    acest lucru de cele mai multe ori \u00eencetine\u0219te tot. Pentru a rezolva acest    lucru, mergem la Tools &gt; Options \u0219i apoi la Environment &gt; General. Op\u021biunea    pe care vrem s\u0103 o dezactiv\u0103m se cheam\u0103 \"Automatically adjust visual    experience based on client performance\", \u00eempreun\u0103 cu \"Enable rich client    visual experience\". Ultima op\u021biune, cea cu accelerarea hardware, trebuie s\u0103    r\u0103m\u00e2n\u0103 activ\u0103, pentru a nu randa software Visual Studio (excep\u021bie fiind dac\u0103    ai un calculator cu o plac\u0103 video foarte slab\u0103 sau dac\u0103 e\u0219ti pe ma\u0219in\u0103    virtual\u0103). Dup\u0103 ce ai terminat, fereastra trebuie s\u0103 fie similar\u0103 cu asta:</p> <p> </p> </li> <li> <p>Windows Defender ruleaz\u0103 constant \u00een fundal pentru a ne proteja de viru\u0219i.    Totu\u0219i, asta impacteaz\u0103 negativ performan\u021ba pentru c\u0103 scaneaz\u0103 toate    directoarele din sistem, inclusiv cele ale lui Visual Studio \u0219i cele ale    proiectelor noastre. Pentru acest lucru, trebuie s\u0103 facem excep\u021bii. Am creat    un script de PowerShell care s\u0103 automatizeze acest proces. Acesta poate fi    desc\u0103rcat de aici:</p> <p>Descarc\u0103 script </p> <p>Scriptul complet ImproveVS2022.ps1<pre><code>if (-not ([Security.Principal.WindowsPrincipal] [Security.Principal.WindowsIdentity]::GetCurrent()).IsInRole([Security.Principal.WindowsBuiltInRole] \"Administrator\")) \n{\n    Write-Host \"Ruleaza acest script ca Administrator.\" -ForegroundColor Red\n    exit\n}\n\n$userPath = $env:USERPROFILE\n$appdataLocal = \"$userPath\\AppData\\Local\"\n$appdataRoaming = \"$userPath\\AppData\\Roaming\"\n$programData = \"C:\\ProgramData\"\n$programFiles = \"C:\\Program Files\"\n$programFilesX86 = \"$programFiles (x86)\"\n\n$pathExclusions = @(\n    'C:\\Windows\\Microsoft.NET',\n    'C:\\Windows\\assembly',\n    \"$userPath\\.dotnet\",\n    \"$userPath\\.librarymanager\",\n    \"$appdataLocal\\Microsoft\\VisualStudio\",\n    \"$appdataLocal\\Microsoft\\VisualStudio Services\",\n    \"$appdataLocal\\GitCredentialManager\",\n    \"$appdataLocal\\GitHubVisualStudio\",\n    \"$appdataLocal\\Microsoft\\dotnet\",\n    \"$appdataLocal\\Microsoft\\VSApplicationInsights\",\n    \"$appdataLocal\\Microsoft\\VSCommon\",\n    \"$appdataLocal\\Temp\\VSFeedbackIntelliCodeLogs\",\n    \"$appdataRoaming\\Microsoft\\VisualStudio\",\n    \"$appdataRoaming\\NuGet\",\n    \"$appdataRoaming\\Visual Studio Setup\",\n    \"$appdataRoaming\\vstelemetry\",\n    \"$programData\\Microsoft\\VisualStudio\",\n    \"$programData\\Microsoft\\NetFramework\",\n    \"$programData\\Microsoft Visual Studio\",\n    \"$programFiles\\Microsoft Visual Studio\",\n    \"$programFiles\\dotnet\",\n    \"$programFiles\\Microsoft SDKs\",\n    \"$programFiles\\Microsoft SQL Server\",\n    \"$programFiles\\IIS\",\n    \"$programFiles\\IIS Express\",\n    \"$programFilesX86\\Microsoft Visual Studio\",\n    \"$programFilesX86\\dotnet\",\n    \"$programFilesX86\\Microsoft SDKs\",\n    \"$programFilesX86\\Microsoft SQL Server\",\n    \"$programFilesX86\\IIS\",\n    \"$programFilesX86\\IIS Express\"\n)\n\n$processExclusions = @(\n    'ServiceHub.SettingsHost.exe',\n    'ServiceHub.IdentityHost.exe',\n    'ServiceHub.VSDetouredHost.exe',\n    'ServiceHub.Host.CLR.x86.exe',\n    'Microsoft.ServiceHub.Controller.exe',\n    'PerfWatson2.exe',\n    'sqlwriter.exe'\n)\n\nWrite-Host \"Acest script va crea excluderi pentru Windows Defender pentru folderele si procesele comune ale Visual Studio 2022.\"\nWrite-Host \"\"\n$projectsFolder = Read-Host \"Care este calea catre folderul proiectelor tale? (exemplu: $userPath\\source\\repos)\"\n\nif (-not (Test-Path $projectsFolder)) \n{\n    Write-Host \"Calea specificata pentru folderul proiectelor nu exista. Iesire din script.\" -ForegroundColor Red\n    exit\n}\n\nWrite-Host \"\"\nWrite-Host \"Adaugare excludere cale: $projectsFolder\"\nAdd-MpPreference -ExclusionPath $projectsFolder\n\nforeach ($exclusion in $pathExclusions) \n{\n    Write-Host \"Adaugare excludere cale: $exclusion\"\n    try \n    {\n        Add-MpPreference -ExclusionPath $exclusion\n    } \n    catch \n    {\n        Write-Host \"Nu s-a reusit adaugarea excluderii pentru calea: $exclusion - $_\" -ForegroundColor Yellow\n    }\n}\n\nforeach ($exclusion in $processExclusions) \n{\n    Write-Host \"Adaugare excludere proces: $exclusion\"\n    try \n    {\n        Add-MpPreference -ExclusionProcess $exclusion\n    } \n    catch \n    {\n        Write-Host \"Nu s-a reusit adaugarea excluderii pentru procesul: $exclusion - $_\" -ForegroundColor Yellow\n    }\n}\n\nWrite-Host \"\"\nWrite-Host \"Excluderile tale:\"\n$prefs = Get-MpPreference\n\nWrite-Host \"Caile excluse:\"\n$prefs.ExclusionPath\nWrite-Host \"\"\n\nWrite-Host \"Procesele excluse:\"\n$prefs.ExclusionProcess\n</code></pre> </p> <p>Pentru a-l folosi, trebuie f\u0103cu\u021bi urm\u0103torii pa\u0219i (presupun c\u0103 ai desc\u0103rcat scriptul \u00een <code>C:\\Users\\&lt;nume&gt;\\Downloads</code> (adic\u0103 \u00een folderul de Desc\u0103rc\u0103ri)):</p> <ol> <li> <p>Deschide o fereastr\u0103 de PowerShell ca administrator. Pentru a face acest    lucru, fie po\u021bi ap\u0103sa incanta\u021bia Win+X, A \u0219i apoi Enter, fie    po\u021bi s\u0103 cau\u021bi Windows Powershell (sau doar Terminal, dac\u0103 e\u0219ti pe Windows    11) \u00een meniu, apoi selectezi Executare ca administrator.</p> </li> <li> <p>Navigheaz\u0103 p\u00e2n\u0103 la calea unde ai desc\u0103rcat cu <code>cd C:\\Users\\&lt;cale&gt;</code>. \u00cen    cazul meu, va fi <code>cd C:\\Users\\RoAlgo\\Downloads</code>.</p> </li> <li> <p>Scrie <code>.\\ImproveVS2022.ps1</code> (presupun\u00e2nd c\u0103 a\u0219a ai numit fi\u0219ierul).</p> </li> <li> <p>Trebuie doar s\u0103 furnizezi calea unde \u00ee\u021bi stochezi proiectele de obicei.    Dac\u0103 e\u0219ti cu set\u0103rile implicite, atunci po\u021bi scrie exact ce \u00ee\u021bi zice    exemplul (adic\u0103 <code>C:\\Users\\&lt;nume&gt;\\source\\repos</code>). Dac\u0103 nu exist\u0103 calea,    atunci programul iese.</p> </li> <li> <p>Ape\u0219i Enter \u0219i a\u0219tep\u021bi s\u0103 \u00ee\u0219i fac\u0103 treab\u0103 (termin\u0103 repede).</p> </li> </ol> </li> </ol> <p>Asta este tot cu configurarea. Po\u021bi acum s\u0103 mergi c\u0103tre urm\u0103torul articol:</p> <p>Mergi la introducere</p>"},{"location":"cppintro/editors/windows/visual-studio-code/","title":"Visual Studio Code (Windows)","text":""},{"location":"cppintro/editors/windows/visual-studio-code/#instalare","title":"Instalare","text":"<p>Procesul de instalare este unul foarte simplu:</p> <ol> <li> <p>Descarc\u0103 installerul de Visual Studio Code:</p> <p>Link direct </p> </li> <li> <p>Dup\u0103 ce s-a desc\u0103rcat, ruleaz\u0103 installerul (care ar trebui s\u0103 fie numit     <code>VSCodeUserSetup-x64-{versiune}.exe</code>). Procesul nu dureaz\u0103 mult, de cele mai     multe ori este un minut.</p> </li> <li> <p>Implicit, VS Code este instalat sub <code>C:\\Users\\{nume utilizator}\\AppData\\Local\\Programs\\Microsoft VS Code</code>.</p> </li> </ol> <p>Alternativ, po\u021bi desc\u0103rca o arhiv\u0103 .zip, s\u0103 o extragi \u0219i s\u0103 rulezi VS Code de acolo. Acest lucru este util \u00een caz c\u0103 vrei s\u0103 rulezi portabil (de pild\u0103, la \u0219coal\u0103, unde nu ai drepturi de administrator pentru a putea instala VS Code \u00een mod normal).</p> <p>Descarc\u0103 arhiva .zip </p>"},{"location":"cppintro/editors/windows/visual-studio-code/#configurare-si-utilizare","title":"Configurare \u0219i utilizare","text":"<p>\u00cenainte de a continua, p\u0103r\u021bile principale ale interfe\u021bei sunt:</p> <ul> <li>Editorul, unde deschizi \u0219i schimbi fi\u0219iere surs\u0103 (\u0219i nu numai). Aici \u00ee\u021bi vei   petrece majoritatea timpului. Po\u021bi avea mai mult de un fi\u0219ier deschis.</li> <li>Bara lateral\u0103 (sidebar) arat\u0103 fi\u0219ierele \u0219i directoarele cu care lucrezi. Poate   fi ascuns\u0103 pentru a vedea mai mult din cod.</li> <li>Bara de status, care se afl\u0103 \u00een partea de jos, \u0219i arat\u0103 informa\u021bii precum   linia \u0219i coloana pe care te afli, tipul de fi\u0219ier, num\u0103rul de erori \u0219.a.m.d.</li> <li>Panel-uri, care sunt arii care apar pentru sarcini specifice precum c\u0103utare,   inspectarea erorilor, gestionarea extensiilor \u0219.a.m.d.</li> </ul> <p>Implicit nu vine cu suport integrat pentru C++. Totu\u0219i, Visual Studio Code are o gam\u0103 larg\u0103 de extensii (pe care le putem accesa folosind butonul de extensii care arat\u0103 ca patru cuburi dintre care unul este desprins, dar poate fi accesat \u0219i cu scurt\u0103tura Ctrl+Shift+X). De acolo, caut\u0103 \"C/C++ Extension Pack\" \u0219i apas\u0103 pe prima extensie de la Microsoft (nu este greu s\u0103 o recuno\u0219ti).</p> <p>Acum s\u0103 facem un fi\u0219ier de C++ pentru a putea continua procesul. Creeaz\u0103 un fi\u0219ier nou, fie din File &gt; New Text File, fie folosind scurt\u0103tura Ctrl+N. \u00cel salv\u0103m imediat undeva (Ctrl+S), loca\u021bia nu este important\u0103 pe moment. Numele fi\u0219ierului trebuie s\u0103 se termine cu <code>.cpp</code> la final, s\u0103-i zicem <code>main.cpp</code>. Imediat ce ai salvat, O s\u0103 vezi c\u0103 Visual Studio Code a recunoscut fi\u0219ierul nostru gol ca unul de C++ \u0219i a activat extensia pe care tocmai am instalat-o. Dac\u0103 \u00ee\u021bi cere \u00eentr-un pop-up s\u0103 te duci la o versiune de pre-release a extensiei de C++, refuz\u0103.</p> <p>Apas\u0103 Ctrl+Shift+P pentru a activa Command Palette (o s\u0103 folose\u0219ti asta foarte des). Scrie \"Intellisense\" \u0219i selecteaz\u0103 op\u021biunea \"C/C++: Select IntelliSense Configuration...\". Alege g++. \u00cen cazul \u00een care ai instalat \u0219i Visual Studio 2022, o s\u0103 ai op\u021biunea de cl.exe. Dac\u0103 nu ai instalat GCC cu MinGW, este bun\u0103 \u0219i aceast\u0103 op\u021biunea, de\u0219i ar fi bine s\u0103 ai g++ \u00een schimb.</p> <p>Ca s\u0103 testezi dac\u0103 a mers, scrie <code>#include &lt;ios</code>. Dac\u0103 \u00ee\u021bi ofer\u0103 sugestii precum <code>ios</code>, <code>iostream</code> \u0219i <code>iso646.h</code>, atunci este func\u021bional.</p> <p>Creeaz\u0103 un director gol \u00eentr-un loc pe care \u00eel \u0219tii \u0219i apoi navigheaz\u0103 p\u00e2n\u0103 la el folosind File &gt; Open Folder (Ctrl+K Ctrl+O). Dac\u0103 ai un popup cu \"Do you trust the authors of the files in this folder?\", apas\u0103 \"Yes, I trust the authors\" (pentru c\u0103 tu e\u0219ti autorul, logic). Po\u021bi op\u021bional s\u0103 bifezi s\u0103 aib\u0103 \u00eencredere \u0219i \u00een fi\u0219ierele din directorul p\u0103rinte. Apoi po\u021bi crea un nou fi\u0219ier pe care s\u0103-l nume\u0219ti tot <code>main.cpp</code>, ca data trecut\u0103. Adaug\u0103 aceste linii \u00een fi\u0219ier:</p> <pre><code>#include &lt;iostream&gt;\n\nint main() {\n    std::cout &lt;&lt; \"Hello from VSCode!\" &lt;&lt; std::endl;\n    return 0;\n}\n</code></pre> <p>Interfa\u021ba ta ar trebui s\u0103 arate similar cu asta:</p> <p>Apoi po\u021bi s\u0103 rulezi fi\u0219ierul astfel:</p> <ol> <li> <p>Du-te la butonul de debug din tab bar (este un triunghi cu un g\u00e2ndac) \u0219i     extinde-l. Din lista aceea, selecteaz\u0103 Run C/C++ code. A\u0219a ar trebui s\u0103     arate:</p> <p> </p> </li> <li> <p>Selecteaz\u0103 de acolo \"C/C++: g++.exe build and debug active file\", ca s\u0103    poat\u0103 compila folosind G++. Este posibil s\u0103 vezi \u0219i op\u021biuni cu Clang sau    cl.exe, dar po\u021bi s\u0103 le ignori. Dac\u0103 \u00ee\u021bi cere extensia de CMake Tools ceva    legat de vizibilitate, d\u0103-i Do not show again, nu \u00ee\u021bi este relevant\u0103 \u021bie    acum.</p> </li> <li> <p>Dac\u0103 totul a mers cum trebuie, ar trebui s\u0103 vezi undeva jos \u00een terminal    mesajul \"Hello from VSCode!\".</p> </li> </ol> <p>Metoda pe care o folosesc eu c\u00e2nd folosesc Visual Studio Code este urm\u0103toarea:</p> <ol> <li> <p>C\u00e2nd ai instalat extensia, \u021bi-a instalat \u0219i suport pentru CMake. Pentru a     crea un proiect de CMake, du-te \u00een Command Palette prin Ctrl+Shift+P \u0219i     apoi scrie \"CMake: Quick Start\" \u0219i selecteaz\u0103 acea op\u021biune;</p> </li> <li> <p>Scrie numele proiectului t\u0103u. De obicei este la fel ca numele problemei pe     care o faci, dar poate fi orice. Nu trebuie s\u0103 con\u021bin\u0103 spa\u021bii (doar linii     sau bar\u0103 jos).</p> <p> </p> </li> <li> <p>Aici te pune s\u0103 alegi limbajul \u00een care va fi proiectul. Cum este o     introducere \u00een C++, noi vom alege C++, fire\u0219te.</p> <p> </p> </li> <li> <p>Noi dorim s\u0103 avem un executabil, deci vom alege op\u021biunea corespunz\u0103toare.</p> <p> </p> </li> <li> <p>Niciuna din aceste op\u021biuni (CPack sau CTest) nu ne este relevant\u0103, deci nu     alegem niciuna \u0219i trecem mai departe.</p> <p> </p> </li> <li> <p>Alegem fi\u0219ierele pe care dorim s\u0103 le avem \u00een target. \u00cen cele mai multe     cazuri, va fi doar un singur fi\u0219ier, probabil numit <code>main.cpp</code>. Este     important s\u0103 existe acest fi\u0219ier \u00eenainte de a folosi Quick Start.</p> <p> </p> </li> <li> <p>\u00cen aceast\u0103 faz\u0103 trebuie s\u0103 configur\u0103m un preset. \u00cen acest caz, este un     preset de configurare, care \u00eei zice lui CMake cum s\u0103 configureze proiectul     nostru. Printre altele, dicteaz\u0103 generatorul, fi\u0219ierul de toolchain (care     detecteaz\u0103 efectiv care este compilatorul \u0219i face disponibile toate     fi\u0219ierele antet) \u0219i locul unde se va da build. Apas\u0103 Enter.</p> <p> </p> </li> <li> <p>Cea mai simpl\u0103 op\u021biune de a crea un preset de configurare este de la     compilator, deci vom selecta \"Create from Compilers\".</p> <p> </p> </li> <li> <p>Aici select\u0103m kit-ul nostru. \u00cen esen\u021b\u0103, un kit este un compilator. Alegem     GCC (sau Visual Studio 17 2022 x64, dac\u0103 ai instalat Visual Studio 2022     \u00eenainte).</p> <p> </p> </li> <li> <p>Acest preset are nevoie de un nume, \u00eel putem numi simplu GCC (sau MSVC, dac\u0103     ai ales VS).</p> <p> </p> </li> </ol> <p>Cel mai important fi\u0219ier este <code>CMakeLists.txt</code>. El arat\u0103 a\u0219a \u00een momentul de fa\u021b\u0103:</p> <pre><code>cmake_minimum_required(VERSION 3.5.0)\nproject(cppintro VERSION 0.1.0 LANGUAGES C CXX)\nadd_executable(cppintro main.cpp)\n</code></pre> <p>Mai trebuie s\u0103 ad\u0103ug\u0103m unele chestii. Un CMakeLists.txt adecvat arat\u0103 astfel:</p> <pre><code>cmake_minimum_required(VERSION 3.27)\nproject(cppintro VERSION 0.1.0 LANGUAGES C CXX)\nset(CMAKE_CXX_STANDARD 20)\nset(CMAKE_CXX_EXTENSIONS OFF)\nset(CMAKE_CXX_STANDARD_REQUIRED ON)\nadd_executable(${PROJECT_NAME} main.cpp)\nif (MSVC)\n    target_compile_options(${PROJECT_NAME} PUBLIC /W4 /WX)\n    target_compile_options(${PROJECT_NAME} PRIVATE $&lt;$&lt;CONFIG:Debug&gt;:/Od /Zi&gt; $&lt;$&lt;CONFIG:Release&gt;:/O2&gt;)\n    target_link_options(${PROJECT_NAME} PRIVATE $&lt;$&lt;CONFIG:Debug&gt;:/DEBUG&gt; $&lt;$&lt;CONFIG:Release&gt;:/DEBUG:NONE&gt;)\nelse()\n    target_compile_options(${PROJECT_NAME} PUBLIC -Wall -Wextra -Wpedantic -Wfloat-conversion)\n    target_compile_options(${PROJECT_NAME} PRIVATE $&lt;$&lt;CONFIG:Debug&gt;:-O0 -g&gt; $&lt;$&lt;CONFIG:Release&gt;:-O3&gt;)\nendif()\n</code></pre> <p>\u00cen esen\u021b\u0103, ce face acest CMakeLists.txt nou este c\u0103 seteaz\u0103 standardul la C++20 \u0219i \u00eel face obligatoriu, \u0219i adaug\u0103 mai multe flag-uri pentru a afi\u0219a mai multe avertiz\u0103ri (ne ajut\u0103 s\u0103 g\u0103sim erori mai devreme) \u0219i a scoate optimiz\u0103rile \u00een momentul \u00een care depan\u0103m codul.</p> <p>Acum c\u0103 avem toate astea, apas\u0103 Shift+F5 \u0219i bucur\u0103-te de executabil.</p> <p>Aici sunt mai multe scurt\u0103turi \u0219i concepte utile care te pot ajuta \u00een a configura editorul:</p> <ol> <li>Po\u021bi s\u0103 \u00ee\u021bi schimbi tema folosind \"Preferences: Color Theme\" din Command    Palette sau folosind Ctrl+K Ctrl+T. De asemenea, po\u021bi g\u0103si alte teme    interesante ca extensii.</li> <li>Pentru a accesa set\u0103rile, folose\u0219te fie Ctrl+,, fie \"Preferences:    Open Settings (UI)\" din Command Palette. Unele set\u0103ri necesit\u0103 configurare    care nu se poate face din interfa\u021b\u0103, deci avem nevoie s\u0103 modific\u0103m un fi\u0219ier    JSON. Pentru acest lucru, avem \u00een partea de sus o icoan\u0103 cu o foaie de h\u00e2rtie    \u0219i o s\u0103geat\u0103. Alternativ, po\u021bi ajunge \u00een acela\u0219i loc din Command Palette,    dac\u0103 scrii \"Preferences: Open User Settings (JSON)\".      </li> <li>Din set\u0103ri, po\u021bi ajusta fontul. Adaug\u0103 fonturile pe care vrei s\u0103 le ai, \u00een    ordinea descresc\u0103toare a preferin\u021bei. Dac\u0103 numele fontului are spa\u021biu,    trebuie s\u0103 pui \u00eentre ghilimele. De asemenea, po\u021bi modifica \u0219i m\u0103rimea    fontului, \u00een func\u021bie de preferin\u021be.</li> <li>Recomand s\u0103 activezi func\u021bia de auto-save. Aceasta \u00ee\u021bi salveaz\u0103 automat    codul. Seteaz\u0103-l pe afterDelay.</li> <li>Pentru a ascunde bara lateral\u0103, apas\u0103 Ctrl+B. Pentru a o aduce \u00eenapoi,    apas\u0103 aceea\u0219i scurt\u0103tur\u0103. Poate fi util \u00een cazul \u00een care lucrezi pe jum\u0103tate    din ecran sau dac\u0103 vrei s\u0103 ai mai mult loc.</li> <li>Po\u021bi ap\u0103sa F11 pentru a face editorul s\u0103 fie fullscreen. Un efect    secundar este c\u0103 dispare bara de meniu, dar este \u00een regul\u0103. Pentru a ie\u0219i din    modul fullscreen, apas\u0103 din nou F11.</li> <li>Uneori, \u0219i modul fullscreen are prea multe distrageri. Po\u021bi activa modul Zen    cu Ctrl+K, Z pentru a ascunde tot \u00een afar\u0103 de editor.</li> <li>Po\u021bi s\u0103 \u00eempar\u021bi editorul \u00een dou\u0103 folosind fie butonul dedicat din bara de    tab-uri (arat\u0103 ca un p\u0103trat \u00eemp\u0103r\u021bit \u00een dou\u0103), fie cu Ctrl+\\.    Alternativ, po\u021bi trage un fi\u0219ier \u00een editor \u0219i vei avea o indica\u021bie vizual\u0103.</li> <li>Pentru a ne asigura c\u0103 avem un stil consistent, putem l\u0103sa Visual Studio Code    s\u0103 formateze codul. Pentru acest lucru, putem ap\u0103sa Shift+Alt+F. Dac\u0103 nu    e\u0219ti sigur de scurt\u0103tura pe platforma ta, po\u021bi c\u0103uta \"Format Document\" din    Command Palette.</li> <li>Uneori, ai nevoie s\u0103 cau\u021bi un \u0219ir \u00eentr-un fi\u0219ier. Pentru acest lucru, apas\u0103    Ctrl+F (sau Ctrl+Shift+F pentru a c\u0103uta \u00een toate fi\u0219ierele). Dac\u0103 \u00een    loc de F ape\u0219i H \u00een combina\u021biile respective, po\u021bi s\u0103 \u0219i \u00eenlocuie\u0219ti    text.</li> <li>La capitolul de c\u0103utat fi\u0219iere, dac\u0103 ape\u0219i Ctrl+P, po\u021bi s\u0103 cau\u021bi numele     unui fi\u0219ier. Dac\u0103 adaugi <code>:</code>, po\u021bi s\u0103 sari la o linie anume \u00een fi\u0219ierul     curent (de pild\u0103, \u00een cazul unei erori de la compilator) sau la un simbol     anume cu <code>@</code> (dac\u0103 trebuie s\u0103 ajungi la o variabil\u0103 sau la o func\u021bie anume).</li> <li>Deseori vei avea nevoie s\u0103 modifici \u00een mai multe locuri simultan. Visual     Studio Code are suport nativ pentru mai multe cursoare. Pentru a crea mai     multe cursoare, apas\u0103 Ctrl+Alt+Up (sau Ctrl+Alt+Down).</li> <li>Pentru a selecta cuv\u00e2ntul curent, apas\u0103 Ctrl+D. Po\u021bi s\u0103 ape\u0219i de mai     multe ori pentru a g\u0103si mai multe apari\u021bii.</li> </ol> <p>Sfat</p> <p>Sunt at\u00e2tea set\u0103ri pe care le po\u021bi modifica \u0219i at\u00e2tea extensii pe care s\u0103 le po\u021bi instala, \u00eens\u0103 recomand s\u0103 \u00eenve\u021bi mai multe scurt\u0103turi pentru ac\u021biuni pe care le faci \u00een mod comun. Dac\u0103 folose\u0219ti mai mult tastatura, devii mai  eficient pentru c\u0103 nu este nevoie s\u0103 \u00ee\u021bi mu\u021bi m\u00e2na spre mouse. </p> <p>Asta este tot cu configurarea. Po\u021bi acum s\u0103 mergi c\u0103tre urm\u0103torul articol:</p> <p>Mergi la introducere</p>"},{"location":"dificil/centroid-decomposition/","title":"Alte probleme \u0219i resurse utile","text":"<ul> <li>Centroid Decomposition</li> </ul>"},{"location":"dificil/componente-biconexe/","title":"Componente biconexe","text":"<p>Autor: \u0218tefan-Cosmin D\u0103sc\u0103lescu</p> <p>\u00cen cele ce urmeaz\u0103, vom prezenta componentele biconexe, algoritmul prin care le afl\u0103m \u0219i cum putem folosi aceste informa\u021bii \u00een probleme. </p>","tags":["grafuri neorientate","programare dinamica","parcurgeri","cicluri"]},{"location":"dificil/componente-biconexe/#introducere","title":"Introducere","text":"<p>\u00cen cele ce urmeaz\u0103, vom prezenta componentele biconexe, elementele principale asociate componentelor biconexe \u0219i cum putem implementa algoritmul specific pentru aflarea lor. De asemenea, vom prezenta \u0219i alte tehnici asociate, \u00eempreun\u0103 cu probleme exemplu. </p> <p>Ca \u0219i cuno\u0219tin\u021be necesare pentru \u00een\u021belegerea componentelor biconexe, se recomand\u0103 studiul parcurgerii grafurilor \u0219i dinamicilor pe arbore. </p> <p>Defini\u021bie</p> <p>\u00centr-un graf neorientat, componentele biconexe sunt submul\u021bimi maximale de noduri cu proprietatea c\u0103 pentru oricare pereche de noduri \\((a, b)\\) care apar\u021bin unei astfel de componente, se poate ajunge de la \\(a\\) la \\(b\\) chiar \u0219i dac\u0103 scoatem un nod din graful rezultat.</p> <p>Observa\u021bie</p> <p>Se poate observa c\u0103 componentele biconexe sunt o versiune mai avansat\u0103 a componentelor conexe, prelucrarea lor va fi una mai specific\u0103 \u0219i a\u0219a cum ve\u021bi vedea \u00een acest articol, destul de u\u0219or de aplicat dup\u0103 c\u00e2teva exemple explicate.</p> <p>Exemplu</p> <p>De exemplu, dac\u0103 avem urm\u0103torul graf: \\(n = 8\\), \\(m = 9\\) \u0219i urm\u0103toarele muchii de tip \\((a, b)\\): \\((1, 2), (2, 3), (3, 4), (4, 1), (1, 5), (5, 6), (6, 7), (7, 5), (7, 8)\\), componentele biconexe sunt \\(\\{1, 2, 3, 4\\}\\), \\(\\{7, 8\\}\\), \\(\\{5, 6, 7\\}\\) \u0219i \\(\\{1, 5\\}\\). Mai jos g\u0103si\u021bi un desen reprezentativ.  </p> <p></p> <p>Pentru aflarea componentelor biconexe, exist\u0103 mai multe metode de a le afla, dar aici vom prezenta una dintre ele, care se bazeaz\u0103 pe o parcurgere DFS \u0219i \u00eemp\u0103r\u021birea muchiilor \u00een dou\u0103 categorii, cre\u00e2ndu-se ceea ce vom numi un arbore DFS.</p>","tags":["grafuri neorientate","programare dinamica","parcurgeri","cicluri"]},{"location":"dificil/componente-biconexe/#arborele-dfs-dfs-tree","title":"Arborele DFS (DFS Tree)","text":"<p>Observa\u021bie</p> <p>Recomand\u0103m \u00een mod special acest blog de pe Codeforces pentru \u00een\u021belegerea conceptului \u0219i chiar pentru explica\u021bii suplimentare pentru unele con\u021binuturi care vor fi prezentate ulterior \u00een acest articol.</p> <p>Defini\u021bie</p> <p>Un arbore DFS este un arbore pe care \u00eel ob\u021binem parcurg\u00e2nd un graf neorientat folosind o parcurgere DFS, dac\u0103 p\u0103str\u0103m doar muchiile care au fost folosite pentru a apela DFS din noduri noi. </p> <p>Deoarece grafurile cu care lucr\u0103m nu sunt arbori, se impune \u00eemp\u0103r\u021birea muchiilor grafului \u00een func\u021bie de apartenen\u021ba la arborele DFS. </p> <p>Defini\u021bie</p> <p>Muchiile care nu apar\u021bin arborelui DFS, dar apar\u021bin grafului ini\u021bial reprezint\u0103 muchii de \u00eentoarcere. </p> <p>Observa\u021bie</p> <p>Se poate observa c\u0103 \u00een func\u021bie de ordinea \u00een care se realizeaz\u0103 parcurgerea DFS, unele muchii principale pot deveni muchii de \u00eentoarcere \u0219i invers, dar exist\u0103 muchii care nu vor fi niciodat\u0103 muchii de \u00eentoarcere, acestea devenind subiectul nostru de discu\u021bie ulterior \u00een articol. </p> <p>\u00cen desenul de mai jos, muchiile \u00eengro\u0219ate reprezint\u0103 arborele DFS. Muchiile care nu sunt \u00eengro\u0219ate reprezint\u0103 muchiile de \u00eentoarcere. </p> <p></p>","tags":["grafuri neorientate","programare dinamica","parcurgeri","cicluri"]},{"location":"dificil/componente-biconexe/#elemente-esentiale","title":"Elemente esen\u021biale","text":"<p>\u00cen cele ce urmeaz\u0103, vom prezenta c\u00e2teva dintre cele mai importante no\u021biuni care se reg\u0103sesc atunci c\u00e2nd lucr\u0103m cu componente biconexe. </p>","tags":["grafuri neorientate","programare dinamica","parcurgeri","cicluri"]},{"location":"dificil/componente-biconexe/#muchii-critice","title":"Muchii critice","text":"<p>Muchiile critice (numite \u00een englez\u0103 bridges) reprezint\u0103 muchiile care dac\u0103 le scoatem din graf, acesta nu va mai fi conex. Un astfel de exemplu \u00een desenul de mai sus este muchia \\((2, 4)\\).</p> <p>Observa\u021bie</p> <p>O muchie de \u00eentoarcere nu va fi niciodata o muchie critic\u0103, arborele DFS s-a putut construi deja f\u0103r\u0103 ea. </p>","tags":["grafuri neorientate","programare dinamica","parcurgeri","cicluri"]},{"location":"dificil/componente-biconexe/#puncte-de-articulatie","title":"Puncte de articula\u021bie","text":"<p>Punctele de articula\u021bie reprezint\u0103 nodurile care dac\u0103 le scoatem din graf, acesta nu va mai fi conex. Un astfel de exemplu \u00een desenul de mai sus este nodul \\(9\\).</p>","tags":["grafuri neorientate","programare dinamica","parcurgeri","cicluri"]},{"location":"dificil/componente-biconexe/#algoritmul-de-aflare-a-componentelor-biconexe","title":"Algoritmul de aflare a componentelor biconexe","text":"<p>Pentru a afla componentele biconexe, precum \u0219i celelalte valori relevante (muchiile critice \u0219i punctele de articula\u021bie), vom folosi un algoritm bazat pe o parcurgere DFS \u0219i o abordare specific\u0103 program\u0103rii dinamice. </p> <p>\u00cen primul r\u00e2nd, vom avea nevoie s\u0103 \u0219tim pentru fiecare nod, nivelul la care se afl\u0103 conform arborelui DFS, lucru ce se poate afla foarte u\u0219or. </p> <p>\u00cen al doilea r\u00e2nd, \u0219i poate cel mai important aspect al acestui algoritm, reprezint\u0103 recuren\u021ba prin care afl\u0103m pentru fiecare nod care este cel mai mic nivel pe care \u00eel putem accesa folosind nodurile din subarborele s\u0103u, \u00eempreun\u0103 cu muchiile de \u00eentoarcere ale nodurilor din acesta, recuren\u021b\u0103 care va fi numit\u0103 \\(low\\). </p> <p>Pentru a calcula valoarea lui \\(low\\) pentru fiecare nod, ne vom folosi de valorile lui \\(low\\) calculate pentru fiecare fiu al nodului curent, \u00eempreun\u0103 cu nivelele la care se afl\u0103 nodurile din muchiile de \u00eentoarcere corespunz\u0103toare nodului curent. Cu alte cuvinte, aceast\u0103 recuren\u021b\u0103 este foarte similar\u0103 cu alte recuren\u021be cu care sunte\u021bi obi\u0219nui\u021bi de la dinamicile pe arbore, scopul acesteia reprezint\u0103 aflarea nivelului la care se afl\u0103 cel mai apropiat nod de r\u0103d\u0103cin\u0103 pe care \u00eel putem accesa. </p> <p>Un alt aspect de implementare foarte important reprezint\u0103 memorarea nodurilor \u00eentr-o stiv\u0103, \u00een ordinea \u00een care au fost accesate, scopul fiind acela de a identifica componentele biconexe, deoarece de fiecare dat\u0103 c\u00e2nd d\u0103m de un punct de articula\u021bie, putem separa nodurile ce fac parte din componenta biconex\u0103 curent\u0103 de restul grafului, \u00een ordinea invers\u0103 celei \u00een care au fost ad\u0103ugate \u00een stiv\u0103.</p>","tags":["grafuri neorientate","programare dinamica","parcurgeri","cicluri"]},{"location":"dificil/componente-biconexe/#implementare","title":"Implementare","text":"<p>Pentru a implementa acest algoritm, tot ce trebuie s\u0103 facem este s\u0103 aplic\u0103m pa\u0219ii de mai sus, aten\u021bia la implementare fiind necesar\u0103. </p> <p>Pentru a afla punctele de articula\u021bie, avem dou\u0103 cazuri care trebuie avute \u00een vedere:</p> <ul> <li>Fie nodul este r\u0103d\u0103cina \u0219i are cel pu\u021bin doi copii</li> <li>Fie nodul nu este r\u0103d\u0103cina, iar unul din copii are valoarea lui \\(low\\) mai mare sau egal\u0103 dec\u00e2t cea a nivelului nodului curent.</li> </ul> <p>Pentru a afla muchiile critice, trebuie s\u0103 g\u0103sim leg\u0103turile de tip \\((a, b)\\) astfel \u00eenc\u00e2t \\(low[b] = niv[a]\\).</p> <p>Implementarea de mai jos este bazat\u0103 pe problema Strongly Connected Edges, unde ne baz\u0103m pe diferen\u021bele dintre nivelurile nodurilor pentru a fixa direc\u021biile muchiilor.</p> <pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n\nint n, m, cnt;\nvector&lt;vector&lt;int&gt; &gt; v;\n\nvector&lt;int&gt; vis, lvl, low;\ndeque&lt;int&gt; d;\n\nset&lt;pair&lt;int, int&gt; &gt; edges; // pentru a fixa directiile\n\nvector&lt;vector&lt;int&gt; &gt; bccs;\n\nvoid dfs (int parent, int node) {\n    vis[node] = 1;\n    low[node] = lvl[node];\n    d.push_back(node);\n\n    bool articulation = 0;\n\n    int children = 0;\n    for (int i = 0; i &lt; (int) v[node].size(); ++i) {\n        int nxt = v[node][i];\n        if (nxt == parent) {\n            continue;\n        }\n        if (vis[nxt]) {\n            low[node] = min(low[node], lvl[nxt]);\n\n            if (lvl[node] &gt; lvl[nxt]) {\n                edges.insert({node, nxt});\n            }\n            else {\n                edges.insert({nxt, node});\n            }\n            continue;\n        }\n\n        lvl[nxt] = lvl[node] + 1;\n        children++;\n        dfs(node, nxt);\n        low[node] = min(low[node], low[nxt]);\n\n        if (lvl[node] &lt; lvl[nxt]) {\n            edges.insert({node, nxt});\n        }\n        else {\n            edges.insert({nxt, node});\n        }\n\n        if (low[nxt] &gt;= lvl[node]) {\n            cnt++;\n\n            if (parent != 0) {\n                articulation = 1;\n            }\n            int lst;\n            do\n            {\n                lst = d.back();\n                sol[cmt].push_back(d.back());\n                d.pop_back();\n            }while(!d.empty() &amp;&amp; lst != nxt);\n        }\n\n        if (low[nxt] &gt; lvl[node]) {\n            // muchiile critice sunt intre nod si nxt\n            cout &lt;&lt; \"IMPOSSIBLE\\n\";\n            exit(0);\n        }\n    }\n\n    if (parent == 0 &amp;&amp; children &gt;= 2) {\n        articulation = 1;\n    }\n}\nint main()\n{\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n\n    cin &gt;&gt; n &gt;&gt; m;\n\n    v.resize(n+1); vis.resize(n+1);\n    lvl.resize(n+1); low.resize(n+1);\n\n    for (int i = 1; i &lt;= m; ++i) {\n        int a, b;\n        cin &gt;&gt; a &gt;&gt; b;\n        v[a].push_back(b);\n        v[b].push_back(a);\n    }\n\n    dfs(0, 1);\n\n    if (edges.size() != m) {\n        cout &lt;&lt; \"IMPOSSIBLE\\n\";\n        return 0;\n    }\n\n    for (auto x : edges) {\n        cout &lt;&lt; x.first &lt;&lt; \" \" &lt;&lt; x.second &lt;&lt; '\\n';\n    }\n    return 0;\n}\n</code></pre>","tags":["grafuri neorientate","programare dinamica","parcurgeri","cicluri"]},{"location":"dificil/componente-biconexe/#concluzii","title":"Concluzii","text":"<p>Componentele biconexe, la fel ca \u0219i componentele tare conexe, sunt un concept al c\u0103ror implementare, odat\u0103 ce este \u0219tiut\u0103, face procesul de rezolvare al problemelor mult mai u\u0219or. Totu\u0219i, trebuie avut \u00een vedere faptul c\u0103 acestea apar de multe ori \u0219i combinate cu alte tehnici, precum programarea dinamic\u0103 sau al\u021bi algoritmi pe grafuri.</p> <p>O alt\u0103 aplica\u021bie a acestei metode reprezint\u0103 algoritmul lui Tarjan, explicat aici.</p>","tags":["grafuri neorientate","programare dinamica","parcurgeri","cicluri"]},{"location":"dificil/componente-biconexe/#probleme-suplimentare","title":"Probleme suplimentare","text":"<ul> <li>biconex infoarena</li> <li>Strongly Connected Edges - CSES</li> <li>Componente biconexe - pbinfo</li> <li>Non-academic problem - Codeforces</li> <li>CSES Forbidden Cities</li> <li>ONI 2014 clepsidra</li> <li>ONI 2022 regate</li> <li>infoarena santa</li> <li>Tourism - Codeforces</li> <li>ONI 2019 linegraph</li> <li>Tourist reform - Codeforces</li> <li>Pursuit for artifacts - Codeforces</li> <li>APIO 2018 Duathlon</li> <li>TLE 2017 Investment</li> <li>Probleme cu componente biconexe de pe Kilonova</li> </ul>","tags":["grafuri neorientate","programare dinamica","parcurgeri","cicluri"]},{"location":"dificil/componente-biconexe/#lectura-suplimentara","title":"Lectur\u0103 suplimentar\u0103","text":"<ul> <li>Biconnected Components - USACO Guide</li> <li>Biconexitate - pbinfo</li> <li>DFS Tree and Bridges - Codeforces</li> <li>Biconnected component - wikipedia</li> <li>Finding Bridges in O(n+m) - cpalgorithms</li> <li>Finding articulations - cpalgorithms</li> </ul>","tags":["grafuri neorientate","programare dinamica","parcurgeri","cicluri"]},{"location":"dificil/componente-tare-conexe/","title":"Componente tare conexe","text":"<p>Autor: \u0218tefan-Cosmin D\u0103sc\u0103lescu</p>","tags":["grafuri orientate","parcurgeri","cicluri"]},{"location":"dificil/componente-tare-conexe/#introducere","title":"Introducere","text":"<p>\u00cen cele ce urmeaz\u0103, vom prezenta componentele tare conexe, algoritmii principali \u0219i cum \u00eei putem aplica. </p> <p>Defini\u021bie</p> <p>\u00centr-un graf orientat, componentele tare conexe sunt submul\u021bimi maximale de noduri cu proprietatea c\u0103 pentru oricare pereche de noduri \\((a, b)\\) care apar\u021bin unei astfel de componente, se poate ajunge \u0219i de la \\(a\\) la \\(b\\), \u0219i de la \\(b\\) la \\(a\\) folosind muchiile existente. </p> <p>Observa\u021bie</p> <p>Se poate observa c\u0103 componentele tare conexe sunt versiunea componentelor conexe pentru grafurile orientate. De\u0219i defini\u021biile sunt similare, se va observa c\u0103 aflarea lor va fi mai dificil\u0103 dec\u00e2t cea a componentelor conexe, care const\u0103 \u00eentr-o simpl\u0103 parcurgere. </p> <p>Exemplu</p> <p>De exemplu, dac\u0103 avem urm\u0103torul graf: \\(n = 8\\), \\(m = 12\\) \u0219i urm\u0103toarele muchii de tip \\((a, b)\\): \\((1, 2), (2, 6), (6, 7), (7, 6), (3, 1), (3, 4), (2, 3), (4, 5), (5, 4), (6, 5), (5, 8), (8, 7)\\), componentele tare conexe sunt \\(\\{1, 2, 3\\}\\) \u0219i \\(\\{4, 5, 6, 7, 8\\}\\). Mai jos g\u0103si\u021bi un desen reprezentativ.  </p> <p></p> <p>Pentru aflarea componentelor tare conexe, exist\u0103 doi algoritmi la fel de eficien\u021bi, algoritmul lui Tarjan \u0219i algoritmul lui Kosaraju, ambii fiind algoritmi ce ruleaz\u0103 \u00een timp liniar. </p> <p>\u00cen general, deoarece nu exist\u0103 vreo diferen\u021b\u0103 \u00eentre ei \u00een practic\u0103, se prefer\u0103 folosirea algoritmului lui Kosaraju, deoarece este mai u\u0219or de \u021binut minte \u0219i poate fi aplicat foarte u\u0219or \u00een aplica\u021biile viitoare. </p>","tags":["grafuri orientate","parcurgeri","cicluri"]},{"location":"dificil/componente-tare-conexe/#algoritmul-lui-kosaraju","title":"Algoritmul lui Kosaraju","text":"<p>Algoritmul lui Kosaraju este un algoritm care se va baza pe dou\u0103 parcurgeri de tip DFS, una pe graful ini\u021bial \u0219i cealalt\u0103 pe graful transpus pentru a afla componentele tare conexe. </p> <p>Graf transpus</p> <p>\u00centr-un graf orientat, un graf transpus \\(G'\\) este un graf care are proprietatea c\u0103 pentru fiecare muchie \\((a, b)\\) care se afl\u0103 \u00een \\(G\\), \\(G'\\) va con\u021bine muchia \\((a, b)\\). Cu alte cuvinte, muchiile sunt inversate. Pentru mai multe informa\u021bii, pute\u021bi accesa acest link.</p> <p>Pe scurt, algoritmul va parcurge mai \u00eent\u00e2i nodurile \u00eentr-o manier\u0103 similar\u0103 cu cea de la algoritmul pentru aflarea componentelor conexe, singura diferen\u021b\u0103 fiind aceea c\u0103 la finalizarea pa\u0219ilor efectua\u021bi \u00een func\u021bie pentru un nod dat, acesta va fi ad\u0103ugat \u00eentr-o stiv\u0103. </p> <p>Ulterior, nodurile din stiv\u0103 vor fi luate pe r\u00e2nd, iar pentru fiecare nod nevizitat la acest pas, vom avea o parcurgere similar\u0103 cu cea de la primul pas, parcurgere efectuat\u0103 pe graful transpus care ne va da componentele tare conexe, acelea fiind cele care sunt vizitate de nodul curent la pasul dat. </p> <p>Acest algoritm are complexitate \\(O(n)\\) \u0219i implementarea lui, folosit\u0103 la problema Planets and Kingdoms poate fi citit\u0103 mai jos:</p> <pre><code>#include &lt;iostream&gt;\n#include &lt;vector&gt;\n#include &lt;stack&gt;\n\nusing namespace std;\n\nstack&lt;int&gt;s;\n\nvoid dfs (int node, vector&lt;vector&lt;int&gt;&gt; &amp;v, vector&lt;int&gt; &amp;vis) {\n    vis[node] = 1;\n    for (int j = 0; j &lt; (int) v[node].size(); ++j) {\n        int nxt = v[node][j];\n        if (!vis[nxt]) {\n            dfs(nxt, v, vis);\n        }\n    }\n    s.push(node);\n}\nvoid dfs2 (int node, int cnt, vector&lt;vector&lt;int&gt;&gt; &amp;tr, vector&lt;int&gt; &amp;vis2, vector&lt;int&gt; &amp;scc)\n{\n    vis2[node] = 1;\n    scc[node] = cnt;\n    for (int j = 0; j &lt; (int) tr[node].size(); ++j) {\n        int nxt = tr[node][j];\n        if (!vis2[nxt]) {\n            dfs2(nxt, cnt, tr, vis2, scc);\n        }\n    }\n}\n\nint main() {\n    int n, m;\n    cin &gt;&gt; n &gt;&gt; m;\n\n    vector&lt;int&gt; vis(n+1), vis2(n+1), scc(n+1);\n    vector&lt;vector&lt;int&gt;&gt; v(n+1), tr(n+1);\n\n    for (int i = 1; i &lt;= m; ++i) {\n        int a, b;\n        cin &gt;&gt; a &gt;&gt; b;\n        v[a].push_back(b);\n        tr[b].push_back(a);\n    }\n    for (int i = 1; i &lt;= n; ++i) {\n        if (!vis[i]) {\n            dfs(i, v, vis);\n        }\n    }\n\n    int cnt = 0;\n    while (!s.empty()) {\n        int node = s.top();\n        s.pop();\n        if (!vis2[node]) {\n            ++cnt;\n            dfs2(node, cnt, tr, vis2, scc);\n        }\n    }\n    cout &lt;&lt; cnt &lt;&lt; '\\n';\n    for (int i = 1; i &lt;= n; ++i) {\n        cout &lt;&lt; scc[i] &lt;&lt; \" \";\n    }\n    return 0;\n}\n</code></pre>","tags":["grafuri orientate","parcurgeri","cicluri"]},{"location":"dificil/componente-tare-conexe/#algoritmul-lui-tarjan","title":"Algoritmul lui Tarjan","text":"<p>Ideea de baz\u0103 a algoritmului este urm\u0103toarea: Se \u00eencepe cu o parcurgere DFS dintr-un nod oarecare (parcurgerile viitoare vor fi efectuate pe noduri care nu au fost vizitate \u00eenc\u0103). Aceste parcurgeri ne vor oferi ni\u0219te arbori par\u021biali, construi\u021bi din muchiile care au fost folosite pentru a vizita nodurile \u00een cauz\u0103. </p> <p>Pentru a afla componentele tare conexe, ne vom folosi de arborii crea\u021bi pentru a g\u0103si subarbori care vor avea proprietatea c\u0103 nivelul minim la care se poate ajunge folosind muchiile de \u00eentoarcere este egal cu nivelul nodului curent, unde nivelul nodului este num\u0103rul s\u0103u de ordine din parcurgerea DFS. Un tutorial foarte bun poate fi accesat aici.</p> <p>Pentru cei familiariza\u021bi \u0219i cu componentele biconexe, se vor putea observa destule similarit\u0103\u021bi \u00eentre algoritmul acesta \u0219i cel de la componentele biconexe, ambii fiind inventa\u021bi de Tarjan. Mai jos pute\u021bi g\u0103si o solu\u021bie care rezolv\u0103 aceea\u0219i problem\u0103 de mai sus. </p> <pre><code>#include &lt;iostream&gt;\n#include &lt;vector&gt;\n#include &lt;stack&gt;\n\nusing namespace std;\n\nvector&lt;vector&lt;int&gt;&gt; graph;\nvector&lt;int&gt; idx, lowlink, instack, scc;\nint ptr, ncomp;\n\nstack&lt;int&gt; stk;\n\nvoid dfs(int node) {\n    int aux;\n\n    lowlink[node] = idx[node] = ++ptr;\n    instack[node] = 1;\n    stk.push(node);\n\n    for (int i = 0; i &lt; (int)graph[node].size(); i++) {\n        int nxt = graph[node][i];\n        if (idx[nxt] == 0) {\n            dfs(nxt);\n            lowlink[node] = min(lowlink[node], lowlink[nxt]);\n        } else if (instack[graph[node][i]]) {\n            lowlink[node] = min(lowlink[node], lowlink[nxt]);\n        }\n    }\n\n    if (idx[node] == lowlink[node]) {\n        do {\n            aux = stk.top();\n            stk.pop();\n            instack[aux] = 0;\n            scc[aux] = ncomp;\n        } while (aux != node);\n        ncomp++;\n    }\n}\n\nint solve(int n) {\n    idx.resize(n+1, 0);\n    instack.resize(n+1, 0);\n    lowlink.resize(n+1, 0);\n    scc.resize(n+1, 0);\n\n    for (int i = 1; i &lt;= n; i++) {\n        if (idx[i] == 0) {\n            dfs(i);\n        }\n    }\n    return ncomp;\n}\n\nint main() {\n\n    int n, m;\n    cin &gt;&gt; n &gt;&gt; m;\n\n    graph.resize(n+1);\n\n    for (int i = 1; i &lt;= m; i++) {\n        int a, b;\n        cin &gt;&gt; a &gt;&gt; b;\n        graph[a].push_back(b);\n    }\n\n    cout &lt;&lt; solve(n) &lt;&lt; '\\n';\n    for (int i = 1; i &lt;= n; i++) {\n        cout &lt;&lt; scc[i]+1 &lt;&lt; \" \";\n    }\n    return 0;\n}\n</code></pre>","tags":["grafuri orientate","parcurgeri","cicluri"]},{"location":"dificil/componente-tare-conexe/#aplicatii","title":"Aplica\u021bii","text":"<p>De regul\u0103, componentele tare conexe apar destul de rar \u00een probleme de sine st\u0103t\u0103toare, din cauza faptului c\u0103 cunoa\u0219terea lor ar face diferen\u021ba dintre cei care ar lua punctajul maxim \u0219i cei care nu ar lua puncte. Totu\u0219i, se poate remarca prezen\u021ba lucrului cu componentele tare conexe \u00een unele dinamici pe grafuri, \u00een care putem folosi o proprietate foarte important\u0103, pe care o vom enun\u021ba mai jos. </p> <p>Compresarea componentelor tare conexe</p> <p>Dac\u0103 compres\u0103m componentele tari conexe \u00eentr-un singur nod, noul graf rezultat devine aciclic, fapt care ne ajut\u0103 s\u0103 aplic\u0103m dinamicile specifice grafurilor orientate aciclice. </p> <p>Observa\u021bie</p> <p>Algoritmul lui Kosaraju ne ofer\u0103 componentele tare conexe \u00een ordinea sort\u0103rii topologice din graful rezultat. </p>","tags":["grafuri orientate","parcurgeri","cicluri"]},{"location":"dificil/componente-tare-conexe/#problema-coin-collector","title":"Problema Coin Collector","text":"<p>Pentru a rezolva aceast\u0103 problem\u0103, va trebui s\u0103 afl\u0103m componentele tare conexe, iar mai apoi, s\u0103 le compres\u0103m folosind unul din algoritmii descri\u0219i mai sus. Ulterior, vom construi noul graf \u0219i vom aplica o sortare topologic\u0103 pe noul graf rezultat, \u021bin\u00e2nd o dinamic\u0103, \u00een care vom \u0219ti pentru fiecare component\u0103 tare conex\u0103, suma maxim\u0103 a costurilor ce pot fi luate pe un asemenea drum.</p> <p>Solu\u021bia va fi din nou, una liniar\u0103 raportat\u0103 la dimensiunile grafului. </p> <pre><code>#include &lt;iostream&gt;\n#include &lt;vector&gt;\n#include &lt;stack&gt;\n#include &lt;queue&gt;\n\nusing namespace std;\n\nstack&lt;int&gt; s;\n\nvoid dfs (int node, vector&lt;vector&lt;int&gt;&gt; &amp;v, vector&lt;int&gt; &amp;vis) {\n    vis[node] = 1;\n    for (int j = 0; j &lt; (int) v[node].size(); ++j) {\n        int nxt = v[node][j];\n        if (!vis[nxt]) {\n            dfs(nxt, v, vis);\n        }\n    }\n    s.push(node);\n}\nvoid dfs2 (int node, int cnt, vector&lt;vector&lt;int&gt;&gt; &amp;tr, vector&lt;int&gt; &amp;vis2, vector&lt;int&gt; &amp;scc)\n{\n    vis2[node] = 1;\n    scc[node] = cnt;\n    for (int j = 0; j &lt; (int) tr[node].size(); ++j) {\n        int nxt = tr[node][j];\n        if (!vis2[nxt]) {\n            dfs2(nxt, cnt, tr, vis2, scc);\n        }\n    }\n}\n\nint main() {\n    int n, m;\n    cin &gt;&gt; n &gt;&gt; m;\n\n    vector&lt;long long&gt; vals(n+1), sum(n+1), dp(n+1);\n    for (int i = 1; i &lt;= n; i++) {\n        cin &gt;&gt; vals[i];\n    }\n\n    vector&lt;int&gt; vis(n+1), vis2(n+1), scc(n+1);\n    vector&lt;vector&lt;int&gt;&gt; v(n+1), tr(n+1);\n\n    for (int i = 1; i &lt;= m; ++i) {\n        int a, b;\n        cin &gt;&gt; a &gt;&gt; b;\n        v[a].push_back(b);\n        tr[b].push_back(a);\n    }\n    for (int i = 1; i &lt;= n; ++i) {\n        if (!vis[i]) {\n            dfs(i, v, vis);\n        }\n    }\n\n    int cnt = 0;\n    while (!s.empty()) {\n        int node = s.top();\n        s.pop();\n        if (!vis2[node]) {\n            ++cnt;\n            dfs2(node, cnt, tr, vis2, scc);\n        }\n    }\n\n    long long ans = 0;\n\n    for (int i = 1; i &lt;= n; i++) {\n        sum[scc[i]] += vals[i];\n    }\n\n    vector&lt;vector&lt;int&gt;&gt; sccgraph(n+1);\n    vector&lt;int&gt; degree(n+1);\n    for (int i = 1; i &lt;= n; i++) {\n        for (auto nxt : v[i]) {\n            if (scc[i] != scc[nxt]) {\n                sccgraph[scc[i]].push_back(scc[nxt]);\n                degree[scc[nxt]]++;\n            }\n        }\n    }\n\n    queue&lt;int&gt; q;\n    for (int i = 1; i &lt;= cnt; i++) {\n        if (degree[i] == 0) {\n            q.push(i);\n        }\n    }\n\n    while (!q.empty()) { \n        int node = q.front();\n        q.pop();\n        dp[node] += sum[node];\n        ans = max(ans, dp[node]);\n\n        for (auto nxt : sccgraph[node]) {\n            degree[nxt]--;\n            if (degree[nxt] == 0) {\n                q.push(nxt);\n            }\n            dp[nxt] = max(dp[nxt], dp[node]);\n        }\n    }\n\n    cout &lt;&lt; ans &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["grafuri orientate","parcurgeri","cicluri"]},{"location":"dificil/componente-tare-conexe/#concluzii-si-alte-aplicatii","title":"Concluzii \u0219i alte aplica\u021bii","text":"<p>Componentele tare conexe sunt o no\u021biune fundamental\u0103 foarte important\u0103 care apare \u00een probleme la diverse competi\u021bii, dar \u00een contextul olimpiadelor, se reg\u0103sesc mai ales \u00een dinamicile pe grafuri orientate, precum \u0219i ulterior, atunci c\u00e2nd ve\u021bi studia 2-SAT, problem\u0103 ce se rezolv\u0103 cu ajutorul componentelor tare conexe generate de graful special creat din expresiile logice date. </p> <p>Se recomand\u0103 implementarea clar\u0103 a algoritmului ales (nu ave\u021bi nevoie s\u0103 \u0219ti\u021bi ambii algoritmi, dar cunoa\u0219terea ambilor e un plus) pentru a putea face rezolvarea problemelor ulterioare mai u\u0219oar\u0103.</p>","tags":["grafuri orientate","parcurgeri","cicluri"]},{"location":"dificil/componente-tare-conexe/#probleme-suplimentare","title":"Probleme suplimentare","text":"<ul> <li>ctc infoarena</li> <li>Checkposts Codeforces</li> <li>Ralph and Mushrooms Codeforces</li> <li>IIOT 2023-24 Dogtrick 2</li> <li>Transitive Graph Codeforces</li> <li>Flight Routes Check CSES</li> <li>Grass Cownoisseur USACO Gold</li> <li>obiective infoarena</li> <li>dep Baraj Seniori 2008</li> <li>network Baraj Seniori 2016</li> <li>Probleme cu componente tare conexe de pe kilonova</li> </ul>","tags":["grafuri orientate","parcurgeri","cicluri"]},{"location":"dificil/componente-tare-conexe/#lectura-suplimentara","title":"Lectur\u0103 suplimentar\u0103","text":"<ul> <li>Strongly Connected Components - USACO Guide</li> <li>Tare conexitate - pbinfo</li> <li>Strongly Connected Components - CP-algorithms</li> <li>Algoritmul lui Kosaraju - Wikipedia</li> <li>Algoritmul lui Tarjan - Codeforces</li> <li>Algoritmul lui Tarjan - Wikipedia</li> <li>Graph (IV) - slides 61-83 - HKOI</li> <li>Alt algoritm pentru componente tare conexe de la Radewoosh</li> </ul>","tags":["grafuri orientate","parcurgeri","cicluri"]},{"location":"dificil/digit-dp/","title":"Programare dinamic\u0103 pe cifre (digit DP)","text":"<p>Autor: \u0218tefan-Cosmin D\u0103sc\u0103lescu</p> <p>\u00cen acest articol vom prezenta modul \u00een care aplic\u0103m tehnica program\u0103rii dinamice atunci c\u00e2nd vine vorba de a num\u0103ra c\u00e2te numere au o anumit\u0103 proprietate \u00eentr-un interval, sau care este al \\(k\\)-lea num\u0103r cu o proprietate anume, aceast\u0103 tehnic\u0103 fiind g\u0103sit\u0103 \u0219i sub numele de dinamic\u0103 pe cifre sau digit dp. </p> <p>De\u0219i \u00een cazul unora dintre problemele pe care le vom prezenta exist\u0103 solu\u021bii folosind diverse formule matematice sau combinatoriale, ne vom concentra pe modul general de implementare a acestor probleme, mod care va fi similar \u00een cazul majorit\u0103\u021bii acestor probleme.</p> <p>\u00cen cele ce urmeaz\u0103, vom prezenta c\u00e2teva probleme care se rezolv\u0103 cu aceast\u0103 tehnic\u0103, men\u021bion\u00e2nd aspecte de implementare \u0219i tehnici pentru rezolvarea problemelor. Spre deosebire de alte varia\u021bii ale program\u0103rii dinamice, problemele ce implic\u0103 digit dp vor avea aproape mereu acela\u0219i mod de a fi abordate. </p>","tags":["programare dinamica"]},{"location":"dificil/digit-dp/#counting-numbers-cses","title":"Counting Numbers - CSES","text":"<p>Pentru a afla c\u00e2te numere din intervalul \\([a, b]\\) respect\u0103 proprietatea c\u0103 oricare dou\u0103 cifre adiacente sunt diferite, vom introduce mai \u00eent\u00e2i o proprietate foarte important\u0103:</p> <p>Observa\u021bie</p> <p>\u00cen majoritatea problemelor cu digit dp, pentru a afla r\u0103spunsul \u00een intervalul \\([a, b]\\), vom sc\u0103dea din r\u0103spunsul pentru intervalul \\([1, b]\\), r\u0103spunsul pentru intervalul \\([1, a-1]\\), \u00eentr-o manier\u0103 similar\u0103 cu cea de la sumele par\u021biale.</p> <p>\u00cen cazul acestei probleme, vom defini \\(dp[i][j]\\) drept num\u0103rul de numere cu \\(i\\) cifre care au ultima cifr\u0103 \\(j\\). \u00cen mod evident, din \\(dp[i][j]\\) vom avea tranzi\u021biile spre \\(dp[i+1][x]\\), cu proprietatea c\u0103 \\(j \\neq x\\).</p> <p>Pentru a implementa aceast\u0103 solu\u021bie, avem dou\u0103 variante principale pentru a o implementa:</p>","tags":["programare dinamica"]},{"location":"dificil/digit-dp/#prima-varianta-calcularea-separat-pentru-numerele-cu-mai-putine-cifre-si-numerele-cu-acelasi-numar-de-cifre","title":"Prima variant\u0103 - Calcularea separat pentru numerele cu mai pu\u021bine cifre \u0219i numerele cu acela\u0219i num\u0103r de cifre","text":"<p>A\u0219a cum este sugerat \u0219i \u00een titlu, vom afla cifrele num\u0103rului, iar mai apoi vom avea de f\u0103cut doi pa\u0219i: </p> <ul> <li>Mai \u00eent\u00e2i, vom ini\u021bializa st\u0103rile pentru prima cifr\u0103 \u0219i vom extinde calculele pentru numerele cu cel mult \\(x-1\\) cifre, unde \\(x\\) este num\u0103rul de cifre al num\u0103rului dat.</li> <li>Apoi, vom fixa cifra care va reprezenta departajarea dintre numere \u0219i vom calcula pentru fiecare interval generat separat. De exemplu, dac\u0103 \\(n = 90124\\), aceste intervale ar fi \\([10000, 89999]\\), \\([90000, 90099]\\), \\([90100, 90119]\\), \\([90120, 90123]\\), \\([90124, 90124]\\). Cu alte cuvinte, fiecare cifr\u0103 nenul\u0103 va crea un nou interval, iar la final, vom calcula r\u0103spunsul \u0219i pentru num\u0103rul dat. </li> </ul> <p>Aici pute\u021bi g\u0103si implementarea, care acoper\u0103 ambele p\u0103r\u021bi ale algoritmului descris. </p> <pre><code>#include &lt;iostream&gt;\n#include &lt;vector&gt;\n#include &lt;algorithm&gt;\n\nusing namespace std;\n\nlong long solve (long long n) {\n    if(n &lt;= 9) {\n        return n+1;\n    }\n\n    vector&lt;int&gt; d; // cifrele lui n\n    long long n2 = n;\n    while(n2) {\n        d.push_back(n2%10);\n        n2 /= 10;\n    }   \n    reverse(d.begin(), d.end());\n\n    long long ans = 1;\n\n    vector&lt;vector&lt;long long&gt; &gt; dp(20, vector&lt;long long&gt; (10));\n\n    // lucram cu numerele cu mai putine cifre ca n\n\n    for (int i = 1; i &lt;= 9; ++i) {\n        dp[1][i] = 1;\n    }\n\n    for (int pos = 2; pos &lt; (int) d.size(); ++pos) {\n        for (int digit = 0; digit &lt;= 9; ++digit) {\n            for (int nxt = 0; nxt &lt;= 9; ++nxt) {\n                if (digit == nxt) {\n                    continue;\n                }\n                dp[pos][nxt] += dp[pos-1][digit];\n            }\n        }\n    }\n\n    for (int pos = 1; pos &lt; (int) d.size(); ++pos) {\n        for (int digit = 0; digit &lt;= 9; ++digit) {\n            ans += dp[pos][digit];\n        }\n    }\n\n    for (int i = 0; i &lt; 20; i++) {\n        for (int j = 0; j &lt; 10; j++) {\n            dp[i][j] = 0;\n        }\n    }\n\n    // fixam prefixul pentru numerele cu acelasi numar de cifre ca n\n\n    bool ok = 1; \n\n    for (int prf = 0; prf &lt; (int) d.size(); ++prf) {\n        // daca proprietatea nu mai este respectata, oprim algoritmul\n        if (prf &gt;= 2 &amp;&amp; d[prf-1] == d[prf-2]) {\n            ok = 0;\n            break;\n        }\n\n        if(prf == 0) {\n            for (int dg = 1; dg &lt; d[prf]; ++dg) {\n                dp[prf+1][dg] = 1;\n            }\n        }\n        else {\n            for (int dg = 0; dg &lt; d[prf]; ++dg) {\n                if (dg != d[prf-1]) {\n                    dp[prf+1][dg] = 1;\n                }\n            }\n        }\n\n        for (int pos = 2; pos &lt;= (int) d.size(); ++pos) {\n            for (int digit = 0; digit &lt; 10; ++digit) {\n                for (int nxt = 0; nxt &lt; 10; ++nxt) {\n                    if (digit == nxt) {\n                        continue;\n                    }\n                    dp[pos][nxt] += dp[pos-1][digit];\n                }\n            }\n        }\n\n        for (int digit = 0; digit &lt;= 9; ++digit) {\n            ans += dp[d.size()][digit];\n        }\n\n        for (int i = 0; i &lt; 20; i++) {\n            for (int j = 0; j &lt; 10; j++) {\n                dp[i][j] = 0;\n            }\n        }\n    }\n\n    // verificam proprietatea pentru n\n    if (d[(int) d.size() - 2] == d[(int) d.size() - 1]) {\n        ok = 0;\n    }\n\n    return ans + ok;\n}\n\nint main() {\n\n    long long a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; solve(b) - solve(a-1) &lt;&lt; '\\n'; // [a, b] = [0, b] - [0, a-1]\n\n    return 0;\n}\n</code></pre>","tags":["programare dinamica"]},{"location":"dificil/digit-dp/#a-doua-varianta-folosirea-unei-dimensiuni-in-plus-pentru-a-simplifica-calculele","title":"A doua variant\u0103 - Folosirea unei dimensiuni \u00een plus pentru a simplifica calculele","text":"<p>Vom introduce o a treia dimensiune, care va \u021bine pentru prefixul de p\u00e2n\u0103 acum informa\u021bii cu privire la diferen\u021ba fa\u021b\u0103 de num\u0103rul de p\u00e2n\u0103 acum (mai mare, egal sau mai mic). Se poate observa c\u0103 implementarea va fi mult mai simpl\u0103, a\u0219a cum ve\u021bi putea vedea mai jos.</p> <p>Acum, dinamica noastr\u0103 va fi de forma \\(dp[i][j][x]\\), unde \\(x\\) va fi egal cu \\(0\\), \\(1\\) sau \\(2\\) \u00een func\u021bie de prefixul de p\u00e2n\u0103 acum \u0219i prefixul lui \\(n\\). La final, vom aduna st\u0103rile corespunz\u0103toare numerelor cu mai pu\u021bine cifre \u0219i cele cu acela\u0219i num\u0103r de cifre, dar cu prefix mai mic sau egal. </p> <pre><code>#include &lt;iostream&gt;\n#include &lt;vector&gt;\n#include &lt;algorithm&gt;\n\nusing namespace std;\n\n// comparam cifrele pentru a vedea starea pe care o actualizam\nint cmp(int a, int b) {\n    if (a &lt; b) {\n        return 0;\n    }\n    if (a &gt; b) {\n        return 1;\n    }\n    return 2;\n}\n\nlong long solve (long long n) {\n    if(n &lt;= 9) {\n        return n+1;\n    }\n\n    vector&lt;int&gt; d; // cifrele lui n\n    long long n2 = n;\n    while(n2) {\n        d.push_back(n2%10);\n        n2 /= 10;\n    }   \n    reverse(d.begin(), d.end());\n\n    long long ans = 1;\n\n    vector&lt;vector&lt;vector&lt;long long&gt; &gt; &gt; dp(20, vector&lt;vector&lt;long long&gt; &gt;(10, vector&lt;long long&gt; (3)));\n\n    for (int i = 1; i &lt; 10; i++) {\n        dp[1][i][cmp(i, d[0])] = 1;\n    }\n\n    for (int i = 1; i &lt; (int) d.size(); i++) {\n        for (int curr = 0; curr &lt; 10; curr++) {\n            for (int state = 0; state &lt; 3; state++) {\n                for (int nxt = 0; nxt &lt; 10; nxt++) {\n                    if (curr == nxt) {\n                        continue;\n                    }\n                    if (state == 2) {\n                        dp[i+1][nxt][cmp(nxt, d[i])] += dp[i][curr][state];\n                    }\n                    else {\n                        dp[i+1][nxt][state] += dp[i][curr][state];\n                    }\n                }\n            }\n        }\n    }\n\n    for (int i = 1; i &lt;= (int) d.size(); i++) {\n        for (int curr = 0; curr &lt; 10; curr++) {\n            for (int state = 0; state &lt; 3; state++) {\n                if (i &lt; (int) d.size() || state != 1) {\n                    ans = ans + dp[i][curr][state];\n                }\n            }\n        }\n    }\n\n    return ans;\n}\n\nint main() {\n\n    long long a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; solve(b) - solve(a-1) &lt;&lt; '\\n'; // [a, b] = [0, b] - [0, a-1]\n\n    return 0;\n}\n</code></pre>","tags":["programare dinamica"]},{"location":"dificil/digit-dp/#probleme-de-tipul-al-k-lea-numar-cu-o-proprietate-data","title":"Probleme de tipul al \\(k\\)-lea num\u0103r cu o proprietate dat\u0103","text":"<p>Pentru a rezolva acest tip de probleme, de cele mai multe ori vom c\u0103uta binar r\u0103spunsul, calcul\u00e2nd la fiecare pas num\u0103rul de asemenea numere din intervalul \\([1, x]\\) cu proprietatea din enun\u021b. Un astfel de exemplu \u00eel putem reg\u0103si \u00een problema Bug Lot Juniori 2024, problem\u0103 care dup\u0103 unele simplific\u0103ri ajunge la o c\u0103utare binar\u0103 pe stilul celei men\u021bionate, aici pute\u021bi g\u0103si o surs\u0103 pe aceast\u0103 idee.  </p>","tags":["programare dinamica"]},{"location":"dificil/digit-dp/#probleme-suplimentare","title":"Probleme suplimentare","text":"<ul> <li>CSES Counting Numbers</li> <li>Bug Lot Juniori 2024</li> <li>AtCoder Digit Sum</li> <li>Perfect Number</li> <li>USACO Silver Odometer</li> <li>SPOJ Digit Sum</li> <li>Codeforces Segment Sum</li> <li>Infoarena simpla</li> <li>Infoarena peluzanord</li> <li>ONI 2012 Baraj Juniori cifreco</li> <li>Codeforces Magic Numbers</li> <li>Probleme cu digit dp de pe kilonova</li> </ul>","tags":["programare dinamica"]},{"location":"dificil/digit-dp/#lectura-suplimentara","title":"Lectur\u0103 suplimentar\u0103","text":"<ul> <li>Introduction to Digit Dynamic Programming - Youtube</li> <li>Digit DP - USACO Guide</li> <li>Digit DP - Codeforces (+ probleme)</li> </ul>","tags":["programare dinamica"]},{"location":"dificil/fenwick-tree/","title":"Arbori indexati binar","text":"<p>Autori: \u0218tefan-Cosmin D\u0103sc\u0103lescu, Luca Valentin Mure\u0219an</p>","tags":["structuri de date"]},{"location":"dificil/fenwick-tree/#ce-este-un-arbore-indexat-binar","title":"Ce este un Arbore Indexat Binar?","text":"<p>Arborii indexa\u021bi binar (prescurta\u021bi de regul\u0103, AIB) sunt o structur\u0103 de date ce poate fi folosit\u0103 pentru a actualiza eficient valori \u0219i pentru a calcula sume par\u021biale \u00eentr-un tablou de valori ce poate avea una sau mai multe dimensiuni. </p> <p>De\u0219i arborii indexa\u021bi binar nu \u00eenlocuiesc vreo structur\u0103 de date propriu-zis\u0103 (tot ce poate face un AIB poate face \u0219i un arbore de intervale), marele lor avantaj este dat de faptul c\u0103 implementarea lor este foarte u\u0219oar\u0103 \u0219i constanta folosit\u0103 de ace\u0219tia este una mult redus\u0103 fa\u021b\u0103 de arborii de intervale, fiind de c\u00e2teva ori mai rapizi \u0219i consum\u00e2nd de \\(2-4\\) ori mai pu\u021bin\u0103 memorie, \u00een func\u021bie de implementare. </p>","tags":["structuri de date"]},{"location":"dificil/fenwick-tree/#cum-functioneaza-un-arbore-indexat-binar","title":"Cum func\u021bioneaz\u0103 un Arbore Indexat Binar?","text":"<p>Pentru a putea folosi un AIB, trebuie s\u0103 folosim un vector, unde aib[i] reprezint\u0103 valoarea pe care o stoc\u0103m pe pozi\u021bia \\(i\\). A\u0219a cum \u00eei zice \u0219i numele, fiecare pozi\u021bie \\(i\\) va \u021bine rezultatele pe un interval egal cu \\(2^{zeroes}\\), unde \\(zeroes\\) reprezint\u0103 num\u0103rul de zerouri de la finalul reprezent\u0103rii binare a lui \\(i\\). Aceast\u0103 expresie ne ajut\u0103 s\u0103 adun\u0103m sau s\u0103 sc\u0103dem valoarea celui mai nesemnificativ bit de \\(1\\) din \\(i\\) pentru a putea opera actualiz\u0103rile \u0219i query-urile.</p> <p>Motivul pentru care se folose\u0219te reprezentarea binar\u0103 a nodurilor este acela c\u0103 \u00een acest mod, se garanteaz\u0103 complexitatea logaritmic\u0103 a opera\u021biilor men\u021bionate mai sus (update \u0219i query), precum \u0219i \u00een practic\u0103 o constant\u0103 foarte bun\u0103 datorit\u0103 num\u0103rului redus de bi\u021bi pe care \u00eel au numerele \u00een binar. </p> <p>Observa\u021bie: Arborii indexa\u021bi binar sunt mereu indexa\u021bi de la \\(1\\), deoarece altfel, am avea de-a face cu \\(0\\), care nu are un bit nesemnificativ egal cu \\(1\\).</p>","tags":["structuri de date"]},{"location":"dificil/fenwick-tree/#cum-functioneaza-operatia-de-update","title":"Cum func\u021bioneaz\u0103 opera\u021bia de update?","text":"<p>S\u0103 presupunem c\u0103 avem un AIB cu \\(16\\) noduri \u0219i vrem s\u0103 actualiz\u0103m valoarea de la pozi\u021bia \\(3\\). Pentru a putea face asta, vom rula urm\u0103torul algoritm, c\u00e2t timp valoarea curent\u0103 nu e mai mare dec\u00e2t num\u0103rul de noduri:</p> <ul> <li>actualiz\u0103m valoarea curent\u0103</li> <li>afl\u0103m pozi\u021bia celui mai nesemnificativ bit, s\u0103 o not\u0103m \\(lsb\\)</li> <li>adun\u0103m \\(2^{lsb}\\) la valoarea curent\u0103</li> </ul> <p>De exemplu, pentru nodul \\(3\\) vom trece prin urm\u0103toarele pozi\u021bii, dup\u0103 cum se poate vedea pe desen:</p> <ul> <li>\\(3\\) - pozi\u021bia celui mai nesemnificativ bit este \\(0\\), adun\u0103m \\(2^0 = 1\\) la pozi\u021bie</li> <li>\\(4\\) - pozi\u021bia celui mai nesemnificativ bit este \\(2\\), adun\u0103m \\(2^2 = 4\\) la pozi\u021bie</li> <li>\\(8\\) - pozi\u021bia celui mai nesemnificativ bit este \\(3\\), adun\u0103m \\(2^3 = 8\\) la pozi\u021bie</li> <li>\\(16\\) - pozi\u021bia celui mai nesemnificativ bit este \\(3\\), adun\u0103m \\(2^4 = 16\\) la pozi\u021bie, algoritmul ia sf\u00e2r\u0219it.</li> </ul> <p></p> <p>Complexitatea opera\u021biei de update este \\(O(\\log n)\\), unde \\(n\\) este dimensiunea arborelui indexat binar. </p>","tags":["structuri de date"]},{"location":"dificil/fenwick-tree/#cum-functioneaza-operatia-de-query","title":"Cum func\u021bioneaz\u0103 opera\u021bia de query?","text":"<p>\u00cen mod similar fa\u021b\u0103 de opera\u021bia de update, opera\u021bia de query va rula folosindu-se de reprezentarea binar\u0103 a pozi\u021biei de la care vrem s\u0103 facem query-ul. Este de remarcat faptul c\u0103 dac\u0103 vrem s\u0103 rul\u0103m un query pe intervalul \\([L, R]\\), va trebui s\u0103 sc\u0103dem din rezultatul ob\u021binut p\u00e2n\u0103 la pozi\u021bia \\(R\\), rezultatul ob\u021binut la pozi\u021bia \\(L - 1\\), din cauza faptului c\u0103 informa\u021bia stocat\u0103 \u00een nodurile din AIB nu este suficient de complex\u0103 pentru a putea fi ob\u021binut\u0103 cu o singur\u0103 rutin\u0103 de interogare. Totodat\u0103, aceast\u0103 abordare este similar\u0103 cu cea de la sumele par\u021biale, unde ob\u021binerea lor presupune din nou dou\u0103 calcule, \u00een loc de unul singur.</p> <p>Mai jos prezint algoritmul general \u0219i un exemplu de aplicare al acestuia, pentru valoarea \\(13\\).</p> <ul> <li>adun\u0103m la rezultat valoarea curent\u0103</li> <li>afl\u0103m pozi\u021bia celui mai nesemnificativ bit, s\u0103 o not\u0103m \\(lsb\\)</li> <li>sc\u0103dem \\(2^{lsb}\\) din valoarea curent\u0103.</li> </ul> <p>De exemplu, pentru nodul \\(13\\) vom trece prin urm\u0103toarele pozi\u021bii, dup\u0103 cum se poate vedea pe desen:</p> <ul> <li>\\(13\\) - pozi\u021bia celui mai nesemnificativ bit este \\(0\\), sc\u0103dem \\(2^0 = 1\\) din pozi\u021bie</li> <li>\\(12\\) - pozi\u021bia celui mai nesemnificativ bit este \\(2\\), sc\u0103dem \\(2^2 = 4\\) din pozi\u021bie</li> <li>\\(8\\) - pozi\u021bia celui mai nesemnificativ bit este \\(3\\), sc\u0103dem \\(2^3 = 8\\) din pozi\u021bie, am ajuns la \\(0\\), deci calculul ia sf\u00e2r\u0219it.</li> </ul> <p></p> <p>Complexitatea opera\u021biei de query este \\(O(\\log n)\\), unde \\(n\\) este dimensiunea arborelui indexat binar. </p>","tags":["structuri de date"]},{"location":"dificil/fenwick-tree/#implementarea-in-c","title":"Implementarea \u00een C++","text":"<p>Un mare avantaj al arborilor indexa\u021bi binar este acela c\u0103 implementarea lor este una foarte scurt\u0103, fiind necesare doar c\u00e2teva r\u00e2nduri pentru a putea fi implementa\u021bi.</p> <pre><code>long long fenwick[100002];\nvoid update(int node, int value)\n{\n    for(int i = node; i &lt;= n; i += (i &amp; (-i)))\n        fenwick[i] += value;\n}\nlong long compute(int node)\n{\n    long long ans = 0;\n    for(int i = node; i &gt; 0; i -= (i &amp; (-i)))\n        ans += fenwick[i];\n    return ans;\n}\n</code></pre>","tags":["structuri de date"]},{"location":"dificil/fenwick-tree/#probleme-rezolvate","title":"Probleme rezolvate","text":"","tags":["structuri de date"]},{"location":"dificil/fenwick-tree/#problema-inv","title":"Problema inv","text":"<p>Se d\u0103 un \u015fir \\(S\\) de lungime \\(n\\) cu numere \u00eentregi. Numim o inversiune o pereche de indici \\((i, j)\\) astfel \u00eenc\u00e2t \\(1 \\leq i &lt; j \\leq n\\) \u015fi \\(S_i &gt; S_j\\). S\u0103 se determine c\u00e2te inversiuni sunt \u00een \u015firul dat.</p> <p>Pentru a rezolva aceast\u0103 problem\u0103, putem folosi orice structur\u0103 de date ce ne permite s\u0103 actualiz\u0103m valoarea unei pozi\u021bii \u0219i s\u0103 rul\u0103m query-uri de sum\u0103 pe un interval. \u00cen cazul problemei noastre, vom vrea pentru fiecare valoare din \u0219ir s\u0103 afl\u0103m num\u0103rul de valori de la st\u00e2nga care sunt mai mari dec\u00e2t valoarea curent\u0103, lucru ce se poate realiza afl\u00e2nd pentru valoarea curent\u0103, pozi\u021bia ei \u00een \u0219irul sortat \u0219i proces\u00e2nd un query de sum\u0103 pe intervalul \\([poz + 1, n]\\), unde \\(poz\\) este pozi\u021bia \u00een vectorul sortat a celei mai din dreapta valori din \u0219ir egal\u0103 cu valoarea de la pozi\u021bia curent\u0103. </p>","tags":["structuri de date"]},{"location":"dificil/fenwick-tree/#problema-goal-statistics","title":"Problema Goal Statistics","text":"<p>Se dau \\(q\\) opera\u021bii, opera\u021bia de update adaug\u0103 o valoare egal\u0103 cu \\(k\\), iar opera\u021bia de query cere suma celor mai mici \\(p\\) valori din \u0219ir. </p> <p>Aceast\u0103 problem\u0103 este din nou un exemplu clasic de folosire a structurilor de date, iar \u00eenc\u0103 o dat\u0103, arborii indexa\u021bi binari se dovedesc a fi solu\u021bia potrivit\u0103 pentru aceast\u0103 problem\u0103, datorit\u0103 vitezei de implementare \u0219i a u\u0219urin\u021bei de folosire. Pentru a afla suma celor mai mici \\(p\\) valori din \u0219ir, vom c\u0103uta binar r\u0103spunsul, folosind o metod\u0103 similar\u0103 cu cea descris\u0103 mai sus. De\u0219i c\u0103utarea binar\u0103 naiv\u0103 \u00een \\(O(\\log^2 n)\\) ia punctajul maxim, se recomand\u0103 c\u0103utarea binar\u0103 \u00een \\(O(\\log n)\\).</p> <p>Solu\u021bia de \\(100\\)</p>","tags":["structuri de date"]},{"location":"dificil/fenwick-tree/#alte-aplicatii-si-resurse-suplimentare","title":"Alte aplica\u021bii \u0219i resurse suplimentare","text":"<ul> <li>Fenwick Tree</li> <li>Fenwick Tree</li> <li>Goal Statistics</li> <li>inv</li> <li>Understanding Fenwick Trees</li> <li>Binary Indexed Trees</li> </ul>","tags":["structuri de date"]},{"location":"dificil/hld/","title":"Alte probleme \u0219i resurse utile","text":"<ul> <li>Heavy Light Decomposition</li> </ul>"},{"location":"dificil/lowest-common-ancestor/","title":"Binary lifting. Lowest common ancestor (LCA)","text":"<p>Autori: \u0218tefan-Cosmin D\u0103sc\u0103lescu</p>","tags":["arbori","grafuri","structuri de date"]},{"location":"dificil/lowest-common-ancestor/#introducere","title":"Introducere","text":"<p>Pentru a putea folosi acest articol la adev\u0103rata lui valoare, se recomand\u0103 citirea articolului (aici trebuie pus href la treebasics) pentru a v\u0103 familiariza cu no\u021biunile discutate aici. De asemenea, pentru anumite concepte, vor fi necesare cuno\u0219tin\u021be suplimentare \u00een ceea ce prive\u0219te structurile de date, programarea dinamic\u0103 \u0219i lucrul cu STL. \u00cen cele ce urmeaz\u0103, vom discuta problema afl\u0103rii celui mai mic str\u0103mo\u0219 comun, \u00eempreun\u0103 cu c\u00e2teva tehnici necesare pentru \u00een\u021belegerea ei.</p>","tags":["arbori","grafuri","structuri de date"]},{"location":"dificil/lowest-common-ancestor/#liniarizarea-arborelui","title":"Liniarizarea arborelui","text":"<p>Prima no\u021biune care este necesar\u0103 pentru \u00een\u021belegerea unei mari p\u0103r\u021bi din cuno\u0219tin\u021bele de aici este dat\u0103 de liniarizarea arborelui. Acest procedeu este esen\u021bial pentru a putea transpune informa\u021bia din arbore pentru integrarea structurilor de date \u00eempreun\u0103 cu informa\u021biile deja existente \u00een arbore. Cel mai frecvent algoritm de liniarizare const\u0103 \u00een folosirea unei parcurgeri DFS pentru a trece prin nodurile din arbore \u00een ordinea \u00een care apar, not\u00e2nd pentru fiecare din ele pozi\u021bia la care am intrat \u00een subarborele acelui nod, precum \u0219i pozi\u021bia la care am ie\u0219it din subarborele acelui nod. De aici, putem aplica orice structur\u0103 de date preferat\u0103 pentru a aplica query-urile pe un anumit subarbore. </p> <pre><code>vector&lt;vector&lt;int&gt;&gt; v;\n\nint n, pos, L[200002], R[200002];\nvoid dfs(int parent, int node) {\n    pos++;\n    L[node] = pos;\n\n    for (auto nxt : v[node]) {\n        if (nxt != parent) {\n            dfs(node, nxt);\n        }\n    }\n\n    R[node] = pos;\n}\n</code></pre>","tags":["arbori","grafuri","structuri de date"]},{"location":"dificil/lowest-common-ancestor/#binary-lifting","title":"Binary Lifting","text":"<p>De multe ori, avem nevoie s\u0103 g\u0103sim \u00eentr-un arbore (sau \u00eentr-o construc\u021bie pe care o putem modela ca un arbore) cu \\(n\\) noduri cel de-al \\(k\\)-lea str\u0103mo\u0219 pentru un nod dat. Dup\u0103 cum \u0219ti\u021bi din articolul anterior, un str\u0103mo\u0219 este un nod la care putem ajunge dac\u0103 urc\u0103m de-a lungul arbore, din nod \u00een nod p\u00e2n\u0103 la r\u0103d\u0103cin\u0103. O prim\u0103 metod\u0103 de a afla acest str\u0103mo\u0219 este de a merge fie folosind un vector de p\u0103rin\u021bi calculat anterior, fie folosind o parcurgere, merg\u00e2nd prin to\u021bi cei \\(k\\) str\u0103mo\u0219i. Totu\u0219i, complexitatea acestui algoritm este \\(O(k)\\), fiind mult prea \u00eencet \u00een cazul \u00een care avem de calculat aceste r\u0103spunsuri pentru mai multe asemenea noduri. </p> <p>\u00cen acest caz, se pune problema parcurgerii celor \\(k\\) mut\u0103ri \u00eentr-o manier\u0103 care s\u0103 ne permit\u0103 aflarea acestui r\u0103spuns \u00eentr-un timp c\u00e2t mai rapid, aici pun\u00e2ndu-se problema cum putem scrie un anumit num\u0103r \u00eentr-o sum\u0103 de c\u00e2t mai pu\u021bine numere pentru a putea r\u0103spunde la aceste \u00eentreb\u0103ri, f\u0103r\u0103 s\u0103 folosim prea mult\u0103 memorie. A\u0219a cum sugereaz\u0103 \u0219i numele articolului, vom folosi reprezentarea binar\u0103 a numerelor pentru a putea calcula aceste r\u0103spunsuri. Cu alte cuvinte, pentru fiecare nod \u0219tim deja primul lui str\u0103mo\u0219, ceea ce ne d\u0103 ideea de a afla str\u0103mo\u0219ii pentru pozi\u021biile corespunz\u0103toare puterilor lui \\(2\\) mai mici sau egale cu \\(n\\). </p> <p>Astfel, vom integra \u00een parcurgerea DFS obi\u0219nuit\u0103 construc\u021bia acestei matrici, unde <code>anc[i][j]</code> va reprezenta cel de-al \\(2^i\\)-lea str\u0103mo\u0219 al nodului \\(j\\). Pentru a afla <code>anc[i][j]</code>, dac\u0103 \\(i = 0\\), atunci <code>anc[i][j]</code> va fi p\u0103rintele nodului \\(j\\), altfel, va fi <code>anc[i-1][anc[i-1][nod]]</code>, practic va fi cel de-al \\(2^{i-1}\\)-lea str\u0103mo\u0219 al celui de-al \\(2^{i-1}\\) lea str\u0103mo\u0219 al nodului curent, astfel folosind proprietatea c\u0103 o putere a lui \\(2\\) e dublul puterii precedente a lui \\(2\\), construind acest \u0219ir din aproape \u00een aproape. </p> <p>Pentru a afla apoi un str\u0103mo\u0219 situat la pozi\u021bia \\(x\\) fa\u021b\u0103 de un nod \\(y\\), tot ce va trebui s\u0103 facem va fi s\u0103 parcurgem invers, \u00eencep\u00e2nd de la nodul curent, folosindu-ne de reprezentarea binar\u0103 a nodului dat. </p> <pre><code>// anc[i][j] = nodul situat la distanta 2^i de nodul j\n\nint n, q, anc[20][200002], lvl[200002];\nvector&lt;int&gt; v[200002];\n\nvoid dfs(int tata, int nod) {\n    // Primul stramos este parintele nodului curent\n    anc[0][nod] = tata;\n\n    // Al 2^i-lea stramos al nodului curent e al 2^(i-1)\n    // lea stramos al 2^(i-1) lea stramos al nodului curent\n    for (int i = 1; i &lt;= 18; ++i) {\n        anc[i][nod] = anc[i - 1][anc[i - 1][nod]];\n    }\n\n    for (int i = 0; i &lt; v[nod].size(); ++i) {\n        int vecin = v[nod][i];\n        if (vecin == tata) {\n            continue;\n        }\n\n        // Avem nevoie de nivelul nodului pe arbore pentru cazul cu -1\n        lvl[vecin] = lvl[nod] + 1;\n        dfs(nod, vecin);\n    }\n}\n\n// Cel de-al k-lea stramos al lui nod\nint solve(int nod, int stp) {\n\n    // Parcurgem nivelele pentru a afla stramosul dorit\n    for (int i = 18; i &gt;= 0; --i) {\n        if (stp &gt;= (1 &lt;&lt; i)) {\n            nod = anc[i][nod], stp -= (1 &lt;&lt; i);\n        }\n    }\n    return nod;\n}\n</code></pre>","tags":["arbori","grafuri","structuri de date"]},{"location":"dificil/lowest-common-ancestor/#lowest-common-ancestor","title":"Lowest Common Ancestor","text":"<p>De foarte multe ori, se pune problema afl\u0103rii celui mai mic str\u0103mo\u0219 comun \u00eentre dou\u0103 sau mai multe noduri, \u00eentr-un timp c\u00e2t mai eficient. De\u0219i la fel ca la subproblema precedent\u0103, putem g\u0103si r\u0103spunsul folosind o metod\u0103 brut\u0103, folosirea binary lifting se va dovedi instrumental\u0103 pentru aflarea LCA-ului \u00een \\(O(\\log n)\\). Cu alte cuvinte, mai \u00eent\u00e2i vom vrea s\u0103 aducem nodurile la acela\u0219i nivel, iar mai apoi, urc\u0103m \u00een arbore p\u00e2n\u0103 c\u00e2nd ajungem fix \u00eenainte de nodul care ne va da r\u0103spunsul. Cazul c\u00e2nd un nod este str\u0103mo\u0219ul altuia se trateaz\u0103 anterior. Codul de mai jos se bazeaz\u0103 pe precalcul\u0103rile men\u021bionate mai sus.</p> <p>Observa\u021bie</p> <p>LCA-ul \u00eentre mai multe noduri se poate afla ca fiind LCA-ul \u00eentre primele dou\u0103, apoi rezultatul cu al treilea nod \u0219i a\u0219a mai departe</p> <pre><code>int solve(int a, int b) {\n    if (lvl[a] &lt; lvl[b]) {\n        swap(a, b);\n    }\n\n    for (int i = 18; i &gt;= 0; --i) {\n        if (lvl[a] - (1 &lt;&lt; i) &gt;= lvl[b]) {\n            a = anc[i][a];\n        }\n    }\n\n    if (a == b) {\n        return a;\n    }\n\n    for (int i = 18; i &gt;= 0; --i) {\n        if (dp[i][a] != dp[i][b]) {\n            a = anc[i][a], b = anc[i][b];\n        }\n    }\n\n    return anc[0][a];\n}\n</code></pre> <p>Observa\u021bie</p> <p>LCA-ul \u00eentre dou\u0103 noduri se poate afla \u0219i \u00een \\(O(1)\\) per query, folosind o precalculare de tipul RMQ, care se bazeaz\u0103 pe liniarizarea arborelui (TO-DO)</p>","tags":["arbori","grafuri","structuri de date"]},{"location":"dificil/lowest-common-ancestor/#alte-probleme-si-resurse-utile","title":"Alte probleme \u0219i resurse utile","text":"<ul> <li>Euler Tour Technique</li> <li>Binary Lifting + LCA</li> <li>LCA, predat la CPPI Craiova</li> <li>Milk Visits USACO Silver</li> <li>Sap</li> <li>Tutorial - Binary lifting</li> <li>Tutorial video Errichto (Binary lifting)</li> </ul>","tags":["arbori","grafuri","structuri de date"]},{"location":"dificil/range-dp/","title":"Programare dinamic\u0103 pe intervale (range DP)","text":"<p>Autor: \u0218tefan-Cosmin D\u0103sc\u0103lescu</p> <p>\u00cen acest articol vom prezenta modul \u00een care aplic\u0103m tehnica program\u0103rii dinamice atunci c\u00e2nd vine vorba de a afla diverse r\u0103spunsuri minime sau maxime pentru \u0219iruri cu o lungime relativ mic\u0103 (de regul\u0103, cel mult \\(500\\)), folosind drept st\u0103ri anterioare subsecven\u021be de lungime mai mic\u0103 ale \u0219irului dat. </p> <p>Aceast\u0103 tehnic\u0103 este numit\u0103 \u00een specialitate range dp, fiind g\u0103sit\u0103 \u00een articolele rom\u00e2ne\u0219ti \u0219i sub numele de metoda mixt\u0103 a program\u0103rii dinamice.</p>","tags":["programare dinamica"]},{"location":"dificil/range-dp/#conditii-necesare","title":"Condi\u021bii necesare","text":"<p>Aceast\u0103 tehnic\u0103 apare preponderent \u00een probleme care respect\u0103 c\u00e2t mai multe din condi\u021biile men\u021bionate aici, implementarea \u0219i modul de g\u00e2ndire al st\u0103rilor \u0219i tranzi\u021biilor fiind foarte similar de la o problem\u0103 la alta:</p> <ul> <li>Se pot g\u0103si solu\u021bii greedy destul de u\u0219or, dar f\u0103r\u0103 succes</li> <li>Dac\u0103 \u0219tim r\u0103spunsurile pentru subsecven\u021bele de lungime mai mic\u0103, putem calcula r\u0103spunsul pentru orice subsecven\u021b\u0103 \\([L, R]\\) de o lungime mai mare</li> <li>Putem combina subsecven\u021be disjuncte \u00een mod independent</li> <li>De regul\u0103, \\(n\\) (dimensiunea \u0219irului) este cel mult \\(500\\). </li> </ul>","tags":["programare dinamica"]},{"location":"dificil/range-dp/#cum-aplicam-tehnica","title":"Cum aplic\u0103m tehnica?","text":"<p>Pe scurt, ceea ce vrem s\u0103 facem este s\u0103 avem o stare de tip \\(dp[i][j]\\) care s\u0103 ne \u021bin\u0103 r\u0103spunsul pentru intervalul \\([i, j]\\) \u0219i s\u0103 calcul\u0103m valoarea acestei st\u0103ri fix\u00e2nd pozi\u021bia \\(k\\) pe care o vom folosi pentru a \u00eemp\u0103r\u021bi subsecven\u021ba noastr\u0103 \u00een dou\u0103 subsecven\u021be disjuncte (de regul\u0103, \\([i, k]\\) \u0219i \\([k+1, j]\\)), a c\u0103ror reuniune s\u0103 fie subsecven\u021ba \\([i, j]\\).</p> <p>O alt\u0103 particularitate des \u00eent\u00e2lnit\u0103 va fi s\u0103 iter\u0103m subsecven\u021bele \u00een ordine cresc\u0103toare a lungimilor pentru a avea r\u0103spunsurile calculate \u00een ordine. Alternativ, vom putea implementa aceast\u0103 solu\u021bie \u0219i recursiv, f\u0103c\u00e2nd calculele mai u\u0219oare, a\u0219a cum ve\u021bi putea vedea \u00een exemplele ulterioare. </p>","tags":["programare dinamica"]},{"location":"dificil/range-dp/#un-prim-exemplu-problema-rectangle-cutting","title":"Un prim exemplu - Problema Rectangle Cutting","text":"<p>Aceast\u0103 problem\u0103 ne cere s\u0103 afl\u0103m num\u0103rul minim de t\u0103ieturi pe care le putem face astfel \u00eenc\u00e2t s\u0103 \u00eemp\u0103r\u021bim dreptunghiul ini\u021bial cu dimensiunile \\(a\\) \u0219i \\(b\\) \u00een p\u0103trate. </p> <p>Mai \u00eent\u00e2i, ne-am putea g\u00e2ndi la solu\u021bii de tip backtracking care sunt foarte \u00eencete sau solu\u021bii greedy care \u00eencearc\u0103 s\u0103 ob\u021bin\u0103 p\u0103trate c\u00e2t mai mari, dar aceste abord\u0103ri e\u0219ueaz\u0103 pe diverse teste. </p> <p>Deoarece dimensiunile dreptunghiurilor sunt cel mult \\(500\\), putem s\u0103 ne g\u00e2ndim la o dinamic\u0103 de dou\u0103 dimensiuni, unde \\(dp[i][j]\\) va \u021bine num\u0103rul minim de t\u0103ieturi necesare pentru a ajunge la un dreptunghi de dimensiunile \\(i\\) \u0219i \\(j\\). </p> <p>Un caz de baz\u0103 evident este acela c\u00e2nd \\(i = j\\), unde \\(dp[i][j] = 0\\). Acum, trebuie s\u0103 ne g\u00e2ndim la t\u0103ieturile pe care le putem face, acestea pot fi fie orizontale, fie verticale, at\u00e2ta timp c\u00e2t p\u0103str\u0103m laturile drept numere \u00eentregi. </p> <p>Cu alte cuvinte, vom putea fixa punctul \u00een care vom face t\u0103ietura \u0219i de acolo, vom folosi rezultatele calculate anterior, sau \u00een cazul solu\u021biei recursive, le vom calcula la r\u00e2ndul lor p\u00e2n\u0103 c\u00e2nd toate valorile au fost calculate. Complexitatea acestei solu\u021bii va fi \\(O(n^3)\\), unde \\(n\\) este maximul dintre \\(a\\) \u0219i \\(b\\). </p> <p>Mai jos pute\u021bi g\u0103si implement\u0103rile iterative \u0219i recursive ale acestei probleme.</p> RecursivIterativ <pre><code>#include &lt;iostream&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\nvector&lt;vector&lt;int&gt; &gt; dp;\n\nint solve (int n, int m) {\n    if (n == m) {\n        return 0;\n    }\n    if (dp[n][m] != (1&lt;&lt;20)) {\n        return dp[n][m];\n    }\n    for (int side = 1; side &lt; n; side++) {\n        dp[n][m] = min(dp[n][m], solve(side, m) + solve(n-side, m) + 1);\n    }\n    for (int side = 1; side &lt; m; side++) {\n        dp[n][m] = min(dp[n][m], solve(n, side) + solve(n, m-side) + 1);\n    }\n    return dp[n][m];\n}\n\nint main() {\n\n    int n, m;\n    cin &gt;&gt; n &gt;&gt; m;\n\n    dp.resize(n+1, vector&lt;int&gt; (m+1, (1&lt;&lt;20)));\n\n    cout &lt;&lt; solve(n, m) &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre> <pre><code>#include &lt;iostream&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\nint main() {\n\n    int n, m;\n    cin &gt;&gt; n &gt;&gt; m;\n\n    vector&lt;vector&lt;int&gt; &gt; dp(n+1, vector&lt;int&gt; (m+1, (1&lt;&lt;20)));\n\n    for (int i = 1; i &lt;= n; i++) {\n        for (int j = 1; j &lt;= m; j++) {\n            if (i == j) {\n                dp[i][j] = 0;\n                continue;\n            }\n            for (int side = 1; side &lt; i; side++) {\n                dp[i][j] = min(dp[i][j], dp[side][j] + dp[i-side][j] + 1);\n            }\n            for (int side = 1; side &lt; j; side++) {\n                dp[i][j] = min(dp[i][j], dp[i][side] + dp[i][j-side] + 1);\n            }\n        }\n    }\n\n    cout &lt;&lt; dp[n][m] &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["programare dinamica"]},{"location":"dificil/range-dp/#un-exemplu-mai-dificil-greedy-pie-eaters","title":"Un exemplu mai dificil - Greedy Pie Eaters","text":"<p>\u00cen aceast\u0103 problem\u0103, vrem s\u0103 ne asigur\u0103m c\u0103 putem folosi vaci cu o greutate total\u0103 c\u00e2t mai mare, \u0219tiind c\u0103 fiecare vac\u0103 va m\u00e2nca toate pr\u0103jiturile din intervalul corespunz\u0103tor. </p> <p>Vom \u00eencepe prin a precalcula pentru fiecare mod posibil de a t\u0103ia un interval, cea mai bun\u0103 variant\u0103 de a face asta, folosind o dinamic\u0103 de tipul \\(bstcut[i][j][p]\\), unde aceast\u0103 stare reprezint\u0103 suma maxim\u0103 pe care o putem ob\u021bine din intervalul \\([i, j]\\) dac\u0103 t\u0103iem intervalul \u00een pozi\u021bia \\(p\\). </p> <p>Dup\u0103 ce avem aceast\u0103 dinamic\u0103 calculat\u0103, vom putea rezolva aceast\u0103 problem\u0103 folosind o alt\u0103 dinamic\u0103 pe dou\u0103 dimensiuni, unde \\(dp[i][j]\\) reprezint\u0103 r\u0103spunsul optim pentru intervalul \\([i, j]\\). Aceast\u0103 dinamic\u0103 va putea fi implementat\u0103 recursiv, fix\u00e2nd pozi\u021biile \u00een care asign\u0103m o vac\u0103 sau fix\u00e2nd intervalele pe care le vom \u00eemp\u0103r\u021bi, acestea fiind calculate independent. </p> <pre><code>#include &lt;fstream&gt;\n#include &lt;vector&gt;\n\nusing namespace std;\n\nifstream cin(\"pieaters.in\");\nofstream cout(\"pieaters.out\");\n\nvector&lt;vector&lt;int&gt;&gt; mx, dp;\nvector&lt;vector&lt;vector&lt;int&gt;&gt;&gt; bstcut;\n\nint solve (int st, int dr) {\n    if(st &gt; dr) {\n        return 0;\n    }\n    if (dp[st][dr] != -1) {\n        return dp[st][dr];\n    }\n    dp[st][dr] = 0;\n    for (int i = st; i &lt; dr; ++i) {\n        dp[st][dr] = max(dp[st][dr], solve(st, i) + solve(i+1, dr));\n    }\n    for (int cut = st; cut &lt;= dr; ++cut) {\n        dp[st][dr] = max(dp[st][dr], bstcut[st][dr][cut] + solve(st, cut-1) + solve(cut+1, dr));\n    }\n    return dp[st][dr];\n}\nint main() {\n\n    int n, m;\n    cin &gt;&gt; n &gt;&gt; m;\n    mx.resize(n+2, vector&lt;int&gt; (n+2));\n    dp.resize(n+2, vector&lt;int&gt; (n+2, -1));\n    bstcut.resize(n+2, vector&lt;vector&lt;int&gt; &gt; (n+2, vector&lt;int&gt; (n+2, 0)));\n\n    for (int i = 1; i &lt;= m; ++i) {\n        int am, l, r;\n        cin &gt;&gt; am &gt;&gt; l &gt;&gt; r;\n        mx[l][r] = max(mx[l][r], am);\n    }\n    for (int len = 1; len &lt;= n; ++len) {\n        for (int j = 1; j + len - 1 &lt;= n; ++j) {\n            for (int x = j; x &lt;= j + len - 1; ++x) {\n                bstcut[j][j + len - 1][x] = max(bstcut[j][j + len - 2][x], mx[j][j + len - 1]);\n                bstcut[j][j + len - 1][x] = max(bstcut[j][j + len - 1][x], bstcut[j + 1][j + len - 1][x]);\n            }\n        }\n    }\n\n    cout &lt;&lt; solve(1, n) &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["programare dinamica"]},{"location":"dificil/range-dp/#un-alt-tip-de-range-dp-atcoder-dp-contest-deque","title":"Un alt tip de range dp - Atcoder DP Contest Deque","text":"<p>De\u0219i aceast\u0103 problem\u0103 nu se \u00eencadreaz\u0103 complet \u00een defini\u021bia dat\u0103 mai sus, modul relativ facil pe care \u00eel avem pentru calcularea rezultatelor st\u0103rilor o va putea \u00eencadra \u00een aceast\u0103 categorie. </p> <p>Din nou, o solu\u021bie greedy u\u0219or de g\u0103sit nu este fezabil\u0103, majoritatea greedy-urilor cunoscute av\u00e2nd cazuri pe care solu\u021bia pic\u0103. Astfel, suntem limita\u021bi la a avea o abordare bazat\u0103 pe metoda program\u0103rii dinamice, unde \\(dp[i][j]\\) reprezint\u0103 r\u0103spunsul maxim dac\u0103 \u00eencepem din subsecven\u021ba \\([i, j]\\). La fiecare pas, avem de fixat una din cele dou\u0103 valori pe care o folosim, r\u0103spunsul fiind preluat din secven\u021bele de lungime mai mic\u0103, a\u0219a cum se poate vedea \u00een codul de mai jos. </p> <p>Observa\u021bie</p> <p>Exist\u0103 totu\u0219i o solu\u021bie greedy corect\u0103 pentru aceast\u0103 problem\u0103, fiind una destul de dificil\u0103, \u00een ciuda codului scurt, detaliile fiind explicate \u00een acest paper, pe care \u00eel pute\u021bi g\u0103si aici</p> <pre><code>#include &lt;iostream&gt;\n#include &lt;vector&gt;\n\nusing namespace std;\n\nint main()\n{\n    int n;\n    cin &gt;&gt; n;\n\n    vector&lt;int&gt; v(n+1);\n    for(int i = 1; i &lt;= n; ++i)\n        cin &gt;&gt; v[i];\n\n    vector&lt;vector&lt;int&gt;&gt; dp(n+1, vector&lt;int&gt; (n+1));\n    for (int i = n; i &gt;= 1; --i) {\n        for (int j = i+1; j &lt;= n+1; ++j) {\n            dp[i][j] = max(v[i] - dp[i+1][j], v[j-1] - dp[i][j-1]);\n        }\n    }\n    cout &lt;&lt; dp[1][n+1];\n    return 0;\n}\n</code></pre>","tags":["programare dinamica"]},{"location":"dificil/range-dp/#concluzii","title":"Concluzii","text":"<p>Dup\u0103 cum se poate vedea, Range DP este o tehnic\u0103 care se dovede\u0219te a fi foarte util\u0103 \u00een multe contexte, iar faptul c\u0103 implement\u0103rile vor fi similare de la problem\u0103 la problem\u0103 va face \u00een\u021belegerea \u0219i aplicarea principiului mai u\u0219oar\u0103 dec\u00e2t \u00een cazul altor dinamici, unde este necesar\u0103 o experien\u021b\u0103 mai mare pentru a modifica st\u0103rile \u0219i modul de calcul.</p>","tags":["programare dinamica"]},{"location":"dificil/range-dp/#probleme-suplimentare","title":"Probleme suplimentare","text":"<ul> <li>podm infoarena</li> <li>Slimes AtCoder DP</li> <li>Space Jazz SAPO</li> <li>Mean Info1Cup</li> <li>bmatrix infoarena</li> <li>redu infoarena</li> <li>ONI 2010 Triunghi</li> <li>Taming the Herd USACO Gold</li> <li>ONI 2009 Baraj Seniori maxpal</li> <li>ONI 2008 Baraj Seniori stiva</li> <li>Zuma Codeforces</li> <li>ONI 2023 Baraj Seniori bt</li> <li>Empty String CSES</li> <li>Queries for Number of Palindromes Codeforces</li> <li>3SUM USACO Gold</li> <li>Replace on Segment Codeforces</li> <li>Interesting Problem (Hard Version) Codeforces</li> <li>Probleme de pe kilonova cu Range DP</li> <li>Probleme de pe pbinfo cu Range DP</li> </ul>","tags":["programare dinamica"]},{"location":"dificil/range-dp/#lectura-suplimentara","title":"Lectur\u0103 suplimentar\u0103","text":"<ul> <li>Articolul despre Range DP de pe USACO Guide</li> <li>Tehnici avansate de programare dinamic\u0103 - Infoarena</li> <li>Some Interval DP Problems and State Reduction - Codeforces</li> </ul>","tags":["programare dinamica"]},{"location":"dificil/segment-trees/","title":"Arbori de intervale","text":"<p>Autor: Alexandru Toma</p> <p>\u00cen competi\u021biile de informatic\u0103 \u0219i la olimpiad\u0103 se \u00eent\u00e2lnesc adesea probleme care implic\u0103 operarea pe subsecven\u021bele unui vector. Spre exemplu, cum putem calcula eficient suma, maximul sau minimul pe o subsecven\u021b\u0103 a unui vector, mai ales c\u00e2nd acesta sufer\u0103 modific\u0103ri \u00een timp real? </p> <p>Observa\u021bie</p> <p>Dac\u0103 vectorul este static (nu sufer\u0103 modific\u0103ri), putem utiliza tehnici simple precum vectori de sume par\u021biale sau RMQ (Range Minimum Query). Totu\u0219i, \u00een scenariile unde vectorul se modific\u0103 frecvent, aceste tehnici devin ineficiente. Opera\u021biile de query au o complexitate de \\(O(1)\\) at\u00e2t pentru sume par\u021biale, c\u00e2t \u0219i pentru RMQ. \u00cens\u0103, pentru actualiz\u0103ri, trebuie reconstruit tot tabelul de valori, ceea ce duce la o complexitate de \\(O(n)\\) pentru sume par\u021biale \u0219i \\(O(n \\log n)\\) pentru RMQ.</p> <p>Arborii de intervale (cunoscu\u021bi \u0219i sub denumirea de segment trees sau aint \u00een jargonul rom\u00e2nesc) reprezint\u0103 o solu\u021bie elegant\u0103 \u0219i eficient\u0103 pentru acest tip de probleme, permi\u021b\u00e2nd efectuarea rapid\u0103 de interog\u0103ri \u0219i actualiz\u0103ri \u00een \\(O(log n)\\) pentru ambele opera\u021bii.</p> <p>\u00cen acest articol, vom explora conceptele de baz\u0103 ale arborilor de intervale, modul de construire \u0219i utilizare a acestora, \u0219i vom analiza c\u00e2teva aplica\u021bii frecvente \u00een problemele de olimpiad\u0103. Vom \u00eencepe prin a defini structura unui arbore de intervale \u0219i vom continua prin a explica opera\u021biile de actualizare, interogare \u0219i implement\u0103rile acestora. \u00cen final, vom discuta \u0219i c\u00e2teva probleme ap\u0103rute \u00een concursurile de programare competitiv\u0103. F\u0103r\u0103 prea mult\u0103 vorb\u0103rie, s\u0103 \u00eencepem!</p>","tags":["structuri de date"]},{"location":"dificil/segment-trees/#problema-clasica","title":"Problema clasic\u0103","text":"<p>Problema</p> <p>Fie un vector \\(A\\) cu \\(N\\) elemente. Asupra lui se vor face \\(M\\) opera\u021bii de tipul:</p> <ul> <li><code>update(pos, val)</code> - actualizeaz\u0103 valoarea de pe pozi\u021bia <code>pos</code> \u00een <code>val</code></li> <li><code>query(x, y)</code> - afla\u021bi suma elementelor din intervalul \\([x, y]\\), \\((A_{st} + A_{st+1} + ... + A_{dr})\\)</li> </ul>","tags":["structuri de date"]},{"location":"dificil/segment-trees/#structura-unui-arbore-de-intervale","title":"Structura unui arbore de intervale","text":"<p>Un arbore de intervale este un arbore binar care este folosit pentru a stoca informa\u021bii despre intervalele unui vector. Fiecare nod din arbore reprezint\u0103 un interval \u0219i stocheaz\u0103 o anumit\u0103 valoare (de exemplu, suma, minimul sau maximul) pentru intervalul respectiv.</p>","tags":["structuri de date"]},{"location":"dificil/segment-trees/#cum-se-formeaza-un-arbore-de-intervale","title":"Cum se formeaz\u0103 un arbore de intervale?","text":"<p>S\u0103 consider\u0103m un vector \\(A\\) de dimensiune \\(N\\). Arborele de intervale asociat acestui vector se construie\u0219te astfel:</p> <ul> <li>R\u0103d\u0103cina arborelui va fi nodul \\(1\\) \u0219i va avea asociat r\u0103spunsul pentru intervalul \\([1,n]\\).</li> <li>Un nod \\(k\\) are asociat un interval \\([st,dr]\\), iar acesta are doi fii ce se vor afla pe pozi\u021biile \\(2 \\cdot k\\) (fiul din st\u00e2nga) \u0219i \\(2 \\cdot k + 1\\) (fiul din dreapta). Fiul din st\u00e2nga va avea r\u0103spunsul pentru intervalul \\([st, m]\\), iar fiul din dreapta pentru \\([m+1, dr]\\), unde m este mijlocul intervalului.</li> </ul> <p>Reprezentare \u00een memorie</p> <p>De\u0219i conceptul de arbore de intervale este unul de tip arbore binar, \u00een practic\u0103, structura este stocat\u0103 \u00een memorie sub forma unui vector. Astfel, fiecare nod din arbore corespunde unei pozi\u021bii din acest vector, ceea ce ne permite s\u0103 acces\u0103m eficient nodurile arborelui folosind opera\u021bii de indexare.</p> <p>S\u0103 consider\u0103m vectorul \\(A=[5,8,6,3,2,7,2,6]\\), arborele de intervale asociat vectorului \\(A\\) va ar\u0103ta \u00een felul urm\u0103tor:</p> <p></p>","tags":["structuri de date"]},{"location":"dificil/segment-trees/#care-este-memoria-necesara-stocarii","title":"Care este memoria necesara stocarii ?","text":"<ul> <li>Num\u0103rul de frunze: Arborele de intervale are  N frunze, c\u00e2te una pentru fiecare element din vectorul original. Aceste frunze sunt reprezentate \u00een ultimul nivel al arborelui.</li> <li>Num\u0103rul de noduri interne: avem \\(N-1\\) noduri interne.</li> <li>\u00cen\u0103l\u021bimea maxim\u0103 a unui arbore binar complet cu \\(N\\) frunze este \\(\\lceil \\log_2(N) \\rceil\\).</li> </ul> <p>Astfel, \u00een caz general, num\u0103rul total de noduri (frunze + noduri interne) dintr-un arbore binar complet de \u00een\u0103l\u021bime \\(h\\) este:</p> \\[ \\begin{aligned} 2^{h+1} - 1 &amp;= 2 \\cdot 2^{\\lceil \\log_2(N) \\rceil} - 1 \\\\[0.2cm] &amp;\\leq 2 \\cdot 2^{\\log_2(N) + 1} - 1 \\\\[0.2cm] &amp;\\leq 4 \\cdot 2^{\\log_2(N)} - 1 \\\\[0.2cm] &amp;= 4 \\cdot N - 1 \\end{aligned} \\] <p>Observa\u021bie</p> <p>Dimensiunea \\(4 \\cdot N\\) asigur\u0103 faptul c\u0103 avem suficient spa\u021biu pentru a construi un arbore de intervale complet, indiferent de dimensiunea vectorului original. Aceast\u0103 alocare permite men\u021binerea unui arbore echilibrat \u0219i eficient, permi\u021b\u00e2nd efectuarea de opera\u021bii de actualizare \u0219i interogare \u00eentr-un mod optim.</p>","tags":["structuri de date"]},{"location":"dificil/segment-trees/#operatii-elementare","title":"Opera\u021bii elementare","text":"","tags":["structuri de date"]},{"location":"dificil/segment-trees/#construirea-arborelui","title":"Construirea arborelui","text":"<p>Construirea unui arbore de intervale se realizeaz\u0103 \u00eentr-un mod recursiv bottom-up, pornind de la frunzele arborelui (care corespund elementelor vectorului ini\u021bial) \u0219i merg\u00e2nd spre r\u0103d\u0103cin\u0103. La fiecare nivel al arborelui, valorile nodurilor se determin\u0103 pe baza fiilor s\u0103i.</p> <p>Aceast\u0103 opera\u021bie se efectueaz\u0103 \u00een \\(O(n)\\), unde \\(n\\) este num\u0103rul de elemente din vectorul ini\u021bial. De re\u021binut c\u0103 exist\u0103 \u0219i o alt\u0103 variant\u0103 de a construi arborele prin a actualiza fiecare pozi\u021bie cu valoarea din vector, \u00eens\u0103 duce la o complexitate de \\(O(n \\log n)\\).</p> <p></p> <p>\u00cen diagramele de mai sus, vedem c\u0103 la fiecare pas, valorile din noduri sunt calculate pe baza sumelor subintervalelor din fiul st\u00e2ng \u0219i fiul drept. Acest proces este realizat \u00een codul de mai jos prin apeluri recursive, unde func\u021bia <code>build</code> este apelat\u0103 pentru fiecare subarbore (st\u00e2ng \u0219i drept), iar valorile din noduri sunt apoi actualizate.</p> <p>De re\u021binut</p> <p>Arborii de intervale func\u021bioneaz\u0103 eficient doar cu opera\u021bii asociative (ex: suma, maximul, minimul, cmmdc). Asociativitatea permite combinarea rezultatelor din subintervale f\u0103r\u0103 a afecta corectitudinea rezultatului final.</p> <p>Mai jos sunt prezentate dou\u0103 modalit\u0103\u021bi de implementare, at\u00e2t recursiv\u0103, c\u00e2t \u0219i iterativ\u0103:</p> Construc\u021bie recursiv\u0103Construc\u021bie iterativ\u0103 <pre><code>void build(int node, int st, int dr) {\n    if (st == dr) {\n        aint[node] = A[st];\n        return;\n    }\n    int mid = (st + dr) / 2;\n\n    build(2 * node, st, mid);   // Construim subarborele st\u00e2ng\n    build(2 * node + 1, mid + 1, dr);  // Construim subarborele drept\n\n    // Actualiz\u0103m rezultatul nodului \u00een func\u021bie de rezultatele fiilor\n    aint[node] = aint[2 * node] + aint[2 * node + 1];\n}\n</code></pre> <pre><code>void build(int arr[]) { \n    // Inser\u0103m nodurile frunzelor \u00een arbore\n    for (int i = 0; i &lt; n; i++)  \n        tree[n + i] = arr[i]; \n\n    // Construim arborele prin calcularea p\u0103rin\u021bilor\n    for (int i = n - 1; i &gt; 0; --i)  \n        tree[i] = tree[i &lt;&lt; 1] + tree[i &lt;&lt; 1 | 1];   \n}\n</code></pre>","tags":["structuri de date"]},{"location":"dificil/segment-trees/#operatia-de-update","title":"Opera\u021bia de update","text":"<p>Pentru a efectua un update, ne vom deplasa \u00een arbore p\u00e2n\u0103 la frunza care reprezint\u0103 elementul modificat. Odat\u0103 ce am ajuns la frunz\u0103, \u00eenlocuim valoarea veche cu cea nou\u0103. Pe m\u0103sur\u0103 ce revenim din recursivitate, actualiz\u0103m fiecare nod din drum, recalcul\u00e2nd valorile pe baza celor doi fii, pentru a ne asigura c\u0103 arborele r\u0103m\u00e2ne corect.</p> <p>Aceast\u0103 opera\u021bie se efectueaz\u0103 \u00een \\(O(\\log n)\\), unde \\(n\\) este num\u0103rul de elemente din vectorul ini\u021bial. Complexitatea este determinat\u0103 de \u00een\u0103l\u021bimea arborelui, deoarece actualizarea trebuie propagat\u0103 de la frunz\u0103 p\u00e2n\u0103 la r\u0103d\u0103cin\u0103.</p> <p>Mai jos este prezentat\u0103 o diagram\u0103 care ilustreaz\u0103 cum se modific\u0103 structura arborelui de intervale dup\u0103 ce actualiz\u0103m valoarea elementului de pe pozi\u021bia \\(5\\) din \\(2\\) \u00een \\(1\\).</p> <p></p> <p>\u00cen diagramele de mai sus, putem observa cum se modific\u0103 structura arborelui de intervale dup\u0103 ce modific\u0103m valoarea de pe pozi\u021bia 5 din 2 \u00een 7. Nodurile afectate de aceast\u0103 modificare sunt eviden\u021biate, iar valorile lor sunt actualizate pentru a reflecta noua configura\u021bie.</p> <p>Iat\u0103 un exemplu de implementare a acestei opera\u021bii \u00een C++:</p> <pre><code>void update(int pos, int val, int node, int st, int dr) {\n  if (st == dr) {\n    aint[node] = val; // Daca am ajuns la pozitia pos, schimbam valoarea\n    return;\n  }\n\n  int mid = (st + dr) / 2;\n  if (pos &lt;= mid)  // (1)\n    update(pos, val, node * 2, st, mid);\n  else\n    update(pos, val, node * 2 + 1, mid + 1, dr);\n\n  // La intoarcerea din apelul recursiv, actualizam nodul\n  aint[node] = aint[node * 2] + aint[node * 2 + 1];\n}\n</code></pre> <ol> <li>Dac\u0103 nodul se afl\u0103 \u00een intervalul din st\u00e2nga</li> </ol>","tags":["structuri de date"]},{"location":"dificil/segment-trees/#operatia-de-query","title":"Operatia de query","text":"<p>C\u00e2nd dorim s\u0103 efectu\u0103m o interogare pe un interval \\([x, y]\\), scopul este de a g\u0103si rapid r\u0103spunsul pentru acest subinterval f\u0103r\u0103 a fi nevoie s\u0103 parcurgem to\u021bi termenii din vectorul ini\u021bial. Arborele de intervale face acest lucru prin \u00eemp\u0103r\u021birea intervalului \\([x, y]\\) \u00een subintervale mai mici, pe care le combin\u0103 pentru a g\u0103si r\u0103spunsul final.</p> <p>Aceast\u0103 descompunere se bazeaz\u0103 pe faptul c\u0103, pentru orice interval \\([st, dr]\\) gestionat de un nod din arbore, avem trei cazuri:</p> <ol> <li>Interval complet \u00een afara intervalului de interogare (gri \u00eenchis): Dac\u0103 intervalul \\([st, dr]\\) nu se suprapune cu intervalul \\([x, y]\\), atunci acel interval nu contribuie la r\u0103spuns \u0219i putem returna direct 0 sau alt\u0103 valoare de identitate (pentru maxim, minim etc.).</li> <li>Interval complet inclus \u00een intervalul de interogare (portocaliu): Dac\u0103 intervalul \\([st, dr]\\) este complet inclus \u00een intervalul \\([x, y]\\), return\u0103m valoarea stocat\u0103 \u00een nodul respectiv, deoarece aceasta reprezint\u0103 deja r\u0103spunsul pentru \u00eentregul interval.</li> <li>Interval par\u021bial suprapus (galben): \u00cen acest caz, descompunem intervalul \u00een dou\u0103 subintervale, corespunz\u0103toare fiilor nodului curent, \u0219i combin\u0103m rezultatele interog\u0103rilor pentru aceste subintervale.</li> </ol> <p></p> <p>Iat\u0103 un exemplu de implementare a opera\u021biei de query \u00een C++:</p> <pre><code>int query(int x, int y, int node, int st, int dr) {\n  if(dr &lt; x || y &lt; st) // Daca intervalul se afla complet in afara\n    return 0;\n  if(x &lt;= st &amp;&amp; dr &lt;= y) // Daca intervalul este complet inclus\n    return aint[node];\n\n  int mid = (st + dr) / 2;\n  int Q_st = query(x, y, node * 2, st, mid); // (1)\n  int Q_dr = query(x, y, node * 2 + 1, mid + 1, dr); //(2)\n\n  return Q_st + Q_dr;\n}\n</code></pre> <ol> <li>R\u0103spunsul pentru intervalul din st\u00e2nga</li> <li>R\u0103spunsul pentru intervalul din dreapta</li> </ol>","tags":["structuri de date"]},{"location":"dificil/segment-trees/#probleme-rezolvate","title":"Probleme rezolvate","text":"<p>Tip</p> <p>\u00cenainte de a trece la problemele rezolvate, te \u00eencurajez s\u0103 \u00eencerci s\u0103 implementezi structura de date \u0219i s\u0103 rezolvi singur c\u00e2teva probleme de baz\u0103. \u00cencearc\u0103 s\u0103 implementezi arborele de intervale pentru a calcula suma \u0219i maximul pe un interval dat. \u00cen modul acesta vei vedea unde ai neclarit\u0103\u021bi. Dup\u0103 ce te-ai convins c\u0103 ai \u00een\u021beles tot ce s-a discutat p\u00e2n\u0103 acum, te invit s\u0103 discut\u0103m c\u00e2teva probleme mai interesante. Un alt mic sfat ar fi s\u0103 \u00eencerci problema \u00eenainte de a urm\u0103ri rezolvarea complet\u0103.</p>","tags":["structuri de date"]},{"location":"dificil/segment-trees/#1-arbint","title":"1. Arbint","text":"<p>Fie un vector \\( A \\) cu \\( N \\) elemente naturale. Asupra lui se vor face \\( M \\) opera\u021bii, codificate astfel \u00een fi\u0219ierul de intrare:</p> <ul> <li><code>0 a b</code> - S\u0103 se determine maximul din intervalul \\([a, b]\\).</li> <li><code>1 a b</code> - Valoarea elementului de pe pozi\u021bia \\( a \\) va deveni \\( b \\).</li> </ul> <p>Problema de baz\u0103, identic\u0103 cu cea pe care am rezolvat-o anterior, singura diferen\u021b\u0103 este c\u0103 acum trebuie s\u0103 calcul\u0103m elementul maxim. Solu\u021bia mea o pute\u021bi vedea aici.</p>","tags":["structuri de date"]},{"location":"dificil/segment-trees/#2-maxq-oni-2007","title":"2. Maxq - ONI 2007","text":"<p>Johnie a \u00eenceput s\u0103 se joace cu un vector de numere. El dispune ini\u021bial de un vector \\( V \\) cu \\( N \\) numere \u00eentregi \u0219i poate efectua urm\u0103toarele opera\u021bii:</p> <ul> <li>Schimbarea elementului de pe pozi\u021bia \\( p \\) cu un alt num\u0103r \u00eentreg;</li> <li>Aflarea subsecven\u021bei de sum\u0103 maxim\u0103 din \\( V \\) inclus\u0103 \u00eentre indicii \\( a \\) \u0219i \\( b \\).</li> </ul> <p>Pentru rezolvarea acestei probleme vom adopta aceea\u0219i strategie, vom analiza modul \u00een care putem combina dou\u0103 segmente de lungime \\(L/2\\) \u00eentr-un singur segment de lungime \\(L\\). \u00cen cazul acestei probleme vom avea nevoie de mai multe informa\u021bii pentru fiecare nod:</p> <pre><code>struct Node {\n  int suma;     // Suma subsecventei\n  int prefmax;  // Prefixul de suma maxima\n  int suffmax;  // Sufixul de suma maxima\n  int smax;     // Subsecventa de suma maxima\n};\n</code></pre> <p>S\u0103 analizam pu\u021bin unde se poate afl\u0103 segmentul de sum\u0103 maxim\u0103 dup\u0103 combinarea celor dou\u0103 subsegmente.</p> <ul> <li>Segmentul de sum\u0103 maxim\u0103 se afl\u0103 \u00een intervalul din st\u00e2nga (L.smax)</li> <li>Segmentul de sum\u0103 maxim\u0103 se afl\u0103 \u00een intervalul din dreapta (R.smax)</li> <li>Segmentul de sum\u0103 maxim\u0103 \u00eencepe \u00een intervalul st\u00e2ng \u0219i se termin\u0103 \u00een cel drept. Aceasta este reprezentat\u0103 prin combina\u021bia dintre L.suffmax \u0219i R.prefmax.</li> </ul> <p></p> <p>Pentru a calcula prefixul de sum\u0103 maxim\u0103 pentru fiecare nod lu\u0103m maximul dintre prefixul g\u0103sit \u00een st\u00e2nga \u0219i \u00eentregul segment din st\u00e2nga la care se adaug\u0103 prefixul de sum\u0103 maxim\u0103 din dreapta.</p> <p></p> <p>Analog pentru sufixul de sum\u0103 maxim\u0103, doar c\u0103 lu\u0103m maximul dintre sufixul g\u0103sit \u00een dreapta \u0219i \u00eentregul segment care \u00eencepe \u00een dreapta \u0219i se continua \u00een st\u00e2nga.</p> <pre><code>struct Node {\n  int suma;     // Suma subsecventei\n  int prefmax;  // Prefixul de suma maxima\n  int suffmax;  // Sufixul de suma maxima\n  int smax;     // Subsecventa de suma maxima\n};\n\nNode merge(Node L, Node R) {\n  Node T;\n  T.suma = L.suma + R.suma;\n  T.prefmax = max(L.prefmax, L.suma + R.prefmax);\n  T.suffmax = max(R.suffmax, R.suma + L.suffmax);\n  T.smax = max( max(L.smax, R.smax), L.suffmax + R.prefmax );\n}\n</code></pre> <p>\u00centrebare</p> <p>Cu ce valori ini\u021bializ\u0103m frunzele arborelui ?</p> <p>Iat\u0103 o posibila implementare a acestei probleme in C++:</p> <pre><code>#include &lt;iostream&gt;  \n#include &lt;fstream&gt;  \n#include &lt;algorithm&gt;  \nusing namespace std;\n\nifstream fin(\"maxq.in\");\nofstream fout(\"maxq.out\");\n\nconst int MAXN = 2e5 + 1;\n\nstruct Node {\n  long long suma;    // Suma subsecventei\n  long long prefmax; // Prefixul de suma maxima\n  long long sufmax;  // Sufixul de suma maxima\n  long long smax;    // Subsecventa de suma maxima\n} aint[MAXN * 4];\n\nint n;\n\nNode combine(Node L, Node R) {\n  Node T;\n  T.suma = L.suma + R.suma;\n  T.prefmax = max(L.prefmax, L.suma + R.prefmax);\n  T.sufmax = max(R.sufmax, R.suma + L.sufmax);\n  T.smax = max( max(L.smax, R.smax), L.sufmax + R.prefmax );\n  return T;\n}\n\nvoid update(int pos, int val, int node = 1, int st = 1, int dr = n) {\n  if(st == dr) {\n    if(val &gt; 0)\n      aint[node] = {val, val, val, val};\n    else\n      aint[node] = {val, 0, 0, 0};\n    return;\n  }\n\n  int mid = (st + dr) / 2;\n  if(pos &lt;= mid)\n    update(pos, val, node * 2, st, mid);\n  else\n    update(pos, val, node * 2 + 1, mid + 1, dr);\n  aint[node] = combine(aint[node * 2], aint[node * 2 + 1]);\n}\n\nNode query(int x, int y, int node = 1, int st = 1, int dr = n) {\n  if(y &lt; st || dr &lt; x)\n    return {0, 0, 0, 0};\n  if(x &lt;= st &amp;&amp; dr &lt;= y)\n    return aint[node];\n\n  int mid = (st + dr) / 2;\n  Node Q1 = query(x, y, node * 2, st, mid);\n  Node Q2 = query(x, y, node * 2 + 1, mid + 1, dr);\n  return combine(Q1, Q2);\n}\n\nint main() {\n  int q;\n  fin &gt;&gt; n;\n  for(int i = 1; i &lt;= n; i++) {\n    int x;\n    fin &gt;&gt; x;\n    update(i, x);\n  }\n\n  fin &gt;&gt; q;\n  while(q--) {\n    int op, x, y;\n    fin &gt;&gt; op &gt;&gt; x &gt;&gt; y;\n    if(op == 0)\n      update(x + 1, y);\n    else\n      fout &lt;&lt; query(x + 1, y + 1).smax &lt;&lt; '\\n';\n  }\n\n  return 0;\n}\n</code></pre>","tags":["structuri de date"]},{"location":"dificil/segment-trees/#3-nrinversiuni","title":"3. NrInversiuni","text":"<p>\u00cen aceast\u0103 problem\u0103, trebuie s\u0103 determin\u0103m num\u0103rul de inversiuni dintr-o permutare dat\u0103 a unui vector de lungime \\( n \\). O inversiune este o pereche ordonat\u0103 \\((i, j)\\) astfel \u00eenc\u00e2t \\( 1 \\leq i &lt; j \\leq n \\) \u0219i \\( v[i] &gt; v[j] \\).</p> <p>Solu\u021bia naiv\u0103 ar presupune s\u0103 verific\u0103m pentru fiecare pereche de elemente \\((i, j)\\) dac\u0103 \\( v[i] &gt; v[j] \\). Acest lucru necesit\u0103 dou\u0103 bucle imbricate, una pentru \\( i \\) \u0219i alta pentru \\( j \\), ceea ce duce la o complexitate de \\( O(n^2) \\).</p> <p>Solu\u021bia optim\u0103. Aceast\u0103 problem\u0103 poate fi rezolvat\u0103 eficient cu ajutorul arborilor de intervale. Observa\u021bia esen\u021bial\u0103 este c\u0103 fiecare element formeaz\u0103 inversiuni cu toate elementele mai mari dec\u00e2t el care apar \u00eenaintea lui \u00een vector. Pentru a implementa solu\u021bia, folosim un arbore de intervale care ne ajut\u0103 s\u0103 men\u021binem num\u0103rul de elemente mai mare dec\u00e2t un anumit element pe m\u0103sur\u0103 ce parcurgem vectorul.</p> <p>Not\u0103: Folosind aceast\u0103 metod\u0103, complexitatea algoritmului se reduce la \\( O(n \\log n) \\).</p> <p>Iat\u0103 cum se poate implementa solu\u021bia:</p> <ul> <li>Pentru fiecare element \\(x\\), calcul\u0103m c\u00e2te elemente mai mari dec\u00e2t \\(x\\) se afl\u0103 deja \u00een arbore. Altfel spus, c\u00e2te elemente se afl\u0103 \u00een intervalul \\([x+1,n]\\).</li> <li>Actualiz\u0103m arborele, marc\u00e2nd apari\u021bia elementului \\(x\\).</li> </ul>","tags":["structuri de date"]},{"location":"dificil/segment-trees/#probleme-de-antrenament","title":"Probleme de antrenament","text":"<p>Pentru problemele de pe codeforces, este necesar un cont pentru a putea accesa acest curs din sec\u021biunea EDU (ITMO Academy)</p> <ul> <li>Dynamic Range Minimum Queries</li> <li>Number of Minimums on a Segment</li> <li>Intervalxy</li> <li>Kth one</li> <li>First element at least X</li> <li>Sign Alternation</li> <li>Inversions</li> <li>Xenia and bit operations</li> <li>Irrigation</li> <li>Distinct Value Queries</li> <li>United Cows of Farmer John - USACO Gold</li> <li>Increasing Subsequence II</li> <li>Salary Queries</li> <li>Kth - ONI 2023</li> <li>Intersec\u021bie segmente : baleiere</li> </ul>","tags":["structuri de date"]},{"location":"dificil/segment-trees/#probleme-dificile","title":"Probleme dificile","text":"<ul> <li>Dulciuri - OJI 2021</li> <li>Array Counting - IIOT 2021-2022</li> <li>Panama Sum - IIOT 2022-2023</li> <li>Lucky Array</li> </ul>","tags":["structuri de date"]},{"location":"dificil/segment-trees/#bibliografie-resurse-suplimentare","title":"Bibliografie + Resurse suplimentare","text":"<ul> <li>CPPI</li> <li>USACO Guide</li> <li>Codeforces EDU: curs complet pentru introducerea \u00een arbori de intervale</li> <li>CSAcademy: articol care con\u021bine anima\u021bii pentru opera\u021biile elementare</li> <li>CPAlgorithms: articol mai avansat care prezint\u0103 mai multe tehnici</li> <li>Efficient and easy segment trees</li> <li>Arbori de intervale si baleiere</li> <li>Template arbori de intervale: o clas\u0103 flexibil\u0103 care permite modificarea rapid\u0103 a opera\u021biilor.</li> </ul>","tags":["structuri de date"]},{"location":"dificil/small-to-large/","title":"Small to large","text":"<p>Autor : Radu Moc\u0103na\u0219u</p>"},{"location":"dificil/small-to-large/#cunostinte-necesare","title":"Cuno\u0219tin\u021be necesare:","text":"<ul> <li>Arbori.</li> <li>Parcurgeri <code>DFS</code>.</li> <li>Containerele <code>set</code> \u0219i <code>map</code> din STL.</li> <li>De preferat si <code>DSU</code></li> </ul>"},{"location":"dificil/small-to-large/#introducere","title":"Introducere","text":"<p>S\u0103 \u00eencepem cu urm\u0103toarea problem\u0103:</p>"},{"location":"dificil/small-to-large/#cses-distinct-colors","title":"CSES - Distinct Colors","text":"<p>Pentru a rezolva aceast\u0103 problem\u0103, ar fi necesar s\u0103 \u0219tim pentru fiecare nod c\u00e2te valori diferite se afl\u0103 \u00een mul\u021bimea nodurilor din subarborele s\u0103u.</p> <p>Observa\u021bie</p> <p>Pentru un nod, ar fi destul s\u0103 \u021binem \u00eentr-o structur\u0103 de tip <code>set</code> valorile nodurilor din subarborele s\u0103u (pe care \u00eel vom nota cu \\(s\\)), iar r\u0103spunsul pentru el ar fi <code>s[nod].size()</code>.</p> <p>Astfel, am putea s\u0103 facem o parcurgere <code>DFS</code> a arborelui, unde mul\u021bimii fiec\u0103rui nod \u00eei vom ad\u0103uga valoarea sa \u0219i valorile din mul\u021bimile fiilor s\u0103i. Apoi, putem salva rezultatul \u00eentr-un vector separat, pe care \u00eel putem numi <code>rez</code>.</p> <p>S\u0103 ne uit\u0103m la implementarea acestei idei.</p> <pre><code>#include &lt;iostream&gt;\n#include &lt;set&gt;\n#include &lt;vector&gt;\n\nconstexpr int NMAX = 200005;\nint rez[NMAX];\nstd::vector&lt;std::vector &lt;int&gt;&gt; G(NMAX);\n//tinem minte cate un set pentru fiecare nod\nstd::vector&lt;std::set &lt;int&gt;&gt; s(NMAX);\n\nvoid dfs(int nod, int t) {\n    for (auto x : G[nod]) {\n        if (x != t) {\n            dfs(x, nod);\n            //parcurgem setul fiecarui fiu si adaugam elementele in setul nodului\n            for (auto x2 : s[x]){\n                s[nod].insert(x2);\n            }\n        }\n    }\n    //obtinem rezultatul folosind metoda .size()\n    rez[nod] = s[nod].size();\n}\n\nint main() {\n    int n, i, u, v, c;\n    std::cin &gt;&gt; n;\n    for (i = 1; i &lt;= n; i++) {\n        std::cin &gt;&gt; c;\n        //valoarea nodului o putem adauga direct in setul acestuia\n        s[i].insert(c);\n    }\n    for (i = 1; i &lt; n; i++) {\n        std::cin &gt;&gt; u &gt;&gt; v;\n        G[u].push_back(v);\n        G[v].push_back(u);\n    }\n    dfs(1, 0);\n    for (i = 1; i &lt;= n; i++) {\n        std::cout &lt;&lt; rez[i] &lt;&lt; \" \";\n    }\n    return 0;\n}\n</code></pre> <p>Totu\u0219i, complexitatea reuniunii multimii unui nod cu cele ale fiilor sai poate lua pana la \\(O(n\\log(n))\\), iar noi avem \\(n\\) noduri, deci ar ie\u0219i timp \\(O(n^2\\log(n))\\), ceea ce este foarte lent \u0219i nu se va \u00eencadra \u00een restric\u021biile acestei probleme.</p> <p>\u00cens\u0103, aici intervine urm\u0103toarea informa\u021bie:</p> <p>Observa\u021bie</p> <p>Pe structuri cum ar fi <code>set</code> sau <code>map</code>, opera\u021bia de <code>swap</code> este efectuat\u0103 \u00een timp constant. A\u0219adar, dac\u0103 avem 2 seturi, \\(s_1\\) \u0219i \\(s_2\\), <code>std::swap(s1, s2)</code>, sau alternativ <code>s1.swap(s2)</code>, va lua \\(O(1)\\).</p> <p>A\u0219adar, \u00een cazul \u00een care m\u0103rimea setului unui fiu este mai mare dec\u00e2t cea a setului nodului, le putem interschimba \u00eentre ele. De aici vine \u0219i numele tehnicii, deoarece noi ducem elementele de la mic la mare.</p>"},{"location":"dificil/small-to-large/#demonstratie-complexitate","title":"Demonstra\u021bie complexitate","text":"<p>Demonstra\u021bie scurt\u0103</p> <p>Ne putem baza pe acela\u0219i principiu ca la <code>DSU</code>, anume c\u0103 dac\u0103 la un moment dat avem un element \\(x\\) \u00eentr-un set de m\u0103rime \\(s\\), \u00een cel mai r\u0103u caz, acesta va fi reunit cu un set tot de m\u0103rime \\(s\\). Astfel, urm\u0103torul set \u00een care se va afla elementul va avea cel pu\u021bin \\(2s\\) elemente, sau altfel spus, orice element va fi inserat \u00een maxim \\(\\log(n)\\) seturi pe parcursul algoritmului. A\u0219adar, vom avea complexitate \\(O(n\\log^2(n))\\), deoarece \u0219i inser\u0103rile iau \\(O(\\log(n))\\).</p> <p>Demonstra\u021bie lung\u0103</p> <p>Acum intervine \u00eentrebarea: cu ce ne ajut\u0103 s\u0103 interschimb\u0103m cele dou\u0103 mul\u021bimi? S\u0103 presupunem c\u0103 avem mul\u021bimi care permit existen\u021ba a mai multor elemente egale (structura multiset din STL). Astfel, dac\u0103 avem o mul\u021bime \\(M\\) de m\u0103rime \\(s\\), aceasta va fi reunit\u0103, \u00een cel mai r\u0103u caz, cu o alt\u0103 mul\u021bime de dimensiune \\(s\\), deci urm\u0103toarea mul\u021bime \u00een care se vor afla elementele din \\(M\\) va avea dimensiunea de cel pu\u021bin \\(2 * s\\). A\u0219adar, orice element va fi inserat \u00een maxim \\(\\log(n)\\) seturi pe parcursul algoritmului, iar complexitatea final\u0103 va fi \\(O(n\\log^2(n))\\), deoarece inser\u0103rile iau \u00een total \\(O(n\\log(n))\\).</p> <p>Pentru structurile de tip set (care nu con\u021bin mai multe elemente egale), intervine \u00eens\u0103 o problem\u0103. Anume, dac\u0103 reunim o astfel de mul\u021bime de dimensiune \\(s\\) cu alta de aceea\u0219i dimensiune, num\u0103rul de elemente al mul\u021bimii care va rezulta nu va mai fi neap\u0103rat \\(2 * s\\), deoarece pot fi elemente care apar \u00een ambele mul\u021bimi.</p> <p>Totu\u0219i, putem demonstra c\u0103 \u0219i \u00een acest caz complexitatea r\u0103m\u00e2ne aceea\u0219i. Dac\u0103 pentru fiecare nod, pentru mul\u021bimea sa, am \u021bine minte c\u00e2te elemente ar fi avut dac\u0103 era un multiset. Dac\u0103 am face swap \u00eentre cele dou\u0103 mul\u021bimi doar \u00een func\u021bie de aceast\u0103 proprietate, ar fi cel pu\u021bin la fel de rapid ca \u00een cazul de mai sus (e la fel ca \u0219i cum am fi avut dou\u0103 structuri de tip multiset, minus elementele care se repetau). Aceast\u0103 metod\u0103, nu \u021bine \u00eens\u0103 cont de m\u0103rimea real\u0103 a mul\u021bimilor, deci putem avea cazuri unde mul\u021bimea cu dimensiunea mai mare este reunit\u0103 la cea de dimensiune mai mic\u0103. A\u0219adar, pentru dou\u0103 structuri de tip set, putem s\u0103 le interschimb\u0103m dup\u0103 dimensiunea lor real\u0103, f\u0103r\u0103 ca acest lucru s\u0103 afecteze complexitatea final\u0103, care r\u0103m\u00e2ne tot maxim \\(O(n\\log^2(n))\\).</p> <p>Cu aceast\u0103 schimbare, codul va ar\u0103ta a\u0219a:</p> <pre><code>#include &lt;iostream&gt;\n#include &lt;set&gt;\n#include &lt;vector&gt;\n\nconstexpr int NMAX = 200005;\nint rez[NMAX];\nstd::vector&lt;std::vector &lt;int&gt;&gt; G(NMAX);\n//tinem minte cate un set pentru fiecare nod\nstd::vector&lt;std::set &lt;int&gt;&gt; s(NMAX);\n\nvoid dfs(int nod, int t) {\n    for (auto x : G[nod]) {\n        if (x != t) {\n            dfs(x, nod);\n            //daca numarul de elemente din setul fiului este mai mare decat cel din setul nodului, le interschimbam\n            if(s[x].size() &gt; s[nod].size()){\n                s[nod].swap(s[x]);\n            }\n            //parcurgem setul fiecarui fiu si adaugam elementele in setul nodului\n            for (auto x2 : s[x]){\n                s[nod].insert(x2);\n            }\n        }\n    }\n    //obtinem rezultatul folosind metoda .size()\n    rez[nod] = s[nod].size();\n}\n\nint main() {\n    int n, i, u, v, c;\n    std::cin &gt;&gt; n;\n    for (i = 1; i &lt;= n; i++) {\n        std::cin &gt;&gt; c;\n        //valoarea nodului o putem adauga direct in setul acestuia\n        s[i].insert(c);\n    }\n    for (i = 1; i &lt; n; i++) {\n        std::cin &gt;&gt; u &gt;&gt; v;\n        G[u].push_back(v);\n        G[v].push_back(u);\n    }\n    dfs(1, 0);\n    for (i = 1; i &lt;= n; i++) {\n        std::cout &lt;&lt; rez[i] &lt;&lt; \" \";\n    }\n    return 0;\n}\n</code></pre> <p>Aceast\u0103 solu\u021bie se \u00eencadreaz\u0103 \u00een limitele problemei \u0219i va lua punctaj maxim.</p>"},{"location":"dificil/small-to-large/#small-to-large-folosind-__gnu_pbds","title":"Small to large folosind <code>__gnu_pbds</code>","text":"<p>Aceast\u0103 structur\u0103 de date ofer\u0103 acelea\u0219i func\u021bii ca structura <code>set</code> din STL, \u00eens\u0103 mai ofer\u0103 \u00eenc\u0103 2 func\u021bii care ne pot fi de ajutor \u00een anumite probleme:</p> <ol> <li><code>find_by_order(x)</code>, care returneaz\u0103 un iterator c\u0103tre a x-a cheie ca ordine, \u00een timp \\(O(\\log(n))\\).</li> <li><code>order_of_key(x)</code>, care returneaz\u0103 num\u0103rul de elemente strict mai mici ca x, tot \u00een timp \\(O(\\log(n))\\).</li> </ol> <p>Pentru a putea folosi aceast\u0103 structur\u0103, va trebui s\u0103 ad\u0103ug\u0103m la programul nostru urm\u0103toarele linii: <pre><code>#include &lt;ext/pb_ds/assoc_container.hpp&gt;\n#include &lt;ext/pb_ds/tree_policy.hpp&gt;\nusing namespace __gnu_pbds;\nusing ordered_set = tree&lt;int, null_type, std::less_equal&lt;int&gt;, rb_tree_tag, tree_order_statistics_node_update&gt;; \n</code></pre> \u00cen interiorul parantezelor ascu\u021bite de dup\u0103 <code>tree</code>, primul c\u00e2mp reprezint\u0103 tipul de date, \u00een acest caz <code>int</code>, al patrulea reprezint\u0103 tipul de arbore folosit, \u00een acest caz, <code>rb_tree</code>, care garanteaz\u0103 complexitatea logaritmic\u0103 a opera\u021biilor de inserare \u0219i \u0219tergere. Al treilea c\u00e2mp reprezint\u0103 tipul de comparator folosit, unde <code>std::less_equal</code> permite existen\u021ba a mai multor elemente egale (ca un <code>multiset</code>), iar <code>std::less</code> nu (ca un <code>set</code>).</p> <p>Totu\u0219i, de\u0219i structura __gnu_pbds ne ofer\u0103 multe avantaje, urm\u0103toarele lucruri trebuie luate \u00een considerare c\u00e2nd este folosit\u0103:</p> <ol> <li>Chiar dac\u0103 opera\u021biile au complexitate logaritmic\u0103, constanta este foarte mare.</li> <li>Dac\u0103 vrem s\u0103 interschimb\u0103m 2 astfel de structuri \u00een timp \\(O(1)\\), va trebui s\u0103 folosim metoda .swap(), cum apare \u00een codul de mai jos. Dac\u0103 am folosi func\u021bia <code>std::swap()</code>, aceasta ar avea complexitate liniar\u0103.</li> </ol>"},{"location":"dificil/small-to-large/#problema-e-penultimul-cox-kilonova","title":"Problem\u0103: E - Penultimul Cox -  Kilonova","text":"<p>Aceast\u0103 problem\u0103 se poate rezolva folosind o structur\u0103 de tip <code>__gnu_pbds</code> care admite mai multe chei egale (folose\u0219te comparatorul <code>std::less_equal</code>). Este u\u0219or s\u0103 ne d\u0103m seama c\u0103 r\u0103spunsul pentru fiecare nod este chiar <code>s[nod].order_of_key(v[nod] + 1)</code>. Acel +1 se datoreaz\u0103 faptului c\u0103 ne trebuie num\u0103rul de elemente mai mici sau egale cu \\(v[nod]\\), iar metoda <code>order_of_key</code> returneaz\u0103 num\u0103rul de elemente strict mai mici.</p> <p>O implementare a ideii de mai sus ar fi urm\u0103toarea:</p> <pre><code>#include &lt;iostream&gt;\n#include &lt;vector&gt;\n\n#include &lt;ext/pb_ds/assoc_container.hpp&gt;\n#include &lt;ext/pb_ds/tree_policy.hpp&gt;\nusing namespace __gnu_pbds;\n\n//avem elemente de tip int, care se repeta\nusing ordered_set = tree&lt;int, null_type, std::less_equal&lt;int&gt;, rb_tree_tag, tree_order_statistics_node_update&gt;; \n\nconstexpr int NMAX = 100005;\nstd::vector&lt;std::vector&lt;int&gt;&gt; G(NMAX);\nordered_set s[NMAX];\nint v[NMAX];\nint rez[NMAX];\n\nvoid dfs(int nod) {\n    for (auto x : G[nod]) {\n        dfs(x);\n        //la fel ca la set, operatia de swap ia tot O(1)\n        if (s[x].size() &gt; s[nod].size()){\n            s[x].swap(s[nod]);\n        }\n        for (auto x2 : s[x]){\n            s[nod].insert(x2);\n        }\n    }\n    //numarul de elemente din set mai mici sau egale cu v[nod]\n    rez[nod] = s[nod].order_of_key(v[nod] + 1);\n}\n\nint main() {\n    int n, i, t;\n    std::ios_base::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n    std::cin &gt;&gt; n;\n    for (i = 2; i &lt;= n; i++) {\n        std::cin &gt;&gt; t;\n        G[t].push_back(i);\n    }\n    for (i = 1; i &lt;= n; i++) {\n        std::cin &gt;&gt; v[i];\n        s[i].insert(v[i]);\n    }\n    dfs(1);\n    for (i = 1; i &lt;= n; i++){\n        std::cout &lt;&lt; rez[i] &lt;&lt; \" \";\n    }\n    return 0;\n}\n</code></pre>"},{"location":"dificil/small-to-large/#alte-probleme-si-resurse-utile","title":"Alte probleme \u0219i resurse utile","text":""},{"location":"dificil/small-to-large/#resurse-aditionale-despre-subiectele-abordate","title":"Resurse adi\u021bionale despre subiectele abordate","text":"<ul> <li>Small-to-large USACO GUIDE</li> <li>__gnu_pbds - GeeksForGeeks</li> <li>Urm\u0103toarele bloguri de pe Codeforces:<ul> <li>Blog 1</li> <li>Blog 2</li> <li>Blog 3</li> </ul> </li> </ul>"},{"location":"dificil/small-to-large/#probleme","title":"Probleme","text":"<ul> <li>Toska - Kilonova</li> <li>Lomsat Gerlal - Codeforces</li> <li>Arborel - Kilonova</li> <li>Magic Tree - CEOI 2019</li> <li>Alte probleme cu small-to-large de pe Kilonova</li> </ul>"},{"location":"dificil/square-root-decomposition/","title":"Descompuneri \u00een buc\u0103\u021bi de radical (Square Root Decomposition)","text":"<p>Autor: \u0218tefan-Cosmin D\u0103sc\u0103lescu</p> <p>\u00cen multe probleme de algoritmic\u0103, suntem nevoi\u021bi s\u0103 \u00eemp\u0103r\u021bim datele \u00een grupe mai mici pentru a ajunge s\u0103 ob\u021binem solu\u021bii optime sau cel pu\u021bin suficient de rapide pentru a ob\u021bine un punctaj foarte bun, chiar maxim \u00een anumite situa\u021bii. De cele mai multe ori, vom \u00eemp\u0103r\u021bi datele \u00een buc\u0103\u021bi cu o lungime aproximativ egal\u0103 cu \\(\\sqrt n\\), de unde vine \u0219i numele pentru care aceast\u0103 tehnic\u0103 este cunoscut\u0103 \u00een jargonul interna\u021bional, Square Root Decomposition. </p> <p>\u00cen acest articol, vom prezenta c\u00e2teva dintre cele mai cunoscute tipuri de descompuneri \u0219i grup\u0103ri existente care folosesc aceast\u0103 tehnic\u0103, fie c\u0103 e vorba de gruparea elementelor din vector, gruparea query-urilor sau chiar abord\u0103ri diferite \u00een func\u021bie de dimensiunea datelor, toate aceste tehnici au un numitor comun, \u0219i anume prezen\u021ba valorii \\(\\sqrt n\\) drept un etalon de separare a datelor. </p>","tags":["structuri de date","optimizari","precalculari"]},{"location":"dificil/square-root-decomposition/#impartirea-datelor-in-bucati-de-radical","title":"\u00cemp\u0103r\u021birea datelor \u00een buc\u0103\u021bi de radical","text":"<p>Numit \u00een jargonul rom\u00e2nesc \u0219i sub numele de \u0218menul lui Batog, aceast\u0103 tehnic\u0103 const\u0103 \u00een prelucrarea unui \u0219ir de valori prin \u00eemp\u0103r\u021birea acestuia \u00een buc\u0103\u021bi care acoper\u0103 tot \u0219irul, iar lungimea maxim\u0103 a fiec\u0103rei buc\u0103\u021bi este \u00een jur de \\(\\sqrt n\\). Pentru a afla num\u0103rul de ordine al grupei unde se afl\u0103 o valoare, vom putea folosi formula \\(\\frac{i}{bk}\\), unde \\(i\\) este pozi\u021bia curent\u0103, iar \\(bk\\) este dimensiunea unei grupe (a unui bucket), de regul\u0103 aceasta fiind aproximativ \\(\\sqrt n\\). </p> <p>\u00cen cele mai multe cazuri, query-urile pe care le putem rezolva folosind aceast\u0103 metod\u0103 sunt query-uri relativ simple, precum cele de sum\u0103 sau maxim, query-uri care se pot procesa \u0219i folosind alte structuri de date, precum arborii de intervale sau arborii indexa\u021bi binar. Totu\u0219i, \u00een unele situa\u021bii, se recomand\u0103 abord\u0103ri de tipul square root decomposition, deoarece implement\u0103rile se vor dovedi mai scurte \u0219i mai simplu de abordat, \u00een special \u00een cazul unor limite de timp mai pu\u021bin stricte \u0219i/sau a unor restric\u021bii mai mici.</p> <p>Observa\u021bie</p> <p>Vom presupune \u00een cele ce urmeaz\u0103 c\u0103 indexarea valorilor se face de la \\(0\\). </p> <p>De regul\u0103, vom vrea s\u0103 \u021binem memorate informa\u021bii pentru fiecare grup\u0103, iar atunci c\u00e2nd actualiz\u0103m o valoare, opera\u021bia va fi efectuat\u0103 \u00een timp constant, deoarece schimb\u0103m informa\u021biile dintr-o singur\u0103 grup\u0103. \u00cen ceea ce prive\u0219te interog\u0103rile, complexitatea acestora este \\(O(\\sqrt n)\\) deoarece dac\u0103 avem un interval de forma \\([L, R]\\), noi vom calcula r\u0103spunsul folosind trei pa\u0219i, ace\u0219tia fiind urm\u0103torii:</p> <ul> <li>Intervalul \\([L, x]\\), unde \\(x\\) este cap\u0103tul dreapta al grup\u0103rii \u00een care se afl\u0103 \\(L\\): se poate calcula r\u0103spunsul brut, prin procesarea fiec\u0103rei valori din grup\u0103. </li> <li>Intervalul \\([x+1, y]\\), unde \\(y\\) este cap\u0103tul din dreapta al ultimei grupe care se afl\u0103 \u00een \u00eentregime \u00een intervalul din query. Pentru aceste grupe, se proceseaz\u0103 r\u0103spunsul total corespunz\u0103tor acestui interval \u0219i se consider\u0103 \u00een contextul r\u0103spunsului final. </li> <li>Intervalul \\([y+1, R]\\), unde \\(y+1\\) este cap\u0103tul st\u00e2nga al grup\u0103rii \u00een care se afl\u0103 \\(R\\): se poate calcula r\u0103spunsul brut, prin procesarea fiec\u0103rei valori din grup\u0103.</li> </ul> <p>Observa\u021bie</p> <p>\u00cen mod particular, dac\u0103 \\(L\\) \u0219i \\(R\\) se afl\u0103 \u00een aceea\u0219i grup\u0103, vom putea afla brut r\u0103spunsul cerut, consider\u00e2nd pe r\u00e2nd fiecare valoare din interval. </p> <p>Exemplu</p> <p>De exemplu, dac\u0103 dimensiunea unei grup\u0103ri este \\(5\\), iar intervalul \\([L, R]\\) este \\([7, 21]\\), r\u0103spunsul se va afla \u00een modul urm\u0103tor:</p> <ul> <li>Intervalul \\([7, 9]\\): Fiind o grupare care nu se afl\u0103 \u00een \u00eentregime \u00een interogarea dat\u0103, vom procesa valorile \u00eentr-o manier\u0103 brut\u0103. </li> <li>Intervalele \\([10, 14]\\) \u0219i \\([15, 19]\\): Deoarece aceste intervale se afl\u0103 \u00een \u00eentregime \u00een interogarea dat\u0103, le vom procesa folosind precalcularea f\u0103cut\u0103 anterior pentru grup\u0103rile \u00eentregi. </li> <li>Intervalul \\([20, 21]\\): Fiind o grupare care nu se afl\u0103 \u00een \u00eentregime \u00een interogarea dat\u0103, vom procesa valorile \u00eentr-o manier\u0103 brut\u0103. </li> </ul>","tags":["structuri de date","optimizari","precalculari"]},{"location":"dificil/square-root-decomposition/#cand-folosim-aceste-tehnici","title":"C\u00e2nd folosim aceste tehnici?","text":"<p>De multe ori, pentru a g\u0103si abordarea optim\u0103 pentru asemenea probleme, trebuie s\u0103 avem \u00een vedere faptul c\u0103 dac\u0103 avem restric\u021bii mai mici (de regul\u0103, c\u00e2nd \\(n \\approx 10^5\\)), o abordare de acest tip poate fi foarte eficient\u0103 datorit\u0103 flexibilit\u0103\u021bii pe care o avem, precum \u0219i a faptului c\u0103 putem s\u0103 variem punctul limit\u0103 \u00een func\u021bie de eficien\u021ba celor dou\u0103 abord\u0103ri.</p> <p>Cu alte cuvinte, dac\u0103 avem o abordare care ruleaz\u0103 \u00een \\(O(a \\cdot x)\\) \u0219i alta care ruleaz\u0103 \u00een \\(O(b \\cdot \\frac{n}{x})\\), unde \\(a\\) \u0219i \\(b\\) sunt constante, punctul de cotitur\u0103 \u00eentre cele dou\u0103 abord\u0103ri este acela \u00een care cele dou\u0103 ecua\u021bii au valori egale, din acest motiv nefiind mereu optim s\u0103 abord\u0103m diferit \u00eencep\u00e2nd de la \\(O(\\sqrt n)\\), deoarece uneori aceast\u0103 schimbare trebuie produs\u0103 mai devreme sau mai t\u00e2rziu.</p>","tags":["structuri de date","optimizari","precalculari"]},{"location":"dificil/square-root-decomposition/#problema-dynamic-range-sum-queries-de-pe-cses","title":"Problema Dynamic Range Sum Queries de pe CSES","text":"<p>De\u0219i aceast\u0103 problem\u0103 se poate rezolva \u00eentr-un mod mai eficient folosind arborii de intervale, actualiz\u0103rile \u0219i interog\u0103rile reprezint\u0103 un exemplu foarte bun pentru ilustrarea acestei tehnici. Se va observa faptul c\u0103 pentru fiecare bucat\u0103 din vector se va \u021bine suma acesteia, iar queryurile vor fi procesate conform descrierii de mai sus. </p> <pre><code>#include &lt;iostream&gt;\n#include &lt;vector&gt;\n\nusing namespace std;\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n\n    int n, q;\n    cin &gt;&gt; n &gt;&gt; q;\n\n    vector&lt;int&gt; v(n);\n    for (int i = 0; i &lt; n; i++) {\n        cin &gt;&gt; v[i];\n    }\n\n    int sz = 450;\n\n    vector&lt;long long&gt; bk(n/sz + 1);\n\n    for (int i = 0; i &lt; n; i++) {\n        bk[i / sz] += v[i];\n    }\n\n    for (; q; q--) {\n        int tp;\n        cin &gt;&gt; tp;\n\n        if (tp == 1) {\n            int pos, val;\n            cin &gt;&gt; pos &gt;&gt; val;\n\n            pos--;\n            bk[pos / sz] += (val - v[pos]);\n            v[pos] = val;\n        }\n\n        else {\n            int L, R;\n            cin &gt;&gt; L &gt;&gt; R;\n            L--; R--;\n\n            long long sum = 0;\n            if (L / sz == R / sz) {\n                for (int i = L; i &lt;= R; i++) {\n                    sum += v[i];\n                }\n            }\n            else {\n                int pos = L;\n                while (pos / sz == L / sz) {\n                    sum += v[pos];\n                    pos++;\n                }\n                while (pos / sz != R / sz) {\n                    sum += bk[pos / sz];\n                    pos += sz;\n                }\n                while (pos &lt;= R) {\n                    sum += v[pos];\n                    pos++;\n                }\n            }\n\n            cout &lt;&lt; sum &lt;&lt; '\\n';\n        }\n    }\n\n    return 0;\n}\n</code></pre>","tags":["structuri de date","optimizari","precalculari"]},{"location":"dificil/square-root-decomposition/#problema-consecutive-max-difference-de-pe-cs-academy","title":"Problema Consecutive Max Difference de pe CS Academy","text":"<p>Observa\u021bie</p> <p>Aceast\u0103 problem\u0103, \u00eempreun\u0103 cu varia\u021bii ale ei este explicat\u0103 \u00een detaliu \u0219i \u00een acest blog de pe Codeforces.</p> <p>Pentru a rezolva aceast\u0103 problem\u0103, trebuie s\u0103 ne folosim de faptul c\u0103 \u0219tim o valoare minim\u0103 a acestei diferen\u021be, aceasta fiind raportul dintre diferen\u021ba dintre maxim \u0219i minim, respectiv num\u0103rul de perechi de valori adiacente. Folosind aceast\u0103 regul\u0103, tot ce mai avem de f\u0103cut este s\u0103 grup\u0103m valori \u00een functie de zona unde se afl\u0103 ele \u00een \u0219ir (putem \u00eemp\u0103r\u021bi valorile \u00een \\(n\\) grupe astfel), iar mai apoi vom calcula diferen\u021bele \u00eentre cea mai mare valoare din grupa precedent\u0103 \u0219i cea mai mic\u0103 valoare din grupa urm\u0103toare. </p> <pre><code>long long maxDifference(const vector&lt;int&gt;&amp; v) {\n    int min_val = *min_element(v.begin(), v.end());\n    int max_val = *max_element(v.begin(), v.end());\n    double dif = max_val - min_val;\n    int num_pairs = v.size() - 1;\n\n    int aprox = dif / num_pairs;\n\n    int n = v.size();\n    double bucket_size = ((double)max_val - min_val) / n;\n\n    vector&lt;int&gt; buckets[v.size()];\n    for (int i = 0; i &lt; v.size(); i++) {\n        dif = v[i] - min_val;\n        int bucket = (int)(((double)v[i] - min_val) / bucket_size);\n\n        if (bucket == v.size()) { bucket--; }\n        buckets[bucket].push_back(v[i]);\n    }\n\n    int prev_max = 0;\n    long long ans = 0;\n    for (int i = 0; i &lt; v.size(); i++) {\n        if (!buckets[i].size() == 0) {\n            min_val = *min_element(buckets[i].begin(), buckets[i].end());\n            max_val = *max_element(buckets[i].begin(), buckets[i].end());\n\n            if (i) {\n                ans = max(ans, (long long)min_val - prev_max);\n            }\n            prev_max = max_val;\n        }\n    }\n\n    return ans;\n}\n</code></pre>","tags":["structuri de date","optimizari","precalculari"]},{"location":"dificil/square-root-decomposition/#impartirea-queryurilor-in-bucati-de-radical-algoritmul-lui-mo","title":"\u00cemp\u0103r\u021birea queryurilor \u00een buc\u0103\u021bi de radical - Algoritmul lui Mo","text":"<p>Pentru a calcula query-uri mai complicate, de multe ori ne putem g\u00e2ndi la a grupa query-urile pentru a face actualiz\u0103rile \u0219i interog\u0103rile mai pu\u021bin costisitoare din punct de vedere al timpului. O metod\u0103 foarte popular\u0103 de a face acest lucru const\u0103 \u00een gruparea query-urilor \u00een func\u021bie de grupa \u00een care se afl\u0103 pozi\u021bia de start, iar \u00een caz de egalitate, queryurile se ordoneaz\u0103 cresc\u0103tor \u00een func\u021bie de cap\u0103tul din dreapta. </p> <p>Aceast\u0103 metod\u0103 se nume\u0219te Algoritmul lui Mo \u0219i prin folosirea ei pentru a reordona queryurile, ne asigur\u0103m c\u0103 num\u0103rul de opera\u021bii pe care \u00eel facem \u00een medie la fiecare query este de \\(O(\\sqrt n)\\), lucru ce se poate motiva prin \u00eensumarea a dou\u0103 elemente de complexitate:</p> <ul> <li> <p>Dac\u0103 avem dou\u0103 (sau mai multe) queryuri din acela\u0219i bucket, cap\u0103tul din st\u00e2nga se va mi\u0219ca cu cel mult \\(\\sqrt n\\), iar num\u0103rul total de pa\u0219i pe care \u00eei facem la dreapta este de \\(n\\). Deoarece num\u0103rul de bucketuri este \\(O(\\sqrt n)\\), atunci contribu\u021bia la complexitate de la aceste queryuri este \\(O(n \\sqrt n)\\).</p> </li> <li> <p>Dac\u0103 avem dou\u0103 queryuri din bucketuri diferite, putem avea \u00een cel mai r\u0103u caz \\(n\\) pa\u0219i, dar deoarece num\u0103rul de bucketuri este \\(O(\\sqrt n)\\), atunci contribu\u021bia la complexitate de la aceste queryuri este \\(O(n \\sqrt n)\\).</p> </li> </ul> <p>\u00cen total, complexitatea se reduce la \\(O(n \\sqrt n)\\), presupun\u00e2nd c\u0103 opera\u021biile auxiliare pe care le efectu\u0103m se realizeaz\u0103 \u00een timp constant. </p> <p>Observa\u021bie</p> <p>Pentru a optimiza mai mult aceast\u0103 metod\u0103, putem s\u0103 sort\u0103m invers elementele din aceea\u0219i grup\u0103 dac\u0103 avem de-a face cu grupe cu un num\u0103r par, deoarece putem astfel s\u0103 altern\u0103m direc\u021bia \u00een care ad\u0103ug\u0103m \u0219i scoatem valori la cap\u0103tul din dreapta, constanta reduc\u00e2ndu-se cu un factor de aproximativ \\(2\\) \u00een majoritatea cazurilor.</p> <p>Pentru a explica acest algoritm, voi prezenta o problem\u0103 clasic\u0103 ce folose\u0219te aceast\u0103 metod\u0103. </p>","tags":["structuri de date","optimizari","precalculari"]},{"location":"dificil/square-root-decomposition/#problema-fsecv-de-la-lot-juniori-2019","title":"Problema fsecv de la Lot Juniori 2019","text":"<p>Pentru a calcula rapid c\u00e2te valori au aceea\u0219i frecven\u021b\u0103 egal\u0103 cu \\(k\\), trebuie s\u0103 ne asigur\u0103m c\u0103 num\u0103rul de opera\u021bii de ad\u0103ugare \u0219i \u0219tergere nu este foarte mare, lucru ce \u00eel putem realiza folosind algoritmul lui Mo. Tot ce ne r\u0103m\u00e2ne de f\u0103cut este s\u0103 \u021binem doi vectori de frecven\u021b\u0103, unul cu frecven\u021ba fiec\u0103rui element, iar cel de-al doilea, cu frecven\u021ba frecven\u021bei elementelor. </p> <p>Se poate observa c\u0103 queryurile sunt ordonate dup\u0103 raportul dintre cap\u0103tul din st\u00e2nga \u0219i dimensiunea bucketului, iar \u00een caz de egalitate, dup\u0103 cap\u0103tul din dreapta. De asemenea, pe m\u0103sur\u0103 ce proces\u0103m queryurile, vom ajusta capetele st\u00e2nga \u0219i dreapta \u00een func\u021bie de opera\u021biile pe care trebuie s\u0103 le facem, ad\u0103ug\u00e2nd sau sco\u021b\u00e2nd valori dup\u0103 caz, a\u0219a cum se poate observa \u00een func\u021bia \u00een care proces\u0103m efectiv queryurile. </p> <p>Mai jos pute\u021bi g\u0103si o implementare detaliat\u0103 a problemei men\u021bionate mai sus, aceasta fiind un exemplu clasic al algoritmului lui Mo. </p> <pre><code>#include &lt;bits/stdc++.h&gt;\n\nusing namespace std;\nusing ll = long long;\n\nconst int MAX_A = 1e5, MAX_N = 1e5;\nint a[MAX_N + 5], freq[2 * MAX_A + 5], cnt[MAX_A + 5], blockSize;\n\nstruct Query {\n    int l, r, k, idx;\n\n    bool operator &lt; (Query other) const {\n        return make_pair(l / blockSize, r) &lt; make_pair(other.l / blockSize, other.r);\n    }\n};\n\nvoid add (int idx) {\n    int val = a[idx] + MAX_A; \n\n    if (freq[val] &gt; 0) {\n        cnt[freq[val]]--;\n    }\n    cnt[++freq[val]]++;\n}\n\nvoid remove (int idx) {\n    int val = a[idx] + MAX_A; \n\n    if (freq[val] &gt; 0) {\n        cnt[freq[val]]--;\n    }\n    cnt[--freq[val]]++;\n}\n\nint getAnswer (int idx) {\n    return cnt[idx];\n}\n\nvector&lt;int&gt; MoSAlgorithm (vector&lt;Query&gt; queries) {\n    vector&lt;int&gt; answers (queries.size());\n    sort(queries.begin(), queries.end());\n\n    int curL = 0, curR = -1, i;\n    for (i = 1; i &lt; queries.size(); i++) {\n        Query q = queries[i];\n\n        while (curL &gt; q.l) {\n            add(--curL);\n        }\n\n        while (curR &lt; q.r) {\n            add(++curR);\n        }\n\n        while (curL &lt; q.l) {\n            remove(curL++);\n        }\n\n        while (curR &gt; q.r) {\n            remove(curR--);\n        }\n        answers[q.idx] = getAnswer(q.k);\n    }\n\n    return answers;\n}\n\nint main() {\n\n    ifstream cin(\"fsecv.in\");\n    ofstream cout(\"fsecv.out\");\n\n    int n, q, i;\n    cin &gt;&gt; n &gt;&gt; q;\n\n    blockSize = (int) sqrt(n);\n    for (i = 1; i &lt;= n; i++) {\n        cin &gt;&gt; a[i];\n    }\n\n    vector&lt;Query&gt; queries(q + 1);\n    for (i = 1; i &lt;= q; i++) {\n        cin &gt;&gt; queries[i].l &gt;&gt; queries[i].r &gt;&gt; queries[i].k;\n        queries[i].idx = i;\n    }\n\n    vector&lt;int&gt; output = MoSAlgorithm(queries);\n    for (i = 1; i &lt; output.size(); i++) {\n        cout &lt;&lt; output[i] &lt;&lt; \"\\n\";\n    }\n    return 0;\n}\n</code></pre>","tags":["structuri de date","optimizari","precalculari"]},{"location":"dificil/square-root-decomposition/#procesarea-datelor-in-functie-de-tipul-queryurilor-sau-a-frecventelor","title":"Procesarea datelor \u00een func\u021bie de tipul queryurilor sau a frecventelor","text":"<p>\u00cen alte tipuri de probleme, suntem nevoi\u021bi s\u0103 rezolv\u0103m dou\u0103 probleme diferite pe care s\u0103 le combin\u0103m pentru a ob\u021bine o solu\u021bie c\u00e2t mai bun\u0103 posibil, practic lu\u00e2nd avantajele fiec\u0103rei metode cu scopul de a ob\u021bine o solu\u021bie final\u0103 optim\u0103 pentru datele de care dispunem. Aici am prezentat dou\u0103 asemenea exemple.</p>","tags":["structuri de date","optimizari","precalculari"]},{"location":"dificil/square-root-decomposition/#problema-jumpsum-de-pe-kilonova","title":"Problema Jumpsum de pe Kilonova","text":"<p>Pentru a rezolva aceast\u0103 problem\u0103, plec\u0103m de la faptul c\u0103 dac\u0103 am vrea s\u0103 rezolv\u0103m un query \u00een mod brut, complexitatea ar fi \\(O(\\frac{n}{y})\\), ceea ce pentru valori mici ale lui \\(y\\), ne-ar cauza mari probleme din punct de vedere al vitezei programului. </p> <p>Din acest motiv, o idee care se impune imediat este aceea de a precalcula r\u0103spunsurile pentru c\u00e2t mai multe valori ale lui \\(y\\), pentru a evita aceast\u0103 problem\u0103 pe viitor. Totu\u0219i, nu putem precalcula toate r\u0103spunsurile, deoarece complexitatea ar deveni \\(O(n^2)\\). Din acest motiv, recurgem la o solu\u021bie de compromis, care folose\u0219te avantajele ambelor metode, iar din acest motiv, vom precalcula r\u0103spunsurile pentru toate valorile mai mici de \\(\\sqrt n\\), respectiv brut pentru toate valorile mai mari de \\(\\sqrt n\\), astfel complexitatea devenind \\(n \\sqrt n\\).</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nlong long n, q, sp[302][100002], v[302];\n\nint main() {\n    cin &gt;&gt; n;\n\n    for (int i = 1; i &lt;= n; i++) {\n        cin &gt;&gt; v[i];\n    }\n\n    for (int pas = 1; pas &lt;= min(300, n); pas++) {\n        for (int i = 1; i &lt;= n; i++) {\n            sp[pas][i] = v[i];\n            if(i &gt; pas) {\n                sp[pas][i] += sp[pas][i - pas];\n            }\n        }\n    }\n\n    cin &gt;&gt; q;\n    for (; q; q--) {\n        int x, y;\n        cin &gt;&gt; x &gt;&gt; y;\n\n        if (y &lt;= min(300, n)) {\n            cout &lt;&lt; sp[y][x] &lt;&lt; '\\n';\n        }\n        else {\n            long long ans = 0;\n            while (x &gt; 0) {\n                ans += v[x];\n                x -= y;\n            }\n            cout &lt;&lt; ans &lt;&lt; '\\n';\n        }\n    }\n}\n</code></pre>","tags":["structuri de date","optimizari","precalculari"]},{"location":"dificil/square-root-decomposition/#problema-bvarcolaci-de-la-oni-2015","title":"Problema Bvarcolaci de la ONI 2015","text":"<p>Pentru a rezolva aceast\u0103 problem\u0103, este foarte important s\u0103 \u00eemp\u0103r\u021bim valorile \u00een func\u021bie de frecven\u021ba \u00een care apar. Cu alte cuvinte, dac\u0103 un element apare de \\(x\\) ori \u00een \u0219ir, lungimea maxim\u0103 a unei secven\u021be \u00een care poate fi majoritar este de cel mult \\(2 \\cdot x - 1\\), ceea ce ne motiveaz\u0103 s\u0103 avem dou\u0103 abord\u0103ri diferite \u00een func\u021bie de frecven\u021ba elementelor. </p> <p>Dac\u0103 un element apare de cel pu\u021bin \\(\\sqrt n\\) ori, putem afla num\u0103rul de secven\u021be cu frecven\u021b\u0103 majoritar\u0103 \u00een \\(O(n)\\) cu ajutorul unor sume par\u021biale, num\u0103r\u00e2nd o diferen\u021b\u0103 \u00eentre valorile care apar \u0219i cele care nu apar (reducem problema la un \u0219ir binar).</p> <p>Altfel, vom putea fixa pozi\u021bia primului \u0219i ultimului element egal cu valoarea curent\u0103, iar cu ajutorul unor cazuri, vom putea ajunge s\u0103 g\u0103sim r\u0103spunsul \u00een \\(O(frq^2)\\), unde \\(frq\\) este frecven\u021ba valorii curente.</p> <pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\nifstream f(\"bvarcolaci.in\");\nofstream g(\"bvarcolaci.out\");\n\nint n, v[250002], frq[250002], xx[500002];\nvector&lt;int&gt; pos[250002];\n\nlong long fct (long long a, long long b, long long c) {\n    if(a &gt; b) {\n        swap(a, b);\n    }\n    a = min(a, c);\n    b = min(b, c);\n    if (a + b &lt;= c) {\n        return (a+1) * (b+1);\n    }\n    long long sol = (a+1);\n    sol = sol + 1LL * (c - b + 1) * b;\n    int mx = (b-1);\n    int mn = max(0LL, c - a - 1);\n    sol = sol + 1LL * mx * (mx+1)/2;\n    sol = sol - 1LL * mn * (mn+1)/2;\n    return sol;\n}\nint main() {\n    long long sol = 0;\n    f &gt;&gt; n;\n    int rad = (int)sqrt(n);\n    for (int i = 1; i &lt;= n; ++i) {\n        f &gt;&gt; v[i];\n        pos[v[i]].push_back(i);\n    }\n    for (int i = 1; i &lt;= n; ++i) {\n        if (pos[i].size() &lt;= rad) {\n            for (int j = 0; j &lt; pos[i].size(); ++j) {\n                for (int k = j; k &lt; pos[i].size(); ++k) {\n                    int st = pos[i][j];\n                    int dr = pos[i][k];\n                    int len = (dr - st + 1);\n                    int frq = k - j + 1;\n                    if (frq &lt; len / 2 + 1) {\n                        continue;\n                    }\n                    int disp = frq * 2 - len - 1;\n                    int catest;\n                    if (j != 0) {\n                        catest = st - pos[i][j-1] - 1;\n                    }\n                    else {\n                        catest = st - 1;\n                    }\n                    int catedr;\n                    if (k + 1 == pos[i].size()) {\n                        catedr = n - dr;\n                    }\n                    else {\n                        catedr = pos[i][k + 1] - dr - 1;\n                    }\n                    sol += fct(catest, catedr, disp);\n                }\n            }\n        }\n        else {\n            memset(xx, 0, sizeof(xx));\n            int st = 249999;\n            int nr = 0;\n            for (int j = 1; j &lt;= n; ++j) {\n                if(v[j] == i) {\n                    frq[j] = frq[j-1] + 1;\n                }\n                else {\n                    frq[j] = frq[j-1] - 1;\n                }\n                ++xx[250000 + frq[j-1]];\n                if (250000 + frq[j-1] &lt;= st) {\n                    ++nr;\n                }\n                while (frq[j] + 250000 &lt;= st) {\n                    nr -= xx[st], --st;\n                }\n                while (frq[j] + 250000 &gt; st + 1) {\n                    ++st, nr += xx[st];\n                }\n                sol += nr;\n            }\n        }\n    }\n    g &lt;&lt; sol &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["structuri de date","optimizari","precalculari"]},{"location":"dificil/square-root-decomposition/#recalcularea-datelor-dupa-un-numar-fix-de-queryuri","title":"Recalcularea datelor dup\u0103 un num\u0103r fix de queryuri","text":"<p>Mai exist\u0103 \u0219i alte probleme \u00een care r\u0103spunsul final const\u0103 \u00een unirea unor r\u0103spunsuri precalculate, \u00eempreun\u0103 cu un num\u0103r mic de elemente schimbate care trebuie procesate separat. De\u0219i nu avem prezentate probleme de acest fel, acest tip de abordare este foarte popular mai ales atunci c\u00e2nd lucr\u0103m cu unele tipuri de queryuri pe arbore, unde de multe ori este optim s\u0103 recalcul\u0103m r\u0103spunsurile odat\u0103 la \\(\\sqrt n\\) queryuri. </p> <p>Problema de mai jos reprezint\u0103 un exemplu mai simplu care combin\u0103 \u0219i cuno\u0219tin\u021bele c\u0103p\u0103tate anterior la algoritmul lui Mo.</p>","tags":["structuri de date","optimizari","precalculari"]},{"location":"dificil/square-root-decomposition/#problema-rangemode-de-pe-infoarena","title":"Problema Rangemode de pe infoarena","text":"<p>Pentru a rezolva aceast\u0103 problem\u0103, vom pleca de la solu\u021bia obi\u0219nuit\u0103 pe care o avem folosind algoritmul lui Mo, unde sort\u0103m queryurile \u00een ordine cresc\u0103toare a grupei de unde \u00eencep. Dac\u0103 am proceda conform unui Mo obi\u0219nuit, ar trebui s\u0103 \u021binem \u0219i un set \u00een care s\u0103 p\u0103str\u0103m frecven\u021bele maxime deoarece avem nevoie s\u0103 afl\u0103m elementul minim cu frecven\u021ba maxim\u0103. Totu\u021bi, o complexitate de genul \\(O(q \\sqrt n \\log n)\\) este prea \u00eenceat\u0103. </p> <p>Ne putem g\u00e2ndi acum la ce se \u00eent\u00e2mpl\u0103 cu adev\u0103rat c\u00e2nd rul\u0103m updateurile \u0219i queryurile \u00eentr-un bucket al algoritmului lui Mo. Noi continu\u0103m s\u0103 progres\u0103m spre cap\u0103tul dreapta al vectorului, ad\u0103ug\u00e2nd valorile \u00een structura noastr\u0103 de date. Singurele ajust\u0103ri pe care trebuie s\u0103 le facem sunt atunci c\u00e2nd trebuie s\u0103 ne mi\u0219c\u0103m \u00een bucata par\u021bial\u0103 de la \u00eenceputul query-urilor, bucat\u0103 care are o lungime de cel mult \\(\\sqrt n\\). Din acest motiv, ce putem face acum este s\u0103 reducem abordarea la doar ni\u0219te ad\u0103ug\u0103ri, cu alte cuvinte vom ad\u0103uga valori una c\u00e2te una, ajust\u00e2nd cel mai bun r\u0103spuns \u00eentr-o manier\u0103 foarte simpl\u0103, deoarece putem acum s\u0103 ne d\u0103m seama dac\u0103 valorile ad\u0103ugate la un moment dat pot fi r\u0103spunsuri mai bune. </p> <p>Pentru a trata cele \\(\\sqrt n\\) r\u0103mase, vom \u021bine o copie a celor mai bune r\u0103spunsuri \u0219i vom ad\u0103uga doar valorile r\u0103mase \u00eentr-o manier\u0103 similar\u0103, p\u0103str\u00e2nd cu aten\u021bie noile r\u0103spunsuri pentru valorile r\u0103mase. </p> <pre><code>#include &lt;fstream&gt;\n#include &lt;vector&gt;\n#include &lt;algorithm&gt;\nusing namespace std;\n\nint n, q, v[100002], ans[100002], frq[100002];\n\nstruct queries {\n    int L, R, pi;\n};\nqueries vq[100002];\n\nbool cmp (queries a, queries b) {\n    if (a.L / 300 != b.L / 300) {\n        return a.L &lt; b.L;\n    }\n    return a.R &lt; b.R;\n}\n\nvoid add (int pos, int &amp;mx) {\n    frq[v[pos]]++;\n    if (mx == 100001 || frq[v[pos]] &gt; frq[mx] || (frq[v[pos]] == frq[mx] &amp;&amp; v[pos] &lt; mx)) {\n        mx = v[pos];\n    }\n}\nint main() {\n    ifstream cin(\"rangemode.in\");\n    ofstream cout(\"rangemode.out\");\n\n    cin &gt;&gt; n &gt;&gt; q;\n    for (int i = 1; i &lt;= n; i++) {\n        cin &gt;&gt; v[i];\n    }\n\n    for (int i = 1; i &lt;= q; i++) {\n        cin &gt;&gt; vq[i].L &gt;&gt; vq[i].R;\n        vq[i].pi = i;\n    }\n\n    sort(vq + 1, vq + q + 1, cmp);\n\n    int pq = 1;\n    for (int buk = 0; buk &lt; 350; buk++) {\n        int bg = min(n+1, (buk+1) * 300), mxbigger = 100001;\n        while (pq &lt;= q) {\n            int poz = vq[pq].L / 300;\n            if(poz != buk)\n                break;\n            while (bg &lt;= vq[pq].R) {// adaugam valorile noi\n                add(bg++, mxbigger);\n            }\n            int mx2 = mxbigger;\n            // procesam bucata din stanga\n            for (int Lpos = min(vq[pq].R, (buk+1) * 300 - 1); Lpos &gt;= vq[pq].L; Lpos--) {\n                add(Lpos, mx2);\n            }\n            ans[vq[pq].pi] = mx2;\n            for (int Lpos = min(vq[pq].R, (buk+1) * 300 - 1); Lpos &gt;= vq[pq].L; Lpos--) {\n                frq[v[Lpos]]--;\n            }\n            pq++;\n        }\n        for (int i = 0; i &lt;= 100000; i++) {\n            frq[i] = 0;\n        }\n    }\n\n    for (int i = 1; i &lt;= q; i++) {\n        cout &lt;&lt; ans[i] &lt;&lt; '\\n';\n    }\n    return 0;\n}\n</code></pre>","tags":["structuri de date","optimizari","precalculari"]},{"location":"dificil/square-root-decomposition/#concluzii","title":"Concluzii","text":"<p>\u00cen ceea ce prive\u0219te \u00eemp\u0103r\u021birea pe buc\u0103\u021bi de radical, fie c\u0103 e vorba de procesarea unor grupe de valori separat sau a unor query-uri sau chiar folosirea unor abord\u0103ri diferite \u00een func\u021bie de tipul de query dat, aceste tehnici se dovedesc a fi foarte utile \u0219i frecvent \u00eent\u00e2lnite \u00een concursurile de informatic\u0103, adaptarea \u00een func\u021bie de situa\u021bie fiind foarte important\u0103, a\u0219a cum se poate observa prin alegerea punctului limit\u0103 care depinde \u00een func\u021bie de problem\u0103. </p> <p>Problemele \u0219i resursele pe care le ve\u021bi g\u0103si \u00een cele ce urmeaz\u0103 acoper\u0103 toate aceste tehnici, solu\u021biile optime fiind de cele mai multe ori abord\u0103ri similare cu cele prezentate aici, iar dup\u0103 cum se poate observa, aceast\u0103 familie de algoritmi \u0219i tehnici a ap\u0103rut foarte mult mai ales \u00een ultimii ani \u00een aplica\u021bii tot mai atipice. </p>","tags":["structuri de date","optimizari","precalculari"]},{"location":"dificil/square-root-decomposition/#probleme-suplimentare","title":"Probleme suplimentare","text":"<ul> <li>infoarena mayonaka</li> <li>InfoOltenia 2020 Toorcmmdc</li> <li>Junior Challenge 2020 Aparate</li> <li>infoarena qxy</li> <li>ONI 2022 subsir</li> <li>infoarena suma6</li> <li>infoarena numerex</li> <li>ONI 2015 ksecv</li> <li>ONI 2018 Mexitate</li> <li>Lot Juniori 2019 dss</li> <li>USACO Platinum Minimizing Haybales</li> <li>IIOT 2024 XYQueries</li> <li>ONI 2022 Baraj Seniori Piezisa</li> <li>infoarena arbore</li> <li>Codeforces Sum of Progression</li> <li>Codeforces Array Queries</li> <li>Codeforces Sakurako's Test</li> <li>Codeforces Robot Queries</li> <li>Codeforces Space Harbour</li> <li>Codeforces Ann and Books</li> <li>Codeforces XOR and Favorite Number</li> </ul>","tags":["structuri de date","optimizari","precalculari"]},{"location":"dificil/square-root-decomposition/#lectura-suplimentara","title":"Lectur\u0103 suplimentar\u0103","text":"<ul> <li>cp-algorithms: Sqrt Decomposition</li> <li>SEPI Infobits F1 - paginile 99-137</li> <li>USACO Guide Sqrt Decomposition</li> <li>Infoarena - The Square Root Trick</li> <li>Infoarena - Multe \"smenuri\" de programare in C/C++... si nu numai!</li> <li>Codeforces - Square root decomposition and applications</li> <li>Codeforces - An alternative sorting order for Mo's algorithm</li> <li>Codeforces - Mo's Algorithm on Trees</li> </ul>","tags":["structuri de date","optimizari","precalculari"]},{"location":"dificil/ternary-search/","title":"C\u0103utare ternar\u0103","text":"<p>Autor: \u0218tefan-Cosmin D\u0103sc\u0103lescu</p>","tags":["sortare","cautari","matematica"]},{"location":"dificil/ternary-search/#introducere","title":"Introducere","text":"<p>Un algoritm de c\u0103utare ternar\u0103 este o tehnic\u0103 \u00een informatic\u0103 pentru a g\u0103si minimul sau maximul unei func\u021bii unimodale (care are un singur punct/interval cu valoare maxim\u0103/minim\u0103). </p> <p>Spre deosebire de alte c\u0103ut\u0103ri similare precum c\u0103utarea binar\u0103, c\u0103utarea ternar\u0103 este util\u0103 pentru a afla dac\u0103 valoarea extrem\u0103 nu se g\u0103se\u0219te \u00een prima sau ultima treime a spa\u021biului de c\u0103utare, algoritmul repet\u00e2ndu-se pentru celelalte dou\u0103 treimi ale intervalului c\u0103utat. </p> <p>C\u0103utarea ternar\u0103 este un exemplu de algoritm de tipul divide et impera, al\u0103turi de c\u0103utarea binar\u0103 \u0219i al\u021bi algoritmi similari. </p>","tags":["sortare","cautari","matematica"]},{"location":"dificil/ternary-search/#functia-in-sine","title":"Func\u021bia \u00een sine","text":"<p>Pentru a putea aplica c\u0103utarea ternar\u0103, trebuie ca func\u021bia s\u0103 fie (des)cresc\u0103toare (de regul\u0103, strict) p\u00e2n\u0103 la un punct \\(x\\) unde g\u0103sim cea mai mic\u0103 pozi\u021bie care ne d\u0103 valoarea maxim\u0103/minim\u0103 a func\u021biei, urm\u00e2nd c\u0103 func\u021bia s\u0103 fie mai apoi constant\u0103 p\u00e2n\u0103 la un punct \\(y\\), iar apoi func\u021bia va avea monotonia opus\u0103 fa\u021b\u0103 de cea p\u00e2n\u0103 la punctul \\(x\\).</p> <p>Cu alte cuvinte, func\u021bia cre\u0219te p\u00e2n\u0103 la punctul \\(x\\), apoi e constant\u0103 \u00een intervalul \\([x, y]\\), iar apoi scade de la punctul \\(y\\). Similar, putem spune \u0219i pentru cazul opus al unei func\u021bii unimodale.</p>","tags":["sortare","cautari","matematica"]},{"location":"dificil/ternary-search/#algoritmul-standard","title":"Algoritmul standard","text":"<p>S\u0103 presupunem c\u0103 avem o func\u021bie \\(f\\) care este definit\u0103 pe intervalul \\([a, b]\\). Asem\u0103n\u0103tor c\u0103ut\u0103rii binare, vom \u00eencepe prin a c\u0103uta acel punct extrem pe \u00eentreg intervalul. La fiecare pas, vom lua punctele \\(m_1\\) \u0219i \\(m_2\\), care vor fi situate la \\(\\frac{1}{3}\\) respectiv \\(\\frac{2}{3}\\) de cap\u0103tul din st\u00e2nga al intervalului, iar \u00een func\u021bie de valorile \\(f(m_1)\\) \u0219i \\(f(m_2)\\), avem urm\u0103toarele cazuri, acestea fiind similare \u0219i pentru o func\u021bie mai \u00eent\u00e2i descresc\u0103toare.</p> <ul> <li>Dac\u0103 \\(f(m_1) &lt; f(m_2)\\), maximul nu poate fi \u00een intervalul \\([a, m_1]\\) deoarece   \\(f(m_2)\\) este mai mare dec\u00e2t \\(f(m_1)\\).</li> <li>Dac\u0103 \\(f(m_1) &gt; f(m_2)\\), maximul nu poate fi \u00een intervalul \\([m_2, b]\\) deoarece   \\(f(m_1)\\) este mai mare dec\u00e2t \\(f(m_2)\\).</li> <li>Dac\u0103 \\(f(m_1) = f(m_2)\\), maximul nu poate fi dec\u00e2t \u00een intervalul \\([m_1, m_2]\\)   deoarece \\(f(m_1)\\) \u0219i \\(f(m_2)\\) sunt de p\u0103r\u021bi opuse ale punctului sau punctelor   maxime.</li> </ul> <p>Dup\u0103 ce am redus c\u0103utarea la o lungime suficient de mic\u0103 pentru a preveni erori de precizie, putem trata intervalul r\u0103mas folosind brute force pentru a ajunge la r\u0103spunsul dorit. Alternativ, putem apela algoritmul de un num\u0103r finit de ori, similar cu modul \u00een care am rula c\u0103utarea binar\u0103 pe numere reale. </p> <p>Complexitatea algoritmului este \\(O(\\log n)\\) unde \\(n\\) este dimensiunea intervalului de c\u0103utare. Se poate remarca faptul c\u0103 spre deosebire de c\u0103utarea binar\u0103, constanta este una mai mare deoarece \u00een medie reducem intervalul de c\u0103utare cu \\(\\frac{1}{3}\\) la un pas.</p> <pre><code>// f(i) este o func\u021bie oarecare\nlong long ternara(int epsilon) {\n    int st = 0;\n    int dr = 1000000000;\n\n    long long ans = -(1LL &lt;&lt; 60);\n\n    while (st &lt;= dr) {\n        int mid1 = st + (dr - st) / 3;\n        int mid2 = dr - (dr - st) / 3;\n\n        if (dr - st + 1 &lt;= epsilon) {\n            for (int i = st; i &lt;= dr; ++i) {\n                ans = max(ans, f(i));\n            }\n            break;\n        }\n\n        long long xa = f(mid1);\n        long long xb = f(mid2);\n\n        ans = max(ans, max(xa, xb));\n\n        if (xa == xb) {\n            st = mid1;\n            dr = mid2;\n        } else if (xa &lt; xb) {\n            st = mid1;\n        } else {\n            dr = mid2;\n        }\n    }\n    return ans;\n}\n</code></pre>","tags":["sortare","cautari","matematica"]},{"location":"dificil/ternary-search/#golden-section-search","title":"Golden Section Search","text":"<p>Pe l\u00e2ng\u0103 c\u0103utarea ternar\u0103, putem folosi pentru a optimiza procesul de c\u0103utare \u0219i c\u0103utarea Golden Section, care spre deosebire de c\u0103utarea ternar\u0103, \u00eemparte intervalul astfel \u00eenc\u00e2t cele dou\u0103 valori de mijloc s\u0103 fie puse la distanta \\(r = \\frac{3 - \\sqrt{5}}{2}\\), distant\u0103 care este egal\u0103 cu \\(\\frac{1}{\\phi}\\), unde \\(\\phi\\) este num\u0103rul de aur, egal cu aproximativ \\(1.618\\).</p> <pre><code>#include &lt;cmath&gt;\n#include &lt;iostream&gt;\n\nusing namespace std;\n\nconstexpr double gr = 1.618033988749895;\n\nconstexpr double gss(double (*f)(double), double a, double b,\n                     const double eps = 1e-5) {\n    double c = b - (b - a) / gr;\n    double d = a + (b - a) / gr;\n\n    while (abs(b - a) &gt; eps) {\n        // Pentru maxim, se inverseaz\u0103 semnul\n        if (f(c) &lt; f(d)) {\n            b = d;\n        } else {\n            a = c;\n        }\n\n        // Recalculam c si d pentru a evita pierderea preciziei\n        // lucru ce poate duce la raspunsuri gresite sau loop infinit\n        c = b - (b - a) / gr;\n        d = a + (b - a) / gr;\n    }\n\n    return (b + a) / 2;\n}\n\nint main() {\n    auto f = [](double x) { return (x - 1) * (x - 2); };\n\n    const double result = gss(f, 1, 5);\n\n    std::cout &lt;&lt; \"Minim la x = \" &lt;&lt; result &lt;&lt; std::endl;\n    return 0;\n}\n</code></pre>","tags":["sortare","cautari","matematica"]},{"location":"dificil/ternary-search/#problema-exemplu-devu-and-his-brother","title":"Problema exemplu - Devu and his Brother","text":"<p>\u00cen aceast\u0103 problem\u0103 avem doi vectori \\(a\\) \u0219i \\(b\\) \u0219i putem cre\u0219te/sc\u0103dea o valoare dintr-unul din cei doi vectori cu costul \\(1\\). Vrem s\u0103 afl\u0103m costul minim pentru ca minimul din vectorul \\(a\\) s\u0103 fie cel pu\u021bin egal cu maximul din vectorul \\(b\\). </p> <p>Se poate observa c\u0103 e clar c\u0103 vrem s\u0103 cre\u0219tem valorile din \\(a\\) \u0219i s\u0103 sc\u0103dem valorile din \\(b\\). De asemenea, se poate observa c\u0103 pe m\u0103sur\u0103 ce vrem s\u0103 aducem r\u0103spunsul la o oarecare \"median\u0103\", costul va fi tot mai mic. Aceste lucruri ne duc spre o abordare bazat\u0103 pe o c\u0103utare ternar\u0103 a r\u0103spunsului.</p> <p>Astfel, vom c\u0103uta ternar r\u0103spunsul \u00een intervalul \\([1, 10^9]\\) r\u0103spunsul aplic\u00e2nd algoritmul descris mai sus, implementarea fiind cea de mai sus.</p>","tags":["sortare","cautari","matematica"]},{"location":"dificil/ternary-search/#probleme-suplimentare","title":"Probleme suplimentare","text":"<ul> <li>CF 439D</li> <li>copii3 infoarena</li> <li>CEOI 2017 - Sure Bet</li> <li>CF 1355 E</li> <li>CF 1848 D</li> <li>CCO 18-Gradient Descent</li> </ul>","tags":["sortare","cautari","matematica"]},{"location":"dificil/ternary-search/#bibliografie-si-lectura-suplimentara","title":"Bibliografie \u0219i lectur\u0103 suplimentar\u0103","text":"<ul> <li>Ternary Search - CP Algorithms</li> <li>Ternary Search on Integers  - Codeforces</li> <li>Tutorial On Tof (Ternary Search) - Codeforces</li> <li>Solutia de la copii3 - infoarena</li> <li>Ternary Search - Wikipedia</li> <li>Numerical Methods with Programming - Golden Section Search</li> <li>Golden Section Search - Wikipedia</li> </ul>","tags":["sortare","cautari","matematica"]},{"location":"dificil/trie/","title":"Trie","text":"<p>Autor: Matei Ionescu</p>","tags":["arbori","structuri de date","strings"]},{"location":"dificil/trie/#ce-este-un-trie","title":"Ce este un Trie","text":"<p>Un trie (sau arbore de prefixe) este un arbore de c\u0103utare \\(k\\)-ar (un arbore cu r\u0103d\u0103cin\u0103 unde fiecare nod are maxim \\(k\\) fii), reprezent\u00e2nd un mod unic de a memora informa\u021biile, numite \u0219i chei.</p> <p>Num\u0103rul de fii al unui nod este \u00een mare parte influen\u021bat de tipul informa\u021biilor memorate, dar de cele mai multe ori, un Trie este folosit pentru re\u021binerea \u0219irurilor de caractere, astfel fiecare nod av\u00e2nd maxim \\(26\\) fii.</p> <p>Ini\u021bial arborele con\u021bine doar un singur nod, r\u0103d\u0103cina, urm\u00e2nd ca apoi cuvintele s\u0103 fie introduse \u00een ordinea citirii lor, de la st\u00e2nga la dreapta. Observ\u0103m c\u0103 \u00een\u0103l\u021bimea arborelui este lungimea maxim\u0103 a unui cuv\u00e2nt. Complexitatea de timp este \\(O(L)\\), unde \\(L\\) este lungimea maxim\u0103, iar memoria consumat\u0103, \u00een cel mai r\u0103u caz, este \\(O({ L \\cdot k})\\).</p> Un exemplu de trie pentru cuvintele am, bad, be \u0219i so","tags":["arbori","structuri de date","strings"]},{"location":"dificil/trie/#moduri-de-implementare","title":"Moduri de implementare","text":"<p>Exist\u0103 dou\u0103 modalit\u0103\u021bi standard prin care putem implementa un Trie, folosind pointeri sau vectori. Ambele func\u021bioneaz\u0103 la fel de bine, \u00eens\u0103 opera\u021bia de delete este mai greu de implementat cu vectori.</p>","tags":["arbori","structuri de date","strings"]},{"location":"dificil/trie/#prin-pointeri","title":"Prin pointeri","text":"<p>Ne vom folosi de o structur\u0103 unde vom re\u021bine un contor reprezent\u00e2nd de c\u00e2te ori am trecut prin nodul curent, c\u00e2t \u0219i un vector de pointeri, reprezent\u00e2nd fiii nodului curent.</p> <pre><code>struct Trie {\n    int cnt;\n    Trie *fii[26];\n\n    Trie() : cnt{0} {\n        for (int i = 0; i &lt; 26; ++i) {\n            fii[i] = nullptr;\n        }\n    }\n\n    ~Trie() {\n        for (int i = 0; i &lt; 26; ++i) {\n            delete fii[i];\n        }\n    }\n};\n\nTrie *root = new Trie;\n</code></pre> <p>Opera\u021bia de insert poate fi foarte u\u0219or scris\u0103 recursiv.</p> <pre><code>void insert(Trie *node, string a, int poz) {\n    if (poz == a.size()) {\n        node-&gt;cnt++;\n        return;\n    }\n\n    int index = a[poz] - 'a';\n    if (node-&gt;fii[index] == nullptr) {\n        node-&gt;fii[index] = new Trie();\n    }\n\n    insert(node-&gt;fii[index], a, poz + 1);\n}\n</code></pre> <p>\u00cen momentul \u00een care am ajuns la un nod \\(node\\) \u00een arbore, verific\u0103m dac\u0103 exist\u0103 fiul pentru caracterul urm\u0103tor \u0219i dac\u0103 nu exist\u0103, \u00eel ad\u0103ug\u0103m \u00een arbore, apoi apel\u0103m recursiv p\u00e2n\u0103 ajungem la finalul stringului. </p> <p>Pentru a elimina un string din trie ne mai trebuie o informa\u021bie suplimentar\u0103, \u0219i anume s\u0103 \u0219tim c\u00e2\u021bi fii are un nod. A\u0219adar, dac\u0103 am eliminat un sufix al \u0219irului \u0219i nodul curent nu mai are fii nici nu mai este vizitat prin alt \u0219ir inserat, putem da erase complet la pointerul respectiv. </p> <pre><code>bool del(Trie *node, string a, int pos) {\n    int idx = a[pos] - 'a';\n    if (pos == a.size()) {\n        node-&gt;cnt--;\n    } else if (del(node-&gt;fii[idx], a, pos + 1)) {\n        node-&gt;nrf--;\n        node-&gt;fii[idx] = nullptr;\n    }\n\n    if (node-&gt;cnt == 0 &amp;&amp; node-&gt;nrf == 0 &amp;&amp; node != t) {\n        delete node;\n        return 1;\n    }\n\n    return 0;\n}\n</code></pre> <p>Restul opera\u021biilor se implementeaz\u0103 similar, practic baza tuturor opera\u021biilor st\u0103 \u00een modul de a parcurge trie-ul.</p>","tags":["arbori","structuri de date","strings"]},{"location":"dificil/trie/#prin-vectori","title":"Prin vectori","text":"<p>\u00cen loc de o structur\u0103 vom folosi un vector cu \\(k\\) coloane. \u00cen fiecare element din vector vom re\u021bine pozi\u021bia fiului respectiv.</p> <pre><code>vector&lt;vector&lt;int&gt;&gt; trie(1, vector&lt;int&gt;(26, -1));\n</code></pre> <p>Astfel <code>trie[node][5]</code> va fi egal cu pozi\u021bia \u00een vectorul trie pentru al cincilea fiu a lui <code>node</code>.</p> <p>Opera\u021bia de inserare este foarte similar\u0103 fa\u021b\u0103 de cea precedent\u0103, singurul lucru care difer\u0103 este modul de implementare. \u00cen acest caz ne este mult mai u\u0219or s\u0103 folosim o func\u021bie care s\u0103 itereze propriu-zis prin \u0219irul de caractere.</p> <pre><code>vector&lt;vector&lt;int&gt;&gt; trie(1, vector&lt;int&gt;(26, -1));\nvector&lt;int&gt; cnt(1);\n\nvoid insert(string a) {\n    int root = 0;\n    for (const char i : a) {\n        int idx = i - 'a';\n        if (trie[root][idx] == -1) {\n            trie[root][idx] = trie.size();\n            trie.emplace_back(26, -1);\n            cnt.push_back(0);\n        }\n        cnt[root]++;\n        root = trie[root][idx];\n    }\n    cnt[root]++;\n}\n</code></pre> <p>Observ\u0103m faptul c\u0103 increment\u0103m \u0219i la final contorul.</p>","tags":["arbori","structuri de date","strings"]},{"location":"dificil/trie/#trie-pe-biti","title":"Trie pe bi\u021bi","text":"<p>Unele probleme necesit\u0103 re\u021binerea numerelor \u00eentr-o structur\u0103 de date, cum ar fi un trie, \u00eensa vom \u00eenlocui \u0219irurile de caractere cu reprezentarea binar\u0103 a numerelor.</p>","tags":["arbori","structuri de date","strings"]},{"location":"dificil/trie/#problema-xormax-de-pe-kilonova-usoara","title":"Problema xormax de pe Kilonova (u\u0219oar\u0103)","text":"<p>Un exemplu bun este chiar problema xormax, unde ni se d\u0103 un vector cu \\(N\\) elemente \u0219i trebuie s\u0103 afl\u0103m care este suma xor maxim\u0103 a unui interval. Suma xor a unui interval cu capetele \\([L, R]\\) este valoarea  \\(v_L \\oplus v_{L+1} \\oplus \\dots \\oplus v_R\\), unde \\(\\oplus\\) este operatorul xor pe bi\u021bi.</p> <p>Pentru a rezolva problema putem parcurge vectorul de la st\u00e2nga la dreapta \u0219i s\u0103 aflam pentru fiecare \\(1 \\leq i \\leq N\\) care este suma xor maxim\u0103 a unui interval care se termin\u0103 \u00een \\(i\\). Dac\u0103 construim vectorul \\(xp\\), unde \\(xp[i] = v_1 \\oplus v_2 \\oplus \\dots \\oplus v_{i-1} \\oplus v_i\\), atunci suma xor pe intervalul \\([L, R]\\) este egal\u0103 cu \\(xp[R] \\oplus xp[L-1]\\). Observ\u0103m c\u0103 pentru un \\(R\\) fixat trebuie s\u0103 g\u0103sim care este \\(L\\)-ul care maximizeaz\u0103 rela\u021bia de mai sus. Pentru a face asta putem s\u0103 introducem primii \\(R-1\\) \\(xp\\)-uri \u00eentr-un trie pe bi\u021bi \u0219i s\u0103 c\u0103ut\u0103m bit cu bit, \u00eencep\u00e2nd cu bitul semnificativ, \\(xp\\)-ul care va maximiza rezultatul.</p> <pre><code>#include &lt;iostream&gt;\n#include &lt;vector&gt;\n\nusing namespace std;\nconst int N = 2e5 + 1;\n\nvector&lt;vector&lt;int&gt;&gt; trie(1, vector&lt;int&gt;(2, -1));\n\nint n, v[N], xp[N];\n\nint find(int nr) {\n    int root = 0;\n    int ans = 0;\n    for (int bit = 31; bit &gt;= 0; bit--) {\n        bool b = (nr &amp; (1 &lt;&lt; bit));\n        if (trie[root][!b] == -1) {\n            if (trie[root][b] == -1) {\n                return ans;\n            } else {\n                root = trie[root][b];\n            }\n        } else {\n            ans += (1 &lt;&lt; bit);\n            root = trie[root][!b];\n        }\n    }\n    return ans;\n}\n\nvoid insert(int nr) {\n    int root = 0;\n    for (int bit = 31; bit &gt;= 0; bit--) {\n        bool b = (nr &amp; (1 &lt;&lt; bit));\n        if (trie[root][b] == -1) {\n            trie[root][b] = trie.size();\n            trie.emplace_back(2, -1);\n        }\n        root = trie[root][b];\n    }\n}\n\nint main() {\n    cin.tie(nullptr)-&gt;sync_with_stdio(nullptr);\n    cin &gt;&gt; n;\n\n    for (int i = 1; i &lt;= n; i++) {\n        cin &gt;&gt; v[i];\n        xp[i] = xp[i - 1] ^ v[i];\n    }\n\n    int ans = 0;\n    insert(0);\n\n    for (int i = 1; i &lt;= n; i++) {\n        int res = find(xp[i]);\n        ans = max(ans, res);\n        insert(xp[i]);\n    }\n\n    cout &lt;&lt; ans;\n}\n</code></pre> <p>O variant\u0103 care se folose\u0219te de implementarea cu pointeri este urm\u0103toarea:</p> <pre><code>#include &lt;iostream&gt;\n#include &lt;vector&gt;\n\nusing namespace std;\n\nstruct Trie {\n    Trie *_next[2];\n    int _pos;\n\n    explicit Trie(const int value)\n        : _pos{value}\n        , _next{nullptr, nullptr} {}\n\n    Trie() : Trie{-1} {}\n\n    ~Trie() {\n        delete _next[0];\n        delete _next[1];\n    }\n} *root;\n\n\nvoid add(const int val, const int idx) {\n    Trie *node = root;\n\n    for (int i = 29; i &gt;= 0; i--) {\n        bool has = (val &gt;&gt; i) &amp; 1;\n        if (node-&gt;_next[has] == nullptr)\n            node-&gt;_next[has] = new Trie(idx);\n        node = node-&gt;_next[has];\n    }\n}\n\nint query(const int val) {\n    Trie *node = root;\n\n    for (int i = 29; i &gt;= 0; i--) {\n        bool has = (val &gt;&gt; i) &amp; 1;\n        if (node-&gt;_next[!has])\n            node = node-&gt;_next[!has];\n        else if (node-&gt;_next[has])\n            node = node-&gt;_next[has];\n        else\n            break;\n    }\n    return node-&gt;_pos;\n}\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(nullptr);\n    cout.tie(nullptr);\n\n    root = new Trie(0);\n\n    int n, x, sum = 0, value = 0;\n    cin &gt;&gt; n;\n    vector&lt;int&gt; sums(n + 1);\n\n    add(sum, 0);\n\n    for (int i = 1; i &lt;= n; i++) {\n        cin &gt;&gt; x;\n        sum ^= x;\n        sums[i] = sum;\n\n        value = max(value, x);\n\n        if (i &gt; 1) {\n            int qry = query(sum);\n            value = max(value, sum ^ sums[qry]);\n        }\n\n        add(sum, i);\n    }\n\n    cout &lt;&lt; value;\n\n    delete root;\n\n    return 0;\n}\n</code></pre>","tags":["arbori","structuri de date","strings"]},{"location":"dificil/trie/#problema-xor-construction-medie","title":"Problema XOR Construction (medie)","text":"<p>\u00cen aceast\u0103 problem\u0103 ni se dau \\(n-1\\) numere, unde al \\(i\\)-lea are valoarea \\(a_i\\), iar noi trebuie s\u0103 construim alt vector \\(b\\), cu \\(n\\) elemente, astfel \u00eenc\u00e2t s\u0103 existe toate numerele de la \\(0\\) la \\(n-1\\) \u00een \\(b\\), iar \\(b_i \\oplus b_{i+1} = a_i\\).</p> <p>\u00cen primul r\u00e2nd, dac\u0103 \\(b_i = 0\\) atunci \\(b_{i+1} = a_i\\), \\(b_{i+1} \\oplus b_{i+2} = a_{i+1}\\) , deci \\(b_{i+2} = a_i \\oplus a_{i+1}\\) \u0219i \\(b_{i+3} = a_i \\oplus a_{i+1} \\oplus a_{i+2}\\). Prin urmare deducem o form\u0103 general\u0103 pentru \\(b_j\\), unde \\(i &lt; j\\) , \u0219i anume \\(b_j = a_i \\oplus a_{i+1} \\oplus a_{i+2} \\oplus \\dots \\oplus a_{j-1}\\). Proprietatea se respect\u0103 \u0219i pentru oricare \\(j &lt; i\\), avem \\(b_j = a_j \\oplus a_{j+1} \\oplus \\dots \\oplus a_{i-1}\\).</p> <p>\u00cen al doilea r\u00e2nd, enun\u021bul problemei asigur\u0103 faptul c\u0103 mereu va exista solu\u021bie. Dar c\u00e2nd nu avem solu\u021bie? P\u0103i \u00een momentul \u00een care se repet\u0103 dou\u0103 elemente \u00een vectorul \\(b\\), ceea ce \u00eenseamn\u0103 faptul c\u0103 trebuie s\u0103 existe o secven\u021b\u0103 cu suma xor egal\u0103 cu \\(0\\). Pentru simplitate vom spune c\u0103 pe pozi\u021bia \\(k\\) va fi \\(b_k = 0\\). Dac\u0103 \\(i &lt; j\\) \u0219i \\(b_i = b_j\\) \u0219i \\(j &lt; k\\), atunci \\(a_i \\oplus a_{i+1} \\oplus a_{i+2} \\oplus \\dots \\oplus a_{j-1} = 0\\), analog pentru \\(i &gt; j &gt; k\\). Dac\u0103 \\(i &lt; k &lt; j\\) \u0219i \\(b_i = b_j\\) atunci \\(b_i = a_i \\oplus a_{i+1} \\oplus \\dots \\oplus a_{k-1}\\), \\(b_j = a_k \\oplus a_{k+1} \\dots \\oplus a_{j-1}\\). Prin urmare \\(a_i \\oplus a_{i+1} \\oplus \\dots \\oplus a_{j-1} = 0\\). A\u0219adar, \u0219tim ca mereu \u00een vectorul \\(b\\) elementele vor fi distincte.</p> <p>\u00cen al treilea r\u00e2nd, observ\u0103m c\u0103 vectorul \\(b\\) este generat \u00een func\u021bie de ce valoare are \\(k\\). Deci o prim\u0103 idee ar fi s\u0103 fix\u0103m mai \u00eent\u00e2i unde vom pune \\(0\\)-ul \u00een vectorul \\(b\\) \u0219i s\u0103-l construim \u00een \\(O(n)\\), complexitatea temporal\u0103 fiind \\(O(n^2)\\). Dar putem s\u0103 ne folosim de a doua observa\u021bie, \u0219i anume c\u0103 mereu vectorul \\(b\\) va avea elementele distincte. Deci ne este suficient s\u0103 \u0219tim care va fi valoarea maxim\u0103 din \\(b\\) dac\u0103 \\(0\\)-ul se afl\u0103 pe pozi\u021bia \\(k\\). Pentru a face asta putem s\u0103 folosim 2 trie-uri, unul pentru sufix, altul pentru prefix, complexitatea final\u0103 devenind \\(O(n \\log n)\\).</p> <pre><code>#include &lt;iostream&gt;\n#include &lt;vector&gt;\n\nusing namespace std;\nconst int N = 2e5 + 1;\n\nint n;\nvector&lt;int&gt; v(N), ans(N);\nvector&lt;int&gt; xr1(N), xr2(N);\n\nvector&lt;vector&lt;int&gt;&gt; trie1(1, vector&lt;int&gt;(2, -1)),\n                    trie2(1, vector&lt;int&gt;(2, -1));\n\nvector&lt;int&gt; maxim1(N), maxim2(N);\n\nvoid insert(vector&lt;vector&lt;int&gt;&gt; &amp;trie, int nr) {\n    int root = 0;\n    for (int i = 30; i &gt;= 0; i--) {\n        bool bit = (nr &amp; (1 &lt;&lt; i));\n        if (trie[root][bit] == -1) {\n            trie[root][bit] = trie.size();\n            trie.push_back(vector&lt;int&gt;(2, -1));\n        }\n        root = trie[root][bit];\n    }\n\n}\n\nint get_max(vector&lt;vector&lt;int&gt;&gt; &amp;trie, int nr) {\n    int ans = 0;\n    int root = 0;\n    for (int i = 30; i &gt;= 0; i--) {\n        bool bit = (nr &amp; (1 &lt;&lt; i));\n        if (trie[root][!bit] != -1) {\n            ans += (1 &lt;&lt; i);\n            root = trie[root][!bit];\n        } else if (trie[root][bit] != -1) {\n            root = trie[root][bit];\n        }\n    }\n    return ans;\n}\n\nint main() {\n    cin &gt;&gt; n;\n    int xr = 0;\n    for (int i = 1; i &lt; n; i++) {\n        cin &gt;&gt; v[i];\n        xr1[i] = xr1[i - 1] ^ v[i];\n    }\n    for (int i = n - 1; i &gt;= 1; i--) {\n        xr2[i] = xr2[i + 1] ^ v[i];\n    }\n\n    maxim1[1] = 0;\n    maxim2[n] = 0;\n    insert(trie1, xr2[1]);\n\n    for (int i = 2; i &lt;= n; i++) {\n        maxim1[i] = get_max(trie1, xr2[i]);\n        insert(trie1, xr2[i]);\n    }\n\n    insert(trie2, xr1[n - 1]);\n    for (int i = n - 2; i &gt;= 0; i--) {\n        maxim2[i] = get_max(trie2, xr1[i]);\n        insert(trie2, xr1[i]);\n    }\n\n\n    for (int i = 1; i &lt;= n; i++) {\n        if (max(maxim1[i], maxim2[i - 1]) == n - 1) {\n            int xr1 = 0, xr2 = 0;\n            vector&lt;int&gt; fr(2 * n + 1);\n            fr[0] = 1;\n            ans[i] = 0;\n            for (int j = i - 1; j &gt;= 1; j--) {\n                ans[j] = v[j] ^ ans[j + 1];\n                xr1 ^= v[j];\n                fr[ans[j]]++;\n                if (fr[ans[j]] &gt;= 2) {\n                    break;\n                }\n            }\n            for (int j = i; j &lt; n; j++) {\n                ans[j + 1] = v[j] ^ xr2;\n                xr2 ^= v[j];\n                fr[ans[j + 1]]++;\n                if (fr[ans[j + 1]] &gt;= 2) {\n                    break;\n                }\n            }\n            int ok = 1;\n            for (int j = 0; j &lt; n; j++) {\n                if (fr[j] != 1) {\n                    ok = 0;\n                    break;\n                }\n            }\n            if (1) {\n                for (int j = 1; j &lt;= n; j++) {\n                    cout &lt;&lt; ans[j] &lt;&lt; \" \";\n                }\n                return 0;\n            }\n        }\n    }\n}\n</code></pre>","tags":["arbori","structuri de date","strings"]},{"location":"dificil/trie/#problema-cuvinte-medie-grea","title":"Problema cuvinte (medie-grea)","text":"<p>Se dau \\(N\\) cuvinte formate doar din primele \\(K\\) litere mici ale alfabetului englez \u0219i un \u0219ir \\(x_i\\), de \\(M\\) numere naturale. Trebuie s\u0103 se formeze \\(M\\) cuvinte astfel \u00eenc\u00e2t oricare cuv\u00e2nt \\((1 \\leq i \\leq M)\\) s\u0103 respecte urm\u0103toarele propriet\u0103\u021bi:</p> <ul> <li>S\u0103 aib\u0103 lungimea \\(x_i\\).</li> <li>S\u0103 fie format doar din primele \\(K\\) litere mici ale alfabetului englez.</li> <li>S\u0103 nu existe \\(j \\leq M,\\, j \\neq i\\), sau un cuv\u00e2nt \\(cuv\\) din cele \\(N\\), astfel   \u00eenc\u00e2t cuv\u00e2ntul \\(j\\) s\u0103 fie prefix pentru cuv\u00e2ntul \\(i\\), sau \\(cuv\\) s\u0103 fie prefix   pentru \\(i\\).</li> <li>*S\u0103 nu existe \\(j \\leq M,\\, j \\neq i\\), sau un cuv\u00e2nt \\(cuv\\) din cele \\(N\\), astfel   \u00eenc\u00e2t cuv\u00e2ntul \\(i\\) s\u0103 fie prefix pentru cuv\u00e2ntul \\(j\\), sau \\(i\\) s\u0103 fie prefix   pentru \\(cuv\\).</li> </ul>","tags":["arbori","structuri de date","strings"]},{"location":"dificil/trie/#solutie","title":"Solu\u021bie","text":"<p>Prima idee ar fi s\u0103 sortam vectorul \\(x\\). Fie \\(dp_i\\) = \u00een c\u00e2te moduri putem alege primele \\(i\\) cuvinte. Putem considera toate posibilit\u0103\u021bile de a forma \u0219irurile , iar abia apoi s\u0103 vedem cum elimin\u0103m pe cele care nu sunt bune. Cu alte cuvinte, fie \\((s_1, s_2, .. , s_{i-1})\\) primele \\(i-1\\) cuvinte alese astfel \u00eenc\u00e2t s\u0103 respecte condi\u021biile impuse de problem\u0103. Sunt \u00een total \\(dp_{i-1} \\cdot K^{x_i}\\) moduri de a forma un set de \u0219iruri cu primele \\(i\\) cuvinte.</p> <p>Observa\u021bie</p> <p>Nu exist\u0103 dou\u0103 cuvinte, \\(s_x\\) \u0219i \\(s_y\\), astfel \u00eenc\u00e2t ambele s\u0103 fie prefixe pentru \\(s_i\\).</p> <p>Dac\u0103 ambele ar fi prefixe pentru \\(s_i\\), atunci fie \\(s_x\\) este prefix pentru \\(s_y\\), fie invers, ceea ce este fals, pentru c\u0103 noi am generat primele \\(i-1\\) cuvinte optim.</p> <p>Astfel dac\u0103 pentru fiecare cuv\u00e2nt \\(k\\), \\(k &lt; i\\), putem s\u0103 sc\u0103dem din num\u0103rul total de posibilit\u0103\u021bi \u0219irurile unde \\(s_k\\) este prefix pentru \\(s_i\\), nu vom elimina dou\u0103 configura\u021bii la fel. $$ dp_i = dp_{i-1} \\cdot K^{x_i} - dp_{i-1} \\cdot \\sum_{j = 1}^{i-1} K^{x_i - x_j} $$</p> <p>Observa\u021bie</p> <p>Nu exist\u0103 dou\u0103 cuvinte, unul provenit din cele \\(N\\) date \u0219i cel\u0103lalt (\\(s_k\\)) din primele \\(i-1\\) astfel \u00eenc\u00e2t ambele s\u0103 fie prefixe pentru \\(s_i\\).</p> <p>Dac\u0103 ambele sunt prefixe pentru \\(s_i\\), atunci fie \\(s_k\\) este prefix pentru un cuv\u00e2nt din cele \\(N\\), fie invers.</p> <p>Deci, putem s\u0103 fixam un cuv\u00e2nt din cele \\(N\\) date ini\u021bial \u0219i s\u0103 elimin\u0103m num\u0103rul de posibilit\u0103\u021bi ca el s\u0103 fie prefix pentru \\(s_i\\). Datorit\u0103 observa\u021biei, nu vom elimina o posibilitate dac\u0103 a fost eliminat\u0103 deja \u00een prima etap\u0103.</p> <p>\u00cen mod natural vom zice c\u0103 din dp-ul nostru vom sc\u0103dea \u00een mod similar \\(dp_{i-1} \\cdot \\sum_{j = 1}^{N} K^{x_i - len(j)}\\), unde \\(len(j)\\) = lungimea cuv\u00e2ntului \\(j\\), cu \\(x_i \\geq len(j)\\). \u00cens\u0103 nu este adev\u0103rat, pentru c\u0103 dac\u0103 avem dou\u0103 cuvinte \\(x\\) \u0219i  \\(y\\) , unde \\(x\\) este prefix pentru \\(y\\), atunci suma de mai sus va num\u0103ra 2 configura\u021bii de dou\u0103 ori. Observ\u0103m c\u0103 nou\u0103 ne trebuie practic doar acele cuvinte \\(x\\), pentru care nu exist\u0103 alt cuv\u00e2nt \\(y\\), cu \\(y\\) prefix pentru \\(x\\), iar \\(len(x) \\leq x_i\\).</p> <p>Astfel putem parcurge direct pe Trie-ul cuvintelor. Dac\u0103 suntem la un nod \\(node\\), acesta este cap\u0103tul unui cuv\u00e2nt, iar \\(len(cuv) \\leq x_i\\), atunci putem sc\u0103dea din dp-ul nostru \\(dp_{i-1} \\cdot K^{x_i - len(cuv)}\\) \u0219i s\u0103 oprim parcurgerea. Dac\u0103 suntem la un nod \\(node\\), acesta are lungimea egal\u0103 cu \\(x_i\\), atunci sc\u0103dem din dp \\(dp_{i-1}\\) \u0219i oprim parcurgerea. </p> <p>Cu alte cuvinte, o solu\u021bie \u00een \\(O(M^2 + M \\cdot S)\\) este posibil\u0103, unde \\(S = \\sum_{i=1}^{N} len(i)\\). Putem optimiza solu\u021bia, observ\u00e2nd c\u0103 de fiecare dat\u0103 putem face tranzi\u021biile \u00een \\(O(1)\\). Solu\u021bia final\u0103 devine \\(O(M + S)\\) sau \\(O(M \\cdot \\log + S)\\). </p> <pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\nconst int mod = 1e9 + 7, N = 3e5 + 1;\nstruct Mint\n{\n    int val;\n    Mint(int x = 0)\n    {\n        val = x % mod;\n    }\n    Mint(long long x)\n    {\n        val = x % mod;\n    }\n    Mint operator+(Mint oth)\n    {\n        return val + oth.val;\n    }\n    Mint operator*(Mint oth)\n    {\n        return 1LL * val * oth.val;\n    }\n    Mint operator-(Mint oth)\n    {\n        return val - oth.val + mod;\n    }\n    Mint fp(Mint a, long long n){\n        Mint p = 1;\n        while(n){\n            if(n &amp; 1){\n                p = p * a;\n            }\n            a = a * a;\n            n /= 2;\n        }\n        return p;\n    }\n    Mint operator/(Mint oth){\n        Mint invers = fp(oth, mod - 2);\n        return 1LL * val * invers.val;\n    }\n    friend ostream&amp; operator &lt;&lt; (ostream&amp; os, const Mint&amp; lol){\n        os &lt;&lt; lol.val;\n        return os;\n    }\n};\n\nint n, m, k;\nvector&lt;Mint&gt; dp(N);\nvector&lt;int&gt; x(N), depth(N), cnt1(N);\nvector&lt;vector&lt;int&gt;&gt; trie(1, vector&lt;int&gt;(26,-1));\nvector&lt;bool&gt; cnt(1);\nMint spm = 0;\nMint fp(Mint a, int n){\n    Mint p = 1;\n    while(n){\n        if(n &amp; 1) p = a * p;\n        a = a * a;\n        n /= 2;\n    }\n    return p;\n}\n\nvoid insert(string a){\n    int root = 0;\n    for(int i = 0; i &lt; a.size(); i++){\n        if(trie[root][a[i]-'a'] == -1){\n            trie[root][a[i]-'a'] = trie.size();\n            trie.push_back(vector&lt;int&gt;(26, -1));\n            cnt.push_back(0);\n        }\n        root = trie[root][a[i]-'a'];\n    }\n    cnt[root]=1;\n}\nvoid dfs(int node, int lenx, int len){\n    if(lenx == len){\n        return;\n    }\n    if(cnt[node]){\n        spm = spm + fp(k, lenx - len);\n        return;\n    }\n    for(int i = 0; i &lt; 26; i++){\n        if(trie[node][i] != -1){\n            dfs(trie[node][i], lenx, len + 1);\n        }\n    }\n}\nvoid dfs1(int node, int len){\n    depth[len]++;\n    if(cnt[node]){\n        cnt1[len]++;\n        return;\n    }\n    for(int i = 0; i &lt; 26; i++){\n        if(trie[node][i] != -1){\n            dfs1(trie[node][i], len+1);\n        }\n    }\n}\nint main(){\n    cin.tie(0)-&gt;sync_with_stdio(0);\n    cin &gt;&gt; n &gt;&gt; m &gt;&gt; k;\n    for(int i = 1; i &lt;= n; i++){\n        string a;\n        cin &gt;&gt; a;\n        insert(a);\n    }\n    for(int i = 1; i &lt;= m; i++){\n        cin &gt;&gt; x[i];\n    }\n    sort(x.begin() + 1, x.begin() + 1 + m);\n    dp[1] = fp(k, x[1]);\n    Mint sm = 0;\n    dfs(0, x[1], 0);\n    dfs1(0, 0);\n    dp[1] = dp[1] - depth[x[1]];\n    dp[1] = dp[1] - spm;\n    for(int i = 2; i &lt;= m; i++){\n        dp[i] = dp[i - 1] * fp(k, x[i]);\n        sm = sm * fp(k, x[i]-x[i-1]);\n        sm = sm + fp(k, x[i]-x[i-1]);\n        dp[i] = dp[i] - dp[i-1]*sm;\n        spm = spm * fp(k, x[i]-x[i-1]);\n        for(int j = x[i-1]; j &lt; x[i]; j++){\n            spm = spm + fp(k, x[i] - j) * cnt1[j];\n        }\n        dp[i] = dp[i] - dp[i-1]*depth[x[i]];\n        dp[i] = dp[i] - dp[i-1]*spm;\n    }\n    cout &lt;&lt; dp[m];\n}\n</code></pre>","tags":["arbori","structuri de date","strings"]},{"location":"dificil/trie/#problema-cli-medie-grea","title":"Problema cli (medie-grea)","text":"<p>Se dau \\(N\\) cuvinte care trebuie tastate \u00eentr-un terminal. Un cuv\u00e2nt este considerat tastat dac\u0103 el va ap\u0103rea \u00een terminal cel pu\u021bin odat\u0103 pe parcursul tast\u0103rii. Avem dou\u0103 tipuri de opera\u021bii la dispozi\u021bie: ad\u0103ug\u0103m un caracter la finalul \u0219irul tastat deja, elimin\u0103m un caracter de la finalul \u0219irului (dac\u0103 nu este vid). Pentru fiecare \\(i = \\overline{1, K}\\), noi trebuie s\u0103 aflam care este num\u0103rul minim de opera\u021bii pentru a tasta exact \\(i\\) cuvinte distincte dintre cele date. \u00cen momentul \u00een care \u00eencepem s\u0103 tast\u0103m un cuv\u00e2nt, trebuie mereu s\u0103 \u00eencepem de la un \u0219ir vid \\((\\emptyset)\\), \u0219i s\u0103 termin\u0103m tastarea tot la un \u0219ir vid. Un exemplu de tastare corect\u0103 este: \\(\\emptyset \\rightarrow a \\rightarrow ab \\rightarrow abc \\rightarrow ab \\rightarrow a \\rightarrow \\emptyset\\).</p> <p>Ne vom folosi din nou de metoda program\u0103rii dinamice, dar de data asta vom face dp direct pe trie. Astfel, fie \\(dp[nod][i]\\) = num\u0103rul minim de opera\u021bii pentru a tasta \\(i\\) cuvinte cu prefixul format din lan\u021bul de la r\u0103d\u0103cin\u0103 la \\(nod\\). Acum, pentru un nod fixat din trie-ul nostru, putem presupune c\u0103 \u00een momentul tast\u0103rii vom \u00eencepe mereu cu \u0219irul format de la r\u0103d\u0103cin\u0103 la \\(nod\\), \u00een loc de \\(\\emptyset\\). De exemplu, dac\u0103 cuvintele au prefixul \\textit{abab}, atunci noi vom presupune o succesiune valid\u0103 de opera\u021bii: \\(abab \\rightarrow abab\\textbf{c} \\rightarrow \\dots \\rightarrow abab\\textbf{c} \\rightarrow abab\\). Putem deci face un rucsac pentru fiii nodului, \\(dp1[i][j]\\) = care e num\u0103rul minim de opera\u021bii pentru a tasta \\(j\\) cuvinte din primii \\(i\\) fii. Pentru c\u0103 prefixul necesit\u0103 \\(\\text{len}(prefix)\\) opera\u021bii de ad\u0103ugare \u0219i \u0219tergere, vom \u00eencepe \\(dp\\)-ul nostru cu \\(2 \\cdot \\text{len}(prefix)\\) opera\u021bii deja f\u0103cute. Cu alte cuvinte, pentru a tasta \\(0\\) cuvinte vom face \\(dp1[0][0] = 2 \\cdot \\text{len}(prefix)\\). \u00cen momentul \u00een care trecem de la \\(i\\) la \\(i+1\\) avem 2 cazuri: fie nu lu\u0103m fiul respectiv \u00een considerare, fie alegem \\(p\\) \u0219iruri pe care le vom tasta \u00een \\(dp[fiu(i)][p] - 2 \\cdot \\text{len}(prefix)\\) opera\u021bii. </p> <pre><code>for (int i = 1; i &lt;= 26; i++) {\n    for (int k1 = 0; k1 &lt;= min(sz[nod], k); k1++) {\n        dp1[i][k1] = min(dp1[i][k1], dp1[i - 1][k1]);\n\n        const auto nod2 = trie[nod][i - 1];\n        for (int k2 = 1; k2 &lt;= k1 &amp;&amp; nod2 != -1 &amp;&amp; k2 &lt; dp[nod2].size(); k2++) {\n            dp1[i][k1] =\n                min(dp1[i][k1], dp1[i - 1][k1 - k2] + dp[nod2][k2] - 2 * len);\n        }\n    }\n}\n</code></pre> <p>Problema const\u0103 \u00een faptul c\u0103 secven\u021ba de cod de mai sus ruleaz\u0103 pentru fiecare nod din trie, ceea ce ar rezulta \u00eentr-o complexitate de \\(O(N \\cdot K^2)\\). Doar c\u0103, \u00een practic\u0103 solu\u021bia are complexitatea de \\(O(N \\cdot K)\\). \u00cen momentul \u00een care facem rucsac pe un arbore, este foarte important s\u0103 fim aten\u021bi la memoria \u0219i la timpul consumate. Observ\u0103m faptul c\u0103 cele dou\u0103 bucle merg p\u00e2n\u0103 la \\(\\min(sz[nod], k)\\), lucru ce  \u00eembun\u0103t\u0103\u021be\u0219te timpul de execu\u021bie considerabil. Pute\u021bi citi mai multe din solu\u021bia problemei Barricades, iar sursa complet\u0103 o pute\u021bi vizualiza aici.</p>","tags":["arbori","structuri de date","strings"]},{"location":"dificil/trie/#resurse-suplimentare","title":"Resurse suplimentare","text":"<ul> <li>Trie (USACO Guide)</li> </ul>","tags":["arbori","structuri de date","strings"]},{"location":"dificil/trie/#probleme","title":"Probleme","text":"<ul> <li>intervalxor2 (Trie pe bi\u021bi persistent. Pute\u021bi face queriurile \u0219i offline)</li> <li>xortree2 (Problem\u0103 ok cu trie pe bi\u021bi)</li> <li>rps (Alt exemplu de dp pe trie)</li> <li>ratina (Lowest Common Ancestor pe trie)</li> <li>aiacupalindroame</li> <li>Facebook Search</li> <li>Perfect Security</li> <li>Collapsing Strings</li> </ul>","tags":["arbori","structuri de date","strings"]},{"location":"mediu/","title":"Mediu","text":"<p>In accesta categorie sunt toate de dificultate medie</p>"},{"location":"mediu/apcm/","title":"Arbore par\u021bial de cost minim","text":"<p>\u00cen diverse probleme de grafuri, suntem nevoi\u021bi s\u0103 alegem o mul\u021bime de muchii care formeaz\u0103 un graf conex, iar costul s\u0103 fie c\u00e2t mai mic. \u00cen cele mai multe cazuri, va fi \u00eendeajuns s\u0103 cre\u0103m un arbore par\u021bial, iar acesta s\u0103 fie de cost minim, concept ce va fi subiectul acestui articol.</p>","tags":["grafuri","greedy"]},{"location":"mediu/apcm/#introducere","title":"Introducere","text":"<p>Defini\u021bie</p> <p>Arborele par\u021bial de cost minim (APM) un graf par\u021bial conex cu proprietatea c\u0103 suma costurilor muchiilor este minim\u0103 \u0219i graful este un arbore (deci, are \\(n-1\\) muchii). </p> <p>Observa\u021bie</p> <p>Un graf poate avea mai mul\u021bi arbori par\u021biali de cost minim, dar \u00een aproape toate problemele, precum \u0219i \u00een practic\u0103, nu conteaz\u0103 cu ce arbore lucr\u0103m, at\u00e2ta timp c\u00e2t suma costurilor muchiilor este minim\u0103. </p> <p>Exemplu</p> <p>De exemplu, dac\u0103 avem urm\u0103torul graf: \\(n = 5\\), \\(m = 6\\) \u0219i urm\u0103toarele muchii de tip \\((a, b, cost)\\): \\((1, 2, 3), (2, 3, 5), (2, 4, 2), (3, 4, 8), (5, 1, 7), (5, 4, 4)\\), arborele par\u021bial de cost minim va avea costul \\(14\\), aleg\u00e2ndu-se primele trei muchii \u0219i ultima. </p> <p>Pentru a afla APM-ul, exist\u0103 mai mul\u021bi algoritmi, dar cei mai folosi\u021bi algoritmi sunt algoritmul lui Kruskal \u0219i algoritmul lui Prim. Exist\u0103 \u0219i al\u021bi algoritmi mai pu\u021bin cunoscu\u021bi, precum algoritmul lui Boruvka, dar acest articol va acoperi doar primii doi algoritmi, cu resurse disponibile \u0219i pentru Boruvka. </p> <p>\u00cen probleme, de cele mai multe ori vom putea aplica algoritmul ales f\u0103r\u0103 prea multe modific\u0103ri, dar g\u0103sirea unui graf pe care s\u0103 aplic\u0103m APM se va dovedi a fi o alegere mai dificil\u0103. </p>","tags":["grafuri","greedy"]},{"location":"mediu/apcm/#algoritmul-lui-kruskal","title":"Algoritmul lui Kruskal","text":"<p>Defini\u021bie</p> <p>Algoritmul lui Kruskal este un algoritm de tip greedy care va prelucra muchiile \u00een ordine cresc\u0103toare a costurilor acestora, iar pentru fiecare dintre muchii, va verifica dac\u0103 ad\u0103ugarea ei \u00een graful par\u021bial va genera un ciclu sau nu. Pentru verificarea rapid\u0103 a ciclurilor \u00een graf, vom folosi o structur\u0103 de tip Union-Find, iar sortarea se poate face cu u\u0219urin\u021b\u0103 p\u0103str\u00e2nd muchiile \u00eentr-o structur\u0103 potrivit\u0103. </p> <p>Observa\u021bie</p> <p>Dac\u0103 sunt mai multe muchii cu cost egal, nu are importan\u021b\u0103 care este aleas\u0103, rezultatul fiind identic. </p> <p>Un lucru care se poate remarca este faptul c\u0103 acest algoritm este centrat \u00een jurul muchiilor, opera\u021biile f\u0103cute cu acestea fiind esen\u021biale pentru algoritmul nostru (sortarea lor, urmat\u0103 de verificarea individual\u0103). Deoarece sortarea muchiilor este de departe cea mai costisitoare parte a algoritmului, complexitatea final\u0103 a algoritmului va fi \\(O(m \\log m)\\).</p> <p>Aici pute\u021bi g\u0103si o implementare \u00een limbajul C++ a algoritmului lui Kruskal.</p> <pre><code>#include &lt;iostream&gt;\n#include &lt;algorithm&gt;\n#include &lt;vector&gt;\n\nusing namespace std;\n\n/* Procesarea muchiilor */\nstruct edges {\n    int a, b, c;\n};\nedges v[200001];\n\nbool cmp (edges a, edges b) {\n    return a.c &lt; b.c;\n}\n\n/* Clasa pentru paduri de multimi disjuncte */\nclass dsu{\n    private:\n        int n;\n        vector&lt;int&gt; parent, card; \n    public:\n        void init (int sz) {\n            n = sz;\n            parent.resize(n+1);\n            card.resize(n+1);\n            for (int i = 1; i &lt;= n; i++) {\n                parent[i] = i;\n                card[i] = 1;\n            }\n        }\n        int Find (int x) {\n            if (parent[x] == x) {\n                return x;\n            }\n            return parent[x] = Find(parent[x]);\n        }\n        void Union (int a, int b) {\n            a = Find(a); b = Find(b);\n            if (a == b) {\n                return;\n            }\n            if (card[b] &gt; card[a]) {\n                swap(a, b);\n            }\n            parent[b] = a;\n            card[a] += card[b];\n        }\n};\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n\n    int n, m;\n    cin &gt;&gt; n &gt;&gt; m;\n\n    for (int i = 0; i &lt; m; i++) {\n        cin &gt;&gt; v[i].a &gt;&gt; v[i].b &gt;&gt; v[i].c;\n    }\n    sort(v, v + m, cmp);\n\n    dsu links; links.init(n);\n\n    long long cost = 0;\n    int mch = 0;\n    for (int i = 0; i &lt; m; i++) {\n        if (links.Find(v[i].a) != links.Find(v[i].b)) {\n            cost += v[i].c;\n            mch++;\n            links.Union(v[i].a, v[i].b);\n        }\n    }\n\n    if (mch == n-1) {\n        cout &lt;&lt; cost &lt;&lt; '\\n';\n    }\n    else {\n        cout &lt;&lt; \"IMPOSSIBLE\\n\";\n    }\n    return 0;\n}\n</code></pre>","tags":["grafuri","greedy"]},{"location":"mediu/apcm/#algoritmul-lui-prim","title":"Algoritmul lui Prim","text":"<p>Defini\u021bie</p> <p>Algoritmul lui Prim este un algoritm de tip greedy care va prelucra nodurile \u00een ordine cresc\u0103toare a costurilor de a fi conectate, plec\u00e2nd de la un nod oarecare, iar pentru fiecare dintre noduri, va verifica dac\u0103 ad\u0103ugarea muchiilor vecine cu acel nod \u00een graful par\u021bial va rezulta \u00een mic\u0219orarea unor costuri sau nu. Pentru verificarea rapid\u0103 a \u00eembun\u0103t\u0103\u021birilor pe care le ob\u021binem \u00een privin\u021ba costurilor, vom folosi o implementare similar\u0103 cu cea de la algoritmul lui Dijkstra. </p> <p>Observa\u021bie</p> <p>Dac\u0103 sunt mai multe noduri cu cost egal, nu are importan\u021b\u0103 care este aleas, rezultatul fiind identic. </p> <p>Un lucru care se poate remarca este faptul c\u0103 acest algoritm este centrat \u00een jurul nodurilor, opera\u021biile f\u0103cute cu acestea fiind esen\u021biale pentru algoritmul nostru (procesarea lor, urmat\u0103 de verificarea muchiilor adiacente fiec\u0103rui nod). Deoarece algoritmul este similar \u00een stil cu algoritmul lui Dijkstra, complexitatea final\u0103 va fi aceea\u0219i cu cea de la Dijkstra, \\(O((n+m) \\log n)\\)</p> <p>Aici pute\u021bi g\u0103si o implementare \u00een limbajul C++ a algoritmului lui Prim.</p> <pre><code>#include &lt;iostream&gt;\n#include &lt;vector&gt;\n#include &lt;set&gt;\nusing namespace std;\n\nint main() {\n    int n, m;\n    cin &gt;&gt; n &gt;&gt; m;\n\n    vector&lt;vector&lt;pair&lt;int, int&gt; &gt; &gt; graph(n+1); \n    for (int i = 1; i &lt;= m; i++) {\n        int a, b, c;\n        cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;\n        graph[a].push_back({b, c});\n        graph[b].push_back({a, c});\n    }\n\n    /* Implementare similara cu cea de la Dijkstra */\n    vector&lt;int&gt; cost(n+1, (1&lt;&lt;30));\n    cost[1] = 0;\n    set&lt;pair&lt;int, int&gt; &gt; s;\n    s.insert({0, 1});\n\n    long long MST = 0;\n    int added = 0;\n    while(!s.empty()) {\n        pair&lt;int, int&gt; smallest = *s.begin();\n        s.erase(smallest);\n\n        MST += smallest.first;\n        cost[smallest.second] = 0;\n        added++;\n        for (int i = 0; i &lt; (int) graph[smallest.second].size(); i++) {\n            int nxt = graph[smallest.second][i].first;\n            int val = graph[smallest.second][i].second;\n\n            if (val &lt; cost[nxt]) {\n                if (s.find({cost[nxt], nxt}) != s.end()) {\n                    s.erase({cost[nxt], nxt});\n                }\n                cost[nxt] = val;\n                s.insert({cost[nxt], nxt});\n            }\n        }\n    }\n\n    if (added == n) {\n        cout &lt;&lt; MST &lt;&lt; '\\n';\n    }\n    else {\n        cout &lt;&lt; \"IMPOSSIBLE\" &lt;&lt; '\\n';\n    }  \n    return 0;\n}\n</code></pre>","tags":["grafuri","greedy"]},{"location":"mediu/apcm/#care-este-algoritmul-mai-bun","title":"Care este algoritmul mai bun?","text":"<p>Niciunul dintre algoritmi nu este mai bun mereu dec\u00e2t cel\u0103lalt. Pe de o parte, Kruskal se dovede\u0219te a fi mult mai bun atunci c\u00e2nd este vorba de grafuri rare, cu \\(M \\approx N\\), deoarece constanta de la sortare este mult mai bun\u0103 dec\u00e2t cea de la seturi. Totu\u0219i, dac\u0103 graful este foarte dens, algoritmul lui Prim este superior, iar \u00een cazul unor grafuri complete, de multe ori este mai bine s\u0103 implement\u0103m varianta sa \u00een \\(O(n^2)\\), similar\u0103 cu cea prezentat\u0103 la Dijkstra, pentru a rezolva probleme precum cablaj.</p> <p>\u00cen condi\u021bii de concurs, dac\u0103 ambii algoritmi vor intra \u00een limita de timp, Kruskal este mult mai u\u0219or de scris \u0219i mai practic, dar cunoa\u0219terea algoritmului lui Prim este foarte util\u0103, mai ales dat fiind factorul de similaritate cu Dijkstra. </p>","tags":["grafuri","greedy"]},{"location":"mediu/apcm/#probleme-suplimentare","title":"Probleme suplimentare","text":"<ul> <li>Road Reparation</li> <li>USACO Gold Fenced In</li> <li>USACO Gold Moo Network</li> <li>infoarena cablaj</li> <li>OJI 2017 Ninjago</li> <li>infoarena desen</li> <li>ONI 2018 Poligon</li> <li>ONI 2019 Oracol</li> <li>USACO Gold Moo Network</li> <li>Problemele cu APM de pe kilonova</li> <li>Probleme educa\u021bionale cu APM</li> <li>Minimum spanning tree for each edge</li> </ul>","tags":["grafuri","greedy"]},{"location":"mediu/apcm/#lectura-suplimentara","title":"Lectur\u0103 suplimentar\u0103","text":"<ul> <li>Minimum Spanning Tree - USACO Guide</li> <li>Minimum spanning tree - Prim's algorithm</li> <li>Minimum spanning tree - Kruskal with Disjoint Set Union</li> <li>Arbore partial de cost minim - CPPI Sync</li> <li>Minimum Spanning Tree Problems</li> <li>Avansat - Boruvka's Algorithm</li> <li>Avansat - Second Best Minimum Spanning Tree</li> </ul>","tags":["grafuri","greedy"]},{"location":"mediu/bignum/","title":"Numere mari","text":"<p>Autori: Susan, \u0218tefan-Cosmin D\u0103sc\u0103lescu</p> <p>Fie \\(\\overline{a_{n-1} a_{n-2} \\ldots a_1 a_0}\\) un num\u0103r \u00een baza \\(10\\), format din \\(n\\) cifre. Aici, \\(a_i\\) pentru \\(0 \\leq i &lt; n\\) sunt cifrele num\u0103rului, cu fiecare \\(a_i\\) satisf\u0103c\u00e2nd \\(0 \\leq a_i \\leq 9\\), \u0219i \\(a_{n-1} \\neq 0\\). Valoarea num\u0103rului este dat\u0103 de:</p> \\[ \\overline{a_{n-1} a_{n-2} \\cdots a_1 a_0} = \\sum_{k=0}^{n-1} a_k \\cdot 10^k \\] <p>Aceast\u0103 sum\u0103 poate fi descompus\u0103 \u00een:</p> \\[ \\overline{a_{n-1} a_{n-2} \\cdots a_1 a_0} = a_{n-1} \\cdot 10^{n-1} + a_{n-2} \\cdot 10^{n-2} + \\ldots + a_1 \\cdot 10^1 + a_0 \\cdot 10^0 \\] <p>Similar, fie \\((\\overline{a_{n-1} a_{n-2} \\ldots a_1 a_0})_b\\) un num\u0103r \u00een baza \\(b\\), format din \\(n\\) cifre, unde \\(a_i\\) \u00eendepline\u0219te acelea\u0219i condi\u021bii ca mai sus. Valoarea num\u0103rului este dat\u0103 de:</p> \\[ \\overline{a_{n-1} a_{n-2} \\ldots a_1 a_0}_b = \\sum_{k=0}^{n-1} a_k \\cdot b^k \\] <p>Aceast\u0103 sum\u0103 poate fi descompus\u0103 \u00een:</p> \\[ \\overline{a_{n-1} a_{n-2} \\ldots a_1 a_0}_b = a_{n-1} \\cdot b^{n-1} + a_{n-2} \\cdot b^{n-2} + \\ldots + a_1 \\cdot b^1 + a_0 \\cdot b^0 \\] <p>Numerele mari sunt esen\u021biale pentru calcule ce dep\u0103\u0219esc limita de \\(2^{63} - 1\\). Acestea se bazeaz\u0103 pe reprezentarea cifric\u0103 a numerelor. De exemplu, s\u0103 reprezent\u0103m num\u0103rul \\(82534\\) folosind defini\u021bia numerelor \u00een baza \\(10\\):</p> \\[ \\begin{align*} 82534 &amp;= 80000 + 2000 + 500 + 30 + 4\\\\ &amp;= 8 \\cdot 10000 + 2 \\cdot 1000 + 5 \\cdot 100 + 3 \\cdot 10 + 4 \\cdot 1\\\\ &amp;= 8 \\cdot 10^{4} + 2 \\cdot 10^3 + 5 \\cdot 10^2 + 3 \\cdot 10^1 + 4 \\cdot 10^0 \\\\ \\end{align*} \\]","tags":["vectori","matematica"]},{"location":"mediu/bignum/#reprezentarea-numerelor-in-memorie","title":"Reprezentarea numerelor \u00een memorie","text":"<p>Reprezentarea pe cifre a numerelor ne duce cu g\u00e2ndul la reprezentarea num\u0103rului folosind un vector. Astfel, o abordare comun\u0103 pentru manipularea numerelor mari \u00een algoritmic\u0103 este reprezentarea acestora prin intermediul unui vector de cifre. Consider\u0103m un num\u0103r mare, pe care \u00eel descompunem \u00een cifrele sale componente \u0219i le stoc\u0103m \u00eentr-un vector.</p> <p>Exemplu</p> <p>De exemplu, num\u0103rul \\(82534\\) poate fi stocat \u00eentr-un vector \\(v\\) astfel:</p> \\[ \\begin{array}{r|cccccccc} i &amp; 0 &amp; 1 &amp; 2 &amp; 3 &amp; 4\\\\ \\hline v[i] &amp; 4 &amp; 3 &amp; 5 &amp; 2 &amp; 8 \\\\ \\end{array} \\]","tags":["vectori","matematica"]},{"location":"mediu/bignum/#reprezentarea-inversa","title":"Reprezentarea invers\u0103","text":"<p>Fie un num\u0103r natural \\(N\\) cu cifrele $\\overline{a_{n-1} a_{n-2} \\ldots a_1 a_0} $ \u00een baza 10. Reprezentarea invers\u0103 a lui \\(N\\) \u00eentr-un vector \\(v\\) de dimensiune \\(n\\) este definit\u0103 astfel:</p> \\[ v[i] = a_{n-i},\\,\\forall\\ 0 \\leq i &lt; n \\] <p>unde \\(n\\) este num\u0103rul de cifre ale num\u0103rului natural \\(N\\), iar \\(v[0]\\) reprezint\u0103 cifra unit\u0103\u021bilor, \\(v[1]\\) cifra zecilor \u0219.a.m.d.</p> <p>Observa\u021bie</p> <p>Numerotarea cifrelor de la coad\u0103, ca \u00een exemplul anterior, este op\u021bional\u0103, dar este indicat\u0103 pentru simplificare, deoarece este mult mai simplu s\u0103 efectu\u0103m opera\u021biile dac\u0103 p\u0103str\u0103m num\u0103rul \u00een memorie \u00een ordine invers\u0103 fa\u021b\u0103 de cum l-am scrie \u00een mod obi\u0219nuit. Practic, ad\u0103ugarea unor valori la pozi\u021biile mai nesemnificative este o opera\u021bie mult mai des \u00eent\u00e2lnit\u0103 dec\u00e2t ad\u0103ugarea la \u00eenceputul num\u0103rului, iar c\u00e2nd e nevoie, putem cre\u0219te lungimea num\u0103rului plas\u00e2nd noua cifr\u0103 pe pozi\u021bia \\(n\\), \\(v[n]\\) \u021bin\u00e2nd aceast\u0103 valoare.</p>","tags":["vectori","matematica"]},{"location":"mediu/bignum/#citirea-si-afisarea-unui-numar-mare","title":"Citirea \u0219i afi\u0219area unui num\u0103r mare","text":"<p>Pentru citirea unui num\u0103r mare, vom citi lungimea num\u0103rului (num\u0103rul de cifre) \u0219i apoi cifrele sale, \u00eencep\u00e2nd de la cea mai pu\u021bin semnificativ\u0103 cifr\u0103 (cifra unit\u0103\u021bilor). Pentru afi\u0219are, proced\u0103m invers, \u00eencep\u00e2nd de la cea mai semnificativ\u0103 cifr\u0103.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\n// Lungimea maxim\u0103 a num\u0103rului\nconst int NMAX = 1000;\n\n// Vectorul care va stoca cifrele num\u0103rului\nint cifre[NMAX];\n\n// Lungimea num\u0103rului\nint n;\n\nint main() {\n    cin &gt;&gt; n;\n\n    // Citim cifrele de la coad\u0103 spre cap\n    for (int i = n - 1; i &gt;= 0; i--) {\n        cin &gt;&gt; cifre[i];\n    }\n\n    // Afi\u0219\u0103m num\u0103rul\n    for (int i = n - 1; i &gt;= 0; i--) {\n        cout &lt;&lt; cifre[i];\n    }\n\n    return 0;\n}\n</code></pre>","tags":["vectori","matematica"]},{"location":"mediu/bignum/#optimizarea-prin-stocarea-lungimii-v0","title":"Optimizarea prin stocarea lungimii v[0]","text":"<p>O \u00eembun\u0103t\u0103\u021bire semnificativ\u0103 a acestei metode este reprezentat\u0103 de utilizarea primei pozi\u021bii a vectorului, \\(v[0]\\), pentru a stoca lungimea num\u0103rului. Aceasta face mai u\u0219oar\u0103 manipularea lungimii \u0219i permite modific\u0103ri mai u\u0219oare ale num\u0103rului, cum ar fi ad\u0103ugarea sau eliminarea cifrelor.</p>","tags":["vectori","matematica"]},{"location":"mediu/bignum/#reprezentarea-inversa_1","title":"Reprezentarea invers\u0103","text":"<p>Fie un num\u0103r natural $N $ cu cifrele $\\overline{a_{n-1} a_{n-2} \\ldots a_1 a_0} $ \u00een baza 10. Reprezentarea invers\u0103 a lui \\(N\\) \u00eentr-un vector \\(v\\) de dimensiune $n $ este definit\u0103 astfel:</p> \\[ \\begin{gather*} v[0] = n\\\\ v[i + 1] = a_{n-i},\\,\\forall\\ 0 \\leq i &lt; n  \\end{gather*} \\] <p>unde \\(v[0]\\) reprezint\u0103 cifra unit\u0103\u021bilor, \\(v[1]\\) cifra zecilor \u0219.a.m.d., \u0219i \\(n\\) este num\u0103rul de cifre ale num\u0103rului natural \\(N\\).</p> <p>Exemplu</p> <p>De exemplu, num\u0103rul \\(82534\\) va fi stocat astfel:</p> \\[ \\begin{array}{r|ccccccccc} i &amp; \\boldsymbol{0} &amp; 1 &amp; 2 &amp; 3 &amp; 4 &amp; 5\\\\ \\hline v[i] &amp; \\boldsymbol{5} &amp; 4 &amp; 3 &amp; 5 &amp; 2 &amp; 8 \\\\ \\end{array} \\] <p>Aici, \\(v[0]=5\\) indic\u0103 num\u0103rul de cifre din \\(N\\), iar cifrele sunt stocate \u00een ordine invers\u0103 \u00eencep\u00e2nd de la \\(v[1]\\).</p>","tags":["vectori","matematica"]},{"location":"mediu/bignum/#procesarea-eficienta-a-numerelor-mari-in-c","title":"Procesarea eficient\u0103 a numerelor mari \u00een C++","text":"<p>Un aspect comun este citirea numerelor mari atunci c\u00e2nd acestea sunt prezentate ca un \u0219ir continuu de cifre, f\u0103r\u0103 separatoare precum spa\u021biile. O tehnic\u0103 eficient\u0103 pentru a aborda aceast\u0103 problem\u0103 implic\u0103 utilizarea string-urilor. Aceast\u0103 metod\u0103 are avantajul de a permite citirea numerelor indiferent de lungimea lor, f\u0103r\u0103 a necesita specificarea acesteia \u00een prealabil.</p>","tags":["vectori","matematica"]},{"location":"mediu/bignum/#pasul-1-citirea-numarului-ca-string","title":"Pasul 1: Citirea num\u0103rului ca string","text":"<p>Primul pas este citirea \u00eentregului num\u0103r ca un string. Aceasta este o abordare flexibil\u0103 care nu este constr\u00e2ns\u0103 de lungimea num\u0103rului. De exemplu, pentru a citi un num\u0103r mare:</p> <pre><code>string numarMare;\ncin &gt;&gt; numarMare;\n</code></pre>","tags":["vectori","matematica"]},{"location":"mediu/bignum/#pasul-2-conversia-stringului-in-vector-de-cifre","title":"Pasul 2: Conversia stringului \u00een vector de cifre","text":"<p>Dup\u0103 citirea num\u0103rului, urm\u0103torul pas este conversia fiec\u0103rui caracter al stringului \u00eentr-o cifr\u0103 numeric\u0103 individual\u0103 \u0219i stocarea acesteia \u00eentr-un vector. Aceast\u0103 conversie este realizat\u0103 prin sc\u0103derea valorii ASCII a caracterului <code>'0'</code> din fiecare caracter al stringului. De asemenea, lungimea num\u0103rului este salvat\u0103 \u00een prima pozi\u021bie a vectorului pentru a facilita accesul \u0219i manipularea ulterioar\u0103 a cifrelor.</p> <p>Iat\u0103 cum arat\u0103 implementarea:</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\n// Lungimea maxim\u0103 a num\u0103rului\nconst int NMAX = 1000;\n\n// Vectorul care va stoca cifrele num\u0103rului\nint cifre[NMAX];\n\n// Lungimea num\u0103rului\nint n;\n\nint main() {\n    string numarMare;\n    cin &gt;&gt; numarMare;\n\n    // Stoc\u0103m lungimea numarului \u00een cifre[0].\n    cifre[0] = numarMare.size();\n\n    // Citim num\u0103rul de la coad\u0103 la cap, convertind\n    // fiecare caracter \u00een valoarea sa numeric\u0103.\n    for (int i = 0; i &lt; cifre[0]; ++i) {\n        cifre[cifre[0] - i] = numarMare[i] - '0';\n    }\n\n    // Afi\u0219area num\u0103rului\n    for (int i = cifre[0]; i &gt;= 1; i--) {\n        cout &lt;&lt; cifre[i];\n    }\n    cout &lt;&lt; endl;\n\n    return 0;\n}\n</code></pre> <p>Aceast\u0103 abordare simplific\u0103 semnificativ citirea numerelor mari</p>","tags":["vectori","matematica"]},{"location":"mediu/bignum/#utilizarea-vectorint-din-stl-pentru-stocare","title":"Utilizarea <code>vector&lt;int&gt;</code> din STL pentru stocare","text":"<p>C\u00e2nd am f\u0103cut citirea cu string-uri, am folosit <code>numarMare.size()</code> pentru a afla lungimea string-ului. Putem folosi aceea\u0219i metod\u0103 pentru a afla \u0219i lungimea num\u0103rului fara s\u0103 o stoc\u0103m in \\(v[0]\\), dar pentru a putea realiza asta, trebuie s\u0103 folosim <code>vector&lt;int&gt;</code>, astfel nemaifiind nevoie s\u0103 stoc\u0103m dimensiunea \u00een \\(v[0]\\).</p>","tags":["vectori","matematica"]},{"location":"mediu/bignum/#crearea-vectorului-si-inserareastergerea-cifrelor-la-inceput","title":"Crearea vectorului si inserarea/\u0219tergerea cifrelor la inceput","text":"<pre><code>#include &lt;iostream&gt;\n#include &lt;vector&gt;\n\nusing namespace std;\n\nvoid afisareNumar(const vector&lt;int&gt;&amp; cifre) {\n    // Pornim de la cifre.size() - 1, deoarece vectorul e indexat de la zero.\n    for (int i = cifre.size() - 1; i &gt;= 0; --i) {\n        cout &lt;&lt; cifre[i];\n    }\n    cout &lt;&lt; \"\\n\";\n}\n\nvoid inserareCifra(vector&lt;int&gt;&amp; cifre, int cifra) {\n    // Inserarea unei cifre noi are loc \u00een fa\u021b\u0103, deoarece folosim reprezentarea\n    // invers\u0103.\n    cifre.push_back(cifra);\n}\n\nvoid stergereCifra(vector&lt;int&gt;&amp; cifre) {\n    // Analog, prima cifr\u0103 se \u0219terge din spate.\n    cifre.pop_back();\n}\n\nint main() {\n    // Putem ini\u021bializa astfel vectorul cu un num\u0103r predefinit, 12 \u00een acest\n    // exemplu.\n    vector&lt;int&gt; cifre = {2, 1};\n\n    cout &lt;&lt; \"Numarul de cifre: \" &lt;&lt; cifre.size() &lt;&lt; \"\\n\";\n    afisareNumar(cifre);\n\n    // Inserarea unei cifre noi \u00een fa\u021b\u0103.\n    inserareCifra(cifre, 9);\n\n    cout &lt;&lt; \"Numarul de cifre: \" &lt;&lt; cifre.size() &lt;&lt; \"\\n\";\n    afisareNumar(cifre);\n\n    // \u0218tergem ultima cifr\u0103.\n    stergereCifra(cifre);\n\n    cout &lt;&lt; \"Numarul de cifre: \" &lt;&lt; cifre.size() &lt;&lt; \"\\n\";\n    afisareNumar(cifre);\n}\n</code></pre> <p>Observ\u0103m c\u0103 astfel dimensiunea vectorului poate varia, un lucru care ne poate ajuta extrem de mult atunci c\u00e2nd nu \u0219tim cat de lung va fi num\u0103rul final.</p>","tags":["vectori","matematica"]},{"location":"mediu/bignum/#implementarea-diverselor-operatii-pe-numerele-mari","title":"Implementarea diverselor opera\u021bii pe numerele mari","text":"<p>Pentru implementarea opera\u021biilor pe numere mari, avem de-a face cu c\u00e2teva cazuri ce vor fi prezentate \u00een ordinea frecven\u021bei lor \u00een practic\u0103, urm\u00e2nd ca la final s\u0103 fie puse toate \u00eempreun\u0103 \u00eentr-o implementare complet\u0103 a unei clase de numere mari. Aceast\u0103 metod\u0103 ce se recomand\u0103 \u00een special celor cu mai mult\u0103 experien\u021b\u0103. \u00cen subcapitolele ce urmeaz\u0103, vom presupune c\u0103 ambii termeni ai opera\u021biilor sunt numere mari, cu excep\u021bia \u00eemp\u0103r\u021birii \u0219i a \u00eenmul\u021bii, unde vom trata ca operanzi at\u00e2t numere mari, c\u00e2t \u0219i numere mici (adic\u0103 numere care nu sunt mari).</p>","tags":["vectori","matematica"]},{"location":"mediu/bignum/#adunarea-numerelor-mari","title":"Adunarea numerelor mari","text":"<p>Adunarea a dou\u0103 numere mari se va realiza \u00een mod similar cu modul \u00een care a\u021bi fost obi\u0219nui\u021bi s\u0103 aduna\u021bi numere la \u0219coal\u0103 \u00een clasele mici, cifr\u0103 cu cifr\u0103 \u0219i \u021bin\u00e2nd cont de transportul cifrelor adi\u021bionale.</p> <pre><code>// Adunarea fiec\u0103rei cifre din b la cifra corespunz\u0103toare din a\nfor (int i = 1; i &lt;= b[0]; i++) {\n    a[i] += b[i];\n}\n\n// `a` trebuie s\u0103 aib\u0103 num\u0103rul potrivit de cifre pentru a putea \u00eenc\u0103pea adunarea,\n// a\u0219adar alegem maximul dintre lungimile celor dou\u0103 numere.\na[0] = max(a[0], b[0]);\n\n// Gestionarea transportului\nfor (int i = 1; i &lt;= a[0]; i++) {\n    // Avem un transport!\n    if (a[i] &gt;= 10) {\n        // Dac\u0103 e ultima cifr\u0103, doar cre\u0219tem num\u0103rul de cifre.\n        if (i == a[0]) {\n            a[0]++;\n        }\n\n        // Adaug\u0103 transportul la cifra urm\u0103toare, \u0219i re\u021bine doar ultima cifr\u0103.\n        a[i + 1]++;\n        a[i] -= 10;\n    }\n}\n</code></pre>","tags":["vectori","matematica"]},{"location":"mediu/bignum/#scaderea-numerelor-mari","title":"Sc\u0103derea numerelor mari","text":"<p>Sc\u0103derea a dou\u0103 numere mari se va realiza \u00een mod similar cu modul \u00een care a\u021bi fost obi\u0219nui\u021bi s\u0103 sc\u0103de\u021bi numere la \u0219coal\u0103 \u00een clasele mici, cifr\u0103 cu cifr\u0103 \u0219i \u021bin\u00e2nd cont de \u00eemprumutul cifrelor necesare pentru efectuarea opera\u021biilor.</p> <pre><code>// Sc\u0103derea fiec\u0103rei cifre din b din cifra corespunz\u0103toare din a\nfor (int i = 1; i &lt;= b[0]; i++) {\n    a[i] -= b[i];\n}\n\n// Gestionarea \u00eemprumutului\nfor (int i = a[0]; i &gt;= 1; i--) {\n    // Dac\u0103 cifra este negativ\u0103, \u201ene \u00eemprumut\u0103m\u201d\n    // Ad\u0103ug\u0103m 10 la cifra curent\u0103 \u0219i sc\u0103dem 1 de la cifra urm\u0103toare pentru a \n    // face \u00eemprumutul.\n    if (a[i] &lt; 0) {\n        a[i] += 10;\n        a[i + 1]--;\n    }\n}\n\n// Elimin\u0103 zerourile nesemnificative din fa\u021ba num\u0103rului\nwhile (a[a[0]] == 0) {\n    a[0]--;\n}\n</code></pre>","tags":["vectori","matematica"]},{"location":"mediu/bignum/#compararea-a-doua-numere-mari","title":"Compararea a dou\u0103 numere mari","text":"<p>Pentru a compara dou\u0103 numere mari, avem dou\u0103 cazuri simple de tratat, urm\u00e2nd ca restul implement\u0103rii s\u0103 fie similar cu modul \u00een care am compara dou\u0103 \u0219iruri de caractere.</p> <p>Dac\u0103 cele dou\u0103 numere au un num\u0103r diferit de cifre, putem trage concluzia \u00een mod evident, iar \u00een caz contrar, vom lua cifr\u0103 cu cifr\u0103, de la cea mai semnificativ\u0103 la cea mai pu\u021bin semnificativ\u0103.</p> <pre><code>// -1 dac\u0103 a &lt; b\n// 0 dac\u0103 a == b\n// 1 dac\u0103 a &gt; b\nint comparaCifre(const vector&lt;int&gt;&amp; a, const vector&lt;int&gt;&amp; b) {\n    // a are mai multe cifre\n    if (a[0] &gt; b[0]) {\n        return 1;\n    }\n\n    // b are mai multe cifre\n    if (a[0] &lt; b[0]) {\n        return -1;\n    }\n\n    // Au acela\u0219i num\u0103r de cifre, deci compar\u0103m cifr\u0103 cu cifr\u0103.\n    for (int i = a[0]; i &gt;= 1; i--) {\n        if (a[i] == b[i]) {\n            continue;\n        }\n\n        return (a[i] &gt; b[i]) ? 1 : -1;\n    }\n\n    return 0;\n}\n</code></pre>","tags":["vectori","matematica"]},{"location":"mediu/bignum/#inmultirea-unui-numar-mare-cu-un-numar-mic","title":"\u00cenmul\u021birea unui num\u0103r mare cu un num\u0103r mic","text":"<p>Acest subcaz al \u00eenmul\u021birii poate fi implementat mult mai u\u0219or, implementarea prelu\u00e2nd multe elemente din cele ale adun\u0103rii a dou\u0103 numere mari. Vom presupune c\u0103 vom \u00eenmul\u021bi num\u0103rul mare cu \\(x\\).</p> <pre><code>long long val = 0;\n\nfor (int i = 1; i &lt;= a[0]; i++) {\n    // Includem produsul dintre cifra curent\u0103 \u0219i x\n    val += 1LL * a[i] * x;\n    // Stoc\u0103m ultima cifr\u0103 a acestei sume...\n    a[i] = val % 10;\n    // ...\u0219i o scoatem din sum\u0103.\n    val /= 10;\n}\n\n// Gestionarea transportului r\u0103mas dup\u0103 \u00eenmul\u021bire. \n// Pentru fiecare cifr\u0103 din val, l\u0103rgim num\u0103rul \u0219i stoc\u0103m ultima cifr\u0103 din val \n// ca prima cifr\u0103 din num\u0103r.\nfor (; val; val /= 10) {\n    a[0]++;\n    a[a[0]] = val % 10;\n}\n</code></pre>","tags":["vectori","matematica"]},{"location":"mediu/bignum/#inmultirea-a-doua-numere-mari","title":"\u00cenmul\u021birea a dou\u0103 numere mari","text":"<p>\u00cenmul\u021birea a dou\u0103 numere mari va necesita lucrul cu toate cifrele num\u0103rului, complexitatea algoritmului devenind \\(O(n_A \\cdot n_B)\\), unde \\(n_A\\) reprezint\u0103 num\u0103rul de cifre al lui \\(A\\), iar \\(n_B\\), num\u0103rul de cifre al lui \\(B\\). Din nou, implementarea va fi asem\u0103n\u0103toare cu cea \u00eenv\u0103\u021bat\u0103 \u00een clasele mici la \u0219coal\u0103.</p> <pre><code>// Num\u0103rul nostru este cel pu\u021bin la fel de mare ca suma cifrelor lor + 1.\nvector&lt;long long&gt; ans(a[0] + b[0] + 1);\n\n// Facem produsul fiec\u0103rei cifre din a cu fiecare cifr\u0103 din b\nfor (int i = 1; i &lt;= a[0]; i++) {\n    for (int j = 1; j &lt;= b[0]; j++) {\n        ans[i + j - 1] += 1LL * b[j] * a[i];\n    }\n}\n\n// Ajustarea dimensiunii vectorului a pentru a \u021bine cont de posibilele\n// transporturi\na[0] += b[0] - 1;\n\nfor (int i = 1; i &lt;= a[0]; i++) {\n\n    // Avem un transport\n    if (ans[i] &gt;= 10) {\n\n        // Dac\u0103 este ultima cifr\u0103...\n        if (i == a[0]) {\n            // ...cre\u0219tem dimensiunea \u0219i o ad\u0103ug\u0103m.\n            a[0]++;\n            ans.push_back(ans[i] / 10);\n        } else {\n            // Adaug\u0103 transportul la cifra urm\u0103toare.\n            ans[i + 1] += ans[i] / 10;\n        }\n\n        // P\u0103streaz\u0103 cifra curent\u0103.\n        ans[i] %= 10;\n    }\n}\n\n// Copierea cifrelor din ans \u00eenapoi \u00een a\nfor (int i = 1; i &lt; (int)ans.size(); i++) {\n    a[i] = ans[i];\n}\n</code></pre>","tags":["vectori","matematica"]},{"location":"mediu/bignum/#impartirea-unui-numar-mare-la-un-numar-mic","title":"\u00cemp\u0103r\u021birea unui num\u0103r mare la un num\u0103r mic","text":"<p>La fel ca la \u00eenmul\u021bire, vom lucra cifr\u0103 cu cifr\u0103 \u0219i vom avea grij\u0103 s\u0103 lu\u0103m transportul cifr\u0103 cu cifr\u0103. Vom presupune c\u0103 vom \u00eemp\u0103r\u021bi num\u0103rul mare la \\(x\\).</p> <pre><code>long long val = 0;\n\nfor (int i = a[0]; i &gt;= 1; i--) {\n    // Actualizeaz\u0103 val pentru a include cifra curent\u0103\n    val = val * baza + a[i];\n\n    // Stocheaz\u0103 c\u00e2tul \u00eemp\u0103r\u021birii lui val la x \u00een pozi\u021bia curent\u0103\n    a[i] = val / x;\n\n    // Stocheaz\u0103 restul \u00eemp\u0103r\u021birii \u00een val\n    val %= x;\n}\n\n// Elimin\u0103, zerourile nesemnificative din fa\u021ba num\u0103rului\nwhile (a[a[0]] == 0) {\n    a[0]--;\n}\n</code></pre>","tags":["vectori","matematica"]},{"location":"mediu/bignum/#afisarea-unui-numar-mare","title":"Afi\u0219area unui num\u0103r mare","text":"<p>Atunci c\u00e2nd lucr\u0103m cu o baz\u0103 mai mare ca \\(10\\), afi\u0219area num\u0103rului poate deveni un pic mai complicat\u0103, fiind nevoie de aten\u021bie suplimentar\u0103 pentru a face lucrurile s\u0103 func\u021bioneze. Aici am pus o implementare mai generalizat\u0103, unde \\(b\\) este baza pe care o folosim (implicit e \\(10\\), dar poate fi ajustat\u0103).</p> <pre><code>bool ok = false;\n\n// Parcurgem de la cea mai semnificativ\u0103 cifr\u0103 c\u0103tre cea mai pu\u021bin semnificativ\u0103 \n// cifr\u0103\nfor (int i = a[0]; i &gt;= 1; i--) {\n    if (ok) {\n        // Valoarea curent\u0103 s\u0103 fie cel pu\u021bin 1\n        long long val = max(1LL, a[i]);\n\n        // Ad\u0103ug\u0103m zerouri la \u00eenceput pentru a p\u0103stra formatul corect.\n        while (val * 10 &lt; b) {\n            cout &lt;&lt; 0;\n            val *= 10;\n        }\n    }\n\n    // Dac\u0103 cifra curent\u0103 nu este zero, am \u00eenceput s\u0103 afi\u0219\u0103m\n    // adic\u0103 am sc\u0103pat de zerourile ini\u021biale.\n    if (a[i]) {\n        ok = true;\n    }\n\n    cout &lt;&lt; a[i];\n}\n</code></pre>","tags":["vectori","matematica"]},{"location":"mediu/bignum/#optimizari-ce-se-pot-face-la-implementare","title":"Optimiz\u0103ri ce se pot face la implementare","text":"<p>Prima \u0219i cea mai evident\u0103 optimizare const\u0103 \u00een lucrul cu o baz\u0103 mai mare ca \\(10\\), de regul\u0103 putere a lui \\(10\\). Se recomand\u0103 folosirea unei baze \u00eentre \\(10^6\\) \u0219i \\(10^8\\), pentru a evita overflow-urile ce ar putea ap\u0103rea de la stocarea individual\u0103 a fiec\u0103rei pozi\u021bii drept un num\u0103r de \\(10\\) sau mai multe cifre. Aceast\u0103 optimizare poate fi util\u0103 mai ales \u00een situa\u021bia \u00een care foarte multe calcule sunt necesare sau limita de timp este str\u00e2ns\u0103. Un astfel de exemplu reprezint\u0103 problemele de programare dinamic\u0103 \u00een care trebuie afi\u0219at num\u0103rul complet de solu\u021bii (totu\u0219i, \u00een prezent, o mare parte din acele probleme cer r\u0103spunsul modulo un num\u0103r prim).</p> <p>De asemenea, a\u0219a cum ve\u021bi observa mai t\u00e2rziu, exist\u0103 diverse metode de a optimiza opera\u021biile de \u00eenmul\u021bire, folosind diver\u0219i algoritmi precum algoritmul lui Karatsuba sau FFT, dar ace\u0219tia nu fac obiectul discu\u021biei noastre din acest articol.</p>","tags":["vectori","matematica"]},{"location":"mediu/bignum/#probleme-si-resurse-suplimentare","title":"Probleme \u0219i resurse suplimentare","text":"<ul> <li>Clas\u0103 de numere mari</li> <li>Lucrul cu numere mari</li> <li>Probleme cu numere mari</li> <li>perm3 de pe infoarena</li> <li>pastile, lot juniori 2015</li> <li>num\u0103r, OJI 2010 IX</li> </ul>","tags":["vectori","matematica"]},{"location":"mediu/bitmask-dp/","title":"Dinamic\u0103 pe st\u0103ri exponen\u021biale (bitmask DP)","text":"<p>Autor: \u0218tefan-Cosmin D\u0103sc\u0103lescu</p> <p>Atunci c\u00e2nd vorbim de tipuri de probleme pentru care apel\u0103m la solu\u021bii bazate pe metoda program\u0103rii dinamice, dinamicile pe m\u0103\u0219ti pe bi\u021bi (bitmask dp) se disting prin faptul c\u0103 reu\u0219esc s\u0103 formalizeze aceste calcule pentru dimensiuni mici ale valorilor, elimin\u00e2nd necesitatea de a calcula toate cele \\(N!\\) permut\u0103ri ale \u0219irului dat, prin st\u0103ri care s\u0103 \u021bin\u0103 doar posibilele rezultate optime.</p> <p>Chiar dac\u0103 aceast\u0103 subtehnic\u0103 este folosit\u0103 doar pentru dimensiuni ale datelor foarte mici (de regul\u0103, valoarea maxim\u0103 a lui \\(N\\) \u00eentr-o problem\u0103 de acest gen este \\(20\\)), bitmask dp se dovede\u0219te a fi o unealt\u0103 foarte util\u0103 \u00een multe instan\u021be, chiar \u0219i atunci c\u00e2nd trebuie s\u0103 g\u0103sim solu\u021bii \u00eencete pentru a face pa\u0219i spre a optimiza diverse abord\u0103ri.</p> <p>Observa\u021bie</p> <p>\u00cen jargonul algoritmic rom\u00e2nesc, aceast\u0103 tehnic\u0103 este numit\u0103 dinamic\u0103 pe st\u0103ri exponen\u021biale, denot\u00e2nd num\u0103rul exponen\u021bial de st\u0103ri (de regul\u0103, \\(2^N\\) st\u0103ri)</p>","tags":["programare dinamica","operatii pe biti","submultimi"]},{"location":"mediu/bitmask-dp/#introducere-si-aplicare","title":"Introducere \u0219i aplicare","text":"<p>\u00cen primul r\u00e2nd, pentru a putea folosi aceast\u0103 tehnic\u0103, trebuie s\u0103 ne reamintim c\u00e2teva concepte \u00eenv\u0103\u021bate de la opera\u021biile pe bi\u021bi, cele mai importante fiind submul\u021bimile \u0219i m\u0103\u0219tile pe bi\u021bi. Pentru mai multe detalii, pute\u021bi citi aici.</p> <p>Acum c\u0103 acest concept v\u0103 este cunoscut, pentru a formaliza o stare \u00eentr-o problem\u0103 de acest gen, trebuie s\u0103 g\u0103sim o mul\u021bime de valori cu un cardinal suficient de mic, care are proprietatea c\u0103 submul\u021bimile sale pot constitui st\u0103ri \u00eentr-o rela\u021bie de recuren\u021b\u0103 de acest fel. </p> <p>Observa\u021bie</p> <p>Nu este obligatoriu ca starea pe care o folosim s\u0103 fie legat\u0103 strict de \u0219irul de numere dat. De foarte multe ori, vom aplica aceast\u0103 tehnic\u0103 atunci c\u00e2nd avem o particularitate care poate fi transpus\u0103 \u00een submul\u021bimi (un exemplu ar fi atunci c\u00e2nd avem pu\u021bine valori distincte sau un set de litere al alfabetului).</p> <p>\u00cen cele mai multe cazuri, vorbim de dinamici de tipul \\(dp[msk]\\) sau \\(dp[msk][i]\\), unde ambele reprezint\u0103 r\u0103spunsul optim pentru submul\u021bimea reprezentat\u0103 cu masca \\(msk\\) \u0219i eventual \\(i\\) fiind ultima valoare aleas\u0103. Evident, dac\u0103 problema o impune, putem folosi \u0219i alte dimensiuni pentru a reprezenta datele \u00eentr-o manier\u0103 mai clar\u0103 \u0219i f\u0103r\u0103 poten\u021biale erori.</p> <p>Vom continua prin a prezenta probleme clasice care se rezolv\u0103 cu aceast\u0103 tehnic\u0103. </p>","tags":["programare dinamica","operatii pe biti","submultimi"]},{"location":"mediu/bitmask-dp/#problema-teamwork","title":"Problema teamwork","text":"<p>Se poate remarca faptul c\u0103 sunt cel mult \\(18\\) participan\u021bi, iar fiecare trebuie s\u0103 fie folosit o dat\u0103. Generarea tuturor permut\u0103rilor ar fi mult prea \u00eenceat\u0103, a\u0219a c\u0103 va trebui s\u0103 p\u0103str\u0103m informa\u021bii legate de varianta optim\u0103 de a folosi toate submul\u021bimile de copii. </p> <p>Definim \\(dp[msk]\\) ca fiind suma maxim\u0103 a scorurilor dac\u0103 am folosit submul\u021bimea cu masca \\(msk\\). Pentru a face tranzi\u021bia de la \\(msk\\) la o alt\u0103 stare, va trebui s\u0103 parcurgem lista de participan\u021bi, verific\u00e2nd cu ajutorul opera\u021biilor pe bi\u021bi dac\u0103 au mai fost lua\u021bi sau nu. </p> <p>Solu\u021bia va avea complexitate \\(O(2^n \\cdot n)\\), fiind suficient de bun\u0103 pentru problema dat\u0103. </p> <p>Observa\u021bie</p> <p>De-a lungul solu\u021biilor prezentate, se va observa preferin\u021ba pentru indexarea de la \\(0\\) a pozi\u021biilor, motivul fiind unul ce \u021bine de eficien\u021ba de timp \u0219i memorie (dac\u0103 am fi indexat de la \\(1\\), am fi avut nevoie de dou\u0103 ori mai multe m\u0103\u0219ti, deoarece m\u0103\u0219tile care con\u021bineau pozi\u021bia \\(0\\) deveneau inutile).</p> <pre><code>#include &lt;fstream&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\nint main() {\n\n    ifstream cin(\"teamwork.in\");\n    ofstream cout(\"teamwork.out\");\n\n    int n;\n    cin &gt;&gt; n;\n\n    vector&lt;vector&lt;int&gt;&gt; a(n, vector&lt;int&gt; (n));\n    vector&lt;int&gt; dp(1&lt;&lt;n);\n\n    for (int i = 0; i &lt; n; ++i) {\n        for (int j = 0; j &lt; n; ++j) {\n            cin &gt;&gt; a[i][j];\n        }\n    }\n    for (int msk = 0; msk &lt; (1 &lt;&lt; n) - 1; ++msk) {\n        // cati biti are i\n        int nb = __builtin_popcount(msk); \n        for (int j = 0; j &lt; n; ++j) {\n            if (!(msk &amp; (1 &lt;&lt; j))) {\n                dp[msk ^ (1 &lt;&lt; j)] = max(dp[msk ^ (1 &lt;&lt; j)], dp[msk] + a[nb][j]);\n            }\n        }\n    }\n    cout &lt;&lt; dp[(1 &lt;&lt; n) - 1] &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["programare dinamica","operatii pe biti","submultimi"]},{"location":"mediu/bitmask-dp/#problema-elevator-rides","title":"Problema Elevator Rides","text":"<p>Pentru a rezolva aceast\u0103 problem\u0103, vom recurge la o alt\u0103 dinamic\u0103 similar\u0103 cu cea anterioar\u0103, singura diferen\u021b\u0103 fiind faptul c\u0103 trebuie s\u0103 o g\u00e2ndim \u0219i din perspectiva problemei rucsacului. Este clar c\u0103 vrem s\u0103 avem ceva de tipul \\(dp[msk]\\) care s\u0103 ne \u021bin\u0103 num\u0103rul minim de folosiri ale liftului pentru submul\u021bimea de oameni cu masca \\(msk\\), dar trebuie s\u0103 g\u0103sim o metod\u0103 pentru a departaja mul\u021bimile cu acela\u0219i num\u0103r de excursii cu liftul.</p> <p>O metod\u0103 simpl\u0103 este aceea de a \u021bine o alt\u0103 informa\u021bie \u00een dinamica noastr\u0103, \u0219i anume gradul de umplere al liftului la excursia curent\u0103, astfel vom \u021bine \u00een dinamica noastr\u0103 o pereche, care va avea at\u00e2t num\u0103rul minim de c\u0103l\u0103torii, c\u00e2t \u0219i gradul de umplere al c\u0103l\u0103toriei curente. La fiecare pas, fie vom reu\u0219i s\u0103 ad\u0103ug\u0103m c\u0103l\u0103torul curent \u00een excursia curent\u0103, fie vom \u00eencepe un alt drum cu liftul.</p> <p>Complexitatea va fi la fel ca la problema precedent\u0103, \\(O(2^n \\cdot n)\\), fiind suficient de bun\u0103 pentru cerin\u021bele problemei. </p> <pre><code>#include &lt;iostream&gt;\n#include &lt;vector&gt;\n\nusing namespace std;\n\nint main() {\n\n    int n, w;\n    cin &gt;&gt; n &gt;&gt; w;\n\n    vector&lt;int&gt; v(n);\n    for (int i = 0; i &lt; n; ++i) {\n        cin &gt;&gt; v[i];\n    }\n\n    vector&lt;pair&lt;int, int&gt;&gt; dp(1&lt;&lt;n);\n    dp[0].first = 1;\n\n    for (int msk = 1; msk &lt; (1&lt;&lt;n); ++msk) {\n        dp[msk].first = n+1;\n    }\n\n    for (int msk = 0; msk &lt; (1&lt;&lt;n); ++msk) {\n        for (int j = 0; j &lt; n; ++j) {\n            if (msk &amp; (1&lt;&lt;j)) {\n                continue;\n            }\n            if (dp[msk].second + v[j] &lt;= w) {\n                dp[msk + (1&lt;&lt;j)] = min(dp[msk + (1&lt;&lt;j)], {dp[msk].first, dp[msk].second + v[j]});\n            }\n            else {\n                dp[msk + (1&lt;&lt;j)] = min(dp[msk + (1&lt;&lt;j)], {dp[msk].first + 1, v[j]});\n            }\n        }\n    }\n\n    cout &lt;&lt; dp[(1&lt;&lt;n) - 1].first;\n    return 0;\n}\n</code></pre>","tags":["programare dinamica","operatii pe biti","submultimi"]},{"location":"mediu/bitmask-dp/#problema-hamiltonian-flights","title":"Problema Hamiltonian Flights","text":"<p>Aceast\u0103 problem\u0103 este una din varia\u021biile problemei comis-voiajorului sau cum se nume\u0219te \u00een englez\u0103, Traveling salesman problem. </p> <p>Pentru a afla num\u0103rul de drumuri de la \\(0\\) la \\(n-1\\) care trec prin toate nodurile, vom \u021bine o dinamic\u0103 de tip \\(dp[msk][i]\\) \u00een care vom \u021bine num\u0103rul de drumuri care pleac\u0103 de la \\(0\\), sunt la nodul \\(i\\) \u0219i au trecut prin submul\u021bimea de noduri \\(msk\\). Se poate observa c\u0103 graful dat poate avea muchii multiple, acesta fiind motivul pentru care \u021binem muchiile \u00eentr-o list\u0103 de vecini \u0219i nu \u00eentr-o matrice de adiacen\u021b\u0103.</p> <p>Deoarece limita de timp este una str\u00e2ns\u0103, sunt necesare c\u00e2teva optimiz\u0103ri prezentate \u00een cod pentru a evita parcurgerea st\u0103rilor inutile. </p> <pre><code>#include &lt;iostream&gt;\n#include &lt;vector&gt;\n#include &lt;cassert&gt;\n\nusing namespace std;\n\nconst int mod = 1000000007;\n\nint main() {\n\n    int n, m;\n    cin &gt;&gt; n &gt;&gt; m;\n\n    vector&lt;vector&lt;int&gt;&gt; graph(n);\n\n    for (int i = 0; i &lt; m; ++i) {\n        int a, b;\n        cin &gt;&gt; a &gt;&gt; b;\n        --a, --b;\n        graph[a].push_back(b);\n    }\n\n    vector&lt;vector&lt;int&gt;&gt; dp((1&lt;&lt;n), vector&lt;int&gt; (n));\n    dp[1][0] = 1;\n\n    for (int msk = 0; msk &lt; (1&lt;&lt;n); msk++) {\n        // daca masca nu contine 1, nu are sens sa continuam\n        if (!(msk &amp; 1)) { \n            continue;\n        }\n        // daca masca contine n, nu e valida (procesam n la final)\n        if (msk &amp; (1&lt;&lt;(n-1))) {\n            continue;\n        }\n        for (int node = 0; node &lt; n; node++) {\n            // nodul trebuie sa fi fost procesat deja\n            if (!(msk &amp; (1&lt;&lt;node))) {\n                continue;\n            }\n            for (int nxt : graph[node]) {\n                // nu vom procesa un nod deja vizitat\n                if (msk &amp; (1&lt;&lt;nxt)) {\n                    continue;\n                }\n                dp[msk ^ (1&lt;&lt;nxt)][nxt] += dp[msk][node];\n                if (dp[msk ^ (1&lt;&lt;nxt)][nxt] &gt;= mod) {\n                    dp[msk ^ (1&lt;&lt;nxt)][nxt] -= mod;\n                }\n            }\n        }\n    }\n\n    cout &lt;&lt; dp[(1&lt;&lt;n) - 1][n-1] &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["programare dinamica","operatii pe biti","submultimi"]},{"location":"mediu/bitmask-dp/#concluzii","title":"Concluzii","text":"<p>Dinamica pe st\u0103ri exponen\u021biale este o tehnic\u0103 foarte util\u0103 c\u00e2nd trebuie s\u0103 formaliz\u0103m rela\u021bii pe un num\u0103r mic de elemente. Aplica\u021biile acesteia pe grafuri sau pe alte tipuri de mul\u021bimi vor fi foarte utile at\u00e2t \u00een concursuri, c\u00e2t \u0219i \u00een alte situa\u021bii practice, iar tehnici precum SOS DP \u0219i Broken Profile DP vor aduce conceptul la un nivel \u0219i mai avansat.</p>","tags":["programare dinamica","operatii pe biti","submultimi"]},{"location":"mediu/bitmask-dp/#probleme-suplimentare","title":"Probleme suplimentare","text":"<ul> <li>infoarena morcovi</li> <li>infoarena poly</li> <li>infoarena coins</li> <li>infoarena zebughil</li> <li>RCPCamp 2023 Anton Would Approve this problem</li> <li>OJI 2011 Ubuntzei</li> <li>OJI 2020 RecycleBin</li> <li>Lot Juniori 2014 ssce</li> <li>Lot Juniori 2024 nooverlap</li> <li>OJI 2005 scara</li> <li>AtCoder Matching</li> <li>Codeforces Square Subsets</li> <li>Nastya and Scoreboard</li> <li>USACO Gold Uddered but not Heard</li> <li>Codeforces Team Building</li> <li>Codeforces Minimax Problem</li> <li>COCI 2016 Burza</li> </ul>","tags":["programare dinamica","operatii pe biti","submultimi"]},{"location":"mediu/bitmask-dp/#lectura-suplimentara","title":"Lectur\u0103 suplimentar\u0103","text":"<ul> <li>Bitmask DP - USACO Guide</li> <li>A primer on bitmask DP - Neo Wang</li> <li>Curs lot juniori 2023 - Dinamic\u0103 pe st\u0103ri exponen\u021biale</li> <li>Dinamic\u0103 pe st\u0103ri exponen\u021biale - CPPI Sync</li> <li>DP Book, pagina 37</li> <li>(Avansat) Broken Profile DP - USACO Guide</li> <li>(Avansat) SOS DP - USACO Guide</li> <li>(Avansat) SOS Dynamic Programming - Codeforces</li> </ul>","tags":["programare dinamica","operatii pe biti","submultimi"]},{"location":"mediu/bitwise-ops/","title":"Opera\u021bii pe bi\u021bi","text":"<p>Autori: \u0218tefan-Cosmin D\u0103sc\u0103lescu</p> <p>\u00cen informatic\u0103 \u0219i \u00een programare, bitul reprezint\u0103 unitatea de baz\u0103 pentru stocarea informa\u021biilor \u00een memorie. Orice activitate desf\u0103\u0219urat\u0103 folosind un sistem de calcul (inclusiv articolul pe care \u00eel citi\u021bi acum) are la baz\u0103 o \u00een\u0219iruire de bi\u021bi folosi\u021bi pentru a reda informa\u021bia sub o form\u0103 accesibil\u0103 pentru oameni. </p> <p>Din acest considerent, bi\u021bii au ajuns s\u0103 fie studia\u021bi \u00een mod am\u0103nun\u021bit, iar \u00een cele ce urmeaz\u0103, vom prezenta sistemul binar, opera\u021biile pe bi\u021bi \u0219i diverse propriet\u0103\u021bi, observa\u021bii \u0219i tehnici pe care le putem folosi pentru a rezolva probleme de algoritmic\u0103, dar \u0219i modurile \u00een care putem integra cuno\u0219tin\u021bele drept pa\u0219i intermediari pentru rezolvarea altor probleme de algoritmic\u0103. </p>","tags":["biti","matematica"]},{"location":"mediu/bitwise-ops/#sistemul-binar","title":"Sistemul binar","text":"<p>De-a lungul acestui articol, vom lucra cu numere reprezentate \u00een form\u0103 binar\u0103 (\u00een baza \\(2\\)), deci formate din cifre de \\(0\\) \u0219i de \\(1\\). De exemplu, dac\u0103 vrem s\u0103 scriem num\u0103rul \\(27\\) \u00een binar, reprezentarea acestuia va fi:</p> \\[27_{(10)} = 00011011_{(2)} = 0 \\cdot 2^7 + 0 \\cdot 2^6 + 0 \\cdot 2^5 + 1 \\cdot 2^4 + 1 \\cdot 2^3 + 0 \\cdot 2^2 + 1 \\cdot 2^1 + 1 \\cdot 2^0\\] <p>De\u0219i de obicei nu lucr\u0103m cu zerourile nesemnificative, \u00een acest caz ele au fost prezentate pentru \u00een\u021belegerea conceptului, precum \u0219i datorit\u0103 faptului c\u0103 a\u0219a cum ar trebui cunoscut deja, tipurile de date din limbajele C/C++ (\u0219i alte limbaje) au un num\u0103r de bi\u021bi clar definit (de exemplu, <code>int</code> este un tip de date pe \\(32\\) de bi\u021bi, <code>char</code> este un tip de date pe \\(8\\) bi\u021bi \u0219.a.m.d.).</p>","tags":["biti","matematica"]},{"location":"mediu/bitwise-ops/#legatura-dintre-o-baza-oarecare-si-baza-10","title":"Leg\u0103tura dintre o baz\u0103 oarecare \u0219i baza \\(10\\)","text":"<p>\u00cen cele ce urmeaz\u0103, prezent\u0103m algoritmul de transformare a unui num\u0103r din baza \\(10\\) \u00een baza \\(k\\) \u0219i invers. Remarc\u0103m faptul c\u0103 acest algoritm func\u021bioneaz\u0103 indiferent de baza de la care plec\u0103m, at\u00e2ta timp c\u00e2t baza \\(10\\) este parte din calculele noastre. </p> <p>Observa\u021bie</p> <p>\u00cen general, dac\u0103 vrem s\u0103 transform\u0103m din baza \\(a\\) \u00een baza \\(b\\), un algoritm foarte u\u0219or de implementat va fi s\u0103 transform\u0103m mai \u00eent\u00e2i din baza \\(a\\) \u00een baza \\(10\\), iar mai apoi s\u0103 transform\u0103m din baza \\(10\\) \u00een baza \\(b\\). </p>","tags":["biti","matematica"]},{"location":"mediu/bitwise-ops/#transformarea-unui-numar-din-baza-10-in-baza-k","title":"Transformarea unui num\u0103r din baza \\(10\\) \u00een baza \\(k\\).","text":"<p>Pentru a transforma un num\u0103r din baza \\(10\\) \u00een baza \\(k\\), vom \u00eemp\u0103r\u021bi repetat num\u0103rul la \\(k\\), p\u00e2n\u0103 c\u00e2nd num\u0103rul va deveni \\(0\\), iar resturile \u00eemp\u0103r\u021birilor pe care le ob\u021binem vor crea num\u0103rul \u00een baza \\(k\\), \u00een ordine invers\u0103. </p> <p>Exemplu</p> <p>De exemplu, dac\u0103 vrem s\u0103 convertim num\u0103rul \\(46\\) \u00een baza \\(2\\), vom ob\u021bine urm\u0103toarele c\u00e2turi \u0219i resturi.</p> <ul> <li>\\(n = 46\\), \\(\\frac{46}{2} = 23\\), restul \\(0\\).</li> <li>\\(n = 23\\), \\(\\frac{23}{2} = 11\\), restul \\(1\\).</li> <li>\\(n = 11\\), \\(\\frac{11}{2} = 5\\), restul \\(1\\).</li> <li>\\(n = 5\\), \\(\\frac{5}{2} = 2\\), restul \\(1\\).</li> <li>\\(n = 2\\), \\(\\frac{2}{2} = 1\\), restul \\(0\\).</li> <li>\\(n = 1\\), \\(\\frac{1}{2} = 0\\), restul \\(1\\).</li> </ul> <p>Dac\u0103 lu\u0103m resturile \u00eemp\u0103r\u021birilor la \\(2\\) \u00een ordine invers\u0103, ob\u021binem \\(101110\\), num\u0103r care se poate verifica c\u0103 ne va returna \\(n = 46\\) daca \u00eel convertim \u00een baza \\(10\\). </p> <p>Mai jos pute\u021bi g\u0103si o scurt\u0103 implementare \u00een limbajul C++.</p> <pre><code>int n, k; // transformam n in baza k\ncin &gt;&gt; n &gt;&gt; k;\nint nrcif = 0, v[32]; // cifrele in baza k\n\n// obtinem cifrele, una cate una\nwhile (n &gt; 0) {\n    int c = n%k;\n    nrcif++;\n    v[nrcif] = c;\n    n /= k;\n}\n\n// pentru a le afisa, le vom afisa invers\nfor (int i = nrcif; i &gt;= 1; i--) {\n    cout &lt;&lt; v[i];\n}\ncout &lt;&lt; '\\n';\n</code></pre>","tags":["biti","matematica"]},{"location":"mediu/bitwise-ops/#transformarea-unui-numar-din-baza-k-in-baza-10","title":"Transformarea unui num\u0103r din baza \\(k\\) \u00een baza \\(10\\).","text":"<p>Pentru a transforma un num\u0103r din baza \\(k\\) \u00een baza \\(10\\), vom lua cifrele num\u0103rului, de la dreapta la st\u00e2nga, \u0219i vom ad\u0103uga la r\u0103spunsul nostru \\(cif \\cdot k^i\\), unde \\(cif\\) este cifra curent\u0103, \\(k\\) este baza de la care plec\u0103m \u0219i \\(i\\) este num\u0103rul pasului la care suntem. </p> <p>Exemplu</p> <p>De exemplu, dac\u0103 vrem s\u0103 convertim num\u0103rul \\(10110\\) \u00een baza \\(10\\), vom avea urm\u0103toarele cifre:</p> <ul> <li>pozi\u021bia \\(0\\): cifra este \\(0\\), se adun\u0103 \\(0\\) la num\u0103rul \u00een baza \\(10\\).</li> <li>pozi\u021bia \\(1\\): cifra este \\(1\\), se adun\u0103 \\(2^1\\) la num\u0103rul \u00een baza \\(10\\).</li> <li>pozi\u021bia \\(2\\): cifra este \\(1\\), se adun\u0103 \\(2^2\\) la num\u0103rul \u00een baza \\(10\\).</li> <li>pozi\u021bia \\(3\\): cifra este \\(0\\), se adun\u0103 \\(0\\) la num\u0103rul \u00een baza \\(10\\).</li> <li>pozi\u021bia \\(4\\): cifra este \\(1\\), se adun\u0103 \\(2^4\\) la num\u0103rul \u00een baza \\(10\\).</li> </ul> <p>Adunate, aceste puteri ne vor da \\(22\\), acesta fiind num\u0103rul in baza \\(10\\). </p> <p>Mai jos pute\u021bi g\u0103si o scurt\u0103 implementare \u00een limbajul C++.</p> <pre><code>int n, k; // transformam n in baza 10, vom presupune ca se da numarul n drept un numar zecimal dar cu cifre mai mici decat k\ncin &gt;&gt; n &gt;&gt; k;\nint nrcif = 0, v[32]; // cifrele in baza k\n\n// obtinem cifrele, una cate una\nwhile (n &gt; 0) {\n    int c = n%10;\n    nrcif++;\n    v[nrcif] = c;\n    n /= k;\n}\n\n// pentru a le afisa, le vom afisa invers\nint putere = 1;\nint zecimal = 0; // numarul convertit in baza 10\nfor (int i = 1; i &lt;= nrcif; i++) {\n    zecimal += putere * v[i]; // adunam cifra inmultita cu puterea lui k\n    putere *= k; // la fiecare pas, crestem exponentul cu 1, inmultind cu k\n}\ncout &lt;&lt; zecimal &lt;&lt; '\\n';\n</code></pre>","tags":["biti","matematica"]},{"location":"mediu/bitwise-ops/#operatii-pe-biti","title":"Opera\u021bii pe bi\u021bi","text":"<p>Pe l\u00e2ng\u0103 opera\u021biile specifice lucrului cu diverse baze de numera\u021bie, putem lucra cu bi\u021bi folosind opera\u021biile consacrate pe bi\u021bi, care ne vor permite s\u0103 folosim eficien\u021ba lucrului cu bi\u021bi la maxim. Pentru a efectua aceste opera\u021bii, va trebui s\u0103 \u0219tim ce operatori putem folosi. O bun\u0103 parte din cuno\u0219tinte se vor lega de sintaxa \u00eenv\u0103\u021bat\u0103 anterior, \u00een special cele referitoare la operatorii logici. </p> <p>\u00cen contextul algoritmic, putem vorbi de urm\u0103torii operatori:</p>","tags":["biti","matematica"]},{"location":"mediu/bitwise-ops/#operatorul-and-si-pe-biti","title":"Operatorul AND (\"\u0219i\" pe bi\u021bi)","text":"<p>Acest operator ia drept parametri dou\u0103 numere \\(a\\) \u0219i \\(b\\) \u0219i calculeaz\u0103 pentru fiecare bit rezultatul opera\u021biei logice AND. Cu alte cuvinte, pentru o pozi\u021bie \\(i\\), dac\u0103 ambii bi\u021bi de pe pozi\u021bia \\(i\\) din \\(a\\) \u0219i \\(b\\) sunt egali cu \\(1\\), opera\u021bia AND va returna \\(1\\) pentru acea pozi\u021bie. Altfel, va returna \\(0\\). Mai jos pute\u021bi g\u0103si un tabel de adev\u0103r a acestei opera\u021bii, notat\u0103 \u00een limbajele C/C++ cu <code>&amp;</code>:</p> &amp; \\(0\\) \\(1\\) \\(0\\) \\(0\\) \\(0\\) \\(1\\) \\(0\\) \\(1\\) <p>Exemplu</p> <p>De exemplu, dac\u0103 aplic\u0103m opera\u021bia pentru \\(12\\) \u0219i \\(23\\), reprezent\u0103rile lor binare sunt \\(01100\\), respectiv \\(10111\\) (am pus un zero nesemnificativ \u00een fa\u021ba lui \\(12\\) pentru a ne asigura c\u0103 numerele au acela\u0219i num\u0103r de bi\u021bi), rezultatul opera\u021biei AND este \\(4\\), deoarece bitul de pe pozi\u021bia \\(2\\) este singurul bit egal cu \\(1\\) \u00een ambele numere. </p>","tags":["biti","matematica"]},{"location":"mediu/bitwise-ops/#operatorul-or-sau-pe-biti","title":"Operatorul OR (\"sau\" pe bi\u021bi)","text":"<p>Acest operator ia drept parametri dou\u0103 numere \\(a\\) \u0219i \\(b\\) \u0219i calculeaz\u0103 pentru fiecare bit rezultatul opera\u021biei logice OR. Cu alte cuvinte, pentru o pozi\u021bie \\(i\\), dac\u0103 cel pu\u021bin unul din bi\u021bii de pe pozi\u021bia \\(i\\) din \\(a\\) \u0219i \\(b\\) sunt egali cu \\(1\\), opera\u021bia OR va returna \\(1\\) pentru acea pozi\u021bie. Altfel, va returna \\(0\\). Mai jos pute\u021bi g\u0103si un tabel de adev\u0103r a acestei opera\u021bii, notat\u0103 \u00een limbajele C/C++ cu <code>|</code>:</p> | \\(0\\) \\(1\\) \\(0\\) \\(0\\) \\(1\\) \\(1\\) \\(1\\) \\(1\\) <p>Exemplu</p> <p>De exemplu, dac\u0103 aplic\u0103m opera\u021bia pentru \\(12\\) \u0219i \\(19\\), reprezent\u0103rile lor binare sunt \\(01100\\), respectiv \\(10011\\) (am pus un zero nesemnificativ \u00een fa\u021ba lui \\(12\\) pentru a ne asigura c\u0103 numerele au acela\u0219i num\u0103r de bi\u021bi), rezultatul opera\u021biei OR este \\(27\\), deoarece fiecare din cei \\(5\\) bi\u021bi apare \u00een m\u0103car unul din numerele date, cu excep\u021bia bitului \\(2\\).  </p>","tags":["biti","matematica"]},{"location":"mediu/bitwise-ops/#operatorul-xor-sau-exclusiv-pe-biti","title":"Operatorul XOR (\"sau exclusiv\" pe bi\u021bi)","text":"<p>Acest operator ia drept parametri dou\u0103 numere \\(a\\) \u0219i \\(b\\) \u0219i calculeaz\u0103 pentru fiecare bit rezultatul opera\u021biei logice XOR. Cu alte cuvinte, pentru o pozi\u021bie \\(i\\), dac\u0103 exact unul din bi\u021bii de pe pozi\u021bia \\(i\\) din \\(a\\) \u0219i \\(b\\) sunt egali cu \\(1\\), opera\u021bia XOR va returna \\(1\\) pentru acea pozi\u021bie. Altfel, va returna \\(0\\). Mai jos pute\u021bi g\u0103si un tabel de adev\u0103r a acestei opera\u021bii, notat\u0103 \u00een limbajele C/C++ cu <code>^</code>:</p> ^ \\(0\\) \\(1\\) \\(0\\) \\(0\\) \\(1\\) \\(1\\) \\(1\\) \\(0\\) <p>Exemplu</p> <p>De exemplu, dac\u0103 aplic\u0103m opera\u021bia pentru \\(12\\) \u0219i \\(22\\), reprezent\u0103rile lor binare sunt \\(01100\\), respectiv \\(10110\\) (am pus un zero nesemnificativ \u00een fa\u021ba lui \\(12\\) pentru a ne asigura c\u0103 numerele au acela\u0219i num\u0103r de bi\u021bi), rezultatul opera\u021biei XOR este \\(26\\), deoarece bitul de pe pozi\u021bia \\(2\\) este singurul bit egal cu \\(1\\) \u00een ambele numere, iar ceilal\u021bi bi\u021bi apar o singur\u0103 dat\u0103, cu excep\u021bia bitului \\(0\\), care nu este fixat \u00een niciunul dintre numere. </p>","tags":["biti","matematica"]},{"location":"mediu/bitwise-ops/#shiftarea-pe-biti","title":"Shiftarea pe bi\u021bi","text":"<p>Un alt operator care este folosit \u00een foarte multe contexte este shiftarea pe bi\u021bi, at\u00e2t la st\u00e2nga, c\u00e2t \u0219i la dreapta. Operatorul este folosit atunci c\u00e2nd vrem s\u0103 \u00eenmul\u021bim sau s\u0103 \u00eemp\u0103r\u021bim un num\u0103r cu o putere a lui \\(2\\), lucru ce ne poate fi foarte folositor atunci c\u00e2nd vrem s\u0103 afl\u0103m valoarea unui bit anume, s\u0103 ini\u021bializ\u0103m o valoare minim\u0103 sau maxim\u0103, precum \u0219i \u00een multe alte cazuri similare. </p> <p>Shiftarea la st\u00e2nga, notat\u0103 cu <code>&lt;&lt;</code> este folosit\u0103 atunci c\u00e2nd vrem s\u0103 \u00eenmul\u021bim un num\u0103r cu o putere a lui \\(2\\). Modul de folosire al acestui operator este <code>a&lt;&lt;b</code>, care are semnifica\u021bia c\u0103 \u00eenmul\u021bim \\(a\\) cu \\(2^b\\). </p> <p>Observa\u021bie</p> <p>\u00cen mod particular, <code>1&lt;&lt;x</code> ne va returna \u00een timp constant \\(2^x\\), iar pentru puterile lui \\(2\\) mai mari de \\(30\\), se impune folosirea nota\u021biei <code>1LL&lt;&lt;x</code>, pentru a ne asigura c\u0103 lucr\u0103m \u00een spa\u021biul numerelor din tipul de date long long. </p> <p>Shiftarea la dreapta, notat\u0103 cu <code>&gt;&gt;</code> este folosit\u0103 atunci c\u00e2nd vrem s\u0103 \u00eemp\u0103r\u021bim un num\u0103r cu o putere a lui \\(2\\). Modul de folosire al acestui operator este <code>a&gt;&gt;b</code>, care are semnifica\u021bia c\u0103 \u00eemp\u0103r\u021bim \\(a\\) cu \\(2^b\\). </p>","tags":["biti","matematica"]},{"location":"mediu/bitwise-ops/#proprietati-aplicatii-si-legaturi-intre-operatii-pe-biti","title":"Propriet\u0103\u021bi, aplica\u021bii \u0219i leg\u0103turi \u00eentre opera\u021bii pe bi\u021bi","text":"<p>Atunci c\u00e2nd vine vorba de opera\u021bii pe bi\u021bi, exist\u0103 diverse leg\u0103turi, propriet\u0103\u021bi \u0219i trucuri pe care le putem folosi pentru a ajunge s\u0103 rezolv\u0103m mai u\u0219or anumite probleme. Aici voi men\u021biona cele mai frecvent \u00eent\u00e2lnite asemenea propriet\u0103\u021bi, preciz\u00e2nd pentru fiecare dintre ele utilitatea ei. </p> <p>Observa\u021bie</p> <p>\u00cenainte de toate, vrem s\u0103 reamintim faptul c\u0103 \\(2^i &gt; \\sum_{x=0}^{i-1} 2^x\\), deci cu alte cuvinte, dac\u0103 vom avea de f\u0103cut o alegere \u00eentre o putere a lui \\(2\\) \u0219i unele puteri mai mici ale lui \\(2\\), alegerea unei puteri mai mari ne va garanta un r\u0103spuns optim, chiar dac\u0103 am putea alege ulterior o serie de puteri ale lui \\(2\\).</p> <p>Observa\u021bie</p> <p>Un alt aspect important, care va fi folosit \u00een majoritatea problemelor ce \u021bin de opera\u021bii pe bi\u021bi este acela c\u0103 putem trata bi\u021bii de pe pozi\u021bii diferite \u00een mod independent, f\u0103r\u0103 a afecta corectitudinea solu\u021biei g\u0103site. </p> <p>Leg\u0103tura dintre suma numerelor, AND \u0219i XOR</p> <p>Pentru oricare dou\u0103 valori \\(a\\) \u0219i \\(b\\) mai mari sau egale cu \\(0\\), \\(a + b = 2 \\cdot (a \\&amp; b) + (a \\oplus b)\\).</p> <p>Aceast\u0103 proprietate se poate demonstra u\u0219or folosind independen\u021ba bi\u021bilor \u0219i evalu\u00e2nd expresia pentru toate modurile \u00een care putem asigna valori bi\u021bilor.</p> <p>Mici verific\u0103ri cu impact major</p> <ul> <li>Pentru a verifica dac\u0103 \\(n\\) este o putere a lui \\(2\\), este \u00eendeajuns s\u0103 verific\u0103m valoarea expresiei \\(n \\ \\&amp; \\ (n-1)\\). Dac\u0103 aceasta este \\(0\\), \u00eenseamn\u0103 c\u0103 \\(n\\) \u0219i \\(n-1\\) nu au bi\u021bi \u00een comun, iar singurul caz \u00een care acest lucru se poate \u00eent\u00e2mpla este dac\u0103 \\(n\\) este putere a lui \\(2\\) (reprezentarea binar\u0103 a lui \\(n\\) ar fi \\(100 \\dots 0\\), iar cea a lui \\(n-1\\) ar fi \\(011 \\dots 1\\).)</li> <li>Pentru a verifica dac\u0103 pentru o valoare \\(n\\), bitul de pe pozi\u021bia \\(x\\) este setat, este \u00eendeajuns s\u0103 afl\u0103m dac\u0103 rezultatul expresiei \\((n \\ \\&amp; \\ (1&lt;&lt;x)) \\neq 0\\). Deoarece \\(2^x\\) este o putere a lui \\(2\\), singurul mod \u00een care expresia ar fi nenul\u0103 este c\u00e2nd bitul de pe pozi\u021bia \\(x\\) este setat \u00een \\(n\\).</li> <li>Pentru a afla valoarea celui mai nesemnificativ bit, este \u00eendeajuns s\u0103 folosim opera\u021bia \\(x \\ \\&amp; \\ (-x)\\), motivul pentru care aceast\u0103 opera\u021bie func\u021bioneaz\u0103 este acela c\u0103 \u00een cazul lui \\(-x\\), bi\u021bii vor fi inversa\u021bi, cu excep\u021bia ultimului bit, care va r\u0103m\u00e2ne la fel, datorit\u0103 modului \u00een care sunt dispuse \u00een memorie numerele negative (bitul de semn va fi mereu setat \u00een cazul lor).</li> </ul>","tags":["biti","matematica"]},{"location":"mediu/bitwise-ops/#lucrul-cu-submultimi","title":"Lucrul cu submul\u021bimi","text":"<p>A\u0219a cum ve\u021bi vedea \u00een detaliu dac\u0103 ve\u021bi citi articolul specific combinatoricii, lucrul cu submul\u021bimi va reprezenta o aplica\u021bie important\u0103 a lucrului cu bi\u021bi, cele \\(2^n\\) submul\u021bimi ale unei mul\u021bimi cu dimensiunea \\(n\\) put\u00e2nd fi toate codificate folosind c\u00e2te un num\u0103r \u00een intervalul \\([0, 2^n - 1]\\).</p> <p>Pentru mai multe detalii, pute\u021bi citi aici articolul nostru care prive\u0219te \u00een detaliu submul\u021bimile din perspectiva combinatoricii. Totu\u0219i, aplica\u021biile prezentate acolo se aplic\u0103 \u00een totalitate \u0219i din perspectiva articolului curent.</p> <p>Lectur\u0103 suplimentar\u0103</p> <p>Alternativ, pute\u021bi citi mai multe detalii de pe articolul de pe cp-algorithms despre enumerarea submul\u021bimilor.</p>","tags":["biti","matematica"]},{"location":"mediu/bitwise-ops/#probleme-suplimentare","title":"Probleme suplimentare","text":"<ul> <li>morse ONI 2006</li> <li>intervale RoAlgo Contest #3</li> <li>Bit Showdown RoAlgo Contest #9</li> <li>patratele OJI 2022</li> <li>Matmare RoAlgo PreOJI 2024</li> <li>Searching for Soulmates USACO</li> <li>Powered Addition</li> <li>Data Structures Fan</li> <li>castel OJI 2018</li> <li>Sheikh (Easy version)</li> <li>Three Days Ago</li> <li>Preparing Olympiad</li> <li>Petr and a Combination Lock</li> <li>CSES Xor Pyramid</li> <li>Probleme cu opera\u021bii pe bi\u021bi de pe kilonova</li> <li>Probleme cu opera\u021bii pe bi\u021bi de pe codeforces</li> </ul>","tags":["biti","matematica"]},{"location":"mediu/bitwise-ops/#lectura-suplimentara","title":"Lectur\u0103 suplimentar\u0103","text":"<ul> <li>Articol de pe USACO Guide</li> <li>Bitwise operations for beginners</li> <li>Bitwise operations for beginners, part 2</li> <li>Opera\u021bii pe bi\u021bi - Infoarena</li> <li>Opera\u021bii pe bi\u021bi - CPPI Sync</li> <li>Opera\u021bii pe bi\u021bi - Dan Pracsiu</li> <li>Bit Manipulation - cp-algorithms</li> <li>Curs lot juniori 2015</li> <li>Easy explanation about Bitwise operations [Tutorial]</li> </ul>","tags":["biti","matematica"]},{"location":"mediu/cf-atcoder/","title":"Abordarea concursurilor de pe Codeforces/AtCoder","text":"<p>Autor: \u0218tefan-Cosmin D\u0103sc\u0103lescu</p>","tags":["meta","practice","concursuri","rating"]},{"location":"mediu/cf-atcoder/#introducere","title":"Introducere","text":"<p>O platform\u0103 foarte popular\u0103 folosit\u0103 de elevii \u0219i studen\u021bii din toat\u0103 lumea pentru a se preg\u0103ti mai bine pentru olimpiadele \u0219i concursurile de informatic\u0103, dar \u0219i pentru des\u0103v\u00e2r\u0219irea cuno\u0219tin\u021belor \u00een materie de algoritmi \u0219i structuri de date, precum \u0219i pentru a-\u0219i \u00eembun\u0103t\u0103\u021bi abilit\u0103\u021bile de rezolvare a problemelor este Codeforces. O alt\u0103 platform\u0103 similar\u0103 este AtCoder, cu un format similar al concursurilor, dar ne vom concentra pe Codeforces \u00een explica\u021biile ce urmeaz\u0103. </p> <p>De\u0219i concursurile de pe Codeforces sunt diferite ca format fa\u021b\u0103 de olimpiade (de regul\u0103, 5-7 probleme \u00een 2-3 ore, de regul\u0103 ordonate cresc\u0103tor \u00een func\u021bie de dificultate), problemele de pe acest site sunt foarte apreciate \u0219i recomandate de sute de mii de utilizatori la nivel global, fiind cea mai mare platform\u0103 de acest fel la nivel mondial. Problemele sunt disponibile \u00een englez\u0103 \u0219i rus\u0103.</p> <p>Aceast\u0103 platform\u0103 este una pe care o recomand\u0103m mai ales dup\u0103 ce ave\u021bi oarecare experien\u021b\u0103 cu problemele de pe Pbinfo \u0219i cele mai simple date la concursurile rom\u00e2ne\u0219ti de informatic\u0103, pentru o provocare \u00een plus \u0219i pentru a \u00eenv\u0103\u021ba lucruri noi.</p>","tags":["meta","practice","concursuri","rating"]},{"location":"mediu/cf-atcoder/#formatul-problemelor","title":"Formatul problemelor","text":"<p>Problemele sunt algoritmice, nivelul acestora este unul foarte variat, \u00eencep\u00e2nd de la aplica\u021bii foarte simple, similare cu nivelul problemelor de pe siteuri precum Pbinfo \u0219i termin\u00e2nd cu probleme foarte dificile, uneori nerezolvate \u00een timpul concursurilor. De regul\u0103, problemele A de la rundele de Div. 3 \u0219i Div. 4 sunt cele mai u\u0219oare, unele din cele mai dificile probleme fiind problemele de la rundele de Div. 1, literele E-F sunt cele mai dificile, sau echivalentul lor, problemele G, H sau I de la rundele Div. 1 + Div. 2. </p> <p>De\u0219i sunt peste \\(10 \\ 000\\) de probleme pe Codeforces, o bun\u0103 parte dintre ele se vor dovedi a nu fi foarte relevante pentru contextul fiec\u0103rui cititor al acestei arhive, din cauza dificult\u0103\u021bii prea sc\u0103zute/ridicate a acestora sau din cauza faptului c\u0103 stilul problemelor nu se mai reg\u0103se\u0219te la fel de mult \u00een problemele care se dau \u00een prezent pe Codeforcees.</p> <p>Spre deosebire de problemele cu care sunte\u021bi obi\u0219nui\u021bi de la olimpiade sau de pe Pbinfo, verdictele care pot ap\u0103rea pe Codeforces sunt diferite. Cele mai frecvent \u00eent\u00e2lnite sunt acestea: </p> <ul> <li>Accepted: A\u021bi rezolvat problema corect, echivalent punctajului de \\(100\\) de puncte de la olimpiade. \u00cen timpul concursului pute\u021bi g\u0103si verdictul Pretests passed, similar \u00een scop cu Accepted. </li> <li>Wrong answer on test x: A\u021bi rezolvat corect problema pentru primele \\(x-1\\) teste, dar la testul \\(x\\), r\u0103spunsul este gre\u0219it. </li> <li>Time limit exceeded on test \\(x\\): A\u021bi rezolvat corect problema pentru primele \\(x-1\\) teste, dar la testul \\(x\\), solu\u021bia dep\u0103\u0219e\u0219te timpul de execu\u021bie alocat pentru problem\u0103 (de regul\u0103, 1-2 secunde).</li> <li>Memory limit exceeded on test \\(x\\): A\u021bi rezolvat corect problema pentru primele \\(x-1\\) teste, dar la testul \\(x\\), solu\u021bia dep\u0103\u0219e\u0219te memoria alocat\u0103 pentru problem\u0103 (de regul\u0103, 256 MB). </li> <li>Idleness limit exceeded on test \\(x\\): \u00cen cazul problemelor interactive, a\u021bi rezolvat corect problema pentru primele \\(x-1\\) teste, dar la testul \\(x\\), solu\u021bia nu se opre\u0219te din rulat.  </li> </ul> <p>Observa\u021bie</p> <p>\u00cen preajma anului nou, \u00een spirit de s\u0103rb\u0103toare, verdictul Accepted este \u00eenlocuit cu Happy New Year!</p>","tags":["meta","practice","concursuri","rating"]},{"location":"mediu/cf-atcoder/#competitiile-si-sistemul-de-rating","title":"Competi\u021biile \u0219i sistemul de rating","text":"","tags":["meta","practice","concursuri","rating"]},{"location":"mediu/cf-atcoder/#diviziile-si-ratingurile-de-pe-codeforces","title":"Diviziile \u0219i ratingurile de pe Codeforces","text":"<p>\u00cen func\u021bie de nivelul dovedit la concursurile de pe Codeforces, nivel m\u0103surat prin rating, concuren\u021bii pot avea urm\u0103toarele culori \u0219i titluri:</p> Titlu Culoare Rating Divizie Newbie \u25a0 0-1199 4, 3, 2 Pupil \u25a0 1200-1399 4, 3, 2 Specialist \u25a0 1400-1599 3, 2 Expert \u25a0 1600-1899 2 Candidate Master \u25a0 1900-2099 2, 1 Master \u25a0 2100-2299 1 International Master \u25a0 2300-2399 1 Grandmaster \u25a0 2400-2599 1 International Grandmaster \u25a0 2600-2999 1 Legendary Grandmaster \u25a0 \u25a0 3000+ 1 <p>Observa\u021bie</p> <p>Un singur rom\u00e2n a atins rankul de legendary grandmaster, Costin Andrei Oncescu, acesta particip\u00e2nd \u0219i de 3 ori la IOI.</p> <p>Server interna\u021bional pentru cei cu rating 1900+</p> <p>Exist\u0103 un server neoficial de Discord care cuprinde cea mai mare comunitate de utilizatori care sunt \u00een Div. 1, AC, accesul la discu\u021bii fiind disponibil celor cu rating peste \\(1900\\), ei fiind creatorii botului TLE, pe care \u00eel avem \u0219i noi.</p> <p>Ini\u021bial, un concurent are rating \\(0\\), dar dup\u0103 \\(6\\) concursuri \u00een care ratingul este unul provizoriu, acesta devine unul conform cu abilit\u0103\u021bile dovedite de concurent, mai multe detalli sunt aici. Sistemul prin care se acord\u0103 rating este unul de tip ELO, \u00een care se m\u0103soar\u0103 performan\u021ba fiec\u0103rui concurent comparat cu performan\u021ba medie care era a\u0219teptat\u0103 de la acesta.</p> <p>\u00cen func\u021bie de ratingul pe care un concurent \u00eel are, acesta poate participa la urm\u0103toarele tipuri de competi\u021bii \u00een mod oficial:</p> <ul> <li>Div. 4: Cele mai u\u0219oare competi\u021bii, participarea oficial\u0103 este limitat\u0103 celor cu rating sub 1400. </li> <li>Div. 3: Competi\u021bii u\u0219oare, care sunt mai grele dec\u00e2t Div. 4, participarea oficial\u0103 este limitat\u0103 celor cu rating sub 1600. </li> <li>Div. 2: Competi\u021biile standard ale Codeforces, participarea oficial\u0103 este limitat\u0103 celor cu rating sub 1900 (atunci c\u00e2nd se \u021bine \u00een paralel o rund\u0103 de Div. 1) sau 2100 (c\u00e2nd se \u021bine doar runda de Div. 2, \u00een aceast\u0103 categorie intr\u00e2nd \u0219i rundele Educational). </li> <li>Div. 1: Cele mai dificile competi\u021bii, participarea oficial\u0103 este limitat\u0103 celor cu rating cel pu\u021bin egal cu 1900. </li> <li>Div. 1 + Div. 2: Runde speciale, care combin\u0103 problemele de la Div. 1 \u0219i Div. 2, fiind deschise tuturor concuren\u021bilor.</li> </ul> <p>Pentru a \u021bi se schimba ratingul dup\u0103 o competi\u021bie, va trebui s\u0103 participi oficial, iar dac\u0103 performezi mai bine dec\u00e2t ratingul t\u0103u ar indica, acesta va cre\u0219te. \u00cen caz contrar, acesta va sc\u0103dea. Cu c\u00e2t ratingul este mai mare, cu at\u00e2t trebuie s\u0103 ai rezultate mai bune pentru a le p\u0103stra, iar competi\u021biile mai slabe pot cauza o sc\u0103dere mai accentuat\u0103 a ratingului.</p> <p>Aten\u021bie</p> <p>Nu vei ob\u021bine mereu un rating mai mare dec\u00e2t ai avut la o rund\u0103 anterioar\u0103, dar asta este ceva ce nu trebuie s\u0103 te demoralizeze, deoarece e o parte normal\u0103 din via\u021ba fiec\u0103rui competitor. Ce po\u021bi face \u00een schimb este s\u0103 \u00eenve\u021bi din gre\u0219eli \u0219i la competi\u021biile viitoare, s\u0103 \u00eencerci s\u0103 le evi\u021bi. Mai multe detalii ulterior \u00een articol. </p> <p>Exist\u0103 \u0219i alte competi\u021bii pe Codeforces, precum Kotlin Heroes, runde de ICPC \u0219i multe alte competi\u021bii neoficiale, dar ne vom rezuma la competi\u021biile oficiale. </p>","tags":["meta","practice","concursuri","rating"]},{"location":"mediu/cf-atcoder/#tipurile-competitiilor","title":"Tipurile competi\u021biilor","text":"<p>Competi\u021biile de pe Codeforces sunt de dou\u0103 tipuri, dup\u0103 cum urmeaz\u0103:</p> <ol> <li>Runde \u00een care fiecare problem\u0103 are un punctaj diferit, tot mai mare \u00een func\u021bie de nivelul de dificultate al problemei (Aici se \u00eencadreaz\u0103 rundele de Div. 1, Div. 2 \u0219i Div. 1 + Div. 2), iar \u00een func\u021bie de timpul necesar pentru rezolvarea problemei \u0219i num\u0103rul de submisii gre\u0219ite, punctajul ob\u021binut pentru fiecare problem\u0103 scade. </li> <li>Runde \u00een care fiecare problem\u0103 are acela\u0219i punctaj, iar \u00een func\u021bie de timpul necesar pentru rezolvarea problemei \u0219i num\u0103rul de submisii gre\u0219ite, penalizarea ob\u021binut\u0103 cre\u0219te (Aici se \u00eencadreaz\u0103 rundele educa\u021bionale, rundele Div. 3 \u0219i rundele Div. 4).</li> </ol> <p>Observa\u021bie</p> <p>Indiferent de tipul rundei, se recomand\u0103 rezolvarea problemelor \u00een ordine, \u00eencep\u00e2nd de la prima problem\u0103. Uneori, dac\u0103 apar dificult\u0103\u021bi la rezolvarea problemei curente, se recomand\u0103 citirea urm\u0103toarei probleme pentru a avea o \u0219ans\u0103 la ob\u021binerea unor puncte \u00een plus.</p> <p>De regul\u0103, competi\u021biile dureaz\u0103 \u00eentre \\(120\\) \u0219i \\(150\\) minute (\\(2\\) ore - \\(2.5\\) ore), rareori dur\u00e2nd \\(180\\) minute \u00een cazul unor runde mai dificile \u0219i \u00eencep vara \u00een jurul orei 17:35 sau iarna \u00een jurul 16:35, cu mici excep\u021bii.</p> <p>\u00cen cazul rundelor men\u021bionate \u00een prima categorie, solu\u021biile vor fi testate doar pe o parte din testele finale ale problemei (preteste), iar verdictul de Accepted va fi \u00eenlocuit \u00een timpul rundei cu verdictul Pretests passed. </p> <p>\u00cen cadrul rundelor men\u021bionate \u00een cea de-a doua categorie, exist\u0103 o sec\u021biune dup\u0103 concurs de \\(12\\) ore, \u00een care orice test care este folosit pentru a da hack la o solu\u021bie care ob\u021binuse Accepted \u00een timpul concursului va fi folosit pentru a evalua toate celelalte solu\u021bii, la finalul acestei etape. </p> <p>Indiferent de rund\u0103, are loc o sec\u021biune \u00een care toate testele preg\u0103tite de autori sunt folosite pentru a evalua solu\u021biile, cele care iau Accepted dup\u0103 aceast\u0103 sec\u021biune sunt cele care vor conta la scorul fiec\u0103rui concurent. </p> <p>Cu c\u00e2teva zile \u00eenainte de \u00eenceputul fiec\u0103rei runde, autorii vor anun\u021ba competi\u021bia, anun\u021b care va ap\u0103rea pe prima pagin\u0103 a Codeforces. La finalul competi\u021biei, autorii vor publica solu\u021biile problemelor folosind un alt blog, care va fi ad\u0103ugat la anun\u021bul concursului.</p>","tags":["meta","practice","concursuri","rating"]},{"location":"mediu/cf-atcoder/#stilul-problemelor-de-pe-codeforces","title":"Stilul problemelor de pe Codeforces","text":"<p>De\u0219i problemele care apar pe Codeforces cuprind no\u021biuni din toat\u0103 programarea competitiv\u0103, inclusiv no\u021biuni care nu apar la olimpiadele de informatic\u0103 sau \u00een general, la concursuri, se pot observa cu prec\u0103dere preferin\u021be care trebuie avute \u00een vedere pentru a maximiza performan\u021bele la concursuri. </p>","tags":["meta","practice","concursuri","rating"]},{"location":"mediu/cf-atcoder/#problemele-ad-hoc","title":"Problemele ad-hoc","text":"<p>Foarte multe probleme, mai ales cele date \u00een prima parte a rundelor, nu necesit\u0103 un algoritm sau vreo metod\u0103 de programare pentru a rezolva problema, fiind \u00eendeajuns doar observa\u021bii de baz\u0103 \u0219i observarea unor rela\u021bii matematice simple, majoritatea acestor probleme fiind fie probleme matematice, fie probleme care se bazeaz\u0103 pe observa\u021bii Greedy foarte simple sau construc\u021bii elementare. </p> <p>De\u0219i aceste teme se reg\u0103sesc \u0219i ulterior \u00een competi\u021bii, ele apar foarte mult mai ales \u00een primele probleme din runde, spre deosebire de olimpiadele din Rom\u00e2nia \u0219i alte \u021b\u0103ri, unde problemele tind s\u0103 fie mai algoritmice \u0219i tehnice. </p>","tags":["meta","practice","concursuri","rating"]},{"location":"mediu/cf-atcoder/#implementari-simple-si-clare","title":"Implement\u0103ri simple \u0219i clare","text":"<p>De\u0219i acest lucru este important indiferent de problema pe care vre\u021bi s\u0103 o rezolva\u021bi, se poate observa faptul c\u0103 multe din solu\u021biile pe care autorii le au \u00een g\u00e2nd pentru probleme, mai ales c\u00e2nd vine vorba de cele care apar la \u00eenceputul competi\u021biilor sunt foarte simple, aceasta poate fi o capcan\u0103 \u00een care mul\u021bi concuren\u021bi cad, \u00eencerc\u00e2nd s\u0103 aib\u0103 solu\u021bii mai complicate dec\u00e2t trebuie, fie c\u0103 e vorba de implement\u0103ri care sunt prea lungi sau abord\u0103ri mai eficiente dec\u00e2t trebuie. </p>","tags":["meta","practice","concursuri","rating"]},{"location":"mediu/cf-atcoder/#tendintele-concursurilor","title":"Tendin\u021bele concursurilor","text":"<p>De-a lungul anilor, au existat diverse mode (meta-uri) \u00een ceea ce prive\u0219te tipurile de probleme care apar \u00een competi\u021bii, ceea ce necesit\u0103 o oarecare perioad\u0103 de adaptare, meta-uri care devin o necesitate pentru a introduce idei, perspective \u0219i \u00een unele cazuri, metode noi de a rezolva problemele. </p> <p>Totu\u0219i, \u00een ciuda acestui fapt, o mare parte din sfaturile de aici vor putea fi aplicate \u0219i peste mul\u021bi ani, chiar dac\u0103 stilul problemelor va fi diferit p\u00e2n\u0103 atunci.</p>","tags":["meta","practice","concursuri","rating"]},{"location":"mediu/cf-atcoder/#cum-ne-putem-antrena-pentru-codeforces","title":"Cum ne putem antrena pentru Codeforces","text":"<p>\u00cen primul r\u00e2nd, cel mai bun antrenament const\u0103 \u00een concursurile care apar pe platform\u0103, de regul\u0103 cam \\(6-10\\) pe lun\u0103. De\u0219i nu toate sunt potrivite pentru to\u021bi concuren\u021bii, exist\u0103 mereu c\u00e2teva runde \u00een fiecare lun\u0103 care merit\u0103 date. De regul\u0103, recomand\u0103m rundele de Div. 3 \u0219i Div. 4 pentru elevii sub \\(1400\\) rating, rundele de Div. 2 pot fi date dac\u0103 ai cel pu\u021bin \\(1400\\) rating \u0219i evident, rundele de Div. 1 odat\u0103 ce sunte\u021bi eligibili pentru ele. </p> <p>Concursuri virtuale - simul\u0103ri</p> <p>Chiar dac\u0103 nu ave\u021bi cum s\u0103 ajunge\u021bi la runde sau vre\u021bi s\u0103 simula\u021bi runde ce au avut loc \u00een trecut, pute\u021bi face asta folosind feature-ul Virtual Participation ce apare dac\u0103 intra\u021bi aici. </p> <p>Upsolving</p> <p>O alt\u0103 recomandare pe care o avem este ca dup\u0103 fiecare concurs pe care \u00eel da\u021bi, s\u0103 rezolva\u021bi 1-2 probleme care nu a\u021bi reu\u0219it s\u0103 le rezolva\u021bi \u00een timpul concursului, \u00eempreun\u0103 cu tot ce \u021bine de algoritmii sau tehnicile care trebuie \u0219tiute pentru rezolvarea acelor probleme. \u00cen specialitate, aceast\u0103 parte a competi\u021biilor de informatic\u0103 se nume\u0219te upsolving. </p>","tags":["meta","practice","concursuri","rating"]},{"location":"mediu/cf-atcoder/#botul-tle","title":"Botul TLE","text":"<p>Botul TLE este cel mai complet bot de Discord pe care \u00eel pute\u021bi folosi pentru a v\u0103 antrena pentru Codeforces, acesta fiind disponibil gratuit pe serverul nostru, RoAlgo. Acesta v\u0103 d\u0103 posibilitatea s\u0103 v\u0103 urm\u0103ri\u021bi progresul de pe Codeforces pe discord, s\u0103 lucra\u021bi probleme apropiate de nivelul vostru \u0219i s\u0103 v\u0103 recomande concursuri, probleme \u0219i multe alte facilit\u0103\u021bi, precum dueluri sau alte turnee. </p> <p>\u00cen timpul concursului, \u00een limita func\u021bionalit\u0103\u021bii serverelor de pe Codeforces, pute\u021bi vedea \u0219i \u00een timp real care ar fi schimbarea prev\u0103zut\u0103 a ratingului la acel moment, dar nu recomand\u0103m folosirea acestui clasament, deoarece e mult mai bine s\u0103 v\u0103 concentra\u021bi pe problemele pe care le ave\u021bi de rezolvat. </p> <p>Observa\u021bie</p> <p>\u00cen general, e bine ca \u00een timpul concursurilor s\u0103 v\u0103 concentra\u021bi strict pe ce ave\u021bi de f\u0103cut \u0219i nu pe ce rezultate au prietenii, colegii, rivalii vo\u0219tri etc. Concursurile trebuie s\u0103 le privi\u021bi mai \u00eent\u00e2i ca o lupt\u0103 cu voi \u00een\u0219i\u0219i \u0219i nu cu ceilal\u021bi din jurul vostru, pentru c\u0103 oric\u00e2nd ve\u021bi g\u0103si lucruri care trebuie \u00eembun\u0103t\u0103\u021bite. </p> <p>Dintre cele mai populare comenzi ale botului, vom enum\u0103ra urm\u0103toarele:</p> <ul> <li> <p><code>;handle identify [numele_vostru]</code> - aceast\u0103 comand\u0103 v\u0103 permite s\u0103 asocia\u021bi contul vostru de Codeforces cu baza noastr\u0103 de date, dup\u0103 ce trimite\u021bi o surs\u0103 care d\u0103 eroare de compilare la problema care vi se asigneaz\u0103.</p> </li> <li> <p><code>;gitgud</code> - aceast\u0103 comand\u0103 v\u0103 permite s\u0103 rezolva\u021bi o problem\u0103 cu un rating egal cu ratingul vostru, dac\u0103 o rezolva\u021bi pute\u021bi scrie <code>;gotgud</code> \u0219i primi\u021bi puncte \u00een clasamentul lunar pe care \u00eel avem pe server. Singura particularitate este c\u0103 dac\u0103 nu vre\u021bi s\u0103 rezolva\u021bi o anumit\u0103 problem\u0103, trebuie s\u0103 a\u0219tepta\u021bi dou\u0103 ore p\u00e2n\u0103 c\u00e2nd ve\u021bi folosi comanda din nou. </p> </li> </ul> <p>Observa\u021bie</p> <p>Dac\u0103 vre\u021bi s\u0103 rezolva\u021bi probleme mai grele sau mai u\u0219oare, pute\u021bi scrie <code>;gitgud x</code>, unde \\(x\\) este un multiplu de \\(100\\) reprezent\u00e2nd diferen\u021ba fa\u021b\u0103 de ratingul vostru curent. De asemenea, pute\u021bi vedea toate variantele de a folosi aceast\u0103 comand\u0103 pe server.</p> <ul> <li> <p><code>;gimme</code> - aceast\u0103 comand\u0103 v\u0103 permite s\u0103 rezolva\u021bi o problem\u0103 cu un rating egal cu ratingul vostru, f\u0103r\u0103 a fi constr\u00e2n\u0219i de condi\u021biile specifice comenzii gitgud. Din nou, ave\u021bi multe variante \u0219i moduri de a folosi aceast\u0103 comand\u0103. </p> </li> <li> <p><code>;duel</code> - Aceast\u0103 categorie de comenzi permite dueluri \u00eentre doi sau mai mul\u021bi membri de pe server care au contul asociat cu baza noastr\u0103 de date, sub diferite condi\u021bii. </p> </li> <li> <p><code>;plot comanda</code> - Aceast\u0103 categorie de comenzi permite vizionarea diverselor grafice care se ocup\u0103 de prelucrarea datelor statistice din concursuri \u0219i datele concuren\u021bilor, inclusiv \u00een ceea ce prive\u0219te partea de exersare a problemelor. </p> </li> <li> <p><code>;help</code> - Aceast\u0103 comand\u0103 arat\u0103 toate modurile de a folosi botul nostru, \u00eencep\u00e2nd de la cele descrise aici \u0219i termin\u00e2nd cu multe alte comenzi care arat\u0103 date statistice, sugestii pentru probleme dar \u0219i grafice care arat\u0103 evolu\u021bia ratingului, a performan\u021belor \u0219i multe altele.</p> </li> </ul>","tags":["meta","practice","concursuri","rating"]},{"location":"mediu/cf-atcoder/#ce-trebuie-evitat","title":"Ce trebuie evitat?","text":"<p>\u00cen primul r\u00e2nd, tri\u0219atul la aceste competi\u021bii nu este permis \u00een nicio form\u0103 \u0219i cu niciun scop, acesta v\u0103 poate cauza conturile s\u0103 fie excluse din concursuri sau de pe site, precum \u0219i pierderea reputa\u021biei voastre ca concuren\u021bi \u0219i \u00een func\u021bie de gravitatea situa\u021biei, se poate ajunge la pedepse pe server. </p> <p>Tri\u0219atul const\u0103 fie \u00een discutarea problemelor cu al\u021bi concuren\u021bi \u00een timpul rundei sau copierea de solu\u021bii, \u00een mod voit sau nevoit, inclusiv dac\u0103 discuta\u021bi idei, da\u021bi spoilere sau alte asemenea \u00een timpul concursului.</p> <p>Observa\u021bie</p> <p>Totu\u0219i, dac\u0103 g\u0103si\u021bi o problem\u0103 similar\u0103 cu cea din concurs care s-a dat anterior \u0219i modifica\u021bi solu\u021bia acelei probleme, nu constituie fraud\u0103. </p>","tags":["meta","practice","concursuri","rating"]},{"location":"mediu/cf-atcoder/#greseli-comune-in-timpul-rundelor","title":"Gre\u0219eli comune \u00een timpul rundelor","text":"<p>O eroare frecvent f\u0103cut\u0103 \u00een timpul concursurilor const\u0103 \u00een folosirea unor instruc\u021biuni precum memset pe vectorii statici (reseteaz\u0103 memoria de fiecare dat\u0103, iar \u00een cazul Codeforces, unde problemele sunt de obicei multi-test, poate cauza limit\u0103 de timp dep\u0103\u0219it\u0103 c\u00e2nd num\u0103rul de teste este mare).</p> <p>O alt\u0103 eroare frecvent exploatat\u0103 de hackeri const\u0103 \u00een folosirea unor structuri de date precum unordered_map, din cauza coliziunilor ce pot avea loc ca urmare a faptului c\u0103 toate valorile ar folosi acela\u0219i hash. </p> <p>Este de asemenea foarte important s\u0103 evita\u021bi submisiile date la grab\u0103 sau care au ca scop doar ca s\u0103 testeze evitarea unor anumite verdicte, ideal este s\u0103 trimite\u021bi solu\u021bii care au o \u0219ans\u0103 s\u0103 ia Accepted (pe scurt, nu are niciun sens s\u0103 trimite\u021bi un brut neoptimizat, cel mai probabil lua\u021bi Time Limit Exceeded).</p> <p>\u00cen general, este bine s\u0103 ave\u021bi codul foarte bine organizat pentru a evita erori subtile sau de implementare. De asemenea, testele sunt mult mai puternice, deci posibilele abord\u0103ri care exploateaz\u0103 testele slabe au \u0219anse mult mai mici de succes pe Codeforces.</p>","tags":["meta","practice","concursuri","rating"]},{"location":"mediu/cf-atcoder/#conturi-multiple","title":"Conturi multiple","text":"<p>Folosirea de conturi multiple \u00een timpul concursurilor este strict interzis\u0103, la fel ca \u0219i folosirea activ\u0103 a mai multor conturi \u00een acela\u0219i timp. </p> <p>Totu\u0219i, \u00een unele situa\u021bii, aceast\u0103 practic\u0103 este acceptat\u0103 tacit de comunitate, foarte mul\u021bi utilizatori av\u00e2nd aceste conturi multiple pentru diverse scopuri, printre care \u00eencerc\u0103ri de a c\u00e2\u0219tiga runde sau de a ob\u021bine mai mult\u0103 \u00eencredere \u00een sine, condi\u021bia fiind aceea de a folosi un singur cont \u00een fiecare rund\u0103. </p>","tags":["meta","practice","concursuri","rating"]},{"location":"mediu/cf-atcoder/#concluzii","title":"Concluzii","text":"<p>Codeforces este o platform\u0103 foarte important\u0103 pentru programarea competitiv\u0103, fiind practic cea mai mare comunitate de acest fel la nivel mondial. Zecile de concursuri ce au loc \u00een fiecare an, \u00eempreun\u0103 cu blogurile care sunt scrise des \u0219i care prezint\u0103 diverse tehnici, algoritmi \u0219i structuri de date prezentate \u0219i aici (ve\u021bi g\u0103si de multe ori resurse de pe Codeforces recomandate de noi) fiind esen\u021biale pentru progresul vostru ca algoritmi\u0219ti. </p> <p>Respectarea competi\u021biei este esen\u021bial\u0103 \u0219i v\u0103 va ajuta s\u0103 deveni\u021bi mai buni \u00een acest mod, iar \u00een timp, pute\u021bi folosi aceast\u0103 platform\u0103 pentru a v\u0103 completa abilit\u0103\u021bile de rezolvitori de probleme \u0219i de programatori. Chiar dac\u0103 nu poate suplini sau \u00eenlocui \u00een niciun fel lucratul pentru olimpiad\u0103, Codeforces, AtCoder \u0219i alte platforme de acest fel sunt potrivite pentru concursuri rapide, diferite ca stil care v\u0103 ajut\u0103 s\u0103 v\u0103 adapta\u021bi mai bine la provoc\u0103rile pe care le ave\u021bi. </p> <p>Mult succes la competi\u021biile de aici!</p>","tags":["meta","practice","concursuri","rating"]},{"location":"mediu/contest-list/","title":"List\u0103 de concursuri relevante","text":"<p>Autor: \u0218tefan-Cosmin D\u0103sc\u0103lescu</p> <p>Pe l\u00e2ng\u0103 olimpiada de informatic\u0103, prezentat\u0103 mai devreme \u00een acest articol, exist\u0103 numeroase concursuri \u0219i olimpiade pentru elevii de gimnaziu, liceu \u0219i chiar \u0219i pentru studen\u021bi. Nu \u00een ultimul r\u00e2nd, exist\u0103 numeroase platforme cu concursuri online cu diverse reguli care permit oric\u0103rui entuziast de algoritmic\u0103 s\u0103 se men\u021bin\u0103 \u00een form\u0103 \u0219i de ce nu, s\u0103 devin\u0103 tot mai bun. </p> <p>Aceasta nu este o list\u0103 complet\u0103 a concursurilor, iar de multe ori apar concursuri ce nu sunt neap\u0103rat organizate \u00eentr-un mod regular, a\u0219a c\u0103 recomand\u0103m s\u0103 fi\u021bi pe faz\u0103 pe serverul nostru RoAlgo.</p>","tags":["concursuri","pregatire","olimpiada"]},{"location":"mediu/contest-list/#concursuri-romanesti","title":"Concursuri rom\u00e2ne\u0219ti","text":"<p>\u00cen primul r\u00e2nd, \u021bara noastr\u0103 organizeaz\u0103 o gam\u0103 larg\u0103 de concursuri care au loc \u00een prezent, continu\u00e2nd o tradi\u021bie \u00eendelungat\u0103 a concursurilor de acest fel. Aici voi enumera cele mai importante concursuri, precum \u0219i c\u00e2nd au loc. </p> <p>Multe dintre aceste concursuri, pe l\u00e2ng\u0103 faptul c\u0103 reprezint\u0103 o oportunitate \u00een plus de a te preg\u0103ti pentru olimpiad\u0103, au \u0219i premii generoase \u0219i de asemenea reprezint\u0103 o metod\u0103 de a putea fi admis mai u\u0219or la universit\u0103\u021bile de profil din Rom\u00e2nia.</p> <ul> <li> <p>Olimpiada de Informatic\u0103 pe Echipe (IIOT): Are loc anual pe parcursul a \\(4\\) runde preliminare, o rund\u0103 final\u0103 \u0219i o rund\u0103 interna\u021bional\u0103, rundele preliminare av\u00e2nd loc lunar \u00een perioada noiembrie-februarie, cu finala na\u021bional\u0103 av\u00e2nd loc \u00een fiecare an la Colegiul Na\u021bional de Informatic\u0103 Piatra Neam\u021b. \u00cen prezent, este dedicat exclusiv elevilor de liceu, care pot participa \u00een echipe de \\(4\\) membri \u0219i \\(2\\) rezerve din aceea\u0219i \u0219coal\u0103/centru de excelen\u021b\u0103. Problemele din anii anteriori se g\u0103sesc aici.</p> </li> <li> <p>Concursul na\u021bional \"Urma\u0219ii lui Moisil\": Are loc \u00een fiecare an, dup\u0103 olimpiada jude\u021bean\u0103 de informatic\u0103, este dedicat elevilor de liceu \u0219i reune\u0219te cei mai buni elevi din fiecare jude\u021b, av\u00e2nd o prob\u0103 de dificultate similar\u0103 cu olimpiada na\u021bional\u0103. Problemele din anii anteriori se g\u0103sesc aici.</p> </li> <li> <p>Concursul Prosoft@NT este un concurs de algoritmic\u0103 pentru elevii de liceu care are loc \u00een fiecare an, concomitent cu runda na\u021bional\u0103 a IIOT, organizat de Colegiul Na\u021bional de Informatic\u0103 Piatra Neam\u021b. </p> </li> <li> <p>Concursul interjude\u021bean \"Grigore Moisil\": Are loc \u00een fiecare an, dup\u0103 olimpiada jude\u021bean\u0103 de informatic\u0103, este dedicat elevilor de gimnaziu \u0219i liceu \u0219i reune\u0219te elevii de top din Transilvania, Banat, Cri\u0219ana \u0219i Maramure\u0219, av\u00e2nd o prob\u0103 de dificultate similar\u0103 cu olimpiada na\u021bional\u0103. Problemele din anii anteriori se g\u0103sesc aici.</p> </li> <li> <p>Concursul interjude\u021bean \"Info Oltenia\": Are loc \u00een fiecare an, de regul\u0103 iarna, este dedicat elevilor de gimnaziu \u0219i liceu \u0219i reune\u0219te elevii de top din Oltenia, av\u00e2nd o prob\u0103 de dificultate similar\u0103 cu olimpiada jude\u021bean\u0103. Problemele din anii anteriori se g\u0103sesc aici.</p> </li> <li> <p>Concursul \"Adolescent Grigore Moisil\": Are loc \u00een fiecare an, pe parcursul a mai multor runde, este dedicat elevilor de gimnaziu \u0219i liceu \u0219i are reguli similare cu cele ale concursului ICPC (echipe de \\(3\\) persoane), dificultatea problemelor fiind ridicat\u0103, nivelul acestora fiind cuprins \u00eentre ONI \u0219i Lot Seniori. Problemele din anii anteriori se g\u0103sesc aici.</p> </li> <li> <p>Concursul ICPC \u0219i etapele regionale la care particip\u0103 universit\u0103\u021bile rom\u00e2ne\u0219ti, RCPC, SEERC \u0219i EUC: Are loc \u00een fiecare an, de regul\u0103 toamna, este dedicat studen\u021bilor \u0219i dificultatea problemelor este una ridicat\u0103, scopul final al echipelor este acela de a avansa la finala mondial\u0103, ce are loc de regul\u0103 anual. Problemele din anii anteriori se g\u0103sesc pe Codeforces, Infoarena \u0219i alte site-uri specifice ICPC.</p> </li> </ul>","tags":["concursuri","pregatire","olimpiada"]},{"location":"mediu/contest-list/#concursuri-internationale-cu-participare-romaneasca","title":"Concursuri interna\u021bionale cu participare rom\u00e2neasc\u0103","text":"<ul> <li> <p>Olimpiada Interna\u021bional\u0103 de Informatic\u0103 (IOI) este cel mai important concurs de algoritmic\u0103 pentru elevi la nivel mondial, reunind cei mai buni \\(4\\) elevi din fiecare \u021bar\u0103 participant\u0103. \u00cen 2024, au participat elevi din peste \\(90\\) de \u021b\u0103ri, Rom\u00e2nia ob\u021bin\u00e2nd o medalie de aur, dou\u0103 de argint \u0219i una de bronz. Nivelul de dificultate al problemelor este foarte ridicat, fiind menit s\u0103 testeze p\u00e2n\u0103 \u0219i cei mai buni elevi la nivel mondial. </p> </li> <li> <p>Olimpiada Europei Centrale de Informatic\u0103 (CEOI) este un concurs de algoritmic\u0103 pentru elevii \u021b\u0103rilor Europei Centrale, reunind \\(4\\) dintre cei mai buni elevi din fiecare \u021bar\u0103 participant\u0103. \u00cen 2024, au participat elevi din \\(14\\) \u021b\u0103ri, Rom\u00e2nia ob\u021bin\u00e2nd trei medalii de argint \u0219i una de bronz. Nivelul de dificultate al problemelor este ridicat, fiind menit s\u0103 testeze p\u00e2n\u0103 \u0219i cei mai buni elevi \u00een vederea IOI. </p> </li> <li> <p>Olimpiada Balcanic\u0103 de Informatic\u0103 (BOI) este un concurs de algoritmic\u0103 pentru elevii \u021b\u0103rilor din Peninsula Balcanic\u0103, reunind \\(4\\) dintre cei mai buni elevi din fiecare \u021bar\u0103 participant\u0103. \u00cen 2024, particip\u0103 elevi din \\(15\\) \u021b\u0103ri, iar Rom\u00e2nia a ob\u021binut (aici voi pune ce au ob\u021binut, concursul nu a avut loc \u00eenc\u0103). Nivelul de dificultate al problemelor este ridicat, fiind menit s\u0103 testeze p\u00e2n\u0103 \u0219i cei mai buni elevi \u00een vederea IOI. </p> </li> <li> <p>Olimpiada European\u0103 de Informatic\u0103 pentru Fete (EGOI) este un concurs de algoritmic\u0103 pentru fete la nivel european \u0219i nu numai, reunind cele mai bune eleve din fiecare \u021bar\u0103 participant\u0103. Nivelul de dificultate al problemelor este ridicat, dar sub cel al IOI. \u00cen \\(2024\\), Rom\u00e2nia a ob\u021binut dou\u0103 medalii de argint \u0219i dou\u0103 de bronz. </p> </li> <li> <p>Olimpiada European\u0103 de Informatic\u0103 pentru Juniori (EJOI) este cel mai important concurs de algoritmic\u0103 pentru juniori (elevi care au cel mult \\(15\\) ani) la nivel european, reunind cei mai buni \\(4\\) juniori din \u021b\u0103rile participante. \u00cen \\(2024\\), Rom\u00e2nia a ob\u021binut dou\u0103 medalii de aur \u0219i dou\u0103 de argint. </p> </li> <li> <p>Olimpiada Balcanic\u0103 de Informatic\u0103 pentru Juniori (JBOI) este un concurs de algoritmic\u0103 pentru juniorii \u021b\u0103rilor din Peninsula Balcanic\u0103, reunind \\(4\\) dintre cei mai buni juniori din fiecare \u021bar\u0103 participant\u0103. \u00cen \\(2024\\), Rom\u00e2nia a ob\u021binut trei medalii de aur \u0219i una de argint. </p> </li> <li> <p>Concursul Info(1)Cup este un concurs de algoritmic\u0103 pentru juniori la nivel mondial, reunind unii cei mai buni juniori din fiecare \u021bar\u0103 participant\u0103. Acest concurs este organizat \u00een fiecare an de Centrul Jude\u021bean de Excelen\u021b\u0103 Prahova. \u00cen fiecare an, Rom\u00e2nia are o participare numeroas\u0103, juniorii ob\u021bin\u00e2nd rezultate dintre cele mai bune. </p> </li> <li> <p>Turneul de Informatic\u0103 de la Shumen (IATI) este un concurs de algoritmic\u0103 pentru juniori \u0219i seniori la nivel regional, reunind unii cei mai buni elevi din fiecare \u021bar\u0103 participant\u0103. Acest concurs este organizat \u00een fiecare an \u00een Shumen, Bulgaria. \u00cen fiecare an, Rom\u00e2nia are o participare numeroas\u0103, elevii participan\u021bi ob\u021bin\u00e2nd rezultate dintre cele mai bune. </p> </li> <li> <p>Romanian Masters of Informatics (RMI) este un concurs de algoritmic\u0103 pentru juniori \u0219i seniori la nivel regional, reunind unii cei mai buni elevi din fiecare \u021bar\u0103 participant\u0103. Acest concurs este organizat \u00een fiecare an de Colegiul Na\u021bional de Informatic\u0103 \"Tudor Vianu\", Bucure\u0219ti. \u00cen fiecare an, Rom\u00e2nia are o participare numeroas\u0103, elevii participan\u021bi ob\u021bin\u00e2nd rezultate dintre cele mai bune. </p> </li> </ul>","tags":["concursuri","pregatire","olimpiada"]},{"location":"mediu/contest-list/#concursuri-online","title":"Concursuri online","text":"<p>Majoritatea platformelor cu concursuri online propun runde pe stilul ICPC, unde pentru o problem\u0103, trebuie trecute toate testele pentru a primi puncte (cu alte cuvinte, exact cum ar fi olimpiada dac\u0103 singurele punctaje posibile ar fi \\(0\\) sau \\(100\\) de puncte). Totu\u0219i, exist\u0103 \u0219i olimpiade care ofer\u0103 posibilitatea unor runde mirror dup\u0103 sau chiar \u00een timpul rundelor oficiale. </p> <ul> <li> <p>Codeforces este una din cele mai populare platforme unde au loc concursuri online de algoritmic\u0103 la nivel mondial. De regul\u0103, au loc aproximativ dou\u0103 concursuri pe s\u0103pt\u0103m\u00e2n\u0103, nivelul lor variaz\u0103 de la Div. 4 la Div. 1, \u00een ordine cresc\u0103toare a dificult\u0103\u021bii. Un concurs dureaz\u0103 \u00eentre \\(2\\) \u0219i \\(3\\) ore \u0219i are \u00eentre \\(5\\) \u0219i \\(9\\) probleme, ordonate cresc\u0103tor dup\u0103 dificultate. Pentru a deveni tot mai bun la aceste concursuri, po\u021bi folosi facilit\u0103\u021bile pe care le avem \u00een exclusivitate \u00een Rom\u00e2nia pe serverul RoAlgo, unde po\u021bi folosi botul TLE pentru a primi cele mai interesante sugestii de probleme, concursuri, dueluri \u0219i multe alte beneficii. Problemele de pe acest site tind s\u0103 fie mai ad-hoc \u00een natur\u0103, cu excep\u021bia celor de la Div. 3 \u0219i Div. 4, care sunt o surs\u0103 foarte bun\u0103 de tehnici educa\u021bionale. </p> </li> <li> <p>AtCoder este o alt\u0103 platform\u0103 popular\u0103 unde au loc concursuri online de algoritmic\u0103 la nivel mondial. De regul\u0103, se organizeaz\u0103 un concurs pe s\u0103pt\u0103m\u00e2n\u0103, nivelul lor variaz\u0103 de la ABC la AGC, \u00een ordine cresc\u0103toare a dificult\u0103\u021bii. Un concurs dureaz\u0103 \u00eentre \\(2\\) \u0219i \\(3\\) ore \u0219i are \u00eentre \\(6\\) \u0219i \\(8\\) probleme, ordonate cresc\u0103tor dup\u0103 dificultate. Problemele de pe acest site tind s\u0103 fie mai matematice \u00een natur\u0103, cu excep\u021bia celor de la ABC, care sunt o surs\u0103 foarte bun\u0103 de tehnici educa\u021bionale. </p> </li> <li> <p>Concursurile de pe Kilonova \u0219i \u00een special RoAlgo Contests sunt foarte utile pentru exersarea diverselor tehnici, organiz\u00e2ndu-se runde foarte importante precum concursurile de tip PreOJI, care sunt menite pentru a testa abilit\u0103\u021bile concuren\u021bilor \u00eenainte de Olimpiada de informatic\u0103. </p> </li> <li> <p>LeetCode este o platform\u0103 popular\u0103 unde au loc concursuri online de algoritmic\u0103 la nivel mondial, problemele fiind propuse \u00een special pe modelul celor de la interviurile de angajare. De regul\u0103, se organizeaz\u0103 un concurs pe s\u0103pt\u0103m\u00e2n\u0103, nivelul lor este unul mai sc\u0103zut, con\u021bin\u00e2nd \\(4\\) probleme ce trebuie rezolvate \u00een cel mult \\(2\\) ore, ordonate cresc\u0103tor dup\u0103 dificultate. </p> </li> <li> <p>USACO este siteul oficial al Olimpiadei de Informatic\u0103 a Statelor Unite, aceasta organiz\u00e2nd \\(4\\) concursuri \u00een fiecare an, \u00een perioada decembrie-martie. Concursurile sunt \u00eemp\u0103r\u021bite pe divizii, Bronze fiind cea mai simpl\u0103, apoi Silver, Gold \u0219i Platinum, formatul concursurilor fiind similar celor de la olimpiad\u0103. Se recomand\u0103 participarea la acest concurs pentru cei care vor s\u0103 ob\u021bin\u0103 rezultate bune la olimpiad\u0103, \u00een special datorit\u0103 flexibilit\u0103\u021bii pe care o au (fiecare concurs se poate da \u00eentr-un interval de \\(4\\) zile). </p> </li> <li> <p>COCI este siteul oficial al Olimpiadei de Informatic\u0103 a Croa\u021biei, aceasta organiz\u00e2nd \\(6-8\\) concursuri \u00een fiecare an, \u00een perioada noiembrie-aprilie. Concursurile au \\(3-4\\) ore \u0219i se recomand\u0103 participarea la acest concurs pentru cei care vor s\u0103 ob\u021bin\u0103 rezultate bune la olimpiad\u0103, problemele fiind de un nivel variat.</p> </li> <li> <p>JOI este siteul oficial al Olimpiadei de Informatic\u0103 a Japoniei, aceasta organiz\u00e2nd \\(6-8\\) concursuri \u00een fiecare an, \u00een perioada februarie-mai. Concursurile au \\(5\\) ore \u0219i se recomand\u0103 participarea la acest concurs pentru cei care vor s\u0103 ob\u021bin\u0103 rezultate bune la olimpiad\u0103, problemele fiind de un nivel ridicat, de multe ori cele mai grele probleme sunt mai grele dec\u00e2t problemele de la lotul Rom\u00e2niei de informatic\u0103.</p> </li> </ul>","tags":["concursuri","pregatire","olimpiada"]},{"location":"mediu/contest-list/#alte-concursuri","title":"Alte concursuri","text":"<p>Pentru mai multe informa\u021bii \u0219i concursuri, pute\u021bi verifica aceste liste de pe USACO Guide, precum \u0219i celelalte liste de concursuri de mai jos. Nu \u00een ultimul r\u00e2nd, pe serverul RoAlgo v\u0103 \u021binem la curent cu concursurile care apar. </p> <ul> <li>Concursuri</li> <li>Olimpiade</li> <li>Gym Codeforces - cuprinde at\u00e2t olimpiade, c\u00e2t \u0219i runde de tip ICPC.</li> <li>Clist - list\u0103 cu toate concursurile de algoritmic\u0103 posibile, totu\u0219i multe dintre ele nu sunt relevante. </li> </ul>","tags":["concursuri","pregatire","olimpiada"]},{"location":"mediu/data-normalization/","title":"Normalizarea datelor","text":"<p>Autor: \u0218tefan-Cosmin D\u0103sc\u0103lescu</p> <p>\u00cen unele probleme, suntem nevoi\u021bi s\u0103 prelucr\u0103m datele de intrare, astfel \u00eenc\u00e2t s\u0103 putem efectua opera\u021bii de actualizare \u0219i interogare ale datelor mult mai u\u0219or. O metod\u0103 foarte popular\u0103 care are drept scop compresia datelor de intrare este normalizarea datelor. Cu alte cuvinte, scopul principal al acestei metode este acela de a transforma un \u0219ir cu valori arbitrare \u00eentr-un \u0219ir cu valori mai mici.</p> <p>De regul\u0103, transform\u0103m valorile \u00eentr-un \u0219ir cu valori \u00eentre \\(1\\) \u0219i \\(n\\), \u00een care fiecare valoare va fi modificat\u0103 \u00een func\u021bie de pozi\u021bia acesteia \u00een \u0219irul sortat. De\u0219i \u00een multe cazuri, vom putea folosi \u0219i alte structuri de date, normalizarea devine \u00een multe cazuri o metod\u0103 care ne ajut\u0103 s\u0103 \u00eembun\u0103t\u0103\u021bim constanta de timp pentru multe solu\u021bii.</p>","tags":["normalizare","implementare"]},{"location":"mediu/data-normalization/#mod-de-implementare","title":"Mod de implementare","text":"<p>Cum am zis \u0219i anterior, vrem s\u0103 putem prelucra un \u0219ir dat, astfel \u00eenc\u00e2t s\u0103 afl\u0103m cu u\u0219urin\u021b\u0103 pozi\u021bia lui din \u0219irul sortat, reduc\u00e2nd astfel intervalul de valori la unul de lungime \\(n\\). </p> <p>De exemplu, dac\u0103 \u0219irul nostru este \\(v = \\{4, 9, 41, 22, 14, 7, 44 \\}\\), dup\u0103 normalizare, vrem s\u0103 ob\u021binem \\(v = \\{1, 3, 6, 5, 4, 2, 7 \\}\\). </p> <p>Observa\u021bie</p> <p>Dac\u0103 avem mai multe valori egale, nu are importan\u021b\u0103 dac\u0103 le vom atribui aceea\u0219i valoare sau valori diferite, a\u0219a cum ve\u021bi putea vedea \u00een implementarea de mai jos. </p> <p>Pentru a face asta, exist\u0103 dou\u0103 abord\u0103ri principale. Prima const\u0103 \u00een a \u021bine un \u0219ir separat cu valorile, pe care le vom sorta, iar mai apoi la fiecare opera\u021bie, dac\u0103 vrem s\u0103 afl\u0103m pozi\u021bia \u00een \u0219irul sortat pentru o valoare dat\u0103, vom folosi o c\u0103utare binar\u0103. Cea de-a doua abordare este similar\u0103, singura diferen\u021b\u0103 fiind c\u0103 \u021binem valorile \u00eentr-o structur\u0103 de tip <code>std::set</code> \u0219i dup\u0103 ce iter\u0103m prin set, facem coresponden\u021bele cu valorile \u00een timp logaritmic pentru fiecare valoare \u00eent\u00e2lnit\u0103. Mai jos pute\u021bi g\u0103si o implementare ce folose\u0219te prima metod\u0103.</p> <p>Codul de mai jos sorteaz\u0103 \u0219irul \u0219i afl\u0103 pentru fiecare valoare din \u0219irul ini\u021bial pozi\u021bia pe care s-ar afla \u00een \u0219irul normalizat. </p> <p>Observa\u021bie</p> <p>Exist\u0103 structuri de date care fac acest lucru \u0219i f\u0103r\u0103 a fi nevoie de prelucr\u0103ri adi\u021bionale, precum Policy based data structures, dar \u00een multe situa\u021bii, acestea se dovedesc a fi foarte \u00eencete \u0219i foarte costisitoare din punct de vedere al memoriei, normalizarea fiind o op\u021biune superioar\u0103 \u00een toate situa\u021biile. Totu\u0219i, dac\u0103 limita de timp nu este str\u00e2ns\u0103, acestea pot fi o op\u021biune viabil\u0103.</p> <pre><code>#include &lt;iostream&gt;\n#include &lt;vector&gt;\n#include &lt;algorithm&gt;\nusing namespace std;\n\nint main() {\n    int n;\n    cin &gt;&gt; n;\n\n    vector&lt;int&gt; v(n+1), sorted(n+1);\n    for (int i = 1; i &lt;= n; i++) {\n        cin &gt;&gt; v[i];\n        sorted[i] = v[i];\n    }\n\n    sort(sorted.begin() + 1, sorted.begin() + n + 1);\n\n    int maxi = 0;\n    for (int i = 1; i &lt;= n; i++) {\n        int L = 1;\n        int R = n;\n        int ans = 0;\n        while (L &lt;= R) {\n            int mid = (L + R) / 2;\n            if (sorted[mid] &lt; v[i]) {\n                ans = mid;\n                L = mid + 1;\n            }\n            else {\n                R = mid - 1;\n            }\n        }\n        cout &lt;&lt; ans &lt;&lt; '\\n';\n    }\n    return 0;\n}\n</code></pre>","tags":["normalizare","implementare"]},{"location":"mediu/data-normalization/#problema-restaurant-customers-de-pe-cses","title":"Problema Restaurant Customers de pe cses","text":"<p>Pentru a rezolva aceast\u0103 problem\u0103, trebuie s\u0103 g\u0103sim o metod\u0103 care ne ajut\u0103 s\u0103 proces\u0103m intervalele \u00een a\u0219a fel \u00eenc\u00e2t s\u0103 nu trebuiasc\u0103 s\u0103 avem nevoie de foarte mult\u0103 memorie pentru valorile din intervale. </p> <p>O prim\u0103 solu\u021bie brut\u0103 const\u0103 \u00een verificarea fiec\u0103rui punct posibil de la \\(1\\) la \\(10^9\\), iar pentru fiecare punct, verific\u0103m dac\u0103 este inclus \u00een fiecare dintre cele \\(n\\) intervale date. Complexitatea ar fi \\(O(n \\cdot maxval)\\), ceea ce este mult prea \u00eencet pentru o solu\u021bie optim\u0103.</p> <p>Observa\u021bie</p> <p>Singurele puncte \u00een care se schimb\u0103 num\u0103rul de intervale acoperite de un punct sunt acelea unde \u00eencepe \u0219i se termin\u0103 un interval, deci num\u0103rul de puncte relevante scade la \\(2 \\cdot n\\).</p> <p>Solu\u021bia men\u021bionat\u0103 mai sus ar fi optimizat\u0103 la \\(O(n^2)\\), ceea ce nu este \u00eendeajuns pentru rezolvarea problemei date. </p> <p>O alt\u0103 abordare const\u0103 \u00een folosirea unei abord\u0103ri pe stilul \u0218menului lui Mars, iar pentru fiecare interval, putem ad\u0103uga \\(1\\) \u00een zona \\([st, dr]\\), iar complexitatea ar deveni \\(O(maxval)\\). </p> <p>Folosind observa\u021bia de mai sus, putem reduce num\u0103rul de puncte la \\(2 \\cdot n\\), iar dup\u0103 ce sort\u0103m punctele relevante, solu\u021bia explicat\u0103 mai sus poate fi optimizat\u0103 la \\(O(n \\log n)\\), unele din abord\u0103rile care merg pot fi fie folosirea \u0219menului lui Mars pe vectorul cu punctele normalizate, fie sortarea punctelor relevante \u0219i considerarea lor drept evenimente, mai apoi parcurg\u00e2ndu-le \u00een ordine cresc\u0103toare. </p> <p>O abordare care consider\u0103 punctele drept evenimente se poate citi mai jos. Deoarece toate punctele sunt distincte, nu este necesar s\u0103 consider\u0103m \u00eentr-o manier\u0103 particular\u0103 intr\u0103rile \u0219i ie\u0219irile.</p> <pre><code>#include &lt;iostream&gt;\n#include &lt;algorithm&gt;\n\nusing namespace std;\n\nint n;\n\npair&lt;int, int&gt; p[400002]; \n\nint main() {\n    cin &gt;&gt; n;\n    for (int i = 1; i &lt;= n; ++i) {\n        int a, b;\n        cin &gt;&gt; a &gt;&gt; b;\n        // 1 - intrare in restaurant, -1 - iesire din restaurant\n        // transformam fiecare moment intr-o pereche\n        p[i*2-1] = {a, 1};\n        p[i*2] = {b, -1};\n    }\n\n    sort(p + 1, p + n * 2 + 1); \n\n    int counter = 0, max_counter = 0;\n    for (int i = 1; i &lt;= n*2; ++i) {\n        counter += p[i].second; \n        if (counter &gt; max_counter) {\n            max_counter = counter;\n        }\n    }\n\n    cout &lt;&lt; max_counter &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["normalizare","implementare"]},{"location":"mediu/data-normalization/#concluzii","title":"Concluzii","text":"<p>De\u0219i normalizarea nu este altceva dec\u00e2t o tehnic\u0103 auxiliar\u0103, aceasta se va dovedi a fi una foarte important\u0103 \u00een cazul multor probleme algoritmice, acest pas fiind un pas intermediar foarte important atunci c\u00e2nd avem nevoie s\u0103 prelucr\u0103m datele folosind structuri de date, evit\u00e2nd astfel folosirea unor variante dinamice, care ocup\u0103 mult mai mult\u0103 memorie \u0219i consum\u0103 mult mai mult timp. </p>","tags":["normalizare","implementare"]},{"location":"mediu/data-normalization/#probleme-suplimentare","title":"Probleme suplimentare","text":"<ul> <li>map pbinfo</li> <li>Probleme cu normalizare de pe pbinfo</li> <li>Rectangular Pasture USACO Silver</li> <li>nextseq infoarena</li> <li>Static Range Queries Codeforces</li> </ul>","tags":["normalizare","implementare"]},{"location":"mediu/data-normalization/#lectura-suplimentara","title":"Lectur\u0103 suplimentar\u0103","text":"<ul> <li>Coordinate Compression - USACO Guide</li> <li>Normalize an array</li> </ul>","tags":["normalizare","implementare"]},{"location":"mediu/deque/","title":"Deque","text":"<p>Autor: \u0218tefan-Cosmin D\u0103sc\u0103lescu</p> <p>Probabil c\u0103 p\u00e2n\u0103 acum, v-ati obi\u0219nuit cu folosirea stivelor \u0219i a cozilor \u00een diverse probleme de algoritmic\u0103, iar de\u0219i aceste structuri de date sunt foarte puternice, fiecare dintre ele are lipsuri care fac implementarea anumitor p\u0103r\u021bi mult mai dificil\u0103. </p> <p>Acum, se pune \u00eentrebarea fireasc\u0103 dac\u0103 putem s\u0103 unim propriet\u0103\u021bile cozilor \u0219i ale stivelor f\u0103r\u0103 s\u0103 avem de f\u0103cut sacrificii majore, iar r\u0103spunsul este din fericire un DA clar. \u00cen cele ce urmeaz\u0103, vom discuta despre deque, o structur\u0103 de date care \u00eembin\u0103 propriet\u0103\u021bile stivelor \u0219i ale cozilor, ad\u0103ug\u00e2nd \u0219i facilit\u0103\u021bi \u00een plus. </p>","tags":["vectori","structuri de date"]},{"location":"mediu/deque/#introducere-si-sintaxa","title":"Introducere \u0219i sintax\u0103","text":"<p>Defini\u021bie</p> <p>Un deque (double-ended queue) este o structur\u0103 de date liniar\u0103, similar\u0103 cu stiva \u0219i coada, cu proprietatea c\u0103 suport\u0103 opera\u021biile specifice stivelor \u0219i cozilor \u00een timp constant. A\u0219a cum \u00eei zice \u0219i numele, practic este o coad\u0103 dubl\u0103, din care putem extrage valori din ambele capete, dar \u0219i ad\u0103uga \u00een ambele capete. </p> <p>Observa\u021bie</p> <p>Complexitatea men\u021bionat\u0103 mai sus este cel pu\u021bin pentru implementarea din STL (std::deque) una amortizat\u0103, cu alte cuvinte, \\(n\\) opera\u021bii f\u0103cute pe un deque vor fi \\(O(n)\\), dar asta nu garanteaz\u0103 faptul c\u0103 fiecare opera\u021bie va lua \\(O(1)\\). Din acest motiv, vom spune c\u0103 complexitatea unui deque este \\(O(1)\\) amortizat. </p>","tags":["vectori","structuri de date"]},{"location":"mediu/deque/#sintaxa","title":"Sintax\u0103","text":"<p>La fel ca \u0219i \u00een cazul cozilor \u0219i stivelor, deque-ul poate fi implementat de m\u00e2n\u0103, folosind un tablou de lungime fix\u0103, ad\u0103ug\u00e2nd \u0219i sco\u021b\u00e2nd valori \u00eentr-un mod ciclic.</p> <pre><code>const int QMAX = 100001;\nint coada[100001];\n\nint pop() {\n  ultim = (ultim - 1 + QMAX) % QMAX;\n  return coada[ultim];\n}\nvoid pushFront(int e) {\n  prim = (prim - 1 + QMAX) % QMAX;\n  coada[prim] = e;\n}\nvoid pushBack(int e) {\n  ultim = (ultim + 1 - QMAX) % QMAX;\n  coada[ultim] = e;\n}\n</code></pre> <p>Totu\u0219i, \u00een cele mai multe probleme, ne vom folosi de versiunea specific\u0103 limbajului C++, \u0219i anume std::deque. Acesta va avea func\u021biile specifice cozilor \u0219i stivelor, f\u0103r\u0103 a fi nevoie s\u0103 le implement\u0103m noi. </p> <p>Lista operatorilor \u0219i func\u021biilor pe care le pute\u021bi folosi \u00een deque este urm\u0103toarea:</p> <ol> <li>push_back(value): Adaug\u0103 value la sf\u00e2r\u0219itul deque-ului.</li> <li>push_front(value): Adaug\u0103 value la \u00eenceputul deque-ului.</li> <li>pop_back(): Scoate valoarea de la sf\u00e2r\u0219itul deque-ului.</li> <li>pop_front(): Scoate valoarea de la \u00eenceputul deque-ului.</li> <li>front(): Spune care este valoarea de la \u00eenceputul deque-ului.</li> <li>back(): Spune care este valoarea de la cap\u0103tul deque-ului.</li> <li>empty(): Spune dac\u0103 deque-ul este goal\u0103.</li> <li>size(): Returneaz\u0103 dimensiunea deque-ului.</li> </ol> <p>Mai jos pute\u021bi g\u0103si exemple de aplicare a func\u021biilor \u00een deque.</p> <pre><code>deque&lt;int&gt; d;\nd.push_back(1); // 1\nd.push_back(3); // 1 3\nd.push_front(2); // 2 1 3\nd.push_back(4); // 2 1 3 4\nd.push_front(5); // 5 2 1 3 4\nd.pop_back(); // 5 2 1 3\nd.pop_back(); // 5 2 1\nd.pop_front(); // 2 1\ncout &lt;&lt; d.front() &lt;&lt; '\\n'; // 2\ncout &lt;&lt; d.back() &lt;&lt; '\\n'; // 1\ncout &lt;&lt; d.size() &lt;&lt; '\\n'; // 2\nif (!d.empty()) {\n    cout &lt;&lt; \"Are valori\";\n}\n</code></pre>","tags":["vectori","structuri de date"]},{"location":"mediu/deque/#motivatie","title":"Motiva\u021bie","text":"<p>Motivul principal pentru care folosim deque-urile este acela de a putea performa opera\u021bii pe secven\u021be de lungime fix\u0103, fiind una din tehnicile des folosite \u00een cazul problemelor ce folosesc tehnica sliding window (sau \u00een rom\u00e2n\u0103, fereastra glisant\u0103), subiect discutat \u00een acest articol (note: aici trebuie s\u0103 punem articolul cu sliding window c\u00e2nd va fi). Acesta va fi \u0219i scopul principal al acestui articol, acela de a prezenta cele mai des \u00eent\u00e2lnite aplica\u021bii ale deque-ului.</p> <p>De cele mai multe ori, atunci c\u00e2nd vom lucra cu deque-ul, vom vrea s\u0103 proces\u0103m secven\u021be de o lungime fix\u0103, av\u00e2nd opera\u021bii bine stabilite \u0219i de cele mai multe ori, prelu\u00e2nd aspecte de implementare v\u0103zute mai devreme c\u00e2nd a\u021bi studiat principiile de func\u021bionare ale stivei. </p>","tags":["vectori","structuri de date"]},{"location":"mediu/deque/#problema-deque","title":"Problema deque","text":"<p>\u00cen aceast\u0103 problem\u0103, se cere aflarea valorii minime pentru toate subsecven\u021bele de lungime \\(k\\). O solu\u021bie ce merit\u0103 men\u021bionat\u0103, dar care nu este optim\u0103, este folosirea unei structuri de tip set care reu\u0219e\u0219te s\u0103 ob\u021bin\u0103 rezultatul dorit \u00een \\(O(n \\log n)\\).</p> <p>Pentru solu\u021bia optim\u0103, vom proceda \u00een mod similar cum am proceda dac\u0103 am vrea s\u0103 afl\u0103m cea mai apropiat\u0103 valoare mai mic\u0103 de la st\u00e2nga, singura modificare fiind faptul c\u0103 dac\u0103 valoarea minim\u0103 este prea departe de pozi\u021bia curent\u0103, o scoatem. </p> <pre><code>#include &lt;fstream&gt;\n#include &lt;deque&gt;\n\nusing namespace std;\n\nint n, k, v[5000002];\n\nifstream fin(\"deque.in\");\nofstream fout(\"deque.out\");\n\nint main() {\n    fin &gt;&gt; n &gt;&gt; k;\n    for (int i = 1; i &lt;= n; ++i) {\n        fin &gt;&gt; v[i];\n    }\n    deque&lt;int&gt; d;\n\n    long long ans = 0;\n    for (int i = 1; i &lt;= n; ++i) {\n        if (!d.empty() &amp;&amp; i - d.front() == k) {\n            d.pop_front();\n        }\n        while (!d.empty() &amp;&amp; v[i] &lt;= v[d.back()]) {\n            d.pop_back();\n        }\n        d.push_back(i);\n        if (i &gt;= k) {\n            ans += v[d.front()];\n        }\n    }\n\n    fout &lt;&lt; ans &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["vectori","structuri de date"]},{"location":"mediu/deque/#problema-maximum-subarray-sum-ii","title":"Problema Maximum Subarray Sum II","text":"<p>Pentru a rezolva aceast\u0103 problem\u0103, ne folosim de faptul c\u0103 suma unei subsecven\u021be \u00eentre pozi\u021biile \\(L\\) \u0219i \\(R\\) este \\(sp[R] - sp[L-1]\\), unde \\(sp[i]\\) este suma par\u021bial\u0103 a valorilor p\u00e2n\u0103 la pozi\u021bia \\(i\\). Astfel, dat fiind c\u0103 trebuie s\u0103 afl\u0103m suma maxim\u0103 a unei subsecven\u021be \u00eentre lungimile \\(a\\) \u0219i \\(b\\), la pasul \\(i\\), vom insera \\(sp[i-a]\\), folosind deque-ul drept o stiv\u0103 care \u021bine sumele minime. La fel ca la problema precedent\u0103, dac\u0103 pozi\u021bia \\(i - b - 1\\) \u00eenc\u0103 este \u00een deque, o vom scoate.</p> <p>Observa\u021bie</p> <p>Vrem s\u0103 sc\u0103dem din suma curent\u0103 o sum\u0103 c\u00e2t mai mic\u0103 pentru a avea o sum\u0103 maxim\u0103, deoarece \\(sp[i]\\) este elementul fix, invariant.</p> <pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n\nlong long v[200002], sp[200002]; \nint main() {\n    int n, a, b;\n    cin &gt;&gt; n &gt;&gt; a &gt;&gt; b;\n\n    for (int i = 1; i &lt;= n; i++) {\n        cin &gt;&gt; v[i];\n        sp[i] = sp[i-1] + v[i];\n    }\n\n    deque&lt;int&gt; d;    \n    long long ans = -(1LL&lt;&lt;60);\n\n    for (int i = a; i &lt;= n; i++) {\n        while (!d.empty() &amp;&amp; sp[i - a] &lt;= sp[d.back()]) {\n            d.pop_back();\n        }\n        while (!d.empty() &amp;&amp; i - d.front() &gt; b) {\n            d.pop_front();\n        }\n        d.push_back(i-a);\n        if (sp[i] - sp[d.front()] &gt;= ans) {\n            ans = sp[i] - sp[d.front()];\n        }\n    }\n\n    cout &lt;&lt; ans;\n</code></pre>","tags":["vectori","structuri de date"]},{"location":"mediu/deque/#problema-cetate","title":"Problema cetate","text":"<p>Pentru rezolvarea cerin\u021bei \\(2\\) a acestei probleme, putem fixa dou\u0103 linii \u0219i s\u0103 aplic\u0103m o tehnic\u0103 similar\u0103 folosind deque, afl\u00e2nd suma maxim\u0103 folosindu-ne de sumele par\u021biale de pe coloane, mai jos fiind codul de la cerin\u021ba a doua, \u00eentreaga submisie put\u00e2nd fi accesat\u0103 aici </p> <pre><code>maxSum = LLONG_MIN;\nfor (linTop = 1; linTop &lt;= n; linTop++) {\n    linBot = linTop;\n    while (linBot &lt;= n &amp;&amp; (linBot - linTop + 1) &lt;= k) {\n        /* precalculam suma pe coloane */\n        cols[0] = 0;\n        for (col = 1; col &lt;= m; col++) {\n            cols[col] = cols[col - 1];\n            cols[col] += sp[linBot][col] - sp[linBot][col - 1] - sp[linTop - 1][col] + sp[linTop - 1][col - 1];\n        }\n\n        /* sliding window */\n        d.clear();\n        d.push_back(0);\n        for (col = 1; col &lt;= m; col++) {\n            /* daca a ramas ceva in urma */\n            if (d.front() == (col - k - 1)) {\n                d.pop_front();\n            }\n\n            sum = cols[col] - cols[d.front()];\n\n            bool isGreater = sum &gt; maxSum;\n            bool lexicSort = sum == maxSum &amp;&amp; (linTop &lt;= maxLin || d.front() + 1 &lt;= maxCol);\n            if (isGreater || lexicSort) {\n                maxSum = sum;\n\n                maxLin = linTop, maxCol = d.front() + 1;\n                maxLin1 = linBot, maxCol1 = col;\n            }\n\n            /* ideea de la next greater element */\n            while (!d.empty() &amp;&amp; cols[col] &lt; cols[d.back()]) {\n                d.pop_back();\n            }\n            d.push_back(col);\n        }\n        linBot++;\n    }\n}\n\ncout &lt;&lt; maxSum &lt;&lt; \"\\n\";\ncout &lt;&lt; maxLin &lt;&lt; \" \" &lt;&lt; maxCol &lt;&lt; \" \" &lt;&lt; maxLin1 &lt;&lt; \" \" &lt;&lt; maxCol1 &lt;&lt; \"\\n\";\n</code></pre>","tags":["vectori","structuri de date"]},{"location":"mediu/deque/#probleme-suplimentare","title":"Probleme suplimentare","text":"<ul> <li>infoarena vila2</li> <li>RoAlgo PreOJI 2024 pofta</li> <li>JBOI 2022 Wall</li> <li>Lot Juniori 2016 pofta</li> <li>IIOT Discount Optimization</li> <li>Problemele cu deque de pe kilonova</li> <li>Problemele cu deque de pe infoarena</li> </ul>","tags":["vectori","structuri de date"]},{"location":"mediu/deque/#lectura-suplimentara","title":"Lectur\u0103 suplimentar\u0103","text":"<ul> <li>Deque CPPI Sync</li> <li>Deque si aplicatii - Infoarena</li> <li>Deque Algopedia</li> <li>Minima/maxima over all fixed-size arrays (multi-dimensional)</li> <li>Minimum stack / Minimum queue</li> </ul>","tags":["vectori","structuri de date"]},{"location":"mediu/dsu/","title":"P\u0103duri de mul\u021bimi disjuncte (DSU)","text":"<p>Autor: \u0218tefan-Cosmin D\u0103sc\u0103lescu</p> <p>Structurile de date sunt de multe ori foarte utile \u00een multe contexte \u00een programare, acestea dovedindu-se a fi \u00een special foarte puternice \u0219i esen\u021biale \u00een lucrul problemelor date la diverse olimpiade \u0219i concursuri de informatic\u0103. Acest articol va prezenta o structur\u0103 de date care nu e la prima vedere foarte complicat\u0103 fa\u021b\u0103 de alte structuri de date mai consacrate, dar care se dovede\u0219te a fi foarte puternic\u0103 \u00een rezolvarea multor probleme de toate felurile. </p> <p>A\u0219a cum sugereaz\u0103 \u0219i titlul, vom prezenta \u00een acest articol p\u0103durile de mul\u021bimi disjuncte, sau union-find, denumire dat\u0103 dup\u0103 cele dou\u0103 opera\u021bii principale pe care aceast\u0103 structur\u0103 de date le ofer\u0103. Union-Find poate fi folosit cu mare u\u0219urin\u021b\u0103 pentru probleme de tipul acelora \u00een care ni se cere s\u0103 afl\u0103m pe parcurs ce valori sunt legate \u00eentre ele printr-o rela\u021bie, presupun\u00e2nd c\u0103 rela\u021biile dintre valori se adaug\u0103 treptat. Pe parcurs se vor remarca diverse optimiz\u0103ri, precum \u0219i diferitele clase de probleme \u00een care se poate folosi o asemenea structur\u0103 de date.</p> <p>Pentru u\u0219urarea explica\u021biilor, vom presupune c\u0103 avem o situa\u021bie ipotetic\u0103 \u00een care avem \\(n\\) prieteni \u0219i ni se dau opera\u021bii \u00een care fie dou\u0103 persoane devin prietene, fie trebuie s\u0103 decidem dac\u0103 dou\u0103 persoane apar\u021bin aceluia\u0219i grup de prieteni.</p>","tags":["vectori","arbori","multimi"]},{"location":"mediu/dsu/#definirea-operatiilor-si-functionalitatii-structurii-de-date","title":"Definirea opera\u021biilor \u0219i func\u021bionalit\u0103\u021bii structurii de date","text":"","tags":["vectori","arbori","multimi"]},{"location":"mediu/dsu/#fundamente","title":"Fundamente","text":"<p>Pentru a reprezenta datele, vom \u021bine \u00eentr-un vector dimensiunea fiec\u0103rei mul\u021bimi, iar \u00eentr-un alt vector vom \u021bine pentru fiecare pozi\u021bie, nodul reprezentativ corespunz\u0103tor grupului de prieteni din care face parte, la \u00eenceput fiecare nod fiind reprezentantul lui \u00eensu\u0219i.</p> <pre><code>vector&lt;int&gt; rad(n + 1), card(n + 1);\n\nfor(int i = 1; i &lt;= n; ++i) {\n    rad[i] = i;\n    card[i] = 1;\n}\n</code></pre>","tags":["vectori","arbori","multimi"]},{"location":"mediu/dsu/#operatia-de-unire-union","title":"Opera\u021bia de unire (Union)","text":"<p>La acest pas, ni se dau dou\u0103 persoane \u0219i trebuie s\u0103 stabilim rela\u021bia de prietenie dintre ei. De\u0219i aceast\u0103 opera\u021bie se face \u00een timp constant, conteaz\u0103 foarte mult modul \u00een care facem rela\u021bia de atribuire, aceasta put\u00e2nd schimba radical complexitatea algoritmului. Astfel, voi introduce prima optimizare, si anume optimizarea de unire dup\u0103 cardinalul mul\u021bimii, astfel \u00eenc\u00e2t vom uni mereu mul\u021bimea cu cardinal mai mic la mul\u021bimea cu cardinal mai mare.</p> <p>Motivul pentru care aceast\u0103 optimizare duce la o complexitate mai mic\u0103 va fi dat de num\u0103rul mai mic de opera\u021bii pe care func\u021bia Find le va face la fiecare pas. De asemenea, aceast\u0103 optimizare de a uni mul\u021bimile mai mici la cele mai mari se reg\u0103se\u0219te \u00een mod frecvent \u0219i \u00een alte contexte \u00een diverse structuri de date \u0219i nu numai. </p> <pre><code>void Union(int a, int b) {\n    if (card[a] &lt; card[b]) { // (1)\n        swap(a, b);\n    }\n    rad[b] = a;              // (2)\n    card[a] += card[b];      // (3)\n}\n</code></pre> <ol> <li>Vom vrea sa ata\u0219\u0103m nodul \\(b\\) la nodul \\(a\\).</li> <li>R\u0103d\u0103cina lui \\(b\\) devine \\(a\\).</li> <li>Cre\u0219tem cardinalul lui \\(a\\) cu cardinalul lui \\(b\\).</li> </ol>","tags":["vectori","arbori","multimi"]},{"location":"mediu/dsu/#operatia-de-cautare-find","title":"Opera\u021bia de c\u0103utare (Find)","text":"<p>La aceast\u0103 opera\u021bie, vrem s\u0103 g\u0103sim pentru un nod, pozi\u021bia nodului reprezentativ \u00een structura noastr\u0103 de date. \u00cen mod normal, aceast\u0103 opera\u021bie poate face cel mult \\(O(n)\\) pa\u0219i, \u00een cazul \u00een care arborele rezultat ar fi un lan\u021b. Totu\u0219i, putem s\u0103 ne folosim de parcurgerile pe care le facem pentru a re\u021bine rezultatele pentru toate nodurile de pe parcursul acelui drum, astfel \u00eenc\u00e2t la o parcurgere ulterioar\u0103, num\u0103rul de pa\u0219i s\u0103 se reduc\u0103 spre un num\u0103r constant, structura arborelui ajung\u00e2nd similar\u0103 cu cea a unui arbore stea. </p> <pre><code>int Find(int x) {\n    if (rad[x] == x) {  // (1)\n        return x;\n    }\n    rad[x] = Find(rad[x]);  // (2) \n    return rad[x];\n}\n</code></pre> <ol> <li>Dac\u0103 nodul nostru este r\u0103d\u0103cin\u0103, \u00eenseamn\u0103 c\u0103 l-am g\u0103sit \u0219i-l return\u0103m \u00een     consecin\u021b\u0103.</li> <li>R\u0103d\u0103cina nodului nostru va deveni r\u0103d\u0103cina r\u0103d\u0103cinii curente.</li> </ol>","tags":["vectori","arbori","multimi"]},{"location":"mediu/dsu/#prime-concluzii","title":"Prime concluzii","text":"<p>Opera\u021bia union are complexitatea \\(O(1)\\), iar opera\u021bia de find are complexitatea \\(O(n)\\). Totu\u0219i, datorit\u0103 optimiz\u0103rilor men\u021bionate mai sus (compresia drumurilor \u0219i unirea dup\u0103 dimensiunea mul\u021bimilor), num\u0103rul total de opera\u021bii f\u0103cute este \\(O(n \\log^* n)\\), unde \\(\\log^* x\\) reprezint\u0103 inversul func\u021biei Ackermann, valoare care se poate aproxima ca fiind o constant\u0103. De asemenea, nefolosirea optimiz\u0103rii de compresie a drumurilor ar duce la complexitatea \\(O(n \\log n)\\), rezultat foarte important \u00een contextul altor optimiz\u0103ri, cum ar fi tehnica small-to-large sau \u00een general \u00een demonstrarea diverselor rezultate ce \u021bin de sume armonice. </p>","tags":["vectori","arbori","multimi"]},{"location":"mediu/dsu/#problema-disjoint","title":"Problema disjoint","text":"<p>Pentru fiecare opera\u021bie citit\u0103 de la intrare, vom implementa func\u021biile necesare pentru a ob\u021bine rezultatul problemei. Unirea a dou\u0103 mul\u021bimi implic\u0103 mai \u00eent\u00e2i folosirea func\u021biei Find pentru a g\u0103si r\u0103d\u0103cinile, iar mai apoi folosim func\u021bia Union pentru a face unirea propriu-zis\u0103. Folosirea ambelor optimiz\u0103ri pentru \u00eembun\u0103t\u0103\u021birea complexit\u0103\u021bii duce la solu\u021bia optim\u0103, ce ruleaz\u0103 \u00eentr-un timp aproximativ liniar raportat la num\u0103rul de valori citite. </p> <p>Solu\u021bia de 100 de puncte este urm\u0103toarea: <pre><code>#include &lt;fstream&gt;\n#include &lt;vector&gt;\n\nusing namespace std;\n\nconstexpr int NMAX = 100002;\n\nint n, m;\n\nvector&lt;int&gt; rad(NMAX), card(NMAX);\n\nint Find(int x) {\n    if (rad[x] == x) {\n        return x;\n    }\n    rad[x] = Find(rad[x]);\n    return rad[x];\n}\n\nvoid Union(int a, int b) {\n    if (card[a] &lt; card[b]) {\n        swap(a, b);\n    }\n    rad[b] = a;\n    card[a] += card[b];\n}\n\nint main() {\n    ifstream fin(\"disjoint.in\");\n    ofstream fout(\"disjoint.out\");\n\n    fin &gt;&gt; n &gt;&gt; m;\n\n    for (int i = 1; i &lt;= n; ++i) {\n        rad[i] = i;\n        card[i] = 1;\n    }\n\n    for (int i = 1; i &lt;= m; ++i) {\n        int cod, x, y;\n        fin &gt;&gt; cod &gt;&gt; x &gt;&gt; y;\n\n        if (cod == 1 &amp;&amp; Find(x) != Find(y)) {\n            Union(Find(x), Find(y));\n        } else {\n            fout &lt;&lt; (Find(x) == Find(y)) ? \"DA\\n\" : \"NU\\n\";\n        }\n    }\n\n    fin.close();\n    fout.close();\n    return 0;\n}\n</code></pre></p>","tags":["vectori","arbori","multimi"]},{"location":"mediu/dsu/#oare-putem-implementa-mai-eficient","title":"Oare putem implementa mai eficient?","text":"<p>Ini\u021bial, noi am implementat aceast\u0103 structur\u0103 folosind doi vectori, anume cel \u00een care \u021binem cardinalul fiec\u0103rei mul\u021bimi, precum \u0219i cel \u00een care \u021binem r\u0103d\u0103cina fiec\u0103rei mul\u021bimi. Totu\u0219i, se poate observa faptul c\u0103 noi folosim o gr\u0103mad\u0103 de informa\u021bie inutil\u0103 din cauza faptului c\u0103 pentru fiecare num\u0103r, practic ne intereseaz\u0103 doar dac\u0103 e o r\u0103d\u0103cin\u0103 a unei mul\u021bimi de valori sau nu. Astfel, vom recurge la a reprezenta pozi\u021biile corespunz\u0103toare r\u0103d\u0103cinilor cu numere negative, reprezent\u00e2nd \\(-x\\), unde \\(x\\) e cardinalul mul\u021bimii reprezentat de acea valoare, respectiv reprezentarea nodurilor adiacente cu numere pozitive, reprezent\u00e2nd r\u0103d\u0103cina mul\u021bimii din care acea valoare face parte.</p> <p>Solu\u021bia de 100 de puncte cu optimizarea de memorie este urm\u0103toarea: <pre><code>#include &lt;fstream&gt;\n#include &lt;vector&gt;\n\nusing namespace std;\n\nconstexpr int NMAX = 100002;\n\nint n, q;\n\nvector&lt;int&gt; sz(NMAX);\n\nint Find(int nod) {\n    if (sz[nod] &lt; 0) {\n        return nod;\n    }\n    sz[nod] = Find(sz[nod]);\n    return sz[nod];\n}\n\nvoid Union(int a, int b) {\n    if (a == b) {\n        return;\n    }\n\n    if (sz[a] &gt; sz[b]) {\n        swap(a, b);\n    }\n\n    sz[a] += sz[b];\n    sz[b] = a;\n}\n\nint main() {\n    ifstream fin(\"disjoint.in\");\n    ofstream fout(\"disjoint.out\");\n\n    fin &gt;&gt; n &gt;&gt; q;\n\n    for (int i = 1; i &lt;= n; ++i) {\n        sz[i] = -1;\n    }\n\n    for (int i = 1; i &lt;= q; ++i) {\n        int cod, x, y;\n        fin &gt;&gt; cod &gt;&gt; x &gt;&gt; y;\n\n        if (cod == 1 &amp;&amp; Find(x) != Find(y)) {\n            Union(Find(x), Find(y));\n        } else {\n            fout &lt;&lt; (Find(x) == Find(y)) ? \"DA\\n\" : \"NU\\n\";\n        }\n    }\n\n    fin.close();\n    fout.close();\n    return 0;\n}\n</code></pre></p>","tags":["vectori","arbori","multimi"]},{"location":"mediu/dsu/#problema-bile","title":"Problema bile.","text":"<p>Cerin\u021b\u0103</p> <p>Pe o tabla patratica impartita in \\(N^2\\) patratele (\\(N\\) linii si \\(N\\) coloane), se afla asezate \\(N^2\\) bile (cate una in fiecare patratica a tablei). Lui Gigel ii plac bilele foarte mult, astfel ca el ia, pe rand, cate o bila de pe tabla, pana cand nu mai ramane pe tabla nici o bila. Gigel este, de asemenea, un baiat foarte curios. El a constatat ca bilele pot fi impartite in componente conexe, astfel:</p> <ul> <li> <p>fiecare bila face parte din exact o componenta conexa</p> </li> <li> <p>daca 2 bile sunt invecinate pe orizontala sau verticala, atunci ele fac   parte din aceeasi componenta conexa (adica daca una se afla imediat   deasupra, dedesubtul, la dreapta sau la stanga celeilalte)</p> </li> </ul> <p>Dimensiunea unei componente conexe este egala cu numarul de bile care fac parte din componenta conexa respectiva. Dupa fiecare bila luata, Gigel vrea sa stie care este valoarea maxima dintre dimensiunile componentelor conexe din care fac parte bilele ramase.</p> <p>Mai \u00eent\u00e2i, trebuie observat faptul c\u0103 problema determin\u0103rii conectivit\u0103\u021bii dinamice este una foarte dificil de rezolvat (vezi acest articol de pe Wikipedia), deci nu are sens s\u0103 ne chinuim cu asemenea implement\u0103ri care nu fac obiectul cursului nostru sau \u00een general a programelor olimpiadelor de informatic\u0103.</p> <p>Asta ne duce cu g\u00e2ndul s\u0103 \u00eencerc\u0103m s\u0103 privim problema dintr-o perspectiv\u0103 diferit\u0103, \u00een special \u0219i datorit\u0103 faptului c\u0103 nu suntem for\u021ba\u021bi s\u0103 r\u0103spundem la actualiz\u0103ri online. Din acest motiv, vom introduce o abordare care se folose\u0219te la multe solu\u021bii ce se bazeaz\u0103 pe folosirea p\u0103durilor de mul\u021bimi disjuncte. </p> <p>Practic, \u00een loc s\u0103 privim problema de la \u00eenceput la final, vom rezolva problema invers\u0103, \u00een care putem ad\u0103uga bile, ceea ce ne ajut\u0103 s\u0103 reducem problema la o aplica\u021bie standard a p\u0103durilor de mul\u021bimi disjuncte, r\u0103spunsurile ajung\u00e2nd \u00een cele din urm\u0103 s\u0103 fie afi\u0219ate \u00een ordinea invers\u0103 \u00een care le-am aflat. </p> <p>Solu\u021bia de 100 de puncte este urm\u0103toarea: <pre><code>#include &lt;algorithm&gt;\n#include &lt;fstream&gt;\n#include &lt;utility&gt;\n\nusing namespace std;\n\ntemplate&lt;typename T, size_t N&gt;\nusing Array = T[N];\n\nint n, maxim;\n\nArray&lt;int, 251*251&gt; rad, card, rasp;\nArray&lt;pair&lt;int, int&gt;, 251*251&gt; elim;\nArray&lt;Array&lt;int, 251&gt;, 251&gt; nr;\nArray&lt;Array&lt;bool, 251&gt;, 251&gt; viz;\n\nint dx[] = {-1, 0, 1, 0};\nint dy[] = {0, 1, 0, -1};\n\nint Find(int x) {\n    if (rad[x] == x) {\n        return x;\n    }\n\n    return rad[x] = Find(rad[x]);\n}\n\nvoid Union(int a, int b) {\n    if (card[a] &lt; card[b]) {\n        swap(a, b);\n    }\n\n    rad[b] = a;\n    card[a] += card[b];\n\n    maxim = max(maxim, card[a]);\n}\n\nint main() {\n    ifstream fin(\"bile.in\");\n\n    fin &gt;&gt; n;\n\n    for (int i = 1; i &lt;= n; ++i)\n        for (int j = 1; j &lt;= n; j++) {\n            int idx = (i - 1) * n + j;\n            nr[i][j] = idx;\n            card[idx] = 1;\n            rad[idx] = idx;\n        }\n\n    for (int i = 1; i &lt;= n * n; ++i) {\n        fin &gt;&gt; elim[i].first &gt;&gt; elim[i].second;\n    }\n\n    fin.close();\n\n    for (int i = n * n; i &gt;= 1; i--) {\n        rasp[i] = maxim;\n        int x = elim[i].first;\n        int y = elim[i].second;\n\n        for (int j = 0; j &lt; 4; j++) {\n            int newX = x + dx[j];\n            int newY = y + dy[j];\n\n            if (newX &gt;= 1 &amp;&amp; newX &lt;= n &amp;&amp; newY &gt;= 1 &amp;&amp; newY &lt;= n &amp;&amp;\n                viz[newX][newY]) {\n                int b1 = nr[x][y];\n                int b2 = nr[newX][newY];\n                if (nr[newX][newY] != 0 &amp;&amp; Find(b1) != Find(b2)) {\n                    Union(Find(b1), Find(b2));\n                }\n            }\n        }\n\n        maxim = max(maxim, 1);\n        viz[x][y] = true;\n    }\n\n    ofstream fout(\"bile.out\");\n\n    for (int i = 1; i &lt;= n * n; ++i) {\n        fout &lt;&lt; rasp[i] &lt;&lt; '\\n';\n    }\n\n    fout.close();\n\n    return 0;\n}\n</code></pre></p>","tags":["vectori","arbori","multimi"]},{"location":"mediu/dsu/#problema-secvmax","title":"Problema Secvmax.","text":"<p>Cerin\u021b\u0103</p> <p>Fiona are o secventa de \\(N\\) numere naturale. Ea se \u00eentreab\u0103 din c\u00e2nd \u00een c\u00e2nd pentru un anumit num\u0103r \\(Q\\) care este cea mai lung\u0103 subsecven\u021b\u0103 care are toate numerele mai mici sau egale cu \\(Q\\). Ajuta\u021bi-o pe Fiona s\u0103 \u00ee\u0219i r\u0103spund\u0103 la toate \u00eentreb\u0103rile.</p> <p>Aici putem folosi din nou prelucrarea numerelor \u00een ordine cresc\u0103toare a numerelor din vector, iar atunci c\u00e2nd ad\u0103ug\u0103m valorile \u00een considerare, vom verifica fiecare vecin s\u0103 vedem dac\u0103 putem uni valorile din cele dou\u0103 mul\u021bimi, iar la fiecare pas r\u0103spunsul e cardinalul maxim al unei mul\u021bimi, care e cresc\u0103tor pe m\u0103sur\u0103 ce cre\u0219tem valorile ad\u0103ugate.  </p> <pre><code>#include &lt;fstream&gt;\n#include &lt;algorithm&gt;\n#include &lt;vector&gt;\n\nusing namespace std;\n\nifstream f(\"secvmax.in\");\nofstream g(\"secvmax.out\");\n\nstruct Pair {\n    int value;\n    int index;\n\n    constexpr bool operator&lt;(const Pair &amp;other) const {\n        if (value == other.value) {\n            return index &lt; other.index;\n        }\n        return value &lt; other.value;\n    }\n};\n\nvector&lt;Pair&gt; queries, elements;\nvector&lt;int&gt; result, parent, sequence, length;\nint maxLength = 0;\n\nint Find(int node) {\n    int root;\n    for (root = parent[node]; root != parent[root]; root = parent[root]);\n    int x = node;\n    while (x != root) {\n        swap(root, parent[x]);\n    }\n    return root;\n}\n\nvoid Union(int a, int b) {\n    if (length[a] &lt; length[b]) {\n        length[b] += length[a];\n        parent[a] = b;\n        length[a] = 0;\n    } else {\n        length[a] += length[b];\n        parent[b] = a;\n        length[b] = 0;\n    }\n\n    maxLength = max(maxLength, length[a] + length[b]);\n}\n\nint main() {\n    int n, q;\n    f &gt;&gt; n &gt;&gt; q;\n\n    elements.resize(n + 1);\n    parent.resize(n + 1);\n    sequence.resize(n + 1);\n    length.resize(n + 1);\n\n    queries.resize(q + 1);\n    result.resize(q + 1);\n\n    for (int i = 1; i &lt;= n; ++i) {\n        int value;\n        f &gt;&gt; value;\n        elements[i] = {value, i};\n        sequence[i] = value;\n        parent[i] = i;\n    }\n\n    sort(elements.begin() + 1, elements.end());\n\n    for (int i = 1; i &lt;= q; ++i) {\n        int value;\n        f &gt;&gt; value;\n        queries[i] = {value, i};\n    }\n\n    sort(queries.begin() + 1, queries.end());\n\n    int pos = 1;\n\n    for (int i = 1; i &lt;= q; ++i) {\n        while (pos &lt;= n &amp;&amp; elements[pos].value &lt;= queries[i].value) {\n            int idx = elements[pos++].index;\n            length[idx] = 1;\n            maxLength = max(maxLength, 1);\n\n            if (idx &gt; 0 &amp;&amp; sequence[idx - 1] &lt;= sequence[idx]) {\n                Union(Find(idx - 1), Find(idx));\n            }\n\n            if (idx &lt; n - 1 &amp;&amp; sequence[idx + 1] &lt; sequence[idx]) {\n                Union(Find(idx + 1), Find(idx));\n            }\n\n        }\n        result[queries[i].index] = maxLength;\n    }\n\n    for (int i = 1; i &lt;= q; ++i) {\n        g &lt;&lt; result[i] &lt;&lt; '\\n';\n    }\n\n    return 0;\n}\n</code></pre>","tags":["vectori","arbori","multimi"]},{"location":"mediu/dsu/#problema-joingraf","title":"Problema joingraf.","text":"<p>Cerin\u021b\u0103</p> <p>A fost ziua lui Traian de cur\u00e2nd, iar el a primit \u00een dar un graf cu \\(N\\) noduri. La \u00eenceput, fiecare nod era \u00eentr-o component\u0103 conex\u0103, singur. Dar apoi, c\u00e2inele lui Traian a venit \u0219i i-a spus \\(Q\\) \u00eentreb\u0103ri de forma urm\u0103toare:</p> <ul> <li>\\(1 \\ x \\ y\\): Adaug\u0103 la graful t\u0103u muchiile \\((x, x + 1), (x + 1, x + 2), \\dots , (y - 1, y)\\)</li> <li>\\(2 \\ x \\ y\\): Spune dac\u0103 nodurile \\(x\\) \u0219i \\(y\\) sunt \u00een aceea\u0219i component\u0103 conex\u0103.</li> </ul> <p>Pentru a rezolva aceast\u0103 problem\u0103 exist\u0103 mai multe abord\u0103ri, plec\u00e2nd de la diverse moduri de a g\u00e2ndi problema, dar \u00een contextul p\u0103durilor de mul\u021bimi disjuncte, ne vom concentra pe solu\u021bia cu DSU. </p> <p>Mai \u00eent\u00e2i, trebuie s\u0103 observ\u0103m c\u0103 componentele conexe sunt ca ni\u0219te intervale. De exemplu, s\u0103 lu\u0103m \\(n = 7\\). Atunci, la \u00eenceput intervalele vor fi: \\([1, 1], [2, 2], [3, 3], [4, 4], [5, 5], [6, 6], [7, 7]\\). Dac\u0103 unim muchiile de la \\(3\\) la \\(6\\), intervalele vor deveni: \\([1, 1], [2, 2], [3, 6], [7, 7]\\).</p> <p>Atunci, putem folosi o structur\u0103 de tip DSU. Vom re\u021bine $par_i = $ \"p\u0103rintele\" nodului \\(i\\), sau mai u\u0219or de \u00een\u021beles, cap\u0103tul st\u00e2nga al intervalului \u00een care este nodul \\(i\\). Este nevoie s\u0103 re\u021binem doar cap\u0103tul dreapta, deoarece cap\u0103tul dreapta al secven\u021bei curente este predecesorul cap\u0103tului st\u00e2nga al secven\u021bei urm\u0103toare. Vom re\u021bine \u0219i $nxt_i = $ cap\u0103tul st\u00e2nga al secven\u021bei de dup\u0103 secven\u021ba \u00een care este \\(i\\).</p> <p>Iar atunci c\u00e2nd avem update cu \\(x, y\\), mergem la fiecare secven\u021b\u0103 p\u00e2n\u0103 la \\(y\\) (adic\u0103 c\u00e2nd avans\u0103m de la \\(p\\) la urm\u0103toarea, facem \\(p = nxt_p\\)) \u0219i o reunim cu secven\u021ba \u00een care este \\(x\\).</p> <p>Iar la query, verific\u0103m dac\u0103 intervalul \u00een care este \\(x\\) este egal cu cel \u00een care este \\(y\\). Complexitate: \\(O(N + Q \\ log \\ N)\\) timp, \\(O(n)\\) memorie.</p> <pre><code>#include &lt;iostream&gt;\n#include &lt;vector&gt;\n\nusing namespace std;\n\nconstexpr int N = 1e6 + 2;\nint n, q;\n\nvector&lt;int&gt; tt(N), jump(N);\n\nint root(int nd) {\n    while (tt[nd] != nd) {\n        return tt[nd] = root(tt[nd]);\n    }\n    return nd;\n}\nvoid unite(int a, int b) {\n    a = root(a);\n    b = root(b);\n\n    if (a == b) {\n        return;\n    }\n\n    tt[b] = tt[a];\n}\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(nullptr);\n\n    cin &gt;&gt; n &gt;&gt; q;\n\n    for (int i = 1; i &lt;= n; i++) {\n        tt[i] = jump[i] = i;\n    }\n\n    while (q--) {\n        int t, x, y;\n        cin &gt;&gt; t &gt;&gt; x &gt;&gt; y;\n\n        if (t != 1) {\n            cout &lt;&lt; (root(x) == root(y) ? \"Da\\n\" : \"Nu\\n\");\n            continue;\n        }\n\n        int p = x;\n        while (p &lt;= y) {\n            unite(x, p);\n            p = jump[p] + 1;\n        }\n        jump[x] = jump[y];\n    }\n    return 0;\n}\n</code></pre>","tags":["vectori","arbori","multimi"]},{"location":"mediu/dsu/#concluzii","title":"Concluzii","text":"<p>Acest articol este menit s\u0103 introduc\u0103 audien\u021ba \u00een folosirea p\u0103durilor de mul\u021bimi disjuncte, pun\u00e2nd accentul pe func\u021bionalit\u0103\u021bile de baz\u0103, f\u0103r\u0103 a men\u021biona alte aplica\u021bii importante, cum ar fi algoritmul lui Kruskal sau algoritmii folosi\u021bi pentru dynamic connectivity. De asemenea, p\u0103durile de mul\u021bimi disjuncte pot fi folosite pentru a scurta foarte mult implement\u0103rile aplica\u021biilor simple la grafuri.</p>","tags":["vectori","arbori","multimi"]},{"location":"mediu/dsu/#probleme-suplimentare","title":"Probleme suplimentare","text":"","tags":["vectori","arbori","multimi"]},{"location":"mediu/dsu/#probleme-de-la-olimpiade","title":"Probleme de la olimpiade","text":"<ul> <li>Chemical table - EJOI 2018</li> <li>MexC ONI 2008</li> <li>JBOI 2023 Frequencies</li> <li>IIOT 2023-24 Binary Chess</li> <li>Probleme cu DSU de pe kilonova</li> <li>COCI 13-ladice</li> <li>USACO MooTube</li> <li>USACO Wormhole Sort</li> </ul>","tags":["vectori","arbori","multimi"]},{"location":"mediu/dsu/#probleme-de-pe-codeforcesatcoder","title":"Probleme de pe Codeforces/AtCoder","text":"<ul> <li>Galleries - AGM 2020</li> <li>DSU Step 1 - Codeforces EDU</li> <li>DSU Step 2 - Codeforces EDU</li> </ul>","tags":["vectori","arbori","multimi"]},{"location":"mediu/dsu/#bibliografie-si-lectura-suplimentara","title":"Bibliografie \u0219i lectur\u0103 suplimentar\u0103","text":"<p>Am ordonat resursele suplimentare \u00een ordinea dificult\u0103\u021bii \u00een\u021belegerii \u0219i \u00eentr-o ordine logic\u0103 pentru a u\u0219ura ob\u021binerea de cuno\u0219tinte despre tehnicile, abord\u0103rile \u0219i problemele discutate \u00een acest curs. </p> <ul> <li>P\u0103duri de mul\u021bimi disjuncte - CS Academy</li> <li>Algoritmul Union-Find - Algopedia</li> <li>Link ce trebuie accesat pentru inscrierea la cursul despre DSU facut de ITMO Academy</li> <li>Articol USACO Guide - DSU</li> <li>Curs despre DSU - Codeforces (este necesar un cont pentru a putea accesa acest curs, plus accesarea linkului de mai sus)</li> <li>Sack (dsu on tree) - Avansat</li> <li>Smenul de manevrare a query-urilor offline cu DSU</li> </ul>","tags":["vectori","arbori","multimi"]},{"location":"mediu/euler-totient/","title":"Indicatorul lui Euler","text":"<p>Autor: \u0218tefan-Cosmin D\u0103sc\u0103lescu</p>","tags":["matematica","divizori","precalculari"]},{"location":"mediu/euler-totient/#introducere","title":"Introducere","text":"<p>Defini\u021bie</p> <p>Indicatorul lui Euler este un rezultat matematic care este folosit pentru a num\u0103ra c\u00e2te valori prime cu \\(n\\) sunt \u00een intervalul \\([1, n]\\). Acesta este notat cu \\(\\varphi (n)\\).</p> <p>Exemplu</p> <p>De exemplu, \\(\\varphi (12) = 4\\), deoarece \\(1\\), \\(5\\), \\(7\\) \u0219i \\(11\\) sunt prime cu \\(12\\). </p> <p>Aceast\u0103 func\u021bie se va dovedi util\u0103 \u00een multe probleme de algoritmic\u0103, fie c\u0103 e vorba de aflarea unor r\u0103spunsuri referitoare la divizorii comuni ai unor numere sau ca pas intermediar \u00een algoritmi \u0219i metode mai complicate, precum Func\u021bia M\u00f6bius sau pentru cei mai avansa\u021bi, teorema chinezeasc\u0103 a resturilor.</p>","tags":["matematica","divizori","precalculari"]},{"location":"mediu/euler-totient/#calcularea-functiei-si-proprietatile-acesteia","title":"Calcularea func\u021biei \u0219i propriet\u0103\u021bile acesteia","text":"<p>Pentru a calcula \\(\\varphi (n)\\), putem fie s\u0103 verific\u0103m pentru fiecare num\u0103r de la \\(1\\) la \\(n\\) dac\u0103 \\((i, n) = 1\\), unde cu \\((a, b)\\) am notat cel mai mare divizor comun al numerelor \\(a\\) \u0219i \\(b\\), fie s\u0103 g\u0103sim o formul\u0103 care se bazeaz\u0103 pe o observa\u021bie mai avansat\u0103. </p> <p>Cu alte cuvinte, dac\u0103 \u0219tim factorii primi care apar \u00een reprezentarea lui \\(n\\), \u00eei not\u0103m \\(p_1\\), \\(p_2\\), \\(\\dots\\), \\(p_k\\), formula va deveni urm\u0103toarea:</p> \\[ n \\cdot \\prod_{1}^{k} \\frac{p_i - 1}{p_i} \\] <p>De exemplu, pentru \\(n = 30\\), \\(\\varphi (n) = \\frac{2 - 1}{2} \\cdot \\frac{3 - 1}{3} \\cdot \\frac{5 - 1}{5} = 8\\)</p> <p>Aceast\u0103 formul\u0103 poate fi calculat\u0103 \u00een \\(O(\\sqrt n)\\) folosind un algoritm similar cu cel pentru aflarea divizorilor primi ai unui num\u0103r, codul de mai jos rezolv\u00e2nd problema Phi de pe pbinfo. </p> <p>Observa\u021bie</p> <p>Trebuie avut grij\u0103 s\u0103 \u00eemp\u0103r\u021bim mai \u00eent\u00e2i r\u0103spunsul la \\(i\\) \u0219i apoi s\u0103 \u00eenmul\u021bim cu \\((i-1)\\), pentru a evita un overflow care nu este necesar, dat fiind c\u0103 \\(\\varphi \\ (n) \\leq n\\).</p> <pre><code>int Phi(int n) {\n    int ans = n;\n    for (int i = 2; i * i &lt;= n; i++) {\n        if (n % i == 0) {\n            ans = ans / i;\n            ans = ans * (i-1);\n            while (n % i == 0) {\n                n /= i;\n            }\n        }\n    }\n    if (n &gt; 1) {\n        ans = ans / n;\n        ans = ans * (n-1);\n    }\n    return ans;\n}\n</code></pre>","tags":["matematica","divizori","precalculari"]},{"location":"mediu/euler-totient/#calcularea-functiei-pentru-toate-valorile-de-la-1-la-n","title":"Calcularea func\u021biei pentru toate valorile de la \\(1\\) la \\(n\\)","text":"<p>Pentru a calcula \\(\\varphi (i)\\) pentru toate valorile de la \\(1\\) la \\(n\\), tot ce trebuie s\u0103 facem este s\u0103 folosim o precalculare similar\u0103 cu cea descris\u0103 la ciurul lui Eratostene.</p> <p>Mai \u00eent\u00e2i, vom ini\u021bializa r\u0103spunsul pentru fiecare pozi\u021bie ca fiind \\(i\\), iar pentru fiecare num\u0103r prim \u00een intervalul \\([2, n]\\) (numerele prime se pot afla u\u0219or, verific\u00e2nd dac\u0103 valoarea calculat\u0103 este \u00eenc\u0103 egal\u0103 cu \\(i\\)), vom trece prin to\u021bi multiplii \u0219i vom \u00eemp\u0103r\u021bi la \\(i\\) \u0219i \u00eenmul\u021bi cu \\(i-1\\). </p> <p>Codul de mai jos rezolv\u0103 problema eratostene3 de pe pbinfo, \u00een care trebuie s\u0103 afl\u0103m pentru fiecare valoare de la intrare c\u00e2te numere sunt prime cu ea.</p> <pre><code>#include &lt;fstream&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\nconst int n = 1000000;\nint main() {\n    ifstream cin(\"eratostene3.in\");\n    ofstream cout(\"eratostene3.out\");\n\n    vector&lt;int&gt; totient(n+1);\n    for (int i = 1; i &lt;= n; i++) {\n        totient[i] = i;\n    }\n\n    for (int i = 2; i &lt;= n; i++) {\n        // daca numarul inca este prim, trecem prin multipli\n        if (totient[i] == i) { \n            for (int j = i; j &lt;= n; j += i) {\n                totient[j] /= i;\n                totient[j] *= (i-1);\n            }\n        }\n    }\n\n    int q;\n    cin &gt;&gt; q;\n\n    while (q--) {\n        int n;\n        cin &gt;&gt; n;\n\n        cout &lt;&lt; totient[n] &lt;&lt; \" \";\n    }\n    return 0;\n}\n</code></pre>","tags":["matematica","divizori","precalculari"]},{"location":"mediu/euler-totient/#aflarea-valorilor-functiei-folosind-proprietatea-sumei-divizorilor","title":"Aflarea valorilor func\u021biei folosind proprietatea sumei divizorilor","text":"<p>Gauss a descoperit o proprietate care va fi foarte util\u0103 \u00een contextul calculelor noastre viitoare \u0219i \u00een special la func\u021bia Mobius. </p> <p>$$  \\sum_{d|n} \\varphi \\ (d) = n $$\u200a</p> <p>Aceast\u0103 sum\u0103 este calculat\u0103 pentru to\u021bi divizorii lui \\(n\\).</p> <p>De exemplu, divizorii lui \\(10\\) sunt \\(1\\), \\(2\\), \\(5\\) \u0219i \\(10\\). Suma valorilor lui \\(\\varphi (i)\\) este \\(1\\) + \\(1\\) + \\(4\\) + \\(4\\) = \\(10\\).</p> <p>Folosind aceast\u0103 proprietate putem calcula toate valorilor indicatorului lui Euler \u00een \\(O(n \\log n)\\) ca la ciurul lui Eratostene, dar implementarea este una mai simpl\u0103.</p> <pre><code>void phi_1_to_n(int n) {\n    vector&lt;int&gt; phi(n + 1);\n    phi[0] = 0;\n    phi[1] = 1;\n    for (int i = 2; i &lt;= n; i++) {\n        phi[i] = i - 1;\n    }\n    for (int i = 2; i &lt;= n; i++) {\n        for (int j = 2 * i; j &lt;= n; j += i) {\n              phi[j] -= phi[i];\n        }\n    }\n}\n</code></pre>","tags":["matematica","divizori","precalculari"]},{"location":"mediu/euler-totient/#concluzii","title":"Concluzii","text":"<p>Indicatorul lui Euler este o func\u021bie care se dovede\u0219te a fi foarte important\u0103 \u00een foarte multe probleme de algoritmic\u0103, dar \u0219i mai t\u00e2rziu, odat\u0103 ce func\u021bia M\u00f6bius \u0219i teorema chinezeasc\u0103 a resturilor apar \u00een problemele mai avansate date la concursurile de programare competitiv\u0103. Aplica\u021biile acesteia \u00een algebr\u0103 \u0219i \u00een teoria numerelor pot reprezenta un bun loc de plecare pentru cei pasiona\u021bi \u0219i nu numai. </p>","tags":["matematica","divizori","precalculari"]},{"location":"mediu/euler-totient/#probleme-suplimentare","title":"Probleme suplimentare","text":"<ul> <li>fractii infoarena</li> <li>LCMSUM Spoj</li> <li>Permeuler pbinfo</li> <li>Common Divisors Codeforces</li> <li>problemele de pe CPPI Sync</li> <li>problemele de pe pbinfo</li> <li>Problemele din aceast\u0103 list\u0103 de pe Vjudge</li> </ul>","tags":["matematica","divizori","precalculari"]},{"location":"mediu/euler-totient/#lectura-suplimentara","title":"Lectur\u0103 suplimentar\u0103","text":"<ul> <li>phi function - cp-algorithms</li> <li>Indicatorul lui Euler - pbinfo</li> <li>Euler's phi function, its properties, and how to compute it - Codeforces</li> <li>Euler's totient function - wikipedia</li> <li>Func\u021bia M\u00f6bius</li> </ul>","tags":["matematica","divizori","precalculari"]},{"location":"mediu/fenwick-tree-bit/","title":"Fenwick tree bit","text":"<p>Autori: \u0218tefan-Cosmin D\u0103sc\u0103lescu, Luca Mure\u0219an</p>"},{"location":"mediu/fenwick-tree-bit/#ce-este-un-arbore-indexat-binar","title":"Ce este un arbore indexat binar?","text":"<p>Arborii indexa\u021bi binar (prescurta\u021bi de regul\u0103, AIB) sunt o structur\u0103 de date ce poate fi folosit\u0103 pentru a actualiza eficient valori \u0219i pentru a calcula sume par\u021biale \u00eentr-un tablou de valori ce poate avea una sau mai multe dimensiuni. </p> <p>De\u0219i arborii indexa\u021bi binar nu \u00eenlocuiesc vreo structur\u0103 de date propriu-zis\u0103 (tot ce poate face un AIB poate face \u0219i un arbore de intervale), marele lor avantaj este dat de faptul c\u0103 implementarea lor este foarte u\u0219oar\u0103 \u0219i constanta folosit\u0103 de ace\u0219tia este una mult redus\u0103 fa\u021b\u0103 de arborii de intervale, fiind de c\u00e2teva ori mai rapizi \u0219i consum\u00e2nd de 2-4 ori mai pu\u021bin\u0103 memorie, \u00een func\u021bie de implementare. </p>"},{"location":"mediu/fenwick-tree-bit/#cum-functioneaza-un-arbore-indexat-binar","title":"Cum func\u021bioneaz\u0103 un Arbore Indexat Binar?","text":"<p>Pentru a putea folosi un AIB, trebuie s\u0103 folosim un vector, unde aib[i] reprezint\u0103 valoarea pe care o stoc\u0103m pe pozi\u021bia \\(i\\). A\u0219a cum \u00eei zice \u0219i numele, fiecare pozi\u021bie \\(i\\) va \u021bine rezultatele pe un interval egal cu \\(2^{zeroes}\\), unde \\(zeroes\\) reprezint\u0103 num\u0103rul de zerouri de la finalul reprezent\u0103rii binare a lui \\(i\\). Aceast\u0103 expresie ne ajut\u0103 s\u0103 adun\u0103m sau s\u0103 sc\u0103dem valoarea celui mai nesemnificativ bit de \\(1\\) din \\(i\\) pentru a putea opera actualiz\u0103rile \u0219i interog\u0103rile.</p> <p>Motivul pentru care se folose\u0219te reprezentarea binar\u0103 a nodurilor este acela c\u0103 \u00een acest mod, se garanteaz\u0103 complexitatea logaritmic\u0103 a opera\u021biilor men\u021bionate mai sus (update \u0219i query), precum \u0219i \u00een practic\u0103 o constant\u0103 foarte bun\u0103 datorit\u0103 num\u0103rului redus de bi\u021bi pe care \u00eel au numerele \u00een binar. </p> <p>Observa\u021bie</p> <p>Arborii indexa\u021bi binar sunt mereu indexa\u021bi de la \\(1\\), deoarece altfel, am avea de-a face cu \\(0\\), care nu are un bit nesemnificativ egal cu \\(1\\).</p>"},{"location":"mediu/fenwick-tree-bit/#cum-functioneaza-operatia-de-update","title":"Cum func\u021bioneaz\u0103 opera\u021bia de update?","text":"<p>S\u0103 presupunem c\u0103 avem un AIB cu \\(16\\) noduri \u0219i vrem s\u0103 actualiz\u0103m valoarea de la pozi\u021bia \\(3\\). Pentru a putea face asta, vom rula urm\u0103torul algoritm, c\u00e2t timp valoarea curent\u0103 nu e mai mare dec\u00e2t num\u0103rul de noduri:</p> <ul> <li>actualiz\u0103m valoarea curent\u0103</li> <li>afl\u0103m pozi\u021bia celui mai nesemnificativ bit, s\u0103 o not\u0103m \\(lsb\\)</li> <li>adun\u0103m \\(2^{lsb}\\) la valoarea curent\u0103</li> </ul> <p>De exemplu, pentru nodul \\(3\\) vom trece prin urm\u0103toarele pozi\u021bii, dup\u0103 cum se poate vedea pe desen:</p> <ul> <li>\\(3\\) - pozi\u021bia celui mai nesemnificativ bit este \\(0\\), adun\u0103m \\(2^0 = 1\\) la   pozi\u021bie</li> <li>\\(4\\) - pozi\u021bia celui mai nesemnificativ bit este \\(2\\), adun\u0103m \\(2^2 = 4\\) la   pozi\u021bie</li> <li>\\(8\\) - pozi\u021bia celui mai nesemnificativ bit este \\(3\\), adun\u0103m \\(2^3 = 8\\) la   pozi\u021bie</li> <li>\\(16\\) - pozi\u021bia celui mai nesemnificativ bit este \\(3\\), adun\u0103m \\(2^4 = 16\\) la   pozi\u021bie, algoritmul ia sf\u00e2r\u0219it.</li> </ul> <p></p> <p>Complexitatea opera\u021biei de update este \\(O(\\log n)\\), unde \\(n\\) este dimensiunea arborelui indexat binar. </p>"},{"location":"mediu/fenwick-tree-bit/#cum-functioneaza-operatia-de-query","title":"Cum func\u021bioneaz\u0103 opera\u021bia de query?","text":"<p>\u00cen mod similar fa\u021b\u0103 de opera\u021bia de update, opera\u021bia de query va rula folosindu-se de reprezentarea binar\u0103 a pozi\u021biei de la care vrem s\u0103 facem query-ul. Este de remarcat faptul c\u0103 dac\u0103 vrem s\u0103 rul\u0103m un query pe intervalul \\([L, R]\\), va trebui s\u0103 sc\u0103dem din rezultatul ob\u021binut p\u00e2n\u0103 la pozi\u021bia \\(R\\), rezultatul ob\u021binut la pozi\u021bia \\(L - 1\\), din cauza faptului c\u0103 informa\u021bia stocat\u0103 \u00een nodurile din AIB nu este suficient de complex\u0103 pentru a putea fi ob\u021binut\u0103 cu o singur\u0103 rutin\u0103 de interogare. Totodat\u0103, aceast\u0103 abordare este similar\u0103 cu cea de la sumele par\u021biale, unde ob\u021binerea lor presupune din nou dou\u0103 calcule, \u00een loc de unul singur.</p> <p>Mai jos prezint algoritmul general \u0219i un exemplu de aplicare al acestuia, pentru valoarea \\(13\\).</p> <ul> <li>adun\u0103m la rezultat valoarea curent\u0103</li> <li>afl\u0103m pozi\u021bia celui mai nesemnificativ bit, s\u0103 o not\u0103m \\(lsb\\)</li> <li>sc\u0103dem \\(2^{lsb}\\) din valoarea curent\u0103.</li> </ul> <p>De exemplu, pentru nodul \\(13\\) vom trece prin urm\u0103toarele pozi\u021bii, dup\u0103 cum se poate vedea pe desen:</p> <ul> <li>\\(13\\) - pozi\u021bia celui mai nesemnificativ bit este \\(0\\), sc\u0103dem \\(2^0 = 1\\) din   pozi\u021bie</li> <li>\\(12\\) - pozi\u021bia celui mai nesemnificativ bit este \\(2\\), sc\u0103dem \\(2^2 = 4\\) din   pozi\u021bie</li> <li>\\(8\\) - pozi\u021bia celui mai nesemnificativ bit este \\(3\\), sc\u0103dem \\(2^3 = 8\\) din   pozi\u021bie, am ajuns la \\(0\\), deci calculul ia sf\u00e2r\u0219it.</li> </ul> <p></p> <p>Complexitatea opera\u021biei de query este \\(O(\\log n)\\), unde \\(n\\) este dimensiunea arborelui indexat binar. </p>"},{"location":"mediu/fenwick-tree-bit/#implementarea-in-c","title":"Implementarea \u00een C++","text":"<p>Un mare avantaj al arborilor indexa\u021bi binar este acela c\u0103 implementarea lor este una foarte scurt\u0103, fiind necesare doar c\u00e2teva r\u00e2nduri pentru a putea fi implementa\u021bi.</p> <pre><code>long long fenwick[100002];\nvoid update(int node, int value) {\n    for (int i = node; i &lt;= n; i += (i &amp; (-i))) {\n        fenwick[i] += value;\n    }\n}\nlong long compute(int node) {\n    long long ans = 0;\n    for (int i = node; i &gt; 0; i -= (i &amp; (-i))) {\n        ans += fenwick[i];\n    }\n\n    return ans;\n}\n</code></pre>"},{"location":"mediu/fenwick-tree-bit/#probleme-rezolvate","title":"Probleme rezolvate","text":""},{"location":"mediu/fenwick-tree-bit/#problema-inv","title":"Problema inv","text":"<p>Se d\u0103 un \u015fir \\(S\\) de lungime \\(n\\) cu numere \u00eentregi. Numim o inversiune o pereche de indici \\((i, j)\\) astfel \u00eenc\u00e2t \\(1 \\leq i &lt; j \\leq n\\) \u015fi \\(S_i &gt; S_j\\). S\u0103 se determine c\u00e2te inversiuni sunt \u00een \u015firul dat.</p> <p>Pentru a rezolva aceast\u0103 problem\u0103, putem folosi orice structur\u0103 de date ce ne permite s\u0103 actualiz\u0103m valoarea unei pozi\u021bii \u0219i s\u0103 rul\u0103m interog\u0103ri de sum\u0103 pe un interval. \u00cen cazul problemei noastre, vom vrea pentru fiecare valoare din \u0219ir s\u0103 afl\u0103m num\u0103rul de valori de la st\u00e2nga care sunt mai mari dec\u00e2t valoarea curent\u0103, lucru ce se poate realiza afl\u00e2nd pentru valoarea curent\u0103, pozi\u021bia ei \u00een \u0219irul sortat \u0219i proces\u00e2nd un query de sum\u0103 pe intervalul \\([poz + 1, n]\\), unde \\(poz\\) este pozi\u021bia \u00een vectorul sortat a celei mai din dreapta valori din \u0219ir egal\u0103 cu valoarea de la pozi\u021bia curent\u0103. </p>"},{"location":"mediu/fenwick-tree-bit/#problema-goal-statistics","title":"Problema Goal Statistics","text":"<p>Se dau \\(q\\) opera\u021bii, opera\u021bia de update adaug\u0103 o valoare egal\u0103 cu \\(k\\), iar opera\u021bia de query cere suma celor mai mici \\(p\\) valori din \u0219ir. </p> <p>Aceast\u0103 problem\u0103 este din nou un exemplu clasic de folosire a structurilor de date, iar \u00eenc\u0103 o dat\u0103, arborii indexa\u021bi binari se dovedesc a fi solu\u021bia potrivit\u0103 pentru aceast\u0103 problem\u0103, datorit\u0103 vitezei de implementare \u0219i a u\u0219urin\u021bei de folosire. Pentru a afla suma celor mai mici \\(p\\) valori din \u0219ir, vom c\u0103uta binar r\u0103spunsul, folosind o metod\u0103 similar\u0103 cu cea descris\u0103 mai sus. De\u0219i c\u0103utarea binar\u0103 naiv\u0103 \u00een \\(O(\\log^2 n)\\) ia punctajul maxim, se recomand\u0103 c\u0103utarea binar\u0103 \u00een \\(O(\\log n)\\).</p> <p>Solu\u021bia de \\(100\\)</p>"},{"location":"mediu/fenwick-tree-bit/#alte-aplicatii-si-resurse-suplimentare","title":"Alte aplica\u021bii \u0219i resurse suplimentare","text":"<ul> <li>Fenwick Tree</li> <li>Fenwick Tree</li> <li>Goal Statistics</li> <li>inv</li> <li>Understanding Fenwick Trees</li> <li>Binary Indexed   Trees</li> </ul>"},{"location":"mediu/hashing/","title":"Hashing","text":"<p>Autor: \u0218tefan-Cosmin D\u0103sc\u0103lescu</p> <p>\u00cen informatic\u0103 \u0219i \u00een algoritmic\u0103, de multe ori avem de-a face cu stocarea unei cantit\u0103\u021bi semnificative de informa\u021bie f\u0103r\u0103 s\u0103 putem s\u0103 o stoc\u0103m \u00een intregime, sau \u00een alte cazuri va trebui s\u0103 alter\u0103m informa\u021bia sau s-o organiz\u0103m diferit pentru a putea ajunge la r\u0103spunsurile c\u0103utate c\u00e2t mai rapid \u0219i eficient. \u00cen acest articol voi prezenta c\u00e2teva tipuri de probleme pentru care putem folosi tehnici care vor fi categorizate drept tehnici specifice hashingului, aici voi enumera string hashing, hash tables \u0219i alte tehnici similare, precum xor hashing sau unele fundamente din spatele structurilor de tipul hash map. Pentru a putea parcurge acest capitol, e bine s\u0103 v\u0103 familiariza\u021bi cu lucrul cu \u0219iruri de caractere \u0219i cu aritmetica modular\u0103.</p>","tags":["hashing","siruri de caractere","matematica"]},{"location":"mediu/hashing/#string-hashing","title":"String hashing","text":"<p>Se d\u0103 urm\u0103toarea problem\u0103 ce trebuie rezolvat\u0103: D\u00e2ndu-se dou\u0103 \u0219iruri de caractere, s\u0103 se afle de c\u00e2te ori apare cel de-al doilea \u0219ir \u00een primul. Aceast\u0103 problem\u0103 are diverse solu\u021bii, \u00eencep\u00e2nd de la solu\u021biile de tip brute-force care verific\u0103 naiv toate apari\u021biile unui \u0219ir \u00een cel\u0103lalt, \u0219i termin\u00e2nd cu solu\u021biile care folosesc algoritmi de potrivire a \u0219irurilor, precum KMP sau Z-function, care vor fi aborda\u021bi in alte capitole.</p> <p>\u00cen acest capitol voi prezenta o alt\u0103 abordare foarte util\u0103 pentru acest tip de probleme, \u0219i anume string hashingul. Pe scurt, vom vrea s\u0103 codific\u0103m fiecare \u0219ir de caractere cu un num\u0103r natural care s\u0103 poat\u0103 fi stocat relativ u\u0219or, \u0219i care s\u0103 ne garanteze o probabilitate c\u00e2t mai mare de succes. De ce probabilitate? Dat fiind c\u0103 avem un num\u0103r finit de numere pe care le vom putea folosi \u0219i un num\u0103r mult mai mare de \u0219iruri de caractere care se pot crea, va exista o \u0219ans\u0103 foarte mic\u0103 de a ob\u021bine un rezultat diferit de cel adev\u0103rat (cu alte cuvinte, s\u0103 consider\u0103m dou\u0103 \u0219iruri de caractere diferite ca fiind identice). Dar a\u0219a cum ve\u021bi vedea mai t\u00e2rziu, vom putea mic\u0219ora \u0219ansa de a avea o asemenea coliziune.</p>","tags":["hashing","siruri de caractere","matematica"]},{"location":"mediu/hashing/#cum-aplicam-un-hash-pe-un-sir-de-caractere","title":"Cum aplic\u0103m un hash pe un \u0219ir de caractere","text":"<p>\u00cen cazul majorit\u0103\u021bii problemelor, vom avea de-a face cu \u0219iruri de caractere ce con\u021bin litere mici sau mari ale alfabetului englez (\u00een total, \\(26\\) de litere) \u0219i care au o lungime de un ordin cel mult \\(10^6\\). Din nou, dac\u0103 apar \u0219i alte caractere, va trebui s\u0103 ajust\u0103m parametrii dupa o regul\u0103 bine precizat\u0103.</p> <p>S\u0103 presupunem pentru un moment c\u0103 putem stoca numere arbitrar de mari \u00een timp constant, put\u00e2nd s\u0103 efectu\u0103m opera\u021bii pe ele. Dat fiind c\u0103 sunt \\(26\\) de litere, ne putem g\u00e2ndi la folosirea bazei \\(26\\) pentru a stoca un num\u0103r corespunz\u0103tor unui \u0219ir de caractere, fiecare pozi\u021bie av\u00e2nd o valoare egal\u0103 cu \\(26^{n - i - 1} \\cdot ind_i\\), unde \\(n\\) este lungimea \u0219irului de caractere, \\(i\\) este pozi\u021bia caracterului curent iar \\(ind_i\\) este pozi\u021bia din alfabet (cu indexare de la \\(0\\)) a caracterului de pe pozi\u021bia \\(i\\). De exemplu, dac\u0103 \\(s_i = d\\), \\(ind_i = 3\\) (d este cea de-a patra liter\u0103 din alfabet).</p> <p>De exemplu, dac\u0103 \u0219irul de caractere este algo, num\u0103rul pe care l-am stoca ar fi egal cu</p> \\[ 26^3 \\cdot 0 + 26^2 \\cdot 11 + 26^1 \\cdot 6 + 26^0 \\cdot 14 = 7606 \\] <p>Din p\u0103cate, nu avem parte de numere infinit de mari, a\u0219a c\u0103 trebuie s\u0103 ne limit\u0103m op\u021biunile. Astfel, va trebui s\u0103 facem ajust\u0103ri \u00een ceea ce prive\u0219te baza folosit\u0103, dar \u0219i ca o noutate, vom stoca numerele modulo \\(m\\), care va fi de regul\u0103 un num\u0103r prim mare, valori potrivite sunt de regul\u0103 \\(10^9 + 7\\), \\(998 \\ 244 \\ 353\\) sau \\(10^9 + 9\\). \u00cen mod similar, vom vrea s\u0103 folosim o baz\u0103 \\(b\\) care va fi \u0219i ea un num\u0103r prim, mai mare dec\u00e2t num\u0103rul de caractere distincte pe care \u00eel putem avea (dat fiind c\u0103 avem \\(26\\) de litere, alegeri bune pentru baz\u0103 ar fi \\(29\\) sau \\(31\\)).</p> <p>Observa\u021bie</p> <p>Numerele prime sunt recomandate pentru crearea hashurilor deoarece neav\u00e2nd divizori comuni cu alte numere, riscul de a ajunge la valori egale cu \\(0\\) este mult mai sc\u0103zut, ceea ce reduce semnificativ riscul unor coliziuni.</p> <p>Un alt aspect important ce trebuie prezentat const\u0103 \u00een prezentarea modului \u00een care calcul\u0103m hashul unei subsecven\u021be a unui \u0219ir de caractere de la pozi\u021bia \\(L\\) la pozi\u021bia \\(R\\), lungimea acestuia fiind \\(R - L + 1\\). Dac\u0103 \u0219tim hashul pentru intervalul \\([1, R]\\) \u0219i hashul pentru intervalul \\([1, L-1]\\), s\u0103 le not\u0103m \\(x_R\\) \u0219i \\(x_L\\), hashul subsecven\u021bei \\([L, R]\\) va fi \\(y - x \\cdot base^{R - L + 1}\\).</p> <p>Observa\u021bie</p> <p>Deoarece \u00een majoritatea cazurilor avem de p\u0103strat valoarea modulo \\(X\\), va trebui s\u0103 fim aten\u021bi \u00een ceea ce prive\u0219te calculul hashului \u0219i evitarea valorilor negative ale opera\u021biei modulo. Acum, tot ce ne mai r\u0103m\u00e2ne de f\u0103cut e s\u0103 explic\u0103m cum s\u0103 calcul\u0103m aceste hashuri \u0219i s\u0103 putem ajusta parametrii \u00een func\u021bie de problemele care trebuie rezolvate.</p>","tags":["hashing","siruri de caractere","matematica"]},{"location":"mediu/hashing/#implementarea-si-folosirea-hashurilor","title":"Implementarea \u0219i folosirea hashurilor","text":"<p>Pentru a putea folosi hashurile, va trebui s\u0103 precalcul\u0103m mai \u00eent\u00e2i puterile bazei, p\u00e2n\u0103 la \\(n\\), unde \\(n\\) e lungimea \u0219irului de caractere. De asemenea, va trebui sa precalcul\u0103m hashurile pentru toate prefixele \u0219irului \\(s\\) folosind formula de mai sus, practic la fiecare pas vom \u00eenmul\u021bi r\u0103spunsul anterior cu baza \u0219i adun\u0103m valoarea literei noastre, \u021bin\u00e2nd cont de valoarea modulo-ului. Mai jos pute\u021bi g\u0103si chiar solu\u021bia problemei strmatch de pe infoarena, unde ni se cere s\u0103 afl\u0103m de c\u00e2te ori apare primul \u0219ir \u00een cel de-al doilea.</p> <pre><code>#include &lt;fstream&gt;\n#include &lt;string&gt;\n#include &lt;vector&gt;\n\nusing namespace std;\n\nconstexpr int base = 127;\nconstexpr int mod = 1000000007;\nconstexpr int N = 2000000;\n\nint n, m;\nlong long textHash[N + 1], power[N + 1];\n\nint main() {\n    ifstream fin(\"strmatch.in\");\n    ofstream fout(\"strmatch.out\");\n\n    string pattern, text;\n    fin &gt;&gt; pattern &gt;&gt; text;\n\n    int textLen = text.size();\n    int patternLen = pattern.size();\n\n    power[0] = 1;\n    for (int i = 1; i &lt;= N; i++) {\n        power[i] = (power[i - 1] * base) % mod;\n    }\n\n    long long patternHash = 0;\n    for (int i = 0; i &lt; patternLen; i++) {\n        patternHash *= base;\n        patternHash += pattern[i] - '0';\n        patternHash %= mod;\n    }\n\n    for (int i = 0; i &lt; textLen; i++) {\n        textHash[i + 1] = textHash[i];\n\n        textHash[i + 1] *= base;\n        textHash[i + 1] += text[i] - '0';\n        textHash[i + 1] %= mod;\n    }\n\n    int matchCount = 0;\n\n    vector&lt;int&gt; matchPositions;\n    for (int i = patternLen; i &lt;= textLen; i++) {\n        const auto endHash = textHash[i];\n        const auto startHash = textHash[i - patternLen];\n        const auto newStartHash = (startHash * power[patternLen]) % mod;\n\n        const auto currHash = (endHash - newStartHash + mod) % mod;\n\n        if (currHash == patternHash) {\n            matchCount++;\n            if (matchCount &lt;= 1000) {\n                matchPositions.push_back(i - patternLen);\n            }\n        }\n    }\n\n    fout &lt;&lt; matchCount &lt;&lt; '\\n';\n\n    for (const auto pos : matchPositions) {\n        fout &lt;&lt; pos &lt;&lt; \" \";\n    }\n    return 0;\n}\n</code></pre>","tags":["hashing","siruri de caractere","matematica"]},{"location":"mediu/hashing/#double-si-multiple-hashing","title":"Double \u0219i multiple hashing","text":"<p>\u00cen unele probleme, precum String Matching de pe CSES, folosirea unui singur hash nu garanteaz\u0103 r\u0103spunsul corect, datorit\u0103 calit\u0103\u021bii testelor. Astfel, se impune folosirea mai multor hashuri concomitent. Cu alte cuvinte, vom proceda la fel ca la un singur hash, doar c\u0103 pentru a testa egalitatea a dou\u0103 \u0219iruri de caractere de aceea\u0219i lungime, va trebui s\u0103 ne asigur\u0103m c\u0103 \u0219irurile returneaz\u0103 acela\u0219i hash pentru toate perechile de tipul \\((baz\u0103, modulo)\\) alese, perechi care trebuie s\u0103 respecte propriet\u0103\u021bile descrise mai sus.</p> <p>Un exemplu de implementare pe aceast\u0103 idee se poate g\u0103si aici, dou\u0103 hashuri fiind suficiente aici.</p> <p>\u00cen practic\u0103, cu c\u00e2t ad\u0103ug\u0103m mai multe hashuri, cu at\u00e2t probabilitatea ca noi s\u0103 nu mai avem coliziuni scade exponen\u021bial, de cele mai multe ori dou\u0103 hashuri fiind suficiente, dac\u0103 sunt alese \u00een mod potrivit.</p>","tags":["hashing","siruri de caractere","matematica"]},{"location":"mediu/hashing/#hash-tables-si-unordered-map","title":"Hash tables \u0219i unordered map","text":"<p>\u00cen anumite situa\u021bii, suntem nevoi\u021bi s\u0103 grup\u0103m valorile \u00een func\u021bie de anumite criterii, ajung\u00e2nd astfel s\u0103 avem nevoie de o structur\u0103 de date care s\u0103 poat\u0103 grupa elementele cu aceea\u0219i valoare pentru a putea procesa opera\u021bii de inserare, \u0219tergere \u0219i modificare \u00een timp rezonabil. Aici intervin tabelele hash, unde vom p\u0103stra valorile grupate \u00een func\u021bie de un criteriu ales de noi anterior (de exemplu, putem s\u0103 le grup\u0103m \u00een func\u021bie de restul \u00eemp\u0103r\u021birii la un num\u0103r prim mare, dar spre deosebire de string hashing, nu foarte mare deoarece va trebui s\u0103 p\u0103str\u0103m aceste liste separat).</p> <p>Totu\u0219i, \u00een prezent o metod\u0103 mult mai popular\u0103 \u0219i mai simplu de folosit pentru a stoca informa\u021bii legate de valori, p\u0103str\u00e2nd \u0219i eficien\u021ba proces\u0103rii acestora const\u0103 \u00een folosirea structurii de date unordered map, care func\u021bioneaz\u0103 \u00eentr-o manier\u0103 similar\u0103 cu a tabelelor hash. Practic, fiecare valoare inserat\u0103 \u00eentr-un unordered map este stocat\u0103 \u00eentr-o tabel\u0103 hash \u00een func\u021bie de valoarea unui hash intern calculat de structura de date \u00een sine. Aceast\u0103 structur\u0103 de date ne garanteaz\u0103 o complexitate foarte bun\u0103 pe un caz obi\u0219nuit, opera\u021biile fiind \u00een medie \\(O(1)\\), dar trebuie avut grij\u0103 la cazul cel mai prost, unde complexitatea unei opera\u021bii poate atinge \u0219i \\(O(n)\\), mai jos g\u0103si\u021bi un exemplu de implementare.</p> <pre><code>#include &lt;fstream&gt;\n#include &lt;iostream&gt;\n#include &lt;unordered_map&gt;\n\nusing namespace std;\n\nconstexpr enum Action { INSERT = 1, DELETE = 2, QUERY = 3 };\n\nint main() {\n    ifstream fin(\"hashuri.in\");\n    ofstream fout(\"hashuri.out\");\n\n    unordered_map&lt;int, bool&gt; fr;\n    int n;\n    fin &gt;&gt; n;\n\n    while (n--) {\n        int p, x;\n        fin &gt;&gt; p &gt;&gt; x;\n\n        switch (p) {\n            case Action::INSERT:\n                fr[x] = true;\n                break;\n            case Action::DELETE:\n                fr.erase(x);\n                break;\n            case Action::QUERY:\n                fout &lt;&lt; (fr.count(x) &gt; 0) &lt;&lt; \"\\n\";\n                break;\n            default:\n                break;\n        }\n    }\n\n    return 0;\n}\n</code></pre> <p>Observa\u021bie</p> <p>De\u0219i <code>unordered_map</code> este o structur\u0103 de date destul de eficient\u0103 \u0219i foarte util\u0103 \u00een concursuri, se recomand\u0103 evitarea ei la rundele de Codeforces, unde datorit\u0103 perioadei de open hacking de 12 ore de la rundele Div. 3, Div. 4 \u0219i educationale, solu\u021biile care folosesc <code>unordered_map</code> sunt vulnerabile hackurilor ce se folosesc de tehnicile descrise \u00een acest blog. O alternativ\u0103 const\u0103 \u00een folosirea unui hash custom, sau \u0219i mai simplu, folosirea map-ului chiar dac\u0103 pierdem un factor de \\(O(\\log n)\\). Totu\u0219i, la olimpiade nu se genereaz\u0103 de regul\u0103 teste anti-unordered map.</p>","tags":["hashing","siruri de caractere","matematica"]},{"location":"mediu/hashing/#xor-hashing","title":"Xor Hashing","text":"<p>O alt\u0103 tehnic\u0103 ce merit\u0103 men\u021bionat\u0103, dat fiind faptul c\u0103 a ap\u0103rut relativ recent, este cea a xor hashurilor. Pe scurt, modul cum func\u021bioneaz\u0103 este c\u0103 pentru fiecare valoare care apare \u00een \u0219ir (de regul\u0103, o permutare de la \\(1\\) la \\(n\\) sau \u00een general un interval de valori mici), vom vrea s\u0103 o \u00eenlocuim cu o valoare aleas\u0103 aleator \u00eentr-un \u00eenterval foarte mare (de regul\u0103, numerele \u00eentregi pe \\(32\\) de bi\u021bi).</p> <p>Aceast\u0103 tehnic\u0103 ne ajut\u0103 s\u0103 putem afla cu u\u0219urin\u021b\u0103 dac\u0103 un set de numere \u00eentr-un anumit interval apare \u00eentr-o subsecven\u021b\u0103 sau \u00eentr-un \u0219ir de numere (de regul\u0103, problemele se reduc la a afla dac\u0103 valorile dintr-un interval de numere formeaz\u0103 o permutare a mul\u021bimii \\(\\{1, 2, \\dots, n\\}\\).</p>","tags":["hashing","siruri de caractere","matematica"]},{"location":"mediu/hashing/#exemplu-mixperm-lot-juniori-2017","title":"Exemplu: mixperm lot juniori 2017","text":"<p>Pentru aceast\u0103 problem\u0103, se poate observa c\u0103 este un exemplu clasic al folosirii tehnicii xor hashing (solu\u021bia oficial\u0103 folose\u0219te o combina\u021bie de propriet\u0103\u021bi matematice) deoarece putem genera un num\u0103r aleator pentru fiecare valoare de la \\(1\\) la \\(n\\) iar mai apoi c\u00e2nd verific\u0103m fiecare secven\u021b\u0103 brut, folosim valorile xor-urilor par\u021biale pentru a determina cu o probabilitate de aproximativ \\(100 \\%\\) dac\u0103 ob\u021binem o permutare a mul\u021bimii \\(\\{1, 2, \\dots, n\\}\\). O surs\u0103 demonstrativ\u0103 se poate g\u0103si mai jos, submisia put\u00e2nd fi accesat\u0103 aici sau mai jos.</p> <pre><code>#include &lt;chrono&gt;\n#include &lt;fstream&gt;\n#include &lt;iostream&gt;\n#include &lt;random&gt;\n\nusing namespace std;\n\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\nconst int randgen(int left = 1, int right = 1000000000) {\n    return uniform_int_distribution&lt;int&gt;(left, right)(rng);\n}\n\nconstexpr int N = 10000;\n\nint hsh[N + 5], a[N + 5], b[N + 5];\n\nint prefa[N + 5], prefb[N + 5];\nint suffa[N + 5], suffb[N + 5];\n\nint main() {\n    ifstream fin(\"mixperm.in\");\n    ofstream fout(\"mixperm.out\");\n\n    int n;\n    fin &gt;&gt; n;\n\n    int xr = 0;\n\n    for (int i = 1; i &lt;= n; i++) {\n        hsh[i] = randgen();\n        xr ^= hsh[i];\n    }\n\n    for (int i = 1; i &lt;= n; i++) {\n        fin &gt;&gt; a[i];\n    }\n\n    for (int i = 1; i &lt;= n; i++) {\n        fin &gt;&gt; b[i];\n    }\n\n    for (int i = 1; i &lt;= n; i++) {\n        prefa[i] = prefa[i - 1] ^ hsh[a[i]];\n        prefb[i] = prefb[i - 1] ^ hsh[b[i]];\n\n        const int j = n - i + 1;\n        suffa[j] = suffa[j + 1] ^ hsh[a[j]];\n        suffb[j] = suffb[j + 1] ^ hsh[b[j]];\n    }\n\n    int ans = 0;\n    for (int i = 1; i &lt;= n; i++) {\n        for (int j = i; j &lt;= n; j++) {\n            const int secva = prefa[j] ^ prefa[i - 1];\n            const int secvb = prefb[j] ^ prefb[i - 1];\n\n            const int suffa_xor = suffa[j + 1];\n            const int suffb_xor = suffb[j + 1];\n\n            if ((prefa[i - 1] ^ secvb ^ suffa_xor) == xr ||\n                (prefb[i - 1] ^ secva ^ suffb_xor) == xr) {\n                ans++;\n            }\n        }\n    }\n\n    fout &lt;&lt; ans &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["hashing","siruri de caractere","matematica"]},{"location":"mediu/hashing/#probleme-suplimentare","title":"Probleme suplimentare","text":"","tags":["hashing","siruri de caractere","matematica"]},{"location":"mediu/hashing/#probleme-de-la-olimpiade","title":"Probleme de la olimpiade","text":"<ul> <li>subsecvente OJI 2013</li> <li>Carry Bit IIOT 2023-24</li> <li>sp Lot juniori 2021</li> <li>mixperm Lot juniori 2017</li> <li>Palindrome String</li> <li>sap RoAlgo Contest 6 - XOR Hashing</li> <li>toska Stelele Informaticii - XOR Hashing</li> <li>Bovine Genomics   USACO</li> <li>RMI 2017 Hangman   2</li> <li>Probleme cu hashing de pe kilonova</li> <li>Probleme cu hashing de pe   infoarena</li> </ul>","tags":["hashing","siruri de caractere","matematica"]},{"location":"mediu/hashing/#probleme-de-pe-alte-siteuri","title":"Probleme de pe alte siteuri","text":"<ul> <li>Finding Periods</li> <li>Sum of Four Values</li> <li>Fullmetal Alchemist II</li> <li>Mysterious Crime</li> <li>The Number of Subpermutations</li> <li>Alte probleme cu hashing de pe   Codeforces</li> </ul>","tags":["hashing","siruri de caractere","matematica"]},{"location":"mediu/hashing/#bibliografie-si-lectura-suplimentara","title":"Bibliografie \u0219i lectur\u0103 suplimentar\u0103","text":"<p>Am ordonat resursele suplimentare \u00een ordinea dificult\u0103\u021bii \u00een\u021belegerii \u0219i \u00eentr-o ordine logic\u0103 pentru a u\u0219ura ob\u021binerea de cuno\u0219tinte despre tehnicile, abord\u0103rile \u0219i problemele discutate \u00een acest curs.</p> <ul> <li>Cartea SEPI F1 - Capitolul 12 (pagina 171) - C\u0103ut\u0103ri \u00een \u0219iruri de caractere.   Algoritmul Rabin-Karp - Articol   Recomandat</li> <li>Articol USACO Guide - String   Hashing</li> <li>Articol USACO Guide - Hash maps</li> <li>XOR Hashing TUTORIAL</li> <li>On the mathematics behind rolling hashes and anti-hash   tests</li> <li>Articolul de pe cppi.sync</li> <li>Hash tables</li> <li>Hash tables - prezentare   detaliata</li> </ul>","tags":["hashing","siruri de caractere","matematica"]},{"location":"mediu/intro-combinatorics/","title":"Introducere \u00een combinatoric\u0103","text":"<p>Autori: \u0218tefan-Cosmin D\u0103sc\u0103lescu, \u0218tefan-Iulian Alecu</p> <p>Combinatorica este una din ramurile principale ale matematicii, precum \u0219i una din cele patru ramuri din care se dau problemele de la olimpiada interna\u021bional\u0103 de matematic\u0103 (IMO) celelalte fiind algebra, teoria numerelor \u0219i geometria. \u00cen algoritmic\u0103 \u0219i \u00een programarea competitiv\u0103, combinatorica se reg\u0103se\u0219te \u00een probleme de nivel mediu \u0219i ridicat, aplica\u021biile diverselor formule matematice, precum \u0219i tehnicile de rezolvare ale problemelor de combinatoric\u0103 fiind un pas important spre des\u0103v\u00e2r\u0219irea abilit\u0103\u021bilor de rezolvare a problemelor algoritmice, deoarece spre deosebire de alte capitole, combinatorica este mai greu de antrenat, iar experien\u021ba c\u0103p\u0103tat\u0103 prin rezolvarea problemelor se va dovedi a fi una crucial\u0103.</p> <p>\u00cen acest capitol vom prezenta cele mai importante formule specifice combinatoricii, o serie de identit\u0103\u021bi \u0219i rela\u021bii care sunt folosite \u00een foarte multe probleme de algoritmic\u0103, precum \u0219i diverse tehnici care au scopul s\u0103 v\u0103 ajute pentru a putea \u00een\u021belege formulele necesare, precum \u0219i s\u0103 v\u0103 ajute pentru a putea rezolva problemele de acest fel \u00eentr-un mod c\u00e2t mai u\u0219or \u0219i intuitiv. \u00cen cadrul olimpiadelor \u0219i concursurilor de informatic\u0103 din Rom\u00e2nia, combinatorica se reg\u0103se\u0219te drept parte esen\u021bial\u0103 \u00een dou\u0103 competi\u021bii - lotul de juniori \u0219i olimpiada clasei a zecea. Ulterior, poate s\u0103 se reg\u0103seasc\u0103 \u0219i ca subprobleme la probele ulterioare de seniori, \u00eentr-o m\u0103sur\u0103 mai mic\u0103.</p> <p>Pentru a putea parcurge acest capitol, recomand\u0103m citirea \u00een prealabil a articolelor despre aritmetica modular\u0103, divizibilitate \u0219i \u00een general s\u0103 ave\u021bi o \u00een\u021belegere a conceptelor matematice din capitolele anterioare. Va fi foarte important\u0103 \u0219i \u00een\u021belegerea conceptului de invers modular, deoarece de\u0219i \u00een cele mai multe probleme vom avea de-a face cu modulo numere prime, uneori va trebui s\u0103 \u0219tim s\u0103 implement\u0103m \u0219i inversul modular.</p>","tags":["matematica","combinatorica","teoria numerelor","permutari","aranjamente","combinari"]},{"location":"mediu/intro-combinatorics/#notiuni-teoretice-fundamentale","title":"No\u021biuni teoretice fundamentale","text":"","tags":["matematica","combinatorica","teoria numerelor","permutari","aranjamente","combinari"]},{"location":"mediu/intro-combinatorics/#regula-sumei-si-a-produsului","title":"Regula sumei \u0219i a produsului","text":"<p>Presupunem pentru urm\u0103toarele dou\u0103 reguli c\u0103 avem dou\u0103 mul\u021bimi \\(A\\) \u0219i \\(B\\) disjuncte (adic\u0103 \\(A\\cap B =\\emptyset\\)), av\u00e2nd cardinalul \\(|A| = n\\) \u0219i \\(|B| = m\\).</p> <p>Regula sumei</p> <p>Num\u0103rul de moduri de a alege o valoare din \\(A\\) sau \\(B\\) este \\(n+m\\).</p> <p>Regula produsului</p> <p>Num\u0103rul de moduri de a alege o pereche de valori, una din \\(A\\) \u0219i una din \\(B\\) este \\(n\\cdot m\\).</p> <p>Exemplu</p> <p>C\u00e2te numere de forma \\(\\overline{aba}\\) cu \\(a \\neq 0\\) i \\(a \\neq b\\) exist\u0103?</p> <p>Valorile posibile pentru \\(a\\) sunt \\(\\{1, 2, 3, \\dots, 9}\\), iar valorile posibile ale lui \\(b\\) sunt \\(\\{0, 1, 2, 3, \\dots, 9}\\). </p> <p>Avem \\(9\\) variante de a alege o valoare pentru \\(a\\), iar pentru \\(b\\) avem tot \\(9\\) variante (\\(10\\), din care excludem cea egala cu \\(a\\)), astfel num\u0103rul total de variante este \\(9 \\cdot 9 = 81\\).</p> <p>Aceste rela\u021bii vor fi foarte importante mai ales c\u00e2nd avem de-a face cu formule independente care contribuie la r\u0103spunsul final.</p>","tags":["matematica","combinatorica","teoria numerelor","permutari","aranjamente","combinari"]},{"location":"mediu/intro-combinatorics/#permutari","title":"Permut\u0103ri","text":"<p>Permutare</p> <p>O permutare a unei mul\u021bimi reprezint\u0103 o aranjare a elementelor dintr-o mul\u021bime \\(M\\) finit\u0103 \u00eentr-o ordine diferit\u0103. Dac\u0103 cardinalul mul\u021bimii \\(|M| = n\\), num\u0103rul de permut\u0103ri ale unei mul\u021bimi de \\(n\\) valori este \\(n!\\).</p> <p>De exemplu, pentru \\(n = 3\\), cele \\(6\\) permut\u0103ri ale mul\u021bimii \\(\\{1, 2, 3\\}\\) sunt urm\u0103toarele: \\(\\{1, 2, 3\\}\\), \\(\\{1, 3, 2\\}\\), \\(\\{2, 1, 3\\}\\), \\(\\{2, 3, 1\\}\\), \\(\\{3, 1, 2\\}\\),  \\(\\{3, 2, 1\\}\\)</p> <p>\u00cen probleme, exist\u0103 diverse cazuri particulare ale permut\u0103rilor care devin foarte utile \u00een rezolvarea unor probleme de combinatoric\u0103.</p> <p>Deranjamente</p> <p>Un deranjament este o permutare f\u0103r\u0103 puncte fixe, adic\u0103 \\(\\forall i\\), \\(p_i\\neq i\\).</p> <p>Num\u0103rul de deranjamente cu \\(n\\) elemente este egal cu \\(D_n = (n-1)\\cdot (D_{n-1} + D_{n-2})\\), unde \\(D_0 = 1\\) \u0219i \\(D_1 = 0\\). Acest concept a fost util printre altele la rezolvarea problemei Poseidon, dat\u0103 la OJI 2024, clasa a X-a.</p> <p>Permut\u0103ri cu repeti\u021bii</p> <p>Definim o permutare cu repeti\u021bii ca fiind o secven\u021b\u0103 de \\(n\\) numere, care are  proprietatea c\u0103 fiecare valoare este \u00een intervalul \\([1, n]\\) \u0219i valorile se  pot repeta. Num\u0103rul de permut\u0103ri cu repeti\u021bie cu aceste propriet\u0103\u021bi care au  \\(n\\) elemente este</p> \\[ \\frac{n!}{F_1!\\cdot F_2!\\cdot\\dots\\cdot F_n!} = n!\\prod_{k = 1}^{n}\\frac{1}{F_k!} \\] <p>unde \\(F_i\\) reprezint\u0103 frecven\u021ba la care apare \\(i\\) \u00een permutare.  Acest concept se reg\u0103se\u0219te \u00eentr-un num\u0103r de probleme date \u00een special la  loturile de juniori.</p> <p>Mai jos pute\u021bi g\u0103si o secven\u021b\u0103 de cod pe care o putem folosi pentru a genera toate permut\u0103rile unui \u0219ir. Func\u021bia <code>std::next_permutation</code> nu va genera permut\u0103ri cu repeti\u021bie dac\u0103 acestea apar de mai multe ori.</p> <pre><code>vector&lt;int&gt; v(10);\n\nint i = 1;\n\nfor (auto&amp; x : v) {\n    x = i++;\n}\n\ndo {\n    afiseaza(v);\n} while (next_permutation(v.begin(), v.end()));\n</code></pre>","tags":["matematica","combinatorica","teoria numerelor","permutari","aranjamente","combinari"]},{"location":"mediu/intro-combinatorics/#submultimi","title":"Submul\u021bimi","text":"<p>O submul\u021bime a unui num\u0103r const\u0103 \u00een alegerea unui num\u0103r de elemente dintr-o mul\u021bime \\(M\\). Num\u0103rul de submul\u021bimi ale lui \\(M\\) este egal cu \\(2^{|M|}\\), deoarece pentru fiecare element al mul\u021bimii, putem alege dac\u0103 s\u0103 \u00eel includem \u00een submul\u021bimea pe care vrem s\u0103 o cre\u0103m sau nu.</p> <p>Dac\u0103 mul\u021bimea \\(M\\) este egal\u0103 cu \\(\\{0, 1, 1\\}\\), cele \\(8\\) submul\u021bimi ale ei sunt urm\u0103toarele: \\(\\emptyset\\), \\(\\{0\\}\\), \\(\\{0, 1\\}\\), \\(\\{0, 1, 2\\}\\), \\(\\{0, 2\\}\\), \\(\\{1\\}\\), \\(\\{1, 2\\}\\), \\(\\{2\\}\\).</p> <p>Pentru a putea itera prin toate submul\u021bimile unei mul\u021bimi date, ne putem folosi de faptul c\u0103 fiind \\(2^n\\) asemenea submul\u021bimi, putem identifica fiecare submul\u021bime folosind una din reprezent\u0103rile binare ale numerelor de la \\(0\\) la \\(2^n - 1\\), tehnic\u0103 numit\u0103 colocvial bitmasks sau m\u0103\u0219ti pe bi\u021bi. Pentru a vedea dac\u0103 trebuie s\u0103 folosim unul din numere sau nu, trebuie doar verificat pentru o submul\u021bime dat\u0103 dac\u0103 bitul corespunz\u0103tor acelei pozi\u021bii este setat sau nu \u00een masca pe care o verific\u0103m. Pentru mai multe detalii, pute\u021bi vedea codul de mai jos.</p> <pre><code>const int totalSubsets = 1 &lt;&lt; n; // 2^n\n\nfor (int mask = 0; mask &lt; totalSubsets; ++mask) {\n    vector&lt;int&gt; subset;\n\n    for (int idx = 0; idx &lt; n; ++idx) {\n        if (mask &amp; (1 &lt;&lt; idx)) { // (1)\n            subset.push_back(idx);\n        }\n    }\n\n    process(subset);\n}\n</code></pre> <ol> <li>Dac\u0103 bitul din masc\u0103 la pozi\u021bia \\(idx\\) este setat, \u00eenseamn\u0103 c\u0103 elementul de la     indice este prezent \u0219i deci ad\u0103ug\u0103m indicele \u00een submul\u021bime. </li> </ol>","tags":["matematica","combinatorica","teoria numerelor","permutari","aranjamente","combinari"]},{"location":"mediu/intro-combinatorics/#aranjamente","title":"Aranjamente","text":"<p>Un aranjament de \\(n\\) elemente luate c\u00e2te \\(k\\) reprezint\u0103 o submul\u021bime ordonat\u0103 a lui \\(A\\) de \\(k\\) elemente. De exemplu, aranjamente de \\(4\\) luate c\u00e2te \\(3\\) ale mul\u021bimii \\(\\{1, 2, 3, 4\\}\\) sunt urm\u0103toarele: \\(\\{1, 2, 3\\}\\), \\(\\{1, 2, 4\\}\\), \\(\\{1, 3, 4\\}\\), \\(\\{2, 1, 3\\}\\), \\(\\{2, 1, 4\\}\\), \\(\\{2, 3, 4\\}\\), \\(\\{3, 1, 2\\}\\), \\(\\{3, 1, 4\\}\\), \\(\\{3, 2, 4\\}\\), \\(\\{4, 1, 2\\}\\), \\(\\{4, 1, 3\\}\\), \\(\\{4, 2, 3\\}\\)</p> <p>Similar permut\u0103rilor, aranjamentele pot fi considerate func\u021bii injective definite pe mul\u021bimea \\(\\{1, 2, 3,\\dots, k\\}\\) cu valori \u00een \\(\\{1, 2, 3,\\dots, n\\}\\)</p> <p>Num\u0103rul aranjamentelor de \\(n\\) luate c\u00e2te \\(k (k\\leq n)\\) se noteaz\u0103 cu \\(A_n^k\\) \u0219i este egal cu \\(\\(\\frac{n!}{(n-k)!}\\)\\)</p> <p>O alt\u0103 formul\u0103 care poate fi util\u0103 \u00een special \u00een cazul precalcul\u0103rilor este \\(A_n^k = (n - k + 1)\\cdot A_n^{k-1}\\)</p>","tags":["matematica","combinatorica","teoria numerelor","permutari","aranjamente","combinari"]},{"location":"mediu/intro-combinatorics/#combinari","title":"Combin\u0103ri","text":"<p>O combinare de \\(n\\) elemente luate c\u00e2te \\(k\\) reprezint\u0103 o submul\u021bime neordonat\u0103 a lui \\(A\\) de \\(k\\) elemente. De exemplu, combin\u0103rile de \\(4\\) luate c\u00e2te \\(3\\) ale mul\u021bimii \\(\\{1, 2, 3, 4\\}\\) sunt urm\u0103toarele: \\(\\{1, 2, 3\\}\\), \\(\\{1, 2, 4\\}\\), \\(\\{1, 3, 4\\}\\), \\(\\{2, 3, 4\\}\\)</p> <p>Se poate observa c\u0103 spre deosebire de aranjamente, dac\u0103 dou\u0103 mul\u021bimi au acelea\u0219i elemente dar \u00eentr-o ordine diferit\u0103, se num\u0103r\u0103 o singur\u0103 dat\u0103.</p> <p>Formula pentru combin\u0103ri de \\(n\\) luate c\u00e2te \\(k\\), care se noteaz\u0103 cu \\(C_n^k\\) (alternativ, ve\u021bi mai putea g\u0103si nota\u021bii precum \\({}_{n}C_{k}\\), \\(C(n, k)\\) sau \\(\\binom{n}{k}\\) este  $$ C_n^k = \\frac{n!}{k!\\cdot (n-k)!} $$ unde \\(C_0^0 = C_n^n = 1\\).</p> <p>Exist\u0103 numeroase moduri \u0219i propriet\u0103\u021bi de a lega valoarea lui \\(C_n^k\\) de alte valori combinatoriale, cele mai importante fiind urm\u0103toarele:</p> <ul> <li>\\(C_{n}^{k} =C_{n-1}^{k} +C_{n-1}^{k-1}\\), deoarece:</li> </ul> \\[ \\begin{align*} C_n^k = \\frac{n!}{k! (n-k)!} &amp;= \\frac{n(n - 1)!}{k! (n-k)!}\\\\ &amp;= \\frac{k(n - 1)!}{k!  (n - k)!} + \\frac{(n-k)(n - 1)!}{k!  (n - k)!}\\\\ &amp;= \\frac{(n - 1)!}{(k - 1)!  (n - k)!} + \\frac{(n - 1)!}{k!  (n - k - 1)!}\\\\ &amp;= C_{n-1}^{k-1} +C_{n-1}^{k} \\end{align*} \\] <ul> <li>Dac\u0103 simplific\u0103m frac\u021biile din formula de mai sus, putem scrie \\(C_n^k\\) ca fiind  $$ C_n^k = \\prod_{i=1}^{k}\\frac{n-i+1}{i} =\\frac{(n-k+1)\\cdot (n-(k - 1) + 1)\\cdots(n-1)\\cdot n}{1\\cdot 2\\cdot 3\\cdots\\cdot k} $$</li> <li>\\(C_{n}^{k} = C_{n}^{n-k}\\), fapt ce se poate observa din aplicarea formulei specifice.</li> <li>\\(\\sum_{i=0}^{n} C_n^i = 2^n\\)</li> </ul> <p>De multe ori, pentru a calcula combin\u0103rile, vom folosi triunghiul lui Pascal drept precalculare, fapt ce \u00eel putem realiza cu ajutorul formulei de mai sus care leag\u0103 \\(C_{n}^{k}\\) de \\(C_{n-1}^{k}\\) \u0219i \\(C_{n-1}^{k-1}\\).</p> <pre><code>const int N = 1000;\n\nint C[N + 1][N + 1];\n\nC[0][0] = 1;\n\nfor (int n = 1; n &lt;= N; n++) {\n    C[n][0] = 1;\n\n    for (int k = 1; k &lt;= n; k++) {\n        if (n == k) {\n            C[n][k] = 1;\n        } else {\n            C[n][k] = C[n-1][k] + C[n-1][k-1];\n        }\n    }\n}\n</code></pre> <p>Exist\u0103 o metod\u0103 mai eficient\u0103 de a calcula \\(C_n^k\\) \u00een timp \\(O(k)\\) \u0219i spa\u021biu \\(O(1)\\):</p> <pre><code>const long long C(int n, int k) {\n    long long res = 1;\n\n    // C(n, k) = C(n, n-k)\n    if (k &gt; n - k) {\n        k = n - k;\n    }\n\n    for (int i = 0; i &lt; k; ++i) {\n        res *= (n - i);\n        res /= (i + 1);\n    }\n\n    return res;\n}\n</code></pre> <p>\u00cen alte situa\u021bii, va trebui s\u0103 precalcul\u0103m factorialele \u0219i inversele modulare pentru a putea calcula combin\u0103rile, a\u0219a cum vom ar\u0103ta mai jos. Dac\u0103 nu sunte\u021bi familiari cu ridicarea la putere \u00een timp logaritmic, v\u0103 rug\u0103m s\u0103 citi\u021bi articolul pe aceast\u0103 tem\u0103.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nconst int MOD = 998244353;\nconst int N = 100000;\n\nlong long fact[N + 1], inv[N + 1];\n\nconst long long modpow(long long base, long long exponent) {\n    long long result = 1;\n    while (exponent) {\n        if (exponent &amp; 1) {\n            result = (result * base) % MOD;\n        }\n        base = (base * base) % MOD;\n        exponent &gt;&gt;= 1;\n    }\n    return result;\n}\n\nconst long long C(const int n, const int k) {\n    if (k &gt; n || k &lt; 0) {\n        return 0;\n    }\n\n    // C(n, k) = n! * (k!)^-1 * (n - k)!^-1\n    long long result = fact[n];\n    result *= inv[k]; \n    result %= MOD;\n    result *= inv[n - k]; \n    result %= MOD;\n    return result;\n}\n\nvoid precalc() {\n    fact[0] = 1;\n    inv[0] = 1;\n\n    for (int i = 1; i &lt;= N; i++) {\n        fact[i] = (fact[i - 1] * i) % MOD;\n    }\n\n    inv[N] = modpow(fact[N], MOD - 2, MOD); // (1)\n    for (int i = N - 1; i &gt;= 0; --i) {\n        inv[i] = (inv[i + 1] * (i + 1)) % MOD;\n    }\n}\n\n1.  Calcul\u0103m inversul modular $x^{-1} \\mod p$ ($p$ este `MOD` \u00een cod). \u00cen cazul \n    \u00een care $p$ este prim, conform micii teoreme a lui Fermat, $x^{-1} = x^{p - 2}$.\n\nint main() {\n    precalc();\n\n    int n, k;\n    cin &gt;&gt; n &gt;&gt; k;\n    cout &lt;&lt; C(n, k);\n    return 0;\n}\n</code></pre>","tags":["matematica","combinatorica","teoria numerelor","permutari","aranjamente","combinari"]},{"location":"mediu/intro-combinatorics/#partitii","title":"Parti\u021bii","text":"<p>Numim parti\u021bie a unui num\u0103r \\(n\\) o secven\u021b\u0103 de numere naturale nenule \\(P\\) cu proprietatea c\u0103 \\(\\sum_{i = 1}^k P_i = n\\), unde \\(k\\) este num\u0103rul de numere din parti\u021bie. Parti\u021biile unui num\u0103r pot fi ordonate sau neordonate, \u00een func\u021bie de proprietatea pe care dorim s\u0103 o aplic\u0103m \u00eentr-o problem\u0103.</p> <p>Pentru a afla num\u0103rul de parti\u021bii ordonate ale unui num\u0103r \\(n\\), putem s\u0103 ne g\u00e2ndim la num\u0103rul de moduri de a \u00eemp\u0103r\u021bi \\(n\\) stele folosind diferite bare (anticip\u0103m \u00eentr-o oarecare m\u0103sur\u0103 discu\u021bia pe care o vom avea la Stars and Bars), iar dat fiind c\u0103 avem \\(n-1\\) pozi\u021bii unde putem face o \u00eemp\u0103r\u021bire, iar pentru fiecare pozi\u021bie avem posibilitatea de a pune o limit\u0103 sau nu, cu alte cuvinte avem \\(2^{n-1}\\) parti\u021bii ordonate ale unui num\u0103r \\(n\\).</p> <p>\u00cen privin\u021ba parti\u021biilor neordonate, deoarece trebuie s\u0103 p\u0103str\u0103m proprietatea c\u0103 numerele din parti\u021bie sunt cresc\u0103toare, trebuie s\u0103 avem grij\u0103 la calculul num\u0103rului de parti\u021bii de acest tip, iar o prim\u0103 solu\u021bie la aceast\u0103 problem\u0103 const\u0103 \u00een folosirea unei recuren\u021be de tipul \\(p(i, j)\\) = num\u0103rul de parti\u021bii neordonate ale lui \\(i\\), unde lungimea acesteia este \\(j\\). Pentru a putea calcula aceast\u0103 recuren\u021b\u0103, avem o formul\u0103 relativ simpl\u0103.</p> <ul> <li>\\(p(i, j) = p(i-1, j-1) + p(i-j, j)\\), dac\u0103 \\(i\\geq 1\\) \u0219i \\(j\\geq 1\\) (cu alte   cuvinte, fie ad\u0103ug\u0103m un \\(1\\) la \u00eenceputul parti\u021biei, fie increment\u0103m toate   elementele din parti\u021bie).</li> <li>\\(p(i, 0) = 0\\), pentru \\(i\\geq 1\\)</li> <li>\\(p(0, 0) = 1\\).</li> </ul> <p>Complexitatea acestei recuren\u021be este \\(n^2\\), optimizarea ei fiind imposibil\u0103 folosind aceast\u0103 abordare. Din fericire, exist\u0103 o metod\u0103 \u0219i mai rapid\u0103, care folose\u0219te numere pentagonale, abordare ce ne duce la o solu\u021bie \u00een \\(O(n\\sqrt n)\\), pentru mai multe detalii pute\u021bi accesa acest articol sau rezolva problema cresc\u0103tor2. </p>","tags":["matematica","combinatorica","teoria numerelor","permutari","aranjamente","combinari"]},{"location":"mediu/intro-combinatorics/#trucuri-pentru-rezolvarea-problemelor-de-combinatorica","title":"Trucuri pentru rezolvarea problemelor de combinatoric\u0103","text":"","tags":["matematica","combinatorica","teoria numerelor","permutari","aranjamente","combinari"]},{"location":"mediu/intro-combinatorics/#stars-and-bars","title":"Stars and Bars","text":"<p>Tehnica stars and bars este o tehnic\u0103 folosit\u0103 pentru a determina diverse sume combinatoriale care se reduc la aflarea num\u0103rului de solu\u021bii ale ecua\u021biei \\(x_1 + x_2 + ... + x_k = n\\), unde \\(x_i\\) este fie num\u0103r natural pozitiv, fie num\u0103r \u00eentreg non-negativ, reg\u0103sindu-se dou\u0103 cazuri.</p> <p>Num\u0103rul de moduri de a \u00eemp\u0103r\u021bi \\(n\\) obiecte \u00een \\(k\\) grupe, fiecare grup\u0103 av\u00e2nd cel pu\u021bin un element este egal cu \\(C_{n-1}^{k-1}\\), deoarece avem \\(n-1\\) locuri unde putem pune barierele \u0219i trebuie s\u0103 punem \\(k-1\\) bariere pentru a ob\u021bine \\(k\\) grupe.</p> <p>Num\u0103rul de moduri de a \u00eemp\u0103r\u021bi \\(n\\) obiecte \u00een \\(k\\) grupe, dac\u0103 fiecare grup\u0103 poate fi \u0219i goal\u0103 cu \\(C_{n+k-1}^{k-1}\\), deoarece avem \\(n+k-1\\) locuri unde putem pune barierele \u0219i trebuie s\u0103 punem \\(k-1\\) bariere pentru a ob\u021bine \\(k\\) grupe.</p> <p>Aceast\u0103 tehnic\u0103 se g\u0103se\u0219te \u00een diferite aplica\u021bii, de obicei atunci c\u00e2nd vrem s\u0103 grup\u0103m diferite valori sau diferite \u0219iruri, \u00een problemele de num\u0103rare.</p>","tags":["matematica","combinatorica","teoria numerelor","permutari","aranjamente","combinari"]},{"location":"mediu/intro-combinatorics/#hockey-stick-identity","title":"Hockey Stick Identity","text":"<p>Pentru dou\u0103 numere \\(n\\) \u0219i \\(r\\), \\(\\sum_{i=r}^{n} C_i^r = C_{n+1}^{r+1}\\). Pentru a demonstra aceast\u0103 rela\u021bie, se pot folosi argumente inductive, algebrice sau metode ce se folosesc de func\u021bii generatoare. Pentru mai multe detalii, pute\u021bi citi acest blog.</p>","tags":["matematica","combinatorica","teoria numerelor","permutari","aranjamente","combinari"]},{"location":"mediu/intro-combinatorics/#numerele-catalan","title":"Numerele Catalan","text":"<p>\u00cen combinatoric\u0103, numerele Catalan sunt o serie de numere care apar \u00een diverse probleme, devenind foarte cunoscute \u0219i folosite \u00een aplica\u021bii ce se g\u0103sesc de multe ori la olimpiadele de informatic\u0103 pentru juniori.</p> <p>\u0218irul numerelor Catalan este \\(1, 1, 2, 5, 14, 42, \\dots\\) \u0219i formula pentru aflarea celui de-al \\(i\\)-lea num\u0103r Catalan este:</p> \\[ C_n = \\frac{1}{n+1}\\cdot C_{2n}^{n} =\\frac{(2n)!}{(n+1)! n!} = \\prod_{k = 2}^{n} \\frac{n + k}{k} \\] <p>Computa\u021bional vorbind, se folose\u0219te deseori forma recursiv\u0103, cu \\(C_0 = 1\\) \u0219i $$ C_n = \\sum_{i = 1}^n C_{i - 1}C_{n - i} = \\frac{2(2n - 1)}{n + 1} C_{n - 1} $$</p> <p>Printre altele, numerele Catalan apar \u00een aplica\u021bii precum:</p> <ul> <li>Num\u0103rul de arbori binari cu \\(n\\) noduri.</li> <li>Num\u0103rul de parantez\u0103ri corecte de lungime \\(2n\\).</li> <li>Num\u0103rul de drumuri de la \\((0, 0)\\) la \\((n, n)\\) care merg \u00een sus \u0219i la dreapta   f\u0103r\u0103 s\u0103 treac\u0103 de partea cealalt\u0103 a diagonalei principale.</li> <li>\u0218i multe altele, pe care le pute\u021bi g\u0103si   aici</li> </ul> <p>A\u0219a se calculeaz\u0103 num\u0103rul Catalan:</p> Calcul cu C(n, k)Calcul cu DPCalcul direct <pre><code>const unsigned long long C(int n, int k) {\n    unsigned long long res = 1;\n\n    // C(n, k) = C(n, n-k)\n    if (k &gt; n - k) {\n        k = n - k;\n    }\n\n    for (int i = 0; i &lt; k; ++i) {\n        res *= (n - i);\n        res /= (i + 1);\n    }\n\n    return res;\n}\n\nconst unsigned long long catalan(int n) {\n    return C(2 * n, n) / (n + 1);\n}\n</code></pre> <pre><code>unsigned long long catalan(unsigned int n)\n{\n    unsigned long long C[n + 1];\n\n    C[0] = C[1] = 1;\n\n    for (int i = 2; i &lt;= n; i++) {\n        C[i] = 0;\n        for (int j = 0; j &lt; i; j++)\n            C[i] += C[j] * C[i - j - 1];\n    }\n\n    return C[n];\n}\n</code></pre> <pre><code>const unsigned long long catalan(int n) {\n    unsigned long long res = 1;\n\n    for (int i = 1; i &lt;= n; ++i) {\n        res *= 2 * (2 * i - 1);\n        res /= (i + 1);\n    }\n\n    return res;\n}\n</code></pre>","tags":["matematica","combinatorica","teoria numerelor","permutari","aranjamente","combinari"]},{"location":"mediu/intro-combinatorics/#numerele-stirling","title":"Numerele Stirling","text":"<p>La fel ca \u0219i numerele Catalan, numerele Stirling \u0219i Bell apar \u00een anumite aplica\u021bii ale problemelor de combinatoric\u0103. Numerele Stirling de prim\u0103 spe\u021b\u0103 sunt folositoare \u00een special c\u00e2nd vine vorba de num\u0103rarea ciclurilor \u00een permut\u0103ri, iar numerele Stirling de cea de-a doua spe\u021b\u0103, precum \u0219i numerele Bell se reg\u0103sesc \u00een probleme legate de num\u0103rarea unor parti\u021bii.</p> <p>Numerele lui Stirling de spe\u021ba I num\u0103r\u0103 c\u00e2te permut\u0103ri de ordin \\(n\\) cu \\(k\\) cicluri exist\u0103, \u0219i se noteaz\u0103 cu \\(s(n, k)\\). De exemplu, permutarea \\(1, 4, 2, 3, 6, 5\\) are \\(3\\) cicluri (\\(1\\), \\(2, 4, 3\\) \u0219i \\(5, 6\\)). Cazurile particulare sunt \\(s(0, 0) = 1, s(n, 0) = 0\\) \u0219i \\(s(0, k) = 0\\), iar formula recurent\u0103 este \\(s(n, k) = s(n-1, k-1) + (n-1)\\cdot s(n-1, k)\\), recuren\u021b\u0103 ce se poate explica recurg\u00e2nd la cazurile pe care le \u00eent\u00e2mpin\u0103m atunci c\u00e2nd ad\u0103ug\u0103m o nou\u0103 valoare la permutare, deoarece fie putem forma un ciclu nou, fie \u00eel introducem \u00eentr-un ciclu deja existent.</p> <p>Numerele lui Stirling de spe\u021ba II reprezint\u0103 num\u0103rul de parti\u021bii ale unei mul\u021bimi cu \\(n\\) elemente \u00een \\(k\\) submul\u021bimi, \u0219i se noteaz\u0103 cu \\(S(n, k)\\). Cazurile particulare sunt \\(S(0, 0) = 1, S(n, 0) = 0\\) \u0219i \\(S(0, k) = 0\\), iar formula recurent\u0103 este \\(S(n, k) = s(n-1, k-1) + k\\cdot s(n-1, k)\\), recuren\u021b\u0103 ce se poate explica recurg\u00e2nd la cazurile pe care le \u00eent\u00e2mpin\u0103m atunci c\u00e2nd ad\u0103ug\u0103m o nou\u0103 valoare la parti\u021biile existente, deoarece fie putem forma o nou\u0103 parti\u021bie, fie o introducem \u00eentr-o parti\u021bie deja existent\u0103.</p> Stirling de spe\u021ba IStirling de spe\u021ba II <pre><code>const int MAX = 100;\n\nunsigned long long S[MAX + 1][MAX + 1];\n\nvoid stirling(const int N) {\n    S[0][0] = 0;\n\n    for (int i = 1; i &lt;= N; ++i) {\n        for (int j = 1; j &lt;= i; ++j) {\n            S[i][j] = S[i - 1][j - 1] + (i - 1) * S[i - 1][j];\n        }\n    }\n}\n</code></pre> <pre><code>const int MAX = 100;\n\nunsigned long long S[MAX + 1][MAX + 1];\n\nvoid stirling(const int N) {\n    S[0][0] = 0;\n\n    for (int i = 1; i &lt;= N; ++i) {\n        for (int j = 1; j &lt;= i; ++j) {\n            S[i][j] = S[i - 1][j - 1] + j * S[i - 1][j];\n        }\n    }\n}\n</code></pre> <p>Numerele Bell se refer\u0103 la num\u0103rul de modalit\u0103\u021bi prin care putem parti\u021biona o mul\u021bime cu \\(n\\) elemente, \u0219i se noteaz\u0103 cu \\(B_n\\), fiind o generalizare a numerelor Stirling de spe\u021ba II, num\u0103r\u00e2nd toate parti\u021biile posibile pentru o mul\u021bime. \\(B_n\\) poate fi calculat u\u0219or plec\u00e2nd de la numerele Stirling de spe\u021ba a doua, \\(B_n = S(n, 0) + S(n, 1) +\\dots + S(n, n)\\) sau folosind direct numerele Bell anterioare, \\(B_n =\\sum_{i=0}^{n-1} C_{n-1}^i\\cdot B_i\\).</p>","tags":["matematica","combinatorica","teoria numerelor","permutari","aranjamente","combinari"]},{"location":"mediu/intro-combinatorics/#cum-putem-rezolva-probleme-de-combinatorica","title":"Cum putem rezolva probleme de combinatoric\u0103?","text":"<p>De obicei, c\u00e2nd vine vorba de rezolvarea problemelor de combinatoric\u0103, este foarte important mai \u00eent\u00e2i de toate s\u0103 v\u0103 asigura\u021bi c\u0103 \u0219ti\u021bi formulele \u0219i conceptele esen\u021biale, dar \u0219i s\u0103 le \u00een\u021belege\u021bi foarte clar deoarece \u00een cazul acestor probleme, memorarea formulelor f\u0103r\u0103 a le \u00een\u021belege cum trebuie va cauza mai multe probleme dec\u00e2t necunoa\u0219terea lor.</p> <p>Presupun\u00e2nd c\u0103 ave\u021bi un bagaj de cuno\u0219tin\u021be suficient pentru nivelul de dificultate al problemei pe care \u00eel aborda\u021bi, mai \u00eent\u00e2i de toate vre\u021bi s\u0103 \u0219ti\u021bi foarte clar ce date trebuie num\u0103rate \u0219i s\u0103 g\u0103si\u021bi observa\u021bii, care chiar dac\u0103 la \u00eenceput nu par a fi semnificative, pot fi utile pentru ob\u021binerea r\u0103spunsului final.</p> <p>O alt\u0103 tehnic\u0103 foarte important\u0103 const\u0103 \u00een a g\u0103si subprobleme independente ale problemei date, care pot fi folosite pentru a simplifica procesul de g\u0103sire a r\u0103spunsului final, de multe ori acest lucru fiind esen\u021bial \u00een rezolvarea problemelor mai dificile.</p> <p>Nu \u00een ultimul r\u00e2nd, experien\u021ba \u0219i identificarea diferitelor tipuri de formule ce apar de la problem\u0103 la problem\u0103 poate fi foarte folositor, iar de\u0219i acest lucru nu este neap\u0103rat specific strict combinatoricii, se poate observa faptul c\u0103 \u00een cazul acestei tehnici, generarea tuturor solu\u021biilor folosind metode precum backtracking sau brute force se poate dovedi de ajutor pentru identificarea unor posibile rela\u021bii de recuren\u021b\u0103 sau a unor formule care s\u0103 ne duc\u0103 la r\u0103spuns.</p> <p>Trebuie s\u0103 ave\u021bi grij\u0103 \u0219i la faptul c\u0103 \u00een unele cazuri, probleme ce pot p\u0103rea a fi de combinatoric\u0103 s\u0103 nu fie de fapt dinamici care se pot aborda mult mai u\u0219or folosind modul de g\u00e2ndire specific program\u0103rii dinamice, iar chiar dac\u0103 \u00een unele cazuri exist\u0103 similarit\u0103\u021bi \u00eentre cele dou\u0103, acest lucru nu este adev\u0103rat mereu.</p>","tags":["matematica","combinatorica","teoria numerelor","permutari","aranjamente","combinari"]},{"location":"mediu/intro-combinatorics/#probleme-suplimentare","title":"Probleme suplimentare","text":"","tags":["matematica","combinatorica","teoria numerelor","permutari","aranjamente","combinari"]},{"location":"mediu/intro-combinatorics/#probleme-suplimentare_1","title":"Probleme suplimentare","text":"","tags":["matematica","combinatorica","teoria numerelor","permutari","aranjamente","combinari"]},{"location":"mediu/intro-combinatorics/#probleme-de-la-olimpiade","title":"Probleme de la olimpiade","text":"<ul> <li>Combination</li> <li>pascal infoarena</li> <li>Stirling infoarena</li> <li>IIOT Dream</li> <li>Polyglot Kilonova</li> <li>Problemele de combinatoric\u0103 de pe Kilonova, \u00een special cele de la loturile de juniori</li> <li>RoAlgo Contest 4 - Ursul</li> <li>RoAlgo Contest 2 - munte</li> <li>RCPC 2023 KsumT</li> <li>ONI 2014 Spion</li> <li>ONI 2015 Nmult</li> <li>ONI 2015 Baraj Provocare</li> <li>ONI 2013 Xnumere</li> <li>IIOT 2024 Mermaid</li> <li>USACO Gold Help Yourself</li> <li>Problemele de pe cppi.sync</li> </ul>","tags":["matematica","combinatorica","teoria numerelor","permutari","aranjamente","combinari"]},{"location":"mediu/intro-combinatorics/#alte-probleme","title":"Alte probleme","text":"<ul> <li>Bracket Sequences I</li> <li>Bracket Sequences II</li> <li>Distributing Apples</li> <li>Arena</li> <li>Close Tuples (hard version)</li> <li>Almost Identity Permutations</li> <li>Med and Mex</li> <li>Different Subsets For All Tuples</li> <li>Probleme de combinatoric\u0103 de pe Codeforces</li> </ul>","tags":["matematica","combinatorica","teoria numerelor","permutari","aranjamente","combinari"]},{"location":"mediu/intro-combinatorics/#bibliografie-si-lectura-suplimentara","title":"Bibliografie \u0219i lectur\u0103 suplimentar\u0103","text":"<ul> <li>Curs de combinatoric\u0103 f\u0103cut de Bogdan Iordache</li> <li>Curs de combinatoric\u0103 avansat f\u0103cut de Alex Luchianov</li> <li>Combinatorics - USACO Guide (articol + probleme)</li> <li>Elemente de combinatoric\u0103</li> <li>Binomial Coefficients - Eolymp</li> <li>Elemente de combinatoric\u0103, curs predat la lotul de juniori din 2018</li> <li>Derangement - wikipedia</li> <li>Problem Solving Guide to Modular Combinatorics and Exponentiation - Codeforces</li> <li>Binomial coefficient - wikipedia</li> <li>Triunghiul lui Pascal - wikipedia</li> <li>Stars and Bars</li> <li>Num\u0103rul de parti\u021bii ale unui num\u0103r natural</li> <li>Numere Catalan</li> <li>Catalan Numbers and Catalan Convolution</li> <li>Catalan Numbers and Generating Uniform Balanced Bracket Sequences</li> <li>Numerele Stirling \u0219i numerele Bell</li> <li>Numerele Stirling de ambele spe\u021be</li> <li>Partition of a set</li> <li>Op\u021bional, restul articolelor de la sec\u021biunea combinatorics</li> </ul>","tags":["matematica","combinatorica","teoria numerelor","permutari","aranjamente","combinari"]},{"location":"mediu/knapsack/","title":"Problema rucsacului","text":"<p>Autor: \u0218tefan-Cosmin D\u0103sc\u0103lescu</p>","tags":["optimizare","programare dinamica"]},{"location":"mediu/knapsack/#introducere","title":"Introducere","text":"<p>Se d\u0103 urm\u0103toarea problem\u0103 pe care trebuie s\u0103 o rezolv\u0103m: Ai un set de obiecte pentru care \u0219tim greutatea \u0219i valoarea lor \u0219i vrei s\u0103 alegi unele obiecte din el, pe care s\u0103 le pui \u00eentr-un rucsac \u0219i s\u0103 \u00eencerci s\u0103 le vinzi turi\u0219tilor care viziteaz\u0103 ora\u0219ul \u00een care locuie\u0219ti. Ideal, ai vrea s\u0103 po\u021bi aduce toate obiectele, dar din p\u0103cate, rucsacul are o capacitate limitat\u0103, a\u0219a c\u0103 va trebui s\u0103 alegi ce obiecte vei p\u0103stra \u0219i ce obiecte nu. </p> <p>Aceast\u0103 problem\u0103 se nume\u0219te problema rucsacului \u0219i este una dintre cele mai studiate probleme de optimizare din informatic\u0103, av\u00e2nd multiple solu\u021bii \u00een func\u021bie de condi\u021biile impuse, restric\u021biile cu privire la num\u0103rul de obiecte alese \u0219i multe alte varia\u021bii, pe care le vom discuta \u00een cele ce urmeaz\u0103. </p>","tags":["optimizare","programare dinamica"]},{"location":"mediu/knapsack/#modul-de-abordare","title":"Modul de abordare","text":"<p>\u00cen cazul majorit\u0103\u021bii problemelor de tipul celei men\u021bionate anterior, vom folosi o abordare ce folose\u0219te metoda program\u0103rii dinamice, a\u0219a c\u0103 recomand\u0103m citirea articolului \u00een care facem introducerea acestei metode pentru a putea \u00een\u021belege mai bine con\u021binuturile explicate aici. </p> <p>O excep\u021bie notabil\u0103 const\u0103 \u00een problema rucsacului frac\u021bionar, \u00een care avem voie s\u0103 rupem obiectele \u00een beneficiul nostru, fiind evident \u00een cazul acestei variante faptul c\u0103 abordarea optim\u0103 const\u0103 \u00een sortarea obiectelor \u00een ordine descresc\u0103toare a raportului \\(\\frac{valoare}{greutate}\\) \u0219i alegerea obiectelor cu cel mai bun raport, p\u00e2n\u0103 c\u00e2nd umplem rucsacul. </p>","tags":["optimizare","programare dinamica"]},{"location":"mediu/knapsack/#variatii-ale-problemei-rucsacului","title":"Varia\u021bii ale problemei rucsacului","text":"<p>\u00cen cele ce urmeaz\u0103, vom prezenta diverse varia\u021bii \u00een care apare problema rucsacului, \u00eempreun\u0103 cu strategiile de abordare \u0219i implement\u0103ri care pot fi folosite \u0219i \u00een alte probleme de acest fel. </p>","tags":["optimizare","programare dinamica"]},{"location":"mediu/knapsack/#rucsacul-clasic-0-1-knapsack","title":"Rucsacul clasic (0-1 Knapsack)","text":"<p>Pentru aceast\u0103 problem\u0103, vom presupune c\u0103 avem voie s\u0103 alegem fiecare dintre cele \\(N\\) obiecte cel mult o dat\u0103, obiecte pentru care \u0219tim valoarea \u0219i greutatea lor, \\(V_i\\) \u0219i \\(W_i\\) \u0219i \u0219tim greutatea maxim\u0103 admis\u0103 a rucsacului, \\(G\\). </p> <p>O prim\u0103 solu\u021bie care pare u\u0219or de g\u0103sit este cea pe care am descris-o mai sus, pe modelul rucsacului frac\u021bionar, \u00eens\u0103 aceasta nu merge, deoarece putem g\u0103si foarte u\u0219or un contraexemplu. Un asemenea test ar fi \\(N = 3\\), \\(G = 4\\), \\(V_1 = 9\\), \\(W_1 = 3\\), \\(V_2 = 5\\), \\(W_2 = 2\\), \\(V_3 = 5\\), \\(W_3 = 2\\). Un algoritm greedy ar lua primul obiect deoarece raportul dintre valoare \u0219i greutate este maxim, dar solu\u021bia optim\u0103 const\u0103 \u00een luarea ultimelor dou\u0103 obiecte, care chiar dac\u0103 au rapoarte mai mici, adunate ne vor duce la un r\u0103spuns mai bun. </p> <p>\u00cen acest caz, va trebui s\u0103 g\u00e2ndim altfel problema. Deoarece o solu\u021bie de tip greedy va avea mereu un contra-exemplu pe cazul general, vom putea folosi o dinamic\u0103, \u00een care vom \u021bine cont de greutatea folosit\u0103 \u0219i de num\u0103rul de obiecte procesat. </p> <p>Astfel, vom defini \\(dp[i][j]\\) ca fiind valoarea maxim\u0103 a unor obiecte alese din primele \\(i\\) cu suma greut\u0103\u021bilor egal\u0103 cu \\(j\\). R\u0103spunsul final va fi valoarea maxim\u0103 a unei valori de tipul \\(dp[i][j]\\).</p>","tags":["optimizare","programare dinamica"]},{"location":"mediu/knapsack/#cum-calculam-dpij","title":"Cum calcul\u0103m \\(dp[i][j]\\)?","text":"<p>Pentru a calcula \\(dp[i][j]\\), trebuie s\u0103 ne g\u00e2ndim la cazurile de la care plec\u0103m pentru a ajunge la aceast\u0103 stare (vom presupune c\u0103 \\(W_i \\leq j\\)). Cu alte cuvinte, ce facem cu obiectul \\(i\\). Pe de o parte, \u00eel lu\u0103m \u0219i va trebui s\u0103 consider\u0103m cazul specific acestui lucru, iar pe de alt\u0103 parte, nu \u00eel lu\u0103m \u0219i va trebui s\u0103 ne raport\u0103m la starea anterioar\u0103 cu aceea\u0219i sum\u0103 a greut\u0103\u021bii. Rela\u021bia de recuren\u021b\u0103 va dovedi acest lucru, accentu\u00e2nd caracterul binar al problemei rucsacului (de aici vine \u0219i denumirea de \\(0-1\\) knapsack folosit\u0103 \u00een specialitate).</p> \\[dp[i][j] = max(dp[i-1][j], dp[i-1][j-W_i] + V_i)\\] <p>Dup\u0103 cum pute\u021bi vedea, fiecare stare depinde de exact dou\u0103 st\u0103ri anterioare, \u00een func\u021bie de decizia pe care o lu\u0103m cu privire la cel de-al i-lea obiect. Mai jos pute\u021bi g\u0103si solu\u021bia la problema Knapsack I de pe AtCoder. </p> <pre><code>#include &lt;iostream&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\nint main() {\n    int n, w;\n    cin &gt;&gt; n &gt;&gt; w;\n\n    vector&lt;vector&lt;long long&gt; &gt; dp(n+1, vector&lt;long long&gt; (w+1, 0));\n\n    for (int i = 1; i &lt;= n; i++) {\n        int wi, vi;\n        cin &gt;&gt; wi &gt;&gt; vi;\n        for (int j = 0; j &lt;= w; j++) {\n            dp[i][j] = dp[i-1][j];\n            if (wi &lt;= j &amp;&amp; dp[i-1][j-wi] + vi &gt; dp[i][j]) {\n                dp[i][j] = dp[i-1][j-wi] + vi;\n            }\n        }\n    }\n\n    long long ans = 0;\n    for (int i = 1; i &lt;= n; i++) {\n        for (int j = 0; j &lt;= w; j++) {\n            ans = max(ans, dp[i][j]);\n        }\n    }\n    cout &lt;&lt; ans &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["optimizare","programare dinamica"]},{"location":"mediu/knapsack/#putem-imbunatati-solutia","title":"Putem \u00eembun\u0103t\u0103\u021bi solu\u021bia?","text":"<p>Se poate observa c\u0103 fiecare pozi\u021bie din dinamica noastr\u0103 depinde doar de rezultatele liniei anterioare, deci putem s\u0103 reducem memoria necesar\u0103 la \\(2 \\cdot w\\), cum se poate vedea mai jos.</p> <pre><code>#include &lt;iostream&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\nint main() {\n    int n, w;\n    cin &gt;&gt; n &gt;&gt; w;\n\n    vector&lt;vector&lt;long long&gt; &gt; dp(2, vector&lt;long long&gt; (w+1, 0));\n\n    bool x = 1;\n    for (int i = 1; i &lt;= n; i++) {\n        int wi, vi;\n        cin &gt;&gt; wi &gt;&gt; vi;\n        for (int j = 0; j &lt;= w; j++) {\n            dp[x][j] = dp[x^1][j];\n            if (wi &lt;= j &amp;&amp; dp[x^1][j-wi] + vi &gt; dp[x][j]) {\n                dp[x][j] = dp[x^1][j-wi] + vi;\n            }\n        }\n        x ^= 1;\n    }\n\n    long long ans = 0;\n    for (int i = 0; i &lt;= 1; i++) {\n        for (int j = 0; j &lt;= w; j++) {\n            ans = max(ans, dp[i][j]);\n        }\n    }\n    cout &lt;&lt; ans &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre> <p>Ba chiar putem face o alt\u0103 \u00eembun\u0103t\u0103\u021bire din punct de vedere al memoriei, baz\u00e2ndu-ne pe faptul c\u0103 putem calcula st\u0103rile pas cu pas, de la dreapta la st\u00e2nga, f\u0103r\u0103 a avea nevoie s\u0103 \u021binem o a doua linie. Totu\u0219i, trebuie avut grij\u0103 la implementare, deoarece dac\u0103 forul e f\u0103cut de la st\u00e2nga la dreapta, risc\u0103m s\u0103 repet\u0103m obiecte, lucru care nu ne este permis \u00een aceast\u0103 versiune. </p> <pre><code>#include &lt;iostream&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\nint main() {\n    int n, w;\n    cin &gt;&gt; n &gt;&gt; w;\n\n    vector&lt;long long&gt; dp(w+1, 0);\n\n    bool x = 1;\n    for (int i = 1; i &lt;= n; i++) {\n        int wi, vi;\n        cin &gt;&gt; wi &gt;&gt; vi;\n        for (int j = w; j &gt;= wi; j--) {\n            dp[j] = max(dp[j], dp[j - wi] + vi);\n        }\n    }\n\n    long long ans = 0;\n    for (int j = 0; j &lt;= w; j++) {\n        ans = max(ans, dp[j]);\n    }\n    cout &lt;&lt; ans &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre> <p>Dup\u0103 cum se poate observa, aceast\u0103 implementare a fost adus\u0103 de la \\(O(n \\cdot w)\\) memorie la \\(O(w)\\) memorie, codul devenind de asemenea mai scurt. </p>","tags":["optimizare","programare dinamica"]},{"location":"mediu/knapsack/#rucsacul-in-care-putem-repeta-obiecte-de-un-numar-nelimitat-de-ori","title":"Rucsacul \u00een care putem repeta obiecte de un num\u0103r nelimitat de ori","text":"<p>Aceast\u0103 varia\u021bie este una \u00een care putem folosi un obiect de mai multe ori. Pentru a putea implementa aceast\u0103 varia\u021bie, trebuie doar s\u0103 modific\u0103m ultimul cod pentru a avea o parcurgere clasic\u0103 de la st\u00e2nga la dreapta. Din nou, vom presupune forma datelor de intrare ca fiind aceea\u0219i.</p> <pre><code>#include &lt;iostream&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\nint main() {\n    int n, w;\n    cin &gt;&gt; n &gt;&gt; w;\n\n    vector&lt;long long&gt; dp(w+1, 0);\n\n    bool x = 1;\n    for (int i = 1; i &lt;= n; i++) {\n        int wi, vi;\n        cin &gt;&gt; wi &gt;&gt; vi;\n        for (int j = wi; j &lt;= w; j++) {\n            dp[j] = max(dp[j], dp[j - wi] + vi);\n        }\n    }\n\n    long long ans = 0;\n    for (int j = 0; j &lt;= w; j++) {\n        ans = max(ans, dp[j]);\n    }\n    cout &lt;&lt; ans &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["optimizare","programare dinamica"]},{"location":"mediu/knapsack/#rucsacul-in-care-putem-repeta-obiecte-de-un-numar-limitat-de-ori","title":"Rucsacul \u00een care putem repeta obiecte de un num\u0103r limitat de ori","text":"<p>Aceast\u0103 varia\u021bie este una ceva mai dificil\u0103, deoarece nu mai putem folosi implementarea de mai sus f\u0103r\u0103 a folosi obiecte de prea multe ori, a\u0219a c\u0103 va trebui s\u0103 recurgem la o metod\u0103 de a reduce problema la un rucsac de tipul \\(0-1\\), ca cel prezentat mai sus. </p>","tags":["optimizare","programare dinamica"]},{"location":"mediu/knapsack/#trucul-log_2","title":"Trucul \"\\(\\log_2\\)\"","text":"<p>A\u0219a cum \u00eei zice \u0219i numele, vom vrea s\u0103 descompunem frecven\u021bele obiectelor \u00een sume de puteri ale lui \\(2\\), astfel \u00eenc\u00e2t s\u0103 putem acoperi oricare num\u0103r de la \\(1\\) la frecven\u021ba num\u0103rului, cu c\u00e2t mai pu\u021bine obiecte. Motivul pentru care folosim puterile lui \\(2\\) \u0219i nu numere consecutive este acela c\u0103 \u00een cazul \u00een care frecven\u021bele cresc foarte rapid, vom avea nevoie de foarte pu\u021bine numere (de exemplu, \\(1 + 2 + 4 + 8 = 1 + 2 + 3 + 4 + 5\\)).</p> <p>Vom explica modul de aplicare al acestui truc folosind un exemplu, ca mai apoi s\u0103 ar\u0103t\u0103m o implementare de acest fel. </p> <p>Exemplu</p> <p>Dac\u0103 avem un element cu frecven\u021ba \\(20\\) \u0219i greutatea individual\u0103 \\(W\\), mai \u00eent\u00e2i vom sc\u0103dea puteri ale lui \\(2\\) tot mai mari, iar mai apoi restul r\u0103mas va fi folosit \u0219i el. </p> <ul> <li>\\(20 - 1 = 19\\), putem folosi \\(1\\), deci \u00eenmul\u021bim puterea cu \\(2\\). Vom crea un obiect cu greutate \\(1 \\cdot W\\).</li> <li>\\(19 - 2 = 17\\), putem folosi \\(2\\), deci \u00eenmul\u021bim puterea cu \\(2\\). Vom crea un obiect cu greutate \\(2 \\cdot W\\).</li> <li>\\(17 - 4 = 13\\), putem folosi \\(4\\), deci \u00eenmul\u021bim puterea cu \\(2\\). Vom crea un obiect cu greutate \\(4 \\cdot W\\).</li> <li>\\(13 - 8 = 5\\), putem folosi \\(8\\), deci \u00eenmul\u021bim puterea cu \\(2\\). Vom crea un obiect cu greutate \\(8 \\cdot W\\).</li> <li>\\(5 - 16 = -11\\), nu putem folosi \\(16\\), a\u0219a c\u0103 folosim num\u0103rul r\u0103mas, \\(5\\).  Vom crea un obiect cu greutate \\(5 \\cdot W\\).</li> </ul> <p>Cu alte cuvinte, am \u00eemp\u0103r\u021bit un obiect cu frecven\u021ba \\(20\\) \u00een \\(5\\) obiecte echivalente, cu frecven\u021bele \\(1, 2, 4, 8\\) \u0219i \\(5\\). </p> <p>Un exemplu de problem\u0103 \u00een care se poate aplica acest truc este strehaia de la RoAlgo Contest 2. Pute\u021bi g\u0103si implementarea mai jos.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint ruk[1000001], frq[102];\n\nint main() {\n    int n;\n    cin &gt;&gt; n;\n\n    ruk[0] = 1;\n\n    for (int i = 1; i &lt;= n; i++) {\n        int x;\n        cin &gt;&gt; x;\n\n        for (int p = 1; p &lt;= x; p++) {\n            int q;\n            cin &gt;&gt; q;\n            frq[q]++;\n        }\n    }\n\n    int sm = 0;\n    for (int i = 1; i &lt;= 100; i++) {\n        int val = 1;\n        while (frq[i]) {\n            frq[i] -= val;\n            int total = i * val;\n            for (int poz = sm; poz &gt;= 0; poz--) {\n                if (ruk[poz]) {\n                    ruk[poz + total] = 1;\n                }\n            }\n            sm += total;\n            val *= 2;\n            if (val &gt; frq[i]) {\n                val = frq[i];\n            }\n        }\n    }\n\n    int cnt = 0;\n    for (int i = 0; i &lt;= 1000000; i++) {\n        cnt += ruk[i];\n    }\n    cout &lt;&lt; cnt &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["optimizare","programare dinamica"]},{"location":"mediu/knapsack/#rucsacul-in-care-ne-intereseaza-doar-daca-avem-o-anumita-suma-sau-nu","title":"Rucsacul \u00een care ne intereseaz\u0103 doar dac\u0103 avem o anumit\u0103 sum\u0103 sau nu","text":"<p>\u00cen multe probleme, nu ne intereseaz\u0103 suma maxim\u0103 sau minim\u0103 pe care o putem ob\u021bine, ci pur \u0219i simplu dac\u0103 putem crea o anumit\u0103 sum\u0103 folosind obiectele alese sau nu, acesta fiind un alt exemplu \u00een care putem aplica o dinamic\u0103 de tipul celor prezentate anterior. Deoarece nu mai avem nevoie s\u0103 \u021binem \u0219i o valoare maxim\u0103, avem o mai mare flexibilitate \u00een privin\u021ba implement\u0103rilor. Printre altele, aici putem folosi bitset pentru optimizarea actualiz\u0103rii st\u0103rilor, a\u0219a cum am procedat \u00een aceast\u0103 solu\u021bie pentru problema Money Sums.</p> <pre><code>#include &lt;iostream&gt;\n#include &lt;bitset&gt;\nusing namespace std;\n\nint main() {\n\n    int n;\n    cin &gt;&gt; n;\n\n    bitset&lt;100001&gt; dp;\n\n    dp[0] = 1;\n    for (int i = 1; i &lt;= n; i++) {\n        int x;\n        cin &gt;&gt; x;\n\n        dp |= (dp &lt;&lt; x); // aplicam operatiile pe biti pentru a creste eficienta bitsetului\n    }\n\n    int cnt = 0;\n    for (int i = 1; i &lt;= 100000; i++) {\n        cnt += dp[i];\n    }\n    cout &lt;&lt; cnt &lt;&lt; '\\n';\n    for (int i = 1; i &lt;= 100000; i++) {\n        if (dp[i]) {\n            cout &lt;&lt; i &lt;&lt; \" \";\n        }\n    }\n\n    return 0;\n}\n</code></pre>","tags":["optimizare","programare dinamica"]},{"location":"mediu/knapsack/#adaugarea-si-scoaterea-de-valori-din-rucsac","title":"Ad\u0103ugarea \u0219i scoaterea de valori din rucsac","text":"<p>Dac\u0103 vrem s\u0103 avem un rucsac care s\u0103 poat\u0103 suporta \u0219i actualiz\u0103ri, vom putea folosi o varia\u021bie destul de simpl\u0103 care ne permite s\u0103 ajungem la r\u0103spunsuri mai u\u0219or. Vom presupune c\u0103 vom stoca c\u00e2te moduri sunt s\u0103 ajungem la o anumit\u0103 sum\u0103, modulo \\(P\\), unde \\(P\\) este un num\u0103r prim foarte mare. Acest modulo ne va da flexibilitatea necesar\u0103 pentru a evita coliziunile \u0219i situa\u021biile de tip false negative, c\u00e2nd ajungem s\u0103 spunem c\u0103 nu avem un r\u0103spuns c\u00e2nd de fapt \u00eel avem. </p> <p>Vom presupune c\u0103 suma maxim\u0103 este \\(N\\) \u0219i valoarea ad\u0103ugat\u0103/scoas\u0103 este \\(W\\).</p> <pre><code>for (int i = N; i &gt;= W; i--) { \n    dp[i] += dp[i - W];\n    if (dp[i] &gt;= P) {\n        dp[i] -= P;\n    }\n}\n</code></pre> <p>Pentru a scoate, vom face acela\u0219i lucru dar invers.</p> <pre><code>for (int i = W; i &lt;= N; i++) {\n    dp[i] -= dp[i - W];\n    if (dp[i] &lt; 0) {\n        dp[i] += P;\n    }\n}\n</code></pre>","tags":["optimizare","programare dinamica"]},{"location":"mediu/knapsack/#probleme-suplimentare","title":"Probleme suplimentare","text":"<ul> <li>AtCoder Knapsack I</li> <li>AtCoder Knapsack II</li> <li>CSES Money Sums</li> <li>CSES Coin Combinations I</li> <li>CSES Coin Combinations II</li> <li>ONI 2015 Procente</li> <li>CSES Minimizing Coins</li> <li>RoAlgo Contest 2 strehaia</li> <li>Infoarena Triunghi</li> <li>IIOT 2021 Castle</li> <li>ONI 2015 Procente</li> <li>RCPC 2023 Dragons</li> <li>ONI 2017 Baraj Seniori Cli</li> <li>USACO Gold Fruit Feast</li> <li>Subset Sum Queries</li> <li>Probleme cu rucsac de pe Kilonova</li> <li>Probleme cu rucsac de pe Infoarena</li> </ul>","tags":["optimizare","programare dinamica"]},{"location":"mediu/knapsack/#lectura-suplimentara","title":"Lectur\u0103 suplimentar\u0103","text":"<ul> <li>Problema rucsacului - Infoarena</li> <li>Problema rucsacului - CPPI Sync</li> <li>Knapsack DP - USACO Guide</li> </ul>","tags":["optimizare","programare dinamica"]},{"location":"mediu/lcs/","title":"Sub\u0219ir comun maximal","text":"<p>Autor: \u0218tefan-Cosmin D\u0103sc\u0103lescu</p> <p>Problema sub\u0219irului comun maximal este o alt\u0103 problem\u0103 foarte important\u0103 care are aplica\u021bii \u00een domenii diverse precum genetic\u0103, bioinformatic\u0103 \u0219i procesarea limbajelor naturale, iar algoritmul pe care \u00eel vom prezenta va putea fi folosit cu mici modific\u0103ri \u00een foarte multe dinamici bazate pe matrici. Distan\u021be precum Distan\u021ba Levenshtein vor fi prezentate \u0219i ele aici, datorit\u0103 similarit\u0103\u021bii cu problema sub\u0219irului comun maximal. </p>","tags":["programare dinamica"]},{"location":"mediu/lcs/#subsirul-comun-maximal","title":"Sub\u0219irul comun maximal","text":"<p>Defini\u021bie</p> <p>Definim sub\u0219irul comun maximal a dou\u0103 \u0219iruri de caractere \\(a\\) \u0219i \\(b\\) ca fiind un sub\u0219ir \\(s\\) care are proprietatea c\u0103 pentru fiecare dintre \u0219irurile de caractere \\(a\\) \u0219i \\(b\\), \\(s\\) este un sub\u0219ir al acelui \u0219ir de caractere. De exemplu, sub\u0219irul comun maximal al \u0219irurilor <code>bcdaacd</code> si <code>acdbac</code> este <code>cdac</code>. </p> <p>Observa\u021bie</p> <p>Pot exista mai multe sub\u0219iruri comune maximale, de obicei ne intereseaz\u0103 lungimea sub\u0219irului comun maximal. Dac\u0103 vrem s\u0103 reconstituim sub\u0219irul comun maximal, a\u0219a cum proced\u0103m \u0219i la alte tipuri de dinamici, ne putem \u021bine o alt\u0103 stare \u00een care p\u0103str\u0103m originea r\u0103spunsului optim. </p> <p>Pentru a calcula sub\u0219irul comun maximal, vom avea o dinamic\u0103 pe dou\u0103 dimensiuni, folosind o abordare care va construi r\u0103spunsul din aproape \u00een aproape, pozi\u021bie cu pozi\u021bie. </p> <p>Astfel, vom avea \\(dp[i][j]\\) drept lungimea maxim\u0103 a unui sub\u0219ir comun care poate fi format din primele \\(i\\) caractere ale lui \\(a\\) \u0219i primele \\(j\\) caractere ale \u0219irului \\(b\\). </p> <p>Pentru a calcula aceast\u0103 recuren\u021b\u0103, avem dou\u0103 cazuri principale:</p> <ul> <li>Fie ad\u0103ug\u0103m un caracter din unul din cele dou\u0103 \u0219iruri, prelu\u00e2nd r\u0103spunsurile din \\((i-1, j)\\) \u0219i \\((i, j-1)\\)</li> <li>Fie ad\u0103ug\u0103m c\u00e2te un caracter din ambele \u0219iruri, prelu\u00e2nd r\u0103spunsul din \\((i-1, j-1)\\) \u0219i ad\u0103ug\u00e2nd \\(1\\) dac\u0103 caracterele sunt egale.</li> </ul> <p>Cu alte cuvinte, </p> \\[dp[i][j] = max(dp[i-1][j], dp[i][j-1], dp[i-1][j-1] + x)\\] <p>unde \\(x = 1\\) dac\u0103 \\(a_i = b_j\\) \u0219i \\(x = 0\\) \u00een caz contrar.</p> <p>Aceast\u0103 abordare va avea complexitatea \\(O(|a| \\cdot |b|)\\), unde \\(|a|\\) \u0219i \\(|b|\\) sunt lungimile celor dou\u0103 \u0219iruri de caractere. Aici pute\u021bi g\u0103si o implementare, care rezolv\u0103 problema similara de pe atcoder</p> <pre><code>#include &lt;iostream&gt;\n#include &lt;cstring&gt;\nusing namespace std;\n\nint n, m, dp[3025][3025], fw[3025][3025];\n\nchar c[3025], c2[3025];\n\nvoid solve (int n, int m) {\n    if (n == 0 || m == 0) {\n        return;\n    }\n    if (fw[n][m] == 1) {\n        solve(n-1, m);\n    }\n    if (fw[n][m] == 2) {\n        solve(n, m-1);\n    }\n    if (fw[n][m] == 3) {\n        solve(n-1, m-1);\n        cout &lt;&lt; c[n-1];\n    }\n}\nint main() {\n\n    cin &gt;&gt; c;\n    cin &gt;&gt; c2;\n    n = strlen(c);\n    m = strlen(c2);\n\n    for (int i = 1; i &lt;= n; i++) {\n        for (int j = 1; j &lt;= m; j++) {\n            dp[i][j] = max(dp[i-1][j], max(dp[i][j-1], dp[i-1][j-1] + (c[i-1] == c2[j-1])));\n            if (dp[i-1][j] == dp[i][j]) {\n                fw[i][j] = 1;\n            }\n            else {\n                if (dp[i][j-1] == dp[i][j]) {\n                    fw[i][j] = 2;\n                }\n                else {\n                    fw[i][j] = 3;\n                }\n            }\n        }\n    }\n\n    solve(n, m);\n    return 0;\n}\n</code></pre>","tags":["programare dinamica"]},{"location":"mediu/lcs/#distanta-levenshtein","title":"Distan\u021ba Levenshtein","text":"<p>\u00cen mod similar cu sub\u0219irul comun maximal, putem defini \u0219i distan\u021ba Levenshtein ca fiind distan\u021ba de editare \u00eentre dou\u0103 \u0219iruri, dac\u0103 putem ad\u0103uga, \u0219terge sau modifica caractere. Recuren\u021ba va fi foarte similar\u0103 cu cea de la problema precedent\u0103, singura diferen\u021b\u0103 este aceea c\u0103 opera\u021biile se schimb\u0103 din perspectiva valorii ad\u0103ugate. Aici este solu\u021bia la problema Edit Distance de pe CSES </p> <pre><code>#include &lt;iostream&gt;\n#include &lt;vector&gt;\n#include &lt;string&gt;\nusing namespace std;\n\nconst int mod = 1000000007;\n\nint main() {\n    string a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    int n = a.size();\n    int m = b.size();\n\n    vector&lt;vector&lt;int&gt; &gt; dp(n+1, vector&lt;int&gt; (m+1, (1&lt;&lt;20)));\n    dp[0][0] = 0;\n\n    for (int i = 0; i &lt;= n; i++) {\n        for (int j = 0; j &lt;= m; j++) {\n            if (i != 0) {\n                dp[i][j] = min(dp[i][j], dp[i-1][j] + 1);\n            }\n            if (j != 0) {\n                dp[i][j] = min(dp[i][j], dp[i][j-1] + 1);\n            }\n            if (i != 0 &amp;&amp; j != 0) {\n                dp[i][j] = min(dp[i][j], dp[i-1][j-1] + (a[i-1] != b[j-1]));\n            }\n        }\n    }\n\n    cout &lt;&lt; dp[n][m] &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["programare dinamica"]},{"location":"mediu/lcs/#optional-algoritmul-hunt-szymanski","title":"Op\u021bional - Algoritmul Hunt-Szymanski","text":"<p>Un algoritm interesant care merit\u0103 \u0219tiut pentru aflarea lungimii celui mai lung sub\u0219ir comun este algoritmul Hunt-Szymanski, un algoritm care se bazeaz\u0103 pe ideea c\u0103 dac\u0103 dou\u0103 \u0219iruri de caractere nu au un sub\u0219ir comun lung, foarte multe dintre compara\u021biile necesare sunt irelevante. </p> <p>Principiul din spatele algoritmului este acela c\u0103 ne intereseaz\u0103 doar perechile de pozi\u021bii \\((i, j)\\) cu proprietatea c\u0103 \\(a[i]\\) \u0219i \\(b[j]\\) sunt egale, iar pentru a folosi acest lucru \u00een avantajul nostru, vom precalcula pentru unul din \u0219irurile de caractere pozi\u021biile \u00een care apare fiecare liter\u0103, iar mai apoi, pentru fiecare pozi\u021bie \\(i\\) din \u0219irul \\(a\\), vom itera pozi\u021biile \u00een care apare litera curent\u0103 \u00een ordine descresc\u0103toare, scopul nostru fiind acela de a \u021bine un vector dp cu proprietatea c\u0103 \\(dp[i]\\) este cea mai mic\u0103 pozi\u021bie din \u0219irul \\(b\\) astfel \u00eenc\u00e2t am putut ajunge s\u0103 avem un sub\u0219ir comun maximal de lungime \\(i\\). </p> <p>Complexitatea algoritmului va fi \\(O((n + m) \\log n)\\), unde \\(m\\) este num\u0103rul de perechi de caractere egale. De\u0219i cel mai prost caz este \\(O(n^2 \\log n)\\), \u00een practic\u0103, algoritmul va fi mult mai eficient. Aici pute\u021bi g\u0103si o implementare a acestui algoritm, inspirata din acest cod.</p> <p>Practic, se poate spune c\u0103 acest algoritm este similar cu algoritmul pentru aflarea celui mai lung sub\u0219ir cresc\u0103tor pe perechi de pozi\u021bii. </p> <pre><code>int lcs(const std::string &amp;A, const std::string &amp;B) {\n    std::vector&lt;std::vector&lt;int&gt;&gt; adj(256);\n    int n = A.size(), m = B.size();\n\n    for (int i = 0; i &lt; m; ++i) {\n        adj[B[i]].push_back(i);\n    }\n\n    std::vector&lt;int&gt; ar;\n    ar.push_back(-1);\n\n    for (int i = 0; i &lt; n; ++i) {\n        for (int j = adj[A[i]].size() - 1; j &gt;= 0; --j) {\n            int x = adj[A[i]][j];\n            if (x &gt; ar.back()) {\n                ar.push_back(x);\n            } else {\n                *std::lower_bound(ar.begin(), ar.end(), x) = x;\n            }\n        }\n    }\n    return ar.size() - 1;\n}\n</code></pre>","tags":["programare dinamica"]},{"location":"mediu/lcs/#probleme-suplimentare","title":"Probleme suplimentare","text":"<ul> <li>cmlsc infoarena</li> <li>EJOI 2020 Exam</li> <li>Palindromic Doubles</li> </ul>","tags":["programare dinamica"]},{"location":"mediu/lcs/#lectura-suplimentara","title":"Lectur\u0103 suplimentar\u0103","text":"<ul> <li>Probleme clasice de programare dinamica - CPPI Sync</li> <li>Programare dinamica - Algopedia</li> <li>Longest Common Subsequence - USACO Guide</li> <li>Hunt-Szymanski Algorithm Explained (LCS but optimized for special cases) - Codeforces</li> <li>Paper despre Hunt-Szymanski</li> </ul>","tags":["programare dinamica"]},{"location":"mediu/lee/","title":"Algoritmul lui Lee. Flood Fill","text":"<p>Autor: \u0218tefan-Cosmin D\u0103sc\u0103lescu, Teodor \u0218tefan Manolea</p>","tags":["structuri de date","Coad\u0103","Lee","Fill","Stiva","BFS","DFS"]},{"location":"mediu/lee/#introducere","title":"Introducere","text":"<p>S\u0103 presupunem c\u0103 avem de-a face cu un labirint cu diverse tipuri de obstacole \u0219i spa\u021bii libere, iar obiectivul nostru este acela de a afla dac\u0103 putem ajunge de la punctul \\(A\\) la punctul \\(B\\), unde punctele \\(A\\) \u0219i \\(B\\) sunt date \u00een input. \u00cen alte varia\u021bii ale acestui tip de probleme, ni se poate cere \u0219i aflarea distan\u021bei minime \u00eentre dou\u0103 sau mai multe puncte. </p> <p>Resurs\u0103 foarte util\u0103</p> <p>Recomand\u0103m softul f\u0103cut de cei de la Colegiul Na\u021bional \"Emil Racovi\u021b\u0103\" Ia\u0219i, at\u00e2t pentru valoarea istoric\u0103, c\u00e2t \u0219i pentru claritatea explica\u021biilor grafice, soft educa\u021bional pe care \u00eel g\u0103si\u021bi aici.</p> <p>Pe parcurs, ve\u021bi observa c\u0103 indiferent de modul \u00een care ve\u021bi rezolva aceste clase de probleme, multe dintre principiile pe care le folosi\u021bi vor r\u0103m\u00e2ne acelea\u0219i, \u00een special atunci c\u00e2nd vine vorba de implementarea acestor tipuri de parcurgeri. </p> <p>Cele dou\u0103 moduri principale de a rezolva aceast\u0103 categorie de probleme sunt fie folosind algoritmi de tip flood fill recursiv (numit \u0219i fill \u00een jargonul rom\u00e2nesc), fie folosind algoritmi iterativi de parcurgere ai labirintului (numit algoritmul lui Lee \u00een literatura de specialitate rom\u00e2neasc\u0103).</p> <p>\u00cen cele ce urmeaz\u0103, voi prezenta at\u00e2t flood fill-ul recursiv, c\u00e2t \u0219i algoritmul lui Lee.</p>","tags":["structuri de date","Coad\u0103","Lee","Fill","Stiva","BFS","DFS"]},{"location":"mediu/lee/#fundamente","title":"Fundamente","text":"<p>P\u00e2n\u0103 s\u0103 ajungem s\u0103 discut\u0103m implementarea algoritmilor \u00een sine, vom prezenta c\u00e2\u021biva pa\u0219i importan\u021bi pe care trebuie s\u0103-i facem p\u00e2n\u0103 ajungem s\u0103 implement\u0103m complet ace\u0219ti doi algoritmi, precum \u0219i cuno\u0219tin\u021bele necesare.</p>","tags":["structuri de date","Coad\u0103","Lee","Fill","Stiva","BFS","DFS"]},{"location":"mediu/lee/#cunostinte-necesare","title":"Cuno\u0219tin\u021be necesare","text":"<p>\u00cen ceea ce prive\u0219te metodele iterative, folosite la algoritmul lui Lee, cunoa\u0219terea cozii este obligatorie, detalii despre modul de implementare, precum \u0219i varia\u021biile acestei structuri de date pot fi g\u0103site aici.</p> <p>\u00cen ceea ce prive\u0219te metodele recursive, folosite la flood fill, cunoa\u0219terea stivei \u0219i a recursivit\u0103\u021bii este obligatorie, detalii despre modul de folosire al stivei pot fi g\u0103site aici, iar informa\u021bii despre implementarea func\u021biilor recursive se g\u0103sesc aici.</p> <p>O alt\u0103 no\u021biune care se recomand\u0103 a fi cunoscut\u0103 \u00een prealabil este tipul de date pair sau o alternativ\u0103 a acestuia (tuple sau dac\u0103 prefera\u021bi implement\u0103rile \u00een stilul C, tipul de date struct, care permite \u0219i alte modific\u0103ri dup\u0103 caz).</p>","tags":["structuri de date","Coad\u0103","Lee","Fill","Stiva","BFS","DFS"]},{"location":"mediu/lee/#vectorii-de-directie","title":"Vectorii de direc\u021bie","text":"<p>\u00cen majoritatea problemelor de acest tip, personajele noastre se vor deplasa folosind mut\u0103ri succesive pe una dintre cele \\(4\\) sau \\(8\\) direc\u021bii care ne sunt permise de problem\u0103 (de regul\u0103, direc\u021biile cardinale - nord, est, sud, vest \u0219i eventual direc\u021biile diagonale - nord-est, sud-est, sud-vest, nord-vest).</p> <p>Pentru a stoca \u00een memorie aceste dimensiuni cu u\u0219urin\u021b\u0103, vom \u021bine \u00een memorie toate direc\u021biile posibile, iar pentru a face scrierea lor u\u0219oar\u0103, se recomand\u0103 scrierea lor \u00een sensul acelor de ceasornic. Acestea se pot scrie toate la \u00eenceput, noi put\u00e2nd folosi fie arrays din C, fie vectori. </p> <p>Mai jos g\u0103si\u021bi modul de declarare a acestor vectori de direc\u021bie atunci c\u00e2nd putem merge doar \u00een direc\u021bia celor \\(4\\) vecini cardinali.</p> <pre><code>int ox[] = {-1, 0, 1, 0};\nint oy[] = {0, 1, 0, -1};\n</code></pre> <pre><code>vector&lt;int&gt; ox = {-1, 0, 1, 0};\nvector&lt;int&gt; oy = {0, 1, 0, -1};\n</code></pre> <p>Pentru a extinde acum la \\(8\\) vecini, vom insera direc\u021biile intermediare \u00een ordinea acelor de ceasornic, mai jos g\u0103si\u021bi modul de declarare a acestor vectori de direc\u021bie pentru toate direc\u021biile, \u00eencep\u00e2nd de la N \u0219i termin\u00e2nd cu NV, \u00een sens orar. </p> <pre><code>int ox[] = {-1, -1, 0, 1, 1, 1, 0, -1};\nint oy[] = {0, 1, 1, 1, 0, -1, -1, -1};\n</code></pre> <pre><code>vector&lt;int&gt; ox = {-1, -1, 0, 1, 1, 1, 0, -1};\nvector&lt;int&gt; oy = {0, 1, 1, 1, 0, -1, -1, -1};\n</code></pre> <p>O alternativ\u0103 folosit\u0103 \u00een multe coduri const\u0103 \u00een enumerarea vecinilor \u00een ordine cresc\u0103toare a schimb\u0103rii care se produce pe linie, mai \u00eent\u00e2i prioritiz\u00e2nd vecinii nordici, apoi cei centrali \u0219i apoi cei sudici.</p> <pre><code>int ox[] = {-1, -1, -1, 0, 0, 1, 1, 1};\nint oy[] = {-1, 0, 1, -1, 1, -1, 0, 1};\n</code></pre> <pre><code>vector&lt;int&gt; ox = {-1, -1, -1, 0, 0, 1, 1, 1};\nvector&lt;int&gt; oy = {-1, 0, 1, -1, 1, -1, 0, 1};\n</code></pre> <p>Indiferent de modul \u00een care \u00eei declara\u021bi, dac\u0103 sunte\u021bi la un punct \\((x, y)\\) \u0219i vre\u021bi s\u0103 verifica\u021bi to\u021bi vecinii, tot ce trebuie s\u0103 face\u021bi este s\u0103 parcurge\u021bi vectorii de direc\u021bie \u0219i s\u0103 identifica\u021bi valorile vecinilor. </p> <pre><code>for (int i = 0; i &lt; neighbors; i++) {\n    int nxt_x = x + ox[i];\n    int nxt_y = y + oy[i];\n    // aici urmeaza verificarile ulterioare\n}\n</code></pre>","tags":["structuri de date","Coad\u0103","Lee","Fill","Stiva","BFS","DFS"]},{"location":"mediu/lee/#evitarea-accesarii-unor-patrate-din-afara-matricii","title":"Evitarea acces\u0103rii unor p\u0103trate din afara matricii","text":"<p>Pentru a ne asigura c\u0103 de-a lungul parcurgerilor, noi nu vom ie\u0219i din matrice, avem dou\u0103 variante la fel de bune \u0219i populare.</p> <p>O prim\u0103 variant\u0103 const\u0103 \u00een a ad\u0103uga ziduri imaginare pe marginile matricii, procedeu cunoscut \u0219i sub denumirea de bordare. Vom presupune c\u0103 matricea se nume\u0219te mat, iar tabloul are \\(n\\) linii \u0219i \\(m\\) coloane.</p> <pre><code>for (int i = 0; i &lt;= m+1; i++) {\n    mat[0][i] = mat[n+1][i] = -1; // bordarea liniilor 0 si n+1\n}\nfor (int i = 0; i &lt;= n+1; i++) {\n    mat[i][0] = mat[i][m+1] = -1; // bordarea coloanelor 0 si m+1\n}\n</code></pre> <p>O a doua variant\u0103 const\u0103 \u00een verificarea atent\u0103 a fiec\u0103rei st\u0103ri atunci c\u00e2nd trecem prin ea, astfel \u00eenc\u00e2t s\u0103 ne asigur\u0103m c\u0103 nu ie\u0219im din matrice, lucru ce se \u00eent\u00e2mpl\u0103 c\u00e2nd trecem prin p\u0103trate noi \u00een matrice.</p> <pre><code>for (int i = 0; i &lt; neighbors; i++) {\n    int nxt_x = x + ox[i];\n    int nxt_y = y + oy[i];\n    if (nxt_x &gt;= 1 &amp;&amp; nxt_x &lt;= n &amp;&amp; nxt_y &gt;= 1 &amp;&amp; nxt_y &lt;= m) {\n        // aici vin verificarile ulterioare\n    }\n}\n</code></pre> <p>Pe de o parte, un avantaj al bord\u0103rii este acela c\u0103 nu avem nevoie de o verificare relativ complicat\u0103 pentru p\u0103tratele din matrice. Pe de alt\u0103 parte, verificarea f\u0103r\u0103 bordare nu are nevoie de memorie suplimentar\u0103. Se poate observa faptul c\u0103 ambele metode au avantajele lor, nefiind una din ele superioar\u0103 celeilalte. </p>","tags":["structuri de date","Coad\u0103","Lee","Fill","Stiva","BFS","DFS"]},{"location":"mediu/lee/#problema-introductiva-counting-rooms","title":"Problem\u0103 introductiv\u0103 - Counting Rooms","text":"<p>Pentru a exemplifica aceste no\u021biuni \u0219i a prezenta algoritmii, precum \u0219i diferen\u021bele dintre ei, vom pleca de la o problem\u0103 simpl\u0103, \u0219i anume aflarea num\u0103rului de camere dintr-o \u00eenc\u0103pere.</p>","tags":["structuri de date","Coad\u0103","Lee","Fill","Stiva","BFS","DFS"]},{"location":"mediu/lee/#algoritmul-fill-flood-fill-recursiv","title":"Algoritmul fill (flood fill recursiv)","text":"<p>Pentru a implementa algoritmul flood fill, va trebui s\u0103 plec\u0103m pe r\u00e2nd din fiecare punct nevizitat, iar la un pas al acestui algoritm, vom verifica to\u021bi vecinii folosind vectorul de direc\u021bie creat anterior, iar atunci c\u00e2nd d\u0103m de un asemenea punct, vom apela func\u021bia fill pentru a continua vizitarea punctelor. Trebuie avut grij\u0103 s\u0103 marc\u0103m punctele drept vizitate, pentru a evita ciclarea la infinit. </p> <p>Observa\u021bie</p> <p>Se poate observa c\u0103 acest algoritm este un caz particular al parcurgerii DFS de pe grafuri, ambele fiind recursive \u0219i oper\u00e2nd \u00een acela\u0219i mod.</p> <p>Mai jos, pute\u021bi g\u0103si o implementare recursiv\u0103, \u00een stilul algoritmului flood fill, care rezolv\u0103 problema Counting Rooms, prezentat\u0103 mai sus.</p> <pre><code>#include &lt;iostream&gt;\n#include &lt;fstream&gt;\n#include &lt;vector&gt;\n#include &lt;queue&gt;\n\nusing namespace std;\n\nvector&lt;int&gt; ox = {-1, 0, 1, 0};\nvector&lt;int&gt; oy = {0, 1, 0, -1};\n\nvoid fill (int n, int m, int X, int Y, vector&lt;vector&lt;char&gt; &gt; &amp;grid, vector&lt;vector&lt;int&gt; &gt; &amp;visited) {\n    visited[X][Y] = 1;\n    for (int i = 0; i &lt; 4; i++) {\n        int nxt_x = X + ox[i];\n        int nxt_y = Y + oy[i];\n\n        if (nxt_x &gt;= 1 &amp;&amp; nxt_x &lt;= n &amp;&amp; nxt_y &gt;= 1 &amp;&amp; nxt_y &lt;= m &amp;&amp; visited[nxt_x][nxt_y] == 0 &amp;&amp; grid[nxt_x][nxt_y] == '.') {\n            fill(n, m, nxt_x, nxt_y, grid, visited);\n        }\n    }\n}\nint main() {\n\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n\n    int n, m;\n    cin &gt;&gt; n &gt;&gt; m;\n\n    vector&lt;vector&lt;char&gt; &gt; grid(n+1, vector&lt;char&gt; (m+1));\n    vector&lt;vector&lt;int&gt; &gt; visited(n+1, vector&lt;int&gt; (m+1));\n\n    for (int i = 1; i &lt;= n; i++) {\n        for (int j = 1; j &lt;= m; j++) {\n            cin &gt;&gt; grid[i][j];\n        }\n    }\n\n    int ans = 0;\n\n    for (int i = 1; i &lt;= n; i++) {\n        for (int j = 1; j &lt;= m; j++) {\n            if (grid[i][j] == '.' &amp;&amp; visited[i][j] == 0) {\n\n                fill(n, m, i, j, grid, visited);\n                ans++;\n            }\n        }\n    }\n\n    cout &lt;&lt; ans &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["structuri de date","Coad\u0103","Lee","Fill","Stiva","BFS","DFS"]},{"location":"mediu/lee/#algoritmul-lui-lee-flood-fill-iterativ","title":"Algoritmul lui Lee (flood fill iterativ)","text":"<p>Pentru a implementa algoritmul lui Lee, va trebui s\u0103 plec\u0103m pe r\u00e2nd din fiecare punct nevizitat, iar la un pas al acestui algoritm, vom verifica to\u021bi vecinii folosind vectorul de direc\u021bie creat anterior, iar atunci c\u00e2nd d\u0103m de un asemenea punct, vom ad\u0103uga vecinul \u00een coad\u0103, la fiecare pas prelucr\u00e2nd primul punct care \u00eenc\u0103 se afl\u0103 \u00een coad\u0103. Trebuie avut grij\u0103 s\u0103 marc\u0103m punctele drept vizitate, pentru a evita ciclarea la infinit. </p> <p>Observa\u021bie</p> <p>Se poate observa c\u0103 acest algoritm este un caz particular al parcurgerii BFS de pe grafuri, ambele fiind iterative \u0219i oper\u00e2nd \u00een acela\u0219i mod, folosind o coad\u0103.</p> <p>Mai jos, pute\u021bi g\u0103si o implementare bazat\u0103 pe o coad\u0103, \u00een stilul algoritmului lui Lee, care rezolv\u0103 problema Counting Rooms, prezentat\u0103 mai sus.</p> <p>Observa\u021bie important\u0103</p> <p>De\u0219i \u00een majoritatea cazurilor putem folosi fie metoda fill, fie metoda iterativ\u0103, atunci c\u00e2nd avem nevoie s\u0103 afl\u0103m distan\u021ba dintre dou\u0103 sau mai multe puncte, singura metod\u0103 optim\u0103 este cea iterativ\u0103, bazat\u0103 pe coad\u0103, deoarece \u00een cazul fill, depindem de modul \u00een care ajungem s\u0103 apel\u0103m vecinii recursiv, ceea ce reprezint\u0103 o strategie care va duce la solu\u021bii ineficiente din punct de vedere al timpului \u0219i memoriei. Acest argument va fi reluat \u0219i atunci c\u00e2nd prezent\u0103m DFS \u0219i BFS la grafuri. </p> <pre><code>#include &lt;iostream&gt;\n#include &lt;fstream&gt;\n#include &lt;vector&gt;\n#include &lt;queue&gt;\n\nusing namespace std;\n\nint main() {\n\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n\n    int n, m;\n    cin &gt;&gt; n &gt;&gt; m;\n\n    vector&lt;vector&lt;char&gt; &gt; grid(n+1, vector&lt;char&gt; (m+1));\n    vector&lt;vector&lt;int&gt; &gt; visited(n+1, vector&lt;int&gt; (m+1));\n\n    for (int i = 1; i &lt;= n; i++) {\n        for (int j = 1; j &lt;= m; j++) {\n            cin &gt;&gt; grid[i][j];\n        }\n    }\n\n    int ans = 0;\n    vector&lt;int&gt; ox = {-1, 0, 1, 0};\n    vector&lt;int&gt; oy = {0, 1, 0, -1};\n\n    for (int i = 1; i &lt;= n; i++) {\n        for (int j = 1; j &lt;= m; j++) {\n            if (grid[i][j] == '.' &amp;&amp; visited[i][j] == 0) {\n\n                queue &lt;pair&lt;int, int&gt; &gt; q;\n\n                q.push({i, j});\n                visited[i][j] = 1;\n                ans++;\n\n                while (!q.empty()) {\n                    pair&lt;int, int&gt; node = q.front();\n                    q.pop();\n\n                    for (int i = 0; i &lt; 4; i++) {\n                        int nxt_x = node.first + ox[i];\n                        int nxt_y = node.second + oy[i];\n\n                        if (nxt_x &gt;= 1 &amp;&amp; nxt_x &lt;= n &amp;&amp; nxt_y &gt;= 1 &amp;&amp; nxt_y &lt;= m &amp;&amp; visited[nxt_x][nxt_y] == 0 &amp;&amp; grid[nxt_x][nxt_y] == '.') {\n                            visited[nxt_x][nxt_y] = 1;\n                            q.push({nxt_x, nxt_y});\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    cout &lt;&lt; ans &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["structuri de date","Coad\u0103","Lee","Fill","Stiva","BFS","DFS"]},{"location":"mediu/lee/#problema-alee-oji-2007","title":"Problema Alee OJI 2007","text":"<p>Probabil una din cele mai cunoscute probleme rom\u00e2ne\u0219ti care folose\u0219te algoritmul lui Lee pentru rezolvarea acesteia, aceast\u0103 problem\u0103 necesit\u0103 implementarea algoritmului prezentat anterior pentru aflarea distan\u021bei de la origine la punctul ini\u021bial la cel final. </p> <pre><code>#include &lt;bits/stdc++.h&gt;\n\nusing namespace std;\n\nint ox[4] = {0, 1, 0, -1};\nint oy[4] = {-1, 0, 1, 0};\n\nbool isValid(int x, int y, int n, int m, vector&lt;vector&lt;int&gt; &gt; &amp;mat) {\n    return x &gt; 0 &amp;&amp; y &gt; 0 &amp;&amp; x &lt;= n &amp;&amp; y &lt;= n &amp;&amp; mat[x][y] == 0;\n}\n\nint main() {\n\n    ifstream cin(\"alee.in\");\n    ofstream cout(\"alee.out\");\n\n    int x, y, n, m, final_x, final_y;\n    cin &gt;&gt; n &gt;&gt; m;\n\n\n    vector&lt;vector&lt;int&gt; &gt; mat(n+1, vector&lt;int&gt; (n+1));\n    for (short i = 0; i &lt; m; i++) {\n        cin &gt;&gt; x &gt;&gt; y;\n        mat[x][y] = -1;\n    }\n\n    cin &gt;&gt; final_x &gt;&gt; final_y;\n    mat[final_x][final_y] = 1;\n\n    queue&lt;pair&lt;int, int&gt; &gt; q;\n\n    q.push({final_x, final_y});\n    cin &gt;&gt; final_x &gt;&gt; final_y;\n\n    while (!q.empty()) {\n        pair&lt;int, int&gt; temp = q.front();\n        q.pop();\n\n        for (int i = 0; i &lt; 4; i++) {\n            int new_x = temp.first + ox[i];\n            int new_y = temp.second + oy[i];\n            if (isValid(new_x, new_y, n, m, mat)) {\n                mat[new_x][new_y] = mat[temp.first][temp.second] + 1;\n                q.push({new_x, new_y});\n            }\n        }\n\n    }\n\n    cout &lt;&lt; mat[final_x][final_y] &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["structuri de date","Coad\u0103","Lee","Fill","Stiva","BFS","DFS"]},{"location":"mediu/lee/#problema-labirint-oji-2021","title":"Problema Labirint OJI 2021","text":"<p>Pentru a rezolva aceast\u0103 problem\u0103, putem \u00eencepe o parcurgere din punctele \\((1, 1)\\) \u0219i \\((n, m)\\), iar pentru a verifica dac\u0103 apar \u00eembun\u0103t\u0103\u021biri, trebuie doar s\u0103 verific\u0103m cu aten\u021bie perechile de distan\u021be noi ce apar, acesta fiind motivul pentru care avem nevoie de dou\u0103 parcurgeri, \u00een loc de una. </p> <pre><code>#include &lt;bits/stdc++.h&gt;  \nusing namespace std;  \n\nint n, m, q;  \n\nbool ok[1000002];  \nint mx[1000002];  \n\nchar mat[1002][1002];  \nint dist[2][1002][1002];  \n\nbool viz[1002][1002];  \n\nint ox[] = {-1, 0, 1, 0};  \nint oy[] = {0, 1, 0, -1};  \n\nbool check (int x, int y) {  \n    return ((x &gt;= 1) &amp;&amp; (x &lt;= n) &amp;&amp; (y &gt;= 1) &amp;&amp; (y &lt;= m) &amp;&amp; (viz[x][y] == 0));  \n}  \nvoid lee (int drum, int x, int y) {  \n    memset(viz, 0, sizeof(viz));  \n    deque&lt;pair&lt;int, int&gt; &gt; d;  \n    d.push_back({x, y});  \n    viz[x][y] = 1;  \n    for (int i = 1; i &lt;= n; ++i) { \n        for (int j = 1; j &lt;= m; ++j) {  \n            dist[drum][i][j] = -1;  \n        }\n    }\n    dist[drum][x][y] = 1;  \n    while (!d.empty()) {  \n        pair&lt;int, int&gt; nod = d[0];  \n        d.pop_front();  \n        for (int i = 0; i &lt;= 3; ++i) {  \n            int nxt_x = ox[i] + nod.first;  \n            int nxt_y = oy[i] + nod.second;  \n            if (check(nxt_x, nxt_y) &amp;&amp; dist[drum][nxt_x][nxt_y] == -1) {  \n                dist[drum][nxt_x][nxt_y] = dist[drum][nod.first][nod.second] + 1;  \n                if (mat[nxt_x][nxt_y] == '0') {  \n                    viz[nxt_x][nxt_y] = 1;  \n                    d.push_back({nxt_x, nxt_y});  \n                }  \n            }  \n        }  \n    }  \n}  \n\nchar ans[1002][1002];  \n\nint main() {  \n    ifstream cin(\"labirint.in\");  \n    ofstream cout(\"labirint.out\");  \n\n    cin &gt;&gt; n &gt;&gt; m;  \n    for (int i = 1; i &lt;= n; ++i) {  \n        cin &gt;&gt; (mat[i] + 1);  \n    }  \n\n    lee(0, 1, 1);  \n    lee(1, n, m);  \n\n    for (int i = 1; i &lt;= n; ++i) {\n        for (int j = 1; j &lt;= m; ++j) { \n            if (mat[i][j] == '1' &amp;&amp; dist[0][i][j] != -1 &amp;&amp; dist[1][i][j] != -1) \n            {  \n                if (dist[0][i][j] + dist[1][i][j] - 1 &lt; dist[1][1][1]) {\n                    ans[i][j] = '1';  \n                }\n                else {\n                    ans[i][j] = '0';  \n                }\n            }  \n            else {\n                ans[i][j] = '0';  \n            }\n        }\n    }\n\n    for (int i = 1; i &lt;= n; ++i) { \n        cout &lt;&lt; (ans[i] + 1) &lt;&lt; '\\n';\n    }  \n    return 0;  \n}  \n</code></pre>","tags":["structuri de date","Coad\u0103","Lee","Fill","Stiva","BFS","DFS"]},{"location":"mediu/lee/#lee-cu-mai-multe-origini","title":"Lee cu mai multe origini","text":"<p>\u00cen anumite situa\u021bii, suntem nevoi\u021bi s\u0103 simul\u0103m o varia\u021bie a algoritmului lui Lee \u00een care avem de-a face cu mai multe puncte de start. \u00cen acest caz, deoarece de cele mai multe ori este prea \u00eencet s\u0103 rul\u0103m algoritmul pentru fiecare punct de start, putem pur \u0219i simplu s\u0103 ad\u0103ug\u0103m \u00een coad\u0103 toate originile \u0219i s\u0103 rul\u0103m acela\u0219i algoritm, singura diferen\u021b\u0103 fiind atunci c\u00e2nd vrem s\u0103 afl\u0103m originea fiec\u0103rui drum, deoarece trebuie s\u0103 fim aten\u021bi s\u0103 evit\u0103m situa\u021biile \u00een care nu putem construi drumul cum trebuie. </p>","tags":["structuri de date","Coad\u0103","Lee","Fill","Stiva","BFS","DFS"]},{"location":"mediu/lee/#problema-monsters-de-pe-cses","title":"Problema Monsters de pe CSES","text":"<p>\u00cen aceast\u0103 problem\u0103, trebuie s\u0103 g\u0103sim un drum pentru personajul nostru astfel \u00eenc\u00e2t s\u0103 poat\u0103 ajunge la una din marginile matricii f\u0103r\u0103 s\u0103 se intersecteze cu vreun monstru. </p> <p>Abordarea general\u0103 pentru aceste tipuri de probleme const\u0103 \u00een a afla mai \u00eent\u00e2i pentru mon\u0219tri, respectiv pentru personajul nostru distan\u021bele de la punctele lor de origine la celelalte p\u0103trate din matrice, iar \u00een cazul personajului, singurele p\u0103trate accesibile sunt cele la care va ajunge \u00eenaintea oric\u0103rui monstru, deoarece se \u0219tie c\u0103 mon\u0219trii pot colabora pentru a opri rivalul lor. A\u0219a cum se va observa \u00een implementarea de mai jos, to\u021bi mon\u0219trii sunt ad\u0103uga\u021bi \u00een coad\u0103 la \u00eenceputul travers\u0103rii. </p> <p>Un alt element important \u00een aceast\u0103 problem\u0103 const\u0103 \u00een reconstruirea solu\u021biei, procedeul fiind similar cu cel prezentat la problema anterioar\u0103. </p> <p>Mai jos g\u0103si\u021bi implementarea autorului pentru aceast\u0103 problem\u0103. </p> <pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n\nint ox[] = {0, 1, 0, -1};\nint oy[] = {1, 0, -1, 0};\n\nint main() {\n    int n, m;\n    cin &gt;&gt; n &gt;&gt; m;\n\n    char grid[n+1][m+1];\n    for (int i = 1; i &lt;= n; i++) {\n        cin &gt;&gt; (grid[i] + 1);\n    }\n\n    vector&lt;vector&lt;int&gt; &gt; distM(n+1, vector&lt;int&gt; (m+1, (1&lt;&lt;20))), distA(n+1, vector&lt;int&gt; (m+1, (1&lt;&lt;20)));\n\n    queue&lt;pair&lt;int, int&gt; &gt; qM, qA;\n    for (int i = 1; i &lt;= n; i++) {\n        for (int j = 1; j &lt;= m; j++) {\n            if (grid[i][j] == 'A') {\n                distA[i][j] = 0;\n                qA.push({i, j});\n            }\n            if (grid[i][j] == 'M') {\n                distM[i][j] = 0;\n                qM.push({i, j});\n            }\n        }\n    }\n\n    while(!qM.empty()) {\n        pair&lt;int, int&gt; node = qM.front();\n        qM.pop();\n\n        for (int i = 0; i &lt; 4; i++) {\n            int nxtX = node.first + ox[i];\n            int nxtY = node.second + oy[i];\n            if (nxtX &gt;= 1 &amp;&amp; nxtX &lt;= n &amp;&amp; nxtY &gt;= 1 &amp;&amp; nxtY &lt;= m &amp;&amp; grid[nxtX][nxtY] != '#') {\n                if (distM[nxtX][nxtY] &gt; distM[node.first][node.second] + 1) {\n                    distM[nxtX][nxtY] = distM[node.first][node.second] + 1;\n                    qM.push({nxtX, nxtY});\n                }\n            }\n        }\n    }\n\n    while(!qA.empty()) {\n        pair&lt;int, int&gt; node = qA.front();\n        qA.pop();\n\n        for (int i = 0; i &lt; 4; i++) {\n            int nxtX = node.first + ox[i];\n            int nxtY = node.second + oy[i];\n            if (nxtX &gt;= 1 &amp;&amp; nxtX &lt;= n &amp;&amp; nxtY &gt;= 1 &amp;&amp; nxtY &lt;= m &amp;&amp; grid[nxtX][nxtY] != '#') {\n                if (distA[nxtX][nxtY] &gt; distA[node.first][node.second] + 1 &amp;&amp; distA[node.first][node.second] + 1 &lt; distM[nxtX][nxtY]) {\n                    distA[nxtX][nxtY] = distA[node.first][node.second] + 1;\n                    qA.push({nxtX, nxtY});\n                }\n            }\n        }\n    }\n\n\n    for (int i = 1; i &lt;= n; i++) {\n        for (int j = 1; j &lt;= m; j++) {\n            if (distA[i][j] != (1&lt;&lt;20) &amp;&amp; (i == 1 || i == n || j == 1 || j == m)) { \n                int x = i;\n                int y = j;\n                string s;\n                while (distA[x][y] != 0) {\n                    if (distA[x-1][y] == distA[x][y] - 1) {\n                        s += 'D';\n                        x--;\n                        continue;\n                    }\n                    if (distA[x][y-1] == distA[x][y] - 1) {\n                        s += 'R';\n                        y--;\n                        continue;\n                    }\n                    if (distA[x+1][y] == distA[x][y] - 1) {\n                        s += 'U';\n                        x++;\n                        continue;\n                    }\n                    if (distA[x][y+1] == distA[x][y] - 1) {\n                        s += 'L';\n                        y++;\n                        continue;\n                    }\n                }\n                cout &lt;&lt; \"YES\\n\";\n                cout &lt;&lt; s.size() &lt;&lt; '\\n';\n                reverse(s.begin(), s.end());\n                cout &lt;&lt; s &lt;&lt; '\\n';\n                return 0;\n            }\n        }\n    }\n\n    cout &lt;&lt; \"NO\\n\";\n    return 0;\n}\n</code></pre>","tags":["structuri de date","Coad\u0103","Lee","Fill","Stiva","BFS","DFS"]},{"location":"mediu/lee/#algoritmul-0-1-bfs","title":"Algoritmul 0-1 BFS","text":"<p>De\u0219i acest algoritm este folosit \u00een principal pentru problemele de drumuri minime pe grafuri, exist\u0103 exemple care implic\u0103 \u0219i probleme pe matrici, a\u0219a cum se precizeaz\u0103 \u00een articolul nostru despre drumuri minime.</p>","tags":["structuri de date","Coad\u0103","Lee","Fill","Stiva","BFS","DFS"]},{"location":"mediu/lee/#lee-cu-structuri-de-date","title":"Lee cu structuri de date","text":"<p>\u00cen unele cazuri, putem avea de-a face cu probleme \u00een care vizitarea unui p\u0103trat adiacent din matrice poate avea costuri diferite de \\(0\\) \u0219i \\(1\\), \u00een acest caz se impune folosirea unor structuri de date pentru a calcula aceste costuri minime, implementarea devenind foarte similar\u0103 cu cea pe care o ve\u021bi vedea atunci c\u00e2nd ve\u021bi \u00eenv\u0103\u021ba algoritmul lui Dijkstra, acesta fiind varianta sa pe matrice. </p> <p>La fel ca \u0219i la Dijkstra, cele mai populare structuri de date sunt setul \u0219i coada de priorit\u0103\u021bi, mai jos g\u0103sind implement\u0103ri folosind ambele structuri de date ce rezolv\u0103 problema lee2 de pe pbinfo.</p>","tags":["structuri de date","Coad\u0103","Lee","Fill","Stiva","BFS","DFS"]},{"location":"mediu/lee/#implementare-cu-set","title":"Implementare cu set","text":"<pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n\nint ox[] = {-1, 0, 1, 0};\nint oy[] = {0, 1, 0, -1};\n\nint main() {\n\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n\n    int x, y, z, n, t;\n    cin &gt;&gt; n &gt;&gt; x &gt;&gt; y &gt;&gt; z &gt;&gt; t;\n\n    vector&lt;vector&lt;int&gt; &gt; val(n+1, vector&lt;int&gt; (n+2, 0)), dp(n+1, vector&lt;int&gt; (n+1, (1&lt;&lt;25)));\n\n    for (int i = 1; i &lt;= n; ++i) {\n        cin &gt;&gt; val[1][i];\n    }\n\n    for (int i = 2; i &lt;= n; ++i) {\n        for (int j = 1; j &lt;= n; ++j) {\n            val[i][j] = 1 + (val[i-1][j-1] * x + val[i-1][j] * y + val[i-1][j+1] * z) % t;\n        }\n    }\n\n    dp[1][1] = val[1][1];\n\n    set&lt;pair&lt;int, pair&lt;int, int&gt; &gt; &gt;s;\n    s.insert({dp[1][1], {1, 1}});\n\n    while (!s.empty()) {\n        pair&lt;int, pair&lt;int, int&gt; &gt; x = *s.begin();\n        s.erase(x);\n\n        pair&lt;int, int&gt; nod = x.second;\n\n        for (int i = 0; i &lt;= 3; ++i) {\n            int new_x = ox[i] + nod.first;\n            int new_y = oy[i] + nod.second;\n            if (new_x == 0 || new_y == 0 || new_x == n+1 || new_y == n+1) {\n                continue;\n            }\n            if (dp[nod.first][nod.second] + val[new_x][new_y] &lt; dp[new_x][new_y]) {\n                dp[new_x][new_y] = dp[nod.first][nod.second] + val[new_x][new_y];\n                s.insert({dp[new_x][new_y], {new_x, new_y}});\n            }\n        }\n    }\n\n    cout &lt;&lt; dp[n][n] &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["structuri de date","Coad\u0103","Lee","Fill","Stiva","BFS","DFS"]},{"location":"mediu/lee/#implementare-cu-priority-queue","title":"Implementare cu priority queue","text":"<p>Observa\u021bie</p> <p>Nodurile se introduc \u00een priority queue cu - \u00een fa\u021b\u0103 deoarece vrem s\u0103 \u021binem elementele \u00een ordine cresc\u0103toare, iar implementarea standard a priority queue le \u021bine \u00een ordine descresc\u0103toare.</p> <pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n\nint ox[] = {-1, 0, 1, 0};\nint oy[] = {0, 1, 0, -1};\n\nint main() {\n\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n\n    int x, y, z, n, t;\n    cin &gt;&gt; n &gt;&gt; x &gt;&gt; y &gt;&gt; z &gt;&gt; t;\n\n    vector&lt;vector&lt;int&gt; &gt; val(n+1, vector&lt;int&gt; (n+2, 0)), dp(n+1, vector&lt;int&gt; (n+1, (1&lt;&lt;25)));\n\n    for (int i = 1; i &lt;= n; ++i) {\n        cin &gt;&gt; val[1][i];\n    }\n\n    for (int i = 2; i &lt;= n; ++i) {\n        for (int j = 1; j &lt;= n; ++j) {\n            val[i][j] = 1 + (val[i-1][j-1] * x + val[i-1][j] * y + val[i-1][j+1] * z) % t;\n        }\n    }\n\n    dp[1][1] = val[1][1];\n\n    priority_queue&lt;pair&lt;int, pair&lt;int, int&gt; &gt; &gt;pq;\n    pq.push({-dp[1][1], {1, 1}});\n\n    while (!pq.empty()) {\n        pair&lt;int, pair&lt;int, int&gt; &gt; x = pq.top();\n        pq.pop();\n\n        pair&lt;int, int&gt; nod = x.second;\n\n        for (int i = 0; i &lt;= 3; ++i) {\n            int new_x = ox[i] + nod.first;\n            int new_y = oy[i] + nod.second;\n            if (new_x == 0 || new_y == 0 || new_x == n+1 || new_y == n+1) {\n                continue;\n            }\n            if (dp[nod.first][nod.second] + val[new_x][new_y] &lt; dp[new_x][new_y]) {\n                dp[new_x][new_y] = dp[nod.first][nod.second] + val[new_x][new_y];\n                pq.push({-dp[new_x][new_y], {new_x, new_y}});\n            }\n        }\n    }\n\n    cout &lt;&lt; dp[n][n] &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["structuri de date","Coad\u0103","Lee","Fill","Stiva","BFS","DFS"]},{"location":"mediu/lee/#concluzii","title":"Concluzii","text":"<p>Algoritmii de tip flood fill sunt unii din cei mai \u00eent\u00e2lni\u021bi algoritmi din aceast\u0103 sec\u021biune a structurilor de date liniare, ei reg\u0103sindu-se \u00een foarte multe tipuri de probleme, fiind una din cele mai populare tipuri de probleme de la olimpiadele de informatic\u0103 din Rom\u00e2nia \u0219i nu numai, ace\u0219tia fiind reg\u0103si\u021bi \u0219i \u00een USACO Silver \u0219i alte competi\u021bii similare. </p> <p>\u00cen multe situa\u021bii, datorit\u0103 popularit\u0103\u021bii acestei metode, problemele noi ce folosesc aceast\u0103 tehnic\u0103 combin\u0103 \u0219i al\u021bi algoritmi, precum c\u0103utarea binar\u0103, programarea dinamic\u0103 sau chiar combinatorica \u00een anumite exemple mai dificile.</p> <p>Pe l\u00e2ng\u0103 aplica\u021biile din problemele de algoritmic\u0103, ace\u0219tia se reg\u0103sesc \u0219i \u00een multe situa\u021bii practice, \u00een care trebuie estimat impactul unor poten\u021biale dezastre naturale sau chiar \u0219i \u00een editarea imaginilor \u0219i a altor forme grafice. </p>","tags":["structuri de date","Coad\u0103","Lee","Fill","Stiva","BFS","DFS"]},{"location":"mediu/lee/#probleme-suplimentare","title":"Probleme suplimentare","text":"<ul> <li>OJI 2004 rj</li> <li>OJI 2007 alee</li> <li>infoarena muzeu</li> <li>infoarena barbar</li> <li>RoAlgo Contest #1 - Expansion</li> <li>USACO Silver Icy Perimeter</li> <li>USACO Silver Cross Country Skiing</li> <li>OJI 2021 labirint</li> <li>OJI 2009 insule</li> <li>infoarena delfin</li> <li>infoarena vila</li> <li>infoarena marceland</li> <li>Codeforces Fox and Two Dots</li> <li>USACO Silver Where's Bessie</li> <li>Codeforces Solve the Maze</li> <li>OJI 2018 castel</li> <li>ONI 2014 traseu</li> <li>Codeforces Igor in the Museum</li> <li>ONI 2012 gheizere</li> <li>Codeforces Olya and Energy Drinks</li> <li>USACO Silver Comfortable Cows</li> <li>USACO Silver Snow Boots</li> <li>Lot Juniori 2021 Fete si baieti</li> <li>OJI 2016 miting</li> <li>Probleme cu coada si lee de pe pbinfo</li> <li>Problemele cu flood fill de pe kilonova</li> </ul>","tags":["structuri de date","Coad\u0103","Lee","Fill","Stiva","BFS","DFS"]},{"location":"mediu/lee/#lectura-suplimentara","title":"Lectur\u0103 suplimentar\u0103","text":"<ul> <li>Flood fill - USACO Guide</li> <li>BFS Fill - Algoritmul lui Lee - Algopedia</li> <li>Algoritmul lui Lee - infogenius</li> <li>Algoritmul lui Lee - infoarena</li> <li>Algoritmul lui Lee - pbinfo</li> <li>Cozi (include si alte probleme) - CPPI Sync</li> <li>Probleme diverse - CPPI Sync</li> <li>Flood fill - wikipedia</li> <li>Algoritmi de umplere - generalitati - Pbinfo</li> <li>Algoritmi de umplere - fill recursiv - Pbinfo</li> <li>Algoritmi de umplere - fill cu coada - Pbinfo</li> <li>An Efficient (and quite common) Way to Navigate Grid Problems - Codeforces</li> <li>0-1 BFS - Codeforces</li> </ul>","tags":["structuri de date","Coad\u0103","Lee","Fill","Stiva","BFS","DFS"]},{"location":"mediu/lis/","title":"Sub\u0219ir cresc\u0103tor maximal","text":"<p>Autor: \u0218tefan-Cosmin D\u0103sc\u0103lescu</p> <p>\u00cen cele ce urmeaz\u0103, vom prezenta problema afl\u0103rii celui mai lung sub\u0219ir cresc\u0103tor dintr-un \u0219ir, prezent\u00e2nd o serie de algoritmi care rezolv\u0103 aceast\u0103 problem\u0103, \u00eencep\u00e2nd de la cei mai \u00eence\u021bi \u0219i termin\u00e2nd cu variantele optime, precum \u0219i diversele modific\u0103ri pe care le putem face.</p>","tags":["programare dinamica","structuri de date","optimizari","subsiruri"]},{"location":"mediu/lis/#introducere","title":"Introducere","text":"<p>Se consider\u0103 un sub\u0219ir cresc\u0103tor al vectorului \\(v\\) un sub\u0219ir \\(p_1, p_2, \\dots, p_k\\) cu propriet\u0103\u021bile c\u0103 \\(1 \\leq p_1 &lt; p_2 &lt; \\dots &lt; p_k \\leq n\\), iar \\(v[p_1] &lt; v[p_2] &lt; \\dots &lt; v[p_k]\\).</p> <p>Un sub\u0219ir cresc\u0103tor maximal al unui \u0219ir este un sub\u0219ir cresc\u0103tor al lui \\(v\\) cu proprietatea c\u0103 lungimea acestuia este maxim\u0103. </p> <p>De exemplu, dac\u0103 \\(v = \\{7, 3, 5, 3, 6, 2, 9, 8 \\}\\), unul dintre sub\u0219irurile cresc\u0103toare de lungime maxim\u0103 al acestui \u0219ir este \\(\\{ 3, 5, 6, 9 \\}\\), lungimea acestuia fiind \\(4\\). </p>","tags":["programare dinamica","structuri de date","optimizari","subsiruri"]},{"location":"mediu/lis/#cum-aflam-subsirul-crescator-maximal","title":"Cum afl\u0103m sub\u0219irul cresc\u0103tor maximal?","text":"<p>O prim\u0103 solu\u021bie const\u0103 \u00een folosirea unei metode de tip Backtracking pentru a testa toate sub\u0219irurile, dar aceasta este mult prea \u00eenceat\u0103, nu are sens s\u0103 o discut\u0103m aici. Totu\u0219i, exist\u0103 c\u00e2teva solu\u021bii care sunt bazate pe algoritmi de tip Greedy \u0219i bazate pe metoda program\u0103rii dinamice care ne duc la r\u0103spuns, \u00een diverse complexit\u0103\u021bi de timp. \u00cen cele ce urmeaz\u0103, le vom prezenta, una c\u00e2te una. </p>","tags":["programare dinamica","structuri de date","optimizari","subsiruri"]},{"location":"mediu/lis/#dinamica-in-on2","title":"Dinamica \u00een O(n^2)","text":"<p>O solu\u021bie foarte cunoscut\u0103 a acestei probleme const\u0103 \u00een folosirea unei dinamici, \u00een care \\(dp[i]\\) va \u021bine lungimea sub\u0219irului cresc\u0103tor maximal care con\u021bine pozi\u021bia \\(i\\). Tranzi\u021biile vor fi foarte simple, fiecare pozi\u021bie este comparat\u0103 cu fiecare, complexitatea solu\u021biei ajung\u00e2nd la $O(n^2). </p> \\[ dp[i] = \\max_{\\substack{j &lt; i \\\\\\\\ v[j] &lt; v[i]}} \\left(dp[j] + 1\\right) \\] <p>Evident, dac\u0103 nu exist\u0103 o pozi\u021bie \\(j &lt; i\\) care respect\u0103 condi\u021bia de mai sus, \\(dp[i] = 1\\).</p> <p>Implementarea acestei solu\u021bii nu este foarte complicat\u0103, mai jos g\u0103si\u021bi solu\u021bia propus\u0103 de noi pentru problema SCLM de pe pbinfo. </p> <pre><code>#include &lt;fstream&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\nint main() {\n\n    ifstream cin(\"sclm.in\");\n    ofstream cout(\"sclm.out\");\n\n    int n;\n    cin &gt;&gt; n;\n\n    vector&lt;int&gt; v(n+1), dp(n+1), fw(n+1);\n    for (int i = 1; i &lt;= n; i++) {\n        cin &gt;&gt; v[i];\n    }\n\n    int maxi = 0;\n    int pos = 0;\n    for (int i = 1; i &lt;= n; i++) {\n        for (int j = 1; j &lt; i; j++) {\n            if (v[j] &lt; v[i] &amp;&amp; dp[j] &gt; dp[i]) {\n                dp[i] = dp[j];\n                fw[i] = j;\n            }\n        }\n        dp[i]++;\n        if (dp[i] &gt; maxi) {\n            maxi = dp[i];\n            pos = i;\n        }\n    }\n\n    // vom reconstitui raspunsul din aproape in aproape\n    cout &lt;&lt; maxi &lt;&lt; '\\n';\n    vector&lt;int&gt; ans;\n    while (pos) {\n        ans.push_back(pos);\n        pos = fw[pos];\n    }\n    for (int i = maxi - 1; i &gt;= 0; i--) {\n        cout &lt;&lt; ans[i] &lt;&lt; \" \";\n    }\n    return 0;\n}\n</code></pre>","tags":["programare dinamica","structuri de date","optimizari","subsiruri"]},{"location":"mediu/lis/#solutie-in-on-log-n-cu-cautare-binara","title":"Solu\u021bie \u00een \\(O(n \\log n)\\) cu c\u0103utare binar\u0103","text":"<p>Pentru a rezolva aceast\u0103 problem\u0103 \u00een timp optim, trebuie s\u0103 observ\u0103m c\u0103 foarte mul\u021bi candida\u021bi pe care \u00eei \u021binem la solu\u021bia anterioar\u0103 nu \u00ee\u0219i au rostul, fiind \u00eendeajuns s\u0103 \u0219tim doar candidatul cu cea mai mic\u0103 valoare pentru fiecare valoare distinct\u0103 pe care o poate lua \\(dp[i]\\). </p> <p>Deoarece pe m\u0103sur\u0103 ce cre\u0219tem valorile lui \\(dp[i]\\), candida\u021bii pe care \u00eei p\u0103str\u0103m au valori tot mai mari, putem \u00eembun\u0103t\u0103\u021bi aceast\u0103 solu\u021bie p\u0103str\u00e2nd doar candida\u021bii \u0219i c\u0103ut\u00e2nd binar valoarea minim\u0103 din \u0219irul candida\u021bilor care dep\u0103\u0219e\u0219te valoarea curent\u0103. Mai jos g\u0103si\u021bi solu\u021bia problemei Increasing Subsequence de pe CSES.</p> <pre><code>#include &lt;iostream&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\nint main() {\n    int n;\n    cin &gt;&gt; n;\n\n    vector&lt;int&gt; v(n+1), dp(n+1);\n    for (int i = 1; i &lt;= n; i++) {\n        cin &gt;&gt; v[i];\n    }\n\n    vector&lt;int&gt; candidates;\n    int maxi = 0;\n    for (int i = 1; i &lt;= n; i++) {\n        if (i == 1 || v[i] &gt; v[candidates.back()]) {\n            candidates.push_back(i);\n            dp[i] = candidates.size();\n        }\n        else {\n            int L = 0;\n            int R = (int) candidates.size() - 1;\n            int ans = -1;\n            while (L &lt;= R) {\n                int mid = (L + R) / 2;\n                if (v[candidates[mid]] &gt;= v[i]) {\n                    ans = mid;\n                    R = mid - 1;\n                }\n                else {\n                    L = mid + 1;\n                }\n            }\n            // ans ne da si pozitia in cazul in care avem nevoie de reconstruirea solutiei\n            dp[i] = ans + 1;\n            candidates[ans] = i;\n        }\n        maxi = max(maxi, dp[i]);\n    }\n\n    cout &lt;&lt; maxi &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["programare dinamica","structuri de date","optimizari","subsiruri"]},{"location":"mediu/lis/#solutie-in-on-log-n-cu-structuri-de-date","title":"Solu\u021bie \u00een \\(O(n \\log n)\\) cu structuri de date","text":"<p>Pentru solu\u021biile \u00een \\(O(n \\log n)\\) care folosesc structuri de date, mai \u00eent\u00e2i vom vrea s\u0103 avem o copie a vectorului ini\u021bial, pe care s\u0103 o sort\u0103m. Recomand\u0103m mai \u00eent\u00e2i familiarizarea cu arborii de intervale sau arborii indexa\u021bi binar pentru a continua, precum \u0219i normalizarea dac\u0103 nu a\u021bi mai folosit aceast\u0103 tehnic\u0103 anterior.</p> <p>Acest lucru ne garanteaz\u0103 normalizarea vectorului, lucru pe care \u00eel vom folosi pentru a putea avea queryuri de tip maxim pe un interval pe parcursul implement\u0103rii voastre.</p> <p>Dup\u0103 ce am f\u0103cut acest pas, tot ce trebuie s\u0103 facem este s\u0103 c\u0103ut\u0103m binar pentru fiecare valoare din \u0219ir, \u00een ordinea \u00een care apar, care ar fi pozi\u021bia \u00een vectorul sortat, facem query-urile de maxim pe interval \u0219i actualiz\u0103m pozi\u021bia g\u0103sit\u0103 anterior \u00een timpul c\u0103ut\u0103rii binare. Mai jos g\u0103si\u021bi cele dou\u0103 variante folosind cele dou\u0103 structuri de date, solu\u021biile fiind pentru aceea\u0219i problem\u0103 de pe CSES.</p>","tags":["programare dinamica","structuri de date","optimizari","subsiruri"]},{"location":"mediu/lis/#solutie-cu-arbori-de-intervale","title":"Solu\u021bie cu arbori de intervale","text":"<pre><code>#include &lt;iostream&gt;\n#include &lt;vector&gt;\n#include &lt;algorithm&gt;\nusing namespace std;\n\nvoid add (int node, int L, int R, int poz, int val, vector&lt;int&gt; &amp;segtree) {\n    if (L == R) {\n        segtree[node] = max(segtree[node], val);\n        return;\n    }\n\n    int mid = (L + R) / 2;\n    if (poz &lt;= mid) {\n        add(node * 2, L, mid, poz, val, segtree);\n    }\n    else {\n        add(node * 2 + 1, mid+1, R, poz, val, segtree);\n    }\n    segtree[node] = max(segtree[node * 2], segtree[node * 2 + 1]);\n}\n\nint query(int node, int L, int R, int qL, int qR, vector&lt;int&gt; &amp;segtree) {\n    if (qL &lt;= L &amp;&amp; R &lt;= qR) {\n        return segtree[node];\n    }\n\n    if (qR &lt; L || qL &gt; R) {\n        return 0;\n    }\n\n    int mid = (L + R) / 2;\n    return max(query(node * 2, L, mid, qL, qR, segtree), query(node * 2 + 1, mid+1, R, qL, qR, segtree));\n}\n\nint main() {\n    int n;\n    cin &gt;&gt; n;\n\n    vector&lt;int&gt; v(n+1), sorted(n+1), segtree(4*n+1);\n    for (int i = 1; i &lt;= n; i++) {\n        cin &gt;&gt; v[i];\n        sorted[i] = v[i];\n    }\n    sort(sorted.begin() + 1, sorted.begin() + n + 1);\n\n    int maxi = 0;\n    for (int i = 1; i &lt;= n; i++) {\n        int L = 1;\n        int R = n;\n        int ans = 0;\n        while (L &lt;= R) {\n            int mid = (L + R) / 2;\n            if (sorted[mid] &lt; v[i]) {\n                ans = mid;\n                L = mid + 1;\n            }\n            else {\n                R = mid - 1;\n            }\n        }\n\n        int query_ans = query(1, 1, n, 1, ans, segtree) + 1;\n        maxi = max(maxi, query_ans);\n        add(1, 1, n, ans + 1, query_ans, segtree);\n    }\n\n    cout &lt;&lt; maxi &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["programare dinamica","structuri de date","optimizari","subsiruri"]},{"location":"mediu/lis/#solutie-cu-arbori-indexati-binar","title":"Solu\u021bie cu arbori indexa\u021bi binar","text":"<pre><code>#include &lt;iostream&gt;\n#include &lt;vector&gt;\n#include &lt;algorithm&gt;\nusing namespace std;\n\nvoid add (int node, int n, int val, vector&lt;int&gt; &amp;fen) {\n    for (; node &lt;= n; node += (node &amp; (-node))) {\n        fen[node] = max(fen[node], val);\n    }\n}\n\nint compute (int node, vector&lt;int&gt; &amp;fen) {\n    int ans = 0;\n    for (; node; node -= (node &amp; (-node))) {\n        ans = max(ans, fen[node]);\n    }\n    return ans;\n}\n\nint main() {\n    int n;\n    cin &gt;&gt; n;\n\n    vector&lt;int&gt; v(n+1), sorted(n+1), fen(n+1);\n    for (int i = 1; i &lt;= n; i++) {\n        cin &gt;&gt; v[i];\n        sorted[i] = v[i];\n    }\n    sort(sorted.begin() + 1, sorted.begin() + n + 1);\n\n    int maxi = 0;\n    for (int i = 1; i &lt;= n; i++) {\n        int L = 1;\n        int R = n;\n        int ans = 0;\n        while (L &lt;= R) {\n            int mid = (L + R) / 2;\n            if (sorted[mid] &lt; v[i]) {\n                ans = mid;\n                L = mid + 1;\n            }\n            else {\n                R = mid - 1;\n            }\n        }\n\n        int query_ans = compute(ans, fen) + 1;\n        maxi = max(maxi, query_ans);\n        add(ans + 1, n, query_ans, fen);\n    }\n\n    cout &lt;&lt; maxi &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["programare dinamica","structuri de date","optimizari","subsiruri"]},{"location":"mediu/lis/#concluzii-si-alte-moduri-in-care-putem-folosi-aceasta-abordare","title":"Concluzii \u0219i alte moduri \u00een care putem folosi aceast\u0103 abordare","text":"<p>Probleme similare cu cea descris\u0103 mai sus sunt unele precum num\u0103rul de sub\u0219iruri cresc\u0103toare maximale, lungimea unui sub\u0219ir cresc\u0103tor maximal \u00een care putem avea elemente egale sau pentru doritorii unei provoc\u0103ri mai avansate, num\u0103rul minim de sub\u0219iruri descresc\u0103toare necesare pentru a acoperi o secven\u021b\u0103 dat\u0103. </p> <p>De\u0219i toate aceste solu\u021bii au utilitatea lor, pe parcurs, ve\u021bi observa c\u0103 solu\u021biile ce implic\u0103 structuri de date au o mai mare plaj\u0103 \u00een ceea ce prive\u0219te modific\u0103rile care pot fi f\u0103cute \u0219i timpul de implementare al acestora.</p>","tags":["programare dinamica","structuri de date","optimizari","subsiruri"]},{"location":"mediu/lis/#probleme-suplimentare","title":"Probleme suplimentare","text":"<ul> <li>CopyCopyCopyCopyCopy Codeforces</li> <li>scmax infoarena</li> <li>subsiruri infoarena</li> <li>LIS On Permutations - Codeforces</li> <li>IIOT 2018 UpDown</li> <li>Codeforces Tourist</li> <li>interclasare infoarena</li> <li>USACO Gold Cowjog</li> </ul>","tags":["programare dinamica","structuri de date","optimizari","subsiruri"]},{"location":"mediu/lis/#lectura-suplimentara","title":"Lectur\u0103 suplimentar\u0103","text":"<ul> <li>Articolul de pe wikipedia</li> <li>Articolul de pe pbinfo</li> <li>Articolul de pe cp-algorithms</li> <li>Articolul de pe USACO Guide</li> </ul>","tags":["programare dinamica","structuri de date","optimizari","subsiruri"]},{"location":"mediu/mitm/","title":"Meet in the Middle","text":"<p>Autor: \u0218tefan-Cosmin D\u0103sc\u0103lescu</p>","tags":["optimizari","precalculare","brute force"]},{"location":"mediu/mitm/#introducere","title":"Introducere","text":"<p>Meet in the middle este o tehnic\u0103 de programare care este folosit\u0103 atunci c\u00e2nd avem de-a face cu probleme pentru care solu\u021bia optim\u0103 este aceea de a \u00eemp\u0103r\u021bi spa\u021biul de c\u0103utare \u00een dou\u0103, pentru a putea aplica for\u021ba brut\u0103 independent pentru cele dou\u0103 jum\u0103t\u0103\u021bi rezultate. </p> <p>Numele \u0219i principiile acestei tehnici sunt \u00eenrudite cu atacul criptografic cu acela\u0219i nume.</p> <p>\u00cen algoritmic\u0103, acea tehnic\u0103 este folosit\u0103 atunci c\u00e2nd vrem s\u0103 rezolv\u0103m probleme folosind brute-force, dar restric\u021biile nu sunt suficient de mici pentru un brute-force clasic, utilizarea cea mai des \u00eent\u00e2lnit\u0103 pentru meet in the middle este atunci c\u00e2nd trebuie s\u0103 lucr\u0103m cu submul\u021bimi.</p> <p>!!! \"Observa\u021bie\"     Deoarece spa\u021biul de c\u0103utare se \u00eemparte \u00een dou\u0103, complexitatea exponen\u021bial\u0103 va cre\u0219te mult mai greu, meet in the middle devenind util pentru probleme la care dimensiunea datelor de intrare este cel mult \\(40-45\\).</p> <p>Cu alte cuvinte, vom rula un algoritm brute-force pentru fiecare jum\u0103tate, iar apoi vom uni rezultatele ob\u021binute \u00een timp liniar, raportat la num\u0103rul de solu\u021bii generate.</p> <p>Astfel, complexitatea algoritmului va deveni acum \\(O(2^{\\frac{n}{2}})\\).</p>","tags":["optimizari","precalculare","brute force"]},{"location":"mediu/mitm/#problema-meet-in-the-middle","title":"Problema Meet in the Middle","text":"<p>Pentru a afla c\u00e2te submul\u021bimi au suma \\(k\\), vom precalcula pentru prima jum\u0103tate din \u0219ir sumele tuturor submul\u021bimilor, stoc\u00e2nd sumele \u00eentr-un vector sau map, iar apoi pentru fiecare sum\u0103 din cea de-a doua jum\u0103tate, vom afla c\u00e2te sume sunt egale cu complementul ei \\(k - sum\\). </p> <pre><code>#include &lt;iostream&gt;\n#include &lt;vector&gt;\n#include &lt;algorithm&gt;\n\nusing namespace std;\n\nint bs(int sum, vector&lt;int&gt; &amp;sums) {\n    int L = 0;\n    int R = sums.size() - 1;\n    int ans = 0;\n    while (L &lt;= R) {\n        int mid = (L + R) / 2;\n        if (sums[mid] &lt;= sum) {\n            ans = mid + 1;\n            L = mid + 1;\n        }\n        else {\n            R = mid - 1;\n        }\n    }\n    return ans;\n}\n\nint main() {\n\n    int n, k;\n    cin &gt;&gt; n &gt;&gt; k;\n\n    vector&lt;int&gt; v(n);\n    for (int i = 0; i &lt; n; i++) {\n        cin &gt;&gt; v[i];\n    }\n\n    long long ans = 0;\n    vector&lt;int&gt; sums;\n\n    int firsthalf = n/2+n%2;\n    int secondhalf = n - firsthalf;\n    for (int i = 0; i &lt; (1&lt;&lt;firsthalf); i++) {\n        long long sum = 0;\n        for (int j = 0; j &lt; firsthalf; j++) {\n            if (i &amp; (1&lt;&lt;j)) {\n                sum += v[j];\n            }\n        }\n\n        if (sum &lt;= k) {\n            sums.push_back(sum);\n        }\n    }\n\n    sort(sums.begin(), sums.end());\n\n    for (int i = 0; i &lt; (1&lt;&lt;secondhalf); i++) {\n        long long sum = 0;\n        for (int j = firsthalf; j &lt; n; j++) {\n            if (i &amp; (1&lt;&lt;(j - firsthalf))) {\n                sum += v[j];\n            }\n        }\n\n        if (sum &lt;= k) {\n            ans += bs(k - sum, sums) - bs(k - sum - 1, sums);\n        }\n    }\n\n    cout &lt;&lt; ans &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["optimizari","precalculare","brute force"]},{"location":"mediu/mitm/#problema-sum-of-four-values","title":"Problema Sum of Four Values","text":"<p>Un alt tip de probleme care se poate rezolva cu meet in the middle este acela \u00een care trebuie s\u0103 g\u0103sim o submul\u021bime de dimensiunea \\(x\\) cu o anumit\u0103 proprietate, iar abordarea pentru aceste probleme const\u0103 \u00een a crea submul\u021bimi de dimensiunea \\(\\frac{x}{2}\\) iar mai apoi, le vom uni \u00eentr-un mod similar cu cel de la prima problem\u0103, a\u0219a cum facem \u0219i aici.</p> <pre><code>#include &lt;iostream&gt;\n#include &lt;vector&gt;\n#include &lt;map&gt;\n\nusing namespace std;\n\nint main()\n{\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n\n    int n, x;\n    cin &gt;&gt; n &gt;&gt; x;\n\n    vector&lt;int&gt; v(n+1);\n    for (int i = 1; i &lt;= n; ++i) {\n        cin &gt;&gt; v[i];\n    }\n\n    map&lt;int, int&gt; mp;\n    for (int i = 2; i &lt;= n; ++i) {\n        for (int j = i+1; j &lt;= n; ++j) {\n            mp[v[i] + v[j]]++;\n        }\n    }\n\n    for (int i = 2; i &lt;= n; ++i) {\n        for (int j = i+1; j &lt;= n; ++j) {\n            if (mp[v[i] + v[j]] &gt;= 2) {\n                mp[v[i] + v[j]]--;\n            }\n            else {\n                mp.erase(v[i] + v[j]);\n            }\n        }\n        for (int j = i-1; j &gt;= 1; --j) {\n            if (mp.find(x - v[i] - v[j]) != mp.end()) {\n                int rem = x - v[i] - v[j];\n                cout &lt;&lt; j &lt;&lt; \" \" &lt;&lt; i &lt;&lt; \" \";\n                for (int q = i+1; q &lt;= n; ++q) {\n                    for (int p = q+1; p &lt;= n; ++p) {\n                        if (v[p] + v[q] == rem) {\n                            cout &lt;&lt; q &lt;&lt; \" \" &lt;&lt; p &lt;&lt; '\\n';\n                            return 0;\n                        }\n                    }\n                }\n            }\n        }\n    }\n    cout &lt;&lt; \"IMPOSSIBLE\";\n    return 0;\n}\n</code></pre>","tags":["optimizari","precalculare","brute force"]},{"location":"mediu/mitm/#concluzii","title":"Concluzii","text":"<p>Tehnica meet in the middle este o tehnic\u0103 util\u0103 pentru a \u00eembun\u0103t\u0103\u021bi timpul de execu\u021bie pentru foarte multe solu\u021bii ce se bazeaz\u0103 pe metode de tip brute-force. Fie c\u0103 e vorba de probleme cu restric\u021bii mici sau la care avem nevoie de submul\u021bimi mici, meet in the middle este o tehnic\u0103 foarte util\u0103 pentru diferite tipuri de aplica\u021bii.</p>","tags":["optimizari","precalculare","brute force"]},{"location":"mediu/mitm/#probleme-suplimentare","title":"Probleme suplimentare","text":"<ul> <li>Piese Lot Juniori 2017</li> <li>Infoarena loto</li> <li>23 - IIOT 2019-20</li> <li>OJI 2018 eq4</li> <li>Infoarena aiacubiti</li> <li>CEOI 2019 cubeword</li> <li>USACO Silver Field Day</li> <li>Probleme cu meet in the middle de pe Codeforces</li> <li>Probleme cu meet in the middle de pe Kilonova</li> </ul>","tags":["optimizari","precalculare","brute force"]},{"location":"mediu/mitm/#lectura-suplimentara","title":"Lectur\u0103 suplimentar\u0103","text":"<ul> <li>Meet in the middle - Errichto</li> <li>Meet in the middle - USACO Guide</li> <li>Infobits F1 - SEPI (pagina 89)</li> <li>Meet in the middle - infoarena</li> </ul>","tags":["optimizari","precalculare","brute force"]},{"location":"mediu/mobius/","title":"Func\u021bia M\u00f6bius","text":"<p>Autor: Matei Ionescu</p>"},{"location":"mediu/mobius/#notiuni-introductive","title":"No\u021biuni introductive","text":"<p>\u00cen teoria numerelor, o func\u021bie aritmetic\u0103 este o func\u021bie \\(f(n) : \\mathbb{N} \\to \\mathbb{C}\\). O func\u021bie aritmetic\u0103 exprim\u0103 propriet\u0103\u021bi aritmetice pentru \\(n\\).</p> <p>Pentru \\(m, n\\) numere prime \u00eentre ele (adic\u0103 \\(cmmdc(m, n) = 1\\)), avem dou\u0103 feluri de func\u021bii aritmetice:</p> <ul> <li>func\u021bii aditive, unde \\(f(mn) = f(n) + f(m)\\);</li> <li>func\u021bii multiplicative, unde \\(f(mn)\\) = \\(f(m)f(n)\\).</li> </ul> <p>Pentru simplitate vom defini urm\u0103toarele aspecte: </p> <ul> <li>\\([p] = 1\\) dac\u0103 \\(p\\) este o propozi\u021bie adev\u0103rat\u0103 sau 0 \u00een caz contrar.</li> <li>\\(\\lfloor n \\rfloor\\) = partea \u00eentreag\u0103 a lui \\(n\\).</li> </ul> <p>C\u00e2t \u0219i urm\u0103toarele propriet\u0103\u021bi celebre:</p> <ul> <li>\\(\\sum_{k = 1}^{N} \\frac{1}{k} \\approx \\log{N}\\).</li> <li>\u0218irul $ a_i = \\lfloor \\frac{N}{i} \\rfloor $, cu \\(\\leq N\\), are \\(O(\\sqrt N)\\) valori distincte.</li> </ul> <p>Pentru \\(\\forall p \\in \\mathbb{N}\\), \\(p\\) num\u0103r prim, \u0219i \\(\\forall k \\in \\mathbb{N}\\), definim urm\u0103toarele func\u021bii multiplicative:</p> <ul> <li>func\u021bia identic\u0103 \\(I(p^k) = p^k\\);</li> <li>func\u021bia putere \\(P_a(p^k) = p^{ka}\\), unde \\(a\\) este constant\u0103 (nu confund\u0103m cu func\u021bia exponen\u021biala \\(f_a(p^k) = a^{p^k}\\));</li> <li>func\u021bia unitate \\(U(p^k) = [p^k = 1]\\);</li> <li>func\u021bia divizorilor \\(\\sigma (p^k)\\) = num\u0103rul de divizori ai lui \\(p^k\\); </li> <li>indicatorul lui Euler $\\varphi(p^k) $ = \\(p^{k} - p^{k-1}\\), c\u00e2te numere \\(x\\), cu \\(1 \\leq x \\leq p^k\\) \u0219i \\(cmmdc(x, p^k) = 1\\) exist\u0103 </li> <li>func\u021bia M\u00f6bius \\(\\mu(p^k) = [k = 0] - [k = 1]\\).</li> </ul> <p>Defini\u021bie</p> <p>Dou\u0103 func\u021bii multiplicative , \\(f(n)\\) \u0219i $g(n) $,  sunt identice dac\u0103 pentru oricare \\(p\\) num\u0103r prim \u0219i oricare \\(k \\geq 0\\), \\(g(p^k) = f(p^k)\\).</p>"},{"location":"mediu/mobius/#precalcularea-functiilor-multiplicative","title":"Precalcularea func\u021biilor multiplicative","text":"<p>\u00cen contextul nostru, vom lucra cel mai des cu func\u021bii multiplicative, iar de cele mai multe ori avem nevoie s\u0103 \u0219tim valorile unei func\u021bii pentru un set mai larg de elemente. \u0218i se dovede\u0219te c\u0103 Ciurul \u00eenv\u0103\u021bat \u00een clasa a 6-a este bun nu numai la aflarea numerelor prime.</p> <p>\\subsection{Ciurul lui Eratostene}</p> <p>Acest algoritm este poate cel mai popular printre elevii de liceu \u0219i gimnaziu pentru a afla numerele prime \u00eentr-un interval. </p> <pre><code>vector&lt;int&gt; ciur(N+1);\nciur[0] = ciur[1] = 1;\nfor (int i = 2; i &lt;= N; i++) {\n    if (ciur[i] == 0) { //numarul i este prim\n        for (int j = 2 * i; j &lt;= N; j += i) {\n            ciur[j] = 1; //j se scrie ca i * p\n        }\n    }\n}\n</code></pre> <p>La finalul programului, \\(k\\) va fi num\u0103r prim doar dac\u0103 \\(\\operatorname{ciur}(k) = 0\\).</p> <p>Complexitatea de timp este \\(O(\\sum_{k=1}^N \\frac{N}{k}) = O(N \\log{N})\\). </p>"},{"location":"mediu/mobius/#ciur-liniar","title":"Ciur liniar","text":"<p>Observ\u0103m c\u0103 fiecare num\u0103r compus \\(X\\) este parcurs de c\u0103tre cel de-al doilea for de mai multe ori. Dac\u0103 am putea s\u0103 iter\u0103m prin fiecare num\u0103r compus exact o singur\u0103 dat\u0103 am ajunge la complexitatea de \\(O(N)\\). Re\u021binem \u00eentr-un vector auxiliar numerele prime, \u0219i pentru un \\(i\\) fixat vom parcurge numerele prime p\u00e2n\u0103 c\u00e2nd un num\u0103r prim  divide \\(i\\).</p> <pre><code>vector&lt;int&gt; prime;\nvector&lt;int&gt; is_composite(N+1);\n\nfor (int i = 2; i &lt;= n; i++) {\n    if (!is_composite[i]) \n        prime.push_back(i);\n    for (int j = 0; j &lt; prime.size() &amp;&amp; i * prime[j] &lt;= n; j++) {\n        is_composite[i * prime[j]] = 1;\n        if (i % prime[j]) \n            break;\n    }\n}\n</code></pre> <p>Demonstra\u021bie</p> <p>Ca s\u0103 demonstr\u0103m faptul c\u0103 ciurul de mai sus itereaz\u0103 prin fiecare num\u0103r compus exact odat\u0103 avem nevoie de cel mai mic factor prim al acestuia, \\(p\\). S\u0103 presupunem c\u0103 \\(q = i \\cdot p\\). Pentru oricare \\(j &gt; i\\), \\(j\\) este divizor a lui  \\(q\\), presupunem ca \\(k = \\frac{q}{j}\\) este prim. Cum \\(i &lt; j\\), atunci \\(k &lt; p\\), \u00eens\u0103 \\(p\\) este cel mai mic num\u0103r prim care divide \\(q\\), deci nu exist\u0103 un astfel \\(k\\). Deci odat\u0103 luat\u0103 \u00een considerare perechea \\((i, p)\\),\\, \\(i \\cdot p\\) va fi calculat doar o singur\u0103 dat\u0103, transform\u00e2nd complexitatea final\u0103 \u00een \\(O(N)\\).</p>"},{"location":"mediu/mobius/#precalcularea-indicatorului-lui-euler-folosind-ciurul-liniar","title":"Precalcularea indicatorului lui Euler folosind Ciurul Liniar","text":"<p>Pentru a calcula \\(\\varphi(n)\\) trebuie s\u0103 luam \u00een considerare \\(3\\) cazuri:</p> <ul> <li>\\(n\\) este prim \\(\\Rightarrow \\varphi(n) = n-1\\)</li> <li>\\(n = i \\cdot p\\) \u0219i \\(p \\nmid i \\Rightarrow \\varphi(n) = \\varphi(i) \\varphi(p)\\). Prin \\(a \\nmid b\\) \u00een\u021belegem : \"a nu divide pe b\".</li> <li>\\(n = i \\cdot p\\) \u0219i \\(p \\mid i\\). Acest caz este uneori greu de tratat, dar din fericire \u0219tim sigur c\u0103 \\(\\varphi(ip) = p\\varphi(i)\\ \\forall i, p\\).</li> </ul> <pre><code>vector&lt;int&gt; prime;\nvector&lt;int&gt; phi(N), compus(N);\nphi[1] = 1;\nfor (int i = 2; i &lt;= N; i++) {\n    if (!compus[i]) {\n        prime.push_back(i);\n        phi[i] = i - 1;\n    }\n    for (int j = 0; j &lt; prime.size() &amp;&amp; i * prime[j] &lt;= N; j++) {\n        compus[i * prime[j]] = 1;\n        if (i % prime[j]) {\n            phi[i * prime[j]] = phi[i] * phi[prime[j]];\n        }\n        else {\n            phi[i * prime[j]] = prime[j] * phi[i];\n        }\n    }\n}\n</code></pre>"},{"location":"mediu/mobius/#generalizare-a-ciurului-liniar","title":"Generalizare a ciurului liniar","text":"<p>Totu\u0219i, putem s\u0103 generaliz\u0103m algoritmul prezentat mai sus pentru a func\u021biona pentru oricare func\u021bie multiplicativ\u0103. Fie $sml(n) = $ puterea celui mai mic factor din descompunerea \u00een factori primi a lui \\(n\\). Pentru oricare \\(i\\) \u0219i \\(p\\), \\(p\\) cel mai mic num\u0103r prim care divide \\(i\\), putem scrie \\(f(ip) = f(\\frac{i}{p^{sml(i)}}) \\cdot f(p^{sml(i) + 1})\\).</p> <pre><code>vector&lt;int&gt; prime, phi(N+1), compus(N+1), sml(N+1);\nphi[1] = 1;\nfor (int i = 2; i &lt;= N; i++) {\n    if (!compus[i]) {\n        prime.push_back(i);\n        phi[i] = i - 1;\n        sml[i] = 1;\n    }\n    for (int j = 0; j &lt; prime.size() &amp;&amp; i * prime[j] &lt;= N; j++) {\n        compus[i * prime[j]] = 1;\n        if (i % prime[j]) {\n            phi[i * prime[j]] = phi[i] * phi[prime[j]];\n            sml[i * prime[j]] = 1;\n        }\n        else {\n            phi[i * prime[j]] = (phi[i] / (pow(prime[j], sml[i]) - pow(prime[j], sml[i] - 1)));\n            phi[i * prime[j]] *= (pow(prime[j], sml[i] + 1) - pow(prime[j], sml[i]));\n            sml[i * prime[j]] = sml[i] + 1;\n        }\n    }\n}\n</code></pre> <p>Aten\u021bie</p> <p>Func\u021bia pow din cod este o func\u021bie scris\u0103 de m\u00e2n\u0103. Nu recomand\u0103m folosirea func\u021biei pow din cmath, din cauza erorilor de precizie. </p> <p>G\u00e2ndim similar pentru func\u021bia M\u00f6bius: </p> <ul> <li>\\(n\\) prim \\(\\Rightarrow \\mu(n) = -1\\)</li> <li>\\(n = i \\cdot p\\), \\(p \\nmid i \\Rightarrow~\\mu(n) = \\mu(i) \\cdot \\mu(p)\\)</li> <li>\\(n = i \\cdot p\\), \\(p \\mid i \\Rightarrow~\\mu(n) = \\frac{\\mu(i)}{[sml(i)=0]-[sml(i)=1]} \\cdot ([sml(i)+1=0]-[sml(i)+1=1])\\).</li> </ul> <p>Observa\u021bie</p> <p>\u00cen cazul \u00een care frac\u021bia de mai sus nu este definit\u0103 (numitorul este \\(0\\)), putem spune din start c\u0103 \\(\\mu(n) = 0\\).</p> <pre><code>vector&lt;int&gt; prime;\nvector&lt;int&gt; sml(N), mobius(N), composite(N);\n\nmobius[1] = 1;\nfor (int i = 2; i &lt; N; i++) {\n    if (!composite[i]) {\n        prime.push_back(i);\n        mobius[i] = -1;\n        sml[i] = 1;\n    }\n    for (int j = 0; j &lt; prime.size() &amp;&amp; i * prime[j] &lt; N; j++) {\n        composite[i * prime[j]] = 1;\n        if (i % prime[j]) {\n            mobius[i * prime[j]] = mobius[i] * mobius[prime[j]];\n            sml[i * prime[j]] = 1;\n        }\n        else {\n            int cltr = (sml[i] == 0) - (sml[i] == 1);\n            int pl = (sml[i] + 1 == 0) - (sml[i] + 1 == 1);\n            if (cltr == 0) {\n                mobius[i] = 0;\n            }\n            else {\n                mobius[i * prime[j]] = (mobius[i] / cltr) * pl;\n            }\n            sml[i * prime[j]] = sml[i] + 1;\n        }\n    }\n}\n</code></pre>"},{"location":"mediu/mobius/#implementare-mai-populara","title":"Implementare mai popular\u0103","text":"<p>Rareori avem nevoie de ciur liniar, \u0219i dac\u0103 nu intr\u0103 \u00een timp \\(O(N \\log{N})\\) pentru precalculare, de ce ar intra \\(O(N)\\)? </p> <pre><code>vector&lt;int&gt; phi(N), mobius(N);\nphi[1] = mobius[1] = 1;\n\nfor (int i = 2; i &lt; N; i++) {\n    phi[i] = i-1;\n}\nfor (int i = 1; i &lt; N; i++) {\n    for (int j = 2 * i; j &lt; N; j+=i) {\n        mobius[j] -= mobius[i];\n        if (i &gt; 1) {\n            phi[j] -= phi[i];\n        }\n    }\n}\n</code></pre>"},{"location":"mediu/mobius/#inversiunea-lui-mobius","title":"Inversiunea lui M\u00f6bius","text":"<p>Ultimele din cele \\(3\\) func\u021bii prezentate la \u00eenceputul articolului sunt mai cunoscute ca restul, \u00eens\u0103 noi ne vom folosi cel mai mult de ultimele \\(2\\), anume indicatorul lui Euler \u0219i func\u021bia M\u00f6bius.</p> <p>Fie \\(g(n)\\) = \\(\\sum_{d\\mid n} f(d)\\). Inversiunea lui M\u00f6bius ne spune: $$     f(n) = \\sum_{d\\mid n} g(d) \\cdot \\mu \\left(\\frac{n}{d}\\right) $$ Cu toate astea, o proprietate mai important\u0103 este \\(\\sum_{d\\mid n} \\mu(d) = U(n)\\). Ceea ce sugereaz\u0103 expresia este c\u0103 pentru oricare num\u0103r natural \\(n\\) suma va da \\(1\\) doar dac\u0103 \\(n = 1\\). Pare nesemnificativ\u0103 proprietatea, \u00eens\u0103 este foarte util\u0103 \u00een rezolvarea multor probleme de informatic\u0103.</p> <p>Exerci\u021biu \\(1\\): Calculeaz\u0103 c\u00e2te perechi \\((a,b)\\) (\\(1 \\leq a,b \\leq n\\)) exist\u0103 cu proprietatea c\u0103 \\(gcd(a,b) = 1\\).</p> <p>Rezolvare: Noi trebuie s\u0103 calcul\u0103m \\(\\sum_{i=1}^{n} \\sum_{j=1}^{n} [cmmdc(i, j) = 1]\\). Ne putem folosi de proprietatea de mai sus \u0219i s\u0103 scriem rela\u021bia astfel:  $$     \\sum_{i=1}^{n} \\sum_{j=1}^{n} \\sum_{d \\mid cmmdc(i,j)} \\mu(d) $$ Iter\u0103m prin toate numerele \\(\\leq n\\) \u00een loc de divizorii lui \\(n\\) \u0219i ob\u021binem  $$     \\sum_{i=1}^{n} \\sum_{j=1}^{n} \\sum_{d = 1}^{n} \\mu(d) \\cdot [d\\mid cmmdc(i,j)] = \\sum_{i=1}^{n} \\sum_{j=1}^{n} \\sum_{d = 1}^{n} \\mu(d) \\cdot [d\\mid i] \\cdot [d\\mid j] $$ Rearanj\u0103m termenii \u0219i ob\u021binem $$     \\sum_{d=1}^{n} \\mu(d) \\left(\\sum_{i=1}^{n} [d\\mid i]\\right) \\left(\\sum_{j=1}^{n} [d\\mid j]\\right) $$ Observ\u0103m c\u0103  $$     \\sum_{i=1}^{n} [d\\mid i] = \\sum_{j=1}^{n} [d\\mid j] = \\left\\lfloor \\frac{n}{d} \\right\\rfloor $$ </p> <p>deci rela\u021bia final\u0103 devine \\(\\sum_{d=1}^{n} \\mu(d) \\cdot (\\frac{n}{d})^2\\), care poate fi calculat\u0103 \u00een \\bigO{n}.</p> <p>Exerci\u021biu \\(2\\): Calculeaz\u0103 c\u00e2te perechi \\((a,b)\\) exis\u0103, astfel \u00eenc\u00e2t \\(1 \\leq a,b \\leq n\\) \u0219i \\(cmmdc(a, b)\\) = \\(P\\).</p> <p>Rezolvare: </p> \\[     \\sum_{i=1}^{n} \\sum_{j=1}^{n} [cmmdc(i,j) = P] = \\sum_{i=1}^{\\frac{n}{P}} \\sum_{j=1}^{\\frac{n}{P}} [cmmdc(i,j) = 1] \\] <p>Observ\u0103m c\u0103 e identic cu exerci\u021biul precedent, rezultatul fiind \\(\\sum_{d=1}^{\\frac{n}{P}} \\mu(d) \\cdot \\left(\\frac{n}{dP}\\right)^2\\).\\</p> <p>Exerci\u021biul \\(3\\): Calculeaz\u0103 \\(\\sum_{1 \\leq i,j \\leq N} lcm(i,j)\\), unde $lcm(i,j) = $ cel mai mic multiplu comun al numerelor \\(i\\) \u0219i \\(j\\).</p> <p>Rezolvare: \u0218tim totu\u0219i c\u0103 \\(lcm(i,j) = \\dfrac{i\\cdot j}{cmmdc(i,j)}\\), astfel problema ne cere s\u0103 calcul\u0103m suma: $$     \\sum_{1 \\leq i, j \\leq N} \\dfrac{i \\cdot j}{cmmdc(i,j)} $$ Pentru a ne u\u0219ura calculul, putem defini: $$     f(k) = \\sum_{1 \\leq i, j \\leq N} \\dfrac{i \\cdot j}{cmmdc(i,j)} \\cdot [cmmdc(i,j) = k] $$ Observ\u0103m deci c\u0103 dac\u0103 \u0219tim suma produselor \\(i \\cdot j\\), cu \\(cmmdc(i,j) = k\\), fie aceast\u0103 sum\u0103 \\(p(k)\\), atunci rezultatul devine: $$     f(k) = \\dfrac{p(k)}{k} $$ Pentru a calcula \\(p(k)\\) ne putem folosi de func\u021bia mobius astfel:</p> \\[     p(k) = \\sum_{1 \\leq i,j \\leq N} i \\cdot j \\cdot [cmmdc(i,j) = k]\\\\      = \\sum_{a = 1}^{\\frac{N}{k}} \\sum_{b = 1}^{\\frac{N}{k}} a \\cdot b \\cdot k^2 \\cdot [cmmdc(a,b) = 1]\\\\     = \\sum_{a = 1}^{\\frac{N}{k}} \\sum_{b = 1}^{\\frac{N}{k}} a \\cdot b \\cdot k^2 \\cdot \\sum_{d = 1}^{\\frac{N}{k}} \\mu(d) \\cdot [d \\mid a] \\cdot [d\\mid b]\\\\     = k^2 \\cdot \\sum_{d=1}^{\\frac{N}{k}} \\mu(d) \\cdot \\left(\\sum_{a = 1}^{\\frac{N}{k}} a \\cdot [d \\mid a] \\right) \\cdot \\left(\\sum_{b=1}^{\\frac{N}{k}} b \\cdot [d \\mid b] \\right)\\\\  \\] <p>Observ\u0103m c\u0103: $$     \\sum_{a=1}^{\\frac{N}{k}} a \\cdot [d \\mid a] = \\sum_{b=1}^{\\frac{N}{k}} b \\cdot [d \\mid b] = \\left(d \\cdot (1 + 2 + \\dots + \\frac{N}{kd}) \\right) ^ 2 = \\left( d \\cdot \\dfrac{\\frac{N}{kd} \\cdot (\\frac{N}{kd} + 1)}{2} \\right) ^ 2 $$ Deci: $$     p(k) = k^2 \\cdot \\sum_{d = 1}^{\\frac{N}{k}} \\mu(d) \\cdot \\left( d \\cdot \\dfrac{\\frac{N}{kd} \\cdot (\\frac{N}{kd} + 1)}{2} \\right) ^ 2 $$ Revenim la problema noastr\u0103 ini\u021bial\u0103: $$     f(k) = \\frac{p(k)}{k} = k \\cdot \\sum_{d = 1}^{\\frac{N}{k}} \\mu(d) \\cdot \\left( d \\cdot \\dfrac{\\frac{N}{kd} \\cdot (\\frac{N}{kd} + 1)}{2} \\right) ^ 2 $$ Iar r\u0103spunsul final este \\(\\sum_{k=1}^{N} f(k)\\), care este calculabil \u00een \\(O(N \\log N)\\).</p>"},{"location":"mediu/mobius/#probleme-propuse-spre-rezolvare","title":"Probleme propuse spre rezolvare","text":""},{"location":"mediu/mobius/#problema-sumgcd-de-pe-kilonova","title":"Problema sumgcd de pe Kilonova","text":"<p>Pentru \\(N\\) \u0219i \\(M\\) date la tastatur\u0103, trebuie s\u0103 calcula\u021bi \\(\\sum_{V} cmmdc(V)\\), unde \\(V\\) reprezint\u0103 un \\(M\\)-tuplu. Un \\(M\\)-tuplu reprezint\u0103 o mul\u021bime de \\(M\\) elemente nu neap\u0103rat distincte cu valori cuprinse \u00eentre 1 \u0219i \\(N\\). Formal, noi trebuie s\u0103 calculam \\(\\sum_{i_1 = 1}^{N} \\sum_{i_2 = 1}^{N} \\dots \\sum_{i_M = 1}^{N} cmmdc(i_1, i_2, \\dots, i_M)\\).</p> <p>Dac\u0103 pentru un \\(K\\) fixat afl\u0103m c\u00e2te M-tupluri exist\u0103 cu \\cmmdc-ul egal cu \\(K\\), atunci putem rezolva foarte u\u0219or problema. Fie \\(f(K)\\) num\u0103rul de tupluri \\((m, n)\\) pentru care \\(cmmdc(m, n) = K\\): $$     f(K) = \\sum_{i_1 = 1}^{N} \\sum_{i_2 = 1}^{N} \\dots \\sum_{i_M = 1}^{N} [cmmdc(i_1, i_2, \\dots, i_M) = K] \\Leftrightarrow \\     \\Leftrightarrow f(k) = \\sum_{i_1 = 1}^{\\frac{N}{K}} \\sum_{i_2 = 1}^{\\frac{N}{K}} \\dots \\sum_{i_M = 1}^{\\frac{N}{K}} [cmmdc(i_1, i_2, \\dots, i_M) = 1] \\Leftrightarrow\\     \\Leftrightarrow f(k) = \\sum_{i_1 = 1}^{\\frac{N}{K}} \\sum_{i_2 = 1}^{\\frac{N}{K}} \\dots \\sum_{i_M = 1}^{\\frac{N}{K}} \\sum_{d = 1}^{\\frac{N}{K}} \\mu(d) \\cdot [d\\mid i_1] \\cdot \\dots \\cdot [d\\mid i_M] \\Leftrightarrow\\     \\Leftrightarrow f(k) = \\sum_{d = 1}^{\\frac{N}{K}} \\mu(d) \\cdot \\left(\\sum_{i_1 = 1}^{\\frac{N}{K}} [d\\mid i_1]\\right) \\cdots \\left(\\sum_{i_M = 1}^{\\frac{N}{K}} [d\\mid i_M]\\right) \\Leftrightarrow\\     \\Leftrightarrow f(k) = \\sum_{d = 1}^{\\frac{N}{K}} \\mu(d) \\cdot \\left(\\frac{N}{Kd}\\right)^M. $$</p> <p>Rezultatul problemei este dat de \\(\\sum_{i=1}^{N} f(i) \\cdot i\\). Complexitatea de timp pentru a calcula \\(f(K)\\) este \\bigO{\\frac{N}{K}\\log{M}}, astfel complexitatea final\u0103  este  $$     \\sum_{i=1}^{N} O(\\frac{N}{i} \\log{M})     = O(\\left(N + \\frac{N}{2} + \\frac{N}{3} + \\cdots + \\frac{N}{N}\\right) \\log{M})\\     = O(N \\left(1 + \\frac{1}{2} + \\frac{1}{3} + \\cdots + \\frac{1}{N}\\right) \\log{M})\\     = O(N\\log{N}\\log{M}). $$</p> <p>Alt\u0103 solu\u021bie este urm\u0103toarea: </p> <p>Vom pune pe cele \\(M\\) pozi\u021bii doar multiplii de \\(K\\), astfel se formeaz\u0103 \\(M^{\\lfloor\\frac{N}{K} \\rfloor}\\) \u0219iruri posibile, dintre care sc\u0103dem \\(f(K \\cdot Q), Q \\geq 1\\). $$     f(K) = M^{\\left\\lfloor \\frac{N}{K} \\right\\rfloor} - \\sum_{K\\mid i} f(i)\\     = M^{\\left\\lfloor \\frac{N}{K} \\right\\rfloor} - \\sum_{i=1}^{N} f(i) \\cdot [K\\mid i] \\     = M^{\\left\\lfloor \\frac{N}{K} \\right\\rfloor} - \\sum_{i=1}^{\\frac{N}{K}} f(K \\cdot i) $$</p> <p>Complexitatea devine: $$     \\sum_{i=1}^{N} O(\\left\\lfloor \\frac{N}{i} \\right\\rfloor + \\log{M}) = O(N \\left(1 + \\frac{1}{2} + \\frac{1}{3} + \\dots \\frac{1}{N}\\right) + N \\log{M})     = O(N \\log{N} + N \\log{M}) \\      = O(N\\left(\\log{N} + \\log{M}\\right))     = O(N\\log{(MN)}) $$ Putem precalcula puterile lui \\(M\\), ob\u021binem astfel \\(O(N \\log{N})\\).</p> <p>Ambele iau \\(100\\) puncte.</p>"},{"location":"mediu/mobius/#problema-cntgcd","title":"Problema cntgcd","text":"<p>Se dau dou\u0103 numere naturale \\(N\\) \u0219i \\(D\\). Calcula\u021bi c\u00e2te perechi de numere \\(A\\) \u0219i \\(B\\) mai mici ca \\(N\\) exist\u0103, astfel \u00eenc\u00e2t \\(cmmdc(A,B) = D\\). Perechea \\((A,B)\\) = \\((B, A)\\).</p> <p>Putem s\u0103 lu\u0103m rezultatul de la primul exerci\u021biu, pentru c\u0103 probleme sunt echivalente. Singura restric\u021bie este faptul c\u0103 perechea \\((A,B)\\) = \\((B,A)\\), dar putem efectiv s\u0103 \u00eemp\u0103r\u021bim rezultatul la 2. $$ ans = \\frac{\\sum_{d=1}^{\\frac{N}{D}} \\mu(d) \\cdot \\left(\\frac{N}{dD}\\right)^2 + 1}{2} $$ Solu\u021bia ia undeva la \\(45\\) puncte, datorit\u0103 faptului c\u0103 \\(D \\leq N \\leq 10^9\\).</p> <p>Fie \\(f(n)\\) = num\u0103rul de perechi \\((A,B)\\), unde \\(cmmdc(A,B) = 1\\). Noi trebuie s\u0103 calcul\u0103m practic \\(f(\\left\\lfloor \\frac{N}{D} \\right\\rfloor ) = \\sum_{d = 1}^{\\left\\lfloor \\frac{N}{D} \\right\\rfloor } \\varphi(d)\\).</p> <p>Pentru \\(N \\leq 10^6\\) putem calcula suma brut. Pentru \\(N &gt; 10^6\\) putem elimina perechile care au cmmdc-ul 2, 3 etc. $$     f(n) = \\frac{n^2 - n}{2} - \\sum_{d=2}^{n} f\\left(\\lfloor \\frac{n}{d} \\rfloor\\right) $$</p> <p>Datorit\u0103 faptului c\u0103 \u0219irul \\(a_i = \\lfloor \\frac{N}{i} \\rfloor\\) are \\(O(\\sqrt{N})\\) elemente diferite, putem doar s\u0103 calcul\u0103m c\u00e2te numere \\(d_1\\) exist\u0103, astfel \u00eenc\u00e2t \\(\\frac{n}{d} = \\frac{n}{d_1}\\) \u0219i s\u0103 adun\u0103m la rezultat \\(f(\\lfloor \\frac{n}{d} \\rfloor) \\cdot nr\\).</p> <p>Observa\u021bie</p> <p>Fie \\(d\\) = cel mai mic num\u0103r astfel \u00eenc\u00e2t \\(\\frac{n}{d} = x\\). Atunci cel mai mare num\u0103r care \u00eendepline\u0219te aceea\u0219i proprietate este \\(\\left\\lfloor \\frac{n}{\\lfloor \\frac{n}{d} \\rfloor} \\right\\rfloor\\).</p> <pre><code>long long f (long long n) {\n    //cout &lt;&lt; n &lt;&lt; '\\n';\n    if (n &lt;= 1000000) {\n        return sum_phi[n]; //phi(1) + phi(2) + ... + phi(n)\n    }\n    if (dp[n]) {\n        return dp[n];\n        //am calculat deja rezultatul pt n\n    }\n    long long ans = 1LL * (1LL * n * (n + 1)) / 2; \n    for (int i = 2, dr; i &lt;= n; i = dr + 1) {\n        dr = (n / (n / i));\n        if (dr &gt; n) {\n            break;\n        }\n        ans -= (dr - i + 1) * f(n / i);\n    }\n    dp[n] = ans;\n    return ans;\n}\n</code></pre> <p>Complexitatea algoritmului de mai sus este foarte interesant\u0103, ea fiind \\(O(N^\\frac{2}{3})\\).</p>"},{"location":"mediu/mobius/#problema-tupleco","title":"Problema tupleco","text":"<p>Se dau dou\u0103 numere \\(K\\) \u0219i \\(N\\). S\u0103 se afle \\(T\\), num\u0103rul de tupluri formate din \\(K\\) elemente \\((X_1, X_2, X_3, \\dots , X_K)\\) cu proprietatea c\u0103:</p> <ul> <li>\\(1 \\leq X_1 \\leq X_2 \\leq \\dots \\leq X_K \\leq N\\).</li> <li>\\(cmmdc(X_1, X_2, \\dots, X_K) = 1\\).</li> </ul>"},{"location":"mediu/mobius/#solutie-de-75-rightarrow-80-sau-chiar-100-de-puncte","title":"Solu\u021bie de \\(75 \\rightarrow 80\\) (sau chiar \\(100\\)) de puncte:","text":"<p>Ne vom folosi de func\u021bia M\u00f6bius pentru a calcula rezultatul. Dac\u0103 facem abstrac\u021bie de prima proprietate, r\u0103spunsul nostru devine: $$     \\sum_{d=1}^{N} \\mu(d) \\cdot \\lfloor \\frac{N}{d} \\rfloor ^K $$</p> <p>Ce \u00eenseamn\u0103 \u00eens\u0103 \\(\\lfloor \\dfrac{N}{d} \\rfloor ^ K\\)? Reprezint\u0103 num\u0103rul de \u0219iruri de lungime \\(K\\) , unde \\(X_i\\) este multiplu de \\(d\\). Ca s\u0103 num\u0103r\u0103m doar num\u0103rul de \u0219iruri care sunt sortate, ne vom folosi de Stars and Bars, astfel num\u0103rul de \u0219iruri \\((X_1, X_2, X_3, .. ,X_K)\\) cu \\(X_i \\leq X_{i+1} \\leq N\\) este egal cu \\(N-K+1 \\choose K\\). </p> <p>Rezultatul nostru devine:  $$     \\sum_{d=1}^{N} \\mu(d) \\cdot {\\left\\lfloor \\frac{N}{d} \\right\\rfloor - K + 1 \\choose K} $$ Solu\u021bia ruleaz\u0103 \u00een \\(O(N)\\) cu \\(O(N)\\) sau \\(O(N \\cdot \\log N)\\) precalcularea.</p> <pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\nconst int N = 1e7 + 1, mod = 3000017;\nint n, k;\nifstream fin (\"tupleco.in\");\nofstream fout (\"tupleco.out\");\n#define cin fin\n#define cout fout\nlong long C (int n, int k, vector&lt;long long&gt; &amp;f, vector&lt;long long&gt; &amp;invf) {\n    return (1ULL * f[n] * (1ULL * invf[k] * invf[n - k] % mod) % mod) % mod;\n}\nint main() {\n    cin.tie(0)-&gt;sync_with_stdio(0);\n    cin &gt;&gt; k &gt;&gt; n;\n    vector&lt;long long&gt; f(n + k + 1), inv(n + k + 1), invf(n + k + 1);\n    vector&lt;short&gt; mobius(n + 1);\n    f[0] = f[1] = inv[0] = inv[1] = invf[0] = invf[1] = 1;\n    for (int i = 2; i &lt;= n + k; i++) {\n        f[i] = (1ULL * f[i - 1] * i) % mod;\n        inv[i] = (1ULL * inv[mod % i] * (mod - mod / i)) % mod;\n        invf[i] = (1ULL * invf[i - 1] * inv[i]) % mod;\n    }\n\n    mobius[1] = 1;\n    for (int i = 1; i &lt;= n; i++) {\n        if (mobius[i]) {\n            for (int j = i + i; j &lt;= n; j += i) {\n                mobius[j] -= mobius[i];\n            }\n        }\n    }\n\n    long long ans = 0;\n    for (int d = 1; d &lt;= n; d++) {\n        int lt = n / d;\n        long long plt = C(lt + k - 1, k, f, invf);\n        if (mobius[d] == -1) {\n            ans = (1ULL * ans + mod - plt) % mod;\n        }\n        else \n            if (mobius[d] == 1) {\n                ans = (1ULL * ans + plt) % mod;\n            }\n    }\n    cout &lt;&lt; ans;\n}\n</code></pre>"},{"location":"mediu/mobius/#ok-dar-putem-mai-bine","title":"Ok, dar putem mai bine?","text":"<p>Ne folosim de ideea prezentat\u0103 la problema anterioar\u0103. $$     f(n) = {n-k+1 \\choose k} - \\sum_{d=2}^{n} f\\left(\\left\\lfloor \\frac{n}{d} \\right\\rfloor \\right). $$</p> <p>Observa\u021bie</p> <p>Deducem cu puternicele noastre sim\u021buri c\u0103 modulul (\\(M\\))  \u00een problema asta este mult mai mic dec\u00e2t \\(N\\), astfel putem s\u0103 calcul\u0103m combin\u0103rile mult mai rapid:</p> <ul> <li>\\(n \\leq M \\rightarrow\\) putem precalcula combin\u0103rile \u00een \\(O(M)\\).</li> <li>\\(\\displaystyle n &gt; M \\rightarrow {n \\choose k} \\      \\ \\text{modulo} \\ \\  M = {\\lfloor \\frac{n}{mod} \\rfloor \\choose \\lfloor \\frac{k}{mod} \\rfloor} \\cdot {n \\bmod M \\choose k \\bmod M} \\ \\  \\text{modulo} \\ \\ M\\)</li> </ul> <pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\nconst int mod = 3e6 + 17, N = 1e6 + 2;\nifstream fin (\"tupleco.in\");\nofstream fout (\"tupleco.out\");\n#define cin fin\n#define cout fout\nstruct Mint {\n    int val;\n    Mint (int x = 0) {\n        val = x % mod;\n    }\n    Mint (long long x) {\n        val = x % mod;\n    }\n    Mint operator+(Mint oth) {\n        return val + oth.val;\n    }\n    Mint operator*(Mint oth) {\n        return 1LL * val * oth.val;\n    }\n    Mint operator-(Mint oth) {\n        return val - oth.val + mod;\n    }\n    Mint fp (Mint a, long long n){\n        Mint p = 1;\n        while (n) {\n            if (n &amp; 1) {\n                p = p * a;\n            }\n            a = a * a;\n            n /= 2;\n        }\n        return p;\n    }\n    Mint operator/(Mint oth) {\n        Mint invers = fp(oth, mod - 2);\n        return 1LL * val * invers.val;\n    }\n    friend ostream &amp;operator&lt;&lt;(ostream &amp;os, const Mint &amp;lol) {\n        os &lt;&lt; lol.val;\n        return os;\n    }\n};\nvector&lt;Mint&gt; f(mod), invf(mod), inv(mod);\nMint C (int n, int k) {\n    if (n &lt; 0 || k &lt; 0 || n &lt; k)\n        return 0;\n    if (n &gt;= mod) {\n        return C(n / mod, k / mod) * C(n % mod, k % mod);\n    }\n    return f[n] * invf[n - k] * invf[k];\n}\nint n, k;\nunordered_map&lt;int, Mint&gt; mp;\nMint fr(int n) {\n    if (mp[n].val) {\n        return mp[n];\n    }\n    int dr = 2;\n    Mint total = C(n + k - 1, k);\n    while (dr &lt;= n) {\n        int ptr = n / (n / dr);\n        int lt = n / dr;\n        total = total - (fr(lt) * (ptr - dr + 1));\n        dr = ptr + 1;\n    }\n    mp[n] = total;\n    return total;\n}\nint main() {\n    f[0] = f[1] = inv[0] = inv[1] = invf[1] = invf[0] = 1;\n    for (int i = 2; i &lt; mod; i++) {\n        f[i] = f[i - 1] * i;\n        inv[i] = inv[mod % i] * (mod - mod / i);\n        invf[i] = invf[i - 1] * inv[i];\n    }\n\n    cin &gt;&gt; k &gt;&gt; n;\n    cout &lt;&lt; fr(n);\n}\n</code></pre>"},{"location":"mediu/mobius/#probleme-suplimentare","title":"Probleme suplimentare","text":""},{"location":"mediu/mobius/#probleme-de-la-olimpiade","title":"Probleme de la olimpiade","text":"<ul> <li>Pastile</li> <li>countall</li> <li>Gya-chan and the gcd operation</li> <li>Cowpability</li> </ul>"},{"location":"mediu/mobius/#probleme-de-pe-alte-siteuri","title":"Probleme de pe alte siteuri","text":"<ul> <li>List\u0103 de probleme cu Mobius</li> <li>Sum of gcd of Tuples (Hard)</li> </ul>"},{"location":"mediu/mobius/#bibliografie-si-lectura-suplimentara","title":"Bibliografie \u0219i lectur\u0103 suplimentar\u0103","text":"<ul> <li>Math note \u2014 M\u00f6bius inversion</li> <li>M\u00f6bius Function</li> <li>Prefix Sums of Multiplicative Functions </li> <li>M\u00f6bius inversion formula </li> </ul>"},{"location":"mediu/modular-inverse/","title":"Invers modular","text":"<p>Autor: Iuora\u0219 Andrei</p>","tags":["matematica","combinatorica"]},{"location":"mediu/modular-inverse/#problema","title":"Problema","text":"<p>\u00cen cadrul multor probleme de informatic\u0103 se cere calcularea unei valori \u0219i afi\u0219area acesteia modulo unei constante precizate \u00een enun\u021b. Se poate observa faptul c\u0103 opera\u021biile de adunare, sc\u0103dere \u0219i \u00eenmul\u021bire se pot efectua f\u0103r\u0103 probleme cu respect la un anumit modul, \u00eens\u0103 opera\u021bia de \u00eemp\u0103r\u021bire trebuie tratat\u0103 diferit. Mai exact, dac\u0103 \\(A\\), \\(B\\) si \\(M\\) sunt numere \u00eentregi, \\(M \\ne 0\\), \\(B \\ne 0\\), egalitatea \\(\\frac{A}{B} \\mod{M} = \\frac{A \\mod{M}}{B \\mod{M}} \\mod{M}\\) nu este \u00eentotdeauna adev\u0103rat\u0103.</p> <p>Se recomand\u0103 citirea informa\u021biilor din articolul despre matematic\u0103 de baz\u0103 \u00eenainte de a citi no\u021biunile de aici. </p>","tags":["matematica","combinatorica"]},{"location":"mediu/modular-inverse/#ce-este-inversul-modular","title":"Ce este inversul modular?","text":"<p>\u00cen matematic\u0103, inversul unui num\u0103r real \\(x\\) este acel num\u0103r \\(x^{-1}\\) care satisface \\(x \\cdot x^{-1} = 1\\). \u00cemp\u0103r\u021birea unui num\u0103r la \\(x\\) este echivalent\u0103 cu \u00eenmul\u021birea acestuia cu \\(x^{-1} = \\frac{1}{x}\\). Tot a\u0219a, \u0219i \u00een aritmetica modular\u0103 definim inversul modular al unui num\u0103r \\(x\\) (cu respect la modulul \\(M\\)) acel num\u0103r notat \\(x^{-1}\\) care satisface rela\u021bia \\(x \\cdot x^{-1} \\equiv{1} \\pmod{M}\\). Se poate demonstra faptul c\u0103 un num\u0103r \u00eentreg are un invers modular modulo \\(M\\) dac\u0103 \u0219i numai dac\u0103 el \u0219i \\(M\\) sunt prime \u00eentre ele.</p> <p>Atunci, pentru a efectua opera\u021bia de \u00eemp\u0103r\u021bire cu respect la modul dintre \\(A\\) \u0219i \\(B\\) trebuie s\u0103 \u00eel \u00eenmul\u021bim pe \\(A\\) cu inversul modular al lui \\(B\\), deoarece \\((\\frac{A}{B}) \\mod{M} = (A \\cdot B^{-1}) \\mod{M}\\).</p>","tags":["matematica","combinatorica"]},{"location":"mediu/modular-inverse/#cum-calculam-inversul-modular-al-unui-numar","title":"Cum calcul\u0103m inversul modular al unui num\u0103r?","text":"","tags":["matematica","combinatorica"]},{"location":"mediu/modular-inverse/#calcularea-folosind-mica-teorema-a-lui-fermat","title":"Calcularea folosind mica teorem\u0103 a lui Fermat","text":"<p>Mica teorem\u0103 a lui Fermat</p> <p>Dac\u0103 \\(p\\) este un num\u0103r prim \u0219i \\(a\\) este un num\u0103r \u00eentreg prim cu \\(p\\), atunci \\(a^{p-1} \\equiv 1 \\pmod{p}\\).</p> <p>Congruen\u021ba se mai poate scrie ca:</p> \\[ a \\cdot a^{p - 2} \\equiv 1 \\pmod{p} \\] <p>Se poate observa u\u0219or c\u0103 de fapt inversul modular al lui \\(a\\) este \\(a^{p - 2}\\), care poate fi calculat rapid folosind exponen\u021bierea logaritmic\u0103.</p>","tags":["matematica","combinatorica"]},{"location":"mediu/modular-inverse/#algoritmul-extins-al-lui-euclid","title":"Algoritmul extins al lui Euclid","text":"<p>Lu\u0103m \u00een considerare urm\u0103toarea identitate:</p> <p>Identitatea lui B\u00e9zout</p> <p>Fie numerele \u00eentregi \\(A\\), \\(B\\) \u0219i \\(d = cmmdc(A, B)\\). Atunci, exist\u0103 cel pu\u021bin o pereche de numere \u00eentregi \\(x\\) \u0219i \\(y\\) astfel \u00eencat \\(Ax + By = d\\).</p> <p>Daca \\(A\\) \u0219i \\(M\\) sunt prime \u00eentre ele, atunci exist\u0103 \\(x_1\\) \u0219i \\(y_1\\) astfel \u00eenc\u00e2t \\(Ax_1 + My_1 = 1\\). De aici reiese faptul c\u0103 \\(Ax_1 \\equiv 1 \\pmod{M}\\), adic\u0103 \\(x_1\\) este inversul modular al lui \\(A\\).</p> <p>Fie \\(c\\) c\u00e2tul \u00eemp\u0103r\u021birii lui \\(A\\) la \\(M\\) \u0219i \\(r\\) restul. Algoritmul lui Euclid ne spune c\u0103 \\(cmmdc(A, M) = cmmdc(M, r) \\implies cmmdc(M, r) = 1\\). Astfel, exist\u0103 \\(x_2\\) \u0219i \\(y_2\\) care satisfac \\(Mx_2 + ry_2 = 1\\).</p> <p>Dar</p> \\[ \\begin{align*} r = A - M \\cdot c &amp;\\implies Mx_2 + (A - M \\cdot c)y_2 = 1\\\\ &amp;\\iff Mx_2 + Ay_2 - M \\cdot c \\cdot y_2 = 1\\\\ &amp;\\iff Ay_2 + M(x_2 - c \\cdot y_2) = 1 \\end{align*} \\] <p>Se observa c\u0103 \\(x_1 = y_2\\) \u0219i \\(y_1 = x_2 - c \\cdot y_2\\), iar \\(c = \\lfloor \\frac{A}{M} \\rfloor\\). Astfel, putem folosi recursiv algoritmul lui Euclid, ad\u0103ug\u00e2ndu-i parametrii \\(x_1\\) \u0219i \\(y_1\\):</p> <pre><code>void euclidExtins(const int a, const int b, int&amp; x1, int&amp; y1);\n</code></pre> <p>\u00cen cazul \u00een care parametrul \\(b\\) din func\u021bie este egal cu \\(0\\), atunci \\(a\\) va fi egal cu \\(1\\) \u0219i astfel vom seta \\(x_1 = 1\\), iar \\(y_1\\) poate lua orice valoare, de exemplu tot \\(1\\).</p> <p>Aten\u021bie</p> <p>Valoarea lui \\(x_1\\) poate fi \u0219i negativ\u0103. Dac\u0103 este necesar\u0103 o valoare pozitiv\u0103 atunci facem opera\u021bia \\(x_1 = x_1 + M\\).</p> <p>Mai jos se poate observa o implementare \u00een C++ a algoritmului lui Euclid, respectiv a func\u021biei de calculare a inversului modular al lui \\(A\\) pentru modulul \\(M\\):</p> <pre><code>void euclidExtins(const int a, const int b, int&amp; x1, int&amp; y1) {\n    if (b == 0) {\n        x1 = 1;\n        y1 = 1;\n        return;\n    }\n\n    int x2, y2;\n\n    euclidExtins(b, a % b, x2, y2);\n\n    x1 = y2;\n    y1 = (x2 - a / b * y2) % M;\n}\n\nint inversModular(const int A) {\n    int x1, y1;\n\n    euclidExtins(A, M, x1, y1);\n\n    /* daca vrem x1 pozitiv\n    if(x1 &lt; 0)\n        x1 += M;\n    */\n\n    return x1;\n}\n</code></pre>","tags":["matematica","combinatorica"]},{"location":"mediu/modular-inverse/#probleme-cu-invers-modular","title":"Probleme cu invers modular","text":"<ul> <li>Invers Modular</li> <li>Prosum</li> <li>Codeforces Beautiful Numbers</li> <li>Toate aplicatiile prezentate la combinatorica</li> <li>Codeforces Sum of the kth powers</li> </ul>","tags":["matematica","combinatorica"]},{"location":"mediu/modular-inverse/#lectura-suplimentara","title":"Lectur\u0103 suplimentar\u0103","text":"<ul> <li>Algoritmul lui Euclid extins. Invers modular - Pbinfo</li> <li>Modular arithmetic - USACO Guide</li> <li>Modular multiplicative inverse</li> <li>Calculate modulo inverses efficiently</li> <li>Modular arithmetic for Beginners - Codeforces</li> <li>Func\u021bie scurt\u0103 de a calcula inversul modular - Codeforces</li> <li>Modular Inverse / Inverse Remainder / Modular Division \u2013 A Quick Guide - Codeforeces</li> </ul>","tags":["matematica","combinatorica"]},{"location":"mediu/number-bases/","title":"","text":""},{"location":"mediu/number-bases/#lectura-suplimentara","title":"Lectur\u0103 suplimentar\u0103","text":"<ul> <li>Baze de numeratie CPPI Sync</li> </ul>"},{"location":"mediu/olympiad-info/","title":"Informa\u021bii despre olimpiada de informatic\u0103","text":"<p>Autor: \u0218tefan-Cosmin D\u0103sc\u0103lescu</p>","tags":["meta","olimpiada","informatii"]},{"location":"mediu/olympiad-info/#introducere","title":"Introducere","text":"<p>Ai lucrat diferite tipuri de probleme \u0219i vrei s\u0103 participi la olimpiad\u0103? Dac\u0103 vrei s\u0103 ajungi s\u0103 ai \u0219ansa s\u0103 reprezin\u021bi \u0219coala, jude\u021bul sau chiar \u021bara \u00een diferite competi\u021bii, olimpiada este \u0219ansa ta. </p> <p>\u00cen acest articol, voi prezenta cum po\u021bi participa la olimpiad\u0103 \u0219i la alte concursuri de informatic\u0103 rom\u00e2ne\u0219ti, precum \u0219i informa\u021bii legate de ce trebuie s\u0103 \u00eenve\u021bi \u0219i formatul concursurilor. </p> <p>Disclaimer</p> <p>Acest articol are un caracter neoficial \u0219i reprezint\u0103 totalitatea informa\u021biilor str\u00e2nse de autor de-a lungul experien\u021bei sale la olimpiad\u0103, at\u00e2t ca participant, c\u00e2t \u0219i ca propun\u0103tor, \u00eempreun\u0103 cu informa\u021biile culese de pe siteul olimpiadei, a\u0219a cum erau ele \u00een septembrie \\(2024\\). Pentru informa\u021bii oficiale, contacta\u021bi organizatorii olimpiadei. </p>","tags":["meta","olimpiada","informatii"]},{"location":"mediu/olympiad-info/#olimpiada-nationala-de-informatica-oni","title":"Olimpiada Na\u021bional\u0103 de Informatic\u0103 (ONI)","text":"<p>Cu o tradi\u021bie de aproape \\(5\\) decenii \u00een diverse forme, olimpiada na\u021bional\u0103 de informatic\u0103 este principala competi\u021bie de algoritmic\u0103 rom\u00e2neasc\u0103 pentru elevii de gimnaziu \u0219i liceu. Competi\u021bia este organizat\u0103 separat pentru fiecare clas\u0103, astfel ai posibilitatea s\u0103 concurezi cu al\u021bi elevi din aceea\u0219i clas\u0103 cu tine. </p> <p>Observa\u021bie</p> <p>Po\u021bi concura \u0219i la o clas\u0103 superioar\u0103 v\u00e2rstei tale, iar \u00een mod particular dac\u0103 e\u0219ti \u00eentr-o clas\u0103 mai mic\u0103 de clasa a cincea, po\u021bi concura la olimpiad\u0103 la clasa a V-a \u0219i chiar s-o c\u00e2\u0219tigi.</p> <p>Aceast\u0103 olimpiad\u0103 s-a \u021binut \u00een fiecare an cu excep\u021bia anului \\(2020\\), atunci c\u00e2nd restric\u021biile impuse de virusul COVID-19 au for\u021bat anularea fazelor de dup\u0103 cea jude\u021bean\u0103.</p> <p>\u00cencep\u00e2nd cu anul \\(2021\\), olimpiada este organizat\u0103 de Societatea pentru Excelen\u021b\u0103 \u0219i Performan\u021b\u0103 \u00een Informatic\u0103 (SEPI), organiza\u021bie creat\u0103 de profesori, studen\u021bi \u0219i al\u021bi membri ai comisiilor de lucru ale olimpiadelor na\u021bionale de-a lungul anilor, cu scopul de a asigura continuitatea olimpiadei \u00een timpul pandemiei, iar ulterior, o desf\u0103\u0219urare c\u00e2t mai bun\u0103 a competi\u021biilor de informatic\u0103 rom\u00e2ne\u0219ti, \u00eempreun\u0103 cu ministerul educa\u021biei. </p>","tags":["meta","olimpiada","informatii"]},{"location":"mediu/olympiad-info/#cum-participi","title":"Cum participi?","text":"<p>Pentru a participa la olimpiad\u0103, trebuie s\u0103 iei leg\u0103tura cu profesorul t\u0103u de la clas\u0103 \u0219i atunci c\u00e2nd se public\u0103 formularul de \u00eenscriere, s\u0103 \u00eel completezi cu aten\u021bie, folosind datele tale de identificare corecte, respect\u00e2nd regulile \u00een vigoare. </p> <p>De asemenea, trebuie s\u0103 ai \u00een vedere c\u0103 limbajele de programare acceptate la olimpiad\u0103 sunt C, C++ \u0219i Pascal, dar de departe, cea mai bun\u0103 op\u021biune este limbajul C++, cu precizarea c\u0103 \u0219i limbajul C este o op\u021biune viabil\u0103 \u00een cele mai multe situa\u021bii.</p> <p>\u00cen timpul desf\u0103\u0219ur\u0103rii olimpiadei, toate informa\u021biile importante vor fi prezente pe site-ul SEPI, ei fiind responsabili de tot ce \u021bine informa\u021bii oficiale legate de olimpiad\u0103, premii \u0219i alte informa\u021bii ce \u021bin de jurisdic\u021bia SEPI.</p> <p>Dup\u0103 ce prime\u0219ti confirmarea de la organizatorii olimpiadei, po\u021bi participa la olimpiada jude\u021bean\u0103!</p>","tags":["meta","olimpiada","informatii"]},{"location":"mediu/olympiad-info/#formatul-si-etapele-olimpiadei","title":"Formatul \u0219i etapele olimpiadei","text":"<p>\u00cen cele mai multe jude\u021be, olimpiada de informatic\u0103 \u00eencepe cu etapa jude\u021bean\u0103 (OJI), dar \u00een unele jude\u021be \u0219i \u0219coli, exist\u0103 \u0219i o faz\u0103 preliminar\u0103, colocvial numit\u0103 etapa local\u0103. </p> <p>\u00cen unele jude\u021be, acest concurs este unul organizat \u00eentr-un format similar celui de la OJI, fiind o prim\u0103 selec\u021bie pentru elevi. Un astfel de exemplu este jude\u021bul Ia\u0219i, unde Olimpiada Municipal\u0103 de Informatic\u0103 are o tradi\u021bie de peste \\(20\\) de ani, problemele din anii anteriori g\u0103sindu-se aici.</p> <p>Fiecare problem\u0103 din concurs valoreaz\u0103 \\(100\\) de puncte, punctajul ob\u021binut fiind corespunz\u0103tor calit\u0103\u021bii solu\u021biilor pe care le trimi\u021bi. Cu alte cuvinte, cu c\u00e2t solu\u021bia ta trece de mai multe teste \u00een restric\u021biile impuse (timp \u0219i memorie), cu at\u00e2t vei ob\u021bine mai multe puncte. </p> <p>\u00cencep\u00e2nd cu anul \\(2021\\), sistemul de evaluare folosit este unul automat, \u00een timp real, serverul de concurs este bazat pe Contest Management System (CMS), sistemul folosit la competi\u021biile \u0219i olimpiadele interna\u021bionale de informatic\u0103. </p> <p>Observa\u021bie</p> <p>P\u00e2n\u0103 \u00een anul \\(2020\\), sistemul de evaluare era unul bazat pe colectarea solu\u021biilor participan\u021bilor folosind un stick USB, rezultatele fiind aflate dup\u0103 c\u00e2teva ore de la finalizarea concursului, acestea fiind publicate pe siteul olimpiada.info.</p> <p>La fel ca orice concurs, olimpiada de informatica are \u0219i ea programa ei, aici pute\u021bi g\u0103si cea mai recent\u0103 versiune a programei olimpiadei de informatic\u0103, cuno\u0219tin\u021bele fiind \u00eemp\u0103r\u021bite pe clase, \u00een func\u021bie de clasa la care pot \u00eencepe s\u0103 apar\u0103 astfel de probleme \u00een concurs. </p> <p>De asemenea, este evident faptul c\u0103 orice tentativ\u0103 de a frauda sau perturba concursul are drept consecin\u021b\u0103 excluderea de la olimpiada de informatic\u0103. </p>","tags":["meta","olimpiada","informatii"]},{"location":"mediu/olympiad-info/#olimpiada-judeteana-de-informatica-oji","title":"Olimpiada Jude\u021bean\u0103 de Informatic\u0103 (OJI)","text":"<p>Olimpiada Jude\u021bean\u0103 de Informatic\u0103 (OJI) reprezint\u0103 prima etap\u0103 de selec\u021bie ce are loc la nivel na\u021bional, aceasta organiz\u00e2ndu-se \u00een fiecare an, de regul\u0103 la mijlocul lunii martie.</p> <p>Aceasta const\u0103 \u00eentr-o singur\u0103 prob\u0103 de concurs, ce are loc la un centru jude\u021bean, iar \u00een func\u021bie de clasa \u00een care e\u0219ti, proba are urm\u0103torul format:</p> <ul> <li>Clasele V-VIII: O singur\u0103 prob\u0103 de concurs, cu durata de \\(3\\) ore \u0219i care con\u021bine \\(2\\) probleme. </li> <li>Clasele IX-XII: O singur\u0103 prob\u0103 de concurs, cu durata de \\(4\\) ore \u0219i care con\u021bine \\(3\\) probleme. </li> </ul> <p>Pentru a te califica la etapa na\u021bional\u0103, trebuie s\u0103 ob\u021bii m\u0103car \\(40\\%\\) din punctajul maxim (\\(80\\) sau \\(120\\) de puncte, \u00een func\u021bie de clas\u0103) \u0219i s\u0103 respec\u021bi m\u0103car unul din cele dou\u0103 criterii:</p> <ul> <li>Rezultatul ob\u021binut este cel mai bun din jude\u021bul/sectorul de unde e\u0219ti</li> <li>Rezultatul ob\u021binut nu este cel mai bun din jude\u021bul/sectorul de unde e\u0219ti, dar este \u00een primele \\(90 - x\\) locuri, unde \\(x\\) este num\u0103rul de elevi care s-au calificat conform primului criteriu (locul \\(1\\) pe jude\u021b/sector). \u00cen situa\u021bia \u00een care sunt mai mul\u021bi elevi pe locul \\(90\\) cu punctaj egal, to\u021bi se calific\u0103 la etapa na\u021bional\u0103. </li> </ul> <p>Pentru a rezolva problemele date \u00een anii anteriori, pute\u021bi s\u0103 accesa\u021bi urm\u0103toarea list\u0103: OJI pe Kilonova.</p>","tags":["meta","olimpiada","informatii"]},{"location":"mediu/olympiad-info/#olimpiada-nationala-de-informatica-oni_1","title":"Olimpiada Na\u021bional\u0103 de Informatic\u0103 (ONI)","text":"<p>Olimpiada Na\u021bional\u0103 de Informatic\u0103 (ONI) reprezint\u0103 faza na\u021bional\u0103 a olimpiadei, aici calific\u00e2ndu-se cei mai buni elevi din fiecare jude\u021b, aceasta organiz\u00e2ndu-se \u00een fiecare an, de regul\u0103 \u00een luna aprilie. \u00cen mod tradi\u021bional, faza na\u021bional\u0103 este \u00eemp\u0103r\u021bit\u0103 \u00een dou\u0103 (gimnaziu \u0219i liceu), fiecare dintre ele are loc \u00eentr-un alt ora\u0219, iar \u00een mod uzual, olimpiada are loc \u00een fiecare an \u00een ora\u0219e diferite.</p> <p>De\u0219i au existat diferite formate de-a lungul istoriei, \u00een prezent, proba olimpiadei na\u021bionale de informatic\u0103 este la fel pentru gimnaziu \u0219i liceu, const\u00e2nd \u00eentr-o singur\u0103 prob\u0103 ce are \\(3\\) probleme \u0219i \\(4\\) ore de concurs. </p> <p>Pentru a rezolva problemele date \u00een anii anteriori, pute\u021bi s\u0103 accesa\u021bi urm\u0103toarea list\u0103: ONI pe Kilonova.</p>","tags":["meta","olimpiada","informatii"]},{"location":"mediu/olympiad-info/#premii-mentiuni-si-medalii","title":"Premii, men\u021biuni \u0219i medalii","text":"<p>\u00cen func\u021bie de rezultatul ob\u021binut la clasa unde participi, se acord\u0103 urm\u0103toarele distinc\u021bii:</p> <p>Premii oferite de Ministerul Educa\u021biei:</p> <ul> <li>Premiile I, II \u0219i III care se acord\u0103 primilor \\(3\\) clasa\u021bi la olimpiad\u0103. </li> <li>Men\u021biuni care se acord\u0103 urm\u0103torilor \\(15\\%\\) dintre participan\u021bi. </li> </ul> <p>Premii oferite de SEPI:</p> <ul> <li>Medalie de aur - se acord\u0103 primilor \\(\\frac{1}{12}\\) participan\u021bi (dac\u0103 la olimpiad\u0103 particip\u0103 \\(90\\) de elevi, de regul\u0103 se acord\u0103 \\(7-8\\) medalii de aur)</li> <li>Medalie de argint - se acord\u0103 urm\u0103torilor \\(\\frac{2}{12}\\) participan\u021bi (dac\u0103 la olimpiad\u0103 particip\u0103 \\(90\\) de elevi, de regul\u0103 se acord\u0103 \\(15\\) medalii de argint)</li> <li>Medalie de bronz - se acord\u0103 urm\u0103torilor \\(\\frac{3}{12}\\) participan\u021bi (dac\u0103 la olimpiad\u0103 particip\u0103 \\(90\\) de elevi, de regul\u0103 se acord\u0103 \\(22-23\\) medalii de bronz)</li> </ul> <p>\u00cen general, primii \\(50\\%\\) dintre participan\u021bi ob\u021bin o medalie la olimpiad\u0103, aceasta fiind echivalentul calific\u0103rii la proba de baraj. </p> <p>Observa\u021bie</p> <p>Dac\u0103 exist\u0103 punctaje egale, comisia poate decide acordarea aceluia\u0219i premiu/medalie sau departajarea folosind regulamentul \u00een vigoare. </p> <p>Nu \u00een ultimul r\u00e2nd, \u00een func\u021bie de bugetul asigurat de sponsorii olimpiadei, rezultatele superioare vin \u0219i cu premii materiale valoroase, c\u00e2\u0219tig\u0103torii olimpiadei adjudec\u00e2ndu-\u0219i de regul\u0103 \u0219i device-uri precum laptopuri, telefoane sau alte obiecte similare \u00een valoare.</p> <p>Premiile ob\u021binute mai au un alt rol, \u00een func\u021bie de universitatea la care vrei s\u0103 studiezi, un premiu mai valoros \u00ee\u021bi poate asigura admiterea f\u0103r\u0103 examen, pe locurile specifice olimpicilor. De regul\u0103, o men\u021biune la olimpiada na\u021bional\u0103 ob\u021binut\u0103 \u00een clasele IX-XII este \u00eendeajuns pentru admiterea la facult\u0103\u021bile de profil din Rom\u00e2nia. </p>","tags":["meta","olimpiada","informatii"]},{"location":"mediu/olympiad-info/#proba-de-baraj","title":"Proba de baraj","text":"<p>Dac\u0103 ai ob\u021binut o medalie la ONI, ai dreptul s\u0103 participi la barajul de selec\u021bie pentru lotul na\u021bional. \u00cen func\u021bie de rezultatul pe care \u00eel ob\u021bii, po\u021bi deveni unul din membrii lotului na\u021bional de seniori sau juniori. </p> <p>Spre deosebire de OJI \u0219i ONI, barajul const\u0103 \u00een subiecte unice pentru grupa de v\u00e2rst\u0103 (juniori \u0219i seniori), dup\u0103 cum urmeaz\u0103:</p> <ul> <li>Juniori: o singur\u0103 prob\u0103 de concurs, cu \\(3\\) probleme \u0219i \\(4\\) ore. Se calific\u0103 \\(20\\) de elevi la lotul de juniori. </li> <li>Seniori: dou\u0103 probe de concurs, cu \\(3\\) probleme \u0219i \\(5\\) ore. Se calific\u0103 \\(30\\) de elevi la lotul de seniori.</li> </ul> <p>Un elev junior este un elev care este eligibil pentru participarea la Olimpiada European\u0103 de Informatic\u0103 pentru Juniori (EJOI), ceea ce presupune de regul\u0103 a fi n\u0103scut \u00een anul \\(x - 15\\) sau mai t\u00e2rziu. De exemplu, elevii eligibili pentru EJOI \\(2024\\) au fost cei n\u0103scu\u021bi \u00een \\(2009\\) sau mai t\u00e2rziu. </p> <p>Un elev senior este un elev care este eligibil pentru participarea la Olimpiada Interna\u021bional\u0103 de Informatic\u0103 (IOI), ceea ce presupune de regul\u0103 a avea cel mult \\(19\\) ani \u00eemplini\u021bi atunci c\u00e2nd IOI are loc. De exemplu, elevii eligibili pentru IOI \\(2024\\) au fost cei n\u0103scu\u021bi \u00een septembrie \\(2004\\) sau mai t\u00e2rziu. </p> <p>Pentru a rezolva problemele date \u00een anii anteriori, pute\u021bi s\u0103 accesa\u021bi urm\u0103toarele liste: </p> <ul> <li>Baraj Juniori pe Kilonova.</li> <li>Baraj Seniori pe Kilonova.</li> </ul> <p>Locurile corespunz\u0103toare loturilor na\u021bionale se acord\u0103 astfel:</p> <p>Se acord\u0103 c\u00e2te dou\u0103 locuri fiec\u0103rei clase, locuri ce revin celor mai buni \\(2\\) elevi de la acea clas\u0103, at\u00e2ta timp c\u00e2t ob\u021bin m\u0103car \\(20\\) de puncte la juniori, respectiv \\(30\\) de puncte la seniori. </p> <p>Celelalte \\(12\\), respectiv \\(22\\) de locuri se acord\u0103 elevilor r\u0103ma\u0219i cu punctajele cele mai mari la proba/probele de baraj. </p> <p>De asemenea, \u00een func\u021bie de rezultatele ob\u021binute la probele de baraj (juniori \u0219i seniori), se decide \u0219i echipa care reprezint\u0103 Rom\u00e2nia la Olimpiada European\u0103 de Informatic\u0103 pentru Fete (EGOI), fiind prioritare reprezentantele din lotul na\u021bional, iar mai apoi fetele cu cele mai bune rezultate la probele de baraj pentru seniori \u0219i juniori. </p>","tags":["meta","olimpiada","informatii"]},{"location":"mediu/olympiad-info/#lotul-national-de-informatica","title":"Lotul na\u021bional de informatic\u0103","text":"<p>Dac\u0103 ai ajuns la lot, vei avea \u0219ansa s\u0103 reprezin\u021bi Rom\u00e2nia la concursurile interna\u021bionale de juniori sau seniori, cu condi\u021bia s\u0103 te plasezi \u00een primele locuri la lotul na\u021bional. </p> <p>Formatul concursurilor este acela\u0219i cu cel de la baraj, \\(3\\) probleme \u0219i \\(4\\) ore la juniori, respectiv \\(3\\) probleme \u0219i \\(5\\) ore la seniori, nivelul problemelor fiind similar rigorilor concursurilor interna\u021bionale la care particip\u0103 \u021bara noastr\u0103. </p> <p>Pentru a rezolva problemele date \u00een anii anteriori, pute\u021bi s\u0103 accesa\u021bi urm\u0103toarele liste: </p> <ul> <li>Lot Juniori pe Kilonova.</li> <li>Lot Seniori pe Kilonova.</li> </ul> <p>\u00cen anul \\(2024\\), lotul na\u021bional a fost format din dou\u0103 tabere de preg\u0103tire \u0219i selec\u021bie, care au avut loc la Cluj-Napoca \u0219i Or\u0103\u0219tie \u00een luna mai. Fiecare dintre tabere a avut dou\u0103 probe de concurs, numeroase activit\u0103\u021bi educative dar \u0219i excursii \u0219i multe alte experien\u021be. </p> <p>\u00cen prima tab\u0103r\u0103, \\(30\\) de seniori \u0219i \\(20\\) de juniori au participat, iar la finalul primelor dou\u0103 baraje, primii \\(20\\) de seniori \u0219i \\(12\\) juniori s-au calificat la lotul restr\u00e2ns de informatic\u0103. </p> <p>\u00cen cea de-a doua tab\u0103r\u0103, \\(20\\) de seniori \u0219i \\(12\\) juniori au participat, iar la finalul celor patru baraje, s-au ales echipele reprezentative \u00een func\u021bie de rezultatele ob\u021binute de elevi de-a lungul barajelor. </p> <p>De regul\u0103, primii \\(4\\) seniori reprezint\u0103 Rom\u00e2nia la IOI \u0219i CEOI, iar urm\u0103torii \\(4\\) seniori reprezint\u0103 Rom\u00e2nia la BOI. \u00cen func\u021bie de competi\u021biile care mai apar, membrii lotului pot reprezenta \u021bara noastr\u0103 \u0219i la alte competi\u021bii, precum RMI, IATI etc. </p> <p>De regul\u0103, primii \\(4\\) juniori reprezint\u0103 Rom\u00e2nia la EJOI \u0219i JBOI, iar membrii lotului restr\u00e2ns reprezint\u0103 Rom\u00e2nia la Info(1) Cup. \u00cen func\u021bie de competi\u021biile care mai apar, membrii lotului pot reprezenta \u021bara noastr\u0103 \u0219i la alte competi\u021bii, precum IATI etc. </p> <p>Lista complet\u0103 de competi\u021bii interna\u021bionale la care particip\u0103 Rom\u00e2nia \u00een 2024 poate fi accesat\u0103 aici. </p>","tags":["meta","olimpiada","informatii"]},{"location":"mediu/olympiad-info/#concluzii","title":"Concluzii","text":"<p>De\u0219i drumul spre glorie la nivel na\u021bional \u0219i interna\u021bional este unul destul de lung, este un drum care merit\u0103 str\u0103b\u0103tut dac\u0103 e\u0219ti pasionat \u0219i vrei s\u0103 devii c\u00e2t mai bun. </p> <p>Personal, de-a lungul anilor am cunoscut foarte mul\u021bi oameni de valoare datorit\u0103 olimpiadelor \u0219i pe l\u00e2ng\u0103 succesul oferit de medalii, diplome \u0219i alte asemenea distinc\u021bii, prietenii \u0219i colegii pe care i-am cunoscut reprezint\u0103 de departe cel mai mare avantaj al atingerii unui nivel \u00eenalt, fie c\u0103 e vorba de gimnaziu, liceu sau chiar ulterior, \u00een comisiile de lucru. </p>","tags":["meta","olimpiada","informatii"]},{"location":"mediu/olympiad-info/#informatii-suplimentare","title":"Informa\u021bii suplimentare","text":"<ul> <li>Regulamentul oficial al olimpiadei \u00een anul \u0219colar 2023-2024</li> <li>Programa olimpiadei de informatic\u0103</li> </ul>","tags":["meta","olimpiada","informatii"]},{"location":"mediu/pinex/","title":"Principiul includerii \u0219i excluderii (pinex)","text":"<p>Autor: \u0218tefan-Cosmin D\u0103sc\u0103lescu</p> <p>\u00cen unele probleme de algoritmic\u0103, suntem nevoi\u021bi s\u0103 calcul\u0103m num\u0103rul de r\u0103spunsuri care se potrivesc cu o anumit\u0103 regul\u0103, dar num\u0103rarea direct\u0103 a fiec\u0103rei reguli \u00een mod individual nu aduce cu u\u0219urin\u021b\u0103 r\u0103spunsul corect. \u00cen cazul acestor probleme, vom apela la un principiu matematic folosit \u00een foarte mul\u021bi algoritmi elementari studia\u021bi p\u00e2n\u0103 acum, formaliz\u00e2nd discu\u021bia \u0219i aduc\u00e2nd mai multe asemenea probleme \u00een discu\u021bie. </p> <p>Defini\u021bie</p> <p>Principiul includerii \u0219i al excluderii (de asemenea denumit pinex) este un principiu matematic care este folosit atunci c\u00e2nd vrem s\u0103 afl\u0103m reuniunea a dou\u0103 sau mai multe mul\u021bimi, generaliz\u00e2ndu-se modul de calculare a r\u0103spunsurilor pentru aceast\u0103 clas\u0103 de probleme. </p> <p>Cu alte cuvinte, dac\u0103 avem dou\u0103 sau mai multe condi\u021bii care se intersecteaz\u0103, vrem s\u0103 evit\u0103m num\u0103rarea de mai multe ori a unor elemente. Vom pleca de la exemple simple pentru a putea generaliza mai u\u0219or. </p>","tags":["matematica","combinatorica","multimi"]},{"location":"mediu/pinex/#aplicarea-pinex-pentru-doua-multimi","title":"Aplicarea PINEX pentru dou\u0103 mul\u021bimi","text":"<p>Dac\u0103 avem dou\u0103 mul\u021bimi \\(A\\) \u0219i \\(B\\), pentru a afla num\u0103rul de valori care se reg\u0103sesc \u00een cel pu\u021bin una dintre mul\u021bimi putem s\u0103 sc\u0103dem din suma cardinalelor lui \\(A\\) \u0219i \\(B\\), cardinalul intersec\u021biei celor dou\u0103 mul\u021bimi. Mai formal, vom avea urm\u0103toarea formul\u0103:</p> \\[ |A \\cup B| = |A| + |B| - |A \\cap B| \\] <p>Se poate observa c\u0103 versiuni rudimentare ale acestei tehnici au fost folosite \u0219i \u00een cazul calcul\u0103rii unor r\u0103spunsuri pe baza sumelor par\u021biale (suma valorilor de la pozi\u021bia \\(L\\) la \\(R\\) este suma primelor \\(R\\) valori din care sc\u0103dem suma primelor \\(L-1\\) valori) sau \u00een cazul unor alte probleme celebre.</p>","tags":["matematica","combinatorica","multimi"]},{"location":"mediu/pinex/#problema-moobuzz-usaco-silver","title":"Problema MooBuzz - USACO Silver","text":"<p>Aceast\u0103 problem\u0103 este o adaptare a celebrei probleme FizzBuzz, cer\u00e2ndu-se aflarea celui de-al \\(n\\)-lea num\u0103r scris pe tabl\u0103. Pentru a face acest lucru, vom putea c\u0103uta binar r\u0103spunsul, \u0219tiind c\u0103 la fiecare pas, putem afla c\u00e2te numere au fost scrise pe tabl\u0103 care sunt mai mici sau egale cu \\(k\\). </p> <p>Pentru aflarea acestui r\u0103spuns, vom avea dou\u0103 mul\u021bimi:</p> <ul> <li>\\(A = \\{x | x \\ \\% \\ 3 = 0, x \\leq k \\}\\)</li> <li>\\(B = \\{x | x \\ \\% \\ 5 = 0, x \\leq k \\}\\)</li> </ul> <p>Este evident c\u0103 vom sc\u0103dea din \\(|A| + |B|\\) valoarea \\(|A \\cap B|\\), care reprezint\u0103 mul\u021bimea numerelor care se \u00eempart la \\(15\\), solu\u021bia devenind una \u00een timp constant, singurul factor de timp prezent fiind cel corespunz\u0103tor c\u0103ut\u0103rii binare. Mai jos pute\u021bi g\u0103si implementarea \u00een limbajul C++.</p> <pre><code>#include &lt;fstream&gt;\nusing namespace std;\n\nint main() {\n    ifstream cin(\"moobuzz.in\");\n    ofstream cout(\"moobuzz.out\");\n\n    int n;\n    cin &gt;&gt; n;\n\n    long long L = 1;\n    long long R = 2000000000;\n    long long ans = 0;\n\n    while (L &lt;= R) {\n        long long mid = (L + R) / 2;\n        long long cnt = mid/3 + mid/5 - mid/15;\n        if (mid - cnt &gt;= n) {\n            ans = mid;\n            R = mid - 1;\n        }\n        else {\n            L = mid + 1;\n        }\n    }\n\n    cout &lt;&lt; ans &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["matematica","combinatorica","multimi"]},{"location":"mediu/pinex/#aplicarea-pinex-pentru-trei-sau-mai-multe-multimi","title":"Aplicarea PINEX pentru trei sau mai multe mul\u021bimi","text":"<p>Pentru a aplica aceea\u0219i formul\u0103 pentru trei sau mai multe mul\u021bimi, vom prezenta o proprietate important\u0103 care ne va ajuta de-a lungul formulelor viitoare. </p> <p>Observa\u021bie</p> <p>Pentru a calcula r\u0103spunsul unei probleme la care va trebui s\u0103 aplic\u0103m acest principiu, vom aduna mereu la r\u0103spuns num\u0103rul elementelor care se afl\u0103 \u00eentr-un num\u0103r impar de mul\u021bimi \u0219i vom sc\u0103dea din r\u0103spuns cele care apar \u00eentr-un num\u0103r par de mul\u021bimi.</p> <p></p> <p>De exemplu, c\u00e2nd avem trei mul\u021bimi, formula de mai devreme devine</p> \\[ |A \\cup B \\cup C| = |A| + |B| + |C| - |A \\cap B| - |A \\cap C| - |B \\cap C| + |A \\cap B \\cap C| \\] <p>\u00cen mod general, dac\u0103 avem \\(k\\) mul\u021bimi, r\u0103spunsul va deveni urm\u0103torul, unde \\(A_i\\) reprezint\u0103 cea de-a \\(i\\)-a mul\u021bime:</p> \\[ \\left| \\bigcup_{i=1}^n A_i \\right| = \\sum_{i=1}^n|A_i| - \\sum_{1\\leq i&lt;j\\leq n} |A_i \\cap A_j| + \\sum _{1\\leq i&lt;j&lt;k\\leq n}|A_i \\cap A_j \\cap A_k| - \\cdots + (-1)^{n-1} | A_1 \\cap \\cdots \\cap A_n | \\] <p>Pe scurt, formula va deveni urm\u0103toarea:</p> \\[ \\bigg|\\bigcup_{i=1}^nA_i \\bigg|= \\sum_{0 \\neq J \\in \\{1, 2,...,n\\} } (-1)^{|J|-1} \\bigg| \\bigcap_{j \\in J} A_j \\bigg| \\] <p>Acest lucru ne garanteaz\u0103 c\u0103 pentru un element care apare \u00een mai multe mul\u021bimi, de\u0219i este adunat individual de mai multe ori, se scad p\u0103r\u021bile care apar \u00een plus \u00een calculul final. </p> <p>Observa\u021bie</p> <p>Dac\u0103 avem de-a face cu o problem\u0103 la care trebuie s\u0103 recurgem la aflarea complementului r\u0103spunsului folosind PINEX, termenii care se adun\u0103 \u0219i cei care se scad se inverseaz\u0103. </p>","tags":["matematica","combinatorica","multimi"]},{"location":"mediu/pinex/#problema-prime-multiples","title":"Problema Prime Multiples","text":"<p>Pentru a afla c\u00e2te valori se \u00eempart la m\u0103car unul din cele \\(n\\) numere prime date, vom afla pentru fiecare submul\u021bime de numere c\u00e2te numere se \u00eempart la produsul numerelor din submul\u021bime, adun\u00e2nd sau sc\u0103z\u00e2nd din r\u0103spuns dup\u0103 caz. Pentru a face asta u\u0219or, vom reprezenta fiecare submul\u021bime folosind o masc\u0103 pe bi\u021bi, tehnic\u0103 explicat\u0103 \u00een acest articol. Singurul lucru la care trebuie avut grij\u0103 este ob\u021binerea produselor submul\u021bimilor, pentru a evita overflow-urile. </p> <pre><code>#include &lt;iostream&gt;\n#include &lt;vector&gt;\n\nusing namespace std;\n\nint main() {\n    long long n, k;\n    cin &gt;&gt; n &gt;&gt; k;\n\n    vector&lt;long long&gt; v(k);\n    for (int i = 0; i &lt; k; ++i) {\n        cin &gt;&gt; v[i];\n    }\n\n    long long sum = 0;\n    for (int msk = 1; msk &lt; (1&lt;&lt;k); ++msk) {\n        long long prod = 1;\n        int cnt = 0;\n        for(int i = 0; i &lt; k; ++i) {\n            if(msk &amp; (1&lt;&lt;i)) {\n                if(n / prod &lt; v[i]) { // evitam overflowul\n                    prod = n+1;\n                }\n                else {\n                    prod = prod * v[i];\n                }\n                ++cnt;\n            }\n        }\n        if (cnt % 2 == 1) {\n            sum += n/prod;\n        }\n        else {\n            sum -= n/prod;\n        }\n    }\n\n    cout &lt;&lt; sum;\n    return 0;\n}\n</code></pre>","tags":["matematica","combinatorica","multimi"]},{"location":"mediu/pinex/#aplicarea-pinex-in-probleme-mai-complexe","title":"Aplicarea PINEX \u00een probleme mai complexe","text":"<p>Pe l\u00e2ng\u0103 aplicarea func\u021biei M\u00f6bius \u00een problemele dificile ce folosesc PINEX, se mai reg\u0103se\u0219te o form\u0103 de aplicare a acestui principiu, atunci c\u00e2nd trebuie s\u0103 num\u0103r\u0103m c\u00e2te perechi sau mul\u021bimi de valori au o anumit\u0103 valoare a unei func\u021bii. De foarte multe ori, func\u021biile ce apar \u00een aceste probleme sunt multiplicative, deci scopul va fi acela de a exclude mul\u021bimile care au drept r\u0103spuns o valoare multiplu de num\u0103rul pe care \u00eel c\u0103ut\u0103m.</p>","tags":["matematica","combinatorica","multimi"]},{"location":"mediu/pinex/#problema-counting-coprime-pairs","title":"Problema Counting Coprime Pairs","text":"<p>Pentru a afla num\u0103rul de perechi de numere prime \u00eentre ele, vom afla pentru fiecare valoare posibil\u0103 a celui mai mare divizor comun c\u00e2te asemenea perechi exist\u0103. Pentru a face acest lucru, vom itera \u00een ordine descresc\u0103toare \u0219i vom afla mai \u00eent\u00e2i num\u0103rul de numere multiple cu \\(i\\) din \u0219irul dat, iar mai apoi vom sc\u0103dea din num\u0103rul de perechi posibile care se pot genera, num\u0103rul de perechi deja aflate la pa\u0219ii anteriori, c\u00e2nd am verificat valori mai mari ale celui mai mare divizor comun. Mai jos se poate vedea o asemenea implementare.</p> <pre><code>#include &lt;iostream&gt;\n#include &lt;vector&gt;\n\nusing namespace std;\n\nint main()\n{\n    vector&lt;long long&gt; fr(1000001), cnt(1000001);\n\n    int n;\n    cin &gt;&gt; n;\n\n    for (int i = 1; i &lt;= n; ++i) {\n        int val;\n        cin &gt;&gt; val;\n        fr[val]++;\n    }\n\n    long long ans = 1LL * n * (n-1) / 2;\n    for (int i = 1000000; i &gt;= 2; --i) {\n        long long val = 0;\n        // aflam cate valori sunt multipli de i\n        for (int j = i; j &lt;= 1000000; j += i) {\n            val += fr[j];\n        }\n        cnt[i] = val * (val-1) / 2;\n        // scadem perechile deja calculate\n        for (int j = i+i; j &lt;= 1000000; j += i) {\n            cnt[i] -= cnt[j];\n        }\n        ans -= cnt[i];\n    }\n\n    cout &lt;&lt; ans;\n    return 0;\n}\n</code></pre>","tags":["matematica","combinatorica","multimi"]},{"location":"mediu/pinex/#concluzii","title":"Concluzii","text":"<p>Principiul includerii \u0219i excluderii este un principiu ce se dovede\u0219te a fi util \u00een foarte multe probleme de num\u0103rare, cunoa\u0219terea acestuia dovedindu-se a fi esen\u021bial\u0103 \u00een multe probleme, \u00eencep\u00e2nd de la concursurile de juniori (lot, concursuri interna\u021bionale) \u0219i termin\u00e2nd cu diverse competi\u021bii online \u00een care teoria numerelor \u00ee\u0219i face apari\u021bia. Mai t\u00e2rziu, func\u021bii sau constante ce se bazeaz\u0103 pe PINEX vor demonstra o dat\u0103 \u00een plus utilitatea acestui principiu. Problemele de mai jos pot avea \u0219i alte abord\u0103ri, \u00een afar\u0103 de cea cu PINEX, toate fiind foarte utile \u0219i folositoare \u00een competi\u021biile de informatic\u0103. </p>","tags":["matematica","combinatorica","multimi"]},{"location":"mediu/pinex/#probleme-suplimentare","title":"Probleme suplimentare","text":"<ul> <li>infoarena frac</li> <li>infoarena reuniune</li> <li>infoarena pairs</li> <li>Codeforces Orac and LCM</li> <li>OJI 2024 Poseidon</li> <li>Codeforces Count GCD</li> <li>USACO Gold Cowpability</li> <li>Codeforces Small GCD</li> <li>Lot Juniori 2015 cardinal</li> <li>Lot Juniori 2019 divizori</li> <li>Lot Juniori 2024 pmo</li> <li>Lot Juniori 2023 countall</li> <li>ONI 2023 Comun</li> <li>RoAlgo Contest #1 Echipe</li> <li>infoarena cowfood</li> <li>ONI 2023 Baraj Seniori Secvxor</li> <li>ONI 2019 TreeGCD</li> <li>ONI 2013 Xnumere</li> <li>kilonova polyglot</li> <li>Atcoder DP Contest Grid 2</li> <li>Probleme cu PINEX de pe Kilonova</li> </ul>","tags":["matematica","combinatorica","multimi"]},{"location":"mediu/pinex/#lectura-suplimentara","title":"Lectur\u0103 suplimentar\u0103","text":"<ul> <li>Pinex - Infoarena</li> <li>Inclusion-Exclusion Principle - Codeforces</li> <li>The Inclusion-Exclusion Principle - CP-algorithms</li> <li>Inclusion-Exclusion Principle - USACO Guide</li> <li>PIE - University of Victoria</li> <li>Principiul includerii \u0219i excluderii - Viitori Olimpici</li> <li>Inclusion\u2013exclusion principle - Wikipedia</li> <li>Principle of Inclusion and Exclusion (PIE) - Brilliant</li> </ul>","tags":["matematica","combinatorica","multimi"]},{"location":"mediu/pow-log/","title":"Aritmetic\u0103 modular\u0103. Ridicare la putere \u00een timp logaritmic","text":"<p>Autor: \u0218tefan-Cosmin D\u0103sc\u0103lescu</p>","tags":["algebra","optimizari","modulo"]},{"location":"mediu/pow-log/#introducere","title":"Introducere","text":"<p>De multe ori, sunten nevoi\u021bi s\u0103 calcul\u0103m diverse valori modulo \\(x\\) sau s\u0103 calcul\u0103m puteri foarte mari \u00eentr-o manier\u0103 care s\u0103 ne permit\u0103 s\u0103 ob\u021binem r\u0103spunsurile c\u00e2t mai rapid. </p> <p>Pentru a calcula aceste puteri, vom vrea s\u0103 optimiz\u0103m metoda clasic\u0103 de a \u00eenmul\u021bi rezultatul cu baza de fiecare dat\u0103 p\u00e2n\u0103 c\u00e2nd ajungem la r\u0103spunsul optim, a\u0219a c\u0103 se impune folosirea unor observa\u021bii matematice care ne ajut\u0103 s\u0103 calcul\u0103m expresii de acest gen mult mai rapid. </p>","tags":["algebra","optimizari","modulo"]},{"location":"mediu/pow-log/#fundamente-ale-calcului-modular","title":"Fundamente ale calcului modular","text":"<p>\u00cenainte s\u0103 prezent\u0103m subiectul articolului, trebuie s\u0103 prezent\u0103m ni\u0219te fundamente care ne vor ajuta s\u0103 \u00een\u021belegem mai bine conceptul de aici. Vom presupune c\u0103 \\(a\\) \u0219i \\(b\\) sunt numere naturale, cuprinse \u00eentre \\(0\\) \u0219i \\(mod - 1\\).</p>","tags":["algebra","optimizari","modulo"]},{"location":"mediu/pow-log/#adunarea-modulara","title":"Adunarea modular\u0103","text":"<p>Observa\u021bie</p> <ul> <li>\\((a + b)\\ \\% \\ mod = (a \\ \\% \\ mod + b \\ \\% \\ mod) \\ \\% \\ mod\\). Practic, dac\u0103 adun\u0103m dou\u0103 numere \u0219i facem modulo, e acela\u0219i lucru cu a face modulo separat, iar mai apoi, s\u0103 facem modulo la final. </li> </ul> <p>De multe ori, c\u00e2nd adun\u0103m dou\u0103 numere care sunt deja mai mici dec\u00e2t \\(mod\\), este de preferat s\u0103 evit\u0103m opera\u021bia \\(\\%\\) de la final, pentru a optimiza calculul aritmetic, deoarece operatorul \\(\\%\\) este foarte \u00eencet. Mai jos pute\u021bi g\u0103si un exemplu. </p> <pre><code>int sum = a+b;\nif (sum &gt;= mod) { // mult mai rapid decat %\n    sum -= mod;\n}\n</code></pre>","tags":["algebra","optimizari","modulo"]},{"location":"mediu/pow-log/#scaderea-modulara","title":"Sc\u0103derea modular\u0103","text":"<p>Observa\u021bie</p> <ul> <li>\\((a - b)\\ \\% \\ mod = (a\\ \\% \\ mod - b \\ \\% \\ mod + mod) \\ \\% \\ mod\\). Practic, dac\u0103 sc\u0103dem dou\u0103 numere \u0219i facem modulo, e acela\u0219i lucru cu a face modulo separat, iar mai apoi, s\u0103 facem modulo la final. </li> </ul> <p>Spre deosebire de adunare, trebuie s\u0103 ad\u0103ug\u0103m un \\(mod\\) \u00een cazul \u00een care rezultatul devine negativ, deoarece spre deosebire de propriet\u0103\u021bile matematice, operatorul \\(\\%\\) poate returna valori negative \u00een limbajul C++. Ad\u0103ugarea acestui mod ne va ajuta s\u0103 avem rezultate non-negative. Implementarea va fi una asem\u0103n\u0103toare cu cea de la adunare.</p> <pre><code>int sum = a-b;\nif (sum &lt; 0) { // mult mai rapid decat %\n    sum += mod;\n}\n</code></pre>","tags":["algebra","optimizari","modulo"]},{"location":"mediu/pow-log/#inmultirea-modulara","title":"\u00cenmul\u021birea modular\u0103","text":"<p>Observa\u021bie</p> <ul> <li>\\((a \\cdot b)\\ \\% \\ mod = ((a \\ \\% \\ mod) \\cdot (b \\ \\% \\ mod)) \\ \\% \\ mod\\). Practic, dac\u0103 \u00eenmul\u021bim dou\u0103 numere \u0219i facem modulo, e acela\u0219i lucru cu a face modulo separat, iar mai apoi, s\u0103 facem modulo la final. </li> </ul> <p>De\u0219i nu putem optimiza calculul modulului, trebuie s\u0103 fim aten\u021bi la posibilitatea ca rezultatul s\u0103 nu devin\u0103 mai mare dec\u00e2t valoarea maxim\u0103 a tipurilor de date folosite \u00een probleme (de regul\u0103, tipul int). Folosirea valorii <code>1LL</code> (scrierea lui \\(1\\) folosind tipul de date <code>long long</code>) rezolv\u0103 aceast\u0103 problem\u0103.</p> <pre><code>long long sum = (1LL * a * b) % mod;\n</code></pre>","tags":["algebra","optimizari","modulo"]},{"location":"mediu/pow-log/#impartirea-inversul-modular","title":"\u00cemp\u0103r\u021birea (inversul) modular","text":"<p>\u00cemp\u0103r\u021birea este cea mai grea opera\u021bie de manevrat \u00een cazul opera\u021biilor modulare, recomand\u0103m citirea articolului despre invers modular pentru mai multe detalii.</p>","tags":["algebra","optimizari","modulo"]},{"location":"mediu/pow-log/#ridicarea-la-putere-in-timp-logaritmic","title":"Ridicarea la putere \u00een timp logaritmic","text":"<p>Pentru a calcula expresia \\(a^n\\), o prim\u0103 variant\u0103 este aceea de a lucra folosind brute-force, complexitatea fiind \\(O(n)\\).</p> <pre><code>long long prod = 1;\nfor (int i = 1; i &lt;= n; i++) {\n    prod = (prod * a);\n}\n</code></pre> <p>Totu\u0219i, nu am folosit \u00eenc\u0103 o proprietate esen\u021bial\u0103 pentru a optimiza calculul de mai sus.</p> <p>Observa\u021bie</p> <p>\\(a^b = \\left(a^{\\frac{n}{2}}\\right)^2\\) cu alte cuvinte, dac\u0103 \\(n\\) este par, putem s\u0103 afl\u0103m \\(a^\\frac{n}{2}\\) \u0219i apoi s\u0103-l ridic\u0103m la p\u0103trat. </p> <p>Aceast\u0103 proprietate ne va ajuta s\u0103 deducem urm\u0103torul mod de a calcula \\(a^n\\) recursiv. </p> <p>\\(a^b\\) este egal cu una din urm\u0103toarele dou\u0103 expresii:</p> <ul> <li>\\(a^{n-1} \\cdot a\\), dac\u0103 \\(n\\) este impar.</li> <li>\\(({a^\\frac{n}{2}}) \\cdot ({a^\\frac{n}{2}})\\), dac\u0103 \\(n\\) este par.</li> </ul> <p>Pentru \\(n = 0\\), r\u0103spunsul este evident \\(1\\). </p> <p>Astfel, prin \u00eemp\u0103r\u021birile treptate la \\(2\\) ale exponentului, reducem complexitatea la \\(O(\\log n)\\), unde \\(n\\) este exponentul.</p> <p>Acest algoritm se poate implementa at\u00e2t recursiv, c\u00e2t \u0219i iterativ, acestea fiind func\u021biile folosite pentru problema Exponentiation de pe CSES</p> RecursivIterativ <pre><code>long long pw(long long a, long long n) {\n    if (n == 0) {\n        return 1;\n    }\n    if (n % 2 == 1) {\n        return (a * pw(a, n-1)) % mod;\n    }\n    // n par\n    long long x = pw(a, n/2);\n    return (x*x) % mod;\n}\n</code></pre> <pre><code>long long pw(long long a, long long n) {\n    long long ans = 1;\n    while (n &gt; 0) {\n        if (n % 2 == 1) { // alternativ, n&amp;1\n            ans = (ans * a) % mod;\n        }\n        a = (a * a) % mod;\n        n = n / 2; // alternativ, n &gt;&gt;= 1\n    }\n    return ans;\n}\n</code></pre>","tags":["algebra","optimizari","modulo"]},{"location":"mediu/pow-log/#concluzii","title":"Concluzii","text":"<p>Aritmetica modular\u0103 este esen\u021bial\u0103 pentru \u00een\u021belegerea calculelor de acest fel, care apar la foarte multe tipuri de probleme, precum cele la programarea dinamic\u0103, combinatoric\u0103 sau matematic\u0103 mai avansat\u0103. Ridicarea la putere \u00een timp logaritmic este o rutin\u0103 folosit\u0103 \u0219i ulterior, \u00een ceea ce prive\u0219te algebra liniar\u0103 \u0219i opera\u021bii combinatoriale.</p>","tags":["algebra","optimizari","modulo"]},{"location":"mediu/pow-log/#probleme-suplimentare","title":"Probleme suplimentare","text":"<ul> <li>CSES Exponentiation II</li> <li>Tema infogym</li> <li>modulo infoarena</li> <li>puteri2 pbinfo</li> <li>Santa's bot Codeforces</li> </ul>","tags":["algebra","optimizari","modulo"]},{"location":"mediu/pow-log/#lectura-suplimentara","title":"Lectur\u0103 suplimentar\u0103","text":"<ul> <li>Modular Arithmetic for Beginners Codeforces</li> <li>Modular arithmetic USACO Guide</li> <li>Modular arithmetic Wikipedia</li> </ul>","tags":["algebra","optimizari","modulo"]},{"location":"mediu/queue/","title":"Coada","text":"<p>Autor: \u0218tefan-Cosmin D\u0103sc\u0103lescu, Teodor \u0218tefan Manolea</p>","tags":["structuri de date"]},{"location":"mediu/queue/#introducere-si-definitie","title":"Introducere \u0219i defini\u021bie","text":"<p>Cu to\u021bii suntem obi\u0219nui\u021bi cu no\u021biunea de coad\u0103. Aproape \u00een fiecare zi, suntem nevoi\u021bi s\u0103 st\u0103m la coad\u0103, fie c\u0103 e vorba de cozi la magazin, la o cas\u0103 de bilete sau la un ghi\u0219eu. \u00cen fiecare dintre aceste situa\u021bii, ne a\u0219ez\u0103m \u00een spatele cozii, a\u0219tept\u0103m ca r\u00e2nd pe r\u00e2nd, cei din fa\u021ba noastr\u0103 s\u0103 ias\u0103 din coad\u0103, iar atunci c\u00e2nd ajungem primii in coad\u0103, s\u0103 fim servi\u021bi.</p> <p>\u00cen schimb, atunci c\u00e2nd vine vorba de informatic\u0103 \u0219i mai ales algoritmic\u0103, principiile cozilor sunt foarte utile \u00een ceea ce prive\u0219te reprezentarea datelor, f\u0103c\u00e2ndu-ne via\u021ba mult mai u\u0219oar\u0103 \u0219i deschiz\u00e2nd poarta spre foarte multe tipuri de aplica\u021bii.</p> <p>Coada este structura de date care pune la dispozi\u021bie informa\u021biile primite \u00een ordinea \u00een care au fost introduse.</p> <p>Ea func\u021bioneaz\u0103 pe principiul \u201cprimul venit, primul servit\u201d (First In, First Out/FIFO).</p>","tags":["structuri de date"]},{"location":"mediu/queue/#operatii-cu-coada","title":"Opera\u021bii cu coada","text":"<p>Cu o coad\u0103 se pot face urm\u0103toarele opera\u021bii \u00een timp constant:</p> <ul> <li>ad\u0103ugarea unui nou element \u00een spatele cozii. Opera\u021bia se nume\u0219te push;</li> <li>eliminarea elementului din v\u00e2rful cozii. Opera\u021bia se nume\u0219te pop;</li> <li>accesarea valorii din v\u00e2rful cozii. Opera\u021bia se nume\u0219te front;</li> </ul> <p>Ca o consecin\u021b\u0103 a acestor opera\u021bii principale, putem face \u0219i urm\u0103toarele lucruri:</p> <ul> <li>ini\u021bializarea cozii \u2013 crearea unei cozi vide;</li> <li>verificarea faptului c\u0103 o coad\u0103 este sau nu vid\u0103;</li> </ul>","tags":["structuri de date"]},{"location":"mediu/queue/#modul-de-folosire-si-implementare-al-cozii","title":"Modul de folosire \u0219i implementare al cozii","text":"<p>Pentru a folosi o coad\u0103, avem nevoie de o metod\u0103 de a o implementa. Dou\u0103 dintre cele mai des \u00eent\u00e2lnite variante de a implementa o coad\u0103 sunt varianta static\u0103, folosind tablouri (eventual circulare) sau folosind containerul queue din STL.</p> <p>\u00cen cele ce urmeaz\u0103, vom prezenta aceste implement\u0103ri folosind problema coada de pe pbinfo, aceasta fiind o problem\u0103 de baz\u0103 care ne ajut\u0103 s\u0103 putem explica diferen\u021bele \u00eentre diverse metode de a implementa aceast\u0103 structur\u0103 de date. </p>","tags":["structuri de date"]},{"location":"mediu/queue/#coada-cu-tablouri","title":"Coada cu tablouri","text":"<p>O prim\u0103 metod\u0103 de a implementa o coad\u0103, f\u0103r\u0103 folosirea vreunei instruc\u021biuni avansate este cea care folose\u0219te tablouri, \u021bin\u00e2nd pozi\u021biile \u00een care se afl\u0103 primul \u0219i ultimul element din coad\u0103. </p> <p>Aici se poate observa faptul c\u0103 folosim un tablou de dimensiune fix\u0103, iar atunci c\u00e2nd ad\u0103ug\u0103m \u0219i scoatem valori din coad\u0103, ajust\u0103m valorile lui \\(L\\) \u0219i \\(R\\).</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int n, q[1000001], L = 0, R = 0;\n    cin &gt;&gt; n;\n\n    while (n--) {\n        char c[6];\n        cin &gt;&gt; c;\n\n        // afisam prima valoare a cozii\n        if (c[0] == 'f') {\n            cout &lt;&lt; q[L] &lt;&lt; '\\n';\n        }\n        else {\n            // adaugam o noua valoare si crestem R\n            if (c[1] == 'u') {\n                int val;\n                cin &gt;&gt; val;\n                q[R++] = val;\n            }\n            // scoatem o valoare si crestem L\n            else {\n                L++;\n            }\n        }\n    }\n    return 0;\n}\n</code></pre>","tags":["structuri de date"]},{"location":"mediu/queue/#coada-circulara","title":"Coada circular\u0103","text":"<p>O \u00eembun\u0103t\u0103\u021bire pe care o putem face la aceast\u0103 implementare const\u0103 \u00een a refolosi memoria dac\u0103 \u0219tim dimensiunea maxim\u0103 pe care o poate avea coada la un moment dat. Astfel, \u00een loc s\u0103 stoc\u0103m cantitatea maxim\u0103 de valori care intr\u0103 in coad\u0103, stoc\u0103m doar dimensiunea maxim\u0103 a datelor, iar pentru a ajusta valorile lui \\(L\\) \u0219i \\(R\\), le vom ajusta circular, astfel limit\u00e2nd memoria folosit\u0103. </p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int n, q[1001], L = 0, R = 0, maxi = 1001;\n    cin &gt;&gt; n;\n\n    while (n--) {\n        char c[6];\n        cin &gt;&gt; c;\n\n        // afisam prima valoare a cozii\n        if (c[0] == 'f') {\n            cout &lt;&lt; q[L] &lt;&lt; '\\n';\n        }\n        else {\n            // adaugam o noua valoare si crestem R\n            if (c[1] == 'u') {\n                int val;\n                cin &gt;&gt; val;\n                q[R] = val;\n                R++;\n                if (R &gt;= maxi) {\n                    R -= maxi;\n                }\n            }\n            // scoatem o valoare si crestem L\n            else {\n                L++;\n                if (L &gt;= maxi) {\n                    L -= maxi;\n                }\n            }\n        }\n    }\n    return 0;\n}\n</code></pre>","tags":["structuri de date"]},{"location":"mediu/queue/#coada-implementata-cu-stdqueue","title":"Coada implementat\u0103 cu std::queue","text":"<p>Primele dou\u0103 implement\u0103ri, de\u0219i utile \u0219i corecte, au un mare dezavantaj, practic la fel ca la orice structur\u0103 de date static\u0103, trebuie s\u0103 estim\u0103m c\u00e2te valori vom avea. Astfel, se impune introducerea unei implement\u0103ri dinamice, care s\u0103 elimine acest dezavantaj, iar o metod\u0103 de a implementa coada folosind STL const\u0103 \u00een folosirea containerului std::queue, acesta fiind specializat pentru opera\u021biile descrise mai sus, p\u0103str\u00e2nd toate avantajele cozii, ad\u0103ug\u00e2ndu-se faptul c\u0103 memoria de care avem nevoie este doar cea pe care o folosim la un moment dat, f\u0103r\u0103 spa\u021biu suplimentar folosit. </p> <p>Pentru implementarea std::queue, vom avea nevoie de biblioteca queue, precum \u0219i cunoa\u0219terea func\u021biilor specifice, push, pop \u0219i front. </p> <pre><code>#include &lt;iostream&gt;\n#include &lt;queue&gt;\n\nusing namespace std;\n\nint main() {\n    int n;\n    cin &gt;&gt; n;\n\n    queue&lt;int&gt; q;\n\n    while (n--) {\n        char c[6];\n        cin &gt;&gt; c;\n\n        // afisam prima valoare a cozii\n        if (c[0] == 'f') {\n            cout &lt;&lt; q.front() &lt;&lt; '\\n';\n        }\n        else {\n            // adaugam o noua valoare si crestem R\n            if (c[1] == 'u') {\n                int val;\n                cin &gt;&gt; val;\n                q.push(val);\n            }\n            // scoatem o valoare si crestem L\n            else {\n                q.pop();\n            }\n        }\n    }\n    return 0;\n}\n</code></pre>","tags":["structuri de date"]},{"location":"mediu/queue/#aplicatii-ale-cozii","title":"Aplica\u021bii ale cozii","text":"<p>Coada se reg\u0103se\u0219te ca o aplica\u021bie pentru tot ce \u00eenseamn\u0103 p\u0103strarea datelor \u00eentr-o ordine cronologic\u0103, fie c\u0103 e vorba de evenimente, st\u0103ri, pozi\u021bii sau alte informa\u021bii similare. Datorit\u0103 versatilit\u0103\u021bii sale, putem s\u0103 o folosim \u00een combina\u021bie cu stiva, problemele ce constau \u00een implementarea cozii cu stive \u0219i invers sunt foarte cunoscute \u0219i deschid u\u0219a c\u0103tre idei foarte importante, a\u0219a cum se poate observa \u0219i \u00een problemele de pe Leetcode men\u021bionate mai jos. </p> <p>Dintre cei mai importan\u021bi algoritmi ce au la baz\u0103 o coad\u0103, vom men\u021biona parcurgerea \u00een l\u0103\u021bime (BFS), \u00eempreun\u0103 cu varianta ei pe matrice, algoritmul lui Lee \u0219i in general, Flood Fill. Pentru mai multe detalii, pute\u021bi explora acest articol.</p> <p>Nu \u00een ultimul r\u00e2nd, coada este o structur\u0103 de date ce apare \u00een diverse probleme de simulare a unui proces sau \u00een anumite tipuri de probleme ce folosesc tehnici de tipul Sliding Window, deque-ul fiind o structur\u0103 de date specializat\u0103 pe asemenea algoritmi, a\u0219a cum este prezentat\u0103 \u0219i aici.</p>","tags":["structuri de date"]},{"location":"mediu/queue/#probleme-cu-coada","title":"Probleme cu coad\u0103","text":"<ul> <li>Coada1 pbinfo</li> <li>Implement Queue using Stacks - Leetcode</li> <li>Implement Stack using Queues - Leetcode</li> </ul>","tags":["structuri de date"]},{"location":"mediu/queue/#lectura-suplimentara","title":"Lectur\u0103 suplimentar\u0103","text":"<ul> <li>Tipul coada - algopedia</li> <li>Coada - pbinfo</li> <li>Queue - wikipedia</li> </ul>","tags":["structuri de date"]},{"location":"mediu/rerooting/","title":"Tehnica celor dou\u0103 DFS-uri (rerooting)","text":"<p>Autor: \u0218tefan-Cosmin D\u0103sc\u0103lescu</p> <p>\u00cen ceea ce prive\u0219te rezolvarea problemelor cu arbori, in anumite situatii se poate observa faptul c\u0103 avem nevoie de o calculare ini\u021bial\u0103 a r\u0103spunsului presupun\u00e2nd r\u0103d\u0103cina \u00eentr-un nod oarecare (de regul\u0103, nodul \\(1\\)), urmat\u0103 de folosirea acestor r\u0103spunsuri pentru generalizarea rezultatelor pentru toate r\u0103d\u0103cinile posibile. Vom numi tehnica pe care o folosim pentru aceste probleme rerooting, sau a\u0219a cum este cunoscut\u0103 \u00een jargonul rom\u00e2nesc, tehnica celor dou\u0103 DFS-uri.</p> <p>\u00cen cele ce urmeaz\u0103, vom prezenta c\u00e2teva exemple de probleme care se pot rezolva folosind aceast\u0103 tehnic\u0103, \u00eempreun\u0103 cu abord\u0103rile posibile. Se va putea observa faptul c\u0103 \u00een cele mai multe situa\u021bii, implementarea va fi una foarte similar\u0103, singurele modific\u0103ri fiind f\u0103cute la modul \u00een care vom defini dinamicile \u0219i alte date pe care le folosim.</p>","tags":["grafuri","arbori","programare dinamica"]},{"location":"mediu/rerooting/#problema-tree-distances-de-pe-cses","title":"Problema Tree Distances de pe CSES","text":"<p>Observa\u021bie</p> <p>Aceast\u0103 problem\u0103 are o solu\u021bie video explicat\u0103 chiar de autor, pe care o pute\u021bi accesa aici</p> <p>Pentru a rezolva problema, vom putea folosi o abordare de tip rerooting, dup\u0103 cum urmeaz\u0103:</p> <p>Mai \u00eent\u00e2i, vom precalcula folosind un DFS dintr-un nod oarecare distan\u021ba fa\u021b\u0103 de cea mai \u00eendep\u0103rtat\u0103 frunz\u0103 pentru fiecare nod, acest lucru se poate face foarte u\u0219or dac\u0103 \u021binem \u00eentr-un vector distan\u021bele maxime, \\(maxdist[i]\\) fiind distan\u021ba maxim\u0103 de la nodul \\(i\\) la o frunz\u0103 din subarborele nodului \\(i\\). </p> <p>Calculul acestei valori se poate face destul de simplu, deoarece pentru fiecare nod \\(i\\), vom \u0219ti deja valoarea lui \\(maxdist\\) pentru to\u021bi fiii acestuia, tot ce ne r\u0103m\u00e2ne de f\u0103cut este s\u0103 adun\u0103m \\(1\\) la aceste valori. Evident, pentru o frunz\u0103, \\(maxdist[i] = 0\\).</p> <p>Observa\u021bie</p> <p>Se poate observa faptul c\u0103 \u00een codul de mai jos am ales drept r\u0103d\u0103cin\u0103 nodul \\(1\\), aceasta fiind o conven\u021bie utilizat\u0103 \u00een cele mai multe probleme cu arbori, chiar \u0219i atunci c\u00e2nd nu ni se precizeaz\u0103 \u00een mod specific r\u0103d\u0103cina arborelui.</p> <p>Dup\u0103 ce am aflat valorile din vectorul \\(maxdist\\), acum va trebui s\u0103 folosim aceste r\u0103spunsuri pentru a afla pentru fiecare nod distan\u021ba fa\u021b\u0103 de cel mai \u00eendep\u0103rtat nod care nu se afl\u0103 \u00een subarborele nodului curent (la primul DFS am aflat aceast\u0103 distan\u021b\u0103 fa\u021b\u0103 de nodurile care se aflau \u00een subarborele nodului curent).</p> <p>Pentru a face asta, vom avea nevoie s\u0103 \u021binem ca un parametru suplimentar \u00een cea de-a doua parcurgere DFS distan\u021ba maxim\u0103 de la nodul curent la un nod care nu se afl\u0103 \u00een subarborele s\u0103u, ini\u021bial aceast\u0103 distan\u021b\u0103 fiind \\(0\\) pentru nodul \\(1\\). Vom nota aceast\u0103 distan\u021b\u0103 \\(distUp\\).</p> <p>Calcularea acestor distan\u021be pentru celelalte noduri se va face din aproape \u00een aproape, \u021bin\u00e2nd cont de urm\u0103toarele observa\u021bii:</p> <ul> <li>Pentru un nod, doar cele mai \u00eendep\u0103rta\u021bi doi subarbori sunt relevan\u021bi, deoarece \u00een cazul celorlal\u021bi subarbori, putem oric\u00e2nd s\u0103 folosim ca etalon unul din primii doi subarbori.</li> <li>Pe m\u0103sur\u0103 ce ne apropiem de frunze, distan\u021ba pe care o avem deja anterior calculat\u0103 va cre\u0219te, singurul mod \u00een care poate cre\u0219te mai mult este dac\u0103 pentru un fiu \\(x\\), avem un alt fiu \\(y\\) cu proprietatea c\u0103 \\(maxdist[y] + 1 &gt; distUp\\), motivul fiind acela c\u0103 atunci c\u00e2nd am cobor\u00ee spre frunze, frunza din subarborele lui \\(y\\) ar fi mai \u00eendep\u0103rtat\u0103. </li> <li>Dac\u0103 vrem s\u0103 ajungem la fiul care ne-a dat \\(maxdist[nod]\\), va trebui s\u0103 folosim a doua distan\u021b\u0103 pentru a calcula noua valoare a lui \\(distUp\\), pentru a evita situa\u021bia \u00een care num\u0103r\u0103m acelea\u0219i muchii de mai multe ori. </li> </ul> <p>Aceste observa\u021bii sunt puse laolalt\u0103 \u00een codul de mai jos, se poate observa faptul c\u0103 de\u0219i conceptul pare unul mai complicat, tot ce trebuie s\u0103 facem este s\u0103 observ\u0103m cu aten\u021bie ce se \u00eent\u00e2mpl\u0103 atunci c\u00e2nd ajungem de la un nod la altul. </p> <pre><code>#include &lt;iostream&gt;\n#include &lt;vector&gt;\n\nusing namespace std;\n\nint n;\nvector&lt;vector&lt;int&gt; &gt; tree;\nvector&lt;int&gt; maxdist, ans;\n\nvoid dfs (int parent, int node) {\n    for (int i = 0; i &lt; (int) tree[node].size(); i++) {\n        int nxt = tree[node][i];\n        if (nxt == parent) {\n            continue;\n        }\n        dfs(node, nxt);\n        maxdist[node] = max(maxdist[node], maxdist[nxt] + 1);\n    }\n}\n\nvoid dfs2 (int parent, int node, int distUp) {   \n    ans[node] = max(maxdist[node], distUp);\n    int max1 = 0, max2 = 0; \n    // cele mai mari doua distante fata de subarborii nodului curent\n    for (int i = 0; i &lt; (int) tree[node].size(); i++) {\n        int nxt = tree[node][i];\n        if (nxt == parent) {\n            continue;\n        }\n        // verificam daca distanta e mai mare decat a uneia din primele doua\n        if (maxdist[nxt] + 1 &gt; max1) {\n            max2 = max1;\n            max1 = maxdist[nxt] + 1;\n        }\n        else {\n            if (maxdist[nxt] + 1 &gt; max2) {\n                max2 = maxdist[nxt] + 1;\n            }\n        }\n    }\n\n    for (int i = 0; i &lt; (int) tree[node].size(); i++) {\n        int nxt = tree[node][i];\n        if (nxt == parent) {\n            continue;\n        } \n        // daca nodul curent este cel care ne-a dat distanta maxima\n        if(maxdist[nxt] + 1 == max1) {\n            dfs2(node, nxt, max(distUp, max2) + 1);\n        }\n        else {\n            dfs2(node, nxt, max(distUp, max1) + 1);\n        }\n    }\n}\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n\n    cin &gt;&gt; n;\n    tree.resize(n+1);\n    maxdist.resize(n+1);\n    ans.resize(n+1);\n\n    for (int i = 1; i &lt; n; i++) {\n        int a, b;\n        cin &gt;&gt; a &gt;&gt; b;\n        tree[a].push_back(b);\n        tree[b].push_back(a);\n    }\n\n    dfs(0, 1);\n    dfs2(0, 1, 0);\n\n    for (int i = 1; i &lt;= n; i++) {\n        cout &lt;&lt; ans[i] &lt;&lt; \" \";\n    }\n    return 0;\n}\n</code></pre>","tags":["grafuri","arbori","programare dinamica"]},{"location":"mediu/rerooting/#problema-subtree-de-pe-atcoder","title":"Problema Subtree de pe AtCoder","text":"<p>S\u0103 consider\u0103m o problem\u0103 mai simpl\u0103:</p> <p>Presupun\u00e2nd c\u0103 nodul \\(1\\) este colorat negru, \u00een c\u00e2te moduri putem colora arborele?</p> <p>Mai \u00eent\u00e2i, fix\u0103m r\u0103d\u0103cina arborelui \u00een nodul \\(1\\). Fie \\(dp[i]\\) num\u0103rul de moduri \u00een care putem colora subarborele nodului \\(i\\) astfel \u00eenc\u00e2t fie nodul \\(i\\) este colorat negru, fie niciun nod nu este colorat negru. Observa\u021bi c\u0103, dac\u0103 \\(i\\) este o frunz\u0103, atunci \\(dp[i]=2\\) (alegem s\u0103 color\u0103m nodul \\(i\\) negru sau nu).</p> <p>Pentru fiecare copil \\(c\\) al lui \\(i\\), exist\u0103 \\(dp[c]\\) moduri de a colora subarborele s\u0103u dac\u0103 \\(i\\) este colorat negru. Acest lucru \u00eenseamn\u0103 c\u0103 avem recuren\u021ba</p> \\[ dp[i]=1+\\prod_{c \\in \\text{Copiii lui } i} dp[c] \\] <p>unde produsul corespunde color\u0103rii nodului \\(i\\) \u00een negru, iar \\(1\\) corespunde color\u0103rii nodului \\(i\\) \u00een alb.</p> <p>R\u0103spunsul la problema mai simpl\u0103 este astfel \\(dp[1]-1\\). Calculul tuturor valorilor \\(dp[i]\\) se poate face \u00een \\(\\mathcal{O}(N)\\).</p>","tags":["grafuri","arbori","programare dinamica"]},{"location":"mediu/rerooting/#rezolvarea-pentru-toate-radacinile","title":"Rezolvarea pentru toate r\u0103d\u0103cinile","text":"<p>Mai \u00eent\u00e2i, fix\u0103m r\u0103d\u0103cina arborele arbitrar \u0219i facem un DFS pentru a calcula toate valorile \\(dp[i]\\).</p> <p>Fie \\(dp2[i]\\) num\u0103rul de moduri \u00een care putem colora arborele dac\u0103 elimin\u0103m subarborele nodului \\(i\\) astfel \u00eenc\u00e2t fie p\u0103rintele lui \\(i\\) este negru, fie niciun nod nu este colorat negru. Observa\u021bi c\u0103 \\(dp2[1]=1\\).</p> <p>Num\u0103rul de moduri \u00een care putem colora arborele dac\u0103 \u0219tim c\u0103 nodul \\(i\\) este negru este pur \u0219i simplu \\((dp[i]-1)\\cdot dp2[i]\\). Cum putem \u00eens\u0103 calcula eficient \\(dp2[i]\\)?</p> <p>Recuren\u021ba de baz\u0103 pentru a calcula \\(dp2[i]\\) este</p> \\[ dp2[i] = 1+dp2[\\text{P\u0103rintele lui } i] \\cdot \\prod_{s \\in \\text{Fra\u021bii lui } i} dp[s] \\] <p>unde produsul corespunde color\u0103rii p\u0103rintelui lui \\(i\\) \u00een negru, iar \\(1\\) corespunde color\u0103rii p\u0103rintelui lui \\(i\\) \u00een alb.</p> <p>Totu\u0219i, deoarece \\(M\\) nu este garantat a fi prim, nu putem pur \u0219i simplu s\u0103 g\u0103sim produsul copiilor unui nod \u0219i s\u0103 \u00eemp\u0103r\u021bim acel produs la \\(dp[i]\\) pentru fiecare copil (deoarece nu putem g\u0103si inversul modular u\u0219or).</p> <p>Cu toate acestea, observa\u021bi c\u0103 dac\u0103 nodul \\(i\\) este al \\(k\\)-lea copil al p\u0103rintelui s\u0103u, putem folosi produse prefix \u0219i sufix pentru a calcula</p> \\[ \\prod_{s \\in \\text{Fra\u021bii lui } i}dp[s] \\] <p>f\u0103r\u0103 a folosi \u00eemp\u0103r\u021birea. (Adic\u0103 g\u0103sim produsul lui \\(dp[s]\\) pentru fra\u021bii de la primul la al \\((k - 1)\\)-lea copil al p\u0103rintelui lui \\(i\\), produsul lui \\(dp[s]\\) pentru fra\u021bii de la al \\((k + 1)\\)-lea la ultimul copil al p\u0103rintelui lui \\(i\\), \u0219i apoi le \u00eenmul\u021bim \u00eentre ele.)</p> <p>Calculul tuturor valorilor \\(dp2[i]\\) necesit\u0103 \\(\\mathcal{O}(N)\\) folosind un DFS, astfel \u00eenc\u00e2t complexitatea total\u0103 a acestui algoritm este \\(\\mathcal{O}(N)\\).</p> <pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n\nint n, mod;\nstruct Node {\n    vector&lt;int&gt; adj;\n    vector&lt;int&gt; l, r;\n    int down, up;\n} nodes[100001];\n\nvoid dfs1(int nod, int tt) {\n    nodes[nod].down = 1;\n    for (auto &amp;c : nodes[nod].adj) {\n        if (c != tt) {\n            dfs1(c, nod);\n            nodes[nod].down = (1LL * nodes[nod].down * (nodes[c].down + 1)) % mod;\n        }\n    }\n\n    // scoatem parintele\n    vector&lt;int&gt;::iterator it = find(nodes[nod].adj.begin(), nodes[nod].adj.end(), tt);\n    if (it != nodes[nod].adj.end()) {\n        nodes[nod].adj.erase(it);\n    }\n}\n\nvoid dfs2(int nod, int tt) {\n    int sz = nodes[nod].adj.size();\n    if (sz == 0) {\n        return;\n    }\n    nodes[nod].l.assign(sz, 0);\n    nodes[nod].r.assign(sz, 0);\n\n    nodes[nod].l[0] = nodes[nod].up;\n    for (int i = 1; i &lt; sz; i++) {\n        nodes[nod].l[i] = (1LL * nodes[nod].l[i - 1] * (nodes[nodes[nod].adj[i - 1]].down + 1)) % mod;\n    }\n\n    nodes[nod].r[sz - 1] = 1;\n    for (int i = sz - 2; i &gt;= 0; i--) {\n        nodes[nod].r[i] = (1LL * nodes[nod].r[i + 1] * (nodes[nodes[nod].adj[i + 1]].down + 1)) % mod;\n    }\n\n    for (int i = 0; i &lt; sz; i++) {\n        int next = nodes[nod].adj[i];\n        nodes[next].up = ((1LL * nodes[nod].l[i] * nodes[nod].r[i]) + 1) % mod;\n        dfs2(next, nod);\n    }\n}\nint main() {\n\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n\n    cin &gt;&gt; n &gt;&gt; mod;\n    for (int i = 1; i &lt; n; i++) {\n        int x, y;\n        cin &gt;&gt; x &gt;&gt; y;\n        x--;\n        y--;\n        nodes[x].adj.push_back(y);\n        nodes[y].adj.push_back(x);\n    }\n    dfs1(0, 0);\n    nodes[0].up = 1;\n    dfs2(0, 0);\n    for (int i = 0; i &lt; n; i++) {\n        cout &lt;&lt; (1LL * nodes[i].down * nodes[i].up) % mod &lt;&lt; '\\n';\n    }\n    return 0;\n}\n</code></pre>","tags":["grafuri","arbori","programare dinamica"]},{"location":"mediu/rerooting/#concluzii","title":"Concluzii","text":"<p>Tehnica rerooting este o tehnic\u0103 folositoare \u00een anumite tipuri de probleme cu arbori, de multe ori o precalculare relativ simpl\u0103 poate reprezenta un pas important spre rezolvarea unor probleme foarte complicate de acest fel. De\u0219i nu este o tehnic\u0103 la fel de des \u00eent\u00e2lnit\u0103 precum alte varia\u021bii ale dinamicii pe arbore, apare suficient de des \u00eenc\u00e2t s\u0103 se justifice discu\u021bia ei separat\u0103. </p>","tags":["grafuri","arbori","programare dinamica"]},{"location":"mediu/rerooting/#probleme-suplimentare","title":"Probleme suplimentare","text":"<ul> <li>infoarena razboiul lumilor</li> <li>Codeforces Jovial Jaunt</li> <li>ONI 2003 asmin</li> <li>Codeforces Tree with Maximum Cost</li> <li>infoarena treesearch</li> <li>USACO Gold Directory Traversal</li> <li>Codeforces Two Paths</li> <li>ONI 2015 arbvalmax</li> <li>AtCoder Expensive Expense</li> <li>BOI 2017 City Attractions</li> <li>Codeforces Road Improvement</li> <li>APIO 2010 Patrol</li> </ul>","tags":["grafuri","arbori","programare dinamica"]},{"location":"mediu/rerooting/#lectura-suplimentara","title":"Lectur\u0103 suplimentar\u0103","text":"<ul> <li>Rerooting DP - USACO Guide</li> <li>The Ultimate Reroot Template - Codeforces</li> <li>Rerooting Technique - YouKn0wWho Academy</li> <li>Online Query Based Rerooting Technique</li> <li>Rerooting DP - Codeforces/Youtube</li> </ul>","tags":["grafuri","arbori","programare dinamica"]},{"location":"mediu/sequences/","title":"Abordarea problemelor cu secven\u021be","text":"<p>Autor: \u0218tefan-Cosmin D\u0103sc\u0103lescu</p> <p>\u00cen algoritmic\u0103, dar \u0219i \u00een alte domenii, suntem nevoi\u021bi de multe ori s\u0103 lucr\u0103m cu secven\u021be de valori \u0219i se impune folosirea unor abord\u0103ri specifice pentru a rezolva aceste probleme. Fie c\u0103 este vorba de probleme ce apar \u00een examenele na\u021bionale sau la concursurile de informatic\u0103, algoritmii ce prelucreaz\u0103 secven\u021be de valori se dovedesc a fi foarte importan\u021bi \u0219i cunoa\u0219terea lor, precum \u0219i a tehnicilor de rezolvare a acestor probleme devine esen\u021bial\u0103. </p>","tags":["secvente","sortare","ad-hoc"]},{"location":"mediu/sequences/#notiuni-introductive","title":"No\u021biuni introductive","text":"<p>Defini\u021bie</p> <p>O secven\u021b\u0103 reprezint\u0103 un \u0219ir de valori, de regul\u0103 dispuse consecutiv \u00eentr-un \u0219ir mai mare sau poate reprezenta chiar un \u0219ir de sine st\u0103t\u0103tor. </p> <p>Exemplu</p> <p>\u00cen vectorul \\(30\\), \\(32\\), \\(19\\), \\(8\\), \\(11\\), \\(6\\), putem spune urm\u0103toarele lucruri:</p> <ul> <li>\\(19, 8, 11\\) este o secven\u021b\u0103 care \u00eencepe de la pozi\u021bia \\(3\\) \u0219i se termin\u0103 la pozi\u021bia \\(5\\) a \u0219irului ini\u021bial</li> <li>\\(30, 19, 11\\) nu este o secven\u021b\u0103 a \u0219irului de mai sus (\u00een schimb, este un sub\u0219ir, no\u021biune pe care o vom discuta \u00een articolele ulterioare)</li> </ul> <p>Observa\u021bie</p> <p>\u00cen diverse contexte, secven\u021be precum \\(19, 8, 11\\) sunt numite \u0219i subsecven\u021be, deoarece sunt ob\u021binute prin eliminarea de valori de la \u00eenceputul \u0219i sf\u00e2r\u0219itul secven\u021bei de mai sus. </p> <p>Pentru a prelucra aceste secven\u021be \u0219i subsecven\u021be, o prim\u0103 solu\u021bie const\u0103 \u00een p\u0103strarea valorilor \u00een memorie folosind vectori, iar mai apoi, \u00een func\u021bie de ce cere problema, s\u0103 parcurgem toate variantele de a crea subsecven\u021be \u00een \u0219irul dat, sau eventual s\u0103 verific\u0103m diverse propriet\u0103\u021bi, parcurg\u00e2nd valorile una c\u00e2te una. </p> <p>Observa\u021bie</p> <p>Num\u0103rul de subsecven\u021be ale unui \u0219ir cu lungimea \\(n\\) este \\(\\frac{n \\cdot (n+1)}{2}\\). </p> <p>Pentru a demonstra acest fapt, putem fixa pozi\u021bia de \u00eenceput a unei subsecven\u021be (s\u0103 zicem, \\(i\\)), iar pentru aceast\u0103 pozi\u021bie ini\u021bial\u0103, avem \\((n - i + 1)\\) variante pentru pozi\u021bia final\u0103 - toate pozi\u021biile \\(j\\) astfel \u00eenc\u00e2t \\(i \\leq j \\leq n\\). Astfel, avem \\(n + (n-1) + \\dots + 1 = \\frac{n \\cdot (n+1)}{2}\\).</p> <p>\u00cen cele ce urmeaz\u0103, vom ar\u0103ta diverse tehnici de rezolvare a unor probleme introductive care cuprind secven\u021be, iar mai apoi, vom prezenta \u0219i unul din algoritmii pentru subsecven\u021ba de sum\u0103 maxim\u0103.</p>","tags":["secvente","sortare","ad-hoc"]},{"location":"mediu/sequences/#probleme-in-care-trebuie-sa-aflam-o-secventa-de-lungime-maxima","title":"Probleme \u00een care trebuie s\u0103 afl\u0103m o secven\u021b\u0103 de lungime maxim\u0103","text":"<p>O problem\u0103 care apare frecvent este urm\u0103toarea:</p> <p>Fie \\(X\\) un vector cu elemente de un anumit tip. S\u0103 se determine cea mai lung\u0103 secven\u021b\u0103 din vector \u00een care toate elementele au o anumit\u0103 proprietate (sunt pare, impare, prime, nule, ordonate cresc\u0103tor, egale etc.).</p> <p>Problema are mai multe solu\u021bii, cu complexit\u0103\u021bi diverse. \u00cen toate solu\u021biile vom determina \\(lenmax, stmax\\) \u0219i \\(drmax\\), \\(lenmax\\) fiind lungimea maxim\u0103 a secven\u021bei g\u0103site, \\(stmax\\) fiind cap\u0103tul din st\u00e2nga al \u0219irului g\u0103sit, \\(drmax\\) fiind cap\u0103tul din dreapta al \u0219irului g\u0103sit. Ini\u021bial, putem ini\u021bializa \\(lenmax\\) cu \\(0\\), \\(stmax\\) \u0219i \\(drmax\\) cu \\(-1\\) pentru a marca faptul c\u0103 nu am g\u0103sit \u00eenc\u0103 nicio secven\u021b\u0103 cu condi\u021biile cerute. </p> <p>Pentru exemplele de mai jos, vom afla lungimea celei mai lungi secven\u021be \u00een care toate valorile sunt pare. Dac\u0103 exist\u0103 mai multe asemenea secven\u021be, o vom afla pe cea mai din st\u00e2nga.</p>","tags":["secvente","sortare","ad-hoc"]},{"location":"mediu/sequences/#solutie-in-on3","title":"Solu\u021bie \u00een \\(O(n^3)\\)","text":"<p>Cea mai simpl\u0103 solu\u021bie la acest tip de probleme este aceea \u00een care fix\u0103m capetele secven\u021bei pe care o verific\u0103m, iar pentru fiecare secven\u021b\u0103, verific\u0103m fiecare valoare \u0219i asta ne va ajuta s\u0103 decidem dac\u0103 proprietatea este respectat\u0103. </p> <pre><code>int lenmax = 0, stmax = -1, drmax = -1;\nfor (int i = 1; i &lt;= n; i++) {\n    for (int j = i; j &lt;= n; j++) {\n        int ok = 1; // daca secventa este buna\n        for (int poz = i; poz &lt;= j; poz++) {\n            if (v[poz] % 2 != 0) {\n                ok = 0; // avem numar impar, deci secventa nu este buna\n            }\n        }\n        if (ok == 1 &amp;&amp; j - i + 1 &gt; lenmax) {\n            lenmax = j - i + 1;\n            stmax = i;\n            drmax = j;\n        }\n    }\n}\ncout &lt;&lt; lenmax &lt;&lt; \" \" &lt;&lt; stmax \" \" &lt;&lt; drmax &lt;&lt; '\\n'; \n</code></pre> <p>Chiar dac\u0103 aceast\u0103 solu\u021bie este tot \\(O(n^3)\\), \u00een multe cazuri se va dovedi mai rapid\u0103 \u00een practic\u0103, deoarece iter\u00e2nd \u00een ordine descresc\u0103toare dup\u0103 lungime, dac\u0103 g\u0103sim o secven\u021b\u0103 cu proprietatea dorit\u0103, atunci ne putem opri. </p> <pre><code>int lenmax = 0, stmax = -1, drmax = -1;\nfor (int len = n; len &gt;= 1; len--) {\n    for (int i = 1; i + len - 1 &lt;= n; i++) {\n        int j = i + len - 1;\n        int ok = 1; // daca secventa este buna\n        for (int poz = i; poz &lt;= j; poz++) {\n            if (v[poz] % 2 != 0) {\n                ok = 0; // avem numar impar, deci secventa nu este buna\n            }\n        }\n        if (ok == 1 &amp;&amp; j - i + 1 &gt; lenmax) {\n            lenmax = j - i + 1;\n            stmax = i;\n            drmax = j;\n            // aceste linii de mai jos opresc toate structurile repetitive, break oprind doar cea mai apropiata structura repetitiva\n            i = n;\n            len = 0;\n        }\n    }\n}\ncout &lt;&lt; lenmax &lt;&lt; \" \" &lt;&lt; stmax \" \" &lt;&lt; drmax &lt;&lt; '\\n'; \n</code></pre>","tags":["secvente","sortare","ad-hoc"]},{"location":"mediu/sequences/#solutie-in-on2","title":"Solu\u021bie \u00een \\(O(n^2)\\)","text":"<p>O \u00eembun\u0103t\u0103\u021bire pe care o putem face la algoritmul precedent este aceea c\u0103 dac\u0103 am verificat deja secven\u021ba \\([i, j]\\), pentru a trece la secven\u021ba \\([i, j+1]\\) trebuie doar s\u0103 verific\u0103m pozi\u021bia \\(j-1\\), f\u0103r\u0103 a mai fi necesar\u0103 verificarea din nou a tuturor pozi\u021biilor \u00een intervalul \\([i, j]\\). Deoarece acum va fi nevoie de doar dou\u0103 foruri pentru a verifica toate secven\u021bele, complexitatea va deveni \\(O(n^2)\\).</p> <pre><code>int lenmax = 0, stmax = -1, drmax = -1;\nfor (int i = 1; i &lt;= n; i++) {\n    int ok = 1; // daca secventa este buna\n    for (int j = i; j &lt;= n; j++) {\n        if (v[j] % 2 != 0) {\n            ok = 0; // avem numar impar, deci secventa nu este buna\n        }\n        if (ok == 1 &amp;&amp; j - i + 1 &gt; lenmax) {\n            lenmax = j - i + 1;\n            stmax = i;\n            drmax = j;\n        }\n    }\n}\ncout &lt;&lt; lenmax &lt;&lt; \" \" &lt;&lt; stmax \" \" &lt;&lt; drmax &lt;&lt; '\\n'; \n</code></pre>","tags":["secvente","sortare","ad-hoc"]},{"location":"mediu/sequences/#solutie-in-on","title":"Solu\u021bie \u00een \\(O(n)\\)","text":"<p>Totu\u0219i, putem rezolva aceast\u0103 problem\u0103 \u0219i mai eficient, deoarece dat fiind faptul c\u0103 valorile pe care le avem vor avea mereu acelea\u0219i propriet\u0103\u021bi, putem extinde secven\u021ba curent\u0103 at\u00e2ta timp c\u00e2t valorile respect\u0103 proprietatea cerut\u0103 (\u00een acest caz, paritatea), actualiz\u00e2nd r\u0103spunsul maxim la fiecare pas. </p> <pre><code>int lenmax = 0, stmax = -1, drmax = -1;\nint len = 0;\nfor (int i = 1; i &lt;= n; i++) {\n    if (v[i] % 2 == 0) {\n        len++;\n    }\n    else {\n        len = 0;\n    }\n    if (len &gt; lenmax) {\n        lenmax = len;\n        drmax = i;\n        stmax = i - len + 1;\n    }\n}\ncout &lt;&lt; lenmax &lt;&lt; \" \" &lt;&lt; stmax \" \" &lt;&lt; drmax &lt;&lt; '\\n'; \n</code></pre>","tags":["secvente","sortare","ad-hoc"]},{"location":"mediu/sequences/#solutie-in-on-fara-vectori","title":"Solu\u021bie \u00een \\(O(n)\\) f\u0103r\u0103 vectori","text":"<p>\u00cen cazul unor probleme, \u00een special cele care se dau la examenul de bacalaureat, se cere g\u0103sirea unor solu\u021bii eficiente at\u00e2t din punct de vedere al timpului de execu\u021bie, c\u00e2t \u0219i al memoriei folosite. Deoarece am redus solu\u021bia la una liniar\u0103, \u00een care verific\u0103m o singur\u0103 dat\u0103 fiecare valoare, nu mai are niciun sens s\u0103 \u021binem \u00een memorie un vector \u00een care s\u0103 stoc\u0103m valorile, acestea put\u00e2nd fi citite la fiecare pas.</p> <pre><code>int lenmax = 0, stmax = -1, drmax = -1;\nint len = 0;\nfor (int i = 1; i &lt;= n; i++) {\n    int x;\n    cin &gt;&gt; x;\n    if (x % 2 == 0) {\n        len++;\n    }\n    else {\n        len = 0;\n    }\n    if (len &gt; lenmax) {\n        lenmax = len;\n        drmax = i;\n        stmax = i - len + 1;\n    }\n}\ncout &lt;&lt; lenmax &lt;&lt; \" \" &lt;&lt; stmax \" \" &lt;&lt; drmax &lt;&lt; '\\n'; \n</code></pre>","tags":["secvente","sortare","ad-hoc"]},{"location":"mediu/sequences/#subsecventa-de-suma-maxima","title":"Subsecven\u021ba de sum\u0103 maxim\u0103","text":"<p>\u00cen unele probleme, trebuie s\u0103 afl\u0103m subsecven\u021ba de sum\u0103 maxim\u0103 a unui \u0219ir. Pentru a face acest lucru, vom putea modifica algoritmul prezentat mai sus, \u021bin\u00e2nd cont de o observa\u021bie foarte important\u0103, \u0219i anume faptul c\u0103 dac\u0103 avem de-a face cu o sum\u0103 negativ\u0103 la un moment dat, o putem ignora \u0219i reseta calculele, pentru a maximiza r\u0103spunsul. Acest algoritm este numit \u0219i algoritmul lui Kadane. </p> <pre><code>int summax = 0, stmax = -1, drmax = -1;\nint sum = 0, st = 0;\nfor (int i = 1; i &lt;= n; i++) {\n    int x;\n    cin &gt;&gt; x;\n    if (sum &lt; 0) {\n        sum = x;\n        st = i;\n    }\n    else {\n        sum += x;\n    }\n    if (sum &gt; summax) {\n        summax = sum;\n        drmax = i;\n        stmax = st;\n    }\n}\ncout &lt;&lt; summax &lt;&lt; \" \" &lt;&lt; stmax \" \" &lt;&lt; drmax &lt;&lt; '\\n'; \n</code></pre>","tags":["secvente","sortare","ad-hoc"]},{"location":"mediu/sequences/#concluzii","title":"Concluzii","text":"<p>Dup\u0103 cum se poate observa, secven\u021bele \u0219i prelucrarea lor sunt o parte fundamental\u0103 \u0219i necesar\u0103 pentru abordarea unei plaje foarte largi de probleme, a\u0219a cum ve\u021bi putea vedea \u00een capitolele urm\u0103toare, \u00een special c\u00e2nd vine vorba de diverse cazuri particulare, algoritmi \u0219i metode de programare, aici putem enumera metoda celor doi pointeri, sliding window sau chiar \u0219i problemele \u00een care folosim metodele specifice structurilor de date. Implement\u0103rile precise \u0219i clare vor fi esen\u021biale pentru rezolvarea acestor probleme \u00een timp rapid \u0219i simplu. </p>","tags":["secvente","sortare","ad-hoc"]},{"location":"mediu/sequences/#probleme-suplimentare","title":"Probleme suplimentare","text":"<ul> <li>Pbinfo - Verificarea unor propriet\u0103\u021bi</li> <li>Pbinfo - Probleme cu secven\u021be</li> <li>sss OJI 2022</li> <li>Microbist OJI 2024</li> <li>Subsecven\u021b\u0103 de sum\u0103 maxim\u0103 </li> <li>infoarena joctv</li> </ul>","tags":["secvente","sortare","ad-hoc"]},{"location":"mediu/sequences/#lectura-suplimentara","title":"Lectur\u0103 suplimentar\u0103","text":"<ul> <li>Secven\u021be \u00een vectori</li> <li>Verificarea unor propriet\u0103\u021bi</li> <li>Secven\u021be - CPPI Sync</li> <li>Secven\u021be - Algopedia</li> <li>Secven\u021be partea II- Algopedia</li> <li>Secven\u021ba de sum\u0103 maxim\u0103</li> </ul>","tags":["secvente","sortare","ad-hoc"]},{"location":"mediu/shortest-path/","title":"Algoritmi pentru drumuri minime","text":"<p>Autor: \u0218tefan-Cosmin D\u0103sc\u0103lescu</p> <p>Aflarea drumului minim \u00eentre dou\u0103 sau mai multe loca\u021bii este una dintre cele mai importante probleme pe care oamenii au fost nevoi\u021bi s\u0103 le rezolve de-a lungul istoriei, \u00eencep\u00e2nd din timpurile preistorice \u00een care comunicarea era limitat\u0103 \u0219i p\u00e2n\u0103 \u00een zilele noastre, c\u00e2nd avem foarte multe facilit\u0103\u021bi la dispozi\u021bie. \u00cen func\u021bie de criteriul ales, ne putem g\u00e2ndi la distan\u021ba minim\u0103, timpul minim de parcurgere al unui traseu sau alte criterii, precum dificultatea de parcurgere a drumului ales etc. </p> <p>Exemplu</p> <p>De exemplu, s\u0103 presupunem c\u0103 vrei s\u0103 parcurgi drumul Piatra Neam\u021b - Bra\u0219ov. Acest traseu poate fi parcurs \u00een dou\u0103 moduri principale, fiecare cu avantajele \u0219i dezavantajele lui. </p> <ul> <li>Piatra Neam\u021b - Miercurea Ciuc - Bra\u0219ov: 238km, timp de parcurgere: 4h, traseu dificil</li> <li>Piatra Neam\u021b - Bac\u0103u - Bra\u0219ov: 239km, timp de parcurgere: 4h20m, traseu ceva mai u\u0219or</li> </ul> <p>Chiar dac\u0103 cele dou\u0103 drumuri au o distan\u021b\u0103 identic\u0103, diferen\u021ba este dat\u0103 de timpul de parcurgere \u0219i de dificultatea traseului \u00een sine. De\u0219i primul traseu necesit\u0103 mai pu\u021bin timp pentru parcurgerea lui, cel de-al doilea traseu este semnificativ mai u\u0219or din punct de vedere al dificult\u0103\u021bii din punct de vedere rutier (dup\u0103 p\u0103rerea autorului), fapt ce \u00eei d\u0103 un cost mai mic, fiind preferat primului, \u00een ciuda timpului \u0219i distan\u021bei mai mari. </p> <p>\u00cen cele ce urmeaz\u0103, vom discuta despre algoritmii ce ne ajut\u0103 s\u0103 afl\u0103m drumuri minime, model\u00e2nd aceste probleme folosind grafurile orientate \u0219i neorientate, prezent\u00e2nd avantajele \u0219i dezavantajele fiec\u0103rui algoritm. </p>","tags":["grafuri","drumuri minime"]},{"location":"mediu/shortest-path/#introducere","title":"Introducere","text":"<p>De regul\u0103, atunci c\u00e2nd vorbim de drumuri minime, vorbim de muchii care au asociate costuri. Pentru a \u00een\u021belege mai u\u0219or no\u021biunea de cost pentru o muchie, ne vom raporta la exemplul folosit anterior.</p> <p>Defini\u021bie</p> <p>Un drum minim \u00eentre dou\u0103 noduri \\(a\\) \u0219i \\(b\\) este un lan\u021b simplu cu capetele \u00een \\(a\\) \u0219i \\(b\\) cu proprietatea c\u0103 costul total al muchiilor de pe lan\u021b este minim. </p> <p>Observa\u021bie</p> <p>Dac\u0103 nu se specific\u0103 un asemenea cost, presupunem c\u0103 costul fiec\u0103rei muchii este egal cu \\(1\\).</p> <p>Pentru a p\u0103stra \u00een memorie costul unei muchii, vom \u021bine o variabil\u0103 \u00een plus, astfel vom fi nevoi\u021bi s\u0103 lucr\u0103m cu structuri sau cu tipuri precum pair, dup\u0103 preferin\u021be. </p> <p>Fie c\u0103 e vorba de aflarea drumului minim \u00eentre dou\u0103 noduri, toate nodurile sau dac\u0103 vrem pur \u0219i simplu s\u0103 verific\u0103m anumite propriet\u0103\u021bi, algoritmii pe care \u00eei vom prezenta se vor dovedi a fi solu\u021bii utile, fiecare dintre ei av\u00e2nd avantajele \u0219i dezavantajele lor.  </p>","tags":["grafuri","drumuri minime"]},{"location":"mediu/shortest-path/#algoritmul-lui-dijkstra","title":"Algoritmul lui Dijkstra","text":"<p>De departe cel mai cunoscut algoritm pentru aflarea drumului minim \u00eentre dou\u0103 noduri, algoritmul lui Dijsktra este folosit atunci c\u00e2nd avem de-a face cu costuri pozitive, condi\u021bia minim\u0103 necesar\u0103 este aceea s\u0103 nu avem cicluri negative. </p> <p>Observa\u021bie</p> <p>Algoritmul este numit dup\u0103 un informatician olandez, iar o pronun\u021bie corect\u0103 a numelui lui este <code>daikstra</code> (pentru fanii fotbalului, g\u00e2ndi\u021bi-v\u0103 la Virgil Van Dijk), nu <code>di\u0219tra</code>, <code>jikstra</code> sau alte variante total gre\u0219ite, care sunt folosite foarte des.</p> <p>Defini\u021bie</p> <p>Un ciclu negativ este un ciclu cu proprietatea c\u0103 suma costurilor muchiilor de pe ciclu este negativ\u0103. </p> <p>Modul de func\u021bionare al algoritmului este unul foarte simplu: </p> <ul> <li>Pentru fiecare nod, vom \u021bine un cost total p\u00e2n\u0103 la el, la \u00eenceput acesta va fi ini\u021bializat pentru toate nodurile cu valori mari, cu excep\u021bia nodului (sau nodurilor) start, care vor avea costul ini\u021bial \\(0\\).</li> <li>C\u00e2t timp nu am vizitat toate nodurile, alegem nodul cu costul total dintre cele nealese. Dac\u0103 exist\u0103 mai multe asemenea noduri, oricare poate fi ales. </li> <li>Pentru nodul ales, vom vizita toate nodurile nevizitate, vecine cu el \u0219i verific\u0103m pentru fiecare dintre ele dac\u0103 costul total pentru acel nod devine mai mic.</li> </ul>","tags":["grafuri","drumuri minime"]},{"location":"mediu/shortest-path/#implementare-suboptima","title":"Implementare suboptim\u0103","text":"<p>Acest algoritm, \u00een forma sa neoptimizat\u0103 are complexitatea \\(O(n^2)\\) \u0219i are drept unic scop obi\u0219nuirea cu conceptul algoritmului, singura situa\u021bie \u00een care poate fi folosit drept o solu\u021bie real\u0103 este atunci c\u00e2nd avem un graf complet, \u00een care num\u0103rul de muchii se apropie de \\(n^2\\), mai jos put\u00e2nd fi citit\u0103 o implementare care aplic\u0103 pa\u0219ii de mai sus pe un graf neorientat.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\nint main () {\n    int n, m;\n    cin &gt;&gt; n &gt;&gt; m;\n\n    int adj[n+1][n+1]; // pentru acest exemplu, vom folosi matricea de adiacenta\n    int cost[n+1]; // costul minim de la nodul start la x;\n    int viz[n+1]; // daca nodul a fost procesat deja\n    for (int i = 1; i &lt;= n; i++) {\n        cost[i] = 1000000000;\n        viz[i] = 0;\n        for (int j = 1; j &lt;= n; j++) {\n            adj[i][j] = 1000000000;\n        }\n    }\n\n    for (int i = 1; i &lt;= m; i++) {\n        int a, b, c;\n        cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;\n        adj[a][b] = adj[b][a] = c;\n    }\n\n    int s;\n    cin &gt;&gt; s;\n    cost[s] = 0;\n    for (int i = 1; i &lt;= n; i++) {\n        int mini = 1000000000;\n        int nod = 0;\n        // aflam nodul cu cost minim dintre cele nevizitate\n        for (int j = 1; j &lt;= n; j++) { \n            if (viz[j] == 0 &amp;&amp; cost[j] &lt; mini) {\n                mini = cost[j];\n                nod = j;\n            }\n        }\n\n        // aflam noile distante\n        viz[nod] = 1;\n        for (int j = 1; j &lt;= n; j++) {\n            if (viz[j] == 0 &amp;&amp; cost[nod] + adj[nod][j] &lt; cost[j]) {\n                cost[j] = cost[nod] + adj[nod][j];\n            }\n        }\n    }\n\n    // afisam costurile finale\n    for (int i = 1; i &lt;= n; i++) {\n        cout &lt;&lt; cost[i] &lt;&lt; \" \";\n    }\n    return 0;\n</code></pre>","tags":["grafuri","drumuri minime"]},{"location":"mediu/shortest-path/#implementare-optima","title":"Implementare optim\u0103","text":"<p>Pentru a putea implementa algoritmul \u00een complexitatea sa optim\u0103, \\(O((n+m) \\log n)\\), va trebui s\u0103 facem c\u00e2teva observa\u021bii critice. </p> <p>\u00cen primul r\u00e2nd, nu are niciun sens s\u0103 tot verific\u0103m dac\u0103 nodurile deja vizitate sunt cele cu cost minim. </p> <p>\u00cen al doilea r\u00e2nd, fiind vorba de regul\u0103 de grafuri cu un num\u0103r de muchii apropiat de num\u0103rul de noduri, putem \u021bine vecinii folosind liste. </p> <p>Nu \u00een ultimul r\u00e2nd, cea mai important\u0103 optimizare const\u0103 \u00een g\u0103sirea nodului cu cost minim la fiecare pas, acest lucru se poate realiza folosind o structur\u0103 de date arborescent\u0103, de tip set sau heap (priority queue). Complexitatea acestui pas este redus la \\(O(\\log n)\\), ceea ce ne d\u0103 \u00eembun\u0103t\u0103\u021birea de care avem nevoie. </p> <p>Dup\u0103 aplicarea acestor optimivdeile fiind acelea\u0219i, cu excep\u021bia folosirii unei cozi de priorit\u0103\u021bi sau a unui set, mai jos fiind prezente ambele variante. </p> <pre><code>#include &lt;iostream&gt;\n#include &lt;vector&gt;\n#include &lt;queue&gt;\n\nusing namespace std;\n\nint main() {\n    int n, m;\n    cin &gt;&gt; n &gt;&gt; m;\n\n    vector&lt;vector&lt;pair&lt;int, int&gt; &gt; &gt; graph(n+1); \n    for (int i = 1; i &lt;= m; i++) {\n        int a, b, c;\n        cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;\n        graph[a].push_back({b, c});\n        graph[b].push_back({a, c});\n    }\n\n    vector&lt;long long&gt; cost(n+1, (1LL&lt;&lt;60));\n    vector&lt;int&gt; vis(n+1);\n    cost[1] = 0;\n    // priority queue tine perechile in ordine descrescatoare, de aceea se impune folosirea semnului - pentru a ne folosi de aceasta proprietate fara a folosi alti comparatori\n    priority_queue&lt;pair&lt;long long, int&gt; &gt; s;\n    s.push({0, 1});\n\n    while(!s.empty()) {\n        pair&lt;long long, int&gt; smallest = s.top();\n        s.pop();\n\n        // daca am trecut deja prin acel nod, nu mai are sens sa parcurgem iar vecinii lui\n        if (vis[smallest.second] == 1) {\n            continue;\n        }\n        vis[smallest.second] = 1;\n\n        for (int i = 0; i &lt; (int) graph[smallest.second].size(); i++) {\n            int nxt = graph[smallest.second][i].first;\n            int val = graph[smallest.second][i].second;\n\n            if (-smallest.first + val &lt; cost[nxt]) {\n                cost[nxt] = -smallest.first + val;\n                s.push({-cost[nxt], nxt});\n            }\n        }\n    }\n\n    for (int i = 1; i &lt;= n; i++) {\n        cout &lt;&lt; cost[i] &lt;&lt; \" \";\n    }  \n    return 0;\n}   \n</code></pre> <pre><code>#include &lt;iostream&gt;\n#include &lt;vector&gt;\n#include &lt;set&gt;\nusing namespace std;\n\nint main() {\n    int n, m;\n    cin &gt;&gt; n &gt;&gt; m;\n\n    vector&lt;vector&lt;pair&lt;int, int&gt; &gt; &gt; graph(n+1); \n    for (int i = 1; i &lt;= m; i++) {\n        int a, b, c;\n        cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;\n        graph[a].push_back({b, c});\n        graph[b].push_back({a, c});\n    }\n\n    vector&lt;long long&gt; cost(n+1, (1LL&lt;&lt;60));\n    cost[1] = 0;\n    set&lt;pair&lt;long long, int&gt; &gt; s;\n    s.insert({0, 1});\n\n    while(!s.empty()) {\n        pair&lt;long long, int&gt; smallest = *s.begin();\n        s.erase(smallest);\n\n        for (int i = 0; i &lt; (int) graph[smallest.second].size(); i++) {\n            int nxt = graph[smallest.second][i].first;\n            int val = graph[smallest.second][i].second;\n\n            if (smallest.first + val &lt; cost[nxt]) {\n                if (s.find({cost[nxt], nxt}) != s.end()) {\n                    s.erase({cost[nxt], nxt});\n                }\n                cost[nxt] = smallest.first + val;\n                s.insert({cost[nxt], nxt});\n            }\n        }\n    }\n\n    for (int i = 1; i &lt;= n; i++) {\n        cout &lt;&lt; cost[i] &lt;&lt; \" \";\n    }  \n    return 0;\n</code></pre> <p>Folosind aceste implement\u0103ri, putem afla drumurile minime \u00eentre dou\u0103 noduri foarte rapid, \u00een cazul majorit\u0103\u021bii problemelor de acest fel. Totu\u0219i, a\u0219a cum ve\u021bi vedea \u00een cazul celorlal\u021bi doi algoritmi, Dijkstra nu acoper\u0103 toate variantele de grafuri cu costuri.</p>","tags":["grafuri","drumuri minime"]},{"location":"mediu/shortest-path/#algoritmul-bellman-ford","title":"Algoritmul Bellman-Ford","text":"<p>Algoritmul Bellman-Ford este un algoritm de aflare a drumului minim \u00eentre dou\u0103 noduri folosit mai ales pentru detectarea ciclurilor negative. </p> <p>\u00cen mod similar cu algoritmul lui Dijkstra, vom \u021bine pentru fiecare nod costul total p\u00e2n\u0103 la el, dar ca o noutate, vom \u021bine \u0219i num\u0103rul de modific\u0103ri ale costului minim. Dac\u0103 num\u0103rul de modific\u0103ri ale costului minim este cel pu\u021bin \\(n\\), atunci putem spune c\u0103 avem un ciclu de cost negativ, deoarece asta \u00eenseamn\u0103 c\u0103 sigur am modificat costul minim de dou\u0103 ori din acela\u0219i vecin. </p> <p>De\u0219i \u00een practic\u0103 algoritmul se comport\u0103 rezonabil, complexitatea pe cazul cel mai prost este \\(O(n \\cdot m)\\). Implementarea, una foarte similar\u0103 cu cea a parcurgerii BFS, se poate g\u0103si mai jos. </p> <pre><code>#include &lt;iostream&gt;\n#include &lt;vector&gt;\n#include &lt;queue&gt;\nusing namespace std;\n\nint main() {\n\n    ifstream cin(\"bellmanford.in\");\n    ofstream cout(\"bellmanford.out\");\n\n\n    int n, m;\n    cin &gt;&gt; n &gt;&gt; m;\n\n    vector&lt;vector&lt;pair&lt;int, int&gt; &gt; &gt; graph(n+1);\n    for (int i = 1; i &lt;= m; i++) {\n        int a, b, c;\n        cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;\n\n        graph[a].push_back({b, c});\n    }\n\n    vector&lt;long long&gt; costs(n+1, (1LL&lt;&lt;60));\n    vector&lt;int&gt; cnt(n+1);\n\n    costs[1] = 0;\n    queue&lt;int&gt; q; \n    q.push(1);\n    while(!q.empty()) {\n        int node = q.front();\n        q.pop();\n\n        for (int i = 0; i &lt; (int) graph[node].size(); i++) {\n            int nxt = graph[node][i].first;\n            int c = graph[node][i].second;\n            if (costs[node] + c &lt; costs[nxt]) {\n                costs[nxt] = costs[node] + c;\n                q.push(nxt);\n\n                cnt[nxt]++;\n                if (cnt[nxt] &gt; n) {\n                    cout &lt;&lt; \"Ciclu negativ!\" &lt;&lt; '\\n';\n                    return 0;\n                }\n            }\n        }\n    }\n\n    for (int i = 2; i &lt;= n; i++) {\n        cout &lt;&lt; costs[i] &lt;&lt; \" \";\n    }\n    return 0;\n}\n</code></pre> <p>Observa\u021bie</p> <p>Exist\u0103 o varia\u021bie a acestui algoritm, foarte des folosit\u0103 \u00een cazul unor probleme de drum minim, numit\u0103 SPFA (Shortest Path Faster Algorithm). Acest algoritm este folosit cu succes \u00een multe probleme de informatic\u0103, ca o alternativ\u0103 la algoritmul lui Dijkstra. Totu\u0219i, \u00een cazul cel mai prost complexitatea este similar\u0103 cu cea de la Bellman-Ford, \\(O(n \\cdot m)\\).</p>","tags":["grafuri","drumuri minime"]},{"location":"mediu/shortest-path/#algoritmul-floyd-warshall-roy-floyd","title":"Algoritmul Floyd-Warshall (Roy-Floyd)","text":"<p>Algoritmul Floyd-Warshall (Roy-Floyd) este un algoritm de aflare a drumului minim \u00eentre toate perechile de noduri, f\u0103r\u0103 a fi nevoie de a calcula individual distan\u021bele dintre oricare dou\u0103 noduri. </p> <p>Modul \u00een care func\u021bioneaz\u0103 acest algoritm este acela c\u0103 pentru fiecare pereche de noduri, vom \u021bine \u00een memorie distan\u021ba dintre acea pereche de noduri, iar la fiecare pas, vom fixa un nod pe care \u00eel vom folosi drept un nod intermediar, cu scopul de a mic\u0219ora distan\u021bele dintre noduri \u00een acest fel. </p> <p>Cu alte cuvinte, vom fixa o valoare \\(k\\) corespunz\u0103toare nodului din mijloc, iar pentru fiecare pereche \\((i, j)\\), vom verifica dac\u0103 \\(dist(i, k) + dist(k, j) &lt; dist(i, j)\\), astfel relax\u00e2nd drumul dintre cele dou\u0103 noduri. </p> <p>Complexitatea total\u0103 a algoritmului va fi \\(O(n^3)\\), fiind unul dintre algoritmii folosi\u021bi pentru a evalua performan\u021ba calculatoarelor, datorit\u0103 simplit\u0103\u021bii sale. Mai jos g\u0103si\u021bi implementarea \u00een limbajul C++.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\nint n, a[102][102]; // costul minim de la i la j\nint main() {\n    cin &gt;&gt; n;\n    for (int i = 1; i &lt;= n; ++i) {\n        for (int j = 1; j &lt;= n; ++j) {\n            cin &gt;&gt; a[i][j];\n        }\n    }\n    for (int k = 1; k &lt;= n; k++) {\n        for (int i = 1; i &lt;= n; i++) {\n            for (int j = 1; j &lt;= n; j++) {\n                if (a[i][k] &amp;&amp; a[k][j] &amp;&amp; (a[i][j] &gt; a[i][k] + a[k][j] || !a[i][j]) &amp;&amp; i != j) {\n                    a[i][j] = a[i][k] + a[k][j];\n                }\n            }\n        }\n    }\n    for (int i = 1; i &lt;= n; ++i) {\n        for (int j = 1; j &lt;= n; ++j) {\n            cout &lt;&lt; a[i][j] &lt;&lt; \" \";\n        }\n        cout &lt;&lt; '\\n';\n    }\n    return 0;\n}\n</code></pre> <p>Observa\u021bie</p> <p>Ordinea \u00een care avem cele trei for-uri este esen\u021bial\u0103, fiind obligatoriu s\u0103 \u00eencepem cu nodul pe care \u00eel vom folosi drept cel intermediar \\((k, i, j)\\), celelalte variante fiind gre\u0219ite deoarece rat\u0103m diverse drumuri \u00een acest mod. </p>","tags":["grafuri","drumuri minime"]},{"location":"mediu/shortest-path/#algoritmul-0-1-bfs-si-variatiile-sale","title":"Algoritmul 0-1 BFS \u0219i varia\u021biile sale","text":"<p>\u00cen unele probleme de drum minim, costurile muchiilor sunt valori mici, dar nu doar egale cu \\(1\\). Deoarece avem pu\u021bine costuri, ne putem g\u00e2ndi la optimiz\u0103ri care s\u0103 se foloseasc\u0103 de acest lucru pentru a ajunge s\u0103 avem algoritmi mai rapizi, f\u0103r\u0103 a fi nevoie de Dijkstra sau vreun alt algoritm mai general. </p>","tags":["grafuri","drumuri minime"]},{"location":"mediu/shortest-path/#0-1-bfs","title":"0-1 BFS","text":"<p>Un prim exemplu const\u0103 \u00een grafurile (sau construc\u021biile care pot fi reprezentate ca \u0219i grafuri) \u00een care costurile muchiilor sunt doar \\(0\\) sau \\(1\\). Deoarece avem costuri care nu sunt uniforme, nu vom putea folosi BFS la fel cum am proceda \u00eentr-o problem\u0103 obi\u0219nuit\u0103, dar putem \u00een schimb s\u0103 profit\u0103m de faptul c\u0103 sunt doar dou\u0103 costuri distincte. </p> <p>\u00cen loc s\u0103 avem o singur\u0103 coad\u0103 \u00een care ad\u0103ug\u0103m valori de fiecare dat\u0103 c\u00e2nd drumul devine unul mai optim dec\u00e2t drumul minim, vom avea dou\u0103 cozi (sau un deque) \u00een care vom alterna cozile \u00een care ad\u0103ug\u0103m nodurile, dup\u0103 cum urmeaz\u0103:</p> <ul> <li>Dac\u0103 costul muchiei este \\(0\\), vom ad\u0103uga \u00een coada curent\u0103 (sau \u00een v\u00e2rful deque-ului, dac\u0103 folosim un deque)</li> <li>Dac\u0103 costul muchiei este \\(1\\), vom ad\u0103uga \u00een coada urm\u0103toare (sau la coada deque-ului, dac\u0103 folosim aceast\u0103 structur\u0103 de date)</li> </ul> <p>Observa\u021bie</p> <p>Folosind aceast\u0103 metod\u0103, vom ajunge s\u0103 ad\u0103ug\u0103m fiecare nod \u00een structura noastr\u0103 de date de cel mult \\(2\\) ori, complexitatea devenind liniar\u0103, spre deosebire de o abordare standard folosind BFS, \u00een care complexitatea pe cel mai r\u0103u caz poate fi polinomial\u0103 (de cele mai multe ori, p\u0103tratic\u0103 raportat la num\u0103rul de noduri)</p> <p>De asemenea, prin aceast\u0103 strategie vom p\u0103stra o proprietate fundamental\u0103 a parcurgerii BFS c\u00e2nd vine vorba de drumuri minime, \u0219i anume faptul c\u0103 nodurile vor fi procesate \u00een ordine cresc\u0103toare a costurilor fa\u021b\u0103 de origine. Aceast\u0103 proprietate este una esen\u021bial\u0103 \u0219i va fi p\u0103strat\u0103 indiferent de num\u0103rul de cozi pe care \u00eel vom folosi, prin alternarea cozilor pe care le parcurgem la un moment dat, acestea fiind traversate secven\u021bial. </p> <p>Un exemplu de problem\u0103 \u00een care avem aceast\u0103 abordare este problema padure, \u00een care vom implementa acest algoritm pe o matrice. Mai jos pute\u021bi g\u0103si o implementare ce ia \\(100\\) pe problema dat\u0103. </p> <pre><code>#include &lt;fstream&gt;\n#include &lt;deque&gt;\n#include &lt;vector&gt;\n\nusing namespace std;\n\nint main() {\n\n    vector&lt;pair&lt;int, int&gt; &gt; dir = {{-1, 0}, {0, 1}, {1, 0}, {0, -1}};\n\n    ifstream cin(\"padure.in\");\n    ofstream cout(\"padure.out\");\n\n    int n, m, xa, ya, xb, yb;\n    cin &gt;&gt; n &gt;&gt; m &gt;&gt; xa &gt;&gt; ya &gt;&gt; xb &gt;&gt; yb;\n    --xa, --ya, --xb, --yb;\n\n    vector&lt;vector&lt;int&gt;&gt; mat(n, vector&lt;int&gt;(m)), dist(n, vector&lt;int&gt;(m));\n\n    for (int i = 0; i &lt; n; i++) {\n        for (int j = 0; j &lt; m; j++) {\n            cin &gt;&gt; mat[i][j];\n        }\n    }\n\n    deque&lt;pair&lt;int, int&gt;&gt; Q;\n    dist[xa][ya] = 1;\n    Q.push_front({xa, ya});\n\n    while (!Q.empty()) {\n        pair&lt;int, int&gt; nd = Q.front();\n        Q.pop_front();\n\n        int x = nd.first;\n        int y = nd.second;\n\n        for (int i = 0; i &lt; 4; i++) {\n            auto nx = x + dir[0].first, ny = y + dir[0].second;\n\n            if (nx &gt;= 0 &amp;&amp; ny &gt;= 0 &amp;&amp; nx &lt; n &amp;&amp; ny &lt; m) {\n                if (mat[nx][ny] != mat[x][y] &amp;&amp; (dist[x][y] + 1 &lt; dist[nx][ny] || !dist[nx][ny])) {\n                    dist[nx][ny] = dist[x][y] + 1;\n                    Q.push_back({nx, ny});\n                } else if (mat[nx][ny] == mat[x][y] &amp;&amp; (dist[x][y] &lt; dist[nx][ny] || !dist[nx][ny])) {\n                    dist[nx][ny] = dist[x][y];\n                    Q.push_front({nx, ny});\n                }\n            }\n        }\n    }\n\n\n    cout &lt;&lt; dist[xb][yb] - 1 &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["grafuri","drumuri minime"]},{"location":"mediu/shortest-path/#1-k-bfs-algoritmul-lui-dial","title":"1-K BFS (Algoritmul lui Dial)","text":"<p>Aceast\u0103 abordare poate fi extins\u0103 \u0219i dac\u0103 avem \\(k\\) costuri distincte, folosind o strategie similar\u0103. Deoarece nu vom mai putea folosi un deque, vom recurge la a folosi \\(k\\) cozi, urm\u00e2nd ca mai apoi s\u0103 simul\u0103m algoritmul nostru de drum minim exact ca la 0-1 BFS. </p> <p>Vom \u00eencepe prin a ad\u0103uga punctul ini\u021bial \u00een coada \\(0\\), iar pe parcurs, dac\u0103 lu\u0103m punctul din coada \\(x\\) \u0219i costul muchiei este \\(y\\), atunci noul nod va fi ad\u0103ugat \u00een coada \\((x+y) \\ \\% \\ k\\), urm\u00e2nd a fi procesat \u00eempreun\u0103 cu celelalte puncte. Acest lucru se poate generaliza \u0219i dac\u0103 avem \\(k\\) costuri oarecare, put\u00e2nd astfel ad\u0103uga costurile \u00een cozi \u00een func\u021bie de ultimul cost ad\u0103ugat, exact cum proced\u0103m la problema Biom de la ONI 2023.</p> <p>La fel ca \u0219i la algoritmul precedent, vom parcurge cozile alternativ, p\u0103str\u00e2nd ordinea costurilor intact\u0103, pentru a permite algoritmului nostru s\u0103 r\u0103m\u00e2n\u0103 liniar raportat la num\u0103rul de noduri. </p> <p>Pentru a \u00een\u021belege mai bine modul de folosire a acestei variante generalizate, voi explica solu\u021bia problemei John and Tractor, dat\u0103 la finala FIICode 2023. </p> <p>Aici vom avea trei costuri distincte, unul dintre ele put\u00e2nd fi ajustat de opera\u021bia descris\u0103 \u00een enun\u021b. Ne vom concentra pe partea \u00een care vom rula algoritmul lui Dial, folosind \\(4\\) cozi (costurile sunt \\(1, 2, 3\\)).</p> <pre><code>#include &lt;iostream&gt;\n#include &lt;vector&gt;\n#include &lt;queue&gt;\n\nusing namespace std;\n\nstruct info {\n    int L, C, x;\n};\n\nvector&lt;int&gt; ox = {0, 1, 0, -1};\nvector&lt;int&gt; oy = {1, 0, -1, 0};\n\nint main() {\n\n    // limita de timp stransa, fast io e necesar\n\n    ios_base::sync_with_stdio(false); \n    cin.tie(NULL);\n\n    int n, m, k;\n    cin &gt;&gt; n &gt;&gt; m &gt;&gt; k;\n\n    int xa, ya, xb, yb;\n    cin &gt;&gt; xa &gt;&gt; ya &gt;&gt; xb &gt;&gt; yb;\n\n    vector&lt;vector&lt;int&gt;&gt; grid(n+1);\n\n    for (int i = 1; i &lt;= n; i++) {\n        grid[i].resize(m+1);\n        string s;\n        cin &gt;&gt; s;\n\n        for (int j = 0; j &lt; m; j++) {\n            if (s[j] == 's') {\n                grid[i][j+1] = 1;\n            }\n            if (s[j] == 'p') {\n                grid[i][j+1] = 2;\n            }\n            if (s[j] == 'a') {\n                grid[i][j+1] = 3;\n            }\n        }\n    }\n\n    vector&lt;vector&lt;vector&lt;int&gt;&gt;&gt; dp(n+1, vector&lt;vector&lt;int&gt;&gt; (m+1, vector&lt;int&gt; (k+1, (1&lt;&lt;25)))); \n\n    queue&lt;info&gt; q[4];\n\n    q[grid[xa][ya]].push({xa, ya, 0});\n    dp[xa][ya][0] = grid[xa][ya];\n\n    if (grid[xa][ya] == 2) {\n        q[grid[xa][ya] - 1].push({xa, ya, 1});\n        dp[xa][ya][1] = grid[xa][ya] - 1;\n    }\n\n    int timp = 0;\n    int lastempty = 0;\n\n    while (lastempty &lt;= 10) {\n        lastempty++;\n        // timp%4 = timp&amp;3, pentru puteri ale lui 2\n        while (!q[(timp&amp;3)].empty()) {\n            lastempty = 0;\n            info nod = q[(timp&amp;3)].front();\n            q[(timp&amp;3)].pop();\n\n            for (int dir = 0; dir &lt;= 3; dir++) {\n                int nxtL = nod.L + ox[dir];\n                int nxtC = nod.C + oy[dir];\n                if (nxtL &gt;= 1 &amp;&amp; nxtL &lt;= n &amp;&amp; nxtC &gt;= 1 &amp;&amp; nxtC &lt;= m) {\n                    int nwt = grid[nxtL][nxtC] + dp[nod.L][nod.C][nod.x];\n                    if (nwt &lt; dp[nxtL][nxtC][nod.x]) {\n                        dp[nxtL][nxtC][nod.x] = nwt;\n                        q[(nwt&amp;3)].push({nxtL, nxtC, nod.x});\n                    }\n\n                    if (grid[nxtL][nxtC] == 2 &amp;&amp; nod.x &lt; k) {\n                        nwt--;\n                        if (nwt &lt; dp[nxtL][nxtC][nod.x+1]) {\n                            dp[nxtL][nxtC][nod.x+1] = nwt;\n                            q[(nwt&amp;3)].push({nxtL, nxtC, nod.x+1});\n                        }\n                    }\n                }\n            }\n        }\n        timp++;\n    }\n\n    int ans = 1e9;\n    for (int j = 0; j &lt;= k; j++) {\n        ans = min(ans, dp[xb][yb][j]);\n    }\n    cout &lt;&lt; ans &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["grafuri","drumuri minime"]},{"location":"mediu/shortest-path/#care-este-algoritmul-mai-bun","title":"Care este algoritmul mai bun?","text":"<p>Fiecare algoritm are avantajele \u0219i dezavantajele lui, cunoa\u0219terea tuturor fiind necesar\u0103. Dijkstra este op\u021biunea optim\u0103 \u00een cele mai multe cazuri, dar Floyd-Warshall \u0219i Bellman-Ford au ambele beneficiile lui. 0-1 BFS / 1-K BFS au \u0219i ele avantajele lor, \u00een special c\u00e2nd vine vorba de grafuri cu costuri mici, nefiind nici acest algoritm unul de neglijat. </p>","tags":["grafuri","drumuri minime"]},{"location":"mediu/shortest-path/#probleme-suplimentare","title":"Probleme suplimentare","text":"<ul> <li>Simple Shortest Path</li> <li>Shortest Routes I</li> <li>Shortest Routes II</li> <li>catun infoarena</li> <li>High Score</li> <li>Flight Discount</li> <li>OJI 2004 Lanterna</li> <li>FIICode John and Tractor</li> <li>OJI 2017 Rover</li> <li>Baltic Olympiad 2011 Switch</li> <li>Lot 2018 Juniori Road</li> <li>USACO Gold Fine Dining</li> <li>ONI 2023 Biom</li> <li>Cycle Finding</li> <li>Investigation</li> <li>Probleme cu drumul minim de pe Kilonova</li> <li>Probleme cu Dijkstra de pe Infoarena</li> <li>Probleme cu Bellman-Ford de pe Infoarena</li> <li>rfinv infoarena</li> <li>Probleme cu Floyd-Warshall de pe Infoarena</li> </ul>","tags":["grafuri","drumuri minime"]},{"location":"mediu/shortest-path/#lectura-suplimentara","title":"Lectur\u0103 suplimentar\u0103","text":"<ul> <li>Shortest Paths with Non-Negative Edge Weights - USACO Guide</li> <li>Shortest Paths with Negative Edge Weights - USACO Guide</li> <li>Dijkstra - CP-algorithms</li> <li>Aflarea drumului minim - CPPI</li> <li>1-K BFS - Codeforces</li> <li>0-1 BFS - CP-algorithms</li> <li>Roy Floyd - CPPI</li> <li>Dijkstra - CPPI</li> <li>Rethink the Dijkstra algorithm -- Let's go deeper</li> <li>Bellman-Ford - CPPI</li> </ul>","tags":["grafuri","drumuri minime"]},{"location":"mediu/sliding-window/","title":"Sliding window","text":"<p>Autor: \u0218tefan-Cosmin D\u0103sc\u0103lescu</p> <p>A\u0219a cum am men\u021bionat \u00een articolul despre lucrul cu secven\u021be, acestea se reg\u0103sesc \u00een foarte multe tipuri de probleme, iar de\u0219i acolo am discutat \u00een special despre problemele de baz\u0103, aici vom prezenta o tehnic\u0103 care va fi util\u0103 pentru problemele \u00een care trebuie s\u0103 iter\u0103m prin ferestre de lungime fix\u0103. </p> <p>Defini\u021bie</p> <p>Fereastra glisant\u0103 (\u00een englez\u0103 sliding window) reprezint\u0103 o metod\u0103 de rezolvare a problemelor care implic\u0103 folosirea informa\u021biei acumulate pentru a face tranzi\u021biile \u00eentre subsecven\u021be de lungime \\(k\\) cu u\u0219urin\u021b\u0103, f\u0103r\u0103 a fi nevoie de recalcularea r\u0103spunsului pentru toate secven\u021bele de lungime \\(k\\). </p> <p>Observa\u021bie</p> <p>Pe parcursul acestui articol, ve\u021bi observa diferite structuri de date folosite pentru aplicarea conceptelor de aici. Toate acestea vor avea un element comun, folosirea unor precalcul\u0103ri pentru a facilita ob\u021binerea r\u0103spunsurilor.</p> <p>Vom continua prin a prezenta c\u00e2teva probleme de acest fel, precum \u0219i prin a face leg\u0103tura cu tehnici mai generale care folosesc principiile de aici, care se vor aplica \u0219i \u00een cazul unor secven\u021be de lungime variabil\u0103. </p>","tags":["secvente","precalculare"]},{"location":"mediu/sliding-window/#teava-roalgo-summer-flasg","title":"\u021aeava - RoAlgo Summer FLASG","text":"<p>O solu\u021bie brut\u0103 a acestei probleme const\u0103 \u00een a calcula pe r\u00e2nd toate sumele corespunz\u0103toare intervalelor de lungime egal\u0103 cu lungimea intervalului dat, dar aceast\u0103 solu\u021bie va rula \u00een \\(O(n^2)\\). </p> <p>Pentru a optimiza solu\u021bia brut\u0103, vom \u00eencepe prin a calcula \u00een mod brut suma pentru intervalul \\([st, dr]\\), iar mai apoi ne vom folosi de faptul c\u0103 num\u0103rul de valori diferite dintre intervalele \\([st, dr]\\) \u0219i \\([st+1, dr+1]\\) este exact \\(2\\) (cu alte cuvinte, valoarea de pe pozi\u021bia \\(st\\) nu va mai fi considerat\u0103, dar valoarea de pe pozi\u021bia \\(dr+1\\) va fi considerat\u0103).</p> <p>\u00cen acest mod, solu\u021bia va fi optimizat\u0103, ating\u00e2ndu-se complexitatea dorit\u0103, \u0219i anume \\(O(n)\\). Mai jos pute\u021bi g\u0103si implementarea folosind aceast\u0103 metod\u0103. </p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int n;\n    cin &gt;&gt; n;\n\n    vector&lt;int&gt; v(n+1);\n    for (int i = 1; i &lt;= n; i++) {\n        cin &gt;&gt; v[i];\n    }\n\n    int st, dr;\n    cin &gt;&gt; st &gt;&gt; dr;\n\n    // aflam suma initiala\n    long long sm = 0;\n    for (int i = st; i &lt;= dr; i++) {\n        sm += v[i];\n    }\n\n    // ajustam suma initiala folosind cele doua valori care ies/intra\n    long long ans = 0;\n    while (dr &lt;= n) {\n        ans += sm;\n        sm -= v[st];\n        sm += v[dr+1];\n        st++, dr++;\n    }\n\n    cout &lt;&lt; ans &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["secvente","precalculare"]},{"location":"mediu/sliding-window/#inaccurate-subsequence-search-codeforces","title":"Inaccurate Subsequence Search - Codeforces","text":"<p>Pentru a rezolva aceast\u0103 problem\u0103, ne vom folosi de faptul c\u0103 trebuie s\u0103 calcul\u0103m num\u0103rul maxim de elemente care se potrivesc pentru toate subsecven\u021bele de lungime \\(m\\). </p> <p>\u00cen cazul acestei probleme, vom putea folosi o structur\u0103 de date de tip map pentru a stoca frecven\u021bele numerelor din cele dou\u0103 \u0219iruri, implementarea folosind acest principiu pentru a \u021bine cu u\u0219urin\u021b\u0103 r\u0103spunsul c\u0103utat, complexitatea devenind \\(O(n \\log n)\\).</p> <pre><code>#include &lt;iostream&gt;\n#include &lt;map&gt;\n#include &lt;vector&gt;\n\nusing namespace std;\n\nint main() {\n\n    // linii pentru citirea rapida, necesare pentru codeforces\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n\n    int t;\n    cin &gt;&gt; t;\n\n    while (t--) {\n        int n, m, k;\n        cin &gt;&gt; n &gt;&gt; m &gt;&gt; k;\n        map&lt;int, int&gt; mpa, mpb;\n\n        vector&lt;long long&gt; v(n+1), v2(m+1);\n        for (int i = 1; i &lt;= n; i++) {\n            cin &gt;&gt; v[i];\n        }\n        for (int i = 1; i &lt;= m; i++) {\n            cin &gt;&gt; v2[i];\n            mpa[v2[i]]++;\n        }\n        int cnt = 0, total = 0;\n        for (int i = 1; i &lt;= n; i++) {\n            cnt -= min(mpa[v[i]], mpb[v[i]]);\n            mpb[v[i]]++;\n            cnt += min(mpa[v[i]], mpb[v[i]]);\n            if (i &gt; m) {\n                cnt -= min(mpa[v[i-m]], mpb[v[i-m]]);\n                mpb[v[i-m]]--;\n                cnt += min(mpa[v[i-m]], mpb[v[i-m]]);\n            }\n            if (i &gt;= m &amp;&amp; cnt &gt;= k) {\n                total++;\n            }\n        }\n        cout &lt;&lt; total &lt;&lt; '\\n';\n    }\n    return 0;\n}\n</code></pre>","tags":["secvente","precalculare"]},{"location":"mediu/sliding-window/#sliding-window-median","title":"Sliding Window Median","text":"<p>La fel ca la celelalte dou\u0103 probleme, vom vrea s\u0103 proces\u0103m fiecare element care intr\u0103, \u00eempreun\u0103 cu fiecare element care iese f\u0103r\u0103 a schimba prea mult datele problemei. </p> <p>Solu\u021bia descris\u0103 mai jos se bazeaz\u0103 pe faptul c\u0103 \u021binem \u00een dou\u0103 seturi valorile mai mici dec\u00e2t mediana \u0219i cele mai mari dec\u00e2t mediana, iar atunci c\u00e2nd ajust\u0103m fereastra noastr\u0103, vom echilibra dimensiunile seturilor \u00een mod convenabil pentru a putea accesa \u00een continuare mediana cu u\u0219urin\u021b\u0103, folosind func\u021biile specifice std::set.</p> <pre><code>#include &lt;iostream&gt;\n#include &lt;vector&gt;\n#include &lt;set&gt;\n\nusing namespace std;\n\nint main() {\n\n    int n, k;\n    cin &gt;&gt; n &gt;&gt; k;\n\n    vector&lt;int&gt; v(n+1);\n    multiset&lt;int&gt; smaller, larger;\n    for (int i = 1; i &lt;= n; i++) {\n        cin &gt;&gt; v[i];\n    }\n\n    for (int i = 1; i &lt;= n; i++) {\n        smaller.insert(v[i]);\n        if (i &gt; k) {\n            if (smaller.find(v[i-k]) != smaller.end()) {\n                smaller.erase(smaller.lower_bound(v[i-k]));\n            }\n            else {\n                larger.erase(larger.lower_bound(v[i-k]));\n            }\n        }\n        if (i &gt;= k) {\n            for (int i = 1; i &lt;= 2; i++) {\n                if (!larger.empty()) {\n                    int x = *larger.begin();\n                    larger.erase(larger.lower_bound(x));\n                    smaller.insert(x);\n                }\n            }\n            while (smaller.size() - 1 &gt;= larger.size() + 1) {\n                int x = *smaller.rbegin();\n                smaller.erase(smaller.lower_bound(x));\n                larger.insert(x);\n            }\n            cout &lt;&lt; *smaller.rbegin() &lt;&lt; \" \";\n        }\n    }\n    return 0;\n}\n</code></pre>","tags":["secvente","precalculare"]},{"location":"mediu/sliding-window/#alte-aplicatii-si-concluzii","title":"Alte aplica\u021bii \u0219i concluzii","text":"<p>Metode de tipul sliding window se pot folosi \u0219i \u00een cazul altor tehnici, precum tehnica celor doi pointeri, multe dintre aplica\u021biile \u00eent\u00e2lnite la deque \u0219i alte structuri de date mai complicate dec\u00e2t scopul acestui articol, care este unul de leg\u0103tur\u0103 dintre aplica\u021biile \u00eent\u00e2lnite la problemele cu secven\u021be \u0219i cele mai avansate, din capitolele urm\u0103toare. </p>","tags":["secvente","precalculare"]},{"location":"mediu/sliding-window/#probleme-suplimentare","title":"Probleme suplimentare","text":"<ul> <li>OJI 2024 Santinele</li> <li>Strip Codeforces</li> <li>Sliding Window Cost</li> <li>Max Subarray Sum II</li> <li>slidingwindow infoarena</li> <li>Fence Codeforces</li> </ul>","tags":["secvente","precalculare"]},{"location":"mediu/sliding-window/#lectura-suplimentara","title":"Lectur\u0103 suplimentar\u0103","text":"<ul> <li>Sliding Window - USACO Guide</li> </ul>","tags":["secvente","precalculare"]},{"location":"mediu/stack/","title":"Stiva","text":"<p>Autor: Traian Mihai Danciu</p>"},{"location":"mediu/stack/#notiuni-introductive","title":"No\u021biuni introductive","text":"<p>Stiva este ca un teanc de obiecte. Ea are \\(4\\) opera\u021bii principale:</p> <ol> <li>push(value): Adaug\u0103 value pe v\u00e2rful stivei.</li> <li>top(): Spune care este valoarea de pe v\u00e2rful stivei.</li> <li>pop(): Scoate elementul de pe v\u00e2rful stivei.</li> <li>empty(): Spune dac\u0103 stiva este goal\u0103.</li> </ol> <p>Observa\u021bie</p> <p>Valorile vor fi returnate dup\u0103 regula LIFO, adic\u0103 last in, first out.</p>"},{"location":"mediu/stack/#problema-stack","title":"Problema stack","text":"<p>Aceast\u0103 problem\u0103 ne cere s\u0103 implement\u0103m exact opera\u021biile descrise mai sus. Acesta este link-ul la implementare.</p>"},{"location":"mediu/stack/#stiva-din-stl","title":"Stiva din STL","text":"<p>Stiva poate fi implementat\u0103 \u0219i cu func\u021biile din STL. Pentru mai multe detalii, vede\u021bi implementarea \u0219i cppreference.</p>"},{"location":"mediu/stack/#problema-stack_max_min","title":"Problema stack_max_min","text":"<p>Problema ne d\u0103 un \u0219ir de numere \u0219i 4 \u00eentreb\u0103ri pentru c\u00e2te o pozi\u021bie: 1. Cel mai apropiat indice la st\u00e2nga, unde elementul este mai mare dec\u00e2t pozi\u021bia din \u00eentrebare. 2. Cel mai apropiat indice la st\u00e2nga, unde elementul este mai mic dec\u00e2t pozi\u021bia din \u00eentrebare. 3. Cel mai apropiat indice la dreapta, unde elementul este mai mare dec\u00e2t pozi\u021bia din \u00eentrebare. 4. Cel mai apropiat indice la dreapta, unde elementul este mai mic dec\u00e2t pozi\u021bia din \u00eentrebare.</p> <p>Vom precalcula, pentru fiecare element, r\u0103spunsul la fiecare tip de \u00eentrebare. Aici vom descrie algoritmul doar pentru primul tip, deoarece celelalte se rezolv\u0103 analog.</p> <p>Vom parcurge vectorul de la st\u00e2nga la dreapta, iar pe o stiv\u0103 vom re\u021bine indicii cu elemente mai mici sau egale cu elementul curent. Cu alte cuvinte, pentru fiecare element, scoatem de pe stiv\u0103 toate elementele mai mici sau egale cu el. Dac\u0103 stiva este goal\u0103, atunci r\u0103spunsul este \\(-1\\), altfel este indicele elementului de pe v\u00e2rful stivei. Apoi, \u00eel ad\u0103ug\u0103m pe el \u00eensu\u0219i \u00een stiv\u0103.</p> <p>Observa\u021bie: Pe stiv\u0103 vom re\u021bine indici, nu valori.</p> <p>Vom face o simulare a acestui algoritm, folosindu-ne de exemplul din problem\u0103, \\(v = [1 \\ 2 \\ 3 \\ 6 \\ 4 \\ 5 \\ 3 \\ 2 \\ 1 \\ 10]\\). Ca \u00een problem\u0103, vectorul va fi indexat de la \\(0\\). 1. Suntem la indicele 0, \\(stiva = []\\). R\u0103spunsul va fi -1. 2. Suntem la indicele 1, \\(stiva = [0]\\), dar \u00eel scoatem, iar apoi \\(stiva = []\\). R\u0103spunsul va fi -1. 3. Suntem la indicele 2, \\(stiva = [1]\\), dar \u00eel scoatem, iar apoi \\(stiva = []\\). R\u0103spunsul va fi -1. 4. Suntem la indicele 3, \\(stiva = [2]\\), dar \u00eel scoatem, iar apoi \\(stiva = []\\). R\u0103spunsul va fi -1. 5. Suntem la indicele 4, \\(stiva = [3]\\). R\u0103spunsul va fi 3. 6. Suntem la indicele 5, \\(stiva = [3 \\ 4]\\), dar \u00eel scoatem pe 4. R\u0103spunsul va fi 3. 7. Suntem la indicele 6, \\(stiva = [3 \\ 5]\\). R\u0103spunsul va fi 5. 8. Suntem la indicele 7, \\(stiva = [3 \\ 5 \\ 6]\\). R\u0103spunsul va fi 6. 9. Suntem la indicele 8, \\(stiva = [3 \\ 5 \\ 6 \\ 7]\\). R\u0103spunsul va fi 7. 10. Suntem la indicele 9, \\(stiva = [3 \\ 5 \\ 6 \\ 7 \\ 8]\\), dar le scoatem pe toate, iar apoi \\(stiva = []\\). R\u0103spunsul va fi -1.</p> <p>Aceast\u0103 rezolvare are complexitatea \\(\\mathcal{O}(N)\\), pentru c\u0103 fiecare element va fi pus pe stiv\u0103 \u0219i scos, deci se vor face maxim 2 opera\u021bii pentru fiecare.</p> <p>Detaliii de implementare: vom re\u021bine o matrice \\(raspuns[tip - 1][i]\\) care va reprezenta r\u0103spunsul la o \u00eentrebare de tipul \\(tip \\ i\\). De asemenea, vom folosi o santinel\u0103, care va fi o valoare care va fi mereu mai mic\u0103 (sau mai mare, \u00een func\u021bie de caz) dec\u00e2t orice valoare din vector. Pentru mai multe detalii, vezi implementarea.</p> <p>Link implementare</p>"},{"location":"mediu/stack/#probleme-rezolvate","title":"Probleme rezolvate","text":""},{"location":"mediu/stack/#problema-skyline","title":"Problema skyline","text":"<p>Implementarea se afl\u0103 aici.</p>"},{"location":"mediu/stack/#problema-maximum-rectangle","title":"Problema Maximum Rectangle","text":"<p>Implementarea se afl\u0103 aici.</p>"},{"location":"mediu/stack/#problema-unific-oji-2013-vii","title":"Problema unific - OJI 2013 VII","text":"<p>Implementarea se afl\u0103 aici.</p>"},{"location":"mediu/stack/#problema-swap-oni-2013-baraj-juniori","title":"Problema swap - ONI 2013 Baraj Juniori","text":"<p>Implementarea se afl\u0103 aici.</p>"},{"location":"mediu/stack/#problema-ehab-and-prefix-mexs-codeforces-round-649","title":"Problema Ehab and Prefix MEXs - Codeforces Round 649","text":"<p>Implementarea se afl\u0103 aici.</p>"},{"location":"mediu/stack/#probleme-suplimentare","title":"Probleme suplimentare","text":"<ul> <li>Maximum Building I - CSES (Este aceea\u0219i problem\u0103 ca Maximum Rectangle)</li> <li>inunda\u021bie - ONI 2022 VI (Cerin\u021bele 2 \u0219i 3 pot fi rezolvate folosind o stiv\u0103, necesit\u0103 \u0219i c\u0103utare binar\u0103).</li> <li>fuziune - ONI 2023 Baraj Juniori (Problem\u0103 asem\u0103n\u0103toare cu unific, dar necesit\u0103 lucru cu numere mari \u0219i numere prime)</li> <li>\u0219iruri - ONI 2022 VI (Alt\u0103 problem\u0103 asem\u0103n\u0103toare cu unific)</li> <li>tower - Shumen 2016 Juniori (Nu v\u0103 speria\u021bi c\u0103 este de la Shumen, problema este doar o aplica\u021bie la stack_max_min)</li> <li>maxp - ONI 2013 VIII (O alt\u0103 aplica\u021bie la problema stack_max_min)</li> <li>CF 1905C (Problem\u0103 a c\u0103rei rezolvare se folose\u0219te de tehnica de la stack_max_min)</li> <li>CF 1905D (Problem\u0103 a c\u0103rei rezolvare se folose\u0219te de tehnica de la stack_max_min)</li> <li>CF 1909C (Problem\u0103 care are o rezolvare cu tehnica de la stack_max_min)</li> <li>reactii - ONI 2009 X (Problem\u0103 asem\u0103n\u0103toare cu unific)</li> <li>dag - ONI 2019 Baraj Seniori (Problem\u0103 care se folose\u0219te de tehnica de la stack_max_min)</li> <li>leftmax - OJI 2020 X (Problem\u0103 care se folose\u0219te de tehinca de la stack_max_min)</li> </ul>"},{"location":"mediu/stack/#bibliografie-si-lectura-suplimentara","title":"Bibliografie \u0219i lectur\u0103 suplimentar\u0103","text":"<ul> <li>Un video despre stiv\u0103, pentru a v\u0103 ajuta s\u0103 \u00een\u021belege\u021bi mai bine acest concept.</li> <li>Un video despre analiza amortizat\u0103, v\u0103 va ajuta s\u0103 \u00een\u021belege\u021bi mai bine rezolvarea problemei stack_max_min \u0219i de ce are complexitatea \\(\\mathcal{O}(N)\\)</li> <li>Algopedia - Stive</li> <li>Algopedia - Analiza amortizat\u0103, mai multe detalii despre problema stack_max_min</li> <li>Articolul de pe USACO despre stiv\u0103</li> </ul>"},{"location":"mediu/toposort/","title":"Sortare Topologic\u0103","text":"<p>Autor : Radu Moc\u0103na\u0219u</p>"},{"location":"mediu/toposort/#cunostinte-necesare","title":"Cuno\u0219tin\u021be necesare:","text":"<ul> <li>Grafuri.</li> <li>Recursivitate.</li> <li>Liste de Adiacen\u021b\u0103.</li> <li>C\u00e2teva no\u021biuni legate de vectorii STL.</li> </ul>"},{"location":"mediu/toposort/#teorie","title":"Teorie","text":"<p>\u00centr-un graf orientat \u0219i aciclic, definim sortarea topologic\u0103 ca fiind o ordine a nodurilor (nu neap\u0103rat unic\u0103), astfel \u00eenc\u00e2t, dac\u0103 not\u0103m cu \\(P\\) lista pozi\u021biilor nodurilor, iar \\(A\\) \u0219i \\(B\\) sunt dou\u0103 noduri, cu muchie de la \\(A\\) la \\(B\\),  $$P_A &lt; P_B $$</p>"},{"location":"mediu/toposort/#spre-exemplu","title":"Spre exemplu:","text":"<p><pre><code>graph LR\nA((1)) --&gt; B((2))\nB --&gt; C((3))\nA --&gt; D((4))\nA --&gt; E((5))\nE --&gt; C</code></pre> \u00cen acest graf, o sortare topologic\u0103 valid\u0103 ar fi: <code>1, 2, 5, 3, 4</code> , deoarece \\(1\\) se afl\u0103 \u00eenaintea lui \\(2\\), \\(5\\) \u00eenaintea lui \\(3\\), etc. Un alt exemplu ar fi <code>1, 4, 5, 2, 3</code> . O ordine incorect\u0103 ar fi \u00eens\u0103 <code>1, 4, 2, 3, 5</code> , deoarece \\(5\\) se afl\u0103 dup\u0103 \\(3\\), de\u0219i exist\u0103 muchie de la \\(5\\) la \\(3\\).</p>"},{"location":"mediu/toposort/#un-alt-exemplu","title":"Un alt exemplu:","text":"<pre><code>graph LR\nA((1)) --&gt; B((2))\nB --&gt; D((3))\nC((4)) --&gt; A\nD --&gt; C</code></pre> <p>Acest graf con\u021bine un ciclu (de fapt chiar este unul), mai exact \\(1, 2, 3, 4\\) . Astfel, putem alege 2 noduri, \\(A\\) \u0219i \\(B\\), astfel \u00eenc\u00e2t ele apar\u021bin aceluia\u0219i ciclu (se poate ajunge de la \\(A\\) la \\(B\\) \u0219i viceversa). Dar asta implic\u0103 faptul c\u0103 \u00een sortarea topologic\u0103, \\(A\\) se afl\u0103 \u00een fa\u021ba lui \\(B\\), dar \u0219i c\u0103 \\(B\\) se afl\u0103 \u00eenaintea lui \\(A\\), ceea ce duce la o contradic\u021bie. A\u0219adar, \u00eentr-un graf ce con\u021bine un ciclu, nu exist\u0103 nicio sortare topologic\u0103.</p>"},{"location":"mediu/toposort/#algoritmul","title":"Algoritmul","text":"<p>\u00cent\u00e2i, vom presupune c\u0103 graful este aciclic.</p> <p>Numim vecin al unui nod \\(U\\), un nod \\(V\\), astfel \u00eenc\u00e2t exist\u0103 muchie de la \\(U\\) la \\(V\\). \u00cens\u0103, \u0219tim c\u0103 pentru orice dou\u0103 noduri \\(U\\) \u0219i \\(V\\), pentru care exist\u0103 muchie de la \\(U\\) la \\(V\\), \\(U\\) se afl\u0103 \u00eenaintea lui \\(V\\) \u00een ordinea topologic\u0103.</p> <p>A\u0219adar, \u00een sortarea topologic\u0103, orice nod se afl\u0103 \u00eenaintea vecinilor s\u0103i.</p> <p>\u00cen acela\u0219i timp, \u00eentr-o parcurgere <code>DFS</code>, vom intra \u00een vecinii unui nod dup\u0103 ce intr\u0103m \u00een acesta. Putem defini timpul de ie\u0219ire al unui nod ca fiind momentul la care ne \u00eentoarcem din recursivitate \u00eenapoi la el (pentru simplitate, timpii pot fi numerota\u021bi de la \\(1\\) la \\(n\\), unde \\(n\\) este num\u0103rul de noduri). Astfel, timpul de ie\u0219ire al unui nod va fi tot timpul mai mare dec\u00e2t cel al vecinilor s\u0103i, deci pentru a afla ordinea topologic\u0103, trebuie doar s\u0103 sort\u0103m nodurile descresc\u0103tor dup\u0103 timpii de ie\u0219ire.</p> <p>Pentru a face acest lucru mai simplu, putem doar s\u0103 ad\u0103ug\u0103m nodurile \u00eentr-o list\u0103 goal\u0103, pe care o vom inversa la sf\u00e2r\u0219it. S\u0103 ne uit\u0103m la urm\u0103toarea secven\u021b\u0103 de cod:</p> <pre><code>#include &lt;algorithm&gt;\n#include &lt;iostream&gt;\n#include &lt;vector&gt;\n\n// Valoare maxima arbitrara pentru numarul maxim de noduri\nconst int NMAX = 10002;\n\n// Listele de adiacenta\nstd::vector&lt;std::vector&lt;int&gt;&gt; lista_adj(NMAX);\n\n// Lista nodurilor sortate dupa timpii de iesire\nstd::vector&lt;int&gt; ord;\n\n// Daca un nod a mai fost vizitat pana acum sau nu\nstd::vector&lt;bool&gt; viz(NMAX);\n\nvoid dfs(int nod) {\n\n    viz[nod] = 1;\n    // Parcurgem lista vecinilor\n    for (auto vecin : lista_adj[nod]) {\n        // Ne intereseaza doar cei care nu au mai fost vizitati\n        if (!viz[vecin]) {\n            dfs(vecin);\n        }\n    }\n\n    // La intoarcerea din recursivitate adaugam nodul in lista\n    ord.push_back(nod);\n}\n\nint main() {\n    int n, m, u, v;\n\n    // Citire\n    std::cin &gt;&gt; n &gt;&gt; m;\n\n    while (m--) {\n        std::cin &gt;&gt; u &gt;&gt; v;\n        lista_adj[u].push_back(v);\n    }\n\n    // Incepem parcurgerea dfs\n    dfs(1);\n\n    // Inversam lista nodurilor sortate dupa timpii de iesire\n    std::reverse(ord.begin(), ord.end());\n\n    // Afisare\n    for (auto nod : ord) {\n        std::cout &lt;&lt; nod &lt;&lt; \" \";\n    }\n    return 0;\n}\n</code></pre> <p>Acest cod este \u00eens\u0103 gre\u0219it \u0219i nu va da rezultatul corect pentru anumite cazuri. S\u0103 lu\u0103m urm\u0103torul exemplu:</p> <pre><code>graph LR\nA((1)) --&gt; B((2))\nC((3)) --&gt; A\nC --&gt; B</code></pre> <p>\u00cencep\u00e2nd dintr-un nod arbitrar (\u00een acest caz, \\(1\\)), noi vom vizita doar nodurile \u00een care putem ajunge din el. \u00cens\u0103, \u00een exemplul dat, asta \u00eenseamn\u0103 c\u0103 vom ignora nodul \\(3\\), care \u00een sortare s-ar afla \u00eenaintea lui \\(1\\).</p> <p>Pentru a rezolva asta, putem parcurge lista tuturor nodurilor \u0219i s\u0103 verific\u0103m pentru fiecare dac\u0103 este vizitat sau nu. Pentru orice nod nevizitat, \u0219tim c\u0103 nu se poate ajunge la el din niciun nod vizitat, deci este corect s\u0103 spunem c\u0103 orice nod nevizitat se poate afla \u00eenaintea nodurilor deja vizitate.</p> <p>A\u0219adar, pentru orice nod nevizitat, putem \u00eencepe o parcurgere <code>DFS</code> din el \u0219i putem ad\u0103uga \u00een continuare nodurile \u00een lista final\u0103, \u00een func\u021bie de timpul lor de ie\u0219ire.</p> <pre><code>#include &lt;algorithm&gt;\n#include &lt;iostream&gt;\n#include &lt;vector&gt;\n\n// Valoare maxima arbitrara pentru numarul maxim de noduri\nconst int NMAX = 10002;\n\n// Listele de adiacenta\nstd::vector&lt;std::vector&lt;int&gt;&gt; lista_adj(NMAX);\n\n// Lista nodurilor sortate dupa timpii de iesire\nstd::vector&lt;int&gt; ord;\n\n// Daca un nod a mai fost vizitat pana acum sau nu\nstd::vector&lt;bool&gt; viz(NMAX);\n\nvoid dfs(int nod) {\n\n    viz[nod] = 1;\n    // Parcurgem lista vecinilor\n    for (auto vecin : lista_adj[nod]) {\n        // Ne intereseaza doar cei care nu au mai fost vizitati\n        if (!viz[vecin]) {\n            dfs(vecin);\n        }\n    }\n\n    // La intoarcerea din recursivitate adaugam nodul in lista\n    ord.push_back(nod);\n}\n\nint main() {\n    int n, m, u, v;\n\n    // Citire\n    std::cin &gt;&gt; n &gt;&gt; m;\n\n    while (m--) {\n        std::cin &gt;&gt; u &gt;&gt; v;\n        lista_adj[u].push_back(v);\n    }\n\n    // Iteram prin lista nodurilor\n    for (int i = 1; i &lt;= n; i++) {\n        // Daca este nevizitat, incepem parcurgerea DFS din el\n        if (!viz[i]) {\n            dfs(i);\n        }\n    }\n\n    // Inversam lista nodurilor sortate dupa timpii de iesire\n    std::reverse(ord.begin(), ord.end());\n\n    // Afisare\n    for (auto nod : ord) {\n        std::cout &lt;&lt; nod &lt;&lt; \" \";\n    }\n    return 0;\n}\n</code></pre> <p>Acest cod este corect \u0219i va returna o sortare topologic\u0103 valid\u0103 (nu neap\u0103rat unic\u0103). </p>"},{"location":"mediu/toposort/#complexitatea-algoritmului","title":"Complexitatea algoritmului:","text":"<p>Datorit\u0103 faptului c\u0103 folosim o singur\u0103 parcurgere <code>DFS</code>, algoritmul va avea complexitate liniar\u0103 \\(O(n + m)\\), unde \\(n\\) este num\u0103rul de noduri, iar \\(m\\) num\u0103rul de muchii. Memoria va fi tot \\(O(n + m)\\).</p>"},{"location":"mediu/toposort/#exemplu-de-problema-cses-course-schedule","title":"Exemplu de Problema: CSES - Course Schedule","text":""},{"location":"mediu/toposort/#cerinta","title":"Cerin\u021b\u0103:","text":"<p>Se dau \\(n\\) cursuri, numerotate de la \\(1\\) la \\(n\\) \u0219i \\(m\\) condi\u021bii ce trebuie \u00eendeplinite, de forma a doi indici, \\(i\\) \u0219i \\(j\\), cu proprietatea ca acel curs cu num\u0103rul \\(i\\) trebuie terminat \u00eenaintea cursului cu num\u0103rul \\(j\\).</p> \\[1 \\leqslant i &lt; j \\leqslant n\\] <p>Se cere s\u0103 se afi\u0219eze o ordine \u00een care s\u0103 fie f\u0103cute aceste cursuri, astfel \u00eenc\u00e2t toate condi\u021biile s\u0103 fie \u00eendeplinite. Dac\u0103 nu exist\u0103 nicio solu\u021bie, se va afi\u0219a \"IMPOSSIBLE\".</p>"},{"location":"mediu/toposort/#solutie","title":"Solu\u021bie:","text":"<p>Nu este greu s\u0103 ne d\u0103m seama c\u0103 acele 'condi\u021bii' pot fi reprezentate ca ni\u0219te muchii orientate \u00eentr-un graf, iar ordinea valid\u0103 a realiz\u0103rii task-urilor va fi cea din sortarea topologic\u0103 a grafului rezultat. \u00cen cazul \u00een care graful con\u021bine cicluri, algoritmul tot va returna o anumit\u0103 ordine a nodurilor. Astfel, putem parcurge din nou fiecare condi\u021bie \u0219i s\u0103 verific\u0103m dac\u0103 fiecare condi\u021bie e \u00eendeplinit\u0103, iar dac\u0103 nu e, \u00eenseamn\u0103 c\u0103 nu avem solu\u021bie. Putem verifica acest lucru u\u0219or \u021bin\u00e2nd minte \u00eentr-un vector pozi\u021biile nodurilor din sortarea topologic\u0103 \u0219i s\u0103 le compar\u0103m, cum este eviden\u021biat \u0219i \u00een acest cod:</p> <pre><code>#include &lt;algorithm&gt;\n#include &lt;iostream&gt;\n#include &lt;vector&gt;\n\n// Algoritmul descris mai sus, doar ca am schimbat un pic denumirile\nstd::vector&lt;std::vector&lt;int&gt;&gt; G(100005);\n\n// Vector cu toate muchiile\nstd::vector&lt;std::pair&lt;int, int&gt;&gt; edges;\n\nstd::vector&lt;int&gt; ord;\n\nstd::vector&lt;bool&gt; viz(100005);\n\n// Pozitia fiecarui nod in ordinea topologica\nstd::vector&lt;int&gt; poz(100005);\n\nvoid dfs(int nod) {\n    viz[nod] = 1;\n    for (auto x : G[nod]) {\n        if (!viz[x]) {\n            dfs(x);\n        }\n    }\n    ord.push_back(nod);\n}\n\nint main() {\n    int n, m, u, v;\n\n    std::cin &gt;&gt; n &gt;&gt; m;\n    while (m--) {\n        std::cin &gt;&gt; u &gt;&gt; v;\n        G[u].push_back(v);\n        // Adaugam muchia in lista de muchii\n        edges.push_back({u, v});\n    }\n\n    for (int i = 1; i &lt;= n; i++) {\n        if (!viz[i]) {\n            dfs(i);\n        }\n    }\n\n    std::reverse(ord.begin(), ord.end());\n\n    for (int i = 0; i &lt; ord.size(); i++) {\n        poz[ord[i]] = i + 1;\n    }\n\n    // Parcurgem din nou toate muchiile si verificam\n    for (auto e : edges) {\n        if (poz[e.first] &gt; poz[e.second]) {\n            // Am gasit o muchie pentru care nu este respectata ordinea topologica\n            std::cout &lt;&lt; \"IMPOSSIBLE\";\n            return 0;\n        }\n    }\n\n    // Daca ordinea respecta toate conditiile, o afisam\n    for (auto x : ord) {\n        std::cout &lt;&lt; x &lt;&lt; \" \";\n    }\n    return 0;\n}\n</code></pre>"},{"location":"mediu/toposort/#resurse-utile","title":"Resurse Utile","text":""},{"location":"mediu/toposort/#probleme-si-articole-recomandate","title":"Probleme \u0219i Articole Recomandate","text":"<ul> <li>USACO Guide</li> <li>Sortare Topologica - Infoarena</li> <li>Path - Infoarena</li> <li>Leximin - Kilonova</li> </ul>"},{"location":"mediu/toposort/#probleme-aditionale","title":"Probleme adi\u021bionale","text":"<ul> <li>Easygraph - Infoarena</li> <li>xy - Kilonova</li> <li>Somnoros - Kilonova</li> <li>Alpin - Infoarena</li> </ul>"},{"location":"mediu/tree-1/","title":"Introducere \u00een arbori. Diametrul unui arbore","text":"","tags":["arbori","grafuri"]},{"location":"mediu/tree-1/#introducere","title":"Introducere","text":"<p>Arborii sunt un tip particular de grafuri, ace\u0219tia fiind denumirea folosit\u0103 pentru a defini grafurile neorientate conexe \u0219i aciclice. Se poate remarca faptul c\u0103 reprezentarea grafic\u0103 a acestora seaman\u0103 foarte mult cu configura\u021bia unui arbore din p\u0103dure, diferen\u021ba major\u0103 fiind faptul c\u0103 r\u0103d\u0103cina arborelui este plasat\u0103 de obicei \u00een partea de sus a desenului, \u00een contrast cu pozi\u021bia real\u0103 a unei r\u0103d\u0103cini. Nu suntem totu\u0219i la ora de biologie, a\u0219a c\u0103 vom continua cu definirea arborilor.</p> <p>Dintre propriet\u0103\u021bile pe care le au arborii, vom enumera cele mai importante dintre ele, acestea fiind utilizate \u00een mod alternativ \u00een enun\u021buri pentru a defini acela\u0219i lucru.</p> <ul> <li>Graf neorientat conex \u0219i aciclic.</li> <li>Graf neorientat conex cu \\(n\\) noduri \u0219i \\(n-1\\) muchii.</li> <li>Graf neorientat conex cu proprietatea c\u0103 \u00eentre oricare dou\u0103 noduri exist\u0103 un drum unic. Aceast\u0103 proprietate ne permite folosirea DFS pentru aflarea drumurilor minime \u00een arbore, o particularitate ce nu se \u00eent\u00e2lne\u0219te la alte tipuri de grafuri, unde BFS sau al\u021bi algoritmi mai specializa\u021bi de drumuri minime sunt necesare. </li> </ul> <p>Aceste propriet\u0103\u021bi speciale pe care arborii le au fa\u021b\u0103 de grafurile obi\u0219nuite fac rezolvarea multor probleme cu arbori mult mai facil\u0103 dec\u00e2t \u00een mod uzual. \u00cen acest articol vom discuta tipurile de arbori, modalit\u0103\u021bile de a fi parcur\u0219i precum \u0219i c\u00e2teva probleme elementare care pun \u00een eviden\u021b\u0103 modul \u00een care folosim arborii. </p>","tags":["arbori","grafuri"]},{"location":"mediu/tree-1/#terminologie-de-baza","title":"Terminologie de baz\u0103","text":"<p>Pe l\u00e2ng\u0103 termenii folosi\u021bi la grafuri, vom mai defini c\u00e2\u021biva termeni care sunt frecvent utiliza\u021bi \u00een contextul arborilor. </p> <ul> <li>Un nod cu gradul \\(1\\) se nume\u0219te frunz\u0103.</li> <li>Definim nivelul unui nod ca fiind distan\u021ba de la r\u0103d\u0103cin\u0103 la acesta.</li> <li>Pentru o muchie \\((x, y)\\) cu \\(nivel_x &lt; nivel_y\\), vom spune c\u0103 \\(x\\) este p\u0103rintele lui \\(y\\).</li> <li>\u00cen\u0103l\u021bimea unui subarbore reprezint\u0103 distan\u021ba maxim\u0103 a unui nod fa\u021b\u0103 de r\u0103d\u0103cina arborelui.</li> <li>Dac\u0103 avem dou\u0103 noduri \\(x\\) \u0219i \\(y\\) cu \\(nivel_x &lt; nivel_y\\) \u0219i distan\u021ba de la \\(x\\) la \\(y\\) este \\(nivel_y - nivel_x\\), atunci \\(x\\) este str\u0103mo\u0219 al lui \\(y\\). \u00cen contrast, \\(y\\) este un descendent al lui \\(x\\).</li> <li>Totalitatea nodurilor care sunt descenden\u021bii unui nod \\(x\\) formeaz\u0103 subarborele nodului \\(x\\).</li> </ul>","tags":["arbori","grafuri"]},{"location":"mediu/tree-1/#tipuri-de-arbori","title":"Tipuri de arbori","text":"<p>\u00cen func\u021bie de particularit\u0103\u021bile pe care le au arborii, putem vorbi de urm\u0103toarele tipuri de arbori.</p> <ul> <li>Arbori cu r\u0103d\u0103cin\u0103 - arbori la care \u0219tim nodul de la care vom \u00eencepe parcurgerile. De regul\u0103, r\u0103d\u0103cina se afl\u0103 \u00een primul nod al arborelui. </li> <li>Arbore stea - arbore \u00een care toate nodurile sunt conectate cu o muchie la un singur alt nod. </li> <li>Arbore lan\u021b - arbore care are forma unui lan\u021b.</li> <li>Arbore binar - arbore cu proprietatea c\u0103 orice nod are cel mult doi fii. Datorit\u0103 importan\u021bei lor, vom insista mai mult asupra lor pentru anumite defini\u021bii viitoare.</li> </ul>","tags":["arbori","grafuri"]},{"location":"mediu/tree-1/#arbori-binari","title":"Arbori binari","text":"<p>Un arbore binar este un arbore cu proprietatea c\u0103 orice nod are cel mult doi fii. \u00cen func\u021bie de tipul acestui arbore putem defini urm\u0103toarele feluri de arbori binari. </p> <p>Observatie</p> <p>Arborii binari, datorit\u0103 structurii lor foarte versatile, ajung s\u0103 reprezinte o funda\u021bie solid\u0103 \u00een vederea \u00een\u021belegerii foarte multor algoritmi \u0219i structuri de date arborescente, foarte multe implement\u0103ri ale structurilor de date din STL av\u00e2nd la baz\u0103 arborii binari \u00een diverse forme. </p> <ul> <li>Arbore binar strict - un arbore binar \u00een care fiecare nod, cu excep\u021bia celor terminale, are exact doi descenden\u021bi.</li> <li>Arbore binar plin - un arbore binar \u00een care fiecare nivel \\(k \\in{0,1,2,\\dots,h}\\), unde \\(h\\) este \u00een\u0103l\u021bimea arborelui, con\u021bine \\(2^k\\) noduri.</li> <li>Arbore binar complet - un arbore binar \u00een care fiecare nivel \\(k \\in{0,1,2,\\dots,h}\\), unde \\(h\\) este \u00een\u0103l\u021bimea arborelui, con\u021bine \\(2^k\\) noduri, cu excep\u021bia ultimului nivel, nivelul \\(k\\) con\u021bine eventual mai pu\u021bin de \\(2^h\\) noduri, acestea fiind grupate de regul\u0103 \u00een partea st\u00e2ng\u0103..</li> <li>Arbore binar echilibrat - un arbore binar \u00een care pentru fiecare nod, \u00een\u0103l\u021bimea subarborilor din st\u00e2nga \u0219i din dreapta difer\u0103 cu cel mult \\(1\\). </li> <li>Arbore binar de c\u0103utare - un arbore binar \u00een care fiecare nod are o cheie unic\u0103 de identificare care respect\u0103 urm\u0103toarele condi\u021bii: pentru orice subarbore, cheile nodurilor din subarborele st\u00e2ng sunt mai mici dec\u00e2t cheia r\u0103d\u0103cinii, iar pentru orice subarbore, cheile nodurilor din subarborele drept sunt mai mari dec\u00e2t cheia r\u0103d\u0103cinii.</li> </ul>","tags":["arbori","grafuri"]},{"location":"mediu/tree-1/#parcurgerile-preordine-inordine-postordine","title":"Parcurgerile preordine, inordine, postordine}","text":"<p>\u00cen func\u021bie de ordinea \u00een care parcurgem nodurile \u00eentr-un arbore binar, putem avea urm\u0103toarele tipuri de parcurgere:</p>","tags":["arbori","grafuri"]},{"location":"mediu/tree-1/#parcurgerea-preordine-rsd","title":"Parcurgerea preordine (RSD)","text":"<ul> <li>Vizit\u0103m mai \u00eent\u00e2i nodul curent</li> <li>Vizit\u0103m recursiv subarborele st\u00e2ng al nodului curent. </li> <li>Vizit\u0103m recursiv subarborele drept al nodului curent. </li> </ul> <p>Parcurgerea preordine e o parcurgere ordonat\u0103 topologic, deoarece un nod p\u0103rinte va fi mereu vizitat \u00eenaintea copiilor s\u0103i.</p>","tags":["arbori","grafuri"]},{"location":"mediu/tree-1/#parcurgerea-inordine-srd","title":"Parcurgerea inordine (SRD)","text":"<ul> <li>Vizit\u0103m recursiv subarborele st\u00e2ng al nodului curent. </li> <li>Vizit\u0103m mai \u00eent\u00e2i nodul curent</li> <li>Vizit\u0103m recursiv subarborele drept al nodului curent. </li> </ul> <p>\u00centr-un arbore binar de c\u0103utare construit astfel \u00eenc\u00e2t fiecare nod e mai mare dec\u00e2t nodurile din subarborele st\u00e2ng \u0219i mai mic dec\u00e2t nodurile din subarborele drept, parcurgerea \u00eenordine returneaz\u0103 valorile \u00een ordine cresc\u0103toare.</p>","tags":["arbori","grafuri"]},{"location":"mediu/tree-1/#parcurgerea-postordine-sdr","title":"Parcurgerea postordine (SDR)","text":"<ul> <li>Vizit\u0103m recursiv subarborele st\u00e2ng al nodului curent. </li> <li>Vizit\u0103m recursiv subarborele drept al nodului curent. </li> <li>Vizit\u0103m mai \u00eent\u00e2i nodul curent</li> </ul> <p>Parcurgerea postordine poate fi util\u0103 pentru a ob\u021bine expresia postfix a unui arbore binar pentru evaluarea unei expresii.</p>","tags":["arbori","grafuri"]},{"location":"mediu/tree-1/#aplicatii-ale-arborilor","title":"Aplica\u021bii ale arborilor","text":"<p>Arborii sunt utili \u00een cazul multor probleme, ace\u0219tia dovedindu-\u0219i utilitatea c\u00e2nd vine vorba de procesarea unor rela\u021bii dintre noduri \u00eentr-un mod mult mai facil dec\u00e2t cel al grafurilor. Exist\u0103 algoritmi \u00een capitolele viitoare, precum aflarea arborelui par\u021bial de cost minim, care se bazeaz\u0103 \u00eentr-un mod extensiv pe ei. </p>","tags":["arbori","grafuri"]},{"location":"mediu/tree-1/#problema-exemplu-aflarea-dimensiunilor-subarborilor-unui-nod","title":"Problem\u0103 exemplu - aflarea dimensiunilor subarborilor unui nod","text":"<p>Pentru a rezolva aceast\u0103 problem\u0103, va trebui s\u0103 parcurgem arborele (de preferat, folosind un DFS) de la r\u0103d\u0103cin\u0103, cu scopul de a ajunge pe r\u00e2nd la toate frunzele arborelui. Pentru fiecare frunz\u0103, dimensiunea subarborelui s\u0103u va fi \\(1\\), iar pentru fiecare nod care nu e frunz\u0103, va fi suma subarborilor fiilor s\u0103i. \u00cen final, vom avea un algoritm ce ruleaz\u0103 \u00een \\(O(n)\\).</p> <pre><code>vector&lt;vector&lt;int&gt; &gt; tree;\nint sz[100001];\nvoid dfs (int nod, int tata) {\n    sz[nod] = 1;\n    for (int i = 0; i &lt; (int) tree[nod].size(); i++) {\n        int fiu = tree[nod][i];\n        if (fiu != tata) {\n            dfs(fiu, nod);\n            sz[nod] += sz[fiu];\n        }\n    }\n}\n</code></pre>","tags":["arbori","grafuri"]},{"location":"mediu/tree-1/#problema-exemplu-aflarea-diametrului-unui-arbore","title":"Problem\u0103 exemplu - aflarea diametrului unui arbore","text":"<p>Definim diametrul unui graf ca fiind distan\u021ba minim\u0103 cea mai mare \u00eentre dou\u0103 noduri din graf. De\u0219i \u00een mod normal, aceast\u0103 problem\u0103 este NP-hard, \u00een cazul unui arbore exist\u0103 un algoritm simplu care func\u021bioneaz\u0103 \u00een \\(O(n)\\). Pentru a putea ob\u021bine aceast\u0103 distan\u021b\u0103, avem nevoie de dou\u0103 parcurgeri, ambele pot fi DFS sau BFS. </p> <p>Prima parcurgere este dintr-un nod oarecare, scopul fiind s\u0103 afl\u0103m cel mai \u00eendep\u0103rtat nod de acesta. Apoi, vom rula a doua parcurgere din acest nod cel mai \u00eendep\u0103rtat pentru a afla distan\u021ba maxim\u0103 de la acesta la celelalte noduri din arbore. \u00centr-un final, vom ob\u021bine r\u0103spunsul c\u0103utat \u00een \\(O(n)\\) folosind doar dou\u0103 parcurgeri.</p> <pre><code>#include &lt;vector&gt;\n#include &lt;iostream&gt;\nusing namespace std;\n\nint n, root = 1, a, b;\nvector&lt;vector&lt;int&gt; &gt; graph;\nvector&lt;int&gt; dist;\n\nvoid dfs (int parent, int node) {\n    if (dist[node] &gt; dist[root])\n        root = node;\n    for (int i = 0; i &lt; (int) graph[node].size(); i++) {\n        int nxt = graph[node][i];\n        if(nxt == parent) {\n            continue;\n        }\n        dist[nxt] = dist[node] + 1;\n        dfs(node, nxt);\n    }\n}\nint main() {\n    cin &gt;&gt; n;\n    graph.resize(n+1);\n    dist.resize(n+1);\n    for(int i = 1; i &lt; n; i++) {\n        cin &gt;&gt; a &gt;&gt; b;\n        graph[a].push_back(b);\n        graph[b].push_back(a);\n    }\n    dfs(0, root);\n    dist[root] = 0;\n    dfs(0, root);\n    cout &lt;&lt; dist[root] &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["arbori","grafuri"]},{"location":"mediu/tree-1/#alte-probleme-si-resurse-utile","title":"Alte probleme \u0219i resurse utile","text":"<ul> <li>Introduction to Tree Algorithms</li> <li>Grafuri \u0219i arbori - no\u021biuni de baz\u0103</li> <li>Subordinates</li> <li>nivele2 infoarena</li> <li>Grarb infoarena</li> <li>IIOT tourdetree</li> <li>Tree Diameter</li> <li>Mootube USACO Silver</li> <li>Milk Visits USACO Silver</li> <li>Sap</li> </ul>","tags":["arbori","grafuri"]},{"location":"mediu/two-pointers/","title":"Two pointers","text":"","tags":["vectori","sortare","cautari"]},{"location":"mediu/two-pointers/#fundamente-si-cunostinte-necesare","title":"Fundamente \u0219i cuno\u0219tin\u021be necesare","text":"<p>Tehnica Two pointers este o tehnic\u0103 pe care o putem folosi \u00een foarte multe tipuri de probleme \u00een care avem de c\u0103utat subsecven\u021be cu diverse propriet\u0103\u021bi, condi\u021bia principal\u0103 fiind aceea c\u0103 vrem s\u0103 g\u0103sim o pereche de valori sau de indici ce respect\u0103 anumite reguli, f\u0103r\u0103 s\u0103 dep\u0103\u0219im o anumit\u0103 valoare sau o anumit\u0103 condi\u021bie. Aceast\u0103 tehnic\u0103 apare \u00een foarte multe tipuri de probleme ce se dau la concursurile de informatic\u0103, de foarte multe ori reprezent\u00e2nd o optimizare la posibile solu\u021bii cu c\u0103utare binar\u0103 sau alte structuri de date ce ar ad\u0103uga un factor de complexitate \u00een plus la solu\u021bie.</p> <p>\u00cen articol voi \u00eencepe prin a explica tipurile de probleme unde putem folosi Two pointers, urm\u00e2nd ca apoi s\u0103 prezint c\u00e2teva probleme de diverse dificult\u0103\u021bi, explic\u00e2nd principalele strategii de abordare a acestor tipuri de probleme \u0219i pun\u00e2nd accentul \u0219i pe implement\u0103ri clare, care au drept scop evitarea gre\u0219elilor tipice c\u00e2nd vine vorba de implementarea acestei metode.</p> <p>Pentru a folosi aceast\u0103 metod\u0103, e nevoie s\u0103 st\u0103p\u00e2nim lucrul cu secven\u021be \u0219i ideal \u0219i c\u0103utarea binar\u0103, deoarece pentru multe dintre exemplele ce vor fi men\u021bionate, exist\u0103 solu\u021bii \u0219i folosind acest algoritm. Nu \u00een ultimul r\u00e2nd, pentru anumite probleme e posibil s\u0103 fie nevoie de structuri de date adi\u021bionale, cum ar fi map sau set .</p> <p>\u00cen ceea ce prive\u0219te modul \u00een care \u00eencepem implement\u0103rile, avem dou\u0103 tipuri majore de implement\u0103ri, \u00een func\u021bie de algoritm. Merit\u0103 men\u021bionat faptul c\u0103 ace\u0219ti pointeri sunt de fapt variabile corespunz\u0103toare indicilor din vector la care ne afl\u0103m la momentul respectiv. </p> <p>\u00cen primul r\u00e2nd, vorbim de problemele \u00een care vrem s\u0103 plec\u0103m de la prima pozi\u021bie \u0219i s\u0103 proces\u0103m secven\u021bele care respect\u0103 o anumit\u0103 proprietate monoton\u0103 (cresc\u0103toare sau descresc\u0103toare). \u00cen acest caz, vom avea ambii pointeri cu indexul de \u00eenceput de la 1 \u0219i vom avansa cu pointerul din dreapta at\u00e2ta timp c\u00e2t \u00eenc\u0103 se mai respect\u0103 condi\u021bia cerut\u0103 din enun\u021b.</p> <p>De asemenea, mai exist\u0103 probleme \u00een care plec\u0103m cu pointerul st\u00e2ng de la prima pozi\u021bie \u0219i cu pointerul drept de la ultima pozi\u021bie \u0219i vrem s\u0103 mergem cu ace\u0219ti pointeri \u00een direc\u021bii opuse, deoarece c\u0103ut\u0103m o proprietate ce are o varia\u021bie descresc\u0103toare fa\u021b\u0103 de scopul problemei.</p>","tags":["vectori","sortare","cautari"]},{"location":"mediu/two-pointers/#problema-1-subarray-sums-i","title":"Problema 1 - Subarray Sums I","text":"<p>Dat fiind un vector cu \\(n\\) elemente numere naturale, determina\u021bi num\u0103rul de subsecven\u021be din vector pentru care suma elementelor este egal\u0103 cu \\(x\\).</p> <p>Pentru a rezolva aceast\u0103 problem\u0103, trebuie s\u0103 ne folosim de faptul c\u0103 toate numerele din \u0219irul dat sunt pozitive, ceea ce face rezolvarea mult mai u\u0219oar\u0103. Astfel, vom putea afla pentru fiecare pozi\u021bie de \u00eenceput a \u0219irului, care este pozi\u021bia cea mai din dreapta astfel \u00eenc\u00e2t suma valorilor din acel interval s\u0103 fie mai mic\u0103 sau egal\u0103 cu \\(x\\). Dac\u0103 acea sum\u0103 este egal\u0103 cu \\(x\\), vom incrementa r\u0103spunsul. Vom avea grij\u0103 la fiecare pas s\u0103 increment\u0103m variabila \\(st\\), av\u00e2nd grij\u0103 s\u0103 sc\u0103dem valoarea curent\u0103 din sum\u0103 mai \u00eent\u00e2i.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint n, v[200002], x;\nint st, dr, sum, ans;\n\nint main() {\n    ios_base::sync_with_stdio(false);  \n    cin.tie(nullptr);\n\n    cin &gt;&gt; n &gt;&gt; x;\n    for (int i = 1; i &lt;= n; i++) {\n        cin &gt;&gt; v[i];\n    }\n\n    st = dr = 1;\n    sum = ans = 0;\n    while (st &lt;= n) {\n        while (dr &lt;= n &amp;&amp; sum &lt; x) {\n            sum += v[dr];\n            dr++;\n        }\n        if (sum == x) {\n            ans++;\n        }\n        sum -= v[st];\n        st++;\n    }\n    cout &lt;&lt; ans;\n    return 0;\n}\n</code></pre>","tags":["vectori","sortare","cautari"]},{"location":"mediu/two-pointers/#problema-2-sum-of-two-values","title":"Problema 2 - Sum of Two Values","text":"<p>Se d\u0103 un vector cu \\(n\\) valori pozitive \u0219i o valoare \\(x\\). Scrie\u021bi un program care s\u0103 determine dou\u0103 valori aflate pe pozi\u021bii distincte care adunate s\u0103 dea suma \\(x\\).</p> <p>Pentru a rezolva aceast\u0103 problem\u0103, trebuie s\u0103 folosim o variant\u0103 diferit\u0103 a tehnicii celor doi pointeri. Astfel, de data asta vom \u00eencepe cu un pointer la pozi\u021bia \\(1\\), iar cu cel\u0103lalt la pozi\u021bia \\(n\\). Pe parcurs, vom avea trei cazuri \u00een func\u021bie de suma \\(a_{p_1} + a_{p_2}\\), iar dac\u0103 g\u0103sim dou\u0103 pozi\u021bii cu suma valorilor egal\u0103 cu \\(x\\), afi\u0219\u0103m pozi\u021biile corespunz\u0103toare, altfel modific\u0103m \\(p_1\\) sau \\(p_2\\) dup\u0103 caz. Dac\u0103 nu g\u0103sim nicio pereche, afi\u0219\u0103m IMPOSSIBLE.</p> <pre><code>#include &lt;algorithm&gt;\n#include &lt;iostream&gt;\n\nusing namespace std;\n\nint n, x, a[200002], b[200002];\n\nint main() {\n    cin &gt;&gt; n &gt;&gt; x;\n    for (int i = 1; i &lt;= n; ++i) {\n        cin &gt;&gt; a[i];\n        b[i] = a[i];\n    }\n\n    sort(a + 1, a + n + 1);\n    int p1 = 1, p2 = n;\n\n    while (p1 &lt; p2) {\n        if (a[p1] + a[p2] == x) {\n            int valA = a[p1];\n            int valB = a[p2];\n\n            for (int i = 1; i &lt;= n; ++i) {\n                if (b[i] == valA) {\n                    cout &lt;&lt; i &lt;&lt; \" \";\n                    valA = 0;\n                } else if (b[i] == valB) {\n                    cout &lt;&lt; i &lt;&lt; \" \";\n                    valB = 0;\n                }\n            }\n            return 0;\n        } else {\n            if (a[p1] + a[p2] &gt; x) {\n                --p2;\n            } else {\n                ++p1;\n            }\n        }\n    }\n\n    cout &lt;&lt; \"IMPOSSIBLE\";\n    return 0;\n} \n</code></pre>","tags":["vectori","sortare","cautari"]},{"location":"mediu/two-pointers/#problema-3-nane","title":"Problema 3 - Nane","text":"<p>Nane de pe Jiu, mare algoritmician fiind, v\u0103 provoac\u0103 s\u0103 rezolva\u021bi o problem\u0103 prea u\u0219oar\u0103 pentru el. Nane v\u0103 d\u0103 \\(N\\) numere naturale \u0219i un num\u0103r \\(K\\). Numim subsecven\u021b\u0103 special\u0103 o subsecven\u021b\u0103 pentru care efectu\u00e2nd opera\u021bia OR pe bi\u021bi pentru elementele din subsecven\u021b\u0103 (s\u0103 numim aceast\u0103 opera\u021bie sum\u0103 OR) ob\u021binem un rezultat care are, \u00een reprezentare binar\u0103, cel mult \\(K\\) bi\u021bi de \\(1\\). Dou\u0103 subsecven\u021be sunt diferite dac\u0103 cel pu\u021bin o pozi\u021bie din una nu se reg\u0103se\u0219te \u00een cealalt\u0103. Scrie\u021bi un program care s\u0103 determine num\u0103rul de subsecven\u021be speciale.</p> <p>Pentru a rezolva aceast\u0103 problem\u0103, vom folosi metoda celor doi pointeri pentru a afla num\u0103rul de secven\u021be care au suma OR cu cel mult \\(k\\) de \\(1\\), actualiz\u0103rile fiind foarte similare cu cele de la celelalte probleme de acest tip. De asemenea, deoarece vorbim de suma OR, trebuie s\u0103 folosim c\u00e2te un vector de frecven\u021b\u0103 pentru fiecare bit pentru a evita calculele adi\u021bionale.</p> <pre><code>#include &lt;fstream&gt;\n#define ll long long\nusing namespace std;\n\nint n, k, v[100002], fr[32];\n\nll ans;\n\nbool ok() {\n    int cnt = 0;\n    for (int i = 0; i &lt;= 30; ++i) {\n        if (fr[i]) {\n            ++cnt;\n        }\n    }\n    if (cnt &lt;= k) {\n        return 1;\n    }\n    return 0;\n}\n\nvoid add(int poz, int val) {\n    for (int i = 0; i &lt;= 30; ++i) {\n        if ((v[poz] &amp; (1 &lt;&lt; i))) {\n            fr[i] += val;\n        }\n    }\n}\nint main() {\n    ifstream cin(\"nane.in\");\n    ofstream cout(\"nane.out\");\n\n    cin &gt;&gt; n &gt;&gt; k;\n    for (int i = 1; i &lt;= n; ++i) cin &gt;&gt; v[i];\n    int st = 1;\n    int dr = 1;\n    while (st &lt;= n) {\n        while (dr &gt; n || !ok()) {\n            if (ok()) {\n                ans += dr - st;\n                add(st, -1);\n                ++st;\n            } else {\n                add(st, -1);\n                ++st;\n                ans += dr - st;\n            }\n        }\n        while (dr &lt;= n &amp;&amp; ok()) {\n            add(dr, 1);\n            ++dr;\n        }\n    }\n    cout &lt;&lt; ans &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["vectori","sortare","cautari"]},{"location":"mediu/two-pointers/#problema-4-jjooii","title":"Problema 4 - JJOOII","text":"<p>Se consider\u0103 un \u0219ir format din \\(N\\) caractere din mul\u021bimea {J, O, I}. Se nume\u0219te JOI-\u0219ir de nivel \\(K\\) un \u0219ir format din \\(K\\) litere J, \\(K\\) litere O \u0219i \\(K\\) litere I (\u00een aceast\u0103 ordine). De exemplu, JJOOII este un JOI-\u0219ir de nivel \\(2\\). Bitaro dore\u0219te s\u0103 transforme \u0219irul \\(S\\) \u00eentr-un JOI-\u0219ir de nivel \\(K\\), utiliz\u00e2nd urm\u0103toarele \\(3\\) opera\u021bii, de oric\u00e2te ori \u0219i \u00een orice ordine:</p> <ul> <li>Opera\u021bia \\(1\\): Bitaro \u0219terge primul caracter din \\(S\\);</li> <li>Opera\u021bia \\(2\\): Bitaro \u0219terge ultimul caracter din \\(S\\);</li> <li>Opera\u021bia \\(3\\): Bitaro \u0219terge un caracter din interiorul lui \\(S\\) (care nu este   nici primul nici ultimul).</li> </ul> <p>Deoarece opera\u021biile de tip \\(3\\) necesit\u0103 mult timp, Bitaro dore\u0219te s\u0103 transforme \u0219irul \\(S\\) \u00eentr-un JOI-\u0219ir de nivel \\(K\\) folosind un num\u0103r minim de opera\u021bii de tip \\(3\\). Scrie\u021bi un program care, cunosc\u00e2nd \\(N\\), \\(S\\) \u0219i \\(K\\), determin\u0103 num\u0103rul minim de opera\u021bii de tip \\(3\\) necesare pentru a transforma \u0219irul \\(S\\) \u00eentr-un JOI-\u0219ir de nivel \\(K\\). Dac\u0103 acest lucru nu este posibil, programul va afi\u0219a valoarea \\(-1\\).</p> <p>Pentru a rezolva aceast\u0103 problem\u0103, va trebui mai \u00eent\u00e2i s\u0103 afl\u0103m unde sunt situate literele J, O \u0219i I \u00een \u0219irul nostru de caractere. Ulterior, pe m\u0103sur\u0103 ce fix\u0103m secven\u021bele de \\(k\\) de J, avem pointeri care duc la secven\u021bele corespunz\u0103toare de O \u0219i I din celelalte dou\u0103 \u0219iruri, calculele ulterioare devenind destul de u\u0219oare.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint vj[200001], vo[200001], vi[200001];\n\nint lj, lo, li;\n\nint main() {\n    int n, k;\n    cin &gt;&gt; n &gt;&gt; k;\n\n    string s;\n    cin &gt;&gt; s;\n\n    for (int i = 0; i &lt; n; i++) {\n        if (s[i] == 'J') {\n            vj[++lj] = i;\n        }\n        if (s[i] == 'O') {\n            vo[++lo] = i;\n        }\n        if (s[i] == 'I') {\n            vi[++li] = i;\n        }\n    }\n\n    int pj = 1;\n    int po = 1;\n    int pi = 1;\n\n    int ans = n + 1;\n\n    for (int pj = 0; pj + k - 1 &lt; lj; ++pj) {\n        int po = 0;\n        while (po + k - 1 &lt; lo &amp;&amp; vo[po] &lt;= vj[pj + k - 1]) {\n            po++;\n        }\n\n        if (po + k - 1 &lt; lo) {\n            int pi = 0;\n            while (pi + k - 1 &lt; li &amp;&amp; vi[pi] &lt;= vo[po + k - 1]) {\n                pi++;\n            }\n\n            if (pi + k - 1 &lt; li) {\n                int start = vj[pj];\n                int end = vi[pi + k - 1];\n                int segment_length = (end - start + 1) - 3 * k;\n\n                ans = min(ans, segment_length);\n            }\n        }\n    }\n\n    cout &lt;&lt; (ans == n + 1 ? -1 : ans);\n    return 0;\n}\n</code></pre>","tags":["vectori","sortare","cautari"]},{"location":"mediu/two-pointers/#probleme-suplimentare","title":"Probleme suplimentare","text":"","tags":["vectori","sortare","cautari"]},{"location":"mediu/two-pointers/#probleme-de-la-olimpiade","title":"Probleme de la olimpiade","text":"<ul> <li>Probleme cu two pointers</li> <li>Infoarena 3secv</li> <li>JOI JJOOII 2</li> <li>NOI Singapore Global Warming</li> <li>Baraj Seniori 2023 sirbun</li> <li>Infoarena nane</li> <li>USACO Social   Distancing</li> <li>USACO MooTube</li> <li>USACO Wormhole   Sort</li> <li>USACO Sprinklers</li> <li>USACO Cow Dating</li> </ul>","tags":["vectori","sortare","cautari"]},{"location":"mediu/two-pointers/#probleme-de-pe-codeforces","title":"Probleme de pe Codeforces","text":"<ul> <li>Towers -   Codeforces</li> <li>Two Pointers -   Codeforces</li> <li>Two Pointers Step 1 - Codeforces   EDU</li> <li>Two Pointers Step 2 - Codeforces   EDU</li> <li>Two Pointers Step 3 - Codeforces   EDU</li> </ul>","tags":["vectori","sortare","cautari"]},{"location":"mediu/two-pointers/#bibliografie-si-lectura-suplimentara","title":"Bibliografie \u0219i lectur\u0103 suplimentar\u0103","text":"<ul> <li>Two Pointers - USACO Guide</li> <li>Link ce trebuie accesat pentru inscrierea la cursul despre DSU facut de ITMO   Academy</li> <li>Curs despre Two Pointers - Codeforces (este necesar un cont pentru a putea   accesa acest curs, plus accesarea linkului de mai   sus)</li> <li>Using the Two Pointers   Technique</li> <li>Edu - Two pointers</li> <li>Competitive Programmer's Handbook - Capitolul   8</li> </ul>","tags":["vectori","sortare","cautari"]},{"location":"usor/arrays/","title":"Tablouri (arrays)","text":"<p>Autor: \u0218tefan-Cosmin D\u0103sc\u0103lescu, \u0218tefan-Iulian Alecu</p> <p>Una din primele structuri de date pe care orice programator o folose\u0219te, indiferent de limbajul de programare folosit este tabloul (array \u00een englez\u0103). Ace\u0219tia stau la baza unui num\u0103r mare de prelucr\u0103ri care necesit\u0103 un volum mare de date, iar \u00een contextul rezolv\u0103rii problemelor de algoritmic\u0103, tablouri sunt o parte fundamental\u0103 at\u00e2t \u00een sine, c\u00e2t \u0219i prin faptul c\u0103 toate tablourile multidimensionale sunt de fapt, tablouri unidimensionale pu\u0219i \u00eempreun\u0103. Colocvial, aceste tablouri mai sunt numite \u0219i vectori, dar trebuie evitat\u0103 confuzia cu vectorii din STL, prezenta\u021bi ulterior.</p> <p>Observa\u021bie</p> <p>\u00cen memorie, tablourile sunt stocate secven\u021bial, indiferent de num\u0103rul de dimensiuni pe care \u00eel au.</p> <p>\u00cen contextul limbajului C++, putem lucra cu tablourile \u00een dou\u0103 moduri distincte: fie folosind varianta standard, luat\u0103 din limbajul C, fie folosind STL (Standard Template Library). Conceptele din STL vor fi prezentate \u00een capitolele ulterioare, deoarece acesta nu con\u021bine doar tablouri dinamice. \u00cen acest capitol voi insista mai ales pe varianta standard, lucrul cu STL fiind aprofundat mai cu seam\u0103 \u00een capitolele utile.</p>","tags":["vectori"]},{"location":"usor/arrays/#declararea-si-umplerea-tablourilor-statice","title":"Declararea \u0219i umplerea tablourilor statice","text":"<p>Pentru a declara un tablou \u0219i a da valori, trebuie s\u0103 analiz\u0103m structura acestuia. \u00cen mod similar cu variabilele simple, ne trebuie un tip de date pe care acest tablou s\u0103-l stocheze, precum \u0219i dimensiunea pe care vrem s\u0103 o atribuim acestui tablou.</p> <p>De exemplu, <code>int v[101];</code> \u00eenseamn\u0103 ca am declarat un tablou cu \\(101\\) elemente, pozi\u021biile fiind num\u0103rate de la \\(0\\) la \\(100\\).</p> <p>Observa\u021bie</p> <p>Dac\u0103 prefera\u021bi s\u0103 lucra\u021bi cu tablouri indexate de la \\(1\\), ave\u021bi grij\u0103 s\u0103 ad\u0103uga\u021bi \\(1\\) la dimensiunile pe care le folosi\u021bi pentru a adapta tablourile la stilul vostru de lucru. De asemenea, nu pute\u021bi \u00eencepe tablourile de la indici negativi cum se poate \u00een alte limbaje (Pascal, de pild\u0103) \u0219i nici s\u0103-i folosi\u021bi pentru a lua elemente de la final (ca \u00een Python).</p> <p>Observa\u021bie</p> <p>De obicei, dimensiunea maxim\u0103 este una static\u0103, dar putem transforma tablourile statice \u00een structuri alocate dinamic folosind func\u021biile din limbajul C. Totu\u0219i, acesta nu este scopul articolului de fa\u021b\u0103, iar ulterior va fi prezentat STL. </p> <p>Pentru a atribui o valoare unei anumite pozi\u021bii, se va proceda similar ca la o variabil\u0103 obi\u0219nuit\u0103, de exemplu <code>v[5] = 7;</code> \u00eenseamn\u0103 c\u0103 pe pozi\u021bia \\(5\\), vom avea acum valoarea \\(7\\).</p> <p>Pentru a citi un vector, vom folosi de regul\u0103 o structur\u0103 repetitiv\u0103, precum for sau while, citind valorile pe r\u00e2nd, la fel cum am proceda cu variabile obi\u0219nuite.</p> <p>O alt\u0103 metod\u0103 de a ini\u021bializa elementele dintr-un tablou este aceea de a atribui valori primelor pozi\u021bii, idee ce va fi folosit\u0103 pe parcurs la diver\u0219i algoritmi, un exemplu notabil fiind flood fill. De exemplu, <code>int A[] = {10, 20, 30};</code> va crea un tablou cu \\(3\\) elemente, unde <code>A[0] = 10; A[1] = 20;</code> \u0219.a.m.d.</p>","tags":["vectori"]},{"location":"usor/arrays/#inserarea-stergerea-inversarea-valorilor-dintr-un-tablou","title":"Inserarea, \u0219tergerea, inversarea valorilor dintr-un tablou","text":"<p>De multe ori \u00een diverse aplica\u021bii, putem avea nevoie de opera\u021bia de inserare \u0219i de opera\u021bia de \u0219tergere din tablou, ambele opera\u021bii fiind foarte importante pentru a putea lucra \u00een mod corespunz\u0103tor cu tablourile. \u00cen exemplele pe care le voi prezenta mai jos, voi presupune c\u0103 tablourile sunt indexate de la \\(1\\).</p>","tags":["vectori"]},{"location":"usor/arrays/#inserarea-in-tablou","title":"Inserarea \u00een tablou","text":"<p>Dac\u0103 avem un tablou cu \\(n\\) valori \u0219i vrem s\u0103 inser\u0103m o valoare nou\u0103 la pozi\u021bia \\(k\\), unde \\(1 \\leq k \\leq n+1\\), vom vrea mai \u00eent\u00e2i s\u0103 mut\u0103m valorile \u00eentre pozi\u021biile \\(n\\) \u0219i \\(k\\) cu o pozi\u021bie la dreapta, iar mai apoi vom atribui noua valoare pe pozi\u021bia \\(k\\).  </p> <pre><code>for (int i = n; i &gt;= k; i--) {\n    v[i + 1] = v[i];\n}\n\nv[k] = x;\n\nn++; // (1)\n</code></pre> <ol> <li>Tabloul va avea o valoare \u00een plus, drept pentru care trebuie s\u0103      cre\u0219tem \u00een consecin\u021b\u0103 lungimea sa.</li> </ol> <p>Aten\u021bie</p> <p>Mutarea valorilor trebuie f\u0103cut\u0103 \u00een ordine descresc\u0103toare a pozi\u021biilor ini\u021biale deoarece altfel, am ajunge s\u0103 avem aceea\u0219i valoare peste tot.</p> <pre><code>for (int i = k; i &lt;= n; i++) {\n    v[i + 1] = v[i];\n}\n\nv[k] = x;\n\nn++; \n</code></pre> <p>Se poate observa cu u\u0219urin\u021b\u0103 c\u0103 valoarea de pe pozi\u021bia \\(k\\) va ajunge peste tot dac\u0103 implement\u0103m a\u0219a, ceea ce este gre\u0219it.</p>","tags":["vectori"]},{"location":"usor/arrays/#stergerea-din-tablou","title":"\u0218tergerea din tablou","text":"<p>Dac\u0103 avem un tablou cu \\(n\\) valori \u0219i vrem s\u0103 \u0219tergem valoarea de la pozi\u021bia \\(k\\), unde \\(1 \\leq k \\leq n\\), vom vrea s\u0103 mut\u0103m pe r\u00e2nd valorile de la pozi\u021biile \\(k+1\\), \\(k+2\\), ..., \\(n\\) cu o pozi\u021bie mai \u00een spate. Spre deosebire de cazul inser\u0103rii, vom vrea s\u0103 mut\u0103m valorile \u00een ordine cresc\u0103toare a pozi\u021biei ini\u021biale. </p> <pre><code>for (int i = k; i &lt; n; i++) {\n    v[i] = v[i + 1];\n}\n\n\nn--; // (1)\n</code></pre> <ol> <li>Tabloul va avea o valoare \u00een minus, drept pentru care trebuie s\u0103      sc\u0103dem \u00een consecin\u021b\u0103 lungimea sa.</li> </ol> <p>Aten\u021bie</p> <p>Mutarea valorilor trebuie f\u0103cut\u0103 \u00een ordine cresc\u0103toare a pozi\u021biilor ini\u021biale deoarece altfel, am ajunge s\u0103 avem aceea\u0219i valoare peste tot.</p> <pre><code>for (int i = n; i &gt; k; i--) {\n    v[i - 1] = v[i];\n}\n\nn--; \n</code></pre>","tags":["vectori"]},{"location":"usor/arrays/#inversarea-unui-tablou","title":"Inversarea unui tablou","text":"<p>Pentru a putea inversa un tablou, trebuie s\u0103 \u0219tim num\u0103rul de elemente pe care \u00eel are. Scopul nostru este s\u0103 avem pe pozi\u021bia \\(i\\) valoarea ce se afla anterior pe pozi\u021bia \\(n - i + 1\\), implementarea nefiind prea dificil\u0103. Pentru a p\u0103stra scopul educativ, am implementat interschimbarea elementelor folosind \"regula celor trei pahare\".</p> <pre><code>for (int i = 1; i &lt;= n / 2; i++) {\n    int x = v[i];         // (1)\n    v[i] = v[n - i + 1];  // (2)\n    v[n - i + 1] = x;     // (3)\n}\n</code></pre> <ol> <li>Re\u021binem valoarea lui <code>v[i]</code> \u00een <code>x</code>.</li> <li>Interschimb\u0103m <code>v[i]</code> cu pozi\u021bia echivalent\u0103 de la cap\u0103tul tabloului, adic\u0103 <code>v[n - i + 1]</code>. </li> <li>Re\u021binem valoarea lui <code>v[i]</code> \u00een <code>x</code>.</li> </ol>","tags":["vectori"]},{"location":"usor/arrays/#interclasarea-tablourilor","title":"Interclasarea tablourilor","text":"<p>Pentru a putea interclasa dou\u0103 tablouri (de regul\u0103, cresc\u0103toare) \\(A\\) \u0219i \\(B\\), av\u00e2nd \\(n\\), respectiv \\(m\\) elemente, vom vrea mereu s\u0103 introducem valoarea mai mic\u0103 \u00een tabloul unde \u021binem rezultatul, \\(C\\), acesta av\u00e2nd lungimea \\(n + m\\). De asemenea, vom vrea s\u0103 avem grij\u0103 ca dup\u0103 ce prelucr\u0103m complet unul din cele dou\u0103 tablouri, s\u0103 continu\u0103m inser\u0103rile cu cel de-al doilea tablou, unul din ele ar r\u0103m\u00e2ne mereu cu valori. </p> <p>Observa\u021bie</p> <p>Folosind acest algoritm de interclasare, putem ob\u021bine un tablou cresc\u0103tor \u00een \\(\\mathcal{O}(n + m)\\), unde \\(n\\) \u0219i \\(m\\) sunt lungimile celor dou\u0103 \u0219iruri. </p> <p>Observa\u021bie</p> <p>Folosind un algoritm similar cu cel prezentat mai jos, putem implementa diverse opera\u021bii pe mul\u021bimi, precum reuniunea, intersec\u021bia \u0219i diferen\u021ba.</p> <pre><code>int i = 1;\nint j = 1;\nint poz = 0;\n\n// Mergem prin tablou p\u00e2n\u0103 c\u00e2nd am parcurs unul din ele.\nwhile (i &lt;= n &amp;&amp; j &lt;= m) {\n    poz++;\n\n    // Punem \u00een C elementul mai mic dintre A[i] \u0219i B[j]\n    if (A[i] &lt;= B[j]) {\n        C[poz] = A[i];\n        i++;\n    } else {\n        C[poz] = B[j];\n        j++;\n    }\n}\n\n// Dac\u0103 mai exist\u0103 elemente \u00een A, adaug\u0103-le \u00een C.\nwhile (i &lt;= n) {\n    poz++;\n    C[poz] = A[i];\n    i++;\n}\n\n// Dac\u0103 mai exist\u0103 elemente \u00een B, adaug\u0103-le \u00een C.\nwhile (j &lt;= m) {\n    poz++;\n    C[poz] = B[j];\n    j++;\n}\n</code></pre>","tags":["vectori"]},{"location":"usor/arrays/#rotirea-tablourilor","title":"Rotirea tablourilor","text":"<p>Pentru a putea roti un tablou la st\u00e2nga sau la dreapta, va trebui s\u0103 mut\u0103m toate elementele cu o pozi\u021bie la st\u00e2nga/dreapta, iar pentru a putea face asta, va trebui mai \u00eent\u00e2i s\u0103 p\u0103str\u0103m \u00een memorie valoarea de pe prima/ultima pozi\u021bie, s\u0103 mut\u0103m secven\u021bial celelalte valori \u0219i \u00een cele din urm\u0103 s\u0103 mut\u0103m valoarea p\u0103strat\u0103 pe ultima/prima pozi\u021bie \u00een \u0219irul nou rezultat. \u00cen mod similar, putem implementa rotirea cu \\(k\\) pozi\u021bii, folosind \\(\\mathcal{O}(k)\\) memorie suplimentar\u0103. </p> <p>De\u0219i algoritmul prezentat este unul liniar, mai t\u00e2rziu pute\u021bi descoperi un algoritm ce ruleaz\u0103 \u00een timp constant pentru o rota\u021bie la st\u00e2nga sau la dreapta.</p> <pre><code>void rotire(int arr[], int n, bool laStanga = true, int k = 1) {\n    k = k % n;\n\n    // Dac\u0103 k = 0 sau multiplu de n, nu facem nimic.\n    if (k == 0) {\n        return;\n    }\n\n    int temp[k];\n    if (laStanga) {\n        rotireLaStanga(arr, n, k);\n    } else {\n        rotireLaDreapta(arr, n, k);\n    }\n}\n</code></pre> Rotire la st\u00e2ngaRotire la dreapta <pre><code>void rotireLaStanga(int arr[], int n, int k) {\n    int* temp = new int[k];\n\n    // P\u0103str\u0103m primele k elemente\n    for (int i = 0; i &lt; k; ++i) {\n        temp[i] = arr[i];  // P\u0103str\u0103m primele k elemente\n    }\n\n    // Mut\u0103m elementele spre st\u00e2nga\n    for (int i = 0; i &lt; n - k; ++i) {\n        arr[i] = arr[i + k];\n    }\n\n    // Plas\u0103m elementele p\u0103strate la sf\u00e2r\u0219it\n    for (int i = 0; i &lt; k; ++i) {\n        arr[n - k + i] = temp[i];\n    }\n\n    delete[] temp;\n}\n</code></pre> <pre><code>void rotireLaDreapta(int arr[], int n, int k) {\n    int* temp = new int[k];\n\n    // P\u0103str\u0103m ultimele k elemente\n    for (int i = 0; i &lt; k; ++i) {\n        temp[i] = arr[n - k + i];\n    }\n\n    // Mut\u0103m elementele spre dreapta\n    for (int i = n - 1; i &gt;= k; --i) {\n        arr[i] = arr[i - k];\n    }\n\n    // Plas\u0103m elementele p\u0103strate la \u00eenceput\n    for (int i = 0; i &lt; k; ++i) {\n        arr[i] = temp[i];\n    }\n\n    delete[] temp;\n}\n</code></pre>","tags":["vectori"]},{"location":"usor/arrays/#concluzii","title":"Concluzii","text":"<p>Lucrul cu tablouri unidimensionale este esen\u021bial oric\u0103rui algoritmist, principiile men\u021bionate aici fiind aplicate \u00een diverse moduri \u0219i \u00een ceea ce prive\u0219te alte structuri de date, a\u0219a cum ve\u021bi putea observa \u00een problemele cu matrici \u0219i \u00een diferi\u021bi algoritmi care au la baz\u0103 metodele folosite mai sus. </p>","tags":["vectori"]},{"location":"usor/arrays/#probleme-suplimentare","title":"Probleme suplimentare","text":"<ul> <li>Problemele usoare si medii din capitolul Parcurgerea vectorilor</li> <li>Problemele usoare si medii din capitolul \u0218tergeri \u0219i inser\u0103ri de elemente \u00een vectori</li> <li>Problemele usoare si medii din capitolul Verificarea unor propriet\u0103\u0163i</li> <li>Problemele usoare si medii din capitolul Interclasare</li> </ul>","tags":["vectori"]},{"location":"usor/arrays/#resurse-suplimentare","title":"Resurse suplimentare","text":"<ul> <li>Declararea \u0219i parcurgerea tablourilor unidimensionale</li> <li>\u0218tergeri \u0219i inser\u0103ri de elemente</li> <li>Verificarea unor propriet\u0103\u021bi</li> <li>Interclasarea tablourilor</li> </ul>","tags":["vectori"]},{"location":"usor/basic-math/","title":"Cuno\u0219tin\u021be matematice de baz\u0103","text":"<p>Autor: \u0218tefan-Cosmin D\u0103sc\u0103lescu</p>","tags":["matematica","aritmetica"]},{"location":"usor/basic-math/#introducere","title":"Introducere","text":"<p>Un mit care este r\u0103sp\u00e2ndit de foarte mul\u021bi oameni \u00een diverse medii este acela c\u0103 matematica nu are vreo relevan\u021b\u0103 \u00een programare sau algoritmic\u0103, ceea ce nu poate fi mai fals. De\u0219i nu este necesar s\u0103 fii olimpic la matematic\u0103 pentru a fi foarte bun la algoritmic\u0103 sau mai ales pentru a fi un bun programator, cuno\u0219tin\u021bele adecvate de matematic\u0103 sunt foarte importante deoarece foarte mul\u021bi algoritmi \u0219i foarte multe ramuri ale informaticii se bazeaz\u0103 pe un fundament matematic solid, care s\u0103 permit\u0103 aprofundarea unor capitole specifice. </p> <p>Observa\u021bie</p> <p>Totu\u0219i, dac\u0103 e\u0219ti deja foarte bun la matematic\u0103 sau chiar olimpic, asta va face \u00eenv\u0103\u021barea multor capitole mai u\u0219oar\u0103, deoarece foarte multe no\u021biuni se coreleaz\u0103 cu cele de la matematic\u0103. \u00cen esen\u021b\u0103, programarea se reduce \u00een multe situa\u021bii la limbaj matematic transpus \u00een cod citibil de ma\u0219inile de calcul.</p> <p>De exemplu, de-a lungul studiului algoritmicii, pe l\u00e2ng\u0103 cuno\u0219tin\u021bele matematice de baz\u0103 care vor fi subiectul acestui articol, ve\u021bi avea de-a face cu capitole specifice combinatoricii, divizibilit\u0103\u021bii, teoriei numerelor, geometriei, algebrei liniare \u0219i multe alte subiecte care introduc cititorii \u00een algoritmi mai avansa\u021bi. </p> <p>Chiar \u0219i \u00een aplica\u021bii mai simple, modelarea unor probleme de matematic\u0103 folosind programe a devenit foarte important\u0103 \u00een ultimele decenii, \u00eenv\u0103\u021barea f\u0103c\u00e2ndu-se \u00een prezent aproape exclusiv cu ajutorul solu\u021biilor digitale.</p> <p>\u00cen cele ce urmeaz\u0103, vom discuta fundamentele opera\u021biilor matematice de baz\u0103, sintaxa lor \u00een limbajul C++ precum \u0219i c\u00e2teva lucruri esen\u021biale pe care trebuie s\u0103 le ave\u021bi \u00een vedere atunci c\u00e2nd vre\u021bi s\u0103 simplifica\u021bi lucrurile \u00een ceea ce prive\u0219te aplicarea lor \u00een diverse contexte. </p>","tags":["matematica","aritmetica"]},{"location":"usor/basic-math/#operatii-aritmetice-pe-numere-intregi","title":"Opera\u021bii aritmetice pe numere \u00eentregi","text":"<p>\u00cen primul r\u00e2nd, orice problem\u0103 pe care o rezolva\u021bi implic\u0103 \u00eentr-un mod sau altul opera\u021biile aritmetice de baz\u0103 (adunarea, sc\u0103derea, \u00eenmul\u021birea, \u00eemp\u0103r\u021birea).</p> <p>Ordinea efectu\u0103rii opera\u021biilor este aceea\u0219i ca la matematic\u0103, opera\u021biile de \u00eenmul\u021bire \u0219i \u00eemp\u0103r\u021bire sunt efectuate \u00eenaintea celor de adunare \u0219i sc\u0103dere. </p> <p>Pentru a evita confuzia \u00een ceea ce prive\u0219te folosirea diverselor opera\u021bii matematice, se recomand\u0103 folosirea parantezelor pentru a simplifica calculele. </p> <p>\u00cen ceea ce prive\u0219te opera\u021bia de \u00eemp\u0103r\u021bire pe numere \u00eentregi, rezultatul afi\u0219at va fi mereu num\u0103rul f\u0103r\u0103 virgul\u0103. </p> <pre><code>cout &lt;&lt; 8 + 2 &lt;&lt; '\\n'; // 10\ncout &lt;&lt; 4 * 3 &lt;&lt; '\\n'; // 12\ncout &lt;&lt; 12 - 5 &lt;&lt; '\\n'; // 7\ncout &lt;&lt; 16 / 4 &lt;&lt; '\\n'; // 4\ncout &lt;&lt; 15 / 4 &lt;&lt; '\\n'; // 3\ncout &lt;&lt; -9 / 3 &lt;&lt; '\\n'; // -3\ncout &lt;&lt; -8 / 3 &lt;&lt; '\\n'; // -2\n</code></pre> <p>Observa\u021bie</p> <p>Trebuie avut grij\u0103 la faptul c\u0103 dac\u0103 rezultatul opera\u021biei dep\u0103\u0219e\u0219te valoarea maxim\u0103 sau minim\u0103 a tipului de date \u00een care acesta este p\u0103strat, vom avea overflow-uri, care trebuie evitate cu orice pre\u021b.</p>","tags":["matematica","aritmetica"]},{"location":"usor/basic-math/#solutii-pentru-evitarea-overflow-ului","title":"Solu\u021bii pentru evitarea overflow-ului","text":"<p>Cele mai populare dou\u0103 solu\u021bii sunt fie folosirea tipului de date long long pentru p\u0103strarea termenilor din opera\u021bii, fie folosirea operatorului 1LL, fie folosirea (long long) pentru convertirea datelor.</p> <pre><code>cout &lt;&lt; 594943 * 204232 &lt;&lt; '\\n'; // overflow\ncout &lt;&lt; 1LL * 594943 * 204232 &lt;&lt; '\\n'; // ok\ncout &lt;&lt; (long long) 594943 * 204232 &lt;&lt; '\\n'; // ok\ncout &lt;&lt; 594943 * (long long) 204232 &lt;&lt; '\\n'; // ok\n</code></pre>","tags":["matematica","aritmetica"]},{"location":"usor/basic-math/#operatii-aritmetice-pe-numere-reale","title":"Opera\u021bii aritmetice pe numere reale","text":"<p>\u00cen ceea ce prive\u0219te numerele reale, dac\u0103 apare un num\u0103r real \u00een expresia aritmetic\u0103, rezultatul final va deveni \u0219i el un num\u0103r real. Totu\u0219i, dac\u0103 expresia este memorat\u0103 \u00eentr-un tip de date \u00eentreg, atunci rezultatul va r\u0103m\u00e2ne \u00eentreg.</p> <pre><code>cout &lt;&lt; 2.5 + 7 &lt;&lt; '\\n'; // 9.5\ncout &lt;&lt; 3 * 2.5 &lt;&lt; '\\n'; // 7.5\ncout &lt;&lt; 2.5 / 2 &lt;&lt; '\\n'; // 1.25\ncout &lt;&lt; 2 / 2.5 &lt;&lt; '\\n'; // 0.8\ncout &lt;&lt; 6.3/20+24 &lt;&lt; '\\n'; // 24.315\nint x = 6.3/20+24; \ncout &lt;&lt; x &lt;&lt; '\\n'; // 24\n</code></pre>","tags":["matematica","aritmetica"]},{"location":"usor/basic-math/#ridicarea-la-putere","title":"Ridicarea la putere","text":"<p>Pentru a afla rezultatul expresiei \\(a^b\\), avem dou\u0103 moduri principale de a calcula acest lucru. </p> <p>\u00cen primul r\u00e2nd, putem folosi instruc\u021biunea <code>pow</code> din biblioteca <code>#include &lt;cmath&gt;</code>, sintaxa fiind <code>pow(baza, exponent)</code>, dar problema este aceea c\u0103 de\u0219i aceasta este o solu\u021bie viabil\u0103 pentru numere reale, uneori putem ajunge \u00een situa\u021bia \u00een care dac\u0103 calcul\u0103m un rezultat foarte mare (de exemplu, \\(9^{14}\\)), \u00een func\u021bie de precizia opera\u021biei de ridicare la putere, s\u0103 avem rezultate de forma \\(x.999999999\\) care rotunjite \u00een jos, s\u0103 ne dea \\(x-1\\). </p> <p>O metod\u0103 mai simpl\u0103 const\u0103 \u00een a ridica la putere folosind o structur\u0103 repetitiv\u0103 care calculeaz\u0103 \\(a^b\\) \u00een \\(b\\) pa\u0219i, a\u0219a cum se poate vedea mai jos. </p> <pre><code>int ans = 0;\nfor (int i = 1; i &lt;= b; i++) {\n    ans = ans * a;\n}\ncout &lt;&lt; ans &lt;&lt; '\\n';\n</code></pre> <p>Pentru cei mai avansa\u021bi, aceast\u0103 opera\u021bie se poate face \u0219i \u00een timp logaritmic, cunoa\u0219terea acestei tehnici nefiind necesar\u0103 dec\u00e2t celor care vor s\u0103 mearg\u0103 la olimpiad\u0103. </p>","tags":["matematica","aritmetica"]},{"location":"usor/basic-math/#tehnici-matematice-simple","title":"Tehnici matematice simple","text":"<p>De multe ori, mai ales \u00een problemele mai simple de algoritmic\u0103, cunoa\u0219terea unor formule \u0219i principii matematice simple este esen\u021bial\u0103. </p>","tags":["matematica","aritmetica"]},{"location":"usor/basic-math/#formule-pentru-sume-remarcabile","title":"Formule pentru sume remarcabile","text":"<p>A\u0219a cum \u0219ti\u021bi probabil de la matematic\u0103, avem diverse formule pentru unele sume de numere naturale. Cele mai multe dintre ele se pot demonstra fie prin calcul direct, fie prin induc\u021bie matematic\u0103. </p> <ul> <li>\\(1 + 2 + 3 + \\dots + n = \\frac{n \\cdot (n+1)}{2}\\) (suma lui Gauss)</li> <li>\\(1^2 + 2^2 + 3^2 + \\dots + n^2 = \\frac{n \\cdot (n+1) \\cdot (2 \\cdot n+1)}{6}\\) (suma p\u0103tratelor perfecte)</li> <li>\\(1^3 + 2^3 + 3^3 + \\dots + n^3 = (\\frac{n \\cdot (n+1)}{2})^2\\) (suma cuburilor perfecte)</li> <li>\\(1 + 3 + 5 + \\dots + (2n - 1) = n^2\\)</li> <li>\\((a + b)^2 = a^2 + 2ab + b^2\\)</li> <li>\\((a - b)^2 = a^2 - 2ab + b^2\\)</li> <li>\\(a^2 - b^2 = (a-b)(a+b)\\)</li> </ul>","tags":["matematica","aritmetica"]},{"location":"usor/basic-math/#rezolvarea-unor-tipuri-de-ecuatii","title":"Rezolvarea unor tipuri de ecua\u021bii","text":"<p>Pentru ecua\u021bia de gradul \\(1\\) \u0219i \\(2\\), avem tehnici binecunoscute pentru aflarea solu\u021biilor, dup\u0103 cum urmeaz\u0103.</p> <ul> <li>Pentru o ecua\u021bie de forma \\(ax + b = 0\\), solu\u021bia ecua\u021biei este \\(\\frac{-b}{a}\\).</li> <li>Pentru o ecua\u021bie de forma \\(ax^2 + bx + c = 0\\), avem \\(0\\), \\(1\\) sau \\(2\\) solu\u021bii reale, care pot fi aflate prin formulele \\(\\frac{-b + \\sqrt(\\Delta)}{2a}\\) \u0219i \\(\\frac{-b - \\sqrt(\\Delta)}{2a}\\), unde \\(\\Delta = b^2 - 4ac\\). Dac\u0103 \\(\\Delta &lt; 0\\), nu exist\u0103 solu\u021bii reale. </li> </ul>","tags":["matematica","aritmetica"]},{"location":"usor/basic-math/#rearanjarea-unor-sume-si-produse","title":"Rearanjarea unor sume \u0219i produse","text":"<p>\u00cen unele situa\u021bii, suntem nevoi\u021bi s\u0103 rearanj\u0103m diver\u0219i termeni ai unor egalit\u0103\u021bi pentru a simplifica calculele. De obicei, c\u00e2nd vrem s\u0103 facem asta, scopul este acela de a aduce termenii ce se pot p\u0103stra \u00een acela\u0219i mod \u00eempreun\u0103.</p> <p>Dac\u0103 vrem s\u0103 afl\u0103m c\u00e2te perechi de forma \\((i, j)\\) exist\u0103 cu proprietatea c\u0103 \\(x_i + x_j = y_i + y_j\\), este mai simplu s\u0103 afl\u0103m c\u00e2te perechi exist\u0103 cu proprietatea c\u0103 \\(x_i - y_i = y_j - x_j = -(x_j - y_j)\\), lucru ce se poate afla mult mai u\u0219or folosind vectori de frecven\u021b\u0103.  </p>","tags":["matematica","aritmetica"]},{"location":"usor/basic-math/#lucrul-cu-intervale","title":"Lucrul cu intervale","text":"<p>Dac\u0103 avem dou\u0103 intervale de numere naturale \\([x_1, y_1]\\) \u0219i \\([x_2, y_2]\\) putem discuta despre urm\u0103toarele dou\u0103 intervale:</p> <ul> <li>Pentru intervalele de mai sus, intersec\u021bia lor este \\([max(x_1, x_2), min(y_1, y_2)]\\), cu condi\u021bia c\u0103 \\(max(x_1, x_2) \\leq min(y_1, y_2)\\). </li> <li>Pentru intervalele de mai sus, reuniunea lor este \\([min(x_1, x_2), max(y_1, y_2)]\\), cu condi\u021bia c\u0103 intersec\u021bia lor este nevid\u0103. Dac\u0103 intersec\u021bia este vid\u0103, reuniunea intervalelor este dat\u0103 de cele dou\u0103 intervale luate separat. </li> </ul>","tags":["matematica","aritmetica"]},{"location":"usor/basic-math/#divizibilitatea-numerelor-naturale","title":"Divizibilitatea numerelor naturale","text":"<p>De\u0219i acest capitol este abordat \u00een detaliu aici, aici vom sublinia doar aspectele de baz\u0103.</p> <p>Operatorul pe care \u00eel folosim pentru a verifica dac\u0103 dou\u0103 numere se \u00eempart unul la altul este \\(\\%\\) \u0219i acesta ne afl\u0103 restul \u00eemp\u0103r\u021birii de\u00eemp\u0103r\u021bitului la \u00eemp\u0103r\u021bitor. </p> <p>\u00cen mod particular, dac\u0103 \\(a \\% b = 0\\), atunci \\(a\\) se \u00eemparte exact la \\(b\\).</p> <p>O alt\u0103 particularitate a numerelor prime este aceea c\u0103 num\u0103rul aproximativ de numere prime \u00eentre \\(1\\) \u0219i \\(n\\) este \\(\\frac{n}{\\log n}\\), iar \u00een mod similar, \\(\\sum_{i=1}^n \\frac{n}{i} \\approx n \\log n\\).</p>","tags":["matematica","aritmetica"]},{"location":"usor/basic-math/#concluzii","title":"Concluzii","text":"<p>De\u0219i matematica prezentat\u0103 aici nu ar trebui s\u0103 pun\u0103 probleme unui elev de liceu care cite\u0219te acest articol (sau chiar \u0219i unui elev mai bun de gimnaziu), este foarte important de avut \u00een vedere tehnicile de rezolvare a problemelor, precum \u0219i formulele aflate de la matematic\u0103. </p> <p>Chiar dac\u0103 aplicarea lor este un pic diferit\u0103 precum cea de la mate, pe m\u0103sur\u0103 ce v\u0103 obi\u0219nui\u021bi cu aceste principii, lucrurile vor deveni mai simple. </p>","tags":["matematica","aritmetica"]},{"location":"usor/basic-math/#resurse-suplimentare","title":"Resurse suplimentare","text":"<ul> <li>Problemele usoare si medii din capitolul Sume, produse, numarari</li> <li>Problemele usoare si medii din capitolul Maxime si minime</li> <li>Probleme usoare de matematica de pe Codeforces</li> </ul>","tags":["matematica","aritmetica"]},{"location":"usor/binary-search/","title":"C\u0103utarea binar\u0103","text":"<p>Autor: Andrei-Cristian Ivan</p> <p>S\u0103 presupunem c\u0103 avem un \u0219ir de \\(N\\) numere \u0219i memorie astfel \u00eenc\u00e2t s\u0103 putem re\u021bine doar \u0219irul (plus evident alte variabile, dar nu foarte multe). Noi primim mai multe \u00eentreb\u0103ri, de forma: Exist\u0103 valoarea \\(X\\) \u00een \u0219ir?</p> <p>\u00cen mod evident, o solu\u021bie foarte trivial\u0103 este s\u0103 parcurgem manual \u0219irul pentru fiecare \u00eentrebare, \u0219i s\u0103 vedem dac\u0103 elementul cerut apare sau nu \u00een \u0219ir, astfel ob\u021bin\u00e2nd complexitate total\u0103 de \\(O(N \\cdot Q)\\). Singura noastr\u0103 problem\u0103 este c\u0103 noi o s\u0103 avem \\(N\\) \u0219i \\(Q\\) undeva \u00een jur de \\(10^6\\), ceea ce va face ca aceast\u0103 abordare s\u0103 pice clar \u00een timp, deci va trebui g\u0103sit\u0103 o solu\u021bie mult mai eficient\u0103. Aici intervine algoritmul de c\u0103utare binar\u0103.</p>","tags":["vectori"]},{"location":"usor/binary-search/#prezentarea-algoritmului","title":"Prezentarea algoritmului","text":"<p>Not\u0103</p> <p>De acum \u00eencolo, se va presupune c\u0103 \u0219irul nostru este sortat cresc\u0103tor. C\u0103utarea binar\u0103 pe un \u0219ir nesortat va da mereu r\u0103spunsuri eronate.</p> <p>\u00cen algoritmul de c\u0103utare binar\u0103 se va pleca de la analiza \u0219irului pe \u00eentreaga sa lungime, \u0219i se va fixa punctul de mijloc din sir. Dac\u0103 valoarea pozi\u021biei din mijloc este mai mic\u0103 dec\u00e2t valoarea c\u0103utat\u0103, atunci sigur valoarea c\u0103utat\u0103 se poate (c\u0103 nu \u0219tim sigur dac\u0103 exist\u0103!) afla \u00een a doua jum\u0103tate, altfel, se poate afla \u00een prima jum\u0103tate. Mai departe, nu va mai fi necesar sa analiz\u0103m tot \u0219irul, ci doar jum\u0103tatea relevant\u0103 (cea \u00een care consider\u0103m noi c\u0103 exist\u0103 o \u0219ans\u0103 s\u0103 g\u0103sim valoarea noastr\u0103), \u0219i algoritmul se va repeta p\u00e2n\u0103 c\u00e2nd lungimea devine \\(1\\) \u0219i putem determina r\u0103spunsul. Dat fiind faptul c\u0103 noi la fiecare pas \u00eemp\u0103r\u021bim la \\(2\\) lungimea \u0219irului, acest lucru ne va da complexitate logaritmic\u0103 la determinarea r\u0103spunsului, deci vom avea complexitate \\(O(Q \\log N)\\) (dac\u0103 \u0219irul nostru nu este sortat din input, se mai adaug\u0103 \u0219i un \\(O(N \\log N)\\) la complexitate), cu memorie \\(O(N)\\).</p> <p>Pentru o \u00een\u021belegere mai clar\u0103 a algoritmului, s\u0103 presupunem urm\u0103torul exemplu: se d\u0103 un \u0219ir sortat cresc\u0103tor unde apar toate numerele de la \\(1\\) la \\(100\\), \u0219i se cere s\u0103 determin\u0103m dac\u0103 exist\u0103 \u00een \u0219ir valoarea \\(72\\).</p> <p> </p> <p>O \u00eentrebare la care trebuie totu\u0219i dat r\u0103spuns este: De ce \u00eemp\u0103r\u021bim \u00een dou\u0103 jum\u0103t\u0103\u021bi \u0219i de ce nu \u00een \\(3\\) treimi? Da, \\(\\log_3 N &lt; \\log_2 N\\), dar num\u0103rul de verific\u0103ri efectuate va fi mai mare la \u00eemp\u0103r\u021birea \u00een \\(3\\) treimi, deci \u00een continuare este mai eficient s\u0103 \u00eemp\u0103r\u021bim \u00een dou\u0103 jum\u0103t\u0103\u021bi. \u00cen mod inductiv se va demonstra pentru orice \u00eemp\u0103r\u021bire posibil\u0103.</p>","tags":["vectori"]},{"location":"usor/binary-search/#o-implementare-banala","title":"O implementare banal\u0103","text":"<p>Cea mai des \u00eent\u00e2lnit\u0103 implementare a c\u0103ut\u0103rii binare este urm\u0103toarea:</p> <pre><code>int cb_naiv(int n) {\n    int l = 1;\n    int r = n;\n    int ans = -1;\n\n    while (l &lt;= r) {\n        int mij = (l + r) / 2;\n        if (conditie) {\n            ans = mij;\n            l = mij + 1;\n        } else {\n            r = mij - 1;\n        }\n    }\n\n    return ans;\n}\n</code></pre> <p>Implementarea de mai sus este una corect\u0103, dar se pot \u00eent\u00e2lni urm\u0103toarele bug-uri:</p> <ul> <li> <p>Schimbarea \u00een \\(l = mij\\) \u0219i \\(r = mij\\) va face ca programul nostru s\u0103 ruleze   \u00eentr-o bucl\u0103 infinit\u0103 (deoarece ambele valori vor atinge la un moment dat   valoarea \\(mij\\), \u0219i deci va fi respectat\u0103 mereu condi\u021bia \\(l \\leq r\\))</p> </li> <li> <p>\u00cen timp ce-l calcul\u0103m pe \\(mij\\), ne putem lua overflow (dac\u0103 prin absurd   ajungem s\u0103 c\u0103utam fix pe la valorile maxime pe care le poate re\u021bine tipul   nostru de date, este inevitabil un overflow generat de \\(l + r\\)). De aceea,   urm\u0103toarea variant\u0103 prezentat\u0103 se va axa fix pe rezolvarea acestui bug.</p> </li> </ul>","tags":["vectori"]},{"location":"usor/binary-search/#o-implementare-corecta","title":"O implementare corect\u0103","text":"<pre><code>int cb_corect(int n) {\n    int l = 1;\n    int r = n;\n    int ans = -1;\n\n    while (l &lt; r) {\n        int mij = l + (r - l) / 2;\n\n        if (conditie) {\n            ans = mij;\n            l = mij + 1;\n        } else {\n            r = mij - 1;\n        }\n    }\n\n    return ans;\n}\n</code></pre> <p>Aceast\u0103 c\u0103utare binar\u0103 se bazeaz\u0103 pe principiul men\u021bionat mai sus: noi \u00eenjum\u0103t\u0103\u021bim de fiecare dat\u0103 lungimea \u0219irului pe care \u00eencerc\u0103m s\u0103 c\u0103ut\u0103m ceea ce ne intereseaz\u0103. Formula de mai sus pentru calcularea mijlocului este echivalent\u0103 cu cea din prima c\u0103utare, dar mai mult, nu are cum s\u0103 ne dea overflow.</p> <p>De fiecare dat\u0103 c\u00e2nd mijlocul nostru verific\u0103 condi\u021bie, noi facem un \u201esalt\u201d de la o pozi\u021bie \\(l\\) la alta. La finalul c\u0103ut\u0103rii, indicele \\(l\\) final va fi defapt o sum\u0103 a salturilor, iar ca pe orice num\u0103r \u00eentreg, noi acest num\u0103r \u00eel putem descompune \u00eentr-o alt\u0103 baz\u0103 numeric\u0103. Hai s\u0103 vedem cum putem rafina aceast\u0103 idee cu o alt\u0103 implementare mai jos.</p>","tags":["vectori"]},{"location":"usor/binary-search/#cautarea-binara-a-lui-mihai-patrascu","title":"C\u0103utarea binar\u0103 a lui Mihai P\u0103tra\u0219cu","text":"<pre><code>void cb3_patrascu(int n) {\n    int l = 0;\n\n    for (int bit = 31; bit &gt;= 0; --bit) {\n        int putere = 1 &lt;&lt; bit;\n        if ((l | putere) &lt;= n &amp;&amp; conditie) {\n            l |= putere;\n        }\n    }\n}\n</code></pre> <p>Baza \u00een care noi vom descompune suma va fi baza \\(2\\), pentru a men\u021bine \u00een continuare complexitatea \\(\\log_2 N\\). Ini\u021bial, vom pleca cu un exponent \\(e\\), unde \\(2^e\\) va reprezenta lungimea secven\u021bei pe care o analiz\u0103m (aten\u021bie s\u0103 nu ie\u0219im din vector!). Chiar dac\u0103 noi vom analiza ini\u021bial o lungime care este putere de \\(2\\), care foarte probabil s\u0103 fie diferit\u0103 de \\(N\\), se poate demonstra foarte u\u0219or c\u0103 noi (dac\u0103 o s\u0103 fie necesar), vom putea c\u0103uta valori \u0219i \u00een acea secven\u021b\u0103 neacoperit\u0103 ini\u021bial. L\u0103s\u0103m aceast\u0103 demonstra\u021bie ca tem\u0103 pentru cititor.</p> <p>C\u0103utarea de mai sus poart\u0103 \u0219i numele de C\u0103utarea binar\u0103 a lui Mihai P\u0103tra\u0219cu, sau c\u0103utarea pe bi\u021bi.</p> <p>\u00cen mare parte, aceste c\u0103ut\u0103ri binare ne vor da aceea\u0219i complexitate peste tot, \u00een schimb, c\u00e2nd vrem s\u0103 implement\u0103m algoritmul de Lowest Common Ancestor (LCA) cu Binary Lifting, c\u0103utarea binar\u0103 pe bi\u021bi reduce algoritmul de la \\(O(\\log^2{H})\\) la \\(O(\\log{H})\\), unde \\(H\\) reprezint\u0103 ad\u00e2ncimea maxim\u0103 a arborelui.</p>","tags":["vectori"]},{"location":"usor/binary-search/#cautarea-binara-pe-raspuns","title":"C\u0103utarea binar\u0103 pe r\u0103spuns","text":"<p>Aici trebuie completat</p>","tags":["vectori"]},{"location":"usor/binary-search/#functii-de-sistem-pentru-cautarea-binara","title":"Func\u021bii de sistem pentru c\u0103utarea binar\u0103","text":"<p>\u0218i aici trebuie completat</p>","tags":["vectori"]},{"location":"usor/binary-search/#concluzii-si-lecturi-suplimentare","title":"Concluzii \u0219i lecturi suplimentare","text":"<p>C\u0103utarea binar\u0103 este unul dintre cele mai fundamentale principii ale algoritmicii, fiind absolut necesar pentru a optimiza probleme unde ni se cere s\u0103 determin\u0103m existen\u021ba unei valori \u00eentr-un \u0219ir, sau determinarea unui num\u0103r maxim/minim care s\u0103 respecte o condi\u021bie impus\u0103 de problem\u0103 etc.</p> <p>Pentru aprofundarea a algoritmului, recomand rezolvarea urm\u0103toarelor probleme \u0219i citirea urm\u0103toarelor articole:</p> <p>\u0218i aici trebuie destule probleme \u0219i exemple</p> <ul> <li>Problema cautbin (Infoarena)</li> <li>Binary Search - USACO Guide</li> <li>Cursurile Edu de pe Codeforces, este necesar\u0103 \u00eenregistrarea anterioar\u0103</li> </ul>","tags":["vectori"]},{"location":"usor/complexity/","title":"Complexit\u0103\u021bi","text":"<p>Autor: \u0218tefan-Cosmin D\u0103sc\u0103lescu</p>","tags":["notiuni de baza"]},{"location":"usor/complexity/#introducere","title":"Introducere","text":"<p>Atunci c\u00e2nd elabor\u0103m un algoritm, vrem s\u0103 \u0219tim c\u00e2t de rapid va fi, pentru a putea decide dac\u0103 are sens s\u0103 trecem la implementarea lui propriu-zis\u0103. Un mod de a m\u0103sura calitatea unui algoritm este dat de complexitatea pe care \u00eel are. \u00cen cele ce urmeaz\u0103 vom discuta acest concept \u0219i modul \u00een care \u00eel putem aplica \u00een probleme.</p> <p>\u00cen\u021belegem prin complexitate num\u0103rul de pa\u0219i pe care \u00eel face un algoritm \u00een func\u021bie de dimensiunea setului de date primite. Cunoa\u0219terea acestui concept este fundamental\u0103 pentru facilitarea rezolv\u0103rii de probleme. </p> <p>\u00cen practic\u0103, complexit\u0103\u021bile sunt de dou\u0103 tipuri, cea de timp \u0219i cea de memorie, ambele av\u00e2nd metodele lor specifice de calculare a eficien\u021bei.</p>","tags":["notiuni de baza"]},{"location":"usor/complexity/#complexitatea-de-timp","title":"Complexitatea de timp","text":"<p>Pentru a calcula complexitatea de timp a unui algoritm, trebuie s\u0103 avem \u00een vedere urm\u0103toarele aspecte specifice:</p> <ul> <li>\u00cen practic\u0103, procesoarele moderne pot procesa aproximativ \\(3 \\cdot 10^8\\) opera\u021bii simple pe secund\u0103, acest num\u0103r depinde \u00een func\u021bie de contextul unde trebuie rezolvat\u0103 problema (anumite site-uri sunt mai rapide dec\u00e2t altele \u0219i anumite evaluatoare de la concursurile oficiale sunt mai rapide dec\u00e2t altele).</li> </ul> <p>Observa\u021bie</p> <p>\u00cen concursuri, folosirea valorii de \\(10^8\\) opera\u021bii pe secund\u0103 este o estimare precis\u0103, care este folosit\u0103 de regul\u0103 \u0219i de propun\u0103torii de probleme atunci c\u00e2nd se decid limitele de timp.</p> <ul> <li>Exemple de opera\u021bii simple: opera\u021biile aritmetice simple, increment\u0103rile, opera\u021biile pe bi\u021bi etc.</li> <li>Exemple de opera\u021bii care nu sunt simple: aflarea radicalului, aflarea restului \u00eemp\u0103r\u021birii etc. </li> </ul> <p>\u00cen general, constantele mici pot fi ignorate \u00een calculul complexitatilor. De exemplu, \\(O(N)\\) este echivalent cu \\(O(3 \\cdot N)\\) \u0219i \\(O(2 \\cdot N)\\). Mai jos pute\u021bi g\u0103si exemple de cod, \u00eempreun\u0103 cu complexit\u0103\u021bile lor.</p> <p>Acest cod are complexitatea \\(O(1)\\), opera\u021biile fiind constante. </p> <pre><code>int a = 5;\nint b = 7;\nint c = 4;\nint d = a + b + c + 153;\n</code></pre> <p>Aceste coduri au complexitatea \\(O(n)\\), num\u0103rul de opera\u021bii fiind cel f\u0103cut \u00een structura repetitiv\u0103. </p> <pre><code>for (int i = 1; i &lt;= n; i++) {\n    // cod in timp constant\n}\n</code></pre> <pre><code>int i = 0;\nwhile (i &lt; n) {\n    // cod in timp constant\n    i++;\n}\n</code></pre> <p>\u00cen ciuda constantelor care apar, codurile au din nou complexitatea \\(O(n)\\). Aceste coduri au complexitatea \\(O(n)\\), num\u0103rul de opera\u021bii fiind cel f\u0103cut \u00een structura repetitiv\u0103. </p> <pre><code>for (int i = 1; i &lt;= 5 * n + 17; i++) {\n    // cod in timp constant\n}\n</code></pre> <pre><code>for (int i = 1; i &lt;= n + 758458; i++) {\n    // cod in timp constant\n}\n</code></pre> <p>Dac\u0103 avem de-a face cu mai multe structuri repetitive imbricate, complexitatea se va \u00eenmul\u021bi, complexitatea codului de mai jos este \\(O(n \\cdot m)\\)</p> <pre><code>for (int i = 1; i &lt;= n; i++) {\n    for (int j = 1; j &lt;= m; j++) {\n        // cod in timp constant\n    }\n}\n</code></pre> <p>Dac\u0103 avem de-a face cu diverse repetitive imbricate \u00een diferite blocuri de cod, complexitatea va deveni egal\u0103 cu cea mai costisitoare structur\u0103 de acest gen, complexitatea se va \u00eenmul\u021bi, complexitatea codului de mai jos este \\(O(n \\cdot m)\\), \u00een ciuda buc\u0103\u021bii care are complexitate \\(O(n)\\).</p> <pre><code>for (int i = 1; i &lt;= n; i++) {\n    for (int j = 1; j &lt;= n; j++) {\n        // cod in timp constant\n    }\n}\nfor (int i = 1; i &lt;= m; i++) {\n    // cod in timp constant\n}\n</code></pre>","tags":["notiuni de baza"]},{"location":"usor/complexity/#exemple-de-complexitati-de-timp","title":"Exemple de complexit\u0103\u021bi de timp","text":"<p>Aici prezent\u0103m c\u00e2teva exemple de complexit\u0103\u021bi, care vor fi utile pe parcurs. Nu este nevoie s\u0103 \u0219ti\u021bi algoritmii de aici \u00eenc\u0103, ei vor fi prezenta\u021bi \u0219i \u00eenv\u0103\u021ba\u021bi de-a lungul parcursului vostru \u00een lumea algoritmicii.</p> <ul> <li>Formule matematice care calculeaz\u0103 un r\u0103spuns: \\(O(1)\\)</li> <li>C\u0103utarea binar\u0103: \\(O(\\log n)\\)</li> <li>Folosirea unor structuri de date precum set, map: \\(O(\\log n)\\) per opera\u021bie</li> <li>Aflarea divizorilor unui num\u0103r: \\(O(\\sqrt{n})\\)</li> <li>Citirea sau parcurgerea a \\(n\\) valori: \\(O(n)\\)</li> <li>Sortarea unui vector cu \\(n\\) valori: de obicei \\(O(n \\log n)\\)</li> <li>Parcurgerea tuturor submul\u021bimilor de lungime \\(2\\): \\(O(n^2)\\).</li> <li>Parcurgerea tuturor submul\u021bimilor: \\(O(2^n)\\)</li> <li>Parcurgerea tuturor permut\u0103rilor: \\(O(n!)\\)</li> </ul>","tags":["notiuni de baza"]},{"location":"usor/complexity/#complexitatea-de-memorie","title":"Complexitatea de memorie","text":"<p>\u00cen cazul complexit\u0103\u021bii de memorie, trebuie s\u0103 avem \u00een vedere \u0219i tipul de date folosit.</p> <p>Dintre cele mai frecvente tipuri de date, putem enumera urm\u0103toarele:</p> <ul> <li>tipul int: \\(4\\) bytes, limite intre \\(-2^{31}\\) si \\(2^{31} - 1\\) (\\(-2147483648\\) si \\(2147483647\\)).</li> <li>tipul short: \\(2\\) bytes, limite intre \\(-2^{15}\\) si \\(2^{15} - 1\\) (\\(-32768\\) si \\(32767\\)).</li> <li>tipul char: \\(1\\) byte, limite intre \\(-128\\) si \\(127\\)</li> <li>tipul bool: \\(1\\) byte, accepta doar \\(0\\) sau \\(1\\).</li> <li>tipul long long: \\(8\\) bytes, limite intre \\(-2^{63}\\) si \\(2^{63} - 1\\) (\\(-9223372036854775808\\) si \\(9223372036854775807\\)) - numere de maxim \\(19\\) cifre.</li> </ul> <p>De exemplu, dac\u0103 avem un vector de \\(10^6\\) elemente de tipul int \u0219i altul de \\(10^5\\) elemente de tipul long long, vom folosi \\(4 * 10^6 + 8 * 10^5 = 4.8*10^6\\) bytes = \\(4.8\\) MB. </p> <p>Este foarte important \u00een cazul complexit\u0103\u021bilor de memorie s\u0103 ave\u021bi \u00een vedere faptul c\u0103 \u00een general la concursuri, se ia \u00een considerare memoria a\u0219a cum e declarat\u0103 la \u00eenceput, \u0219i nu ce folose\u0219ti pe parcurs. Astfel, este foarte important pe c\u00e2t posibil s\u0103 nu declara\u021bi mai mult\u0103 memorie dec\u00e2t folosi\u021bi \u0219i s\u0103 ave\u021bi grij\u0103 la c\u00e2t\u0103 memorie aloca\u021bi, pentru a evita \u0219i situa\u021bia \u00een care aloca\u021bi mai pu\u021bin dec\u00e2t trebuie.</p> <p>Pe scurt, e important s\u0103 citi\u021bi cu aten\u021bie restric\u021biile din enun\u021burile problemelor. </p>","tags":["notiuni de baza"]},{"location":"usor/complexity/#complexitati-acceptabile-pentru-diverse-restrictii","title":"Complexit\u0103\u021bi acceptabile pentru diverse restric\u021bii","text":"<p>Acestea sunt aproxim\u0103ri pentru diverse clase de complexit\u0103\u021bi, trebuie s\u0103 ave\u021bi \u00een vedere limita de timp \u0219i sfaturile date anterior, \u00eempreun\u0103 cu particularit\u0103\u021bile problemei.</p> \\(n\\) Complexit\u0103\u021bi posibile \\(n \\leq 10\\) \\(O(n!)\\), \\(O(n^7)\\), \\(O(n^6)\\) \\(n \\leq 20\\) \\(O(2^n \\cdot n)\\), \\(O(n^5)\\) \\(n \\leq 100\\) \\(O(n^4)\\) \\(n \\leq 500\\) \\(O(n^3)\\) \\(n \\leq 10000\\) \\(O(n^2)\\) \\(n \\leq 10^5\\) \\(O(n \\sqrt n)\\) \\(n \\leq 5 \\cdot 10^5\\) \\(O(n \\log n)\\) \\(n \\leq 10^7\\) \\(O(n)\\) \\(n \\leq 10^{18}\\) \\(O(\\log^2 n)\\), \\(O(\\log n)\\), \\(O(1)\\)","tags":["notiuni de baza"]},{"location":"usor/complexity/#concluzii","title":"Concluzii","text":"<p>Complexit\u0103\u021bile reprezint\u0103 o parte fundamental\u0103 din rezolvarea fiec\u0103rei probleme \u0219i \u00een\u021belegerea principiilor din spatele modului \u00een care se calculeaz\u0103 este necesar\u0103 pentru oricine dore\u0219te s\u0103 aprofundeze studiul algoritmicii. Aceste informa\u021bii prezentate aici vor fi esen\u021biale pentru rezolvarea tuturor problemelor de algoritmic\u0103.</p>","tags":["notiuni de baza"]},{"location":"usor/complexity/#lectura-suplimentara","title":"Lectur\u0103 suplimentar\u0103","text":"<ul> <li>Complexitati - USACO Guide</li> <li>Time complexity - Wikipedia</li> <li>A Time Complexity Guide - Codeforces</li> <li>How to determine the solution of a problem by looking at its constraints? - Codeforces</li> </ul>","tags":["notiuni de baza"]},{"location":"usor/digits-manipulation/","title":"Prelucrarea cifrelor unui num\u0103r","text":"<p>Autor: \u0218tefan-Cosmin D\u0103sc\u0103lescu</p>"},{"location":"usor/digits-manipulation/#cunostinte-necesare","title":"Cuno\u0219tinte necesare","text":"<p>\u00cenaintea citirii acestui articol, se recomand\u0103 familiarizarea cu structurile repetitive, deoarece le vom folosi pentru ilustrarea diverselor exemple ce \u021bin de cifrele numerelor, \u00een special c\u00e2nd vine vorba de aplica\u021biile mai avansate.</p>"},{"location":"usor/digits-manipulation/#numerele-de-cel-mult-trei-cifre","title":"Numerele de cel mult trei cifre","text":"<p>Pentru a introduce conceptul, vom pleca de la cazurile cele mai simple, \u0219i anume numerele cu cel mult trei cifre. Ele apar \u00een multe probleme, iar de\u0219i metodele pe care le vom explica aici le putem folosi \u0219i pentru numere cu mai multe cifre, nu este practic s\u0103 le folosim deoarece putem folosi structurile repetitive \u00eentr-un mod mai simplu \u0219i eficient. </p> <p>Dac\u0103 vrem s\u0103 afl\u0103m cifrele unui num\u0103r cu cel mult \\(3\\) cifre, putem s\u0103 ne folosim de diverse rela\u021bii matematice pentru a le afla, \u00eencep\u00e2nd de la ultima la prima. </p> <p>Ultima cifr\u0103</p> <p>Definim ultima cifr\u0103 a unui num\u0103r natural \\(x\\) ca fiind cea mai nesemnificativ\u0103 cifr\u0103 a acestuia. De exemplu, dac\u0103 \\(x = 491\\), ultima cifr\u0103 a acestui num\u0103r este \\(1\\).</p> <p>Pentru a afla aceast\u0103 cifr\u0103, ne vom folosi de proprietatea c\u0103 aceasta este egal\u0103 cu restul \u00eemp\u0103r\u021birii num\u0103rului la \\(10\\), ceea ce ne va da rezultatul dorit. </p> <p>Pentru a afla urm\u0103toarele cifre, avem mai multe variante. Fie \u00eemp\u0103r\u021bim num\u0103rul la \\(10\\) \u0219i afl\u0103m de fiecare dat\u0103 noua cifr\u0103 a unit\u0103\u021bilor la fel ca la pasul precedent, fie vom folosi o formul\u0103 modificat\u0103 pe care o vom prezenta aici:</p> <p>A \\(k\\)-a cifr\u0103 de la coad\u0103</p> <p>Pentru a afla cea de-a \\(k\\)-a cifr\u0103 de la coad\u0103 a unui num\u0103r natural \\(x\\), vom folosi formula  $$ \\frac{x}{10^{k-1}} \\% \\ 10 $$ sau cum am scrie \u00een limbajul C/C++, <code>(x/p) % 10</code>.</p> <p>Observa\u021bie</p> <p>\u00cen formula anterioar\u0103, \\(p\\) este egal cu \\(10^{k-1}\\). De\u0219i se poate folosi formula <code>pow(10, k-1)</code> din <code>#include &lt;cmath&gt;</code>, nu recomand\u0103m folosirea acestei instruc\u021biuni din cauza erorilor de precizie ce apar \u00een cazul numerelor mai mari. Recomand\u0103m calcularea expresiei \\(10^x\\) folosind o instruc\u021biune repetitiv\u0103 de tip for.</p> <p>Mai jos pute\u021bi vedea o secven\u021b\u0103 de cod \u00een care prezent\u0103m ambele metode, care func\u021bioneaz\u0103 pentru numerele de cel mult trei cifre. </p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main () {\n    int n; // numar natural cel mult egal cu 999\n    cin &gt;&gt; n;\n\n    // cifrele luate una dupa alta, fara impartiri \n\n    int ultima = n%10;\n    int penultima = (n/10)%10;\n    int antepenultima = (n/100)%10;\n\n    cout &lt;&lt; antepenultima &lt;&lt; \" \" &lt;&lt; penultima &lt;&lt; \" \" &lt;&lt; ultima &lt;&lt; '\\n';\n\n    // cifrele luate una dupa alta, cu impartiri \n\n    ultima = n%10; \n    n = n / 10;\n    penultima = n%10;\n    n = n / 10;\n    antepenultima = n%10;\n    n = n / 10;\n\n    cout &lt;&lt; antepenultima &lt;&lt; \" \" &lt;&lt; penultima &lt;&lt; \" \" &lt;&lt; ultima &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>"},{"location":"usor/digits-manipulation/#numerele-de-lungime-oarecare","title":"Numerele de lungime oarecare","text":"<p>Acum c\u0103 am \u00eenv\u0103\u021bat cum s\u0103 afl\u0103m cifrele unui num\u0103r, vom generaliza modul de aflare a cifrelor unui num\u0103r \u00een general.</p> <p>Deoarece nu putem depinde la nesf\u00e2r\u0219it de metodele de mai sus din lipsa de practicabilitate ale acestora, trebuie s\u0103 ne g\u00e2ndim la o metod\u0103 ce folose\u0219te o structur\u0103 repetitiv\u0103 pentru a afla cifrele unui num\u0103r \\(n\\). </p> <p>De obicei, deoarece nu \u0219tim c\u00e2te cifre va avea \\(n\\), vom folosi instruc\u021biunea <code>while</code> deoarece aceasta ne d\u0103 flexibilitatea s\u0103 ne oprim atunci c\u00e2nd num\u0103rul nostru nu mai are cifre. </p> <p>Observa\u021bie</p> <p>\u00cen multe probleme, se poate \u00eent\u00e2mpla ca \\(n\\) s\u0103 fie egal cu \\(0\\) \u00eenc\u0103 de la \u00eenceput. \u00cen codurile cu <code>while</code>, vom pune de regul\u0103 un <code>if</code> adi\u021bional care se ocup\u0103 de acest caz particular. O alternativ\u0103 este folosirea instruc\u021biunii <code>do-while</code></p> <p>Un cod tipic pentru aflarea cifrelor unui num\u0103r de la ultima la prima va ar\u0103ta a\u0219a:</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main () {\n    int n; \n    cin &gt;&gt; n;\n\n    if (n == 0) {\n        // caz particular daca n = 0\n    }\n\n    while (n &gt; 0) {\n        int c = n%10;\n        n = n / 10;\n    }\n    return 0;\n}\n</code></pre> <p>De regul\u0103, opera\u021biile ce \u021bin de cifrele g\u0103site se vor efectua \u00een while, indiferent c\u0103 e vorba de g\u0103sirea unor valori auxiliare, num\u0103rarea cifrelor care respect\u0103 o anumit\u0103 proprietate sau calcularea unor sume, maxime etc. </p>"},{"location":"usor/digits-manipulation/#problema-suma-cifrelor-unui-numar","title":"Problema Suma cifrelor unui num\u0103r:","text":"<p>Pentru a afla suma cifrelor unui num\u0103r, vom folosi algoritmul prezentat anterior \u0219i vom aduna la r\u0103spuns valoarea cifrei curente.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main () {\n    int n; \n    cin &gt;&gt; n;\n\n    int s = 0;\n    while (n &gt; 0) {\n        s = s + n % 10;\n        n = n / 10;\n    }\n\n    cout &lt;&lt; s;\n    return 0;\n}\n</code></pre>"},{"location":"usor/digits-manipulation/#problema-control","title":"Problema Control","text":"<p>Cifra de control este un concept ce se reg\u0103se\u0219te frecvent \u00een problemele de algoritmic\u0103 rom\u00e2ne\u0219ti, mai ales la problemele din examene sau problemele mai u\u0219oare de olimpiad\u0103. </p> <p>Cifra de control</p> <p>Cifra de control a unui num\u0103r \\(x\\) reprezint\u0103 valoarea pe care o ob\u021binem dac\u0103 at\u00e2ta timp c\u00e2t \\(x &gt; 9\\), adun\u0103m cifrele din care este compus \\(x\\), iar \\(x\\) va deveni egal cu suma rezultat\u0103. \u00centr-un final, num\u0103rul de o cifr\u0103 ob\u021binut este cifra de control a lui \\(x\\).</p> <p>Exemplu</p> <p>De exemplu, s\u0103 analiz\u0103m num\u0103rul \\(1954\\).</p> <ul> <li>\\(x = 1954\\), suma cifrelor este \\(1 + 9 + 5 + 4 = 19\\).</li> <li>\\(x = 19\\), suma cifrelor este \\(1 + 9 = 10\\).</li> <li>\\(x = 10\\), suma cifrelor este \\(1 + 0 = 1\\).</li> <li>\\(x = 1\\), num\u0103rul are o cifr\u0103, deci cifra de control este \\(1\\).</li> </ul> <p>\u00cen mod particular, se poate observa faptul c\u0103 cifra de control este fix rezultatul opera\u021biei \\(x\\%9\\), cu dou\u0103 particularit\u0103\u021bi pe care trebuie s\u0103 le avem \u00een vedere:</p> <ul> <li>Dac\u0103 \\(x = 0\\), cifra de control a lui \\(x\\) este \\(0\\)</li> <li>Dac\u0103 \\(x\\%9 = 0\\), cifra de control a lui \\(x\\) este \\(9\\).</li> </ul> <p>Mai jos pute\u021bi g\u0103si implement\u0103ri folosind at\u00e2t formula simplificat\u0103, c\u00e2t \u0219i simularea r\u0103spunsului.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int n;\n    cin &gt;&gt; n;\n\n    // cat timp n &gt; 9, aflam suma cifrelor si modificam n\n    while (n &gt; 9) {\n        int n2 = n;\n        n = 0;\n        while (n2) {\n            n += n2%10;\n            n2 /= 10;\n        }\n    }\n\n    cout &lt;&lt; n &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int n;\n    cin &gt;&gt; n;\n\n    if (n == 0) {\n        cout &lt;&lt; 0 &lt;&lt; '\\n';\n    }\n    else {\n        if (n % 9 == 0) {\n            cout &lt;&lt; 9 &lt;&lt; '\\n';\n        }\n        else {\n            cout &lt;&lt; n%9 &lt;&lt; '\\n';\n        }\n    }\n\n    return 0;\n}\n</code></pre>"},{"location":"usor/digits-manipulation/#problema-oglinditul-unui-numar","title":"Problema Oglinditul unui num\u0103r:","text":"<p>Oglinditul unui num\u0103r</p> <p>Oglinditul unui num\u0103r \\(n\\) reprezint\u0103 num\u0103rul scris de la dreapta la st\u00e2nga. De exemplu, dac\u0103 \\(x = 491301\\), oglinditul lui \\(x\\) este \\(103194\\). Dac\u0103 num\u0103rul con\u021bine cifre de \\(0\\) la sf\u00e2r\u0219itul num\u0103rului, acestea vor fi ignorate \u00een oglindit. </p> <p>Numere palindrom</p> <p>Dac\u0103 \\(x\\) \u0219i oglinditul lui \\(x\\) sunt egali, atunci putem spune c\u0103 \\(x\\) este un num\u0103r palindrom. De exemplu, \\(33133\\) \u0219i \\(49594\\) sunt numere palindrom. Cu alte cuvinte, un num\u0103r palindrom este un num\u0103r care se scrie la fel de la st\u00e2nga la dreapta \u0219i invers.</p> <p>Pentru a afla oglinditul unui num\u0103r, vom folosi algoritmul prezentat anterior, \u00eempreun\u0103 cu \u021binerea unei variabile care s\u0103 ne \u021bin\u0103 num\u0103rul inversat.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main () {\n    int n; \n    cin &gt;&gt; n;\n\n    int og = 0;\n    while (n &gt; 0) {\n        og = og * 10 + n % 10;\n        n = n / 10;\n    }\n\n    cout &lt;&lt; og;\n    return 0;\n}\n</code></pre>"},{"location":"usor/digits-manipulation/#problema-aparitii2","title":"Problema Aparitii2:","text":"<p>Pentru a afla de c\u00e2te ori apare prima cifr\u0103 a num\u0103rului dat, mai \u00eent\u00e2i va trebui s\u0103 afl\u0103m care este prima cifr\u0103, iar mai apoi, vom parcurge num\u0103rul din nou pentru a num\u0103ra apari\u021biile primei cifre. </p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main () {\n    int n; \n    cin &gt;&gt; n;\n\n    int n2 = n;\n    while (n2 &gt;= 10) {\n        n2 /= 10;\n    }\n\n    int aparitii = 1; // prima cifra, evitam tratarea separata a cazului n = 0\n    while (n &gt;= 10) {\n        if (n % 10 == n2) {\n            aparitii++;\n        }\n        n = n / 10;\n    }\n\n    cout &lt;&lt; aparitii;\n    return 0;\n}\n</code></pre>"},{"location":"usor/digits-manipulation/#probleme-si-lectura-suplimentara","title":"Probleme \u0219i lectur\u0103 suplimentar\u0103","text":"<ul> <li>Parcurgerea cifrelor unui num\u0103r</li> <li>Cifrele unui num\u0103r</li> <li>Probleme cu aflarea cifrelor unui num\u0103r de pe pbinfo</li> </ul>"},{"location":"usor/divisibility/","title":"Divizibilitatea","text":"<p>Autori: \u0218tefan-Cosmin D\u0103sc\u0103lescu, \u0218tefan-Iulian Alecu</p> <p>De-a lungul parcursului vostru \u00een domeniul algoritmicii, precum \u0219i de multe ori \u00een diferite olimpiade \u0219i concursuri de informatic\u0103, va trebui s\u0103 rezolva\u021bi multe probleme care se bazeaz\u0103 pe un fundament matematic, studiul teoriei din spatele divizibilit\u0103\u021bii numerelor naturale precum \u0219i a algoritmilor de aflare a numerelor prime, num\u0103rului de divizori, lucrului eficient cu numerele prime devenind toate foarte importante pentru asimilarea \u00een cel mai bun mod posibil a acestui capitol. Totu\u0219i, acest document reprezint\u0103 doar un punct de plecare \u00een ceea ce prive\u0219te aplica\u021biile teoriei numerelor \u00een algoritmic\u0103, alte concepte fiind discutate \u00een documentele ulterioare. Aceste no\u021biuni se vor g\u0103si foarte des \u00een problemele de informatic\u0103 pentru clasele de gimnaziu \u0219i clasa a IX-a.</p>","tags":["matematica","divizori","numere prime"]},{"location":"usor/divisibility/#notiuni-introductive","title":"No\u021biuni introductive","text":"<p>Defini\u021bie</p> <p>Un num\u0103r \\(x\\) este numit divizor al altui num\u0103r \\(y\\), dac\u0103 \\(y\\) se poate scrie ca produsul dintre \\(x\\) \u0219i un alt num\u0103r \u00eentreg \\(t\\).</p> <p>Observa\u021bie</p> <p>Orice num\u0103r \\(n\\) se \u00eemparte la \\(1\\) \u0219i la el \u00eensu\u0219i.</p> <p>Defini\u021bie</p> <p>Definim un divizor comun al unei perechi de numere \\((a, b)\\) ca fiind un num\u0103r \\(c\\) care este un divizor at\u00e2t al lui \\(a\\), c\u00e2t \u0219i al lui \\(b\\).</p> <p>CMMDC \u0219i CMMMC</p> <p>Definim cel mai mare divizor comun (cmmdc) al unei perechi de numere \\((a, b)\\) ca fiind cel mai mare num\u0103r care este un divizor at\u00e2t al lui \\(a\\), c\u00e2t \u0219i al lui \\(b\\). Vom nota \\(x = (a, b)\\). Definim cel mai mic multiplu comun (cmmmc) al unei perechi de numere \\([a, b]\\) ca fiind cel mai mic num\u0103r care este un multiplu at\u00e2t al lui \\(a\\), c\u00e2t \u0219i al lui \\(b\\). Vom nota \\(x = [a, b]\\).</p> <p>Observa\u021bie</p> <p>\\(a \\cdot b = (a, b) \\cdot [a, b]\\). Drept concluzie, \\((a, b) = \\frac{a \\cdot b}{[a, b]}\\). </p> <p>Pentru aflarea celui mai mare divizor comun a dou\u0103 numere, exist\u0103 doi algoritmi principali. Primul dintre ei se bazeaz\u0103 pe sc\u0103deri repetate, la fiecare pas sc\u0103z\u00e2ndu-se din num\u0103rul mai mare, num\u0103rul mai mic p\u00e2n\u0103 c\u00e2nd cele dou\u0103 valori devin egale. De\u0219i pentru multe perechi de numere acest algoritm este destul de eficient, atunci c\u00e2nd diferen\u021ba dintre numere este foarte mare, algoritmul va rula \u00een timp cvasi-liniar (de exemplu, pentru numerele \\(3\\) \u0219i \\(10^9\\), un calculator are nevoie de c\u00e2teva secunde s\u0103 afle cmmdc-ul folosind acest algoritm).</p> <p>De aceea vom folosi algoritmul lui Euclid prin \u00eemp\u0103r\u021biri repetate pentru a ajunge la r\u0103spuns. Acest algoritm pleac\u0103 de la ideea c\u0103 o sl\u0103biciune major\u0103 a algoritmului prin sc\u0103deri este dat\u0103 de situa\u021bia c\u00e2nd raportul dintre num\u0103rul mai mare \u0219i cel mai mic este foarte mare, c\u00e2nd practic efectu\u0103m aceea\u0219i opera\u021bie de foarte multe ori. De aceea, \u00een loc de sc\u0103deri, la fiecare pas vom afla restul \u00eemp\u0103r\u021birii num\u0103rului mai mare la cel mai mic, \u00eenlocuind posibilele opera\u021bii de sc\u0103dere cu o singur\u0103 \u00eemp\u0103r\u021bire, algoritmul devenind mult mai eficient. </p> <p>Exemplu</p> <p>De exemplu, s\u0103 analiz\u0103m numerele \\(40\\) \u0219i \\(18\\).</p> <ul> <li>\\(a = 40, b = 18\\). \\(a \\% b = 4\\), noile valori fiind \\(a = 18, b = 4\\);</li> <li>\\(a = 18, b = 4\\). \\(a \\% b = 2\\), noile valori fiind \\(a = 4, b = 2\\);</li> <li>\\(a = 4, b = 2\\). \\(a \\% b = 0\\), noile valori fiind \\(a = 2, b = 0\\);</li> <li>\\(a = 2, b = 0\\). Deoarece \\(b = 0\\), continuarea algoritmului ne-ar duce la \u00eemp\u0103r\u021biri la \\(0\\), opera\u021bie ce nu este valid\u0103.</li> </ul> <p>Mai jos pute\u021bi g\u0103si implementarea \u00een C++ a cmmdc-ului \u0219i a cmmmc-ului, program ce afl\u0103 cmmdc \u0219i cmmmc pentru \\(t\\) perechi de numere. Complexitatea algoritmului este \\(O(\\log n)\\) pentru fiecare test.</p> <pre><code>!!! note \"Observa\u021bie\"\n    Pentru calcularea CMMMC-ului, trebuie avut grij\u0103 s\u0103 \u00eemp\u0103r\u021bim mai \u00eent\u00e2i a la $cmmdc(a, b)$ \u0219i apoi s\u0103 \u00eenmul\u021bim cu $b$, pentru a evita un poten\u021bial overflow.\n</code></pre> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nconstexpr auto cmmdc(int a, int b) {\n    while (b &gt; 0) {\n        int c = a % b;\n        a = b;\n        b = c;\n    }\n    return a;\n}\n\nconstexpr auto cmmmc(int a, int b) { \n    return 1LL * a / cmmdc(a, b) * b; \n}\n\nint main() {\n    int t;\n    cin &gt;&gt; t;\n\n    while (t--) {\n        int a, b;\n        cin &gt;&gt; a &gt;&gt; b;\n\n        auto gcd = cmmdc(a, b);\n        auto lcm = cmmmc(a, b);\n        cout &lt;&lt; gcd &lt;&lt; \" \" &lt;&lt; lcm &lt;&lt; '\\n';\n    }\n    return 0;\n}\n</code></pre> <p>Not\u0103</p> <p>C++17 ofer\u0103 <code>std::gcd()</code> \u0219i <code>std::lcm()</code> \u00een <code>&lt;numeric&gt;</code>, deci nu este nevoie s\u0103 reimplementa\u021bi algoritmul dac\u0103 ave\u021bi acces la un asemenea compilator. </p>","tags":["matematica","divizori","numere prime"]},{"location":"usor/divisibility/#lucrul-cu-divizorii-unui-numar","title":"Lucrul cu divizorii unui num\u0103r","text":"<p>Numere prime \u0219i compuse</p> <p>Un num\u0103r \\(n \\geq 2\\) este num\u0103r prim dac\u0103 \u0219i numai dac\u0103 are doar \\(2\\) divizori: \\(1\\) \u0219i \\(n\\), \u00een caz contrar fiind num\u0103r compus.</p> <p>Observa\u021bii</p> <ol> <li>\\(0\\) \u0219i \\(1\\) nu sunt nici numere prime, nici numere compuse.</li> <li>\\(2\\) este singurul num\u0103r prim par, celelalte numere prime fiind impare.</li> </ol> <p>Descompunerea \u00een factori primi se bazeaz\u0103 pe Teorema fundamental\u0103 a aritmeticii, dat\u0103 mai jos:</p> <p>Teorema fundamental\u0103 a aritmeticii</p> <p>Orice num\u0103r natural \\(n &gt; 1\\) se poate scrie \u00een mod unic sub forma  $$ n = \\prod_{i = 1}^k p_i^{e_i} $$ unde \\(p_1 &lt; p_2 &lt; \\dots &lt; p_k\\) sunt numere prime, iar \\(e_i \\in \\mathbb{N}^\\ast~\\forall 1 \\leq i \\leq k\\).</p> <p>Observa\u021bie</p> <p>Se poate observa c\u0103 num\u0103rul maxim de numere prime la care se \u00eemparte un num\u0103r \\(n\\) este foarte mic. De exemplu, pentru \\(n \\leq 10^{9}\\), sunt cel mult \\(9\\) numere prime \u00een reprezentarea ca produs de factori primi.</p> <p>Pentru a afla divizorii unui num\u0103r natural \\(n\\), cel mai simplu (dar \u0219i ineficient) algoritm const\u0103 \u00een a verifica pe r\u00e2nd fiecare num\u0103r \\(1\\) la \\(n\\) \u0219i s\u0103 verific\u0103m dac\u0103 \\(n\\) se \u00eemparte exact la acel num\u0103r. Pentru a optimiza acest algoritm, va trebui s\u0103 folosim o alt\u0103 observa\u021bie important\u0103.</p> <p>Observa\u021bie</p> <p>Dac\u0103 \\(n\\) se \u00eemparte exact la \\(x\\), se va \u00eemp\u0103r\u021bi exact \u0219i la \\(\\frac{n}{x}\\). A\u0219adar, \\(x^2 \\leq n\\) sau \\(x \\leq \\sqrt{n}\\). Asta ne duce la ideea s\u0103 verific\u0103m doar divizorii p\u00e2n\u0103 la \\(\\sqrt{n}\\), observa\u021bie ce se va dovedi fundamental\u0103 \u00een calculele \u0219i algoritmii pe care \u00ee\u00ee vom scrie pentru toate aceste probleme.</p> <p>Astfel, vom putea afla orice informa\u021bie legat\u0103 de divizorii unui num\u0103r \u00een \\(O(\\sqrt{n})\\), fie c\u0103 e vorba de num\u0103rul de divizori, divizorii primi, descompunerea \u00een factori primi \u0219i a\u0219a mai departe.</p> <p>Totu\u0219i, putem verifica cu u\u0219urin\u021b\u0103 pentru un num\u0103r \\(n\\) dac\u0103 \\(d\\) este divizor al acestuia, folosind o simpl\u0103 condi\u021bie aritmetic\u0103</p> <pre><code>if (n % d == 0) {\n    cout &lt;&lt; d &lt;&lt; \" este divizor al lui \" &lt;&lt; n &lt;&lt; '\\n';\n}\n</code></pre>","tags":["matematica","divizori","numere prime"]},{"location":"usor/divisibility/#problema-divizibilitate-de-pe-kilonova","title":"Problema divizibilitate de pe Kilonova","text":"<p>Cerin\u021b\u0103</p> <p>Se d\u0103 un num\u0103r \\(t\\) \u0219i \\(t\\) numere naturale. S\u0103 se afle pentru fiecare dintre ele r\u0103spunsul la una din urm\u0103toarele \u00eentreb\u0103ri:</p> <ul> <li> <p>\\(1 \\ n\\): S\u0103 se afle dac\u0103 \\(n\\) este prim sau nu. \u00cen caz afirmativ se va afi\u0219a <code>YES</code>, altfel se va afi\u0219a <code>NO</code>.</p> </li> <li> <p>\\(2 \\ n\\): S\u0103 se afle c\u00e2\u021bi divizori are \\(n\\) \u2014 de exemplu, dac\u0103 \\(n = 12\\), se va afi\u0219a \\(6\\) (\\(1\\), \\(2\\), \\(3\\), \\(4\\), \\(6\\), \\(12\\) sunt divizorii lui \\(12\\)).</p> </li> <li> <p>\\(3 \\ n\\): S\u0103 se afle num\u0103rul divizorilor primi ai lui \\(n\\) \u2014 de exemplu, dac\u0103 \\(n = 21\\), se va afi\u0219a \\(2\\).</p> </li> <li> <p>\\(4 \\ n\\): S\u0103 se afi\u0219eze descompunerea \u00een factori primi pe care o are un num\u0103r, fiecare factor fiind scris pe o linie, \u00een ordine cresc\u0103toare a numerelor prime \u2014 de exemplu, dac\u0103 \\(n = 60\\), se vor afi\u0219a pe \\(3\\) linii separate:</p> </li> </ul> <pre><code>2 2\n3 1\n5 1\n</code></pre> <p>Fiecare tip de \u00eentrebare a fost implementat folosind o func\u021bie separat\u0103 pentru a ar\u0103ta diferen\u021bele ce pot ap\u0103rea de la un tip de \u00eentrebare la alta.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nconstexpr bool isPrime(int n) {\n    // n == 0 || n == 1\n    if (n &lt;= 1) {\n        return false;\n    }\n\n    // n == 2 || n == 3\n    if (n &lt;= 3) {\n        return true;\n    }\n\n    if (n % 2 == 0 || n % 3 == 0) {\n        return false;\n    }\n\n    // Iter\u0103m prin to\u021bi divizorii primi, care-s de forma 6k \u00b1 1\n    for (int d = 5; d * d &lt;= n; d += 6) {\n        if (n % d == 0 || n % (d + 2) == 0) {\n            return false;\n        }\n    }\n\n    return true;\n}\n\nconstexpr int countDivisors(int n) {\n    int count = 0;\n\n    for (int div = 1; div * div &lt;= n; ++div) {\n        if (n % div == 0) {\n            // Dac\u0103 div = n/div, atunci \u00eenseamn\u0103 c\u0103 avem un singur \n            // divizor distinct.\n            count += (div == n / div) ? 1 : 2;\n        }\n    }\n    return count;\n}\n\nconstexpr int countPrimeDivisors(int n) {\n    int count = 0;\n\n    for (int div = 2; div * div &lt;= n; ++div) {\n        if (n % div == 0) {\n            count++;\n\n            // Elimin\u0103m to\u021bi multiplii de i, deoarece am contorizat \n            // deja divizorul.\n            while (n % div == 0) {\n                n /= div;\n            }\n        }\n    }\n\n    if (n &gt; 1) {\n        count++;\n    }\n\n    return count;\n}\n\nvoid printPrimeDivisors(int n) {\n    for (int div = 2; div * div &lt;= n; ++div) {\n        if (n % div == 0) {\n            int cnt = 0;\n\n            // Dac\u0103 am g\u0103sit un divizor, calcul\u0103m exponentul s\u0103u.\n            while (n % div == 0) {\n                cnt++;\n                n /= div;\n            }\n\n            cout &lt;&lt; div &lt;&lt; \" \" &lt;&lt; cnt &lt;&lt; '\\n';\n        }\n    }\n\n    if (n &gt; 1) {\n        cout &lt;&lt; n &lt;&lt; \" 1\\n\";\n    }\n}\n\nvoid solveQuery(int type, int n) {\n    switch (type) {\n        case 1:\n            cout &lt;&lt; (isPrime(n) ? \"YES\" : \"NO\") &lt;&lt; '\\n';\n            break;\n        case 2:\n            cout &lt;&lt; countDivisors(n) &lt;&lt; '\\n';\n            break;\n        case 3:\n            cout &lt;&lt; countPrimeDivisors(n) &lt;&lt; '\\n';\n            break;\n        case 4:\n            printPrimeDivisors(n);\n            break;\n        default:\n            break;\n    }\n}\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(nullptr);\n\n    int t;\n    cin &gt;&gt; t;\n\n    while (t--) {\n        int type, number;\n        cin &gt;&gt; type &gt;&gt; number;\n\n        solveQuery(type, number);\n    }\n\n    return 0;\n}\n</code></pre>","tags":["matematica","divizori","numere prime"]},{"location":"usor/divisibility/#probleme-suplimentare","title":"Probleme suplimentare","text":"<ul> <li>CSES Counting Divisors</li> <li>pbinfo difimin</li> <li>pbinfo zerouri</li> <li>CSES Trailing Zeroes</li> <li>Pbinfo divizori3</li> <li>pbinfo zerouri1</li> <li>Problemele cu divizibilitate de pe Pbinfo</li> <li>Infoarena divmul</li> <li>ONI 2006 Suma</li> <li>OJI 2003 Tort</li> <li>OLI 2024 Suceava Perechi</li> <li>OJI 2024 bomboane</li> <li>ONI 2019 copii</li> <li>Probleme cu divizibilitate de pe kilonova</li> </ul>","tags":["matematica","divizori","numere prime"]},{"location":"usor/divisibility/#lectura-suplimentara","title":"Lectur\u0103 suplimentar\u0103","text":"<ul> <li>CMMDC - CPPI Sync</li> <li>Obtinerea divizorilor unui numar - CPPI Sync</li> <li>Articolele despre divizibilitate de pe Pbinfo</li> <li>Number theory  \u2014  Storing information about multiples/divisors</li> <li>Articol de pe USACO Guide</li> <li>Counting Divisors of a Number in \\(N^\\frac{1}{3}\\)</li> </ul>","tags":["matematica","divizori","numere prime"]},{"location":"usor/graphs/","title":"Introducere \u00een teoria grafurilor","text":"<p>Autori: \u0218tefan-Cosmin D\u0103sc\u0103lescu, \u0218tefan-Iulian Alecu</p> <p>\u00cen cele ce urmeaz\u0103 vom prezenta o structur\u0103 de date cu foarte multe aplica\u021bii at\u00e2t \u00een algoritmic\u0103, c\u00e2t \u0219i \u00een via\u021ba de zi cu zi, acestea fiind grafurile. Problema afl\u0103rii existen\u021bei unor conexiuni sau afl\u0103rii distan\u021bei minime \u00eentre dou\u0103 noduri reprezint\u0103 un punct de plecare pentru majoritatea algoritmilor pe grafuri, teoria folosit\u0103 \u00een algoritmic\u0103 fiind una vast\u0103 \u0219i plin\u0103 de abord\u0103ri ce se dovedesc a fi esen\u021biale \u00een foarte multe situa\u021bii, at\u00e2t competi\u021bionale, c\u00e2t \u0219i \u00een aplica\u021bii practice.</p>"},{"location":"usor/graphs/#notiuni-introductive","title":"No\u021biuni introductive","text":""},{"location":"usor/graphs/#terminologie","title":"Terminologie","text":"<p>Un graf este o structur\u0103 care corespunde unui grup de obiecte, \u00een care unele perechi de obiecte sunt \u00eentr-un anumit sens \u201elegate\u201d reciproc. Obiectele corespund unor abstrac\u021bii matematice numite \u00eentr-un graf noduri/v\u00e2rfuri (numite \u0219i puncte) \u0219i fiecare leg\u0103tur\u0103 dintre perechile de obiecte asociate se nume\u0219te muchie (numit\u0103 \u0219i arc sau linie, prin care este \u0219i reprezentat\u0103).</p> <p>O defini\u021bie mai riguroas\u0103 ce se va dovedi util\u0103 este prezentat\u0103 aici:</p> <p>No\u021biunea de graf</p> <p>Un graf \\(G = (V, E)\\) este o structur\u0103 matematic\u0103 compus\u0103 din dou\u0103 mul\u021bimi:</p> <ul> <li> <p>\\(V\\) (mul\u021bimea v\u00e2rfurilor sau nodurilor), care reprezint\u0103 obiectele;</p> </li> <li> <p>\\(E \\subseteq V \\times V\\) (mul\u021bimea muchiilor sau arcelor), care   reprezint\u0103 leg\u0103turile \u00eentre perechi de v\u00e2rfuri.</p> </li> </ul> <p>Fiecare element $ v \\in V$ este numit v\u00e2rf (sau nod), iar fiecare element $ e = (u, v) \\in E$ este numit muchie (sau arc). \u00cen mod obi\u0219nuit, grafurile sunt reprezentate grafic printr-un set de puncte (corespunz\u0103toare v\u00e2rfurilor) conectate prin linii sau curbe (corespunz\u0103toare muchiilor).</p> <p>Voi continua prin a defini termeni ce se dovedesc a fi esen\u021biali pentru \u00een\u021belegerea grafurilor.</p> <p>Graf orientat \u0219i neorientat</p> <p>Un graf neorientat \\(G = (V, E)\\) este un graf \u00een care perechile de v\u00e2rfuri \\((u, v) \\in E\\) sunt neordonate. Aceasta \u00eenseamn\u0103 c\u0103, dac\u0103 \\((u, v) \\in E\\) este o muchie de la \\(u\\) la \\(v\\), atunci \u0219i \\((v, u) \\in E\\).</p> <p>Prin compara\u021bie, un graf orientat este un graf \u00een care perechile de v\u00e2rfuri \\((u, v) \\in E\\) sunt ordonate. Aceasta \u00eenseamn\u0103 c\u0103, dac\u0103 \\((u, v) \\in E\\), atunci \\((v, u) \\not\\in E\\).</p> <p>Noduri adiacente</p> <p>Dou\u0103 noduri \\(u\\) \u0219i \\(v\\) sunt adiacente \u00een graful \\(G = (V, E)\\) dac\u0103 exist\u0103 o muchie $ (u, v) \\in E $. Adic\u0103, exist\u0103 o leg\u0103tur\u0103 direct\u0103 \u00eentre \\(u\\) \u0219i \\(v\\).</p> <p>Formal: $$ u \\text{ \u0219i } v \\text{ sunt adiacente} \\iff (u, v) \\in E \\text{ sau } (v, u) \\in E \\text{ (\u00een cazul grafurilor neorientate)} $$</p> <p>Inciden\u021b\u0103</p> <p>Folosim no\u021biunea de inciden\u021b\u0103 pentru a descrie rela\u021bia dintre noduri \u0219i muchii. O muchie \\((u, v) \\in E\\) este incident\u0103 cu nodurile \\(u\\) \u0219i \\(v\\).</p> <p>Gradul unui nod</p> <p>Definim gradul unui nod \\(v\\) dintr-un graf \\(G = (V, E)\\) ca fiind num\u0103rul de muchii incidente cu \\(v\\).</p> <p>\u00centr-un graf neorientat, gradul nodului \\(v\\), notat \\(\\deg(v)\\), este num\u0103rul de muchii care au \\(v\\) ca una dintre extremit\u0103\u021bi.</p> \\[\\deg(v) = |\\{(u, v) \\in E \\text{ sau } (v, u) \\in E \\mid u \\in V\\}|\\] <p>\u00centr-un graf orientat, se pot defini dou\u0103 tipuri de grad: - Gradul intern (num\u0103rul de muchii care intr\u0103 \u00een nodul \\(v\\)), notat \\(\\deg^-(v)\\):    $$    \\deg^-(v) = |{(u, v) \\in E \\mid u \\in V}|    $$ - Gradul extern (num\u0103rul de muchii care ies din nodul \\(v\\)), notat \\(\\deg^+(v)\\):    $$    \\deg^+(v) = |{(v, u) \\in E \\mid u \\in V}|    $$</p> <p>Observa\u021bie</p> <p>\u00centr-un graf neorientat \\(G = (V, E)\\):</p> \\[ \\sum_{v \\in V} \\deg(v) = 2k,\\,k \\in \\mathbb{N} \\] <p>Explica\u021bia este dat\u0103 de faptul c\u0103 pentru fiecare muchie ad\u0103ugat\u0103, gradul a dou\u0103 noduri cre\u0219te cu \\(1\\).</p> <p>Lan\u021b</p> <p>Numim lan\u021b o secven\u021b\u0103 de noduri \\((v_1, v_2, ..., v_k)\\) cu proprietatea c\u0103 \\((v_i, v_{i + 1}) \\in E\\) oricare ar fi \\(1 \\leq i \\leq k\\). Un lan\u021b este elementar dac\u0103 \\(v_i \\neq v_j\\) oricare ar fi \\(1 \\leq i &lt; j \\leq k\\). Un lan\u021b este simplu dac\u0103 \\((v_i, v_{i + 1}) \\neq (v_j, v_{j+1})\\) oricare ar fi \\(1 \\leq i &lt; j \\leq k\\).</p> <p>Altfel spus, un lan\u021b elementar este un lan\u021b cu nodurile distincte, iar un lan\u021b simplu este un lan\u021b cu muchii distincte.</p> <p>Ciclu</p> <p>O secven\u021b\u0103 de muchii \\((v_1, v_2, ..., v_k, v_1)\\) formeaz\u0103 un ciclu dac\u0103 \\((v_i, v_{i + 1}) \\in E\\) pentru orice \\(1 \\leq i &lt; k\\) \u0219i \\((v_k, v_1) \\in E\\). Un ciclu este simplu dac\u0103 \\(v_i \\neq v_j\\) pentru orice \\(1 \\leq i &lt; j &lt; k\\).</p> <p>Altfel spus, un ciclu reprezint\u0103 o secven\u021b\u0103 de muchii ce nu se repet\u0103, pleac\u0103 de la un nod \\(v_1\\) \u0219i parcurg\u00e2nd \u00een ordine acele muchii, se ajunge tot la nodul \\(v_1\\). Un ciclu simplu este un ciclu \u00een care nu se repet\u0103 noduri.</p> <p>Lungimea unui lan\u021b</p> <p>Lungimea unui lan\u021b \\((v_1, v_2, ..., v_k)\\) este \\(k-1\\) (num\u0103rul de muchii). Uneori, aceasta se define\u0219te ca fiind num\u0103rul de noduri, a\u0219adar lungimea acestui lan\u021b este \\(k\\).</p> <p>Graf par\u021bial \u0219i subgraf</p> <p>Definim graf par\u021bial al unui graf dat ca fiind ceea ce r\u0103m\u00e2ne din graful dat p\u0103str\u00e2nd toate nodurile \u0219i elimin\u00e2nd eventual unele muchii, f\u0103r\u0103 a ad\u0103uga muchii noi.</p> <p>Formal spus, un graf par\u021bial \\(G' = (V, E')\\) a grafului \\(G = (V, E)\\) este un graf unde \\(E' \\subseteq E\\).</p> <p>Definim subgraf al unui graf dat ca fiind ceea ce r\u0103m\u00e2ne din graful dat elimin\u00e2nd unele noduri \u0219i doar muchiile incidente lor, deci nu \u0219i alte muchii \u0219i f\u0103r\u0103 s\u0103 ad\u0103ug\u0103m alte muchii.</p> <p>Formal spus, un subgraf \\(G' = (V', E')\\) al unui graf \\(G = (V, E)\\) este un graf unde \\(V' \\subseteq V\\) \u0219i \\(E' \\subseteq \\{(u, v) \\in E \\mid u, v \\in V'\\}\\).</p> <p>Observa\u021bie</p> <p>Num\u0103rul de subgrafuri ale unui graf \\(G = (V, E)\\) este \\(2^{|V|}\\), iar num\u0103rul de grafuri par\u021biale este \\(2^{|E|}\\), unde \\(|V| = n\\) este num\u0103rul de noduri, iar \\(|E| = m\\) este num\u0103rul de muchii al grafului.</p>"},{"location":"usor/graphs/#cateva-tipuri-speciale-de-grafuri","title":"C\u00e2teva tipuri speciale de grafuri","text":"<p>Se remarc\u0103 faptul c\u0103 \u00een func\u021bie de tipul grafului, mai putem defini urm\u0103toarele tipuri de grafuri, care se vor folosi \u00een diferite aplica\u021bii. De notat ca pentru unele din aceste tipuri, vom avea probleme unde vom explica \u00een detaliu no\u021biunile \u0219i aplica\u021biile unde folosim aceste concepte.</p> <p>Graf complet \\(K_n\\)</p> <p>Definim un graf complet \\(K_n = (V, E)\\) cu \\(|V| = n\\) ca fiind un graf unde \\((v_i, v_j) \\in E\\ \\forall 1 \\leq i &lt; j \\leq n\\). Altfel spus, fiecare nod este conectat cu toate celelalte noduri.</p> <p>Num\u0103rul de muchii ale unui graf complet \\(K_n\\) este \\(|E| = \\frac{n(n-1)}{2}\\).</p> <p>Graf bipartit</p> <p>Definim un graf bipartit \\(G = (A, B, E)\\) ca fiind un graf care poate fi \u00eemp\u0103r\u021bit \u00een dou\u0103 submul\u021bimi \\(V = A \\cup B\\) cu \\(A \\cap B = \\emptyset\\), astfel \u00eenc\u00e2t, dac\u0103 \\(a \\in A\\), atunci acesta se poate conecta doar cu \\(b \\in B\\) \u0219i viceversa.</p> <p>Observa\u021bie</p> <p>Are loc urm\u0103toarea rela\u021bie pentru un graf bipartit \\(G = (A, B, E)\\): $$ \\sum_{a \\in a} \\deg(a) = \\sum_{b \\in B} \\deg(b) = |E| $$</p> <p>Observa\u021bie</p> <p>Un graf este bipartit dac\u0103 \u0219i numai dac\u0103 acesta nu con\u021bine un ciclu de lungime impar\u0103.</p> <p>Graf planar</p> <p>Definim un graf planar ca fiind un graf care are proprietatea c\u0103 poate fi reprezentat grafic f\u0103r\u0103 ca dou\u0103 muchii s\u0103 se intersecteze.</p> <p>Graf regulat</p> <p>Un graf regulat \\(G = (V, E)\\) este un graf \u00een care \\(\\deg(v) = k\\ \\forall v \\in V\\). Adic\u0103, fiecare nod din graf are acela\u0219i num\u0103r de muchii incidente.</p> <p>Un graf regulat cu nodurile de gradul \\(k\\) se nume\u0219te graf \\(k\\)-regulat.</p> <p>Observa\u021bie</p> <p>Condi\u021bia necesar\u0103 \u0219i suficient\u0103 pentru ca un graf \\(k\\)-regulat de ordin \\(n\\) s\u0103 existe este ca \\(n \\geq k + 1\\) \u0219i c\u0103 \\(nk\\) este par.</p> <p>Num\u0103rul de muchii este maxim \u00eentr-un graf complet \\(K_n\\), acesta fiind \\(\\frac{n(n - 1)}{2}\\) cu fiecare nod de gradul \\(n - 1\\). A\u0219adar, \\(k = n - 1\\), sau \\(n = k + 1\\) este \\(n\\) minim pentru un \\(k\\) anume. De asemenea, dup\u0103 rela\u021bia de mai sus, avem \\(\\frac{nk}{2}\\) muchii, deci \\(nk\\) trebuie s\u0103 fie par.</p>"},{"location":"usor/graphs/#lucrul-cu-grafuri-moduri-de-reprezentare-in-memorie","title":"Lucrul cu grafuri. Moduri de reprezentare \u00een memorie","text":"<p>Un concept foarte important \u00een teoria grafurilor reprezint\u0103 modul \u00een care parcurgem aceste structuri de date \u0219i cum putem verifica propriet\u0103\u021bile de care avem nevoie, de la o problem\u0103 la alta.</p> <p>S\u0103 consider\u0103m graful neorientat din figura urm\u0103toare:</p> <p>Acest graf are \\(13\\) noduri \u0219i \\(12\\) muchii, acestea fiind \\((1, 4)\\), \\((1, 3)\\), \\((4, 9)\\), \\((9, 3)\\), \\((4, 2)\\), \\((4, 6)\\), \\((2, 6)\\), \\((2, 5)\\), \\((8, 12)\\), \\((8, 11)\\), \\((8, 10)\\), \\((8, 7)\\).</p> <p>Pentru a reprezenta un graf \u00een memorie, exist\u0103 trei moduri principale de a o face, cu distinc\u021bia c\u0103 \u00een practic\u0103 se va folosi doar reprezentarea prin liste de vecini.</p> <p>Defini\u021bie: Definim matricea de adiacen\u021b\u0103 a unui graf ca fiind o matrice binar\u0103 pentru care \\(a_{ij} = 1\\) dac\u0103 \u0219i numai dac\u0103 avem muchie de la nodul \\(i\\) la nodul \\(j\\) \u0219i \\(a_{ij} = 0\\) \u00een caz contrar.</p> <p>Observa\u021bie: Pentru un graf neorientat, matricea este mereu simetric\u0103, adic\u0103 \\(a_{ij} = a_{ji}\\ \\forall i, j\\).</p> <p>Pentru graful nostru de mai sus, aceasta este matricea de adiacen\u021b\u0103 la care ajungem.</p> <p>List\u0103 de vecini</p> <p>Definim o list\u0103 de vecini ca fiind o list\u0103 (de regul\u0103, alocat\u0103 dinamic) pe care o folosim pentru a \u021bine \u00een memorie pentru fiecare nod doar nodurile adiacente cu acesta, aceast\u0103 metod\u0103 fiind cea mai eficient\u0103 din punct de vedere practic pentru a parcurge grafurile.</p> <p>Exemplu</p> <p>Pentru graful de mai sus, aceasta este lista de vecini:</p> Nod Vecini 1 \\(\\{3,4\\}\\) 2 \\(\\{4,5,6\\}\\) 3 \\(\\{1,9\\}\\) 4 \\(\\{1,2,9\\}\\) 5 \\(\\{2\\}\\) 6 \\(\\{2, 4\\}\\) 7 \\(\\{8\\}\\) 8 \\(\\{7,10,11,12\\}\\) 9 \\(\\{3,4\\}\\) 10 \\(\\{8\\}\\) 11 \\(\\{8\\}\\) 12 \\(\\{8\\}\\) 13 \\(\\emptyset\\) <p>List\u0103 de muchii</p> <p>Definim o list\u0103 de muchii ca fiind o list\u0103 pe care o folosim pentru a \u021bine toate muchiile \u00een memorie. De\u0219i nu este o variant\u0103 prea practic\u0103 de a efectua parcurgerile, aceast\u0103 metod\u0103 poate fi util\u0103 pentru anumi\u021bi algoritmi ce se bazeaz\u0103 \u00een principal pe prelucrarea muchiilor, un astfel de exemplu fiind arborele par\u021bial de cost minim.</p> <p>Exemplu</p> <p>\u00cen cazul nostru, lista de muchii este: \\(\\{1, 4\\}\\),\\(\\{1, 3\\}\\), \\(\\{4,9\\}\\),\\(\\{9,3\\}\\),\\(\\{4,2\\}\\),\\(\\{4,6\\}\\),\\(\\{2,6\\}\\),\\(\\{2,5\\}\\),\\(\\{8,12\\}\\),\\(\\{8,11\\}\\),\\(\\{8,10\\}\\),\\(\\{8,7\\}\\).</p>"},{"location":"usor/graphs/#conexitate-parcurgerea-dfs","title":"Conexitate. Parcurgerea DFS","text":"<p>Problema afl\u0103rii conexit\u0103\u021bii unui graf este una din problemele fundamentale ale teoriei grafurilor, fiind adesea folosit\u0103 drept un exemplu esen\u021bial \u00een explicarea \u0219i \u00een\u021belegerea grafurilor.</p> <p>Graf conex</p> <p>Un graf conex este un graf neorientat \u00een care exist\u0103 o cale \u00eentre oricare dou\u0103 noduri. Cu alte cuvinte, oricare dou\u0103 noduri din graf sunt conectate direct sau indirect printr-o serie de muchii.</p> <p>Componenta conex\u0103</p> <p>O component\u0103 conex\u0103 a unui graf este un subgraf conex maximal, adic\u0103 un subgraf \u00een care oricare dou\u0103 noduri sunt conectate printr-o serie de muchii, iar acest subgraf nu poate fi extins ad\u0103ug\u00e2nd vreun alt nod sau vreo alt\u0103 muchie f\u0103r\u0103 a pierde proprietatea de conexitate.</p> <p>Pentru a rezolva problema afl\u0103rii conexit\u0103\u021bii unui graf, va trebui s\u0103 parcurgem graful folosind unul din algoritmii consacra\u021bi pentru aceast\u0103 problem\u0103. \u00cen cazul de fa\u021b\u0103, vom continua prin a explica parcurgerea \u00een ad\u00e2ncime a grafului (DFS sau depth-first search), una din parcurgerile optime pentru aceast\u0103 problem\u0103.</p> <p>Parcurgerea \u00een ad\u00e2ncime (DFS)</p> <p>Parcurgerea \u00een ad\u00e2ncime (DFS) este un algoritm de explorare a grafului care \u00eencepe de la un nod ales \u0219i viziteaz\u0103 c\u00e2t mai mult posibil din vecinii acestuia \u00eenainte de a se \u00eentoarce \u00eenapoi. Aceasta se realizeaz\u0103 printr-o strategie de backtracking recursiv\u0103 sau prin utilizarea unei stive (stack).</p> <p>DFS \u00eencepe de la un nod \u0219i viziteaz\u0103 toate nodurile pe care le poate atinge \u00een ad\u00e2ncime \u00eenainte de a reveni la nodurile anterioare \u0219i verific\u0103 dac\u0103 un nod a fost deja vizitat pentru a evita bucle infinite.</p> <p>Observa\u021bie</p> <p>Complexitatea parcurgerii \u00een ad\u00e2ncime (DFS) este \\(O(\\lvert V \\rvert + \\lvert E \\lvert)\\), unde \\(\\lvert V \\rvert\\) reprezint\u0103 num\u0103rul de noduri sau v\u00e2rfuri \u0219i \\(\\lvert E \\rvert\\) reprezint\u0103 num\u0103rul de muchii.</p> <p>Observa\u021bie</p> <p>\u00cen probleme se noteaz\u0103 conven\u021bional \\(\\lvert V \\rvert\\) cu \\(N\\) de la noduri, respectiv \\(\\lvert E \\rvert\\) cu \\(M\\) de la muchii. n.red.</p> <p>Observa\u021bie</p> <p>Se remarc\u0103 faptul c\u0103 un nod va fi vizitat la un moment dat doar o singur\u0103 dat\u0103, deci dac\u0103 avem muchiile \\((1, 2)\\), \\((1, 3)\\) \u0219i \\((2, 3)\\), iar DFS-ul pleac\u0103 din \\(1\\), \\(2\\) va fi accesat din \\(1\\), iar \\(3\\) va fi accesat din \\(2\\).</p> <p>Observa\u021bie</p> <p>Se poate remarca faptul c\u0103 ordinea \u00een care vizit\u0103m nodurile \u00een graf depinde de ordinea \u00een care sunt ad\u0103ugate muchiile \u00een graf, acest lucru \u00eenseamn\u0103 c\u0103 nu putem folosi DFS pentru anumite probleme, de exemplu cele la care trebuie aflat\u0103 distan\u021ba minim\u0103 \u00een graf.</p> <p>Ca o recapitulare (sau de fapt compara\u021bie) \u00eentre BFS \u0219i DFS, s\u0103 compar\u0103m fiecare abordare \u00eempreun\u0103 cu o func\u021bie:</p> DFSBFS <pre><code>vector&lt;vector&lt;int&gt;&gt; graph;\n\nvoid dfs(int node, vector&lt;bool&gt;&amp; visited) {\n    visited[node] = true;\n\n    // Ca exemplu\n    cout &lt;&lt; node &lt;&lt; ' '; \n\n    for (int neighbor : graph[node]) {\n        if (!visited[neighbor]) {\n            dfs(neighbor, visited);\n        }\n    }\n}\n</code></pre> <pre><code>vector&lt;vector&lt;int&gt;&gt; graph;\nvector&lt;int&gt; dist; \nqueue&lt;int&gt; q; \n\nvoid bfs(int startNode) {\n    q.push(startNode);\n    dist[startNode] = 0;\n\n    while (!q.empty()) {\n        int node = q.front();\n        q.pop();\n\n        for (auto neighbor : graph[node]) {\n            if (dist[neighbor] == -1) { \n                dist[neighbor] = dist[node] + 1; \n                q.push(neighbor); \n            }\n        }\n    }\n}\n</code></pre>"},{"location":"usor/graphs/#problema-connected-components-de-pe-kilonova","title":"Problema Connected components de pe kilonova","text":"<p>Se d\u0103 un graf neorientat \\(G\\) cu \\(N\\) noduri \u0219i \\(M\\) muchii. S\u0103 se afle c\u00e2te componente conexe are graful dat.</p> <p>Pentru a afla num\u0103rul de componente conexe ale unui graf, putem folosi parcurgerea DFS pentru a afla toate nodurile din care apel\u0103m DFS din func\u021bia <code>main</code>, acesta fiind \u0219i r\u0103spunsul la problema noastr\u0103.</p> <pre><code>#include &lt;iostream&gt;\n#include &lt;vector&gt;\n\nusing namespace std;\n\nvector&lt;vector&lt;int&gt;&gt; adj;\nvector&lt;bool&gt; visited;\n\nvoid dfs(int node) {\n    visited[node] = true;\n\n    for (int next : adj[node]) {\n        if (!visited[next]) {\n            dfs(next);\n        }\n    }\n}\n\nint main() {\n    int n, m;\n    cin &gt;&gt; n &gt;&gt; m;\n\n    adj.resize(n + 1);\n    visited.resize(n + 1, false);\n\n    for (int i = 0; i &lt; m; ++i) {\n        int a, b;\n        cin &gt;&gt; a &gt;&gt; b;\n\n        adj[a].push_back(b);\n        adj[b].push_back(a);\n    }\n\n    int cc = 0;\n    for (int i = 1; i &lt;= n; ++i) {\n        if (!visited[i]) {\n            ++cc;\n            dfs(i);\n        }\n    }\n\n    cout &lt;&lt; cc &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>"},{"location":"usor/graphs/#drumuri-minime-parcurgerea-bfs","title":"Drumuri minime. Parcurgerea BFS","text":"<p>Dac\u0103 \u00een cazul parcurgerii DFS putem s\u0103 o aplic\u0103m f\u0103r\u0103 mari probleme pentru o varietate destul de larg\u0103 de probleme cu grafuri, totu\u0219i nu este suficient\u0103 pentru problemele ce \u021bin de distan\u021be. Un exemplu fundamental este acela al afl\u0103rii drumului minim \u00eentre dou\u0103 sau mai multe noduri \u00eentr-un graf dat.</p> <p>Drum minim</p> <p>Un drum minim este lungimea minim\u0103 a unui lan\u021b care leag\u0103 dou\u0103 noduri din graf.</p> <p>Motivul pentru care nu putem afla drumul minim \u00eentre dou\u0103 noduri folosind DFS este acela c\u0103 ordinea \u00een care nodurile sunt parcurse \u00een DFS depinde de ordinea \u00een care sunt date muchiile de la intrare, parcurgerea recursiv\u0103 f\u0103c\u00e2nd aflarea distan\u021belor minime imposibil\u0103. Astfel, vom introduce un alt mod de a parcurge graful nostru.</p> <p>Parcurgerea \u00een l\u0103\u021bime (BFS)</p> <p>Parcurgerea \u00een l\u0103\u021bime** (BFS, engl. breadth-first search) a unui graf ca fiind o parcurgere iterativ\u0103 ce pleac\u0103 de la unul sau mai multe noduri, iar la fiecare pas, dac\u0103 ne afl\u0103m la un nod \\(x\\), vom vizita vecinii nevizita\u021bi ai nodului \\(x\\), ad\u0103ug\u00e2ndu-i \u00eentr-o coad\u0103, nodurile fiind parcurse \u00een ordinea \u00een care au fost ad\u0103ugate \u00een coad\u0103.</p> <p>Observa\u021bie</p> <p>Complexitatea parcurgerii \u00een l\u0103\u021bime (BFS) este \\(O(\\lvert V \\rvert + \\lvert E \\lvert)\\), unde \\(\\lvert V \\rvert\\) reprezint\u0103 num\u0103rul de noduri sau v\u00e2rfuri \u0219i \\(\\lvert E \\rvert\\) reprezint\u0103 num\u0103rul de muchii.</p> <p>Observa\u021bie</p> <p>Se poate remarca faptul c\u0103 ordinea \u00een care vizit\u0103m nodurile \u00een graf va fi aceea\u0219i cu ordinea cresc\u0103toare a distan\u021bei minime fa\u021b\u0103 de nodul sau nodurile ini\u021biale, datorit\u0103 faptului c\u0103 ele vor fi inserate \u00een coad\u0103 \u00een ordinea \u00een care acestea au fost ad\u0103ugate.</p>"},{"location":"usor/graphs/#problema-simple-shortest-path-de-pe-kilonova","title":"Problema Simple Shortest Path de pe kilonova","text":"<p>Se d\u0103 un graf neorientat \\(G\\) cu \\(N\\) noduri \u0219i \\(M\\) muchii, precum \u0219i un nod \\(S\\). S\u0103 se afle lungimea drumului minim dintre \\(S\\) \u0219i fiecare nod din graf, inclusiv \\(S\\).</p> <p>Pentru a rezolva aceast\u0103 problem\u0103, vom pleca cu un BFS din nodul \\(S\\) \u0219i vom afla pe parcurs, distan\u021bele minime fa\u021b\u0103 de toate celelalte noduri.</p> <pre><code>#include &lt;iostream&gt;\n#include &lt;queue&gt;\n#include &lt;vector&gt;\n\nusing namespace std;\n\nint main() {\n    int n, m, s;\n    cin &gt;&gt; n &gt;&gt; m &gt;&gt; s;\n\n    vector&lt;vector&lt;int&gt;&gt; graf(n);\n    vector&lt;int&gt; ans(n, -1);\n    queue&lt;int&gt; q;\n\n    for (int i = 0; i &lt; m; i++) {\n        int a, b;\n        cin &gt;&gt; a &gt;&gt; b;\n        graf[a].push_back(b);\n        graf[b].push_back(a);\n    }\n\n    ans[s] = 0;\n    q.push(s);\n\n    while (!q.empty()) {\n        int nod = q.front();\n        q.pop();\n\n        for (auto x : graf[nod]) {\n            if (ans[x] == -1) {\n                ans[x] = ans[nod] + 1;\n                q.push(x);\n            }\n        }\n    }\n\n    for (const auto&amp; x : ans) {\n        cout &lt;&lt; x &lt;&lt; \" \";\n    }\n\n    cout &lt;&lt; '\\n';\n\n    return 0;\n}\n</code></pre>"},{"location":"usor/graphs/#problema-grarb-de-pe-infoarena","title":"Problema grarb de pe infoarena","text":"<p>Se d\u0103 un graf \\(G\\) neorientat cu \\(N\\) noduri numerotate de la \\(1\\) la \\(N\\) \u0219i \\(M\\) muchii. Determina\u021bi num\u0103rul minim de muchii care trebuie eliminate \u0219i num\u0103rul minim de muchii care trebuie ad\u0103ugate \u00een graful \\(G\\) astfel \u00eenc\u00e2t acesta sa devina arbore.</p> <p>Aceast\u0103 problem\u0103 se \u00eemparte \u00een dou\u0103 subprobleme relativ u\u0219or de identificat - aflarea componentelor conexe ale grafului (dac\u0103 avem \\(nr\\) componente conexe, va fi nevoie de \\(nr - 1\\) muchii pentru a transforma graful \u00eentr-unul conex), precum \u0219i aflarea num\u0103rului de muchii care trebuie scoase pentru a transforma graful \u00een arbore (la final, trebuie s\u0103 ne r\u0103m\u00e2n\u0103 \\(N-1\\) muchii). Astfel, vom avea nevoie de \\(nr - 1\\) muchii noi \u0219i va trebui s\u0103 scoatem \\(M + nr - 1 - (N - 1)\\) = \\(M + nr - N\\) muchii pentru a avea un arbore.</p> <pre><code>#include &lt;fstream&gt;\n#include &lt;vector&gt;\n\nusing namespace std;\n\n\nvector&lt;vector&lt;int&gt;&gt; adj;\nvector&lt;bool&gt; visited;\n\nvoid dfs(int nod) {\n    visited[nod] = true;\n    for (int next : adj[nod]) {\n        if (!visited[next]) dfs(next);\n    }\n}\n\nint main() {\n    ifstream fin(\"grarb.in\");\n    ofstream fout(\"grarb.out\");\n\n    int n, m, nr = 0;\n\n    fin &gt;&gt; n &gt;&gt; m;\n\n    adj.resize(n);\n    visited.resize(n, false);\n\n    for (int i = 1; i &lt;= m; i++) {\n        int a, b;\n        fin &gt;&gt; a &gt;&gt; b;\n        adj[a].push_back(b);\n        adj[b].push_back(a);\n    }\n\n    for (int i = 0; i &lt; n; i++)\n        if (!visited[i]) {\n            dfs(i);\n            nr++;\n        }\n\n    // Num\u0103rul de muchii ce trebuiesc \u0219terse\n    fout &lt;&lt; m + nr - 1 - (n - 1) &lt;&lt; '\\n';\n    // Num\u0103rul de componente conectate\n    fout &lt;&lt; nr - 1 &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>"},{"location":"usor/graphs/#problema-graf-oji-2006-de-pe-kilonova","title":"Problema Graf (OJI 2006) de pe kilonova","text":"<p>Se d\u0103 un graf neorientat conex cu \\(N\\) noduri \u0219i dou\u0103 noduri \\(X\\) \u0219i \\(Y\\), s\u0103 se afle nodurile ce apar\u021bin tuturor lan\u021burilor optime \u00eentre \\(X\\) \u0219i \\(Y\\).</p> <p>Pentru a rezolva aceast\u0103 problem\u0103, va trebui mai \u00eent\u00e2i s\u0103 afl\u0103m folosind o parcurgere de tip BFS distan\u021bele minime de la \\(X\\) \u0219i \\(Y\\) spre toate celelalte noduri. Apoi, pentru fiecare distan\u021b\u0103 \\(d\\) de la \\(0\\) la \\(\\operatorname{dist}(X, Y)\\), vrem s\u0103 afl\u0103m c\u00e2te noduri se afl\u0103 pe unul din drumurile optime de la \\(X\\) la \\(Y\\) la o distan\u021b\u0103 \\(d\\) fa\u021b\u0103 de \\(X\\). \u00cen cele din urm\u0103, vrem s\u0103 afi\u0219\u0103m nodurile situate la distan\u021bele care apar o singur\u0103 dat\u0103 \u00een mul\u021bimea nodurilor ce fac parte din cel pu\u021bin un drum optim de la \\(X\\) la \\(Y\\).</p> <p>Codul surs\u0103 se poate viziona mai jos.</p> <pre><code>#include &lt;fstream&gt;\n#include &lt;queue&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\nconstexpr int MAXN = 7500;\n\nvector&lt;vector&lt;int&gt;&gt; graph(MAXN + 1);\nvector&lt;int&gt; ans;\n\nvoid bfs(int startNode, vector&lt;int&gt;&amp; dist) {\n    queue&lt;int&gt; q;\n    q.push(startNode);\n    dist[startNode] = 0;\n\n    while (!q.empty()) {\n        int node = q.front();\n        q.pop();\n\n        for (auto neighbor : graph[node]) {\n            if (dist[neighbor] == -1) {\n                dist[neighbor] = dist[node] + 1;\n                q.push(neighbor);\n            }\n        }\n    }\n}\n\nvector&lt;int&gt; distX, distY, solFreq;\n\nint main() {\n    distX.reserve(MAXN + 1);\n    distY.reserve(MAXN + 1);\n    solFreq.reserve(MAXN + 1);\n\n    ifstream fin(\"graf.in\");\n    ofstream fout(\"graf.out\");\n\n    int n, m, x, y;\n    fin &gt;&gt; n &gt;&gt; m &gt;&gt; x &gt;&gt; y;\n\n    while (m--) {\n        int a, b;\n        fin &gt;&gt; a &gt;&gt; b;\n        graph[a].push_back(b);\n        graph[b].push_back(a);\n    }\n\n    distX.resize(n + 1, -1);\n    distY.resize(n + 1, -1);\n    solFreq.resize(n + 1, 0);\n\n    bfs(x, distX);\n    bfs(y, distY);\n\n    int totalDist = distX[y];\n\n    // Lungimea total\u0103 a drumului va fi egal\u0103 cu distX[y].\n    for (int i = 1; i &lt;= n; i++) {\n        if (distX[i] == -1 || distY[i] == -1) {\n            continue;\n        }\n\n        if (distX[i] + distY[i] == totalDist + 1) {\n            solFreq[distX[i]]++;\n        }\n    }\n\n    for (int i = 1; i &lt;= n; i++) {\n        if (distX[i] == -1 || distY[i] == -1) {\n            continue;\n        }\n\n        if (distX[i] + distY[i] == totalDist + 1 &amp;&amp; solFreq[distX[i]] == 1) {\n            ans.push_back(i);\n        }\n    }\n\n    fout &lt;&lt; ans.size() &lt;&lt; '\\n';\n    for (const auto&amp; node : ans) {\n        fout &lt;&lt; node &lt;&lt; ' ';\n    }\n\n    return 0;\n}\n</code></pre>"},{"location":"usor/graphs/#probleme-suplimentare","title":"Probleme suplimentare","text":"<ul> <li>Kilonova unire</li> <li>CSES Message Route</li> <li>CSES Building Teams</li> <li>CSES Round Trip</li> <li>USACO Bronze Milk Factory</li> <li>USACO Bronze The Great Revegetation</li> <li>USACO Silver Closing the Farm</li> <li>USACO Silver Moocast</li> <li>infoarena multiplu</li> <li>ONI 2004 base3</li> <li>Probleme cu grafuri de pe kilonova</li> <li>Probleme cu grafuri de pe codeforces, ordonate dup\u0103 dificultate</li> </ul>"},{"location":"usor/graphs/#lectura-suplimentara","title":"Lectur\u0103 suplimentar\u0103","text":"<ul> <li>Grafuri - no\u021biuni teoretice de baz\u0103</li> <li>Articol introductiv de pe USACO Guide</li> <li>Articol despre parcurgeri de pe USACO Guide</li> </ul>"},{"location":"usor/greedy/","title":"Introducere \u00een Metoda Greedy","text":"<p>Autor: \u0218tefan-Cosmin D\u0103sc\u0103lescu</p> <p>De multe ori atunci c\u00e2nd trebuie s\u0103 rezolv\u0103m probleme algoritmice (\u0219i nu numai), suntem nevoi\u021bi s\u0103 g\u00e2ndim lacom, aleg\u00e2nd cea mai bun\u0103 variant\u0103 la un moment dat. \u00cen algoritmic\u0103, aceast\u0103 abordare este numit\u0103 metoda Greedy \u0219i este una din cele mai importante metode pentru rezolvarea problemelor, fiind \u00eent\u00e2lnit\u0103 at\u00e2t \u00een probleme foarte simple, c\u00e2t \u0219i \u00een unele din cele mai complicate probleme posibile. </p> <p>Chiar dac\u0103 conform manualelor de informatic\u0103 din \u021bara noastr\u0103, metoda Greedy este ceva ce se pred\u0103 abia \u00een clasele mai mari de liceu (mai exact, \u00een clasa a XI-a), o s\u0103 vede\u021bi c\u0103 probleme de acest fel apar \u00eenc\u0103 de la \u00eenceputul studiului algoritmicii.</p> <p>Voi \u00eencepe cu un exemplu de o asemenea problem\u0103, pentru a v\u0103 familiariza cu stilul pe care \u00eel vor avea problemele de acest fel.</p> <p>Exemplu</p> <p>\u0218tefan merge la magazin \u0219i are un buget de \\(L\\) lei. La magazinul unde \u00ee\u0219i face cump\u0103r\u0103turile, se g\u0103sesc \\(n\\) produse alimentare, fiecare dintre ele av\u00e2nd un pre\u021b cunoscut. Deoarece este foarte generos, ast\u0103zi el vrea s\u0103 poat\u0103 oferi c\u00e2te un produs alimentar unui num\u0103r c\u00e2t mai mare de persoane \u00een limita bugetului s\u0103u ini\u021bial. Care este num\u0103rul maxim de produse pe care \u0218tefan \u00eel poate cump\u0103ra?</p> <p>Pentru a rezolva aceast\u0103 problem\u0103, vom vrea s\u0103 alegem cele mai ieftine produse (cele cu pre\u021bul cel mai mic), acest lucru se poate fie afl\u00e2nd la fiecare pas valoarea minim\u0103 din \u0219ir, scaz\u00e2nd-o din buget p\u00e2n\u0103 c\u00e2nd nu mai putem alege obiecte, fie ordon\u00e2nd obiectele cresc\u0103tor dup\u0103 pre\u021b, iar mai apoi sc\u0103z\u00e2nd produsele cu cel mai mic pre\u021b p\u00e2n\u0103 c\u00e2nd nu mai este posibil. </p> <p>O prim\u0103 concluzie pe care o putem trage este aceea c\u0103 \u00een cazul multor probleme ce folosesc aceast\u0103 metod\u0103, vom avea nevoie s\u0103 ordon\u0103m valorile dup\u0103 un anumit criteriu, iar la fiecare pas, vom alege optimul local (fie c\u0103 e vorba de maxim, minim sau alt criteriu pe care \u00eel decidem). </p> <p>\u00cen cele ce urmeaz\u0103, voi prezenta c\u00e2teva probleme mai simple \u0219i cunoscute pentru a prezenta diverse abord\u0103ri.</p>","tags":["sortare","greedy"]},{"location":"usor/greedy/#problema-prodmax1-de-pe-pbinfo","title":"Problema prodmax1 de pe pbinfo","text":"<p>Pentru a avea un produs c\u00e2t mai mare, este logic c\u0103 vrem s\u0103 avem valori c\u00e2t mai mari pe care s\u0103 le \u00eenmul\u021bim. Oare este totu\u0219i suficient s\u0103 ne uit\u0103m doar la cele mai mari dou\u0103 valori?</p> <p>Deoarece \u00eenmul\u021birea a dou\u0103 valori negative duce \u0219i ea la un produs pozitiv, nu este suficient, deci trebuie s\u0103 verific\u0103m \u0219i cele mai mici dou\u0103 valori pentru a acoperi toate cazurile ce pot ap\u0103rea. Mai jos pute\u021bi g\u0103si solu\u021bia problemei. </p> <pre><code>#include &lt;iostream&gt;\n#include &lt;vector&gt;\n#include &lt;algorithm&gt;\n\nusing namespace std;\n\nint main() {\n    int n;\n    cin &gt;&gt; n;\n\n    vector&lt;int&gt; v(n+1);\n    for (int i = 1; i &lt;= n; i++) {\n        cin &gt;&gt; v[i];\n    }\n\n    sort(v.begin() + 1, v.begin() + n + 1);\n    cout &lt;&lt; max(1LL * v[n-1] * v[n], 1LL * v[1] * v[2]) &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["sortare","greedy"]},{"location":"usor/greedy/#problema-movie-festival-problema-spectacolelor-de-pe-cses","title":"Problema Movie Festival - Problema spectacolelor de pe cses","text":"<p>Pentru a afla num\u0103rul maxim de filme pe care le putem urm\u0103ri, trebuie s\u0103 ne g\u00e2ndim la o strategie prin care s\u0103 ordon\u0103m filmele dup\u0103 un anumit criteriu, iar mai apoi s\u0103 alegem filmele conform ordinii alese. </p> <p>Unele din strategiile care ar putea fi folosite pentru aceast\u0103 problem\u0103 sunt ordonarea filmelor dup\u0103 momentul de start, ordonarea dup\u0103 lungimea lor \u0219i ordonarea dup\u0103 momentul de final.</p> <p>Prima strategie este gre\u0219it\u0103 deoarece dac\u0103 avem un film foarte lung la \u00eenceput, ne-ar putea acoperi mai multe filme mai scurte care \u00eencep un pic mai t\u00e2rziu. </p> <p>Strategia de a sorta dup\u0103 lungimea filmelor va da r\u0103spunsuri gre\u0219ite c\u00e2nd avem filme scurte care acoper\u0103 dou\u0103 filme mai lungi care nu se intersecteaz\u0103.</p> <p>\u00cen schimb, ordonarea filmelor dup\u0103 timpul final al acestora este optim\u0103 deoarece vom avea mereu un num\u0103r maxim de oportunit\u0103\u021bi din care alegem. </p> <p>Observa\u021bie</p> <p>Pentru mai multe explica\u021bii \u0219i desene, pute\u021bi accesa articolul de pe usaco.guide care prezint\u0103 aceast\u0103 problem\u0103.</p> <p>Solu\u021bia va consta \u00een sortarea intervalelor dup\u0103 timpul final, iar la fiecare pas vom alege primul film care are un timp ini\u021bial mai mare dec\u00e2t timpul de final precedent.</p> <pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n\nint main() {\n\n    int n;\n    cin &gt;&gt; n;\n\n    vector&lt;pair&lt;int, int&gt; &gt; events(n+1);\n    for (int i = 1; i &lt;= n; ++i) {\n        cin &gt;&gt; events[i].second &gt;&gt; events[i].first;\n    }\n\n    sort(events.begin() + 1, events.begin() + n + 1);\n\n    int ans = 0;\n    int lst = 0;\n    for (int i = 1; i &lt;= n; ++i) {\n        if (events[i].second &gt;= lst) {\n            ++ans, lst = events[i].first;\n        }\n    }\n\n    cout &lt;&lt; ans;\n    return 0;\n}\n</code></pre>","tags":["sortare","greedy"]},{"location":"usor/greedy/#problema-moscraciun2-de-pe-pbinfo","title":"Problema moscraciun2 de pe pbinfo","text":"<p>Pentru a rezolva aceast\u0103 problem\u0103, ne folosim de faptul c\u0103 costurile sunt mici, iar mai apoi parcurgem cadourile \u00een ordine cresc\u0103toare a costurilor, lu\u00e2nd cadourile cu costul cel mai mic, optimiz\u00e2nd la fiecare pas aceast\u0103 parte a r\u0103spunsului, fiind lacomi \u00een privin\u021ba alegerii cadourilor cu pre\u021bul cel mai mic.</p> <pre><code>#include &lt;iostream&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\nint main() {\n    int n, m;\n    cin &gt;&gt; n &gt;&gt; m;\n\n    vector&lt;int&gt; fr(101);\n    for (int i = 1; i &lt;= m; i++) {\n        int pr, cnt;\n        cin &gt;&gt; pr &gt;&gt; cnt;\n        fr[pr] += cnt;\n    }\n\n    int ans = 0;\n    for (int i = 0; i &lt;= 100; i++) {\n        ans += min(n, fr[i]) * i;\n        n -= min(n, fr[i]);\n    }\n\n    if (n &gt; 0) {\n        cout &lt;&lt; \"imposibil\" &lt;&lt; '\\n';\n    }\n    else {\n       cout &lt;&lt; ans &lt;&lt; '\\n';\n    }\n    return 0;\n}\n</code></pre>","tags":["sortare","greedy"]},{"location":"usor/greedy/#concluzii-preliminare","title":"Concluzii preliminare","text":"<p>\u00cen articolul pe care tocmai l-a\u021bi citit, am prezentat c\u00e2teva dintre cele mai cunoscute probleme \u0219i strategii ce folosesc metoda Greedy. Plec\u00e2nd de la aceste exemple care sunt mai simple, am explicat diverse strategii pentru a aborda problemele care folosesc aceast\u0103 metod\u0103. </p> <p>\u00cen articolele viitoare, vom explica principii mai avansate, precum Exchange Argument, Simulated Annealing, precum \u0219i diverse tehnici folosite \u00een algoritmii euristici \u0219i randomiza\u021bi ce folosesc strategii Greedy.</p>","tags":["sortare","greedy"]},{"location":"usor/greedy/#probleme-suplimentare","title":"Probleme suplimentare","text":"<ul> <li>USACO Bronze Watching Mooloo</li> <li>USACO Bronze Cow Tipping</li> <li>pbinfo kmax</li> <li>pbinfo eureni</li> <li>Probleme cu greedy de pe pbinfo</li> <li>USACO Bronze Out of Place</li> <li>Leetcode Minimum Cost to Move Chips to The Same Position</li> <li>OJI 2012 Arme</li> <li>OJI 2024 Santinele</li> <li>ONI 2024 Soldati</li> <li>CSES Tasks and Deadlines</li> <li>USACO Gold High Card Low Card</li> <li>RoAlgo Contest #10 Paranteze</li> <li>USACO Silver Berry Picking</li> <li>Codeforces Ciel and Duel</li> <li>Probleme cu greedy pe Kilonova</li> <li>Probleme cu greedy pe Infoarena</li> </ul>","tags":["sortare","greedy"]},{"location":"usor/greedy/#lectura-suplimentara","title":"Lectur\u0103 suplimentar\u0103","text":"<ul> <li>Metoda greedy - pbinfo</li> <li>Greedy Algorithms - Wikipedia</li> <li>Metoda Greedy si problema fractionara a rucsacului</li> <li>Introduction to Greedy Algorithms - USACO Guide</li> <li>Greedy Algorithms with Sorting - USACO Guide</li> </ul>","tags":["sortare","greedy"]},{"location":"usor/intro-dp/","title":"Introducere \u00een programarea dinamic\u0103","text":"<p>Autori: Teodor-\u0218tefan Manolea, \u0218tefan-Cosmin D\u0103sc\u0103lescu</p>","tags":["programare dinamica","DP"]},{"location":"usor/intro-dp/#introducere","title":"Introducere","text":"<p>Programarea dinamic\u0103 (abrv. DP) este un mod de g\u00e2ndire care poate fi folosit pentru rezolvarea problemelor la care trebuie s\u0103 afl\u0103m fie num\u0103rul de solu\u021bii corecte pentru un anumit set de date, fie solu\u021bia optim\u0103 (minim, maxim, etc.).</p> <p>Pentru a realiza acest lucru, vom descompune problema \u00een mai multe subprobleme, care, luate \u00eempreun\u0103, s\u0103 ne ob\u021bin\u0103 r\u0103spunsul dorit.</p>","tags":["programare dinamica","DP"]},{"location":"usor/intro-dp/#de-ce-trebuie-sa-stim-programare-dinamica","title":"De ce trebuie s\u0103 \u0219tim programare dinamic\u0103?","text":"<p>De\u0219i tipurile de probleme men\u021bionate anterior se pot rezolva \u0219i cu alte tehnici, cum ar fi backtracking, greedy, formul\u0103 matematic\u0103 etc., programarea dinamic\u0103 vine drept o nou\u0103 perspectiv\u0103 asupra problemelor care ne permite s\u0103 g\u0103sim solu\u021bii pentru o mul\u021bime de probleme, p\u0103str\u00e2nd avantajele care ne sunt oferite at\u00e2t de greedy c\u00e2t \u0219i de backtracking, iar \u00een multe cazuri, devenind abordarea cea mai potrivit\u0103, ceea ce face programarea dinamic\u0103 s\u0103 devin\u0103 una dintre cele mai populare tehnici date la concursurile de algoritmic\u0103.</p> <p>Observa\u021bie</p> <p>Aproape \u00een fiecare an la OJI \u0219i ONI clasele XI-XII se d\u0103 o problem\u0103 care necesit\u0103 o solu\u021bie bazat\u0103 pe metoda program\u0103rii dinamice, problemele de acest tip reg\u0103sindu-se \u0219i \u00een foarte multe concursuri mai dificile.</p>","tags":["programare dinamica","DP"]},{"location":"usor/intro-dp/#termenii-specifici-ai-programarii-dinamice","title":"Termenii specifici ai program\u0103rii dinamice","text":"<p>Pentru a explica p\u0103r\u021bile componente ale oric\u0103rei solu\u021bii care se bazeaz\u0103 pe metoda program\u0103rii dinamice, vom explica un exemplu foarte simplu, folosindu-ne de \u0219irul lui Fibonacci. </p> <p>Vom defini \u0219irul lui Fibonacci ca fiind \\(F_0 = 1\\), \\(F_1 = 1\\) \u0219i \\(F_i = F_{i-1} + F_{i-2}\\).</p> <p>Dup\u0103 cum se poate observa, avem \\(F_i\\) care reprezint\u0103 cel de-al \\(i\\)-lea num\u0103r Fibonacci, acesta fiind starea pe care o vom calcula, st\u0103ri pe care le vom g\u0103si \u00een toate problemele ce necesit\u0103 programare dinamic\u0103. St\u0103rile vor avea una sau mai multe dimensiuni. </p> <p>\\(F_i = F_{i-1} + F_{i-2}\\) reprezint\u0103 rela\u021bia de recuren\u021b\u0103 dintre \\(F_i\\) \u0219i valorile precedente. Pasul de la \\(F_{i-1}\\) sau \\(F_{i-2}\\) la \\(F_{i}\\) reprezint\u0103 tranzi\u021biile de la o stare la alta. </p> <p>\u00cen cele din urm\u0103, \\(F_0 = 1\\), \\(F_1 = 1\\) reprezint\u0103 cazurile de baz\u0103, cazuri care nu pot fi definite folosind rela\u021bia de recuren\u021b\u0103 men\u021bionat\u0103 mai sus. </p> <p>\u00cen concluzie, pentru a putea avea o solu\u021bie care folose\u0219te programarea dinamic\u0103, trebuie s\u0103 ne asigur\u0103m c\u0103 avem urm\u0103toarele p\u0103r\u021bi:</p> <ul> <li>Cazuri de baz\u0103</li> <li>Stare pe care o calcul\u0103m</li> <li>Rela\u021bie de recuren\u021b\u0103</li> <li>Tranzitii</li> </ul> <p>Aceste aspecte pot fi \u0219i optimizate \u00een func\u021bie de problem\u0103, aceste optimiz\u0103ri fiind realizabile fie calcul\u00e2nd tranzi\u021biile mai rapid, fie reduc\u00e2nd num\u0103rul de st\u0103ri, a\u0219a cum se va vedea de-a lungul capitolelor ulterioare care abordeaz\u0103 tehnica program\u0103rii dinamice.</p>","tags":["programare dinamica","DP"]},{"location":"usor/intro-dp/#clasificare","title":"Clasificare","text":"<p>\u00cen elaborarea unui algoritm care folose\u0219te metoda program\u0103rii dinamice, putem utiliza mai multe abord\u0103ri.</p>","tags":["programare dinamica","DP"]},{"location":"usor/intro-dp/#tipuri-de-scriere","title":"Tipuri de scriere","text":"<ul> <li> <p>Recursiv</p> </li> <li> <p>Iterativ</p> </li> </ul> Recursiv Iterativ Mai lent Mai rapid Mai u\u0219or de elaborat Mai dificil de elaborat Memoizare Tabulare Top-Down DP Bottom-Up DP","tags":["programare dinamica","DP"]},{"location":"usor/intro-dp/#modalitati-de-abordare","title":"Modalit\u0103\u021bi de abordare","text":"<ol> <li> <p>Top-Down DP:</p> <ul> <li>Aceast\u0103 form\u0103 de DP pleac\u0103 de la starea final\u0103 a problemei, ea utiliz\u00e2nd st\u0103rile anterioare, p\u00e2n\u0103 la starea ini\u021bial\u0103 pe care o cunoa\u0219tem, pentru a-\u0219i construi parametrii ei.</li> <li>De obicei aceast\u0103 form\u0103 de DP este scris\u0103 utiliz\u00e2nd recursivitatea</li> </ul> </li> <li> <p>Bottom-Up DP:</p> <ul> <li>Aceast\u0103 form\u0103 de DP pleac\u0103 de la starea ini\u021bial\u0103 a problemei, ea construind parametrii st\u0103rilor urm\u0103toare care la r\u00e2ndul lor vor face asta p\u00e2n\u0103 ce ajungem la construirea parametrilor st\u0103rii finale.</li> <li>De obicei aceast\u0103 form\u0103 de DP este scris\u0103 utiliz\u00e2nd Complete Search-ul</li> </ul> </li> </ol>","tags":["programare dinamica","DP"]},{"location":"usor/intro-dp/#modalitati-de-tranzitie","title":"Modalit\u0103\u021bi de tranzi\u021bie","text":"<ul> <li>Pull-DP: Informa\u021bia din starea curent\u0103 se formeaz\u0103 baz\u00e2ndu-se pe una sau mai multe st\u0103ri anterioare.</li> <li>Push-DP: Informa\u021bia din starea curent\u0103 se utilizeaz\u0103 pentru calcularea unei st\u0103rii viitoare.</li> </ul>","tags":["programare dinamica","DP"]},{"location":"usor/intro-dp/#probleme-clasice","title":"Probleme clasice","text":"<p>Pentru a ne dezvolta intui\u021bia \u00een ceea ce prive\u0219te aceast\u0103 tehnic\u0103, este necesar s\u0103 \u00een\u021belegem mecanismul pe care se bazeaz\u0103 problemele clasice.</p> <p>Este esen\u021bial s\u0103 rezolv\u0103m c\u00e2t mai multe probleme de DP pentru a deveni fluen\u021bi \u00een elaborarea solu\u021bilor.</p>","tags":["programare dinamica","DP"]},{"location":"usor/intro-dp/#problema-frog-1","title":"Problema Frog 1","text":"<p>Aceast\u0103 problem\u0103 ne cere s\u0103 afl\u0103m costul minim de care are nevoie o broasc\u0103 pentru a ajunge de pe prima piatr\u0103 pe ultima, dac\u0103 se poate deplasa doar pe piatra din fa\u021b\u0103 sau pe piatra cu dou\u0103 pozi\u021bii mai \u00een fa\u021b\u0103.</p> <p>Deoarece restric\u021biile sunt foarte mari, aplicarea unei solu\u021bii care verific\u0103 toate variantele posibile folosind Backtracking este imposibil\u0103, iar diverse abord\u0103ri de tip Greedy, precum saltul spre cea mai apropiat\u0103 piatr\u0103 sau spre piatra cu o diferen\u021b\u0103 de \u00een\u0103l\u021bime minim\u0103 sunt gre\u0219ite.</p> <p>Astfel, se impune folosirea unei solu\u021bii care folose\u0219te metoda program\u0103rii dinamice, unde putem stoca \\(dp[i]\\) care va reprezenta suma minim\u0103 a diferen\u021belor salturilor necesare pentru a ajunge la pozi\u021bia \\(i\\), motivul pentru care vrem s\u0103 facem asta este acela c\u0103 este important s\u0103 avem un r\u0103spuns optim stocat pentru fiecare pozi\u021bie \u00een parte. </p> <p>Pentru a calcula \\(dp[i]\\), ne vom folosi de informa\u021biile din enun\u021b, \u0219i anume faptul c\u0103 avem voie s\u0103 s\u0103rim pe o pozi\u021bie aflat\u0103 la cel mult dou\u0103 unit\u0103\u021bi de pozi\u021bia curent\u0103, astfel \\(dp[i]\\) va fi egal cu urm\u0103toarea formul\u0103:</p> \\[ dp[i] = min(dp[i-1] + abs(v[i] - v[i-1]), dp[i-2] + abs(v[i] - v[i-2])) \\] <p>Cazul de baz\u0103 const\u0103 \u00een faptul c\u0103 \\(dp[1] = 0\\) \u0219i \\(dp[2] = abs(v[1] - v[2])\\), iar complexitatea acestei solu\u021bii este \\(O(n)\\). </p> <p>Mai jos pute\u021bi g\u0103si abordarea recursiv\u0103 \u0219i cea iterativ\u0103 a problemei.</p> RecursivIterativ <pre><code>#include &lt;iostream&gt;\n#include &lt;vector&gt;\n\nusing namespace std;\n\nint solve(int poz, const vector&lt;int&gt; &amp;v, vector&lt;int&gt; &amp;dp) {\n    // cazuri de baza\n    if (poz == 1) {\n        return 0;\n    }\n    if (poz == 2) {\n        return abs(v[2] - v[1]);\n    }\n    // evitarea calculelor redundante\n    if (dp[poz] != -1) {\n        return dp[poz];\n    }\n\n    dp[poz] = min(solve(poz - 1, v, dp) + abs(v[poz - 1] - v[poz]),\n                solve(poz - 2, v, dp) + abs(v[poz - 2] - v[poz]));\n    return dp[poz];\n}\n\nint main() {\n    int n;\n    cin &gt;&gt; n;\n\n    vector&lt;int&gt; v(n + 1);\n    vector&lt;int&gt; dp(n + 1, -1);\n\n    for (int i = 1; i &lt;= n; i++) {\n        cin &gt;&gt; v[i];\n    }\n\n    cout &lt;&lt; solve(n, v, dp) &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre> <pre><code>#include &lt;iostream&gt;\n#include &lt;vector&gt;\n\nusing namespace std;\n\nint main() {\n    int n;\n    cin &gt;&gt; n;\n\n    vector&lt;int&gt; v(n + 1);\n    vector&lt;int&gt; dp(n + 1);\n\n    for (int i = 1; i &lt;= n; i++) {\n        cin &gt;&gt; v[i];\n    }\n\n    for (int i = 2; i &lt;= n; i++) {\n        if (i == 2) {\n            dp[i] = abs(v[i] - v[i - 1]);\n        } else {\n            dp[i] = min(dp[i - 1] + abs(v[i] - v[i - 1]),\n                        dp[i - 2] + abs(v[i] - v[i - 2]));\n        }\n    }\n\n    cout &lt;&lt; dp[n] &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["programare dinamica","DP"]},{"location":"usor/intro-dp/#problema-frog-2","title":"Problema Frog 2","text":"<p>La fel ca la problema precedent\u0103, trebuie s\u0103 afl\u0103m costul minim de care are nevoie o broasc\u0103 pentru a ajunge de pe prima piatr\u0103 pe ultima, dac\u0103 se poate deplasa cu cel mult \\(k\\) pa\u0219i la un moment dat.</p> <p>Spre deosebire de problema precedent\u0103, pentru a calcula \\(dp[i]\\), ne vom folosi de informa\u021biile din enun\u021b, recuren\u021ba de la Frog 1 va fi extins\u0103 pentru a acoperi \\(k\\) pozi\u021bii. </p> \\[ dp[i] = min(dp[i-x] + abs(v[i] - v[i-x])), \\forall x \\leq k \\] <p>Cazul de baz\u0103 const\u0103 \u00een faptul c\u0103 \\(dp[1] = 0\\) \u0219i \\(dp[2] = abs(v[1] - v[2])\\), iar complexitatea acestei solu\u021bii este \\(O(n \\cdot k)\\). </p> RecursivIterativ <pre><code>#include &lt;iostream&gt;\n#include &lt;vector&gt;\n\nusing namespace std;\n\nint solve(int poz, int diff, const vector&lt;int&gt; &amp;v, vector&lt;int&gt; &amp;dp) {\n    if (poz == 1) {\n        return 0;\n    }\n    if (dp[poz] != -1) {\n        return dp[poz];\n    }\n\n    dp[poz] = (1 &lt;&lt; 30);  // 2^30\n    for (int i = 1; i &lt;= diff; i++) {\n        if (poz - i &gt;= 1) {\n            dp[poz] = min(dp[poz], solve(poz - i, diff, v, dp) +\n                                    abs(v[poz] - v[poz - i]));\n        }\n    }\n    return dp[poz];\n}\nint main() {\n    int n, k;\n    cin &gt;&gt; n &gt;&gt; k;\n\n    vector&lt;int&gt; v(n + 1);\n    vector&lt;int&gt; dp(n + 1, -1);\n\n    for (int i = 1; i &lt;= n; i++) {\n        cin &gt;&gt; v[i];\n    }\n\n    cout &lt;&lt; solve(n, k, v, dp) &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre> <pre><code>#include &lt;iostream&gt;\n#include &lt;vector&gt;\n\nusing namespace std;\n\nint main() {\n    int n, k;\n    cin &gt;&gt; n &gt;&gt; k;\n\n    vector&lt;int&gt; v(n + 1);\n    vector&lt;int&gt; dp(n + 1, 1 &lt;&lt; 30);  // 2 ^ 30\n\n    for (int i = 1; i &lt;= n; i++) {\n        cin &gt;&gt; v[i];\n    }\n\n    for (int i = 2; i &lt;= n; i++) {\n        for (int j = 1; j &lt;= k; j++) {\n            if (i - j &gt;= 1) {\n                dp[i] = min(dp[i], dp[i - j] + abs(v[i] - v[i - j]));\n            }\n        }\n    }\n\n    cout &lt;&lt; dp[n] &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["programare dinamica","DP"]},{"location":"usor/intro-dp/#problema-moneda","title":"Problema Moneda","text":"<p>Cerin\u021b\u0103</p> <p>Ast\u0103zi, la ora domnului profesor Tetris, \u021bi s-a pus urm\u0103toarea \u00eentrebare: \u201eDac\u0103 eu \u00ee\u021bi dau \\(N\\) tipuri de monede, av\u00e2nd acces la o infinitate de monede \\(C\\) de acele tipuri, afl\u0103 modalitatea optim\u0103 de a ob\u021bine suma \\(S\\)\u201d. Pe momentul orei tu nu ai \u0219tiut cum s\u0103 r\u0103spunzi, \u00cens\u0103 acum, mai determinat ca niciodat\u0103, vrei s\u0103 rezolvi aceast\u0103 problem, av\u00e2nd \u00een fa\u021b\u0103 un document educational de 5 stele Micheline. Rezolv\u0103 problema!</p> <p>Vom defini modalitatea optim\u0103 de a ob\u021bine suma \\(S\\) ca fiind modalitatea prin care utilizezi c\u00e2t mai pu\u021bine monede per total!</p> <p>Restric\u021bii:</p> <ul> <li> <p>$ 1 \\leq N \\leq 500 $</p> </li> <li> <p>$ 1 \\leq S \\leq 100000 $</p> </li> <li> <p>$ 1 \\leq C_i \\leq 2500 $</p> </li> </ul> <p>La \u00eenceput, c\u00e2nd a\u021bi citit aceast\u0103 problem\u0103, probabil v-a\u021bi g\u00e2ndit la o rezolvare Greedy (care mai \u00eencolo o s\u0103 vede\u021bi c\u0103 este Greedy Euristic), prin care a\u021bi fi sortat descresc\u0103tor \u0219irul de monede \u0219i a\u021bi fi \u00eencercat s\u0103 utiliza\u021bi denomina\u021bia cea mai mare, care este mai mic\u0103 ca S, c\u00e2t timp putea\u021bi. Dup\u0103 a\u021bi fi continuat cu urm\u0103toarea denomina\u021bie cea mai mare care respect\u0103 condi\u021bia aceasta pentru suma r\u0103mas\u0103 \u0219.a.m.d. Ca s\u0103 v\u0103 dovedesc c\u0103 nu func\u021bioneaz\u0103 aceast\u0103 modalitate, \u00eencerca\u021bi s\u0103 rezolva\u021bi aceast\u0103 problem\u0103, utiliz\u00e2nd modalitatea anterior prezentat\u0103, av\u00e2nd aceste date de intrare (\\(N\\) num\u0103rul de monede, apoi \\(S\\) suma \u0219i apoi cele \\(N\\) monede):</p> <pre><code>3\n31\n7 2 15\n</code></pre> <p>Acum c\u0103 a\u021bi \u00eencercat s\u0103 rezolva\u021bi problema \u00eentr-un mod cunoscut vou\u0103, \u0219i a\u021bi v\u0103zut c\u0103 nu \u00ee\u021bi garanteaz\u0103 un r\u0103spuns, haide\u021bi s\u0103 v\u0103 prezint o solu\u021bie corect\u0103!</p> <p>Pentru aceast\u0103 problem, o s\u0103 v\u0103 prezint solu\u021biile utiliz\u00e2nd ambele modalit\u0103\u021bi de abordare \u0219i scriere a sursei \u0219i modalit\u0103\u021bi de tranzi\u021bie.</p> RecursivIterativ <p>Explica\u021bie</p> <p>Pentru a g\u0103si solu\u021bia optim\u0103, noi vom avea vectorul dp care se utilizeaz\u0103 pentru memoizare, el av\u00e2nd forma urm\u0103toare: dp[suma de bani r\u0103mas\u0103 de acoperit] = nr de bacnote necesare pentru a ajunge la suma de bani r\u0103mas\u0103 de acoperit curent\u0103. Pentru asta ne vom utiliza de o recursiune care are ca parametrii de stare suma de bani care a r\u0103mas de pl\u0103tit, num\u0103rul de monede pe care l-am utilizat p\u00e2n\u0103 acum \u0219i vectorul de denomina\u021bii accesibile.</p> <pre><code>#include &lt;iostream&gt;\n#include &lt;vector&gt;\n\nusing namespace std;\n\nconst int MAXIM_SUMA_MONEDE = 100000;\n\nint N, S;\nvector&lt;int&gt; dp(MAXIM_SUMA_MONEDE + 1);\n\nvoid solve(const int suma, const int nr_monede, const vector&lt;int&gt;&amp; monede) {\n    if (suma == 0) {\n        return;\n    }\n\n    for (const auto moneda : monede) {\n        if (suma &gt;= moneda) {\n            if (dp[suma - moneda] &gt; nr_monede + 1) {\n                dp[suma - moneda] = nr_monede + 1;\n                solve(suma - moneda, nr_monede + 1, monede);\n            }\n        }\n    }\n}\n\nint main() {\n    cin &gt;&gt; N &gt;&gt; S;\n\n    vector&lt;int&gt; monede(N, 0);\n\n    for (auto&amp; moneda : monede) {\n        cin &gt;&gt; moneda;\n    }\n\n    solve(S, 0, monede);\n\n    cout &lt;&lt; dp[0];\n    return 0;\n}\n</code></pre> <p>Explica\u021bie</p> <p>Pentru a g\u0103si solu\u021bia optim\u0103, noi vom trece prin fiecare sum\u0103 de bani care este mai mic\u0103 dec\u00e2t \\(S\\), \u00eencerc\u00e2nd, dac\u0103 putem, s\u0103 continu\u0103m s\u0103 ad\u0103ug\u0103m bacnote astfel \u00eenc\u00e2t s\u0103 ajungem la suma de bani dorit\u0103. Pentru acest lucru vom \u021bine un vector dp de forma urm\u0103toare: dp[sum\u0103 de bani total\u0103] = num\u0103rul de bacnote necesare pentru a ajunge la aceast\u0103 sum\u0103 de bani.</p> <pre><code>#include &lt;algorithm&gt;\n#include &lt;iostream&gt;\n#include &lt;vector&gt;\n\nusing namespace std;\n\nconst int MAXIM_SUMA_MONEDE = 100000;\n\nint N, S;\nvector&lt;int&gt; dp(MAXIM_SUMA_MONEDE + 1);\n\nint main() {\n    cin &gt;&gt; N &gt;&gt; S;\n    vector&lt;int&gt; coins(N);\n    for (int i = 0; i &lt; N; i++) {\n        cin &gt;&gt; coins[i];\n    }\n    for (int i : coins) {\n        dp[i] = 1;\n    }\n\n    for (int i = 1; i &lt; S; i++) {\n        if (dp[i] != 0) {\n            for (int coin : coins) {\n                if (i + coin &lt;= S) {\n                    if (dp[i + coin] == 0) {\n                        dp[i + coin] = dp[i] + 1;\n                    } else {\n                        dp[i + coin] = min(dp[i + coin], dp[i] + 1);\n                    }\n                }\n            }\n        }\n    }\n\n    cout &lt;&lt; dp[S];\n    return 0;\n}\n</code></pre>","tags":["programare dinamica","DP"]},{"location":"usor/intro-dp/#problema-vacation","title":"Problema Vacation","text":"<p>Pentru aceast\u0103 problem\u0103, trebuie s\u0103 afl\u0103m satisfac\u021bia maxim\u0103 pe care o poate ob\u021bine Taro \u00een \\(n\\) zile, dac\u0103 nu are voie s\u0103 repete o activitate de dou\u0103 ori la r\u00e2nd. </p> <p>Din nou, se poate demonstra cu u\u0219urin\u021b\u0103 c\u0103 o solu\u021bie de tip Greedy nu va merge, deoarece ne putem bloca alegeri mai bune ulterior cu alegerile curente. </p> <p>Totodat\u0103, mai apare un element nou \u00een rezolvarea acestor probleme, \u0219i anume faptul c\u0103 vom avea nevoie de o nou\u0103 dimensiune pentru a p\u0103stra informa\u021bii cu privire la ultima activitate efectuat\u0103 de el, pentru a evita o situa\u021bie \u00een care alegem de dou\u0103 ori aceea\u0219i activitate. </p> <p>Astfel, vom defini \\(dp[i][j]\\) ca fiind suma maxim\u0103 a satisfac\u021biei dac\u0103 am parcurs primele \\(i\\) zile, iar ultima activitate a fost de tipul \\(j\\), \\(j\\) fiind \\(0\\), \\(1\\) sau \\(2\\), \u00een func\u021bie de activitatea aleas\u0103. </p> <p>Pentru a calcula \\(dp[i][j]\\), va trebui s\u0103 ne raport\u0103m la sumele din ziua precedent\u0103, corespunz\u0103toare celorlalte dou\u0103 activit\u0103\u021bi deoarece nu avem voie s\u0103 alegem aceea\u0219i activitate iar.</p> \\[ dp[i][j] = max(dp[i-1][x]) + v[j], \\forall x \\neq j \\] <p>Din nou ca la celelalte probleme, pute\u021bi g\u0103si mai jos abordarea recursiv\u0103 \u0219i cea iterativ\u0103 a problemei.</p> <p>Observa\u021bie</p> <p>Deoarece avem nevoie doar de valorile din ziua precedent\u0103, nu este necesar s\u0103 p\u0103str\u0103m \u00een memorie toat\u0103 matricea, ci doar ultimele dou\u0103 linii, optimizare pe care o vom prezenta \u00een detaliu mai jos.</p> RecursivIterativIterativ optimizat <pre><code>#include &lt;algorithm&gt;\n#include &lt;iostream&gt;\n#include &lt;vector&gt;\n\nusing namespace std;\n\nint solve(const int poz, const vector&lt;vector&lt;int&gt;&gt; &amp;v, vector&lt;vector&lt;int&gt;&gt; &amp;dp,\n        const int activ) {\n    if (poz == 1) {\n        return v[poz][activ];\n    }\n    if (dp[poz][activ] != -1) {\n        return dp[poz][activ];\n    }\n\n    dp[poz][activ] = 0;\n    for (int i = 0; i &lt; 3; i++) {\n        if (i != activ) {\n            dp[poz][activ] = max(dp[poz][activ], solve(poz - 1, v, dp, i));\n        }\n    }\n\n    dp[poz][activ] += v[poz][activ];\n    return dp[poz][activ];\n}\n\nint main() {\n    int n;\n    cin &gt;&gt; n;\n\n    vector&lt;vector&lt;int&gt;&gt; v(n + 1, vector&lt;int&gt;(3));\n    vector&lt;vector&lt;int&gt;&gt; dp(n + 1, vector&lt;int&gt;(3, -1));\n\n    for (int i = 1; i &lt;= n; i++) {\n        cin &gt;&gt; v[i][0] &gt;&gt; v[i][1] &gt;&gt; v[i][2];\n    }\n\n    cout &lt;&lt; max({solve(n, v, dp, 0), solve(n, v, dp, 1), solve(n, v, dp, 2)})\n        &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre> <pre><code>#include &lt;algorithm&gt;\n#include &lt;iostream&gt;\n#include &lt;vector&gt;\n\nusing namespace std;\n\nint main() {\n    int n;\n    cin &gt;&gt; n;\n\n    vector&lt;vector&lt;int&gt;&gt; dp(n + 1, vector&lt;int&gt;(3));\n\n    for (int i = 1; i &lt;= n; i++) {\n        int a, b, c;\n        cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;\n        if (i == 1) {\n            dp[1][0] = a;\n            dp[1][1] = b;\n            dp[1][2] = c;\n        } else {\n            dp[i][0] = max(dp[i - 1][1], dp[i - 1][2]) + a;\n            dp[i][1] = max(dp[i - 1][0], dp[i - 1][2]) + b;\n            dp[i][2] = max(dp[i - 1][0], dp[i - 1][1]) + c;\n        }\n    }\n\n    cout &lt;&lt; max({dp[n][0], dp[n][1], dp[n][2]}) &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre> <p>Explica\u021bie</p> <p>Deoarece avem nevoie doar de ultimele dou\u0103 linii, nu vom \u021bine toat\u0103 matricea, mut\u00e2nd mereu valorile calculate pe prima linie pentru a p\u0103stra corectitudinea recuren\u021bei.</p> <pre><code>#include &lt;algorithm&gt;\n#include &lt;iostream&gt;\n#include &lt;vector&gt;\n\nusing namespace std;\n\nint main() {\n    int n;\n    cin &gt;&gt; n;\n\n    vector&lt;vector&lt;int&gt;&gt; dp(2, vector&lt;int&gt;(3));\n\n    for (int i = 1; i &lt;= n; i++) {\n        int a, b, c;\n        cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;\n        if (i == 1) {\n            dp[0][0] = a;\n            dp[0][1] = b;\n            dp[0][2] = c;\n        } else {\n            dp[1][0] = max(dp[0][1], dp[0][2]) + a;\n            dp[1][1] = max(dp[0][0], dp[0][2]) + b;\n            dp[1][2] = max(dp[0][0], dp[0][1]) + c;\n\n            swap(dp[0], dp[1]);\n            fill(dp[1].begin(), dp[1].end(), 0);\n        }\n    }\n\n    cout &lt;&lt; max({dp[0][0], , dp[0][1], dp[0][2]}) &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["programare dinamica","DP"]},{"location":"usor/intro-dp/#problema-array-description","title":"Problema Array Description","text":"<p>Pentru aceast\u0103 problem\u0103, trebuie s\u0103 afl\u0103m num\u0103rul de \u0219iruri pe care le putem construi astfel \u00eenc\u00e2t s\u0103 respecte condi\u021biile din enun\u021b cu privire la valorile deja setate \u0219i la diferen\u021ba dintre ele. </p> <p>Astfel, vom defini \\(dp[i][j]\\) ca fiind num\u0103rul de moduri de a crea un \u0219ir cu \\(i\\) numere, dac\u0103 valoarea de pe pozi\u021bia \\(i\\) este \\(j\\). </p> <p>Pentru a afla \\(dp[i][j]\\), va trebui s\u0103 ne raport\u0103m la valorile de pe pozi\u021bia precedent\u0103, aflate la o distan\u021b\u0103 de cel mult \\(1\\), cu condi\u021bia s\u0103 putem pune \\(j\\) pe pozi\u021bia \\(i\\). </p> <p>Observatie</p> <p>Pentru a calcula num\u0103rul de solu\u021bii modulo \\(x\\), vom folosi operatorul \\(\\%\\) (mod). Dar deoarece aici avem nevoie doar de opera\u021bii de adunare, putem pur \u0219i simplu s\u0103 efectu\u0103m opera\u021biile de adunare \u0219i s\u0103 folosim sc\u0103deri \u00een mod convenabil, reu\u0219ind astfel s\u0103 optimiz\u0103m solu\u021bia.</p> <pre><code>#include &lt;iostream&gt;\n#include &lt;vector&gt;\n\nusing namespace std;\n\nconst int MOD = 1000000007;\n\nint main() {\n    int n, m;\n    cin &gt;&gt; n &gt;&gt; m;\n\n    vector&lt;int&gt; vals(n + 1);\n    for (int i = 1; i &lt;= n; i++) {\n        cin &gt;&gt; vals[i];\n    }\n\n    vector&lt;vector&lt;int&gt;&gt; dp(n + 1, vector&lt;int&gt;(m + 1));\n\n    for (int i = 1; i &lt;= m; i++) {\n        if (vals[1] == 0 || vals[1] == i) {\n            dp[1][i] = 1;\n        }\n    }\n\n    for (int i = 2; i &lt;= n; i++) {\n        for (int j = 1; j &lt;= m; j++) {\n            if (vals[i] &amp;&amp; vals[i] != j) {\n                continue;\n            }\n            for (int dif = -1; dif &lt;= 1; dif++) {\n                if (j + dif &gt; 0 &amp;&amp; j + dif &lt;= m) {\n                    dp[i][j] += dp[i - 1][j + dif];\n                    if (dp[i][j] &gt;= MOD) {\n                        dp[i][j] -= MOD;\n                    }\n                }\n            }\n        }\n    }\n\n    int ans = 0;\n    for (int i = 1; i &lt;= m; i++) {\n        ans += dp[n][i];\n        if (ans &gt;= MOD) {\n            ans -= MOD;\n        }\n    }\n\n    cout &lt;&lt; ans &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["programare dinamica","DP"]},{"location":"usor/intro-dp/#problema-grid-1","title":"Problema Grid 1","text":"<p>Pentru aceast\u0103 problem\u0103, trebuie s\u0103 afl\u0103m num\u0103rul de moduri de a parcurge matricea din col\u021bul st\u00e2nga-sus \u00een col\u021bul dreapta-jos prin mi\u0219c\u0103ri \u00een jos \u0219i la dreapta, f\u0103r\u0103 s\u0103 parcurgem p\u0103trate acoperite de ziduri. </p> <p>Deoarece avem de-a face cu o matrice, putem \u021bine \\(dp[i][j]\\) ca fiind num\u0103rul de moduri de a parcurge matricea dac\u0103 am ajuns la p\u0103tratul \\((i, j)\\). Deoarece putem ajunge la \\((i, j)\\) din p\u0103tratele de sus \u0219i st\u00e2nga, acestea vor fi cele dou\u0103 rezultate care contribuie la r\u0103spunsul dat. </p> <p>Astfel, \\(dp[i][j] = dp[i-1][j] + dp[i][j-1]\\).</p>","tags":["programare dinamica","DP"]},{"location":"usor/intro-dp/#solutie","title":"Solu\u021bie","text":"<pre><code>#include &lt;iostream&gt;\n#include &lt;vector&gt;\n\nusing namespace std;\n\nconst int MOD = 1000000007;\n\nint main() {\n    int n, m;\n    cin &gt;&gt; n &gt;&gt; m;\n\n    vector&lt;vector&lt;char&gt;&gt; grid(n + 1, vector&lt;char&gt;(m + 1));\n    vector&lt;vector&lt;int&gt;&gt; dp(n + 1, vector&lt;int&gt;(m + 1));\n    for (int i = 1; i &lt;= n; i++) {\n        for (int j = 1; j &lt;= m; j++) {\n            cin &gt;&gt; grid[i][j];\n        }\n    }\n\n    dp[1][1] = 1;\n    for (int i = 1; i &lt;= n; i++) {\n        for (int j = 1; j &lt;= m; j++) {\n            if (grid[i][j] != '#') {\n                dp[i][j] += dp[i - 1][j] + dp[i][j - 1];\n                if (dp[i][j] &gt;= MOD) {\n                    dp[i][j] -= MOD;\n                }\n            }\n        }\n    }\n\n    cout &lt;&lt; dp[n][m] &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["programare dinamica","DP"]},{"location":"usor/intro-dp/#problema-sumtri1","title":"Problema Sumtri1","text":"RecursivIterativ <pre><code>#include &lt;fstream&gt;\n\nusing namespace std;\nifstream fin(\"sumtri1.in\");\nofstream fout(\"sumtri1.out\");\n\nconst int MAX_N = 101;\n\nusing matrixB = bool[MAX_N][MAX_N];\nusing matrixI = int[MAX_N][MAX_N];\n\nmatrixB change;\nmatrixI triunghi, dp;\n\nint n;\nint ans;\n\nint solve(const int lin, const int col) {\n    if (dp[lin][col] != 0) {\n        return dp[lin][col];\n    }\n    if (lin &gt; n) {\n        return 0;\n    }\n\n    const int left = solve(lin + 1, col);\n    const int right = solve(lin + 1, col + 1);\n\n    if (left &lt; right) {\n        dp[lin][col] = triunghi[lin][col] + left;\n        change[lin][col] = false;\n    } else {\n        dp[lin][col] = triunghi[lin][col] + right;\n        change[lin][col] = true;\n    }\n    return dp[lin][col];\n}\n\nint main() {\n    fin &gt;&gt; n;\n    for (int i = 1; i &lt;= n; i++) {\n        for (int j = 1; j &lt;= i; j++) {\n            fin &gt;&gt; triunghi[i][j];\n        }\n    }\n\n    fout &lt;&lt; solve(1, 1) &lt;&lt; '\\n';\n\n\n    for (int l = 1, c = 1; l &lt;= n; l++) {\n        fout &lt;&lt; triunghi[l][c] &lt;&lt; ' ';\n        if (change[l][c]) {\n            c++;\n        }\n    }\n    return 0;\n}\n</code></pre> <pre><code>#include &lt;fstream&gt;\n\nusing namespace std;\nifstream fin(\"sumtri1.in\");\nofstream fout(\"sumtri1.out\");\n\nconst int MAX_N = 101;\n\nusing matrix = int[MAX_N][MAX_N];\n\nint n;\nmatrix triunghi, dp, cale;\n\nint main() {\n    fin &gt;&gt; n;\n\n    for (int i = 1; i &lt;= n; ++i) {\n        for (int j = 1; j &lt;= i; ++j) {\n            fin &gt;&gt; triunghi[i][j];\n            if (i == n) {\n                dp[n][j] = triunghi[n][j];\n            }\n        }\n    }\n\n    for (int i = n - 1; i &gt; 0; --i) {\n        for (int j = 1; j &lt;= i; ++j) {\n            dp[i][j] = triunghi[i][j];\n            if (dp[i + 1][j + 1] &lt; dp[i + 1][j]) {\n                dp[i][j] += dp[i + 1][j + 1];\n                cale[i][j] = j + 1;\n            } else {\n                dp[i][j] += dp[i + 1][j];\n                cale[i][j] = j;\n            }\n        }\n    }\n\n    fout &lt;&lt; dp[1][1] &lt;&lt; '\\n';\n\n    int j = 1;\n    for (int i = 1; i &lt;= n; ++i) {\n        fout &lt;&lt; triunghi[i][j] &lt;&lt; \" \";\n        j = cale[i][j];\n    }\n\n    return 0;\n}\n</code></pre>","tags":["programare dinamica","DP"]},{"location":"usor/intro-dp/#resurse-suplimentare","title":"Resurse suplimentare","text":"<ul> <li>DP Book</li> <li>Programare dinamica - CPPI Sync</li> <li>Introduction to DP - USACO Guide</li> <li>DP Tutorial and Problem List</li> </ul>","tags":["programare dinamica","DP"]},{"location":"usor/intro-dp/#probleme-suplimentare","title":"Probleme suplimentare","text":"<ul> <li>Infoarena custi</li> <li>Codeforces Boredom</li> <li>AtCoder Weak Takahashi</li> <li>IIOT 2023-24 PingPong</li> <li>AtCoder 1111gal password</li> <li>AtCoder Flip Cards</li> <li>IIOT Police</li> <li>Counting Towers</li> <li>AtCoder Index \u00d7 A(Not Continuous ver.)</li> <li>AtCoder Between Two Arrays</li> <li>Lot Juniori Minusk</li> <li>AtCoder Count Bracket Sequences</li> <li>AtCoder I hate Non Integer Number</li> <li>Problemele cu DP de pe Kilonova</li> <li>Problemele intre rating 500 si 1400 de aici</li> <li>Problemele cu DP de pe infoarena</li> <li>Ping Pong</li> </ul>","tags":["programare dinamica","DP"]},{"location":"usor/partial-sums/","title":"Sume par\u021biale","text":""},{"location":"usor/partial-sums/#cunostiinte-necesare-pentru-intelegerea-completa-a-articolului","title":"Cuno\u0219tiin\u021be necesare pentru \u00een\u021belegerea complet\u0103 a articolului:","text":"<ul> <li>tablourile unidimensionale \u0219i parcurgerea lor</li> <li>tablourile bidimensionale \u0219i parcurgerea lor</li> </ul>"},{"location":"usor/partial-sums/#problema-initiala","title":"Problema ini\u021bial\u0103","text":"<p>S\u0103 presupunem c\u0103 avem un \u0219ir \\(V\\) de \\(N\\) numere indexat de la \\(1\\), iar asupra \u0219irului primim mai multe \u00eentreb\u0103ri de forma: care este suma valorilor cuprinse \u00eentre pozi\u021biile \\(st\\) \u0219i \\(dr\\) (inclusiv) \u00een \u0219ir?</p> <p>R\u0103spunsul pentru aceast\u0103 \u00eentrebare se poate calcula foarte u\u0219or dac\u0103 realiz\u0103m parcurgerea efectiv\u0103 a \u0219irului de la pozi\u021bia \\(st\\) la pozi\u021bia \\(dr\\) \u0219i ne-ar lua \\(O(N)\\) pa\u0219i \u00een cel mai r\u0103u caz ca s\u0103 r\u0103spundem la o \u00eentrebare, complexitatea final\u0103 a programului ajung\u00e2nd la \\(O(N \\cdot Q)\\), ceea ce pentru valori mai mari de \\(10^4\\) pentru \\(N\\) \u0219i \\(Q\\) ar dep\u0103\u0219i limitele de timp la majoritatea problemelor de algoritmic\u0103. A\u0219adar, este nevoie de o optimizare, care se nume\u0219te \u201eSume par\u021biale\u201d.</p>"},{"location":"usor/partial-sums/#prezentarea-conceptului","title":"Prezentarea conceptului","text":"<p>Sumele par\u021biale reprezint\u0103 o optimizare pentru algoritmii care trebuie s\u0103 afle o sum\u0103 pe un interval, iar pe acel interval nu se produc modific\u0103ri. Consider\u0103m: \\(sp[i] =\\) suma valorilor de pe prefixul \\(1, 2, \\dots, i\\)</p> <p>Tabloul se calculeaz\u0103 \u00een felul urm\u0103tor:</p> <pre><code>for (int i = 1; i &lt;= n; i++)\n    sp[i] = sp[i - 1] + v[i];\n</code></pre> <p>Dup\u0103 calculare, putem \u00eencepe s\u0103 r\u0103spunem la \u00eentreb\u0103ri. R\u0103spunsul nostru pentru un interval \\([st, dr]\\), unde \\(1 \\leq st \\leq dr \\leq n\\) va fi: \\(suma \\ = sp[dr] - sp[st - 1]\\)</p> <p>Faptul c\u0103 r\u0103spunsul nostru este dat de o formul\u0103, va face ca timpul nostru efectuat pentru rezolvarea unei \u00eentreb\u0103ri s\u0103 fie constant \\(O(1)\\), ceea ce va duce ca programul nostru s\u0103 aib\u0103 o complexitate final\u0103 \\(O(N + Q)\\), pentru calcularea tabloului \\(sp\\) \u0219i pentru citirea \u0219i r\u0103spunderea la \u00eentreb\u0103ri. Totu\u0219i, hai s\u0103 vedem de ce formula men\u021bionat\u0103 mai sus func\u021bioneaz\u0103. </p> <p>Pentru demonstra\u021bie, vom \u00eencerca o abordare grafic\u0103 a formulei. Primul pas const\u0103 \u00een adunarea sumei prefixului \\(1, 2, \\dots, dr\\).</p> <p></p> <p>Apoi, va trebui s\u0103 sc\u0103dem prefixul \\(1, 2, \\dots, st - 1\\). </p> <p>\u00cen final, subsecven\u021ba \\(st, st + 1, \\dots, dr - 1, dr\\) va fi alc\u0103tuit\u0103 din acele pozi\u021bii care se afl\u0103 \u00een segmentul verde (prefixul \\(1, 2, \\dots, dr\\)), dar care nu se afl\u0103 \u0219i \u00een segmentul ro\u0219u (prefixul \\(1, 2, \\dots, st - 1\\)). A\u0219adar, \u00een urma acestei delimit\u0103ri o s\u0103 ob\u021binem suma cerut\u0103 pe intervalul nostru.</p>"},{"location":"usor/partial-sums/#extinderea-sumelor-partiale-pe-matrice","title":"Extinderea sumelor par\u021biale pe matrice","text":"<p>De asemenea, sumele par\u021biale se pot extinde \u0219i pe tablouri bidimensionale. S\u0103 presupunem c\u0103 lucr\u0103m cu matricea \\(A\\) care are \\(N\\) linii \u0219i \\(M\\) coloane. Vom defini matricea \\(sp\\) \u00een felul urm\u0103tor: </p> <p>\\(sp[i][j] =\\) suma valorilor aflate \u00een submatricea care are col\u021bul st\u00e2nga-sus de coordonate \\((1, 1)\\) \u0219i col\u021bul dreapta-jos de coordonate \\((i, j)\\)</p> <p>Fa\u021b\u0103 de cazul \\(1D\\), aici vom \u00eencepe cu demonstra\u021bia formulei de calcul a unei sume pe o submatrice, apoi vom \u0219i ar\u0103ta cum se va calcula matricea \\(sp\\). Vom analiza ni\u0219te cazuri particulare de submatrice, apoi vom enun\u021ba o formul\u0103 final\u0103.</p> <p>Pentru \u00eenceput, datorit\u0103 modului \u00een care am definit matricea \\(sp\\), primul caz particular pe care \u00eel vom analiza va fi calcularea sumei de pe o submatrice care are col\u021bul st\u00e2nga-sus de coordonate \\((1, 1)\\) \u0219i col\u021bul dreapta-jos de coordonate \\((x, y)\\). R\u0103spunsul \u00een acest caz va fi \\(sp[x][y]\\), deoarece fix acest lucru ne este calculat de c\u0103tre matricea \\(sp\\).</p> <p></p> <p>\\(suma = sp[x][y]\\)</p> <p>Acum, s\u0103 analiz\u0103m urm\u0103torul caz: ni se cere s\u0103 afl\u0103m suma valorilor dintr-o submatrice care are col\u021bul st\u00e2nga-sus de coordonate \\((1, z)\\) \u0219i col\u021bul dreapta-jos de coordonate \\((x, y)\\). Formula men\u021bionat\u0103 mai sus nu este corect\u0103, dar este un punct de plecare. Noi vom con\u021bine o submatrice \u00een plus \u00een cea determinat\u0103 de col\u021burile de coordonate \\((1, 1)\\) \u0219i \\((x, y)\\), anume cea determinat\u0103 de col\u021burile \\((1, 1)\\) \u0219i \\((x, z - 1)\\). A\u0219adar, dup\u0103 adunarea sumei date de \\(sp[x][y]\\) va fi nevoie s\u0103 sc\u0103dem \\(sp[x][z - 1]\\).</p> <p></p> <p>\\(suma = sp[x][y] - sp[x][z - 1]\\)</p> <p>Asemenea cazului precedent este si cazul \u00een care noi dorim s\u0103 afl\u0103m suma unei submatrice care are col\u021burile \\((z, 1)\\) \u0219i \\((x, y)\\). Similar, \\(sp[x][y]\\) nu este suficient, dar este un punct de plecare. Fa\u021b\u0103 de cazul precedent, submatricea \\emph{\u00een plus} este cea determinat\u0103 de col\u021burile \\((1, 1)\\) \u0219i \\((z - 1, y)\\). \u00cen final, formula pentru acest caz va fi \\(sp[x][y] - sp[z - 1][y]\\).</p> <p>% lasa imaginile vietii asa, vad eu cum le refac, dar tot ar fi util sa pui referinte (gen \"In fig.~\\ref{fig:sp5} vorbim de Scufita Rosie\" nuj)</p> <p></p> <p>\\(suma = sp[x][y] - sp[z - 1][y]\\)</p> <p>Acum, putem \u00eencerca s\u0103 deducem o formul\u0103 pentru orice submatrice. S\u0103 consider\u0103m submatricea determinat\u0103 de col\u021burile st\u00e2nga-sus de coordonate \\((x, y)\\) \u0219i dreapta-jos de coordonate \\((z, t)\\). Dac\u0103 ar fi s\u0103 adun\u0103m formulele demonstrate \u00een ultimele dou\u0103 cazuri \\((sp[z][t] - sp[x - 1][t] - sp[z][y - 1])\\), noi o s\u0103 sc\u0103dem de dou\u0103 ori suma din submatricea determinat\u0103 de col\u021burile \\((1, 1)\\) \u0219i \\((x - 1, y - 1)\\), \u00een timp ce noi o adun\u0103m doar o dat\u0103. A\u0219adar, la formul\u0103 se va aduna \u0219i suma din submatricea respectiv\u0103, pentru a compensa deficitul.</p> <p></p> <p>\\(suma = sp[z][t] - sp[z][y - 1] - sp[x - 1][t] + sp[x - 1][y - 1]\\)</p> <p>Cu un ra\u021bionament asem\u0103n\u0103tor celui pentru determinarea formulei pentru cazul general, vom determina \u0219i cum se calculeaz\u0103 matricea \\(sp\\). S\u0103 presupunem c\u0103 vrem s\u0103 afl\u0103m \\(sp[i][j]\\). Mai \u00eent\u00e2i vom porni de la a scrie formula pentru a afla suma valorii de pe pozi\u021bia \\((i, j)\\) \u00een matrice (valoare pe care noi o \u0219i stim!):</p> <p>\\(sp[i][j] - sp[i - 1][j] - sp[i][j - 1] + sp[i - 1][j - 1] = A[i][j]\\)</p> <p>Trecem to\u021bi termenii, cu excep\u021bia lui \\(sp[i][j]\\), \u00een dreapta \u0219i ob\u021binem:</p> <p>\\(sp[i][j] = sp[i - 1][j] + sp[i][j - 1] - sp[i - 1][j - 1] + A[i][j]\\)</p> <p>Deci, tabloul \\(sp\\) se poate calcula destul de u\u0219or \u00een timp \\(O(N \\cdot M)\\). Ata\u0219\u0103m, mai jos, o secven\u021b\u0103 de cod \u00een care se calculeaz\u0103 matricea \\(sp\\).</p> <pre><code>for (int i = 1; i &lt;= n; i++)\n    for (int j = 1; j &lt;= m; j++)\n        sp[i][j] = sp[i - 1][j] + sp[i][j - 1] - sp[i - 1][j - 1] + a[i][j];\n</code></pre>"},{"location":"usor/partial-sums/#smenul-lui-mars","title":"\u0218menul lui Mars","text":"<p>S\u0103 consider\u0103m urm\u0103toarea problem\u0103: se d\u0103 o ax\u0103 \u0219i \\(K\\) intervale de forma \\([st, dr]\\). Ni se dau dup\u0103 \\(Q\\) \u00eentreb\u0103ri de forma: c\u00e2te intervale con\u021bin \u00een interiorul lor punctul \\(x\\) de pe ax\u0103? </p> <p>O solu\u021bie foarte ineficient\u0103 ar fi pentru fiecare \u00eentrebare s\u0103 lu\u0103m fiecare interval \u00een parte \u0219i s\u0103 verific\u0103m dac\u0103 punctul nostru este inclus sau nu \u00een interval. Solu\u021bia este u\u0219or de intuit \u0219i de implementat, dar programul nostru ar avea complexitate \\((Q \\cdot K)\\). \u0218menul lui Marius Andrei (Mars) ne poate rezolva aceast\u0103 problem\u0103 \u00een timp constant, chiar \u0219i dac\u0103 o extindem pe mai multe dimensiuni (dou\u0103 axe, \\(3\\) axe etc.).</p> <p>\u0218menul lui Mars permite efectuarea opera\u021biilor de ad\u0103ugare a unei valori la toate elementele dintr-un interval (sau o submatrice, pentru cazul \u00een care lucr\u0103m cu o matrice), f\u0103r\u0103 posibilitatea de a primi \u00eentreb\u0103ri \u00eentre opera\u021biile de ad\u0103ugare (pentru acest tip de problem\u0103 se vor utiliza arborii de intervale, o tehnic\u0103 care va fi prezentat\u0103 ulterior). C\u00e2nd primim actualiz\u0103rile, noi vom efectua ni\u0219te adun\u0103ri \u0219i ni\u0219te sc\u0103deri pentru a delimita bucata din \u0219ir / matrice pe care se efectueaz\u0103 opera\u021bia. Apoi, valorile efective din structura noastr\u0103 de date se vor calcula asem\u0103n\u0103tor sumelor par\u021biale, fapt ce ne poate intui \u00eentr-o modalitate cum vom efectua aceste opera\u021bii.</p>"},{"location":"usor/partial-sums/#smenul-lui-mars-1d","title":"\u0218menul lui Mars 1D","text":"<p>Primul pas c\u00e2nd aplic\u0103m \u0218menul lui Mars unui \u0219ir, va trebui s\u0103 lu\u0103m fiecare interval \u00een parte \u0219i s\u0103 delimit\u0103m bucata din \u0219ir pe care efectu\u0103m opera\u021bia. Pentru intervalul de pozi\u021bii \\([x, y]\\), vom actualiza \u00een \u0219men cu \\(+1\\) la pozi\u021bia \\(x\\), ca s\u0103 ilustr\u0103m c\u0103 a \u00eenceput un nou interval, \u0219i cu \\(-1\\) la pozi\u021bia \\(y + 1\\) pentru a ar\u0103ta faptul c\u0103 intervalul nostru nu cuprinde \u0219i pozi\u021bia \\(y + 1\\). Astfel, vom avea:</p> <pre><code>mars[x]++;\nmars[y + 1]--;\n</code></pre> <p>unde vectorul \\(mars[]\\) reprezint\u0103 adun\u0103rile / sc\u0103derile din \u0219men. A\u0219a cum am zis \u0219i mai sus, noi calcul\u0103m valorile noastre din \u0219ir ca la sumele par\u021biale, deci, se poate afirma c\u0103: \\(v[i] = mars[1] + mars[2] + \\dots + mars[i]\\)</p> <p>Dupa efectuarea tuturor opera\u021biilor de ad\u0103ugare pe interval, noi vom calcula printr-o parcurgere simpl\u0103 valorile din \u0219irul \\(V\\):</p> <pre><code>for (int i = 1; i &lt;= n; i++) {\n    mars[i] += mars[i - 1];\n    v[i] = mars[i];\n}\n</code></pre> <p>Aten\u021bie la faptul c\u0103 suma pe prefixul \\(1, 2, \\dots, i\\) va fi \u021binut\u0103 \u00een \\(mars[i]\\). Revenind la problema noastr\u0103 ini\u021bial\u0103, r\u0103spunsul la fiecare \u00eentrebare va fi \u00een \\(mars[x]\\), astfel ob\u021bin\u00e2nd \\bigO{1} pe query. Evident, dac\u0103 vrem s\u0103 ad\u0103ug\u0103m o valoare \\(z\\) \u00een loc de \\(1\\) pe interval, acest lucru se poate realiza foarte u\u0219or:</p> <pre><code>mars[x] += z;\nmars[y + 1] -= z;\n/// cod din program\nfor (int i = 1; i &lt;= n; i++) {\n    mars[i] += mars[i - 1];\n    v[i] += mars[i];\n}\n</code></pre> <p>Codul de mai sus poate s\u0103 sus\u021bin\u0103 \u0219i updateuri pe un \u0219ir ini\u021bial nevid. Dac\u0103 problema noastr\u0103 nu are suficient\u0103 memorie pentru men\u021binerea \u0219irului, aceste plusuri \u0219i minusuri se pot re\u021bine ca evenimente, care se pot sorta dup\u0103 pozi\u021bie pentru efectuarea lor. Nu o s\u0103 intr\u0103m \u00een profunzime momentan cu aceast\u0103 tehnic\u0103, dar o l\u0103s\u0103m ca tem\u0103 pentru studiu cititorului.</p>"},{"location":"usor/partial-sums/#smenul-lui-mars-2d","title":"\u0218menul lui Mars 2D","text":"<p>\u0218menul lui Mars aplicat pe o matrice presupune \u00een\u021belegerea mai profund\u0103 a cum se propag\u0103 sumele par\u021biale pe matrice. S\u0103 presupunem c\u0103 avem submatricea delimitat\u0103 de col\u021burile \\((x, y)\\) \u0219i \\((z, t)\\). Dac\u0103 o s\u0103 facem doar o adunare \u0219i o sc\u0103dere ca la cazul liniar din \u0219menul lui Mars, propag\u0103rile noastre vor fi foarte eronate. S\u0103 privim \u00een desen de ce:</p> <p></p> <p>O s\u0103 avem, \u00een plus, multe elemente care sunt actualizate. De aceea, se va proceda \u00een felul urm\u0103tor: se va p\u0103stra adunarea de la \\(mars[x][y]\\) \u0219i se va sc\u0103dea la \\(mars[z + 1][y]\\) \u0219i \\(mars[x][t + 1]\\). \u00cenc\u0103 nu este complet, fiindc\u0103 pe submatricea \\((z + 1, t + 1), (N, M)\\) vor fi o adunare \u0219i dou\u0103 sc\u0103deri, deci acum sc\u0103dem mai mult dec\u00e2t ar trebui, deci va trebui s\u0103 adun\u0103m \u0219i la \\(mars[z + 1][t + 1]\\).</p> <p></p> <p>\u00cen cod, ar ar\u0103ta \u00een felul urm\u0103tor:</p> <pre><code>mars[x][y] += k;\nmars[z + 1][y] -= k;\nmars[x][t + 1] -= k;\nmars[z + 1][t + 1] += k;\n/// cod din program\nfor (int i = 1; i &lt;= n; i++) {\n    for (int j = 1; j &lt;= m; j++) {\n        mars[i][j] += mars[i - 1][j] + mars[i][j - 1] - mars[i - 1][j - 1];\n        a[i][j] += mars[i][j];\n    }\n}\n</code></pre> <p>\u00cen final, \u00een urma opera\u021biilor de ad\u0103ugare, dac\u0103 vrem s\u0103 \u0219tim ce valoare se afl\u0103 pe pozi\u021bia \\((i, j)\\), r\u0103spunsul va fi dat de \\(A_{i, j}\\).</p> <p>\u0218menul lui Mars poate fi extins \u0219i pe \\(3\\) dimensiuni sau chiar mai multe, iar abordarea pe mai multe dimensiuni se va realiza identic, dar o s\u0103 fie rar \u00eent\u00e2lnit \u00een problemele de algoritmic\u0103 cazuri \u00een care s\u0103 se cear\u0103 \u0219menul lui Mars pe mai mult de dou\u0103 dimensiuni.</p>"},{"location":"usor/partial-sums/#concluzii-si-probleme-suplimentare","title":"Concluzii \u0219i probleme suplimentare","text":"<p>Sumele par\u021biale sunt o optimizare cheie \u00een algoritmic\u0103, ajut\u00e2ndu-ne s\u0103 transform\u0103m lucruri precum aflarea unei sume pe un interval dintr-o \u00eentreag\u0103 parcurgere \u00eentr-o simpl\u0103 formul\u0103, cu timp constant de r\u0103spuns.</p> <p>Pentru aprofundarea algoritmilor prezenta\u021bi mai sus, recomand rezolvarea urm\u0103toarelor probleme \u0219i articole:</p>"},{"location":"usor/partial-sums/#probleme-de-la-olimpiade","title":"Probleme de la olimpiade","text":"<ul> <li>Prefix Sums 1D</li> <li>plaja ONI 2010</li> <li>gradina ONI 2013</li> <li>Breed Counting USACO Silver</li> <li>flip01 RoAlgo PreOJI 2024</li> <li>sirpal RoAlgo PreOJI 2024</li> <li>cdcq RoAlgo Contest #1</li> <li>tnia OJI 2018</li> <li>balon ONI 2023</li> <li>poseidon RoAlgo Contest #4</li> <li>investi\u021bie OJI 2023</li> <li>Probleme cu sume par\u021biale</li> <li>Probleme cu \u0219menul lui Mars</li> <li>Subsequences Summing to Sevens USACO Silver</li> <li>Haybale Stacking USACO Bronze</li> <li>ONI 2024 Eras</li> <li>Painting the Barn USACO Gold</li> </ul>"},{"location":"usor/partial-sums/#probleme-de-pe-codeforces","title":"Probleme de pe Codeforces","text":"<ul> <li>Good Subarrays - Codeforces</li> <li>Running Miles - Codeforces</li> <li>Irreductible Anagrams</li> <li>Nusret Gokce</li> <li>Constant Palindrome Sum - Codeforces</li> <li>Two Pointers Step 3 - Codeforces EDU</li> </ul>"},{"location":"usor/partial-sums/#bibliografie-si-lectura-suplimentara","title":"Bibliografie \u0219i lectur\u0103 suplimentar\u0103","text":"<ul> <li>Sume par\u021biale - CPPI</li> <li>Trucul lui Mars - CPPI</li> <li>Prefix Sums - USACO Guide</li> <li>More on Prefix Sums</li> <li>An Introduction to Difference Arrays</li> </ul>"},{"location":"usor/sieve/","title":"Ciurul lui Eratostene","text":"<p>Autor: \u0218tefan-Cosmin D\u0103sc\u0103lescu</p>","tags":["matematica","numere prime","divizori","precalculari"]},{"location":"usor/sieve/#cunostinte-necesare","title":"Cuno\u0219tinte necesare","text":"<p>\u00cenaintea citirii acestui articol, se recomand\u0103 citirea articolului despre divizibilitate. De asemenea, pentru unele aplica\u021bii mai avansate, cunoa\u0219terea elementar\u0103 a STL este necesar\u0103.</p>","tags":["matematica","numere prime","divizori","precalculari"]},{"location":"usor/sieve/#ce-este-ciurul-lui-eratostene","title":"Ce este ciurul lui Eratostene?","text":"<p>Ciurul lui Eratostene este o metod\u0103 eficient\u0103 de afla toate numerele prime \u00eentre \\(1\\) \u0219i \\(n\\), folosindu-ne de propriet\u0103\u021bile corespunz\u0103toare numerelor naturale, precum \u0219i de rela\u021biile dintre divizori \u0219i multipli. Pe l\u00e2ng\u0103 aplica\u021bia sa principal\u0103, se va dovedi a fi un algoritm foarte util pentru foarte multe tipuri de precalcul\u0103ri care sunt centrate \u00een jurul afl\u0103rii divizorilor sau a altor valori ce se calculeaz\u0103 \u00een func\u021bie de divizorii numerelor de la \\(1\\) la \\(n\\).</p> <p>Pentru a afla numerele prime de la \\(1\\) la \\(n\\), vom avea un algoritm simplu, care va lua la r\u00e2nd numerele de la \\(2\\) la \\(n\\) \u0219i pentru fiecare num\u0103r nemarcat de la \\(2\\) la \\(n\\), se vor marca to\u021bi multiplii acestuia. Astfel, numerele nemarcate sunt numerele prime, acestea nefiind marcate anterior de momentul acces\u0103rii lor, iar numerele marcate sunt numerele compuse. Se remarc\u0103 faptul c\u0103 \\(1\\), nefiind num\u0103r prim, nu este luat \u00een considerare.</p> <p>S\u0103 exemplific\u0103m algoritmul pentru numerele de la \\(2\\) la \\(30\\). Voi descrie doar pa\u0219ii ce exemplific\u0103 ce se \u00eent\u00e2mpl\u0103 c\u00e2nd avem de-a face cu numere prime.</p> <ul> <li>La pasul \\(i = 2\\), \\(2\\) este marcat drept num\u0103r prim, iar acesta va marca numerele pare de la \\(4\\) la \\(30\\) drept compuse \\((4, 6, 8, 10, 12, 14, 16, 18, 20\\), \\(22, 24, 26, 28, 30)\\).</li> <li>La pasul \\(i = 3\\), \\(3\\) este marcat drept num\u0103r prim, iar acesta va marca numerele multiplu de \\(3\\) de la \\(6\\) la \\(30\\) drept compuse \\((6, 9, 12, 15, 18, 21, 24, 27, 30)\\).</li> <li>La pasul \\(i = 5\\), \\(5\\) este marcat drept num\u0103r prim, iar acesta va marca numerele multiplu de \\(5\\) de la \\(10\\) la \\(30\\) drept compuse \\((10, 15, 20, 25, 30)\\).</li> <li>La pasul \\(i = 7\\), \\(7\\) este marcat drept num\u0103r prim, iar acesta va marca numerele multiplu de \\(7\\) de la \\(14\\) la \\(30\\) drept compuse \\((14, 21, 28)\\).</li> <li>La pasul \\(i = 11\\), \\(11\\) este marcat drept num\u0103r prim, iar acesta va marca numerele multiplu de \\(11\\) de la \\(22\\) la \\(30\\) drept compuse \\((22)\\).</li> <li>La pasul \\(i = 13\\), \\(13\\) este marcat drept num\u0103r prim, iar acesta va marca numerele multiplu de \\(13\\) de la \\(26\\) la \\(30\\) drept compuse \\((26)\\).</li> <li>La pa\u0219ii \\(i = 17\\), \\(i = 23\\), \\(i = 29\\), \\(17\\), \\(23\\) \u0219i \\(29\\) sunt marca\u021bi drept numere prime, dar multiplii lor mai mari ca ei sunt mai mari ca \\(30\\), nemaifiind marca\u021bi drept numere compuse, chiar dac\u0103 sunt, deoarece nu fac parte din scopul rul\u0103rii algoritmului nostru pentru numerele p\u00e2n\u0103 la \\(30\\).</li> </ul> <p></p> <p>Un exemplu de vizualizare pentru numerele de la \\(1\\) la \\(16\\)</p> <p>Algoritmul se dovede\u0219te a fi o optimizare fa\u021b\u0103 de metoda standard de aflare pentru toate numerele de la \\(1\\) la \\(n\\) a primalit\u0103\u021bii, complexitatea devenind \\(O(n \\log \\log n)\\) pentru aflarea primalit\u0103\u021bii pentru toate numerele, respectiv \\(O(n \\log n)\\) pentru majoritatea celorlalte tipuri de prelucr\u0103ri. De asemenea, \u0219i implementarea se dovede\u0219te a fi una foarte scurt\u0103, ciurul put\u00e2nd fi scris \u00een c\u00e2teva r\u00e2nduri. </p> <pre><code>int prim[100001];\nfor (int i = 2; i &lt;= n; i++) {\n    if (prim[i] == 0) {\n        for (int j = i + i; j &lt;= n; j += i) {\n            prim[j] = 1;\n        }\n    }\n}\n</code></pre> <p>Observa\u021bie</p> <p>E de remarcat c\u0103 numerele prime vor fi cele nemarcate, iar numerele compuse vor fi cele marcate cu \\(1\\).</p>","tags":["matematica","numere prime","divizori","precalculari"]},{"location":"usor/sieve/#optimizari-ale-implementarii","title":"Optimiz\u0103ri ale implement\u0103rii","text":"<p>De\u0219i algoritmul \u00een sine este deja foarte rapid, \u00een practic\u0103 concuren\u021bii tind s\u0103 aplice diverse optimiz\u0103ri de constant\u0103 inspirate din optimiz\u0103rile ce se pot aplica algoritmului de aflare a divizorilor unui num\u0103r \\(n\\). Printre altele, putem vorbi de \u00eenceperea celui de-al doilea for de la \\(i^2\\) (primul num\u0103r compus care nu a fost marcat anterior va fi mereu \\(i^2\\)) sau de procesarea lui \\(2\\), urmat\u0103 de procesarea numerelor impare din \\(2\\) \u00een \\(2\\).</p> <pre><code>int prim[100001];\nfor (int i = 4; i &lt;= n; i += 2) {\n    prim[i] = 1;\n}\nfor (int i = 3; i &lt;= n; i += 2) {\n    if (prim[i] == 0) {\n        for (int j = i * i; j &lt;= n; j += i * 2) {\n            prim[j] = 1;\n        }\n    }\n}\n</code></pre> <p>Observa\u021bie</p> <p>Trebuie avut grij\u0103 la cel de-al doilea for deoarece expresia int j = i * i; poate cauza overflow dac\u0103 implementarea nu este una corespunz\u0103toare. De aceea, concuren\u021bii pot folosi o optimizare similar\u0103 \u0219i pentru primul for.</p> <pre><code>int prim[100001];\nfor (int i = 4; i &lt;= n; i += 2) {\n    prim[i] = 1;\n}\nfor (int i = 3; i * i &lt;= n; i += 2) {\n    if (prim[i] == 0) {\n        for (int j = i * i; j &lt;= n; j += i * 2) {\n            prim[j] = 1;\n        }\n    }\n}\n\n// afisarea numerelor prime de la 1 la n\nfor (int i = 2; i &lt;= n; i++) {\n    if (prim[i] == 0) {\n        cout &lt;&lt; i &lt;&lt; \" \";\n    }\n}\n</code></pre> <p>Chiar dac\u0103 aceste implement\u0103ri nu \u00eembun\u0103t\u0103\u021besc semnificativ performan\u021ba ciurului lui Eratostene, ele pot fi utile \u00een contextul optimiz\u0103rilor ce ar putea fi folosite la rezolvarea problemelor. </p>","tags":["matematica","numere prime","divizori","precalculari"]},{"location":"usor/sieve/#alte-aplicatii-ale-ciurului-lui-eratostene","title":"Alte aplica\u021bii ale ciurului lui Eratostene","text":"<p>Dup\u0103 cum am men\u021bionat la \u00eenceputul articolului, ciurul lui Eratostene este un algoritm foarte versatil, put\u00e2nd fi folosit pentru aflarea multor propriet\u0103\u021bi ale numerelor, precum divizorii (primi sau to\u021bi) ai unui num\u0103r, pentru calcule de tipul celor folosite la pinex sau M\u00f6bius \u0219i a\u0219a mai departe. C\u00e2teva din implement\u0103rile acestor opera\u021bii vor fi prezentate mai jos, \u00een cadrul problemei educa\u021bionale descris\u0103 \u00een cele ce urmeaz\u0103. </p>","tags":["matematica","numere prime","divizori","precalculari"]},{"location":"usor/sieve/#problema-ciurul-lui-eratostene-de-pe-kilonova","title":"Problema Ciurul lui Eratostene de pe Kilonova","text":"<p>Se dau \\(q\\) opera\u021bii de forma \\(type \\ value\\). \u00cen func\u021bie de tipul opera\u021biei, va trebui s\u0103 face\u021bi urm\u0103toarele lucruri:</p> <ul> <li>\\(1 \\ value\\): S\u0103 se afi\u0219eze <code>Prime</code> sau <code>Composite</code> dac\u0103 num\u0103rul este prim, respectiv compus.</li> <li>\\(2 \\ value\\): S\u0103 se afi\u0219eze divizorii primi ai lui \\(value\\), \u00een ordine cresc\u0103toare. Dac\u0103 \\(value = 1\\), se va afi\u0219a o linie goal\u0103.</li> <li>\\(3 \\ value\\): S\u0103 se afi\u0219eze divizorii lui \\(value\\), \u00een ordine cresc\u0103toare.</li> </ul> <p>Pentru a rezolva problema (\u0219i \u00een general pentru a rezolva problemele care implic\u0103 folosirea ciurului lui Eratostene), ne vom precalcula toate r\u0103spunsurile folosind varia\u021bii ale ciurului lui Eratostene, una pentru numerele prime \u0219i cealalt\u0103 pentru divizori \u00een general. Pentru a \u021bine \u00een memorie to\u021bi divizorii, vom folosi varianta din STL a vectorilor, deoarece face accesarea datelor mai u\u0219oar\u0103.</p> <pre><code>#include &lt;iostream&gt;\n#include &lt;vector&gt; \n\nusing namespace std;\n\nconst int NMAX = 1000000;\nint q, prime[NMAX + 1];\nvector&lt;vector&lt;int&gt; &gt; divisors, prime_divisors;\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n\n    divisors.resize(NMAX + 1);\n    prime_divisors.resize(NMAX + 1);\n\n    for (int i = 1; i &lt;= NMAX; i++) {\n        for (int j = i; j &lt;= NMAX; j += i) {\n            divisors[j].push_back(i);\n        }\n    } \n\n    prime[1] = 1;\n    for (int i = 2; i &lt;= NMAX; i++) {\n        if (prime[i] == 0) {\n            for (int j = i; j &lt;= NMAX; j += i) {\n                prime_divisors[j].push_back(i);\n                if (j != i) {\n                    prime[j] = 1;\n                }\n            }\n        }\n    }\n\n    cin &gt;&gt; q;\n\n    for (int i = 1; i &lt;= q; i++) {\n        int type, value;\n        cin &gt;&gt; type &gt;&gt; value;\n        if (type == 1) {\n            cout &lt;&lt; (prime[value] == 0 ? \"Prime\" : \"Composite\") &lt;&lt; '\\n';\n        }\n        if (type == 2) {\n            for (int j = 0; j &lt; (int) prime_divisors[value].size(); j++) {\n                cout &lt;&lt; prime_divisors[value][j] &lt;&lt; \" \";\n            }\n            cout &lt;&lt; '\\n';\n        }\n        if(type == 3) {\n            for (int j = 0; j &lt; (int) divisors[value].size(); j++) {\n                cout &lt;&lt; divisors[value][j] &lt;&lt; \" \";\n            }\n            cout &lt;&lt; '\\n';\n        }\n    }\n    return 0;\n}\n</code></pre>","tags":["matematica","numere prime","divizori","precalculari"]},{"location":"usor/sieve/#problema-cufar-oji-2018-de-pe-kilonova","title":"Problema Cuf\u0103r - OJI 2018 de pe Kilonova","text":"<p>Vr\u0103jitoarea cea bun\u0103 are un cuf\u0103r \u00een care este \u00eenchis\u0103 piatra magic\u0103 de c\u0103tre piticii l\u0103zii cu ajutorul unui cifru digital. Piticii i-au dat vr\u0103jitoarei o cutie \u00een care sunt \\(n\\) cartona\u0219e. Pe fiecare cartona\u0219 este scris un num\u0103r natural pe care vr\u0103jitoarea \u00eel va folosi s\u0103 deschid\u0103 lada. Valorile scrise pe cartona\u0219e sunt distincte \u00eentre ele.</p> <p>Pentru a afla cifrul trebuie s\u0103 procedeze astfel: extrage fiecare cartona\u0219 din cutie \u0219i apoi determin\u0103 valoarea magic\u0103 asociat\u0103 num\u0103rului natural scris pe cartona\u0219. Pentru fiecare cartona\u0219 valoarea magic\u0103 este dat\u0103 de al \\(k\\)-lea divizor prim al num\u0103rului \u00eenscris pe acesta. Vr\u0103jitoarea trebuie s\u0103 adune valorile magice ob\u021binute pentru cele \\(n\\) cartona\u0219e \u0219i apoi s\u0103 introduc\u0103 \u00een ordine cifrele valorii ob\u021binute, pentru a descuia lada.</p> <p>Pentru a rezolva problema vom afla folosind un ciur to\u021bi divizorii primi ai numerelor mai mici sau egale cu \\(10^6\\), ace\u0219tia fiind folosi\u021bi pentru a calcula r\u0103spunsul la query-uri. Aflarea r\u0103spunsului final devine u\u0219oar\u0103 ulterior efectu\u0103rii acestui pas.</p> <p>Solu\u021bia de \\(100\\) de puncte</p>","tags":["matematica","numere prime","divizori","precalculari"]},{"location":"usor/sieve/#problema-primprim-oji-2023-de-pe-kilonova","title":"Problema primprim - OJI 2023 de pe Kilonova","text":"<p>Pentru un numa\u0306r natural a definim costul ca fiind valoarea absoluta\u0306 (modulul) diferen\u021bei dintre a \u0219i numa\u0306rul prim cel mai apropiat de a. Asupra unui \u0219ir de \\(n\\) numere naturale, situate pe pozi\u021bii numerotate de la \\(1\\) la \\(n\\), se aplica\u0306, \u00een ordine, o succesiune de \\(q\\) opera\u021bii. O opera\u021bie consta\u0306 dintr-o \u00eenlocuire \u0219i o afi\u0219are \u0219i este descrisa\u0306 sub forma \\(i \\ x \\ p\\), cu semnifica\u021bia: mai \u00eenta\u0302i \u00eenlocuim cu \\(x\\) elementul din \u0219ir de pe pozi\u021bia \\(i\\); apoi afi\u0219a\u0306m suma minima\u0306 totala\u0306 a costurilor unor elemente convenabil selectate de pe \\(p\\) pozi\u021bii distincte din \u0219ir.</p> <p>Cunosca\u0302nd \\(n\\) \u0219i cele \\(n\\) elemente ale \u0219irului, scrie\u021bi un program care sa\u0306 determine:</p> <ul> <li>suma costurilor tuturor elementelor din \u0219irul dat;</li> <li>rezultatele afi\u0219ate \u00een urma aplica\u0306rii fieca\u0306reia dintre cele \\(q\\) opera\u021bii, date \u00een forma precizata\u0306.</li> </ul> <p>Pentru a rezolva problema, vom precalcula pentru fiecare valoare r\u0103spunsul optim pentru fiecare num\u0103r de la \\(1\\) la \\(a\\) folosind ciurul lui Eratostene. Apoi, parcurgem valorile de la \\(1\\) la \\(a\\) pentru a afla r\u0103spunsul optim dup\u0103 ce am aflat numerele prime din \u0219ir. </p> <p>Pentru a rezolva query-urile, voi folosi un vector de frecventa pentru a tine aceste diferen\u021be, care de altfel sunt destul de mici. Apoi, pentru fiecare query, voi parcurge vectorul de frecven\u021b\u0103 pentru a afla suma celor mai mici \\(p\\) diferen\u021be.</p> <p>Solu\u021bia de \\(100\\) de puncte</p>","tags":["matematica","numere prime","divizori","precalculari"]},{"location":"usor/sieve/#probleme-suplimentare","title":"Probleme suplimentare","text":"<ul> <li>CSES Counting Divisors</li> <li>CSES Common Divisors</li> <li>RoAlgo PreOJI 2024 Factoria</li> <li>Moisil++ Sprime</li> <li>infoarena numereprime</li> <li>ONI 2013 divizori</li> <li>ONI 2019 comun</li> <li>OJI 2024 Macarie</li> <li>OJI 2024 avid</li> <li>OJI 2023 Primprim</li> <li>ONI 2024 Geologie</li> <li>ONI 2013 Extraprime</li> <li>ONI 2022 Baraj Juniori Triprime</li> <li>ONI 2021 Baraj Juniori Intergalactic</li> <li>Probleme cu ciurul lui Eratostene de pe kilonova</li> </ul>","tags":["matematica","numere prime","divizori","precalculari"]},{"location":"usor/sieve/#lectura-suplimentara","title":"Lectur\u0103 suplimentar\u0103","text":"<ul> <li>Ciurul lui Eratostene - Pbinfo</li> <li>Eratostene si alte ciururi - Pbinfo</li> <li>Ciurul lui Eratostene - CPPI Sync</li> <li>Wikipedia - Ciurul lui Eratostene</li> <li>Articol de pe CP Algorithms</li> </ul>","tags":["matematica","numere prime","divizori","precalculari"]},{"location":"usor/sorting/","title":"Algoritmi de sortare","text":"<p>Autor: \u0218tefan-Cosmin D\u0103sc\u0103lescu</p>","tags":["sortare","optimizare"]},{"location":"usor/sorting/#fundamente-si-cunostinte-necesare","title":"Fundamente \u0219i cuno\u0219tin\u021be necesare","text":"<p>\u00cen foarte multe probleme de algoritmic\u0103, un pas important \u00een rezolvarea problemelor const\u0103 \u00een ordonarea datelor de intrare dup\u0103 un anumit criteriu, iar o \u00eentrebare care se pune este cum putem s\u0103 ordon\u0103m datele convenabil, c\u00e2t mai rapid posibil?</p> <p>Din fericire, de-a lungul timpului s-au inventat foarte mul\u021bi algoritmi de sortare pe care \u00eei putem folosi pentru a rezolva problema pus\u0103 mai sus. Pentru a face \u00een\u021belegerea lor u\u0219oar\u0103, voi explica algoritmii \u00een ordine cresc\u0103toare a dificult\u0103\u021bii lor de \u00een\u021belegere, precum \u0219i \u00een ordine cresc\u0103toare a performan\u021bei, men\u021bion\u00e2nd \u00een cazul fiec\u0103ruia din algoritmi cuno\u0219tin\u021bele necesare pentru a-i putea \u00een\u021belege \u0219i folosi cu succes.</p>","tags":["sortare","optimizare"]},{"location":"usor/sorting/#algoritmi-de-sortare-in-on2","title":"Algoritmi de sortare \u00een \\(O(n^2)\\)","text":"<p>Voi \u00eencepe prin a explica algoritmii de sortare \u00een \\(O(n^2)\\) deoarece ace\u0219tia sunt de o dificultate similar\u0103, singura cuno\u0219tin\u021b\u0103 necesar\u0103 pentru ei fiind lucrul cu tablouri unidimensionale. Performan\u021bele celor trei algoritmi pe care \u00eei voi men\u021biona sunt de asemenea foarte similare, dar fiecare din ace\u0219ti algoritmi are punctele lui tari \u0219i slabe. Pentru fiecare sec\u021biune am ata\u0219at un exemplu de ordonare cresc\u0103toare a valorilor folosind acest algoritm.</p>","tags":["sortare","optimizare"]},{"location":"usor/sorting/#selection-sort","title":"Selection sort","text":"<p>Sortarea prin selec\u021bie sau selection sort este un algoritm elementar de sortare care verific\u0103 fiecare pereche de valori din vector \u0219i dac\u0103 cele dou\u0103 valori sunt a\u0219ezate contrar ordinii folosite la ordonarea lor, le vom schimba \u00eentre ele.</p> <pre><code>int v[1001], n;\n\nfor (int i = 1; i &lt; n; i++) {\n    for (int j = i + 1; j &lt;= n; j++) {\n        if (v[i] &gt; v[j]) {\n            int aux = v[i];\n            v[i] = v[j];\n            v[j] = aux;\n        }\n    }\n}\n</code></pre>","tags":["sortare","optimizare"]},{"location":"usor/sorting/#bubble-sort","title":"Bubble sort","text":"<p>Sortarea prin metoda bulelor sau bubble sort este un algoritm elementar de sortare care itereaz\u0103 prin valorile din vector c\u00e2t timp nu sunt ordonate \u0219i la fiecare pas al itera\u021biei, dac\u0103 g\u0103se\u0219te dou\u0103 valori adiacente ordonate contrar ordinii cerute, schimb\u0103 \u00eentre ele valorile \u0219i reseteaz\u0103 contorul folosit pentru a decide dac\u0103 algoritmul va trebui continuat dup\u0103 sf\u00e2r\u0219itul itera\u021biei curente a structurii repetitive.</p> <p>Observa\u021bie</p> <p>Num\u0103rul de interschimb\u0103ri f\u0103cut de algoritmul bubble sort este egal cu num\u0103rul de inversiuni al vectorului dat, observa\u021bie ce se va dovedi a fi foarte util\u0103 pentru multe con\u021binuturi mai avansate.</p> <pre><code>int v[1001], n;\nbool ok = true;\n\nwhile (ok == true) {\n    ok = false;\n\n    for (int i = 1; i &lt; n; i++) {\n        if (v[i] &gt; v[i + 1]) {\n            int aux = v[i];\n            v[i] = v[i + 1];\n            v[i + 1] = aux;\n            ok = false;\n        }\n    }\n}\n</code></pre>","tags":["sortare","optimizare"]},{"location":"usor/sorting/#insertion-sort","title":"Insertion sort","text":"<p>Sortarea prin inser\u021bie sau insertion sort este un algoritm elementar de sortare care pune pe r\u00e2nd fiecare valoare \u00eentre pozi\u021biile \\(2\\) \u0219i \\(n\\) pe pozi\u021bia potrivit\u0103 \u00een ordinea sortat\u0103 a valorilor p\u00e2n\u0103 la acea pozi\u021bie inclusiv.</p> <pre><code>int v[1001], n;\n\nfor (int i = 2; i &lt;= n; i++) {\n    for (int j = i - 1; j &gt;= 1; j--) {\n        if (v[j] &gt; v[j + 1]) {\n            int aux = v[j];\n            v[j] = v[j + 1];\n            v[j + 1] = aux;\n        }\n    }\n}\n</code></pre>","tags":["sortare","optimizare"]},{"location":"usor/sorting/#algoritmi-de-sortare-in-on-log-n","title":"Algoritmi de sortare \u00een \\(O(n \\log n)\\)","text":"<p>Dup\u0103 studiul algoritmilor de mai sus, o \u00eentrebare natural\u0103 se pune: putem sorta un \u0219ir mai repede de \\(O(n^2)\\)? R\u0103spunsul este unul afirmativ, exist\u00e2nd foarte mul\u021bi algoritmi de sortare mai rapizi, cei mai rapizi fiind cei \u00een \\(O(n \\log n)\\). </p> <p>De\u0219i \u00een practic\u0103 \u00een cadrul concursurilor, de regul\u0103 ajungem s\u0103 ne folosim de func\u021bia <code>std::sort</code>, propriet\u0103\u021bile celorlal\u021bi algoritmi pot fi utile pentru \u00een\u021belegerea anumitor concepte prezentate pe parcurs, iar pentru cititorii care se preg\u0103tesc pentru interviurile de angajare sau pentru admiterea la universit\u0103\u021bile de top din str\u0103inatate, pot ap\u0103rea \u00eentreb\u0103ri care s\u0103 con\u021bin\u0103 elemente ale \u00een\u021belegerii algoritmilor de sortare explica\u021bi mai jos.</p>","tags":["sortare","optimizare"]},{"location":"usor/sorting/#functia-stdsort","title":"Func\u021bia std::sort","text":"<p>Se poate spune c\u0103 de departe cea mai folosit\u0103 metod\u0103 de a ordona un \u0219ir \u00een timpul unei competi\u021bii este prin folosirea func\u021biei oferite de limbajul C++ pentru a sorta un \u0219ir, aceast\u0103 func\u021bie av\u00e2nd la spate algoritmul IntroSort, o combina\u021bie \u00eentre QuickSort, HeapSort \u0219i Insertion Sort care preia cele mai bune caracteristici ale celor trei algoritmi men\u021biona\u021bi. Aplicarea ei se va dovedi a fi banal\u0103, fiind nevoie de o singur\u0103 linie de cod.</p> <p>Pentru a scrie func\u021bia, trebuie s\u0103 \u0219tim adresa de \u00eenceput (de regul\u0103, pozi\u021bia \\(0\\) sau \\(1\\) din \u0219ir) \u0219i adresa de final, cea de final fiind incrementat\u0103 cu \\(1\\) deoarece intervalul pe care \u00eel vom folosi pentru func\u021bia descris\u0103 este \u00eenchis la st\u00e2nga \u0219i deschis la dreapta. Dup\u0103 cum se va observa mai jos, vom putea ad\u0103uga func\u021bii de comparare pentru a folosi <code>std::sort</code> la valoarea sa adev\u0103rat\u0103. Mai jos am ata\u0219at dou\u0103 exemple de aplicare a func\u021biei, pe vector indexat de la \\(0\\), respectiv \\(1\\).</p> <pre><code>int v[1001], n;\n\nsort(v + 1, v + n + 1);\n\nvector&lt;int&gt; vx(1002);\nsort(vx.begin(), vx.begin() + 500);\n\nvector&lt;int&gt; vy(2001);\nsort(vx.begin() + 1, vx.end());\n</code></pre>","tags":["sortare","optimizare"]},{"location":"usor/sorting/#quick-sort","title":"Quick Sort","text":"<p>QuickSort sau Sortarea rapid\u0103 este o metod\u0103 eficient\u0103 de sortare a unui tablou, descoperit\u0103 de programatorul britanic Tony Hoare. Pentru un set de \\(n\\) valori oarecare algoritmul efectueaz\u0103 \\(O(n \\log n)\\) compara\u021bii, dar \u00een cazul cel mai nefavorabil se efectueaz\u0103 \\(O(n^2)\\) compara\u021bii. De regul\u0103, acest algoritm este mai rapid dec\u00e2t merge sort sau heap sort at\u00e2ta timp c\u00e2t pivotul este ales favorabil, cazul cel mai nefavorabil va efectua mereu \\(O(n \\log n)\\) compara\u021bii.</p> <p>Algoritmul este de tip divide et impera; el sorteaz\u0103 o secven\u021b\u0103 a tabloului (ini\u021bial \u00eentreg tabloul), astfel:</p> <ul> <li>se alege un element special al listei, numit pivot;</li> <li>se ordoneaz\u0103 elementele listei, astfel \u00eenc\u00e2t toate elementele din st\u00e2nga pivotului s\u0103 fie mai mici sau egale cu acesta, \u0219i toate elementele din dreapta pivotului s\u0103 fie mai mari sau egale cu acesta;</li> <li>se continu\u0103 recursiv cu secven\u021ba din st\u00e2nga pivotului \u0219i cu cea din dreapta lui.</li> </ul> <p>Observa\u021bie</p> <p>Se recomand\u0103 alegerea pivotului \u00eentr-un mod aleator, deoarece alegerea pivotului \u00eentr-o pozi\u021bie previzibil\u0103 (la \u00eenceput, la mijloc sau la sf\u00e2r\u0219it duce la cazuri nefavorabile) poate duce la solu\u021bii care \u00een cel mai r\u0103u caz s\u0103 aib\u0103 o complexitate de \\(O(n^2)\\).</p> <pre><code>vector&lt;int&gt; quicksort (vector&lt;int&gt; v) {\n    if(v.size() == 0) {\n        return v;\n    }\n    ll pivot = 1LL * rand() * rand();\n    pivot %= (v.size());\n    vector&lt;int&gt; greater, smaller, a, b;\n    int same_value = 0;\n    for (int i = 0; i &lt; v.size(); ++i) {\n        if (v[i] &lt; v[pivot]) {\n            smaller.push_back(v[i]);\n        }\n        else {\n            if (v[i] == v[pivot]) {\n                ++same_value;\n            }\n            else {\n                greater.push_back(v[i]);\n            }\n        }\n    }\n    if (same_value == v.size()) {\n        return v;\n    }\n    a = quicksort(greater);\n    b = quicksort(smaller);\n    vector&lt;int&gt; answer;\n    for (int i = 0; i &lt; b.size(); ++i) {\n        answer.push_back(b[i]);\n    }\n    for (int i = 0; i &lt; same_value; ++i) {\n        answer.push_back(v[pivot]);\n    }\n    for (int i = 0; i &lt; a.size(); ++i) {\n        answer.push_back(a[i]);\n    }\n    return answer;\n}\n</code></pre>","tags":["sortare","optimizare"]},{"location":"usor/sorting/#merge-sort","title":"Merge Sort","text":"<p>MergeSort este o metod\u0103 eficient\u0103 de sortare a unui tablou, inventat\u0103 de programatorul John von Neumann. Pentru un set de \\(n\\) valori oarecare algoritmul efectueaz\u0103 \\(O(n \\log n)\\) compara\u021bii, algoritmul fiind acela\u0219i indiferent de modul \u00een care sunt a\u0219ezate valorile. Algoritmul func\u021bioneaz\u0103 \u00een felul urm\u0103tor.</p> <ul> <li>Avem lista curent\u0103, o \u00eemp\u0103r\u021bim \u00een dou\u0103 jum\u0103t\u0103\u021bi egale.</li> <li>Rul\u0103m algoritmul pe fiecare din cele dou\u0103 jum\u0103t\u0103\u021bi.</li> <li>Se interclaseaz\u0103 cele dou\u0103 \u0219iruri rezultate.</li> </ul> <p>Observa\u021bie</p> <p>Este de remarcat c\u0103 acest algoritm poate fi folosit pentru a calcula num\u0103rul de inversiuni al unui \u0219ir.</p> <pre><code>void mergesort (vector&lt;int&gt; &amp;v, int L, int R) {\n    if (L == R) {\n        return;\n    }\n\n    int mid = (L + R) / 2;\n    mergesort(v, L, mid);\n    mergesort(v, mid+1, R);\n\n    vector&lt;int&gt; sorted;\n    int Lx = L;\n    int Rx = mid + 1;\n    while (Lx &lt;= mid &amp;&amp; Rx &lt;= R) {\n        if (v[Lx] &lt;= v[Rx]) {\n            sorted.push_back(v[Lx]);\n            Lx++;\n        }\n        else {\n            sorted.push_back(v[Rx]);\n            Rx++;\n        }\n    }\n\n    while (Lx &lt;= mid) {\n        sorted.push_back(v[Lx]);\n        Lx++;\n    }\n    while (Rx &lt;= R) {\n        sorted.push_back(v[Rx]);\n        Rx++;\n    }\n    for (int i = L; i &lt;= R; i++) {\n        v[i] = sorted[i - L];\n    }\n}\n</code></pre>","tags":["sortare","optimizare"]},{"location":"usor/sorting/#heap-sort","title":"Heap Sort","text":"<p>Heap sort este un algoritm de sortare care la fiecare pas selecteaz\u0103 valoarea minim\u0103 folosind structura de date potrivit\u0103 (un heap, un arbore de intervale, un set etc.) \u0219i de aceea poate fi descris \u0219i drept un selection sort cu structura de date potrivit\u0103. La fiecare pas se afl\u0103 valoarea minim\u0103 din \u0219ir \u0219i se interschimb\u0103 valorile de pe cea mai din st\u00e2nga pozi\u021bie nefixat\u0103 cu valoarea de pe pozi\u021bia minim\u0103 g\u0103sit\u0103.</p> <p>Func\u021bia heapSort este apelat\u0103 din main folosind metoda heapSort, functia heapify fiind o func\u021bie auxiliar\u0103 care are drept scop plasarea valorii curente astfel \u00eenc\u00e2t s\u0103 se p\u0103streze structura de heap.  </p> <pre><code>void heapify(vector&lt;int&gt; &amp;v, int n, int pos)\n{\n    int largest = pos, l = 2 * pos + 1, r = 2 * pos + 2;\n    if (l &lt; n &amp;&amp; v[l] &gt; v[largest]) {\n        largest = l;\n    }\n    if (r &lt; n &amp;&amp; v[r] &gt; v[largest]) {\n        largest = r;\n    }\n    if(largest != pos) {\n        swap(v[pos], v[largest]);\n        heapify(v, n, largest);\n    }\n}\n\nvoid heapSort(vector&lt;int&gt; &amp;v, int n)\n{\n    for (int i = n/2 - 1; i &gt;= 0; i--) {\n        heapify(v, n, i);\n    }\n    for (int i = n - 1; i&gt;=0; i--) {\n        swap(v[0], v[i]);\n        heapify(v, i, 0);\n    }\n}\n</code></pre>","tags":["sortare","optimizare"]},{"location":"usor/sorting/#sortare-cu-comparator-special","title":"Sortare cu comparator special","text":"<p>Uneori, criteriul dup\u0103 care sort\u0103m un \u0219ir poate fi mai dificil de configurat de c\u0103tre <code>std::sort</code>, a\u0219a c\u0103 de multe ori suntem nevoi\u021bi s\u0103 implement\u0103m logica proprie de comparator. De cele mai multe ori, acesta va fi implementat drept o func\u021bie bool, care ia ca parametru dou\u0103 valori ale \u0219irului ce vrem s\u0103 \u00eel ordon\u0103m \u0219i le verific\u0103m folosind criteriul dorit. \u00cen secven\u021ba de mai jos, avem o structur\u0103 str \u0219i vom sorta datele de intrare din structur\u0103 folosind drept criteriu de comparare suma valorilor din pereche. Se poate observa faptul c\u0103 func\u021bia de comparare este apelat\u0103 de, \u00een acest caz, <code>std::sort</code>.</p> <pre><code>constexpr int N = 100;\n\nstruct Foo {\n    int a, b;\n};\n\nFoo v[N + 1];\n\nbool cmp(const Foo x, const Foo y) {\n    return (x.a + x.b) &lt; (y.a + y.b);\n}\n\nsort(v + 1, v + N + 1, cmp);\n\n// Alternativ (vom elabora \u00eentr-o lec\u021bie viitoare):\nvector&lt;Foo&gt; foos(N + 1);\n\nsort(foos.begin(), foos.end(),\n     [](const Foo x, const Foo y) {\n        return (x.a + x.b) &lt; (y.a + y.b);\n     });\n</code></pre>","tags":["sortare","optimizare"]},{"location":"usor/sorting/#sortarea-folosind-structuri-din-stl","title":"Sortarea folosind structuri din STL","text":"<p>De\u0219i aceast\u0103 metod\u0103 este mai \u00eenceat\u0103 comparat cu alte metode men\u021bionate anterior, merit\u0103 men\u021bionat\u0103 drept o utilizare suplimentar\u0103 a structurilor din STL. Structuri de date precum <code>std::map</code>, <code>std::set</code>, <code>std::multiset</code> sau <code>std::priority_queue</code> pot fi folosite cu succes pentru a simula aceste sort\u0103ri \u00een aceea\u0219i complexitate cu cea optim\u0103, dar cu o constant\u0103 mai slab\u0103, ceea ce nu le face practice atunci c\u00e2nd avem nevoie s\u0103 sort\u0103m datele rapid. </p> <p>Mai jos g\u0103si\u021bi un exemplu de implementare cu <code>std::multiset</code>.</p> <pre><code>multiset&lt;int&gt; s;\nfor (int i = 0; i &lt; n; i++) {\n    s.insert(v[i]);\n}\n\nvector &lt;int&gt; sorted;\nfor (auto x : s) {\n    sorted.push_back(x);\n}\n</code></pre>","tags":["sortare","optimizare"]},{"location":"usor/sorting/#algoritmi-speciali-de-sortare","title":"Algoritmi speciali de sortare","text":"","tags":["sortare","optimizare"]},{"location":"usor/sorting/#counting-sort","title":"Counting Sort","text":"<p>Counting sort este un algoritm de sortare folosit atunci c\u00e2nd avem un num\u0103r mic de elemente distincte, care pot fi \u021binute \u00eentr-un vector de frecven\u021b\u0103. Acest algoritm se poate folosi \u0219i dac\u0103 intervalul \u00een care sunt a\u0219ezate valorile este unul mic, complexitatea fiind \u00een ambele cazuri \\(O(n + k)\\), unde \\(n\\) este num\u0103rul de valori din \u0219ir, iar \\(k\\) este diferen\u021ba dintre cea mai mare \u0219i cea mai mic\u0103 valoare din \u0219ir.</p> <p>Observa\u021bie</p> <p>Este de remarcat c\u0103 acest algoritm poate fi implementat \u0219i folosind <code>std::map</code>, complexitatea de timp fiind mai mare cu \\(\\log n\\) din cauza opera\u021biilor specifice acestei structuri de date. </p> <pre><code>int n;\ncin &gt;&gt; n;\n\nvector &lt;int&gt; v(n);\nvector &lt;int&gt; frq(MAXVAL);\nfor (int i = 0; i &lt; n; i++) {\n    cin &gt;&gt; v[i];\n    frq[v[i]]++;\n}\n\nint pos = 0;\nfor (int i = 0; i &lt; MAXVAL; i++) {\n    while (frq[i]) {\n        v[pos] = i;\n        frq[i]--;\n        pos++;\n    }\n}\n</code></pre>","tags":["sortare","optimizare"]},{"location":"usor/sorting/#radix-sort","title":"Radix Sort","text":"<p>Radix sort este un algoritm de sortare folosit atunci c\u00e2nd vrem s\u0103 grup\u0103m elementele \u00een func\u021bie de cifrele lor, de la cea mai semnificativ\u0103 la cea mai nesemnificativ\u0103, acest algoritm fiind util \u00eentr-o serie de probleme ce implic\u0103[ prelucrarea cifrelor \u0219i numerelor \u00een diferite moduri.</p> <pre><code>void radix_sort(vector&lt;int&gt; v, int pwr) {\n    if (pwr == 0) {\n        for(int i = 0; i &lt; v.size(); ++i)\n            v2[poz++] = v[i];\n        return;\n    }\n    vector&lt;int&gt; a[10];\n    for (int i = 0; i &lt; v.size(); ++i) {\n        int val = v[i] % pwr;\n        if (pwr != 1) {\n            val /= (pwr/10);\n        }\n        a[val].push_back(v[i]);\n    }\n    for (int i = 0; i &lt; 10; ++i) {\n        if (!a[i].empty()) {\n            radix_sort(a[i], pwr/10);\n        }\n    }\n}\n</code></pre>","tags":["sortare","optimizare"]},{"location":"usor/sorting/#concluzii-si-probleme-suplimentare","title":"Concluzii \u0219i probleme suplimentare","text":"<p>Algoritmii de sortare sunt foarte utili pentru a \u00een\u021belege bazele multor algoritmi, diversele metode folosite reg\u0103sindu-se \u00een foarte multe tipuri de probleme, dar \u0219i \u00een anumite optimiz\u0103ri care pot fi g\u0103site pentru a evita tratarea anumitor probleme \u00eentr-o manier\u0103 prea generic\u0103.</p> <p>Ace\u0219ti algoritmi ajung s\u0103 fie folosi\u021bi \u00een foarte multe tipuri de probleme, cele mai frecvente fiind aplica\u021biile tip greedy dar \u0219i alte probleme \u00een care sortarea poate consta un pas spre a procesa mai u\u0219or datele de intrare, precum c\u0103utarea binar\u0103, diverse probleme ce implic\u0103 structuri de date \u0219i a\u0219a mai departe.</p>","tags":["sortare","optimizare"]},{"location":"usor/sorting/#probleme-de-la-olimpiade","title":"Probleme de la olimpiade","text":"<ul> <li>perechi kilonova</li> <li>Probleme cu sortari de pe pbinfo</li> <li>sir OJI 2005</li> <li>USACO Bronze Acowdemia I</li> <li>Pergament OJI 2023</li> <li>pseudocmp OJI 2022</li> <li>yinyang OJI 2019</li> <li>JOI 2018 Stove</li> <li>JOI 2018 Art Exhibition</li> <li>InfoPro insertsort</li> <li>probleme cu sortare de pe Kilonova</li> <li>High Card Low Card USACO Gold</li> </ul>","tags":["sortare","optimizare"]},{"location":"usor/sorting/#probleme-de-pe-alte-siteuri","title":"Probleme de pe alte siteuri","text":"<ul> <li>Distinct Numbers</li> <li>Movie Festival</li> <li>Towers</li> <li>Kayaking</li> <li>Movie Festival II</li> <li>Tasks and Deadlines</li> <li>Permutator</li> <li>Playing in a Casino</li> <li>The Party and Sweets</li> <li>USB vs. PS/2</li> </ul>","tags":["sortare","optimizare"]},{"location":"usor/sorting/#bibliografie-si-lectura-suplimentara","title":"Bibliografie \u0219i lectur\u0103 suplimentar\u0103","text":"<ul> <li>Introduction to Sorting - USACO Guide</li> <li>Greedy Algorithms with Sorting</li> <li>Sortarea prin num\u0103rare</li> <li>Tutorial Video RoAlgo</li> </ul>","tags":["sortare","optimizare"]}]}
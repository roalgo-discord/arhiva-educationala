{"config":{"lang":["ro"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Acas\u0103","text":"<p>Aici g\u0103si\u021bi Arhiva Educa\u021bional\u0103 creat\u0103 de comunitatea RoAlgo, centrat\u0103 \u00een jurul serverului de Discord cu acela\u0219i nume, RoAlgo fiind cea mai mare comunitate de algoritmic\u0103 din Rom\u00e2nia, cu peste 3000 de membri.</p> <p>Scopul acestui proiect este de a crea cea mai complet\u0103 arhiv\u0103 educa\u021bional\u0103 pentru un student interesat de programarea competitiv\u0103, concentr\u00e2ndu-se, de asemenea, pe subiectele care apar frecvent \u00een s\u0103lile de clas\u0103, concursurile \u0219i olimpiadele de informatic\u0103 din Rom\u00e2nia.</p>","tags":["arhiva","github","contribuire"]},{"location":"#ce-este-arhiva-educationala","title":"Ce este arhiva educa\u021bional\u0103?","text":"<p>Arhiva educa\u021bional\u0103 RoAlgo este f\u0103cut\u0103 cu scopul realiz\u0103ri unei surse de calitate despre algoritmi care s\u0103 fie folositori pentru toate nivelurile, fie c\u0103 e vorba de aprofundarea lor pentru orele de la clas\u0103, pentru examenele de bacalaureat \u0219i admitere, pentru participarea \u0219i ob\u021binerea de premii la olimpiada de informatic\u0103 \u0219i \u00een general pentru oricine e pasionat \u0219i vrea s\u0103 \u00eenve\u021be mai multe despre algoritmic\u0103, un domeniu tot mai important \u00een via\u021ba de zi cu zi, aici e locul potrivit pentru tine.</p>","tags":["arhiva","github","contribuire"]},{"location":"#ce-ne-propunem-sa-facem","title":"Ce ne propunem s\u0103 facem?","text":"<p>Acest proiect este unul care va fi mereu \u00een curs de \u00eembun\u0103t\u0103\u021bire, pe m\u0103sur\u0103 ce ajungem s\u0103 avem tot mai multe articole mai detaliate pentru o audien\u021b\u0103 tot mai mare, scopul nostru fiind acela de a ajunge la c\u00e2t mai multe persoane.</p> <p>Sper\u0103m c\u0103 \u00eentr-o zi, poate chiar \u0219i cu ajutorul t\u0103u, s\u0103 avem o serie de resurse \u00een limba rom\u00e2n\u0103, care s\u0103 fie la nivelul altor resurse de top f\u0103cute de pasiona\u021bi din alte \u021b\u0103ri, astfel ajut\u00e2nd \u0219i profesorii \u00een munca pe care o depun cu elevii lor.</p> <p>\u00centr-un viitor, ne propunem s\u0103 avem \u0219i sec\u021biuni cu solu\u021bii explicate la problemele \u0219i concursurile care nu au indica\u021bii detaliate, pe care s\u0103 le folosim cu scopul de a \u00eembun\u0103t\u0103\u021bi lista de resurse prezent\u0103 \u00een repo-ul nostru \u00een care am colectat solu\u021biile de la olimpiadele \u0219i concursurile rom\u00e2ne\u0219ti.</p> <p>De asemenea, vrem s\u0103 avem \u00eendeajuns de multe materiale care s\u0103 ajute orice persoan\u0103 s\u0103 poat\u0103 \u00een\u021belege algoritmica \u0219i s\u0103 poat\u0103 folosi cuno\u0219tin\u021bele de aici pentru a-\u0219i \u00eembun\u0103t\u0103\u021bi cuno\u0219tin\u021bele \u0219i abilit\u0103\u021bile de rezolvare a problemelor (nu doar cele de informatic\u0103!).</p>","tags":["arhiva","github","contribuire"]},{"location":"#de-ce-sa-contribui","title":"De ce s\u0103 contribui?","text":"<p>\u00cen primul r\u00e2nd, la fel ca toate celelalte proiecte ale noastre, suntem deschi\u0219i oric\u0103rei persoane care vrea s\u0103 ne ajute \u00een munca noastr\u0103 de a ajuta \u021bara noastr\u0103 s\u0103 r\u0103m\u00e2n\u0103 unul din juc\u0103torii importan\u021bi \u00een informatica european\u0103 \u0219i mondial\u0103.</p> <p>Contribu\u021bia ta va r\u0103m\u00e2ne important\u0103 pentru genera\u021biile viitoare \u0219i vei putea folosi efortul t\u0103u de aici pentru a-\u021bi certifica calit\u0103\u021bile tale \u00een acest domeniu, indiferent c\u0103 e vorba de o experien\u021b\u0103 de voluntariat, o viitoare carier\u0103 \u00een domeniul IT sau chiar \u00een educa\u021bie.</p> <p>Vei cunoa\u0219te o mul\u021bime de oameni minuna\u021bi, mul\u021bi dintre ei fiind chiar cei care c\u00e2\u0219tig\u0103 medalii an de an la competi\u021biile interna\u021bionale din partea Rom\u00e2niei.</p>","tags":["arhiva","github","contribuire"]},{"location":"#cum-poti-contribui","title":"Cum po\u021bi contribui?","text":"<p>Dac\u0103 vrei s\u0103 contribui la arhiva noastr\u0103 educa\u021bional\u0103, o po\u021bi face f\u0103c\u00e2nd un fork care s\u0103 plece din repo-ul nostru principal sau al\u0103tur\u00e2ndu-te serverului de Discord al arhivei noastre, \u00een cazul \u00een care \u00eent\u00e2mpini orice dificultate.</p> <p>\u00cen general, dac\u0103 crezi c\u0103 exist\u0103 articole, probleme, resurse sau alte materiale care merit\u0103 men\u021bionate, aici e locul potrivit unde po\u021bi \u00eenv\u0103\u021ba cum s\u0103 le adaugi \u00een arhiv\u0103, dar \u0219i s\u0103 \u00eenve\u021bi s\u0103 folose\u0219ti niste tooluri care te vor ajuta mult \u0219i pe viitor.</p> <p>Pentru cei curio\u0219i, aici pute\u021bi g\u0103si o list\u0103 cu articolele pe care le-am f\u0103cut, \u00eempreun\u0103 cu oameni care s-au asignat pe ele.</p> <p>Pe l\u00e2ng\u0103 articole noi, suntem mereu \u00een c\u0103utare de probleme interesante pe care s\u0103 le ad\u0103ug\u0103m \u00een articolele noastre \u0219i de \u00eembun\u0103t\u0103\u021biri ce se pot face la articolele existente.</p> <p>Nu \u00een ultimul r\u00e2nd, am fi recunosc\u0103tori dac\u0103 ne-a\u021bi promova proiectul la c\u00e2t mai mul\u021bi colegi, prieteni \u0219i profesori, pentru a ne atinge misiunea de a ajuta to\u021bi elevii din Rom\u00e2nia care studiaz\u0103 informatica.</p>","tags":["arhiva","github","contribuire"]},{"location":"#folosirea-markdown-si-latex","title":"Folosirea Markdown \u0219i LaTeX","text":"<p>Toate articolele noastre sunt scrise \u00een markdown, iar pentru nota\u021biile matematice, folosim LaTeX. \u00cen general, cele mai importante reguli constau \u00een folosirea nota\u021biilor specifice pentru diverse moduri de a eviden\u021bia textul.</p> <p>Pentru mai multe detalii, pute\u021bi accesa acest link.</p> <p>\u00cen ceea ce prive\u0219te LaTeX, pute\u021bi accesa acest link.</p> <p>Foarte multe lucruri se aseam\u0103n\u0103 cu stilul de pe Kilonova, pe care \u00eel pute\u021bi citi aici, la sec\u021biunea Statements.</p> <p>Pe l\u00e2ng\u0103 aceste sfaturi generale, trebuie remarcat\u0103 \u0219i structura specific\u0103 a articolelor noastre. Printre altele, avem comenzi specifice care ne ajut\u0103 s\u0103 marc\u0103m defini\u021bii, observa\u021bii, exemple \u0219i alte asemenea.  </p> <p>O alt\u0103 metod\u0103 de a \u00eenv\u0103\u021ba stilul nostru este aceea de a studia repoul nostru \u0219i articolele de acolo, iar dac\u0103 \u00eencerca\u021bi s\u0103 edita\u021bi un articol (f\u0103r\u0103 a modifica con\u021binutul din browser), ve\u021bi vedea sintaxa deja existent\u0103 \u0219i o pute\u021bi folosi \u0219i voi atunci c\u00e2nd ve\u021bi vrea s\u0103 eviden\u021bia\u021bi anumite aspecte ale articolelor scrise de voi.</p>","tags":["arhiva","github","contribuire"]},{"location":"#folosirea-github-si-git","title":"Folosirea GitHub \u0219i Git","text":"<p>Un alt aspect important este acela c\u0103 va trebui s\u0103 fi\u021bi familiari \u00eentr-o oarecare m\u0103sur\u0103 cu GitHub. Chiar dac\u0103 nu trebuie s\u0103 \u0219ti\u021bi foarte bine cum s\u0103 folosi\u021bi git \u0219i github, \u00eenv\u0103\u021barea acestor tooluri v\u0103 va fi util\u0103 \u0219i ulterior, \u00een special dac\u0103 ve\u021bi ajunge s\u0103 studia\u021bi \u00een domeniu (toate proiectele pe care le ve\u021bi face \u0219i le ve\u021bi \u00eenc\u0103rca acolo vor necesita cunoa\u0219terea Git).</p> <p>Mai specific, pentru a putea \u00eenc\u0103rca munca ta \u0219i a deveni parte a arhivei, trebuie s\u0103 te familiarizezi cu crearea unui branch \u0219i crearea unui pull request. Dup\u0103 ce faci pull request-ul, \u00ee\u021bi vom da feedbackul nostru \u0219i pe parcurs, te vom ajuta s\u0103 creezi un con\u021binut c\u00e2t mai bun.</p> <p>Un tutorial scurt \u0219i foarte bun este acesta.</p>","tags":["arhiva","github","contribuire"]},{"location":"licenta/","title":"Licen\u021b\u0103","text":"<p>Con\u021binutul acestui proiect este licen\u021biat sub Creative Commons Attribution-NonCommercial-ShareAlike (CC BY-NC-SA). Pute\u021bi copia, distribui \u0219i modifica materialul nostru at\u00e2ta timp c\u00e2t ne men\u021biona\u021bi ca surs\u0103, nu folosi\u021bi materialul \u00een scopuri comerciale \u0219i distribui\u021bi lucr\u0103rile derivate sub aceea\u0219i licen\u021b\u0103. Pentru detalii, consulta\u021bi licen\u021ba complet\u0103 aici.</p> <p>Codul scris pentru acest proiect este licen\u021biat sub European Union Public License versiunea 1.2 (EUPL v1.2). Aceasta v\u0103 permite s\u0103 folosi\u021bi, modifica\u021bi \u0219i distribui\u021bi codul, cu condi\u021bia ca orice lucrare derivat\u0103 s\u0103 fie distribuit\u0103 sub aceea\u0219i licen\u021b\u0103. Pentru detalii, consulta\u021bi licen\u021ba complet\u0103 aici.</p>"},{"location":"avansat/2-sat/","title":"2-SAT","text":"<p>Daca vreti sa ne ajutati cu acest articol, ne puteti gasi pe github sau pe serverul nostru de discord</p> <p>Mai jos g\u0103si\u021bi resurse pe care le pute\u021bi citi p\u00e2n\u0103 atunci.</p>","tags":["grafuri","tare conexe","optimizare"]},{"location":"avansat/2-sat/#introducere","title":"Introducere","text":"","tags":["grafuri","tare conexe","optimizare"]},{"location":"avansat/2-sat/#problema-exemplu","title":"Problema exemplu","text":"","tags":["grafuri","tare conexe","optimizare"]},{"location":"avansat/2-sat/#concluzii","title":"Concluzii","text":"","tags":["grafuri","tare conexe","optimizare"]},{"location":"avansat/2-sat/#probleme-suplimentare","title":"Probleme suplimentare","text":"","tags":["grafuri","tare conexe","optimizare"]},{"location":"avansat/2-sat/#resurse-suplimentare","title":"Resurse suplimentare","text":"<ul> <li>2-SAT - CP-algorithms</li> <li>2-SAT - USACO Guide</li> </ul>","tags":["grafuri","tare conexe","optimizare"]},{"location":"avansat/advanced-math/","title":"Matematic\u0103 avansat\u0103","text":"<p>Daca vreti sa ne ajutati cu acest articol, ne puteti gasi pe github sau pe serverul nostru de discord</p> <p>Mai jos g\u0103si\u021bi resurse pe care le pute\u021bi citi p\u00e2n\u0103 atunci.</p>","tags":["matematica"]},{"location":"avansat/advanced-math/#introducere","title":"Introducere","text":"","tags":["matematica"]},{"location":"avansat/advanced-math/#problema-exemplu","title":"Problema exemplu","text":"<p>s</p>","tags":["matematica"]},{"location":"avansat/advanced-math/#concluzii","title":"Concluzii","text":"","tags":["matematica"]},{"location":"avansat/advanced-math/#probleme-suplimentare","title":"Probleme suplimentare","text":"","tags":["matematica"]},{"location":"avansat/advanced-math/#resurse-suplimentare","title":"Resurse suplimentare","text":"","tags":["matematica"]},{"location":"avansat/aho-corasick/","title":"Aho-Corasick","text":"<p>Daca vreti sa ne ajutati cu acest articol, ne puteti gasi pe github sau pe serverul nostru de discord</p> <p>Mai jos g\u0103si\u021bi resurse pe care le pute\u021bi citi p\u00e2n\u0103 atunci.</p>","tags":["structuri de date","siruri de caractere","automate"]},{"location":"avansat/aho-corasick/#introducere","title":"Introducere","text":"","tags":["structuri de date","siruri de caractere","automate"]},{"location":"avansat/aho-corasick/#problema-exemplu","title":"Problema exemplu","text":"","tags":["structuri de date","siruri de caractere","automate"]},{"location":"avansat/aho-corasick/#concluzii","title":"Concluzii","text":"","tags":["structuri de date","siruri de caractere","automate"]},{"location":"avansat/aho-corasick/#probleme-suplimentare","title":"Probleme suplimentare","text":"","tags":["structuri de date","siruri de caractere","automate"]},{"location":"avansat/aho-corasick/#resurse-suplimentare","title":"Resurse suplimentare","text":"","tags":["structuri de date","siruri de caractere","automate"]},{"location":"avansat/aliens-dp/","title":"Aliens DP","text":"<p>Daca vreti sa ne ajutati cu acest articol, ne puteti gasi pe github sau pe serverul nostru de discord</p> <p>Mai jos g\u0103si\u021bi resurse pe care le pute\u021bi citi p\u00e2n\u0103 atunci.</p>","tags":["programare dinamica","optimizare"]},{"location":"avansat/aliens-dp/#introducere","title":"Introducere","text":"","tags":["programare dinamica","optimizare"]},{"location":"avansat/aliens-dp/#problema-exemplu","title":"Problema exemplu","text":"","tags":["programare dinamica","optimizare"]},{"location":"avansat/aliens-dp/#concluzii","title":"Concluzii","text":"","tags":["programare dinamica","optimizare"]},{"location":"avansat/aliens-dp/#probleme-suplimentare","title":"Probleme suplimentare","text":"<ul> <li>Codeforces Pictures with Kittens</li> </ul>","tags":["programare dinamica","optimizare"]},{"location":"avansat/aliens-dp/#resurse-suplimentare","title":"Resurse suplimentare","text":"<ul> <li>Attack on Aliens</li> <li>WQS Binary Search - robert1003 - un alt nume pentru Aliens DP in China</li> <li>The Trick from Aliens - Serbanology</li> <li>Lagrangian Relaxation - USACO Guide</li> </ul>","tags":["programare dinamica","optimizare"]},{"location":"avansat/centroid-decomposition/","title":"Centroid decomposition","text":"<p>Daca vreti sa ne ajutati cu acest articol, ne puteti gasi pe github sau pe serverul nostru de discord</p> <p>Mai jos g\u0103si\u021bi resurse pe care le pute\u021bi citi p\u00e2n\u0103 atunci.</p>","tags":["arbori","structuri de date","optimizare"]},{"location":"avansat/centroid-decomposition/#introducere","title":"Introducere","text":"","tags":["arbori","structuri de date","optimizare"]},{"location":"avansat/centroid-decomposition/#problema-exemplu","title":"Problema exemplu","text":"","tags":["arbori","structuri de date","optimizare"]},{"location":"avansat/centroid-decomposition/#concluzii","title":"Concluzii","text":"","tags":["arbori","structuri de date","optimizare"]},{"location":"avansat/centroid-decomposition/#probleme-suplimentare","title":"Probleme suplimentare","text":"","tags":["arbori","structuri de date","optimizare"]},{"location":"avansat/centroid-decomposition/#resurse-suplimentare","title":"Resurse suplimentare","text":"<ul> <li>Centroid Decomposition - USACO Guide</li> <li>Centroid Decomposition - robert1003</li> </ul>","tags":["arbori","structuri de date","optimizare"]},{"location":"avansat/component-dp/","title":"Component DP","text":"<p>Daca vreti sa ne ajutati cu acest articol, ne puteti gasi pe github sau pe serverul nostru de discord</p> <p>Mai jos g\u0103si\u021bi resurse pe care le pute\u021bi citi p\u00e2n\u0103 atunci.</p>","tags":["programare dinamica","optimizare"]},{"location":"avansat/component-dp/#introducere","title":"Introducere","text":"","tags":["programare dinamica","optimizare"]},{"location":"avansat/component-dp/#problema-exemplu","title":"Problema exemplu","text":"","tags":["programare dinamica","optimizare"]},{"location":"avansat/component-dp/#concluzii","title":"Concluzii","text":"","tags":["programare dinamica","optimizare"]},{"location":"avansat/component-dp/#probleme-suplimentare","title":"Probleme suplimentare","text":"","tags":["programare dinamica","optimizare"]},{"location":"avansat/component-dp/#resurse-suplimentare","title":"Resurse suplimentare","text":"","tags":["programare dinamica","optimizare"]},{"location":"avansat/convex-hull-trick/","title":"Convex Hull Trick","text":"<p>Daca vreti sa ne ajutati cu acest articol, ne puteti gasi pe github sau pe serverul nostru de discord</p> <p>Mai jos g\u0103si\u021bi resurse pe care le pute\u021bi citi p\u00e2n\u0103 atunci.</p>","tags":["programare dinamica","optimizare","stiva","sortare"]},{"location":"avansat/convex-hull-trick/#introducere","title":"Introducere","text":"","tags":["programare dinamica","optimizare","stiva","sortare"]},{"location":"avansat/convex-hull-trick/#problema-exemplu","title":"Problema exemplu","text":"","tags":["programare dinamica","optimizare","stiva","sortare"]},{"location":"avansat/convex-hull-trick/#concluzii","title":"Concluzii","text":"","tags":["programare dinamica","optimizare","stiva","sortare"]},{"location":"avansat/convex-hull-trick/#probleme-suplimentare","title":"Probleme suplimentare","text":"","tags":["programare dinamica","optimizare","stiva","sortare"]},{"location":"avansat/convex-hull-trick/#resurse-suplimentare","title":"Resurse suplimentare","text":"<ul> <li>Convex Hull Trick - Jeffrey Xiao</li> <li>Convex Hull Optimization - robert1003</li> </ul>","tags":["programare dinamica","optimizare","stiva","sortare"]},{"location":"avansat/crt/","title":"Teorema chinez\u0103 a resturilor (CRT)","text":"<p>Daca vreti sa ne ajutati cu acest articol, ne puteti gasi pe github sau pe serverul nostru de discord</p> <p>Mai jos g\u0103si\u021bi resurse pe care le pute\u021bi citi p\u00e2n\u0103 atunci.</p>","tags":["matematica","teoria numerelor"]},{"location":"avansat/crt/#introducere","title":"Introducere","text":"","tags":["matematica","teoria numerelor"]},{"location":"avansat/crt/#problema-exemplu","title":"Problema exemplu","text":"","tags":["matematica","teoria numerelor"]},{"location":"avansat/crt/#concluzii","title":"Concluzii","text":"","tags":["matematica","teoria numerelor"]},{"location":"avansat/crt/#probleme-suplimentare","title":"Probleme suplimentare","text":"","tags":["matematica","teoria numerelor"]},{"location":"avansat/crt/#resurse-suplimentare","title":"Resurse suplimentare","text":"","tags":["matematica","teoria numerelor"]},{"location":"avansat/dc-dp/","title":"D&C DP (optimizarea divide et impera)","text":"","tags":["programare dinamica","optimizare","divide et impera"]},{"location":"avansat/dc-dp/#introducere","title":"Introducere","text":"<p>S\u0103 consider\u0103m o dinamic\u0103 cu urm\u0103toarea formul\u0103:</p> \\[ dp(i,j) = \\min_{0\\leq k \\leq j} ( dp(i-1, k-1) + C(k,j)), \\] <p>unde \\(C(i,j)\\) este o func\u021bie de cost care poate fi calculat\u0103 \u00een \\(O(1)\\). De asemenea, \\(dp(i,j) =0\\) pentru \\(j&lt;0\\).</p> <p>O implementare simpl\u0103 ne-ar da o complexitate de \\(O(M \\cdot N^2)\\) dac\u0103 \\(0 \\leq i &lt; M\\) \u0219i \\(0\\leq j &lt; N\\), deci se impune g\u0103sirea unei optimiz\u0103ri care s\u0103 \u00eembun\u0103t\u0103\u021beasc\u0103 solu\u021bia.</p> <p>\u00cen cele ce urmeaz\u0103, vom prezenta tehnica Divide &amp; Conquer DP, care ne va permite s\u0103 optimiz\u0103m aceast\u0103 dinamic\u0103 la \\(O(M \\cdot N \\log N)\\).</p> <p>Mai \u00eent\u00e2i, vom defini pentru un \\((i, j)\\) oarecare \\(\\text{opt}(i,j)\\) ca fiind valoarea care minimizeaz\u0103 expresia din ecua\u021bie. Astfel, D&amp;C DP se aplic\u0103 doar dac\u0103 \\(\\text{opt}(i,j) \\leq \\text{opt}(i,j+1).\\)</p> <p>De multe ori, demonstra\u021bia poate fi dificil de g\u0103sit, dar dac\u0103 func\u021bia de cost respect\u0103 quadrangle inequality, condi\u021bia se aplic\u0103.</p> <p>Observa\u021bie</p> <p>De multe ori, dac\u0103 crede\u021bi c\u0103 problema pe care o rezolva\u021bi are o asemenea optimizare \u00een spate, pute\u021bi \u00eencepe prin a scrie o solu\u021bie brut\u0103, iar dac\u0103 \\(\\text{opt}(i,j) \\leq \\text{opt}(i,j+1).\\) se aplic\u0103, sunt \u0219anse mari s\u0103 pute\u021bi folosi aceast\u0103 optimizare cu destul de mult succes.</p> <p>Astfel, vom putea aplica ideea din spatele divide et impera. Pentru un interval \\((L, R)\\), \u0219tim punctele posibile care pot fi optime \\((opt_L, opt_R)\\). Astfel, vom \u00eencerca s\u0103 calcul\u0103m dinamica pentru valoarea din mijloc, iar \u00een func\u021bie de valoarea optim\u0103 g\u0103sit\u0103 (o not\u0103m \\(opt\\)), vom \u00eemp\u0103r\u021bi intervalele recursiv \u00een dou\u0103, dup\u0103 cum urmeaz\u0103:</p> <ul> <li>\\((L, mid-1)\\), respectiv \\((opt_L, opt)\\)</li> <li>\\((mid+1, R)\\), respectiv \\((opt, opt_R)\\).</li> </ul> <p>Vom continua acest lucru p\u00e2n\u0103 c\u00e2nd ajungem la intervale unitare, caz \u00een care ne vom opri.</p> <p>Deoarece fiecare valoare a \\(\\text{opt}(i, j)\\) apare de \\(O(\\log n)\\) ori, vom avea o complexitate final\u0103 de \\(O(mn \\log n)\\).</p>","tags":["programare dinamica","optimizare","divide et impera"]},{"location":"avansat/dc-dp/#problema-exemplu-subarray-squares-cses","title":"Problema exemplu - Subarray Squares CSES","text":"<p>Observa\u021bie</p> <p>Aceast\u0103 problem\u0103 are \u0219i o solu\u021bie video postat\u0103 de Algorithms Conquered aici.</p> <p>Pentru a rezolva aceast\u0103 problem\u0103, ne putem g\u00e2ndi mai \u00eent\u00e2i la o dinamic\u0103 simpl\u0103 dar care este prea \u00eenceat\u0103, \u00een stilul celei descrise mai devreme \u00een articol.</p> <p>Totu\u0219i, se poate observa c\u0103 proprietatea legat\u0103 de valorile optime pentru fiecare stare se respect\u0103, ceea ce ne duce cu g\u00e2ndul la aplicarea tehnicii D&amp;C pentru implementarea acestei probleme.</p> <p>Recomand\u0103m citirea implement\u0103rii de mai jos, deoarece este una educa\u021bional\u0103 \u0219i instructiv\u0103 \u0219i pentru celelalte probleme pe care le ve\u021bi rezolva folosind aceast\u0103 tehnic\u0103.</p> <pre><code>#include &lt;iostream&gt;\n#include &lt;vector&gt;\n\nstd::vector&lt;std::vector&lt;long long&gt;&gt; dp, sq;\n\nvoid divide(int layer, int L, int R, int optL, int optR) {\n    if (L &gt; R) {\n        return;\n    }\n    long long bst = (1LL &lt;&lt; 60);\n    int whoo = -1;\n    int mid = (L + R) / 2;\n    for (int i = optL; i &lt;= std::min(mid - 1, optR); i++) {\n        if (dp[layer - 1][i] + sq[i + 1][mid] &lt; bst) {\n            bst = dp[layer - 1][i] + sq[i + 1][mid];\n            whoo = i;\n        }\n    }\n    dp[layer][mid] = bst;\n    divide(layer, L, mid - 1, optL, whoo);\n    divide(layer, mid + 1, R, whoo, optR);\n}\n\nint main() {\n    int n, k;\n    std::cin &gt;&gt; n &gt;&gt; k;\n\n    std::vector&lt;int&gt; v(n + 1);\n    for (int i = 1; i &lt;= n; i++) {\n        std::cin &gt;&gt; v[i];\n    }\n\n    dp.resize(k + 1, std::vector&lt;long long&gt;(n + 1));\n    sq.resize(n + 1, std::vector&lt;long long&gt;(n + 1));\n\n    for (int i = 1; i &lt;= n; i++) {\n        int sum = 0;\n        for (int j = i; j &lt;= n; j++) {\n            sum += v[j];\n            sq[i][j] = 1LL * sum * sum;\n        }\n    }\n\n    for (int i = 1; i &lt;= n; i++) {\n        dp[1][i] = sq[1][i];\n    }\n\n    for (int i = 2; i &lt;= k; i++) {\n        for (int pos = 0; pos + 1 &lt; i; pos++) {\n            dp[i - 1][pos] = (1LL &lt;&lt; 60);\n        }\n        divide(i, i, n, i - 1, n);\n    }\n\n    std::cout &lt;&lt; dp[k][n] &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["programare dinamica","optimizare","divide et impera"]},{"location":"avansat/dc-dp/#problema-roalgo-contest-7-suxumetre","title":"Problema RoAlgo Contest #7 suxumetre","text":"<p>Observa\u021bie</p> <p>Acest editorial a fost scris de Matei Ionescu \u0219i Andrei Chertes ca parte a RoAlgo Contest #7</p> <p>Dinamicele de genul sunt foarte clasice, chiar au o optimizare foarte fain\u0103. Pentru un dp cum ar fi \\(dp_{i, j} = min(dp_{i - 1, k} + C(k + 1, j)\\), not\u0103m \\(opt(i, j)\\) ca fiind \"the optimum splitting point\" \u0219i egal cu \\(k\\)-ul care minimizeaz\u0103 \\(dp_{i, j}\\).</p> <p>Atunci putem spune c\u0103 \\(opt(i, j - 1) \\leq opt(i, j)\\) pentru oricare \\((i, j)\\) doar dac\u0103 oricum am alege patru indici \\((a, b, c, d), C(a, b) + C(b, d) \\leq C(a, d) + C(b, c)\\);</p> \\[C(x, y) = \\sum_{x \\leq i \\leq j \\leq y}{}sp(i, j) \\text{, unde } sp(i, j) = \\sum_{k = i}^{j}v_k\\mod{m}\\] <p>Conform defini\u021biei avem \\(sp(x, y) \\geq 0\\) \u0219i \\(C(x, y) \\geq 0\\).</p> <p></p> <p>\u00cen primul r\u00e2nd, vom analiza ce intervale contribuie la costurile din inegalitatea de mai sus. Distingem trei tipuri de intervale:</p> <ul> <li>interval ro\u0219u: inclus \u00een \\([a, c]\\) sau \\([b, d]\\), dar nu \u00een \\([b, c]\\).</li> <li>interval albastru: inclus \u00een \\([b, c]\\).</li> <li>interval verde: inclus \u00een \\([a, d]\\), dar nu \u00een \\([a, c]\\) sau \\([b, d]\\).</li> </ul> <p>Vom scrie membrul st\u00e2ng \u0219i membrul drept al inegalit\u0103\u021bii \u00een func\u021bie de cele trei tipuri de intervale:</p> <ul> <li>\\(C(a, c) + C(b, d) = \\sum sp(interval_{ro\u0219u}) + 2 \\sum sp(interval_{albastru})\\)</li> <li>\\(C(a, d) + C(b, c) = \\sum sp(interval_{ro\u0219u}) + 2 \\sum sp(interval_{albastru}) + \\sum sp(interval_{verde})\\)</li> <li>\\(C(a, c) + C(b, d) \\leq C(a, d) + C(b, c) \\Leftrightarrow 0 \\leq \\sum sp(interval_{verde})\\)</li> </ul> <p>ceea ce este adev\u0103rat din defini\u021bia func\u021biei \\(sp(x, y)\\).</p> <p>Putem deci s\u0103 dezvolt\u0103m un algoritm tip \"divide and conquer\", unde vom \u00eemp\u0103r\u021bi succesiv vectorul \u00een dou\u0103 intervale \\([st, mij], [mij + 1, dr]\\) \u0219i s\u0103 calcul\u0103m dinamica pentru \\(mij\\) \u00een intervalul \\([opt(i, st), opt(i, dr)]\\).</p> <p>Complexitatea final\u0103 va fi astfel \\(O(k \\cdot n \\ log \\ n)\\).</p> <pre><code>#include &lt;iostream&gt;\n\nconst int N = 5e3 + 1;\n\nlong long cnt[N][N], dp[N][N];\nint n, k, p, m;\nint v[N];\n\nvoid dnc(int k, int l, int r, int optl, int optr) {\n    if (l &gt; r) {\n        return;\n    }\n    int tm = (l + r) / 2;\n    std::pair&lt;long long, int&gt; opt(1e18, 0);\n    for (int i = optl; i &lt;= std::min(tm - 1, optr); i++) {\n        opt = std::min(opt, {1LL * dp[k - 1][i] + cnt[i + 1][tm], i});\n    }\n    dp[k][tm] = opt.first;\n    dnc(k, l, tm - 1, optl, opt.second);\n    dnc(k, tm + 1, r, opt.second, optr);\n}\n\nint main() {\n    std::cin.tie(0)-&gt;sync_with_stdio(0);\n    std::cin &gt;&gt; n &gt;&gt; k &gt;&gt; m;\n\n    for (int i = 1; i &lt;= n; i++) {\n        std::cin &gt;&gt; v[i];\n    }\n    for (int i = 1; i &lt;= n; i++) {\n        int fr[30] = {0};\n        fr[0] = 1;\n        long long sm = 0;\n        for (int j = i; j &lt;= n; j++) {\n            sm += v[j];\n            int l = sm % m;\n            cnt[i][j] += cnt[i][j - 1];\n            for (int f = 0; f &lt; m; f++) {\n                cnt[i][j] += f * fr[(l + m - f) % m];\n            }\n            fr[l]++;\n        }\n    }\n\n    for (int i = 1; i &lt;= n; i++) {\n        dp[1][i] = cnt[1][i];\n    }\n    for (int i = 2; i &lt;= k; i++) {\n        dnc(i, 1, n, 0, n - 1);\n    }\n\n    std::cout &lt;&lt; dp[k][n] &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["programare dinamica","optimizare","divide et impera"]},{"location":"avansat/dc-dp/#concluzii","title":"Concluzii","text":"<p>Aceast\u0103 tehnic\u0103 este una foarte des \u00eent\u00e2lnit\u0103 \u00een ceea ce prive\u0219te optimiz\u0103rile de programarea dinamic\u0103, fiind relativ u\u0219or de \u00een\u021beles dup\u0103 ce a\u021bi c\u0103p\u0103tat suficient\u0103 experien\u021b\u0103 cu celelate tehnici specifice program\u0103rii dinamice.</p> <p>Recomand\u0103m \u0219i abordarea problemelor de mai jos, precum \u0219i a articolelor suplimentare care cuprind multe explica\u021bii la problemele suplimentare \u0219i nu numai.</p>","tags":["programare dinamica","optimizare","divide et impera"]},{"location":"avansat/dc-dp/#probleme-suplimentare","title":"Probleme suplimentare","text":"<ul> <li>Infoarena cubeon</li> <li>ONI 2006 Petrom</li> <li>Codeforces Ciel and Gondolas</li> <li>Atcoder Yakiniku Restaurants</li> <li>Codeforces Yet Another Minimization Problem</li> <li>USACO Platinum Circular Barn</li> <li>USACO Platinum Mowing Mischief</li> <li>COI 2015 Nafta</li> <li>Codeforces Trucks and Cities</li> <li>JOI 2013 Bubblesort</li> <li>IOI 2014 Holiday</li> <li>Codeforces Partition Game</li> </ul>","tags":["programare dinamica","optimizare","divide et impera"]},{"location":"avansat/dc-dp/#resurse-suplimentare","title":"Resurse suplimentare","text":"<ul> <li>Divide and Conquer DP - USACO Guide</li> <li>Dynamic Programming Optimizations - Codeforces</li> <li>Quadrangle Inequality Properties - codeforces</li> <li>DP Optimizations - HKOI</li> <li>Divide and Conquer DP - cp-algorithms</li> <li>Divide and Conquer DP - Jeffrey Xiao</li> <li>DP optimization - Divide and Conquer Optimization - Robert1003</li> </ul>","tags":["programare dinamica","optimizare","divide et impera"]},{"location":"avansat/dynamic-connectivity/","title":"Dynamic connectivity","text":"<p>Daca vreti sa ne ajutati cu acest articol, ne puteti gasi pe github sau pe serverul nostru de discord</p> <p>Mai jos g\u0103si\u021bi resurse pe care le pute\u021bi citi p\u00e2n\u0103 atunci.</p>","tags":["grafuri","structuri de date","optimizare"]},{"location":"avansat/dynamic-connectivity/#introducere","title":"Introducere","text":"","tags":["grafuri","structuri de date","optimizare"]},{"location":"avansat/dynamic-connectivity/#problema-exemplu","title":"Problema exemplu","text":"","tags":["grafuri","structuri de date","optimizare"]},{"location":"avansat/dynamic-connectivity/#concluzii","title":"Concluzii","text":"","tags":["grafuri","structuri de date","optimizare"]},{"location":"avansat/dynamic-connectivity/#probleme-suplimentare","title":"Probleme suplimentare","text":"","tags":["grafuri","structuri de date","optimizare"]},{"location":"avansat/dynamic-connectivity/#resurse-suplimentare","title":"Resurse suplimentare","text":"","tags":["grafuri","structuri de date","optimizare"]},{"location":"avansat/fft/","title":"FFT, NTT etc.","text":"<p>Daca vreti sa ne ajutati cu acest articol, ne puteti gasi pe github sau pe serverul nostru de discord</p> <p>Mai jos g\u0103si\u021bi resurse pe care le pute\u021bi citi p\u00e2n\u0103 atunci.</p>","tags":["matematica","polinoame"]},{"location":"avansat/fft/#introducere","title":"Introducere","text":"","tags":["matematica","polinoame"]},{"location":"avansat/fft/#problema-exemplu","title":"Problema exemplu","text":"","tags":["matematica","polinoame"]},{"location":"avansat/fft/#concluzii","title":"Concluzii","text":"","tags":["matematica","polinoame"]},{"location":"avansat/fft/#probleme-suplimentare","title":"Probleme suplimentare","text":"","tags":["matematica","polinoame"]},{"location":"avansat/fft/#resurse-suplimentare","title":"Resurse suplimentare","text":"","tags":["matematica","polinoame"]},{"location":"avansat/fluxuri/","title":"Fluxuri","text":"<p>Daca vreti sa ne ajutati cu acest articol, ne puteti gasi pe github sau pe serverul nostru de discord</p> <p>Mai jos g\u0103si\u021bi resurse pe care le pute\u021bi citi p\u00e2n\u0103 atunci.</p>","tags":["grafuri","fluxuri"]},{"location":"avansat/fluxuri/#introducere","title":"Introducere","text":"","tags":["grafuri","fluxuri"]},{"location":"avansat/fluxuri/#problema-exemplu","title":"Problema exemplu","text":"","tags":["grafuri","fluxuri"]},{"location":"avansat/fluxuri/#concluzii","title":"Concluzii","text":"","tags":["grafuri","fluxuri"]},{"location":"avansat/fluxuri/#probleme-suplimentare","title":"Probleme suplimentare","text":"","tags":["grafuri","fluxuri"]},{"location":"avansat/fluxuri/#resurse-suplimentare","title":"Resurse suplimentare","text":"","tags":["grafuri","fluxuri"]},{"location":"avansat/game-theory/","title":"Teoria jocurilor","text":"<p>Daca vreti sa ne ajutati cu acest articol, ne puteti gasi pe github sau pe serverul nostru de discord</p> <p>Mai jos g\u0103si\u021bi resurse pe care le pute\u021bi citi p\u00e2n\u0103 atunci.</p>","tags":["jocuri","nim","sprague-grundy"]},{"location":"avansat/game-theory/#introducere","title":"Introducere","text":"","tags":["jocuri","nim","sprague-grundy"]},{"location":"avansat/game-theory/#problema-exemplu","title":"Problema exemplu","text":"","tags":["jocuri","nim","sprague-grundy"]},{"location":"avansat/game-theory/#concluzii","title":"Concluzii","text":"","tags":["jocuri","nim","sprague-grundy"]},{"location":"avansat/game-theory/#probleme-suplimentare","title":"Probleme suplimentare","text":"","tags":["jocuri","nim","sprague-grundy"]},{"location":"avansat/game-theory/#resurse-suplimentare","title":"Resurse suplimentare","text":"","tags":["jocuri","nim","sprague-grundy"]},{"location":"avansat/gauss-algorithm/","title":"Algoritmul lui Gauss","text":"<p>Daca vreti sa ne ajutati cu acest articol, ne puteti gasi pe github sau pe serverul nostru de discord</p> <p>Mai jos g\u0103si\u021bi resurse pe care le pute\u021bi citi p\u00e2n\u0103 atunci.</p>","tags":["matematica","algebra liniara","optimizare"]},{"location":"avansat/gauss-algorithm/#introducere","title":"Introducere","text":"","tags":["matematica","algebra liniara","optimizare"]},{"location":"avansat/gauss-algorithm/#problema-exemplu","title":"Problema exemplu","text":"","tags":["matematica","algebra liniara","optimizare"]},{"location":"avansat/gauss-algorithm/#concluzii","title":"Concluzii","text":"","tags":["matematica","algebra liniara","optimizare"]},{"location":"avansat/gauss-algorithm/#probleme-suplimentare","title":"Probleme suplimentare","text":"","tags":["matematica","algebra liniara","optimizare"]},{"location":"avansat/gauss-algorithm/#resurse-suplimentare","title":"Resurse suplimentare","text":"","tags":["matematica","algebra liniara","optimizare"]},{"location":"avansat/generating-functions/","title":"Func\u021bii generatoare","text":"<p>Daca vreti sa ne ajutati cu acest articol, ne puteti gasi pe github sau pe serverul nostru de discord</p> <p>Mai jos g\u0103si\u021bi resurse pe care le pute\u021bi citi p\u00e2n\u0103 atunci.</p>","tags":["matematica","recurente","optimizare"]},{"location":"avansat/generating-functions/#introducere","title":"Introducere","text":"","tags":["matematica","recurente","optimizare"]},{"location":"avansat/generating-functions/#problema-exemplu","title":"Problema exemplu","text":"","tags":["matematica","recurente","optimizare"]},{"location":"avansat/generating-functions/#concluzii","title":"Concluzii","text":"","tags":["matematica","recurente","optimizare"]},{"location":"avansat/generating-functions/#probleme-suplimentare","title":"Probleme suplimentare","text":"","tags":["matematica","recurente","optimizare"]},{"location":"avansat/generating-functions/#resurse-suplimentare","title":"Resurse suplimentare","text":"","tags":["matematica","recurente","optimizare"]},{"location":"avansat/gray-codes/","title":"Coduri Gray","text":"<p>Daca vreti sa ne ajutati cu acest articol, ne puteti gasi pe github sau pe serverul nostru de discord</p> <p>Mai jos g\u0103si\u021bi resurse pe care le pute\u021bi citi p\u00e2n\u0103 atunci.</p>","tags":["matematica","optimizare"]},{"location":"avansat/gray-codes/#introducere","title":"Introducere","text":"","tags":["matematica","optimizare"]},{"location":"avansat/gray-codes/#problema-exemplu","title":"Problema exemplu","text":"","tags":["matematica","optimizare"]},{"location":"avansat/gray-codes/#concluzii","title":"Concluzii","text":"","tags":["matematica","optimizare"]},{"location":"avansat/gray-codes/#probleme-suplimentare","title":"Probleme suplimentare","text":"","tags":["matematica","optimizare"]},{"location":"avansat/gray-codes/#resurse-suplimentare","title":"Resurse suplimentare","text":"","tags":["matematica","optimizare"]},{"location":"avansat/hld/","title":"Heavy light decomposition (HLD)","text":"<p>Heavy-light decomposition este o tehnic\u0103 ce ne ajut\u0103 s\u0103 efectu\u0103m query-uri \u0219i update-uri \u00eentr-un timp eficient pe un arbore.</p>","tags":["structuri de date","arbori","optimizare"]},{"location":"avansat/hld/#introducere","title":"Introducere","text":"<p>Fie un arbore \\(G\\) cu \\(N\\) noduri, iar r\u0103d\u0103cina acestuia s\u0103 fie \u00een nodul 1.</p> <p>Ideea din spatele algoritmului este de a sparge arborele \u00een mai multe lan\u021buri pentru a atinge r\u0103d\u0103cina din orice nod din arbore \u00een timp logaritmic.</p> <p>Evident, dac\u0103 efectu\u0103m aceast\u0103 descompunere pe arborele nostru, ne va permite s\u0103 reducem anumite interog\u0103ri sau update-uri unice de forma: \"calculeaz\u0103 ceva pe lan\u021bul care leag\u0103 nodul \\(a\\) pe nodul \\(b\\)\" \u00een mai multe interog\u0103ri sau update-uri de forma: \"calculeaz\u0103 ceva pe segmentul \\([l,r]\\) din lan\u021bul \\(K\\)\". Pentru a calcula eficient pe segmentul \\([l,r]\\) din lan\u021bul \\(K\\), ne vom folosi de arbori de intervale.</p>","tags":["structuri de date","arbori","optimizare"]},{"location":"avansat/hld/#constructia-lanturilor","title":"Construc\u021bia lan\u021burilor","text":"<p>Pentru \u00eenceput, vom presupune c\u0103 pentru fiecare nod din \\(G\\) se va efectua acea\u0219i metod\u0103.</p> <p>\u0218tim c\u0103 func\u021bia logaritmic\u0103 cre\u0219te foarte lent, astfel \u00eenc\u00e2t este convenabil s\u0103 construim lan\u021buri de lungimi c\u00e2t mai mari, pentru a minimiza num\u0103rul de opera\u021bii necesare pentru interog\u0103ri \u0219i update-uri pe un num\u0103r c\u00e2t mai mare de noduri din lan\u021b. A\u0219adar, pentru fiecare nod \\(x\\), vom alege s\u0103 continu\u0103m crearea lan\u021bului cu fiul care are cele mai multe noduri \u00een subarborele s\u0103u.</p> <p>De ce nu am ales fiul care are cel mai lung lan\u021b creat p\u00e2n\u0103 la el? C\u00e2nd avem \\(\\sqrt N\\) lan\u021buri elementare, atunci vom avea o complexitate de \\(\\mathcal{O}(\\sqrt N)\\) pentru parcurgerea de la un nod \\(x\\) p\u00e2n\u0103 la r\u0103d\u0103cin\u0103. \u00cen concluzie, vom avea o complexitate de \\(\\mathcal{O}(\\sqrt N \\cdot \\log N)\\) pentru fiecare interogare sau update.</p> <p></p> <p>Dac\u0103 alegem fiul care are cele mai multe noduri \u00een subarbore, constat\u0103m c\u0103 num\u0103rul de lan\u021buri pe care le vom parcurgem p\u00e2n\u0103 la r\u0103d\u0103cin\u0103 se reduce la \\(\\log N\\).</p> <p>Urm\u0103toarea imagine ilustreaz\u0103 descompunerea arborelui cu tehnica descris\u0103 anterior, cunoscut\u0103 \u00een termeni de specialitate sub denumirea de heavy path decomposition.</p> <p></p> <p>Complexitatea final\u0103 pe fiecare interogare va fi \\(\\mathcal{O}(( \\log N ) ^ 2)\\), iar pentru update-ul unui singur nod \u00een \\(\\mathcal{O}(\\log N)\\).</p>","tags":["structuri de date","arbori","optimizare"]},{"location":"avansat/hld/#implementarea-in-c","title":"Implementarea \u00een C++","text":"<p>Exist\u0103 \u0219i alte tehnici de precalculare a lan\u021burilor, dar aceasta este cea mai u\u0219or de \u00een\u021beles.</p> <pre><code>/// nodurile arborelui sunt ini\u021bializa\u021bi de la 1\n\nconst int MAX = 2e5 + 5;  /// limita de noduri din arbore\n\nvector&lt;int&gt; G[MAX];  /// G[i] - nodurile \u00een care putem intra din nodul i\nbitset&lt;MAX&gt; viz;     /// viz[i] - verific\u0103m dac\u0103 am intrat \u00een nodul i\nint niv[MAX];        /// niv[i] - nivelul la care se afl\u0103 nodul i \u00een arbore\nint w[MAX];          /// w[i] - dimensiunea subarborelui cu root i\nint nrL;             /// num\u0103rul de lan\u021buri\nint L[MAX];          /// L[i] - \u00een ce lan\u021b se afl\u0103 nodul i\nint Lfather[MAX];  /// Lfather[L[i]] - primul nod al lan\u021bului \u00een care se afl\u0103 i\nint Lniv[MAX];  /// Lniv[L[i]] - nivelul primului nod al lan\u021bului \u00een care se\n                /// afl\u0103 i\nvector&lt;int&gt; Lant[MAX];  /// Lant[i] - toate nodurile din lan\u021bul i de la frunz\u0103\n                        /// p\u00e2n\u0103 la nodul root al lan\u021bului\n\nvoid dfs(int node) {\n    int leaf = 1, maxl = -1;\n\n    viz[node] = 1;\n    w[node] = 1;\n\n    for (auto x : G[node]) {\n        if (viz[x]) {\n            continue;\n        }\n\n        leaf = 0;\n        niv[x] = niv[node] + 1;\n\n        dfs(x);\n\n        w[node] += w[x];\n\n        /// actualiz\u0103m fiul care are cea mai mare dimensiune al subarborelui\n        if (maxl == -1) {\n            maxl = x;\n        } else if (w[maxl] &lt; w[x]) {\n            maxl = x;\n        }\n    }\n\n    /// daca node este o frunz\u0103\n    if (leaf) {\n        L[node] = ++nrL;  /// se creaz\u0103 un nou lan\u021b\n        Lant[L[node]].push_back(node);\n    }\n    /// altfel o s\u0103 leg\u0103m pe node de maxl\n    else {\n        L[node] = L[maxl];\n        Lant[L[node]].push_back(node);\n\n        /// aici vom fixa nodul de start pentru fii care au r\u0103mas, ace\u0219tia fiind\n        /// primi \u00een lan\u021bul creat p\u0103na la ei\n        for (auto x : G[node]) {\n            if (x == maxl or niv[x] &lt; niv[node]) {\n                continue;\n            }\n\n            Lfather[L[x]] = node;\n            Lniv[L[x]] = niv[node];\n        }\n    }\n}\n</code></pre>","tags":["structuri de date","arbori","optimizare"]},{"location":"avansat/hld/#probleme-rezolvate","title":"Probleme rezolvate","text":"","tags":["structuri de date","arbori","optimizare"]},{"location":"avansat/hld/#problema-heavy-path-decomposition","title":"Problema Heavy Path Decomposition","text":"<p>Se d\u0103 un arbore cu \\(N\\) noduri, fiecare av\u00e2nd asociat\u0103 o valoare \\(v_i\\), \\(1 \\leq i \\leq N\\). Se dau \\(M\\) opera\u021bii de forma \\((t, x, y)\\), cu urm\u0103toarea semnifica\u021bie:</p> <ul> <li>dac\u0103 \\(t\\) este 0, opera\u021bia este de tipul update, iar valoarea \\(v_x\\) asociata   nodului cu indicele \\(x\\) devine \\(y\\);</li> <li>dac\u0103 \\(t\\) este 1, opera\u021bia este de tipul query \u0219i se cere s\u0103 se afi\u0219eze   valoarea maxim\u0103 asociat\u0103 unui nod aflat pe lan\u021bul elementar care une\u0219te   nodurile \\(x\\) \u0219i \\(y\\).</li> </ul> <p>Pentru a rezolva aceast\u0103 problem\u0103 clasic\u0103, trebuie s\u0103 implement\u0103m arbori de intervale pentru lan\u021burile create de noi, iar apoi s\u0103 efectu\u0103m cele dou\u0103 tipuri de opera\u021bii: query \u0219i update.</p> <p>Pentru opera\u021bia de tip update, putem opera doar pe lan\u021bul unde se afl\u0103 nodul \\(x\\).</p> <p>Pentru opera\u021bia de tip query, va trebuie s\u0103 parcurgem mai multe lan\u021buri p\u00e2n\u0103 c\u00e2nd vom ajunge cu cele dou\u0103 noduri \u00een acela\u0219i lan\u021b. Aceast\u0103 opera\u021biune este chiar cea de la Lowest common ancestor (LCA).</p> <p>O implementare de 100 de puncte poate fi citit\u0103 mai jos:</p> <pre><code>#include &lt;algorithm&gt;\n#include &lt;bitset&gt;\n#include &lt;climits&gt;\n#include &lt;fstream&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\nconst string fn(\"heavypath\");\n\nifstream in(fn + \".in\");\nofstream out(fn + \".out\");\n\n#define cin in\n#define cout out\n\nconst int MAX = 1e5;\n\nint n, q, val[MAX + 5], niv[MAX + 5], w[MAX + 5], nrL, L[MAX + 5],\n    Lfather[MAX + 5], Lniv[MAX + 5], Ldecal[MAX + 5];\nint Tree[4 * MAX + 5];\nvector&lt;int&gt; g[MAX + 5], Lant[MAX + 5];\nbitset&lt;MAX + 5&gt; viz;\n\nvoid dfs(int node) {\n    int leaf = 1, maxl = -1;\n\n    viz[node] = 1;\n    w[node] = 1;\n\n    for (auto x : g[node]) {\n        if (viz[x]) {\n            continue;\n        }\n\n        leaf = 0;\n        niv[x] = niv[node] + 1;\n\n        dfs(x);\n\n        w[node] += w[x];\n\n        if (maxl == -1) {\n            maxl = x;\n        } else if (w[maxl] &lt; w[x]) {\n            maxl = x;\n        }\n    }\n\n    if (leaf) {\n        nrL++;\n        L[node] = nrL;\n        Lant[L[node]].push_back(node);\n    } else {\n        L[node] = L[maxl];\n        Lant[L[node]].push_back(node);\n\n        for (auto x : g[node]) {\n            if (x == maxl or niv[x] &lt; niv[node]) {\n                continue;\n            }\n\n            Lfather[L[x]] = node;\n            Lniv[L[x]] = niv[node];\n        }\n    }\n}\n\nvoid build(int node, int l, int r, int decal, int pozl) {\n    if (l == r) {\n        Tree[node + decal] = val[Lant[pozl][l - 1]];\n    } else {\n        int m = (l + r) / 2;\n\n        build(2 * node, l, m, decal, pozl);\n        build(2 * node + 1, m + 1, r, decal, pozl);\n\n        Tree[node + decal] =\n            max(Tree[2 * node + decal], Tree[2 * node + 1 + decal]);\n    }\n}\n\nvoid update(int node, int l, int r, int target, int val, int decal) {\n    if (l == r) {\n        Tree[node + decal] = val;\n    } else {\n        int m = (l + r) / 2;\n\n        if (target &lt;= m) {\n            update(2 * node, l, m, target, val, decal);\n        } else {\n            update(2 * node + 1, m + 1, r, target, val, decal);\n        }\n\n        Tree[node + decal] =\n            max(Tree[2 * node + decal], Tree[2 * node + 1 + decal]);\n    }\n}\n\nint query(int node, int l, int r, int a, int b, int decal) {\n    if (r &lt; a or b &lt; l) {\n        return INT_MIN;\n    }\n\n    if (a &lt;= l and r &lt;= b) {\n        return Tree[node + decal];\n    }\n\n    int m = (l + r) / 2;\n\n    return max(query(2 * node, l, m, a, b, decal),\n               query(2 * node + 1, m + 1, r, a, b, decal));\n}\n\nvoid make_paths() {\n    niv[1] = 1;\n\n    dfs(1);\n\n    for (int i = 1; i &lt;= nrL; i++) {\n        reverse(Lant[i].begin(), Lant[i].end());\n\n        if (i &gt; 1) {\n            Ldecal[i] = Ldecal[i - 1] + Lant[i - 1].size() * 4;\n        }\n\n        build(1, 1, Lant[i].size(), Ldecal[i], i);\n    }\n}\n\nvoid solve() {\n    int t, x, y;\n\n    cin &gt;&gt; t &gt;&gt; x &gt;&gt; y;\n\n    if (t == 0) {\n        update(1, 1, Lant[L[x]].size(), niv[x] - Lniv[L[x]], y, Ldecal[L[x]]);\n    } else {\n        int ans = INT_MIN;\n\n        while (1) {\n            if (L[x] == L[y]) {\n                if (niv[x] &gt; niv[y]) {\n                    swap(x, y);\n                }\n\n                ans =\n                    max(ans, query(1, 1, Lant[L[x]].size(), niv[x] - Lniv[L[x]],\n                                   niv[y] - Lniv[L[x]], Ldecal[L[x]]));\n\n                break;\n            }\n            if (Lniv[L[x]] &lt; Lniv[L[y]]) {\n                swap(x, y);\n            }\n\n            ans = max(ans, query(1, 1, Lant[L[x]].size(), 1,\n                                 niv[x] - Lniv[L[x]], Ldecal[L[x]]));\n            x = Lfather[L[x]];\n        }\n\n        cout &lt;&lt; ans &lt;&lt; '\\n';\n    }\n}\n\nint main() {\n    cin &gt;&gt; n &gt;&gt; q;\n\n    for (int i = 1; i &lt;= n; i++) {\n        cin &gt;&gt; val[i];\n    }\n\n    for (int i = 1, x, y; i &lt; n; i++) {\n        cin &gt;&gt; x &gt;&gt; y;\n\n        g[x].push_back(y);\n        g[y].push_back(x);\n    }\n\n    make_paths();\n\n    while (q--) {\n        solve();\n    }\n    return 0;\n}\n</code></pre>","tags":["structuri de date","arbori","optimizare"]},{"location":"avansat/hld/#problema-struct-arbore","title":"Problema Struct arbore{}","text":"<p>Aceast\u0103 problem\u0103 necesit\u0103 cuno\u0219tin\u021be de la string hashing, respectiv Lowest common ancestor (LCA).</p> <p>\u00cen primul r\u00e2nd, ne vom folosi de tehnica string hashing pentru a afla \u00een \\(\\mathcal{O}(1)\\) valoarea unui lan\u021b. Pentru c\u0103 problema ne cere s\u0103 oper\u0103m \u0219i update-uri, va trebui s\u0103 facem update pe fiecare lan\u021b c\u00e2nd schimb\u0103m litera de la un nod. Astfel, complexitatea pentru update \u0219i query pe un lan\u021b va r\u0103m\u00e2ne tot \\(\\mathcal{O}(\\log(N))\\), datorit\u0103 string hashing. Dac\u0103 vrem s\u0103 afl\u0103m valoarea hash pe un lan\u021b care leag\u0103 dou\u0103 noduri, aceasta va intra \u00een complexitate \\(\\mathcal{O}((\\log N)^2)\\), deoarece putem parcurge maxim \\(\\log N\\) lan\u021buri \u00een tot arborele.</p> <p>\u00cen al doilea r\u00e2nd, trebuie s\u0103 afl\u0103m \u00een mod eficient str\u0103mo\u0219ul celor 2 noduri, astfel \u00eenc\u00e2t acesta s\u0103 fie la o distan\u021b\u0103 c\u00e2t mai mare, iar cele 2 stringuri formate s\u0103 fie identice. Ne vom folosi de tehnica LCA pentru a afla \u00een \\(\\mathcal{O}(\\log N)\\) al \\(K\\) str\u0103mo\u0219 pentru nodul \\(x\\), iar de c\u0103utarea binar\u0103 pentru a afla valoarea \\(K\\) \u00een timp logaritmic. Astfel rezult\u0103 o complexitate final\u0103 de \\(\\mathcal{O}((\\log N)^3)\\) pentru fiecare query \u0219i \\(\\mathcal{O}(\\log N)\\) pentru update.</p> <p>O implementare de 100 de puncte poate fi citit\u0103 mai jos:</p> <pre><code>/// Autor: Ardelean Raul, CNVL - Baia Mare\n/// Cuvinte cheie: Binary Lifting, Hashing, Heavy Path Decomposition, Heavy\n/// Light Decomposition, Binary Search Complexitate: O(Q * log(n) ^ 3)\n#include &lt;algorithm&gt;\n#include &lt;bitset&gt;\n#include &lt;cmath&gt;\n#include &lt;iostream&gt;\n#include &lt;vector&gt;\n#define ll long long\nusing namespace std;\n\nconst int MAX = 1e5 + 6, base = 57, mod = 1e9 + 7;\n\nvector&lt;int&gt; G[MAX], v[30];\nint n, q;\nstring s;\n\nclass kth {\npublic:\n    int l, timer;\n    vector&lt;int&gt; tin, tout;\n    vector&lt;vector&lt;int&gt;&gt; up;\n\n    void dfs(int node, int father) {\n        tin[node] = ++timer;\n        up[node][0] = father;\n\n        for (int i = 1; i &lt;= l; i++) {\n            up[node][i] = up[up[node][i - 1]][i - 1];\n        }\n\n        for (auto x : G[node]) {\n            if (x != father) {\n                dfs(x, node);\n            }\n        }\n\n        tout[node] = ++timer;\n    }\n\n    int kthancestor(int node, int k) {\n        for (int i = 0; i &lt;= l and node != -1; i++) {\n            if (k &amp; (1 &lt;&lt; i)) {\n                node = up[node][i];\n            }\n        }\n\n        return node;\n    }\n\n    void init(int root) {\n        tin.resize(MAX + 5);\n        tout.resize(MAX + 5);\n\n        timer = 0;\n        l = ceil(log2(MAX + 5));\n\n        up.assign(MAX + 5, vector&lt;int&gt;(l + 5));\n\n        dfs(root, root);\n    }\n\n} kth;\n\nclass hpd {\npublic:\n    int niv[MAX + 5], w[MAX + 5], fact[MAX + 5], invfact[MAX + 5];\n    int nrL, L[MAX + 5], Lfather[MAX + 5], Lniv[MAX + 5], Ldecal[MAX + 5];\n    int Tree[4 * MAX + 5], sz[4 * MAX + 5];\n\n    vector&lt;int&gt; Lant[MAX + 5];\n    bitset&lt;MAX + 5&gt; viz;\n\n    void dfs(int node) {\n        int leaf = 1, maxl = -1;\n\n        viz[node] = 1;\n        w[node] = 1;\n\n        for (auto x : G[node]) {\n            if (viz[x]) {\n                continue;\n            }\n\n            leaf = 0;\n            niv[x] = niv[node] + 1;\n\n            dfs(x);\n\n            w[node] += w[x];\n\n            if (maxl == -1) {\n                maxl = x;\n            } else if (w[maxl] &lt; w[x]) {\n                maxl = x;\n            }\n        }\n\n        if (leaf) {\n            L[node] = ++nrL;\n            Lant[L[node]].push_back(node);\n        } else {\n            L[node] = L[maxl];\n            Lant[L[node]].push_back(node);\n\n            for (auto x : G[node]) {\n                if (x == maxl or niv[x] &lt; niv[node]) {\n                    continue;\n                }\n\n                Lfather[L[x]] = node;\n                Lniv[L[x]] = niv[node];\n            }\n        }\n    }\n\n    int upd(int a, int b, int size) {\n        if (size &lt;= 0) {\n            return a;\n        }\n\n        if (min(a, b) == 0) {\n            return max(a, b);\n        }\n\n        return 1LL * (1LL * a * fact[size] % mod + 1LL * b) % mod;\n    }\n\n    void build(int node, int l, int r, int decal, int root) {\n        if (l == r) {\n            Tree[node + decal] = (s[Lant[root][l - 1]] - 'a' + 1);\n            sz[node + decal] = 1;\n        } else {\n            int m = (l + r) / 2;\n\n            build(2 * node, l, m, decal, root);\n            build(2 * node + 1, m + 1, r, decal, root);\n\n            sz[node + decal] = sz[2 * node + decal] + sz[2 * node + 1 + decal];\n            Tree[node + decal] =\n                upd(Tree[2 * node + decal], Tree[2 * node + 1 + decal],\n                    sz[2 * node + 1 + decal]);\n        }\n    }\n\n    void update(int node, int l, int r, int target, int val, int decal) {\n        if (l == r) {\n            Tree[node + decal] = val;\n        } else {\n            int m = (l + r) / 2;\n\n            if (target &lt;= m) {\n                update(2 * node, l, m, target, val, decal);\n            } else {\n                update(2 * node + 1, m + 1, r, target, val, decal);\n            }\n\n            Tree[node + decal] =\n                upd(Tree[2 * node + decal], Tree[2 * node + 1 + decal],\n                    sz[2 * node + 1 + decal]);\n        }\n    }\n\n    int query(int node, int l, int r, int a, int b, int decal) {\n        if (r &lt; a or b &lt; l) {\n            return 0;\n        }\n\n        if (a &lt;= l and r &lt;= b) {\n            return Tree[node + decal];\n        }\n\n        int m = (l + r) / 2;\n\n        int left = query(2 * node, l, m, a, b, decal);\n        int right = query(2 * node + 1, m + 1, r, a, b, decal);\n\n        return upd(left, right, min(r, b) - m);\n    }\n\n    void make_paths() {\n        fact[0] = 1;\n\n        for (int i = 1; i &lt;= MAX; i++) {\n            fact[i] = 1LL * fact[i - 1] * base % mod;\n        }\n\n        niv[1] = 1;\n\n        dfs(1);\n\n        for (int i = 1; i &lt;= nrL; i++) {\n            reverse(Lant[i].begin(), Lant[i].end());\n\n            if (i &gt; 1) {\n                Ldecal[i] = Ldecal[i - 1] + Lant[i - 1].size() * 4;\n            }\n\n            build(1, 1, Lant[i].size(), Ldecal[i], i);\n        }\n    }\n\n    int find(int x, int y) {\n        int hash = 0, tlen = 0;\n\n        while (1) {\n            if (L[x] == L[y]) {\n                if (niv[x] &gt; niv[y]) {\n                    swap(x, y);\n                }\n\n                int len = niv[y] - Lniv[L[x]] - niv[x] + Lniv[L[x]] + 1;\n\n                hash = upd(query(1, 1, Lant[L[x]].size(), niv[x] - Lniv[L[x]],\n                                 niv[y] - Lniv[L[x]], Ldecal[L[x]]),\n                           hash, tlen);\n                tlen += len;\n\n                break;\n            }\n\n            if (Lniv[L[x]] &lt; Lniv[L[y]]) {\n                swap(x, y);\n            }\n\n            int len = niv[x] - Lniv[L[x]];\n\n            hash = upd(query(1, 1, Lant[L[x]].size(), 1, niv[x] - Lniv[L[x]],\n                             Ldecal[L[x]]),\n                       hash, tlen);\n            tlen += len;\n\n            x = Lfather[L[x]];\n        }\n\n        return hash;\n    }\n} tree;\n\nvoid read() {\n    cin &gt;&gt; n &gt;&gt; s;\n\n    s = \" \" + s;\n\n    for (int i = 1; i &lt;= n; i++) {\n        v[s[i] - 'a'].push_back(i);\n    }\n\n    for (int i = 2, x; i &lt;= n; i++) {\n        cin &gt;&gt; x;\n        G[x].push_back(i);\n    }\n}\n\nvoid init() {\n    kth.init(1);\n    tree.make_paths();\n}\n\nvoid solve() {\n    cin &gt;&gt; q;\n\n    while (q--) {\n        int t, a, b;\n\n        cin &gt;&gt; t;\n\n        if (t == 1) {\n            cin &gt;&gt; a &gt;&gt; b;\n\n            int l = 0, r = min(tree.niv[a], tree.niv[b]) - 1, target = 0;\n\n            while (l &lt;= r) {\n                int med = (l + r) / 2;\n\n                int ancestor_a = kth.kthancestor(a, med);\n                int ancestor_b = kth.kthancestor(b, med);\n\n                if (tree.find(ancestor_a, a) == tree.find(ancestor_b, b)) {\n                    target = med + 1, l = med + 1;\n                } else {\n                    r = med - 1;\n                }\n            }\n\n            cout &lt;&lt; target &lt;&lt; '\\n';\n        } else {\n            char ch;\n\n            cin &gt;&gt; a &gt;&gt; ch;\n\n            s[a] = ch;\n            tree.update(1, 1, tree.Lant[tree.L[a]].size(),\n                        tree.niv[a] - tree.Lniv[tree.L[a]], ch - 'a' + 1,\n                        tree.Ldecal[tree.L[a]]);\n        }\n    }\n}\n\nsigned main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(0);\n\n    read();\n    init();\n    solve();\n    return 0;\n}\n</code></pre>","tags":["structuri de date","arbori","optimizare"]},{"location":"avansat/hld/#concluzii","title":"Concluzii","text":"<p>Heavy-light decomposition este un algoritm foarte important \u0219i puternic, care apare rar, datorit\u0103 num\u0103rului mare de linii de cod necesare pentru a restr\u00e2nge arborele \u0219i a prelucra opera\u021bii asupra lan\u021burilor. Orice idee care poate fi realizat\u0103 cu arbori de intervale poate fi extins\u0103 \u0219i folosit\u0103 pe un arbore.</p>","tags":["structuri de date","arbori","optimizare"]},{"location":"avansat/hld/#probleme-suplimentare","title":"Probleme suplimentare","text":"<ul> <li>Path Queries II</li> <li>Company Queries II</li> <li>confuzie</li> <li>Disconnect</li> <li>Sever</li> <li>Petarbore</li> <li>mogger</li> <li>Cow Land</li> <li>QTREE3 - Query on a tree again!</li> <li>Milk Visits</li> <li>Delay</li> <li>Aladdin and the Return Journey</li> <li>Disruption</li> <li>Subtrees And Paths</li> <li>Grass Planting</li> <li>Vertex Set Path Composite</li> <li>Caves and Tunnels</li> <li>Tree Queries</li> <li>The Tree</li> <li>Tree Game</li> <li>Synchronization</li> <li>Cats or Dogs</li> <li>Probleme cu HLD de pe Kilonova</li> </ul>","tags":["structuri de date","arbori","optimizare"]},{"location":"avansat/hld/#resurse-suplimentare","title":"Resurse suplimentare","text":"<ul> <li>HLD - CP Algorithms</li> <li>HLD - USACO Guide</li> <li>Tree decompositions - Infoarena</li> <li>Template HLD - Stefdasca</li> <li>Easiest HLD with subtree queries - Codeforces adamant's blog</li> <li>Heavy path decomposition - Centrul InfO(1)</li> <li>Heavy Light Decomposition - robert1003</li> </ul>","tags":["structuri de date","arbori","optimizare"]},{"location":"avansat/huffman/","title":"Codarea Huffman","text":"<p>Daca vreti sa ne ajutati cu acest articol, ne puteti gasi pe github sau pe serverul nostru de discord</p> <p>Mai jos g\u0103si\u021bi resurse pe care le pute\u021bi citi p\u00e2n\u0103 atunci.</p>","tags":["matematica","optimizare"]},{"location":"avansat/huffman/#introducere","title":"Introducere","text":"","tags":["matematica","optimizare"]},{"location":"avansat/huffman/#problema-exemplu","title":"Problema exemplu","text":"","tags":["matematica","optimizare"]},{"location":"avansat/huffman/#concluzii","title":"Concluzii","text":"","tags":["matematica","optimizare"]},{"location":"avansat/huffman/#probleme-suplimentare","title":"Probleme suplimentare","text":"","tags":["matematica","optimizare"]},{"location":"avansat/huffman/#resurse-suplimentare","title":"Resurse suplimentare","text":"","tags":["matematica","optimizare"]},{"location":"avansat/intro-probability/","title":"Introducere \u00een probabilit\u0103\u021bi","text":"<p>Daca vreti sa ne ajutati cu acest articol, ne puteti gasi pe github sau pe serverul nostru de discord</p> <p>Mai jos g\u0103si\u021bi resurse pe care le pute\u021bi citi p\u00e2n\u0103 atunci.</p>","tags":["matematica","algebra","probabilitati","statistica","expected value"]},{"location":"avansat/intro-probability/#introducere","title":"Introducere","text":"","tags":["matematica","algebra","probabilitati","statistica","expected value"]},{"location":"avansat/intro-probability/#problema-exemplu","title":"Problema exemplu","text":"","tags":["matematica","algebra","probabilitati","statistica","expected value"]},{"location":"avansat/intro-probability/#concluzii","title":"Concluzii","text":"","tags":["matematica","algebra","probabilitati","statistica","expected value"]},{"location":"avansat/intro-probability/#probleme-suplimentare","title":"Probleme suplimentare","text":"","tags":["matematica","algebra","probabilitati","statistica","expected value"]},{"location":"avansat/intro-probability/#resurse-suplimentare","title":"Resurse suplimentare","text":"","tags":["matematica","algebra","probabilitati","statistica","expected value"]},{"location":"avansat/knuth-dp/","title":"Knuth DP","text":"<p>Daca vreti sa ne ajutati cu acest articol, ne puteti gasi pe github sau pe serverul nostru de discord</p> <p>Mai jos g\u0103si\u021bi resurse pe care le pute\u021bi citi p\u00e2n\u0103 atunci.</p>","tags":["programare dinamica","optimizare"]},{"location":"avansat/knuth-dp/#introducere","title":"Introducere","text":"","tags":["programare dinamica","optimizare"]},{"location":"avansat/knuth-dp/#problema-exemplu","title":"Problema exemplu","text":"","tags":["programare dinamica","optimizare"]},{"location":"avansat/knuth-dp/#concluzii","title":"Concluzii","text":"","tags":["programare dinamica","optimizare"]},{"location":"avansat/knuth-dp/#probleme-suplimentare","title":"Probleme suplimentare","text":"","tags":["programare dinamica","optimizare"]},{"location":"avansat/knuth-dp/#resurse-suplimentare","title":"Resurse suplimentare","text":"<ul> <li>Knuth Optimization - Jeffrey Xiao</li> <li>Knuth DP - robert1003</li> </ul>","tags":["programare dinamica","optimizare"]},{"location":"avansat/li-chao/","title":"Arbore Li Chao","text":"<p>Daca vreti sa ne ajutati cu acest articol, ne puteti gasi pe github sau pe serverul nostru de discord</p> <p>Mai jos g\u0103si\u021bi resurse pe care le pute\u021bi citi p\u00e2n\u0103 atunci.</p>","tags":["programare dinamica","optimizare","stiva","sortare","structuri de date"]},{"location":"avansat/li-chao/#introducere","title":"Introducere","text":"","tags":["programare dinamica","optimizare","stiva","sortare","structuri de date"]},{"location":"avansat/li-chao/#problema-exemplu","title":"Problema exemplu","text":"","tags":["programare dinamica","optimizare","stiva","sortare","structuri de date"]},{"location":"avansat/li-chao/#concluzii","title":"Concluzii","text":"","tags":["programare dinamica","optimizare","stiva","sortare","structuri de date"]},{"location":"avansat/li-chao/#probleme-suplimentare","title":"Probleme suplimentare","text":"","tags":["programare dinamica","optimizare","stiva","sortare","structuri de date"]},{"location":"avansat/li-chao/#resurse-suplimentare","title":"Resurse suplimentare","text":"","tags":["programare dinamica","optimizare","stiva","sortare","structuri de date"]},{"location":"avansat/linear-recurrences/","title":"Recuren\u021be liniare","text":"<p>Daca vreti sa ne ajutati cu acest articol, ne puteti gasi pe github sau pe serverul nostru de discord</p> <p>Mai jos g\u0103si\u021bi resurse pe care le pute\u021bi citi p\u00e2n\u0103 atunci.</p>","tags":["matematica","recurente"]},{"location":"avansat/linear-recurrences/#introducere","title":"Introducere","text":"","tags":["matematica","recurente"]},{"location":"avansat/linear-recurrences/#problema-exemplu","title":"Problema exemplu","text":"","tags":["matematica","recurente"]},{"location":"avansat/linear-recurrences/#concluzii","title":"Concluzii","text":"","tags":["matematica","recurente"]},{"location":"avansat/linear-recurrences/#probleme-suplimentare","title":"Probleme suplimentare","text":"","tags":["matematica","recurente"]},{"location":"avansat/linear-recurrences/#resurse-suplimentare","title":"Resurse suplimentare","text":"","tags":["matematica","recurente"]},{"location":"avansat/manacher/","title":"Algoritmul lui Manacher","text":"<p>Daca vreti sa ne ajutati cu acest articol, ne puteti gasi pe github sau pe serverul nostru de discord</p> <p>Mai jos g\u0103si\u021bi resurse pe care le pute\u021bi citi p\u00e2n\u0103 atunci.</p>","tags":["siruri de caractere","palindrom"]},{"location":"avansat/manacher/#introducere","title":"Introducere","text":"","tags":["siruri de caractere","palindrom"]},{"location":"avansat/manacher/#problema-exemplu","title":"Problema exemplu","text":"","tags":["siruri de caractere","palindrom"]},{"location":"avansat/manacher/#concluzii","title":"Concluzii","text":"","tags":["siruri de caractere","palindrom"]},{"location":"avansat/manacher/#probleme-suplimentare","title":"Probleme suplimentare","text":"","tags":["siruri de caractere","palindrom"]},{"location":"avansat/manacher/#resurse-suplimentare","title":"Resurse suplimentare","text":"","tags":["siruri de caractere","palindrom"]},{"location":"avansat/persistent-segment-tree/","title":"Arbore de intervale persisten\u021bi","text":"<p>Daca vreti sa ne ajutati cu acest articol, ne puteti gasi pe github sau pe serverul nostru de discord</p> <p>Mai jos g\u0103si\u021bi resurse pe care le pute\u021bi citi p\u00e2n\u0103 atunci.</p>","tags":["structuri de date","arbori de intervale"]},{"location":"avansat/persistent-segment-tree/#introducere","title":"Introducere","text":"","tags":["structuri de date","arbori de intervale"]},{"location":"avansat/persistent-segment-tree/#problema-exemplu","title":"Problema exemplu","text":"","tags":["structuri de date","arbori de intervale"]},{"location":"avansat/persistent-segment-tree/#concluzii","title":"Concluzii","text":"","tags":["structuri de date","arbori de intervale"]},{"location":"avansat/persistent-segment-tree/#probleme-suplimentare","title":"Probleme suplimentare","text":"","tags":["structuri de date","arbori de intervale"]},{"location":"avansat/persistent-segment-tree/#resurse-suplimentare","title":"Resurse suplimentare","text":"","tags":["structuri de date","arbori de intervale"]},{"location":"avansat/rle/","title":"Run-length encoding","text":"<p>Daca vreti sa ne ajutati cu acest articol, ne puteti gasi pe github sau pe serverul nostru de discord</p> <p>Mai jos g\u0103si\u021bi resurse pe care le pute\u021bi citi p\u00e2n\u0103 atunci.</p>","tags":["matematica","optimizare"]},{"location":"avansat/rle/#introducere","title":"Introducere","text":"","tags":["matematica","optimizare"]},{"location":"avansat/rle/#problema-exemplu","title":"Problema exemplu","text":"","tags":["matematica","optimizare"]},{"location":"avansat/rle/#concluzii","title":"Concluzii","text":"","tags":["matematica","optimizare"]},{"location":"avansat/rle/#probleme-suplimentare","title":"Probleme suplimentare","text":"","tags":["matematica","optimizare"]},{"location":"avansat/rle/#resurse-suplimentare","title":"Resurse suplimentare","text":"","tags":["matematica","optimizare"]},{"location":"avansat/sos-dp/","title":"SOS DP","text":"<p>Daca vreti sa ne ajutati cu acest articol, ne puteti gasi pe github sau pe serverul nostru de discord</p> <p>Mai jos g\u0103si\u021bi resurse pe care le pute\u021bi citi p\u00e2n\u0103 atunci.</p>","tags":["programare dinamica","optimizare"]},{"location":"avansat/sos-dp/#introducere","title":"Introducere","text":"","tags":["programare dinamica","optimizare"]},{"location":"avansat/sos-dp/#problema-exemplu","title":"Problema exemplu","text":"","tags":["programare dinamica","optimizare"]},{"location":"avansat/sos-dp/#concluzii","title":"Concluzii","text":"","tags":["programare dinamica","optimizare"]},{"location":"avansat/sos-dp/#probleme-suplimentare","title":"Probleme suplimentare","text":"","tags":["programare dinamica","optimizare"]},{"location":"avansat/sos-dp/#resurse-suplimentare","title":"Resurse suplimentare","text":"<ul> <li>A Simple Introduction to SoS(Sum over Subset) Dynamic Programming - robert1003</li> </ul>","tags":["programare dinamica","optimizare"]},{"location":"avansat/special-graphs/","title":"Tipuri speciale de grafuri","text":"<p>Daca vreti sa ne ajutati cu acest articol, ne puteti gasi pe github sau pe serverul nostru de discord</p> <p>Mai jos g\u0103si\u021bi resurse pe care le pute\u021bi citi p\u00e2n\u0103 atunci.</p>","tags":["grafuri"]},{"location":"avansat/special-graphs/#introducere","title":"Introducere","text":"","tags":["grafuri"]},{"location":"avansat/special-graphs/#problema-exemplu","title":"Problema exemplu","text":"","tags":["grafuri"]},{"location":"avansat/special-graphs/#concluzii","title":"Concluzii","text":"","tags":["grafuri"]},{"location":"avansat/special-graphs/#probleme-suplimentare","title":"Probleme suplimentare","text":"","tags":["grafuri"]},{"location":"avansat/special-graphs/#resurse-suplimentare","title":"Resurse suplimentare","text":"","tags":["grafuri"]},{"location":"avansat/suffix-array-tree/","title":"Tablou/arbore de sufixe","text":"<p>Disclaimer</p> <p>Cu scopul de a mic\u0219ora m\u0103rimea final\u0103 a articolului \u0219i deoarece cititorii c\u0103rora le este adresat acest articol ar trebui s\u0103 fie informaticieni capabili, unele detalii de implementare nu vor fi discutate aici.</p>","tags":["structuri de date","siruri de caractere"]},{"location":"avansat/suffix-array-tree/#introducere","title":"Introducere","text":"<p>\u0218irul de sufixe (\u00een englez\u0103 suffix array) reprezint\u0103 o structur\u0103 de date foarte versatil\u0103 ce se dovede\u0219te util\u0103 \u00een rezolvarea problemelor dificile pe \u0219iruri de caractere, dar nu numai. Aceast\u0103 structur\u0103 de date este folosit\u0103 ca un \u00eenlocuitor al arborelui de sufixe \u0219i are avantajul c\u0103 folose\u0219te mai pu\u021bin\u0103 memorie, este mai u\u0219oar\u0103 de \u00een\u021beles \u0219i implementarea dureaz\u0103 mult mai pu\u021bin comparativ cu acesta. \u00cen plus, \u00eempreun\u0103 cu \u0219irul \\(LCP\\), care va fi de asemenea explicat \u00een acest articol, putem rezolva majoritatea problemelor pe care le poate rezolva arborele de sufixe. Problemele care nu pot fi rezolvate doar cu \u0219irul de sufixe sunt adesea extrem de dificile \u0219i nu se dau \u00een concursuri.</p> <p>!!!info \"Defini\u021bie\" \u0218irul de sufixe al unui \u0219ir este format din indicii sufixelor sortate \u00een ordine lexicografic\u0103.</p> <p>Spre exemplu, consider\u0103m \u0219irul de sufixe al stringului \\(banana\\):</p> Pozi\u021bie \u00een suffix array Indicele de la care \u00eencepe sufixul Sufixul 0 5 \\(a\\) 1 3 \\(ana\\) 2 1 \\(anana\\) 3 0 \\(banana\\) 4 4 \\(na\\) 6 2 \\(nana\\) <p>Astfel, suffix array-ul \u0219irului este \\(5, 3, 1, 0, 4, 2\\). Se observ\u0103 c\u0103 deoarece toate sufixele au lungimi diferite, acest rezultat este unic.</p> <p>Algoritmul pe care \u00eel vom folosi pentru construire are defapt scopul de a sorta \u00een ordine lexicografic\u0103 rota\u021biile circulare are \u0219irului. Prin introducerea unui caracter santinel\u0103 mai mic dec\u00e2t toate celelalte la final putem folosi acest algoritm pentru a sorta sufixele, corectitudinea provenind din faptul c\u0103 santinela apare pe pozi\u021bii diferite pentru fiecare rota\u021bie. S\u0103 observ\u0103m exemplul de mai jos pentru stringul \\(banana\\), unde am luat caracterul $ ca santinel\u0103.</p> Indicele de la care \u00eencepe rota\u021bia Rota\u021bia 6 \\(\\text{\\$banana}\\) 5 \\(\\text{a\\$banan}\\) 3 \\(\\text{ana\\$ban}\\) 1 \\(\\text{anana\\$b}\\) 0 \\(\\text{banana\\$}\\) 4 \\(\\text{na\\$bana}\\) 2 \\(\\text{nana\\$ba}\\) <p>Observa\u021bie</p> <p>Se observa c\u0103 ordinea este identic\u0103 dupa ce \u0219tergem primul element din tablou. Rota\u021bia ce \u00eencepe cu santinela va fi mereu prima \u0219i nu ne modific\u0103 rezultatul.</p>","tags":["structuri de date","siruri de caractere"]},{"location":"avansat/suffix-array-tree/#construire","title":"Construire","text":"<p>Sortarea va fi realizat\u0103 \u00een \\(\\lceil{\\log_2(N)}\\rceil\\) pa\u0219i, unde \\(N\\) este m\u0103rimea \u0219irului, la pasul \\(i\\) av\u00e2nd sortate rota\u021biile dupa prefixele lor de lungime \\(2^i\\). Pentru a ne u\u0219ura munca introducem conceptul de clase de echivalen\u021b\u0103, fiecarui \u0219ir fiindu-i atribuit un num\u0103r natural, fie el \\(C_i\\) pentru rota\u021bia ce \u00eencepe din \\(i\\), pe care le recalcul\u0103m la fiecare itera\u021bie a sort\u0103rii. Aceste clase de echivalen\u021b\u0103 au urm\u0103toarele propriet\u0103\u021bi : dac\u0103 un \u0219ir este mai mic lexicografic dec\u00e2t altul atunci are o clas\u0103 de echivalen\u021b\u0103 mai mic\u0103 iar dac\u0103 dou\u0103 \u0219iruri sunt egale atunci au aceea\u0219i clas\u0103 de echivalen\u021b\u0103. \u00cen plus, numarul de clase de echivalen\u021b\u0103 folosite trebuie s\u0103 fie minim. Baz\u00e2ndu-ne pe aceste propriet\u0103\u021bi, la pasul \\(i\\) putem sorta prefixele rota\u021biilor folosind o metod\u0103 similar\u0103 cu radixsort : \u00eemp\u0103r\u021bim prefixul de lungime \\(2^i\\) \u00een dou\u0103 buc\u0103\u021bi de lungime \\(2^{i-1}\\) \u0219i le sort\u0103m \u00eentai dup\u0103 bucata din dreapta apoi dup\u0103 bucata din st\u00e2nga. Mare aten\u021bie : aceste sort\u0103ri trebuie s\u0103 nu schimbe ordinea relativ\u0103 \u00een caz de egalitate, altfel se duce totul de r\u00e2p\u0103. Astfel, din proprietatea 3 a claselor de echivalen\u021b\u0103 \u0219tiim c\u0103 nu vor dep\u0103\u0219i niciodat\u0103 valoarea \\(N\\) \u0219i putem folosi metode de sortare \u00een \\(\\mathcal{O}(N)\\) precum counting sort sau, ce recomand eu, doar \u021binem un vector de vectori unde $V_i = $ vectorul indicilor sufixelor ale c\u0103ror clas\u0103 de echivalen\u021b\u0103 pe care o compar\u0103m este \\(i\\). Astfel, complexitatea de timp este \\(\\mathcal{O}(N \\log_2{N})\\) iar cea de spa\u021biu este \\(\\mathcal{O}(N)\\).</p>","tags":["structuri de date","siruri de caractere"]},{"location":"avansat/suffix-array-tree/#cateva-detalii-de-implementare","title":"C\u00e2teva detalii de implementare","text":"<p>Pentru a ob\u021bine clasele jum\u0103t\u0103\u021bilor prefixelor este necesar s\u0103 lucr\u0103m cu indici modulo \\(N\\). Spre exemplu, dac\u0103 \\(N = 5\\), suntem la pasul 2 \u0219i ne dorim s\u0103 ob\u021binem clasele pentru jum\u0103t\u0103\u021bile corespunz\u0103toare prefixului rota\u021biei 3 atunci acestea vor fi clasa rota\u021biei 3 \u00een pasul 1 respectiv clasa lui \\(3 + 2 ^ 1 \\equiv 0 \\pmod{N}\\) \u00een pasul 1. Este l\u0103sat ca demonstra\u021bie pentru cititor de ce algoritmul r\u0103m\u00e2ne corect \u0219i dup\u0103 pasul \\(\\lceil{\\log_2(N)}\\rceil\\) \u00een care este posibil ca jum\u0103t\u0103\u021bile s\u0103 se intersecteze. V\u0103 pute\u021bi testa implementarea aici \u0219i ave\u021bi mai jos implementarea mea :</p> <pre><code>void reorder(vector&lt;int&gt; r[], vector&lt;int&gt; &amp;p) {\n    for (int i = 0, cnt = 0; i &lt; max((int)p.size(), 300); i++) {\n        for (auto &amp;it : r[i]) {\n            p[cnt++] = it;\n        }\n        r[i].clear();\n    }\n}\n\nvector&lt;int&gt; suffix(string s) {\n    s += \"$\";\n    int n = s.size();\n    vector&lt;int&gt; c(n), p(n), nc(n), r[max(n, 300)];\n\n    for (int i = 0; i &lt; n; i++) {\n        r[s[i]].emplace_back(i);\n    }\n    reorder(r, p);\n    c[p[0]] = 0;\n\n    for (int i = 1; i &lt; n; i++) {\n        c[p[i]] = c[p[i - 1]] + (int)(s[p[i]] != s[p[i - 1]]);\n    }\n\n    for (int len = 1; len &lt; n; len &lt;&lt;= 1) {\n        for (int i = 0; i &lt; n; i++) {\n            r[c[(p[i] + len) % n]].emplace_back(p[i]);\n        }\n        reorder(r, p);\n\n        for (int i = 0; i &lt; n; i++) {\n            r[c[p[i]]].emplace_back(p[i]);\n        }\n        reorder(r, p);\n        nc[p[0]] = 0;\n\n        for (int i = 1; i &lt; n; i++) {\n            pair&lt;int, int&gt; last = {c[p[i - 1]], c[(p[i - 1] + len) % n]};\n            pair&lt;int, int&gt; now = {c[p[i]], c[(p[i] + len) % n]};\n            nc[p[i]] = nc[p[i - 1]] + (int)(last != now);\n        }\n\n        c.swap(nc);\n    }\n\n    p.erase(p.begin());\n    return p;\n}\n</code></pre>","tags":["structuri de date","siruri de caractere"]},{"location":"avansat/suffix-array-tree/#aplicatii-elementare-ale-sirului-de-sufixe","title":"Aplica\u021bii elementare ale \u0219irului de sufixe","text":"<p>Aten\u021bie: pentru toate aplica\u021biile de mai jos mai pu\u021bin prima este necesar s\u0103 p\u0103str\u0103m \u0219irul de clase de la fiecare pas al sort\u0103rii.</p>","tags":["structuri de date","siruri de caractere"]},{"location":"avansat/suffix-array-tree/#rotatia-circulara-minim-lexicografica","title":"Rota\u021bia circular\u0103 minim lexicografic\u0103","text":"<p>Putem s\u0103 nu ad\u0103ug\u0103m santinela la finalul \u0219irului iar astfel vom ob\u021bine pe prima pozi\u021bie rota\u021bia minim lexicografic\u0103.</p>","tags":["structuri de date","siruri de caractere"]},{"location":"avansat/suffix-array-tree/#compararea-a-doua-subsecvente","title":"Compararea a dou\u0103 subsecven\u021be","text":"<p>Fie \\(M\\) minimul lungimilor subsecven\u021belor \u0219i \\(l = \\lfloor \\log_2{M} \\rfloor\\). Ca la \\(RMQ\\), putem compara cele dou\u0103 subsecven\u021be compar\u00e2nd perechile corespunz\u0103toare buc\u0103\u021bilor \u00een care le \u00eempar\u021bim folosind clasele de la pasul \\(l\\). \\(\\mathcal{O}(1)\\) pe query.</p>","tags":["structuri de date","siruri de caractere"]},{"location":"avansat/suffix-array-tree/#cel-mai-lung-prefix-comun-dintre-doua-subsecvente","title":"Cel mai lung prefix comun dintre dou\u0103 subsecven\u021be","text":"<p>Caut\u0103m binar pe lungimea r\u0103spunsului \u0219i ne folosim de aplica\u021bia 2 pentru a verifica dac\u0103 subsecven\u021bele corespunz\u0103toare sunt egale. \\(\\mathcal{O}(\\log_2{N})\\) pe query.</p>","tags":["structuri de date","siruri de caractere"]},{"location":"avansat/suffix-array-tree/#sirul-lcp","title":"\u0218irul LCP","text":"<p>\u0218irul \\(LCP\\) este o structur\u0103 de date auxiliar\u0103 \u0219irului de sufixe ce ne deschide o \u00eentreag\u0103 nou\u0103 lume \u00een privin\u021ba problemelor ce pot fi abordate. Acesta este definit astfel : \\(LCP_0 = 0\\) sau doar r\u0103m\u00e2ne nedefinit iar pentru restul avem $LCP_i = $ cel mai lung prefix comun al sufixelor de pe pozi\u021biile \\(i\\) \u0219i \\(i - 1\\) \u00een \u0219irul de sufixe. Acest \u0219ir are mai multe metode de construire : cea mai simpl\u0103 este folosirea repetat\u0103 a aplica\u021biei 3 de mai sus. Cu toate acestea, dorim s\u0103 prezent\u0103m \u0219i o alt\u0103 metod\u0103 de construire \u00een \\(\\mathcal{O}(N)\\) care nu necesit\u0103 men\u021binerea tabloului de clase de la fiecare pas, algoritmul lui Kasai.</p>","tags":["structuri de date","siruri de caractere"]},{"location":"avansat/suffix-array-tree/#algoritmul-lui-kasai","title":"Algoritmul lui Kasai","text":"<p>Acest algoritm se bazeaz\u0103 pe dou\u0103 observa\u021bii:  </p> <ol> <li> <p>dac\u0103 avem doua sufixe care \u00eencep de la pozi\u021biile \\(i\\) respectiv \\(j\\) \u0219i \\(lcp(i,    j) = x\\) atunci \\(lcp(i + 1, j + 1) \\geq x - 1\\)</p> </li> <li> <p>\\(lcp(i, j) = \\min\\limits_{id = R_i + 1}^{R_j} LCP_{id}\\) (lcp-ul dintre    oricare dou\u0103 sufixe este minimul din subsecven\u021ba format\u0103 de pozi\u021biile lor)</p> </li> </ol> <p>Acum c\u0103 am prezentat aceste dou\u0103 observa\u021bii, putem continua cu algoritmul: iter\u0103m prin toate sufixele, de la cel mai lung la cel mai scurt, \u0219i calcul\u0103m valoarea din \u0219irul \\(LCP\\) la pozi\u021bia \u00een care se afl\u0103 el.</p> <p>Dac\u0103 not\u0103m cu \\(l &gt; 0\\) valoarea ob\u021binut\u0103 la sufixul precedent, atunci ideea pivotal\u0103 din spatele acestui algoritm este urm\u0103toarea: putem incepe compararea direct de la indicele \\(l\\) \u00eentruc\u00e2t \u0219tim c\u0103 lcp-ul este cel pu\u021bin \\(l - 1\\).</p> <p>De unde \u0219tim asta? Fie \\(i\\) sufixul anterior si \\(j\\) sufixul cu care l - am comparat. A se observa ca \\(j\\) apare \u00eenaintea lui \\(i\\) \u00een \u0219irul de sufixe. Deoarece avem \\(l &gt; 0\\), putem spune cu certitudine ca sufixul \\(j + 1\\) apare \u00eenaintea lui \\(i + 1\\) iar din observa\u021bia 1 \u0219tim c\u0103 lcp-ul lor este cel pu\u021bin \\(l - 1\\).</p> <p>Dac\u0103 not\u0103m cu \\(k\\) sufixul cu care \u00eel compar\u0103m pe \\(i + 1\\), atunci ordinea de apari\u021bie \u00een \u0219irul de sufixe este \\(j + 1 \\leq k &lt; i + 1\\). Folosind observa\u021bia 2 ob\u021binem c\u0103 \\(lcp(k, i + 1) \\geq l - 1\\).</p> <p>Complexitatea de spa\u021biu este evident \\(\\mathcal{O}(N)\\). Complexitatea de timp necesit\u0103 mai mult\u0103 aten\u021bie: se observ\u0103 c\u0103 decrement\u0103m variabila fun de maxim \\(N\\) ori iar valoarea maxim\u0103 p\u00e2n\u0103 la care o putem incrementa este \\(N\\), a\u0219adar complexitatea de timp este \\(\\mathcal{O}(N)\\).</p> <p>Mai jos ave\u021bi un model de implementare:</p> <pre><code>vector&lt;int&gt; lcp(string &amp;s, vector&lt;int&gt; &amp;p) {\n    vector&lt;int&gt; r(s.size()), l(s.size(), 0);\n    int n = p.size();\n    for (int i = 0; i &lt; n; i++) {\n        r[p[i]] = i;  /// r[i] = pozitia sufixului i in sirul de sufixe\n    }\n\n    int fun = 0, j;\n    for (int i = 0; i &lt; n; i++) {\n        if (!r[i]) {\n            continue;\n        }\n\n        j = p[r[i] - 1];\n        while (i + fun &lt; n &amp;&amp; j + fun &lt; n &amp;&amp; s[i + fun] == s[j + fun]) {\n            fun++;\n        }\n        l[r[i]] = fun;\n        if (fun) {\n            fun--;\n        }\n    }\n\n    return l;\n}\n</code></pre>","tags":["structuri de date","siruri de caractere"]},{"location":"avansat/suffix-array-tree/#aplicatii-ce-folosesc-sirul-lcp-precum-si-sirul-de-sufixe","title":"Aplica\u021bii ce folosesc \u0219irul LCP precum \u0219i \u0219irul de sufixe","text":"<p>Leg\u0103tura dintre subsecven\u021be, prefixe \u0219i sufixe</p> <p>Reamintim c\u0103 orice subsecven\u021b\u0103 este prefix al unui sufix.</p>","tags":["structuri de date","siruri de caractere"]},{"location":"avansat/suffix-array-tree/#pattern-matching-cses","title":"Pattern Matching (CSES)","text":"<p>Cerin\u021b\u0103</p> <p>Se d\u0103 un text \\(T\\) si multiple \u0219iruri \\(P\\) pentru care se cer s\u0103 afl\u0103m de c\u00e2te ori apar \u00een \\(T\\) ca subsecven\u021b\u0103.</p> <p>\u00cen primul r\u00e2nd, orice subsecven\u021ba este un prefix al unui sufix. Astfel, se observ\u0103 c\u0103 toate sufixele \u00een care \\(P\\) este prefix vor forma o subsecven\u021b\u0103 \u00een \u0219irul de sufixe. Pentru a numara de c\u00e2te ori apare \\(P\\) este de ajuns s\u0103 c\u0103utam ternar primul sufix \u00een care apare \\(P\\) ca prefix iar apoi s\u0103 c\u0103utam binar c\u00e2t de mult de putem extinde la dreapta astfel \u00eenc\u00e2t lcp-ul dintre \\(P\\) \u0219i ultimul sufix din subsecven\u021b\u0103 s\u0103 fie \\(|P|\\). Complexitate: \\(\\mathcal{O}(|P| \\log {N})\\) pe query.</p> <p>Solu\u021bia optim\u0103</p> <p>Este probabil s\u0103 lua\u021bi TLE pe aceast\u0103 problem\u0103 deoarece solu\u021bia optim\u0103 este de complexitate liniar\u0103.</p>","tags":["structuri de date","siruri de caractere"]},{"location":"avansat/suffix-array-tree/#repeating-substring-cses","title":"Repeating Substring (CSES)","text":"<p>Cerin\u021b\u0103</p> <p>Se d\u0103 un text \u0219i se cere s\u0103 afi\u0219\u0103m cel mai lung \u0219ir posibil care apare \u00een text ca subsecven\u021b\u0103 de cel pu\u021bin dou\u0103 ori.</p> <p>R\u0103spunsul se ob\u021bine analiz\u00e2nd \u0219irul LCP. Ne uit\u0103m la fiecare sufix pe r\u00e2nd \u0219i ne \u00eentreb\u0103m: \"Care este lungimea maxim\u0103 a unui \u0219ir care apare \u00een acest sufix ca prefix \u0219i respect\u0103 proprietatea din enun\u021b ?\". R\u0103spunsul este evident LCP-ul curent (poate fi \u0219i LCP-ul urm\u0103tor dar avem grij\u0103 de asta la urmatorul pas). Astfel, este de ajuns s\u0103 g\u0103sim minimul din \u0219irul LCP. Aceast\u0103 idee se poate generaliza \u0219i pentru mai multe apari\u021bii, a\u0219a cum ve\u021bi vedea la problemele suplimentare. Ave\u021bi solu\u021bia autorului aici.</p>","tags":["structuri de date","siruri de caractere"]},{"location":"avansat/suffix-array-tree/#distinct-substringscses","title":"Distinct substrings(CSES)","text":"<p>Cerin\u021b\u0103</p> <p>C\u00e2te subsecven\u021be distincte are un \u0219ir? Subsecven\u021bele se disting \u00een func\u021bie de caractere, nu de indici.</p> <p>Vom sc\u0103dea din num\u0103rul total de subsecven\u021be num\u0103rul de subsecven\u021be gre\u0219ite. Pentru a calcula acest num\u0103r iter\u0103m prin \u0219irul LCP: atunci c\u00e2nd suntem la indicele \\(i\\), prefixele acestui sufix care au ap\u0103rut \u00eenainte sunt \u00een num\u0103r de \\(LCP_i\\). Astfel, rezultatul se ob\u021bine sc\u0103z\u00e2nd toate elementele din \u0219irul \\(LCP\\). Solu\u021bia mea o g\u0103si\u021bi aici.</p>","tags":["structuri de date","siruri de caractere"]},{"location":"avansat/suffix-array-tree/#probleme-suplimentare","title":"Probleme suplimentare","text":"<ul> <li>CSES Substring Order I</li> <li>CSES Substring distribution</li> <li>Kattis kindaokarray</li> <li>Lot Seniori 2016 - parb</li> <li>Codeforces Forbidden Indices</li> <li>Probleme cu structuri pe siruri de caractere</li> </ul>","tags":["structuri de date","siruri de caractere"]},{"location":"avansat/suffix-array-tree/#materiale-suplimentare","title":"Materiale suplimentare","text":"<ul> <li>Codeforces - Dynamic Suffix Array</li> <li>Curs MIT de pe Youtube</li> <li>Articolul de pe cp-algorithms</li> </ul>","tags":["structuri de date","siruri de caractere"]},{"location":"avansat/treaps/","title":"Treap-uri","text":"<p>Daca vreti sa ne ajutati cu acest articol, ne puteti gasi pe github sau pe serverul nostru de discord</p> <p>Mai jos g\u0103si\u021bi resurse pe care le pute\u021bi citi p\u00e2n\u0103 atunci.</p>","tags":["structuri de date","arbori","randomizare"]},{"location":"avansat/treaps/#introducere","title":"Introducere","text":"","tags":["structuri de date","arbori","randomizare"]},{"location":"avansat/treaps/#problema-exemplu","title":"Problema exemplu","text":"","tags":["structuri de date","arbori","randomizare"]},{"location":"avansat/treaps/#concluzii","title":"Concluzii","text":"","tags":["structuri de date","arbori","randomizare"]},{"location":"avansat/treaps/#probleme-suplimentare","title":"Probleme suplimentare","text":"","tags":["structuri de date","arbori","randomizare"]},{"location":"avansat/treaps/#resurse-suplimentare","title":"Resurse suplimentare","text":"","tags":["structuri de date","arbori","randomizare"]},{"location":"avansat/virtual-tree/","title":"Arbore virtual (virtual tree)","text":"<p>Daca vreti sa ne ajutati cu acest articol, ne puteti gasi pe github sau pe serverul nostru de discord</p> <p>Mai jos g\u0103si\u021bi resurse pe care le pute\u021bi citi p\u00e2n\u0103 atunci.</p>","tags":["structuri de date","arbori","optimizare"]},{"location":"avansat/virtual-tree/#introducere","title":"Introducere","text":"","tags":["structuri de date","arbori","optimizare"]},{"location":"avansat/virtual-tree/#problema-exemplu","title":"Problema exemplu","text":"","tags":["structuri de date","arbori","optimizare"]},{"location":"avansat/virtual-tree/#concluzii","title":"Concluzii","text":"","tags":["structuri de date","arbori","optimizare"]},{"location":"avansat/virtual-tree/#probleme-suplimentare","title":"Probleme suplimentare","text":"","tags":["structuri de date","arbori","optimizare"]},{"location":"avansat/virtual-tree/#resurse-suplimentare","title":"Resurse suplimentare","text":"","tags":["structuri de date","arbori","optimizare"]},{"location":"codes/cppintro/strings/ascii/","title":"Ascii","text":"Dec Caracter Dec Caracter Dec Caracter Dec Caracter 0 NUL 32 `` 64 @ 96 ` 1 SOH 33 ! 65 A 97 a 2 STX 34 \" 66 B 98 b 3 ETX 35 # 67 C 99 c 4 EOT 36 $ 68 D 100 d 5 ENQ 37 % 69 E 101 e 6 ACK 38 &amp; 70 F 102 f 7 BEL 39 ' 71 G 103 g 8 BS 40 ( 72 H 104 h 9 TAB 41 ) 73 I 105 i 10 LF 42 * 74 J 106 j 11 VT 43 + 75 K 107 k 12 FF 44 , 76 L 108 l 13 CR 45 - 77 M 109 m 14 SO 46 . 78 N 110 n 15 SI 47 / 79 O 111 o 16 DLE 48 0 80 P 112 p 17 DC1 49 1 81 Q 113 q 18 DC2 50 2 82 R 114 r 19 DC3 51 3 83 S 115 s 20 DC4 52 4 84 T 116 t 21 NAK 53 5 85 U 117 u 22 SYN 54 6 86 V 118 v 23 ETB 55 7 87 W 119 w 24 CAN 56 8 88 X 120 x 25 EM 57 9 89 Y 121 y 26 SUB 58 : 90 Z 122 z 27 ESC 59 ; 91 [ 123 { 28 FS 60 &lt; 92 \\ 124 | 29 GS 61 = 93 ] 125 } 30 RS 62 &gt; 94 ^ 126 ~ 31 US 63 ? 95 _ 127 DEL"},{"location":"cppintro/","title":"Introducere \u00een C++","text":"<p>Bine ai venit! Te vom asista \u00een c\u0103l\u0103toria ta de a \u00eenv\u0103\u021ba C++. Acest curs a fost g\u00e2ndit de la bun \u00eenceput s\u0103 fie practic \u0219i adaptat la limbajul C++ modern (C++11 \u0219i mai \u00eencolo).</p>"},{"location":"cppintro/#compilator-si-editor-local","title":"Compilator \u0219i editor local","text":"<p>Pentru a putea \u00eencepe, avem nevoie de un compilator. Un compilator este un program care traduce codul surs\u0103 scris \u00eentr-un limbaj (\u00een cazul nostru, C++) \u00een alt limbaj. Limbajul \u021bint\u0103 este cod ma\u0219in\u0103, adic\u0103 limbajul pe care \u00eel poate \u00een\u021belege \u0219i rula \u00een consecin\u021b\u0103 procesorul. Compilatorul va fi cel mai bun prieten al t\u0103u, a\u0219a c\u0103 este esen\u021bial s\u0103 instal\u0103m un compilator bun.</p> <p>Pentru \u00eenceput, ce sistem de operare folose\u0219ti?</p> <ul> <li> <p> Folosesc Windows 10/11</p> <p> Vezi instruc\u021biuni</p> </li> <li> <p> Folosesc macOS (10.15+)</p> <p> Vezi instruc\u021biuni</p> </li> <li> <p> Folosesc Linux</p> <p> Vezi instruc\u021biuni</p> </li> </ul> <p>Pentru alte op\u021biuni, recomand\u0103m acest articol.</p>"},{"location":"cppintro/#editoare-online","title":"Editoare online","text":"<p>Observa\u021bie</p> <p>Aceast\u0103 solu\u021bie trebuie s\u0103 fie una strict temporar\u0103. Niciun programator serios nu se bazeaz\u0103 strict pe editoare online, editoarele locale au multe avantaje comparativ cu cele online.</p> <p>Totu\u0219i, dac\u0103 dore\u0219ti s\u0103 nu lucrezi folosind un compilator \u0219i un editor, exist\u0103 solu\u021bii online pentru a scrie cod \u00een limbajul C++. O asemenea op\u021biune pe care autorii arhivei o recomand\u0103 este USACO Guide IDE.</p> <p>Pentru alte op\u021biuni, recomand\u0103m acest articol.</p>"},{"location":"cppintro/#concluzii","title":"Concluzii","text":"<p>Editoarele locale sunt mult mai folositoare dec\u00e2t cele online, deoarece permit o varietate de op\u021biuni \u0219i sunt mult mai versatile, fiind \u0219i folosite la concursurile reale de programare competitiv\u0103, inclusiv olimpiad\u0103.</p> <p>Dup\u0103 \u021bi-ai instalat compilatorul \u0219i editorul dorit, te invit\u0103m s\u0103 explorezi facilit\u0103\u021bile limbajului C++, \u00eencep\u00e2nd cu acest articol.</p>"},{"location":"cppintro/arrays/","title":"Vectori (tablouri unidimensionale)","text":"<p>Una din primele structuri de date pe care orice programator o folose\u0219te, indiferent de limbajul de programare folosit este tabloul (array \u00een englez\u0103). Ace\u0219tia stau la baza unui num\u0103r mare de prelucr\u0103ri care necesit\u0103 un volum mare de date, iar \u00een contextul rezolv\u0103rii problemelor de algoritmic\u0103, tablouri sunt o parte fundamental\u0103 at\u00e2t \u00een sine, c\u00e2t \u0219i prin faptul c\u0103 toate tablourile multidimensionale sunt de fapt, tablouri unidimensionale pu\u0219i \u00eempreun\u0103. Colocvial, aceste tablouri mai sunt numite \u0219i vectori, dar trebuie evitat\u0103 confuzia cu vectorii din STL, prezenta\u021bi ulterior.</p> <p>Observa\u021bie</p> <p>\u00cen memorie, tablourile sunt stocate secven\u021bial, indiferent de num\u0103rul de dimensiuni pe care \u00eel au.</p> <p>\u00cen contextul limbajului C++, putem lucra cu tablourile \u00een dou\u0103 moduri distincte: fie folosind varianta standard, luat\u0103 din limbajul C, fie folosind STL (Standard Template Library). Conceptele din STL vor fi prezentate \u00een capitolele ulterioare, deoarece acesta nu con\u021bine doar tablouri dinamice. \u00cen acest capitol voi insista mai ales pe varianta standard, lucrul cu STL fiind aprofundat mai cu seam\u0103 \u00een capitolele utile.</p>","tags":["vectori","implementare"]},{"location":"cppintro/arrays/#declararea-si-umplerea-tablourilor-statice","title":"Declararea \u0219i umplerea tablourilor statice","text":"<p>Pentru a declara un tablou \u0219i a da valori, trebuie s\u0103 analiz\u0103m structura acestuia. \u00cen mod similar cu variabilele simple, ne trebuie un tip de date pe care acest tablou s\u0103-l stocheze, precum \u0219i dimensiunea pe care vrem s\u0103 o atribuim acestui tablou.</p> <p>De exemplu, <code>int v[101];</code> \u00eenseamn\u0103 ca am declarat un tablou cu 101 elemente, pozi\u021biile fiind num\u0103rate de la 0 la 100.</p> <p>Observa\u021bie</p> <p>Dac\u0103 prefera\u021bi s\u0103 lucra\u021bi cu tablouri indexate de la 1, ave\u021bi grij\u0103 s\u0103 ad\u0103uga\u021bi 1 la dimensiunile pe care le folosi\u021bi pentru a adapta tablourile la stilul vostru de lucru. De asemenea, nu pute\u021bi \u00eencepe tablourile de la indici negativi cum se poate \u00een alte limbaje (Pascal, de pild\u0103) \u0219i nici s\u0103-i folosi\u021bi pentru a lua elemente de la final (ca \u00een Python).</p> <p>Observa\u021bie</p> <p>De obicei, dimensiunea maxim\u0103 este una static\u0103, dar putem transforma tablourile statice \u00een structuri alocate dinamic folosind func\u021biile din limbajul C. Totu\u0219i, acesta nu este scopul articolului de fa\u021b\u0103, iar ulterior va fi prezentat STL.</p> <p>Pentru a atribui o valoare unei anumite pozi\u021bii, se va proceda similar ca la o variabil\u0103 obi\u0219nuit\u0103, de exemplu <code>v[5] = 7;</code> \u00eenseamn\u0103 c\u0103 pe pozi\u021bia 5, vom avea acum valoarea 7.</p> <p>Pentru a citi un vector, vom folosi de regul\u0103 o structur\u0103 repetitiv\u0103, precum for sau while, citind valorile pe r\u00e2nd, la fel cum am proceda cu variabile obi\u0219nuite.</p> <p>O alt\u0103 metod\u0103 de a ini\u021bializa elementele dintr-un tablou este aceea de a atribui valori primelor pozi\u021bii, idee ce va fi folosit\u0103 pe parcurs la diver\u0219i algoritmi, un exemplu notabil fiind flood fill. De exemplu, <code>int A[] = {10, 20, 30};</code> va crea un tablou cu 3 elemente, unde <code>A[0] = 10; A[1] = 20;</code> \u0219.a.m.d.</p>","tags":["vectori","implementare"]},{"location":"cppintro/arrays/#problema-exemplu-afisare0-de-pe-pbinfo","title":"Problem\u0103 exemplu - afisare0 de pe pbinfo","text":"<p>Pentru a rezolva aceast\u0103 problem\u0103, va trebui mai \u00eent\u00e2i s\u0103 citim valorile \u00een tablou, iar mai apoi s\u0103 parcurgem valorile pentru a afla multiplii ultimului element.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int n;\n    cin &gt;&gt; n;\n\n    // Vector cu n elemente\n    int v[n + 1];\n\n    for (int i = 1; i &lt;= n; i++) {\n        cin &gt;&gt; v[i];\n    }\n\n    for (int i = 1; i &lt;= n; i++) {\n        if (v[i] % v[n] == 0) {\n            cout &lt;&lt; v[i] &lt;&lt; \" \";\n        }\n    }\n\n    return 0;\n}\n</code></pre>","tags":["vectori","implementare"]},{"location":"cppintro/arrays/#inserarea-stergerea-inversarea-valorilor-dintr-un-tablou","title":"Inserarea, \u0219tergerea, inversarea valorilor dintr-un tablou","text":"<p>De multe ori \u00een diverse aplica\u021bii, putem avea nevoie de opera\u021bia de inserare \u0219i de opera\u021bia de \u0219tergere din tablou, ambele opera\u021bii fiind foarte importante pentru a putea lucra \u00een mod corespunz\u0103tor cu tablourile. \u00cen exemplele pe care le voi prezenta mai jos, voi presupune c\u0103 tablourile sunt indexate de la 1.</p>","tags":["vectori","implementare"]},{"location":"cppintro/arrays/#inserarea-in-tablou","title":"Inserarea \u00een tablou","text":"<p>Dac\u0103 avem un tablou cu \\(n\\) valori \u0219i vrem s\u0103 inser\u0103m o valoare nou\u0103 la pozi\u021bia \\(k\\), unde \\(1 \\leq k \\leq n+1\\), vom vrea mai \u00eent\u00e2i s\u0103 mut\u0103m valorile \u00eentre pozi\u021biile \\(n\\) \u0219i \\(k\\) cu o pozi\u021bie la dreapta, iar mai apoi vom atribui noua valoare pe pozi\u021bia \\(k\\).  </p> <pre><code>for (int i = n; i &gt;= k; i--) {\n    v[i + 1] = v[i];\n}\n\nv[k] = x;\n\nn++;  // (1)\n</code></pre> <ol> <li>Tabloul va avea o valoare \u00een plus, drept pentru care trebuie s\u0103 cre\u0219tem \u00een    consecin\u021b\u0103 lungimea sa.</li> </ol> <p>Aten\u021bie</p> <p>Mutarea valorilor trebuie f\u0103cut\u0103 \u00een ordine descresc\u0103toare a pozi\u021biilor ini\u021biale deoarece altfel, am ajunge s\u0103 avem aceea\u0219i valoare peste tot.</p> <pre><code>for (int i = k; i &lt;= n; i++) {\n    v[i + 1] = v[i];\n}\n\nv[k] = x;\n\nn++;\n</code></pre> <p>Se poate observa cu u\u0219urin\u021b\u0103 c\u0103 valoarea de pe pozi\u021bia \\(k\\) va ajunge peste tot dac\u0103 implement\u0103m a\u0219a, ceea ce este gre\u0219it.</p>","tags":["vectori","implementare"]},{"location":"cppintro/arrays/#stergerea-din-tablou","title":"\u0218tergerea din tablou","text":"<p>Dac\u0103 avem un tablou cu \\(n\\) valori \u0219i vrem s\u0103 \u0219tergem valoarea de la pozi\u021bia \\(k\\), unde \\(1 \\leq k \\leq n\\), vom vrea s\u0103 mut\u0103m pe r\u00e2nd valorile de la pozi\u021biile \\(k+1\\), \\(k+2\\), ..., \\(n\\) cu o pozi\u021bie mai \u00een spate. Spre deosebire de cazul inser\u0103rii, vom vrea s\u0103 mut\u0103m valorile \u00een ordine cresc\u0103toare a pozi\u021biei ini\u021biale.</p> <pre><code>for (int i = k; i &lt; n; i++) {\n    v[i] = v[i + 1];\n}\n\nn--;  // (1)\n</code></pre> <ol> <li>Tabloul va avea o valoare \u00een minus, drept pentru care trebuie s\u0103 sc\u0103dem \u00een    consecin\u021b\u0103 lungimea sa.</li> </ol> <p>Aten\u021bie</p> <p>Mutarea valorilor trebuie f\u0103cut\u0103 \u00een ordine cresc\u0103toare a pozi\u021biilor ini\u021biale deoarece altfel, am ajunge s\u0103 avem aceea\u0219i valoare peste tot.</p> <pre><code>--8&lt;-- \"cppintro/arrays/ins_sterg_inv.cpp:stergere_warning\" \n</code></pre>","tags":["vectori","implementare"]},{"location":"cppintro/arrays/#inversarea-unui-tablou","title":"Inversarea unui tablou","text":"<p>Pentru a putea inversa un tablou, trebuie s\u0103 \u0219tim num\u0103rul de elemente pe care \u00eel are. Scopul nostru este s\u0103 avem pe pozi\u021bia \\(i\\) valoarea ce se afla anterior pe pozi\u021bia \\(n - i + 1\\), implementarea nefiind prea dificil\u0103. Pentru a p\u0103stra scopul educativ, am implementat interschimbarea elementelor folosind \"regula celor trei pahare\".</p> <pre><code>for (int i = 1; i &lt;= n / 2; i++) {\n    int x = v[i];         // (1)\n    v[i] = v[n - i + 1];  // (2)\n    v[n - i + 1] = x;     // (3)\n}\n</code></pre> <ol> <li>Re\u021binem valoarea lui <code>v[i]</code> \u00een <code>x</code>.</li> <li>Interschimb\u0103m <code>v[i]</code> cu pozi\u021bia echivalent\u0103 de la cap\u0103tul tabloului,    adic\u0103 <code>v[n - i + 1]</code>.</li> <li>Re\u021binem valoarea lui <code>v[i]</code> \u00een <code>x</code>.</li> </ol>","tags":["vectori","implementare"]},{"location":"cppintro/arrays/#interclasarea-tablourilor","title":"Interclasarea tablourilor","text":"<p>Pentru a putea interclasa dou\u0103 tablouri (de regul\u0103, cresc\u0103toare) \\(A\\) \u0219i \\(B\\), av\u00e2nd \\(n\\), respectiv \\(m\\) elemente, vom vrea mereu s\u0103 introducem valoarea mai mic\u0103 \u00een tabloul unde \u021binem rezultatul, \\(C\\), acesta av\u00e2nd lungimea \\(n + m\\). De asemenea, vom vrea s\u0103 avem grij\u0103 ca dup\u0103 ce prelucr\u0103m complet unul din cele dou\u0103 tablouri, s\u0103 continu\u0103m inser\u0103rile cu cel de-al doilea tablou, unul din ele ar r\u0103m\u00e2ne mereu cu valori.</p> <p>Observa\u021bie</p> <p>Folosind acest algoritm de interclasare, putem ob\u021bine un tablou cresc\u0103tor \u00een \\(\\mathcal{O}(n + m)\\), unde \\(n\\) \u0219i \\(m\\) sunt lungimile celor dou\u0103 \u0219iruri.</p> <p>Observa\u021bie</p> <p>Folosind un algoritm similar cu cel prezentat mai jos, putem implementa diverse opera\u021bii pe mul\u021bimi, precum reuniunea, intersec\u021bia \u0219i diferen\u021ba.</p> <pre><code>int i = 1;\nint j = 1;\nint poz = 0;\n\n// Mergem prin tablou p\u00e2n\u0103 c\u00e2nd am parcurs unul din ele.\nwhile (i &lt;= n &amp;&amp; j &lt;= m) {\n    poz++;\n\n    // Punem \u00een C elementul mai mic dintre A[i] \u0219i B[j]\n    if (A[i] &lt;= B[j]) {\n        C[poz] = A[i];\n        i++;\n    } else {\n        C[poz] = B[j];\n        j++;\n    }\n}\n\n// Dac\u0103 mai exist\u0103 elemente \u00een A, adaug\u0103-le \u00een C.\nwhile (i &lt;= n) {\n    poz++;\n    C[poz] = A[i];\n    i++;\n}\n\n// Dac\u0103 mai exist\u0103 elemente \u00een B, adaug\u0103-le \u00een C.\nwhile (j &lt;= m) {\n    poz++;\n    C[poz] = B[j];\n    j++;\n}\n</code></pre>","tags":["vectori","implementare"]},{"location":"cppintro/arrays/#rotirea-tablourilor","title":"Rotirea tablourilor","text":"<p>Observa\u021bie</p> <p>Ve\u021bi g\u0103si aceast\u0103 metod\u0103 numit\u0103 \u0219i permutarea circular\u0103 a valorilor dintr-un \u0219ir, deoarece dac\u0103 oper\u0103m aceast\u0103 opera\u021bie de un num\u0103r suficient de ori, vom reveni la configura\u021bia ini\u021bial\u0103.</p> <p>Pentru a putea roti un tablou (mutarea valorilor din el cu un num\u0103r \\(k\\) de pozi\u021bii la st\u00e2nga sau la dreapta), va trebui mai \u00eent\u00e2i s\u0103 p\u0103str\u0103m \u00een memorie valoarea de pe primele/ultimele \\(k\\) pozi\u021bii, s\u0103 mut\u0103m secven\u021bial celelalte valori \u0219i \u00een cele din urm\u0103 s\u0103 mut\u0103m valorile p\u0103strate pe ultimele/primele \\(k\\) pozi\u021bii \u00een \u0219irul nou rezultat.</p> <p>De\u0219i algoritmul prezentat este unul liniar, mai t\u00e2rziu pute\u021bi descoperi o structur\u0103 de date ce permite rota\u021bia unui tablou cu o singur\u0103 pozi\u021bie la st\u00e2nga sau dreapta.</p> <pre><code>void rotire(int arr[], int n, bool laStanga = true, int k = 1) {\n    k = k % n;\n\n    // Dac\u0103 k = 0 (k este multiplu de n), nu facem nimic.\n    if (k == 0) {\n        return;\n    }\n\n    int temp[k];\n    if (laStanga) {\n        rotireLaStanga(arr, n, k);\n    } else {\n        rotireLaDreapta(arr, n, k);\n    }\n}\n</code></pre> Rotire la st\u00e2ngaRotire la dreapta <pre><code>void rotireLaStanga(int arr[], int n, int k) {\n    int temp[k];\n\n    // P\u0103str\u0103m primele k elemente\n    for (int i = 0; i &lt; k; ++i) {\n        temp[i] = arr[i];\n    }\n\n    // Mut\u0103m elementele spre st\u00e2nga\n    for (int i = 0; i &lt; n - k; ++i) {\n        arr[i] = arr[i + k];\n    }\n\n    // Plas\u0103m elementele p\u0103strate la sf\u00e2r\u0219it\n    for (int i = 0; i &lt; k; ++i) {\n        arr[n - k + i] = temp[i];\n    }\n}\n</code></pre> <pre><code>void rotireLaDreapta(int arr[], int n, int k) {\n    int temp[k];\n\n    // P\u0103str\u0103m ultimele k elemente\n    for (int i = 0; i &lt; k; ++i) {\n        temp[i] = arr[n - k + i];\n    }\n\n    // Mut\u0103m elementele spre dreapta\n    for (int i = n - 1; i &gt;= k; --i) {\n        arr[i] = arr[i - k];\n    }\n\n    // Plas\u0103m elementele p\u0103strate la \u00eenceput\n    for (int i = 0; i &lt; k; ++i) {\n        arr[i] = temp[i];\n    }\n}\n</code></pre>","tags":["vectori","implementare"]},{"location":"cppintro/arrays/#sortarea-tablourilor","title":"Sortarea tablourilor","text":"<p>\u00cen multe probleme, suntem nevoi\u021bi s\u0103 ordon\u0103m valorile din \u0219ir conform unui algoritm. \u00cen func\u021bie de performan\u021ba de care avem nevoie, putem avea algoritmi \u00een complexitate \\(\\mathcal{O}(n^2)\\), \\(\\mathcal{O}(n \\log n)\\) \u0219i multe alte clase de complexit\u0103\u021bi.</p> <p>Pentru mai multe detalii, recomand\u0103m citirea articolului pe acest subiect, pe care \u00eel pute\u021bi g\u0103si aici.</p>","tags":["vectori","implementare"]},{"location":"cppintro/arrays/#concluzii","title":"Concluzii","text":"<p>Lucrul cu tablouri unidimensionale este esen\u021bial oric\u0103rui algoritmist, principiile men\u021bionate aici fiind aplicate \u00een diverse moduri \u0219i \u00een ceea ce prive\u0219te alte structuri de date, a\u0219a cum ve\u021bi putea observa \u00een problemele cu matrici \u0219i \u00een diferi\u021bi algoritmi care au la baz\u0103 metodele folosite mai sus.</p>","tags":["vectori","implementare"]},{"location":"cppintro/arrays/#probleme-suplimentare","title":"Probleme suplimentare","text":"<ul> <li>Problemele usoare si medii din capitolul Parcurgerea   vectorilor</li> <li>Problemele usoare si medii din capitolul \u0218tergeri \u0219i inser\u0103ri de elemente \u00een   vectori</li> <li>Problemele usoare si medii din capitolul Verificarea unor   propriet\u0103\u0163i</li> <li>Problemele usoare si medii din capitolul   Interclasare</li> </ul>","tags":["vectori","implementare"]},{"location":"cppintro/arrays/#resurse-suplimentare","title":"Resurse suplimentare","text":"<ul> <li>Declararea \u0219i parcurgerea tablourilor   unidimensionale</li> <li>\u0218tergeri \u0219i inser\u0103ri de   elemente</li> <li>Verificarea unor   propriet\u0103\u021bi</li> <li>Interclasarea   tablourilor</li> </ul>","tags":["vectori","implementare"]},{"location":"cppintro/basic-math/","title":"Operatori \u0219i expresii. Cuno\u0219tin\u021be matematice de baz\u0103","text":"","tags":["matematica","aritmetica","C++"]},{"location":"cppintro/basic-math/#introducere","title":"Introducere","text":"<p>Un mit care este r\u0103sp\u00e2ndit de foarte mul\u021bi oameni \u00een diverse medii este acela c\u0103 matematica nu are vreo relevan\u021b\u0103 \u00een programare sau algoritmic\u0103, ceea ce nu poate fi mai fals. De\u0219i nu este necesar s\u0103 fii olimpic la matematic\u0103 pentru a fi foarte bun la algoritmic\u0103 sau mai ales pentru a fi un bun programator, cuno\u0219tin\u021bele adecvate de matematic\u0103 sunt foarte importante deoarece foarte mul\u021bi algoritmi \u0219i foarte multe ramuri ale informaticii se bazeaz\u0103 pe un fundament matematic solid, care s\u0103 permit\u0103 aprofundarea unor capitole specifice.</p> <p>Observa\u021bie</p> <p>Totu\u0219i, dac\u0103 e\u0219ti deja foarte bun la matematic\u0103 sau chiar olimpic, asta va face \u00eenv\u0103\u021barea multor capitole mai u\u0219oar\u0103, deoarece foarte multe no\u021biuni se coreleaz\u0103 cu cele de la matematic\u0103. \u00cen esen\u021b\u0103, programarea se reduce \u00een multe situa\u021bii la limbaj matematic transpus \u00een cod citibil de ma\u0219inile de calcul.</p> <p>De exemplu, de-a lungul studiului algoritmicii, pe l\u00e2ng\u0103 cuno\u0219tin\u021bele matematice de baz\u0103 care vor fi subiectul acestui articol, ve\u021bi avea de-a face cu capitole specifice combinatoricii, divizibilit\u0103\u021bii, teoriei numerelor, geometriei, algebrei liniare \u0219i multe alte subiecte care introduc cititorii \u00een algoritmi mai avansa\u021bi.</p> <p>Chiar \u0219i \u00een aplica\u021bii mai simple, modelarea unor probleme de matematic\u0103 folosind programe a devenit foarte important\u0103 \u00een ultimele decenii, \u00eenv\u0103\u021barea f\u0103c\u00e2ndu-se \u00een prezent aproape exclusiv cu ajutorul solu\u021biilor digitale.</p> <p>\u00cen cele ce urmeaz\u0103, vom discuta fundamentele opera\u021biilor matematice de baz\u0103, sintaxa lor \u00een limbajul C++ precum \u0219i c\u00e2teva lucruri esen\u021biale pe care trebuie s\u0103 le ave\u021bi \u00een vedere atunci c\u00e2nd vre\u021bi s\u0103 simplifica\u021bi lucrurile \u00een ceea ce prive\u0219te aplicarea lor \u00een diverse contexte.</p>","tags":["matematica","aritmetica","C++"]},{"location":"cppintro/basic-math/#operatii-aritmetice-pe-numere-intregi","title":"Opera\u021bii aritmetice pe numere \u00eentregi","text":"<p>\u00cen primul r\u00e2nd, orice problem\u0103 pe care o rezolva\u021bi implic\u0103 \u00eentr-un mod sau altul opera\u021biile aritmetice de baz\u0103 (adunarea, sc\u0103derea, \u00eenmul\u021birea, \u00eemp\u0103r\u021birea).</p> <p>Ordinea efectu\u0103rii opera\u021biilor este aceea\u0219i ca la matematic\u0103, opera\u021biile de \u00eenmul\u021bire \u0219i \u00eemp\u0103r\u021bire sunt efectuate \u00eenaintea celor de adunare \u0219i sc\u0103dere.</p> <p>Pentru a evita confuzia \u00een ceea ce prive\u0219te folosirea diverselor opera\u021bii matematice, se recomand\u0103 folosirea parantezelor pentru a simplifica calculele.</p> <p>\u00cen ceea ce prive\u0219te opera\u021bia de \u00eemp\u0103r\u021bire pe numere \u00eentregi, rezultatul afi\u0219at va fi mereu num\u0103rul f\u0103r\u0103 virgul\u0103.</p> <pre><code>cout &lt;&lt; 8 + 2 &lt;&lt; '\\n';   // 10\ncout &lt;&lt; 4 * 3 &lt;&lt; '\\n';   // 12\ncout &lt;&lt; 12 - 5 &lt;&lt; '\\n';  // 7\ncout &lt;&lt; 16 / 4 &lt;&lt; '\\n';  // 4\ncout &lt;&lt; 15 / 4 &lt;&lt; '\\n';  // 3\ncout &lt;&lt; -9 / 3 &lt;&lt; '\\n';  // -3\ncout &lt;&lt; -8 / 3 &lt;&lt; '\\n';  // -2\n</code></pre> <p>\u00cen mod particular, pentru opera\u021biile aritmetice de baz\u0103, putem folosi prefixarea \u0219i postfixarea, dup\u0103 cum se poate vedea \u00een solu\u021bia pe care o prezent\u0103m care rezolv\u0103 corect problema asii de pe pbinfo:</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    int sum = a + b;\n\n    int diff = a;\n    diff -= b;\n\n    // Pentru ce e mai sus, puteam scrie \u0219i:\n    //\n    //     int diff = a - b;\n    //\n    // diff -= b \u00eenseamn\u0103 diff = diff - b;\n    //\n    // Similar, putem scrie si a /= b, a += b, a *= b\n\n    int prod = a * b;\n    int ratio = a / b;\n\n    cout &lt;&lt; sum &lt;&lt; \" \" &lt;&lt; diff &lt;&lt; \" \" &lt;&lt; prod &lt;&lt; \" \" &lt;&lt; ratio &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["matematica","aritmetica","C++"]},{"location":"cppintro/basic-math/#solutii-pentru-evitarea-overflow-ului","title":"Solu\u021bii pentru evitarea overflow-ului","text":"<p>Observa\u021bie</p> <p>Trebuie avut grij\u0103 la faptul c\u0103 dac\u0103 rezultatul opera\u021biei dep\u0103\u0219e\u0219te valoarea maxim\u0103 sau minim\u0103 a tipului de date \u00een care acesta este p\u0103strat, vom avea overflow-uri, care trebuie evitate cu orice pre\u021b.</p> <p>Cele mai populare dou\u0103 solu\u021bii sunt fie folosirea tipului de date long long pentru p\u0103strarea termenilor din opera\u021bii, fie folosirea operatorului 1LL, fie folosirea <code>(long long)</code> pentru convertirea datelor.</p> <pre><code>cout &lt;&lt; 594943 * 204232 &lt;&lt; '\\n';  // overflow\n\ncout &lt;&lt; 1LL * 594943 * 204232 &lt;&lt; '\\n';  // ok\n\ncout &lt;&lt; (long long)594943 * 204232 &lt;&lt; '\\n';  // ok\ncout &lt;&lt; 594943LL * 204232 &lt;&lt; '\\n';           // echivalent\n\ncout &lt;&lt; 594943 * (long long)204232 &lt;&lt; '\\n';  // ok\ncout &lt;&lt; 594943 * 204232LL &lt;&lt; '\\n';           // echivalent\n</code></pre> <p>O alt\u0103 solu\u021bie pentru evitarea overflow-urilor \u00een cazul \u00een care trebuie s\u0103 verific\u0103m dac\u0103 produsele dep\u0103\u0219esc o anumit\u0103 valoare este s\u0103 verific\u0103m rezultatul \u00eemp\u0103r\u021birii unui de\u00eemp\u0103r\u021bit la un \u00eemp\u0103r\u021bitor. Cu alte cuvinte, \u00een loc s\u0103 verific\u0103m dac\u0103 \\(a \\cdot b \\geq c\\), vom verifica dac\u0103 \\(\\frac{c}{a} \\geq b\\). Un exemplu de problem\u0103 este problema Overflow de pe pbinfo, solu\u021bia o g\u0103si\u021bi \u00een codul de mai jos.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    // Cel mai mare num\u0103r de tip unsigned long long\n    unsigned long long huge = 18446744073709551615;\n\n    int n;\n    cin &gt;&gt; n;\n\n    for (int i = 0; i &lt; n; i++) {\n        unsigned long long nr1, nr2;\n        cin &gt;&gt; nr1 &gt;&gt; nr2;\n\n        // Evit\u0103m \u00eemp\u0103r\u021birea la zero\n        if (nr2 &amp;&amp; nr1 &gt; huge / nr2) {\n            cout &lt;&lt; \"Overflow!\" &lt;&lt; '\\n';\n        } else {\n            cout &lt;&lt; nr1 * nr2 &lt;&lt; '\\n';\n        }\n    }\n\n    return 0;\n}\n</code></pre>","tags":["matematica","aritmetica","C++"]},{"location":"cppintro/basic-math/#incrementarea-si-decrementarea","title":"Incrementarea \u0219i decrementarea","text":"<p>\u00cen mod particular, \u00een cazul opera\u021biilor de adunare \u0219i sc\u0103dere, putem folosi operatorii de incrementare (adunare cu 1) \u0219i decrementare (sc\u0103dere cu 1) pentru a face scrierea mai scurt\u0103, sintaxa lor fiind <code>a++</code>, respectiv <code>a--</code>.</p> <p>De\u0219i la prima vedere acest operator pare foarte simplu de utilizat, flexibilitatea lui duce la capcane care pot duce la erori \u00een cazul folosirii neadecvate ale acestora, fiind un subiect des \u00eent\u00e2lnit \u00een probele gril\u0103 la examenele de bacalaureat \u0219i admitere.</p> <p>Exemplu</p> <p>De exemplu, se d\u0103 urm\u0103torul program C++, spune\u021bi ce afi\u0219eaz\u0103.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a = 6, b = 8;\n\n    cout &lt;&lt; (a--) &lt;&lt; '\\n';\n    cout &lt;&lt; (++b) + a &lt;&lt; '\\n';\n    cout &lt;&lt; (--a) - (--b) &lt;&lt; '\\n';\n    cout &lt;&lt; a &lt;&lt; \" \" &lt;&lt; b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre> <p>Dac\u0103 a\u021bi r\u0103spuns 6, urmat de 14, urmat de -4, urmat de <code>4 8</code>, felicit\u0103ri!</p> <p>Totu\u0219i, merit\u0103 men\u021bionat de ce avem fiecare asemenea r\u0103spuns. \u00cen primul r\u00e2nd, deoarece operatorul de decrementare este postfixat, instruc\u021biunea <code>a--</code> va produce efect abia dup\u0103 afi\u0219are, \\(a\\) devenind 5 ulterior. Apoi, deoarece operatorul de incrementare este prefixat, instruc\u021biunea <code>b++</code> va produce efect \u00eenainte de afi\u0219are, \\(b\\) devenind 9, deci suma devine 14. Similar, \\(a\\) \u0219i \\(b\\) devin 4 \u0219i 8, deci diferen\u021ba este 4.</p>","tags":["matematica","aritmetica","C++"]},{"location":"cppintro/basic-math/#operatii-aritmetice-pe-numere-reale","title":"Opera\u021bii aritmetice pe numere reale","text":"<p>\u00cen ceea ce prive\u0219te numerele reale, dac\u0103 apare un num\u0103r real \u00een expresia aritmetic\u0103, rezultatul final va deveni \u0219i el un num\u0103r real. Totu\u0219i, dac\u0103 expresia este memorat\u0103 \u00eentr-un tip de date \u00eentreg, atunci rezultatul va r\u0103m\u00e2ne \u00eentreg.</p> <pre><code>cout &lt;&lt; 2.5 + 7 &lt;&lt; '\\n';        // 9.5\ncout &lt;&lt; 3 * 2.5 &lt;&lt; '\\n';        // 7.5\ncout &lt;&lt; 2.5 / 2 &lt;&lt; '\\n';        // 1.25\ncout &lt;&lt; 2 / 2.5 &lt;&lt; '\\n';        // 0.8\ncout &lt;&lt; 6.3 / 20 + 24 &lt;&lt; '\\n';  // 24.315\n\nint x = 6.3 / 20 + 24;\ncout &lt;&lt; x &lt;&lt; '\\n';  // 24\n</code></pre>","tags":["matematica","aritmetica","C++"]},{"location":"cppintro/basic-math/#ridicarea-la-putere","title":"Ridicarea la putere","text":"<p>Pentru a afla rezultatul expresiei \\(a^b\\), avem dou\u0103 moduri principale de a calcula acest lucru.</p> <p>\u00cen primul r\u00e2nd, putem folosi instruc\u021biunea <code>pow</code> din biblioteca <code>&lt;cmath&gt;</code>, sintaxa fiind <code>pow(baza, exponent)</code>, dar problema este aceea c\u0103 de\u0219i aceasta este o solu\u021bie viabil\u0103 pentru numere reale, uneori putem ajunge \u00een situa\u021bia \u00een care dac\u0103 calcul\u0103m un rezultat foarte mare (de exemplu, \\(9^{14}\\)), \u00een func\u021bie de precizia opera\u021biei de ridicare la putere, s\u0103 avem rezultate de forma \\(x.999999999\\) care rotunjite \u00een jos, s\u0103 ne dea \\(x-1\\).</p> <p>O metod\u0103 mai simpl\u0103 const\u0103 \u00een a ridica la putere folosind o structur\u0103 repetitiv\u0103 care calculeaz\u0103 \\(a^b\\) \u00een \\(b\\) pa\u0219i, a\u0219a cum se poate vedea mai jos.</p> <pre><code>int ans = 0;\n\nfor (int i = 1; i &lt;= b; i++) {\n    ans = ans * a;\n}\n\ncout &lt;&lt; ans &lt;&lt; '\\n';\n</code></pre> <p>Pentru cei mai avansa\u021bi, aceast\u0103 opera\u021bie se poate face \u0219i \u00een timp logaritmic, cunoa\u0219terea acestei tehnici nefiind necesar\u0103 dec\u00e2t celor care vor s\u0103 mearg\u0103 la olimpiad\u0103.</p>","tags":["matematica","aritmetica","C++"]},{"location":"cppintro/basic-math/#tehnici-matematice-simple","title":"Tehnici matematice simple","text":"<p>De multe ori, mai ales \u00een problemele mai simple de algoritmic\u0103, cunoa\u0219terea unor formule \u0219i principii matematice simple este esen\u021bial\u0103.</p>","tags":["matematica","aritmetica","C++"]},{"location":"cppintro/basic-math/#notatii-importante","title":"Nota\u021bii importante","text":"<p>De-a lungul acestei arhive, dar \u0219i dac\u0103 studia\u021bi matematica sau alte discipline la \u0219coal\u0103, precum fizic\u0103 sau chimie, ve\u021bi \u00eent\u00e2lni diverse nota\u021bii matematice, pe care le vom folosi \u00een acest articol. Printre altele, vom enumera urm\u0103toarele:</p> <ul> <li>Nota\u021bia pentru sum\u0103: \\(\\sum\\) este folosi pentru a nota diverse sume \u00eentre mai   multe numere legate \u00eentre ele printr-o formul\u0103. De exemplu, \\(\\sum_{i=1}^n x\\)   reprezint\u0103 suma numerelor de la 1 la \\(n\\).</li> <li>Nota\u021bia pentru produs: \\(\\Pi\\) este folosi pentru a nota diverse produse \u00eentre   mai multe numere legate \u00eentre ele printr-o formul\u0103. De exemplu, \\(\\Pi_{i=1}^n   x\\) reprezint\u0103 produsul numerelor de la 1 la \\(n\\).</li> <li>Nota\u021bia pentru logaritm: \\(\\log n\\) este folosit pentru a nota logaritmul unui   num\u0103r \\(n\\), o valoare folosit\u0103 frecvent \u00een calculul complexit\u0103\u021bilor. F\u0103r\u0103 a   intra prea mult \u00een teoria specific\u0103 a logaritmilor (se studiaz\u0103 \u00een clasa a X-a   la mate-info), putem s\u0103-i definim \u00eentr-un mod aproximativ drept num\u0103rul de   pa\u0219i necesari pentru a ajunge la un num\u0103r subunitar dac\u0103 \u00eemp\u0103r\u021bim pe \\(n\\) la</li> <li>De exemplu, \\(\\log 1000 \\approx 10\\),  \\(\\log 1000000 \\approx 20\\) etc.</li> </ul> <p>De asemenea, \u00een func\u021bie de algoritmii studia\u021bi, ve\u021bi mai g\u0103si alte nota\u021bii ce folosesc litere din alfabetul grecesc precum \\(\\pi\\), \\(\\psi\\), \\(\\phi\\) etc.</p>","tags":["matematica","aritmetica","C++"]},{"location":"cppintro/basic-math/#formule-pentru-sume-remarcabile","title":"Formule pentru sume remarcabile","text":"<p>A\u0219a cum \u0219ti\u021bi probabil de la matematic\u0103, avem diverse formule pentru unele sume de numere naturale. Cele mai multe dintre ele se pot demonstra fie prin calcul direct, fie prin induc\u021bie matematic\u0103.</p> <ul> <li>\\(1 + 2 + 3 + \\dots + n = \\frac{n \\cdot (n+1)}{2}\\) (suma lui Gauss)</li> <li>\\(1^2 + 2^2 + 3^2 + \\dots + n^2 = \\frac{n \\cdot (n+1) \\cdot (2 \\cdot n+1)}{6}\\)   (suma p\u0103tratelor perfecte)</li> <li>\\(1^3 + 2^3 + 3^3 + \\dots + n^3 = (\\frac{n \\cdot (n+1)}{2})^2\\) (suma cuburilor   perfecte)</li> <li>\\(1 + 3 + 5 + \\dots + (2n - 1) = n^2\\)</li> <li>\\((a + b)^2 = a^2 + 2ab + b^2\\)</li> <li>\\((a - b)^2 = a^2 - 2ab + b^2\\)</li> <li>\\(a^2 - b^2 = (a-b)(a+b)\\)</li> </ul>","tags":["matematica","aritmetica","C++"]},{"location":"cppintro/basic-math/#rezolvarea-unor-tipuri-de-ecuatii","title":"Rezolvarea unor tipuri de ecua\u021bii","text":"<p>Pentru ecua\u021bia de gradul 1 \u0219i 2, avem tehnici binecunoscute pentru aflarea solu\u021biilor, dup\u0103 cum urmeaz\u0103.</p> <ul> <li>Pentru o ecua\u021bie de forma \\(ax + b = 0\\), solu\u021bia ecua\u021biei este \\(\\frac{-b}{a}\\).</li> <li>Pentru o ecua\u021bie de forma \\(ax^2 + bx + c = 0\\), avem 0, 1 sau 2 solu\u021bii   reale, care pot fi aflate prin formulele \\(\\frac{-b + \\sqrt(\\Delta)}{2a}\\) \u0219i   \\(\\frac{-b - \\sqrt(\\Delta)}{2a}\\), unde \\(\\Delta = b^2 - 4ac\\). Dac\u0103 \\(\\Delta &lt; 0\\),   nu exist\u0103 solu\u021bii reale.</li> </ul>","tags":["matematica","aritmetica","C++"]},{"location":"cppintro/basic-math/#rearanjarea-unor-sume-si-produse","title":"Rearanjarea unor sume \u0219i produse","text":"<p>\u00cen unele situa\u021bii, suntem nevoi\u021bi s\u0103 rearanj\u0103m diver\u0219i termeni ai unor egalit\u0103\u021bi pentru a simplifica calculele. De obicei, c\u00e2nd vrem s\u0103 facem asta, scopul este acela de a aduce termenii ce se pot p\u0103stra \u00een acela\u0219i mod \u00eempreun\u0103.</p> <p>Dac\u0103 vrem s\u0103 afl\u0103m c\u00e2te perechi de forma \\((i, j)\\) exist\u0103 cu proprietatea c\u0103 \\(x_i - x_j = y_i + y_j\\), este mai simplu s\u0103 afl\u0103m c\u00e2te perechi exist\u0103 cu proprietatea c\u0103 \\(x_i - y_i = y_j - x_j = -(x_j - y_j)\\), lucru ce se poate afla mult mai u\u0219or folosind vectori de frecven\u021b\u0103.</p>","tags":["matematica","aritmetica","C++"]},{"location":"cppintro/basic-math/#lucrul-cu-intervale","title":"Lucrul cu intervale","text":"<p>Dac\u0103 avem dou\u0103 intervale de numere naturale \\([x_1, y_1]\\) \u0219i \\([x_2, y_2]\\) putem discuta despre urm\u0103toarele dou\u0103 intervale:</p> <ul> <li>Pentru intervalele de mai sus, intersec\u021bia lor este \\([max(x_1, x_2), min(y_1,   y_2)]\\), cu condi\u021bia c\u0103 \\(max(x_1, x_2) \\leq min(y_1, y_2)\\).</li> <li>Pentru intervalele de mai sus, reuniunea lor este \\([min(x_1, x_2), max(y_1,   y_2)]\\), cu condi\u021bia c\u0103 intersec\u021bia lor este nevid\u0103. Dac\u0103 intersec\u021bia este   vid\u0103, reuniunea intervalelor este dat\u0103 de cele dou\u0103 intervale luate separat.</li> </ul>","tags":["matematica","aritmetica","C++"]},{"location":"cppintro/basic-math/#divizibilitatea-numerelor-naturale","title":"Divizibilitatea numerelor naturale","text":"<p>De\u0219i acest capitol este abordat \u00een detaliu aici, aici vom sublinia doar aspectele de baz\u0103.</p> <p>Operatorul pe care \u00eel folosim pentru a verifica dac\u0103 dou\u0103 numere se \u00eempart unul la altul este \\(\\%\\) \u0219i acesta ne afl\u0103 restul \u00eemp\u0103r\u021birii de\u00eemp\u0103r\u021bitului la \u00eemp\u0103r\u021bitor.</p> <p>\u00cen mod particular, dac\u0103 \\(a \\% b = 0\\), atunci \\(a\\) se \u00eemparte exact la \\(b\\).</p> <p>O alt\u0103 particularitate a numerelor prime este aceea c\u0103 num\u0103rul aproximativ de numere prime \u00eentre 1 \u0219i \\(n\\) este \\(\\frac{n}{\\log n}\\), iar \u00een mod similar, \\(\\sum_{i=1}^n \\frac{n}{i} \\approx n \\log n\\).</p>","tags":["matematica","aritmetica","C++"]},{"location":"cppintro/basic-math/#concluzii","title":"Concluzii","text":"<p>De\u0219i matematica prezentat\u0103 aici nu ar trebui s\u0103 pun\u0103 probleme unui elev de liceu care cite\u0219te acest articol (sau chiar \u0219i unui elev mai bun de gimnaziu), este foarte important de avut \u00een vedere tehnicile de rezolvare a problemelor, precum \u0219i formulele aflate de la matematic\u0103.</p> <p>Chiar dac\u0103 aplicarea lor este un pic diferit\u0103 precum cea de la mate, pe m\u0103sur\u0103 ce v\u0103 obi\u0219nui\u021bi cu aceste principii, lucrurile vor deveni mai simple.</p>","tags":["matematica","aritmetica","C++"]},{"location":"cppintro/basic-math/#resurse-suplimentare","title":"Resurse suplimentare","text":"<ul> <li>Problemele usoare si medii din capitolul Sume, produse,   numarari</li> <li>Problemele usoare si medii din capitolul Maxime si   minime</li> <li>Probleme usoare de matematica de pe   Codeforces</li> </ul>","tags":["matematica","aritmetica","C++"]},{"location":"cppintro/coding-style/","title":"Coding style","text":"","tags":["C++","introducere","coding style"]},{"location":"cppintro/coding-style/#fundamente","title":"Fundamente","text":"<p>A\u0219a cum probabil a\u021bi mai observat c\u00e2nd a\u021bi mai citit programe \u00een limbajul C++, exist\u0103 diverse conven\u021bii \u0219i reguli ce sunt respectate de programatori, lucru ce nu reprezint\u0103 o excep\u021bie \u00een articolele ce fac parte din Arhiva Educa\u021bional\u0103 RoAlgo.</p> <p>De\u0219i sunt multe stiluri de cod care pot fi utilizate, un stil de cod bun este unul u\u0219or de \u00een\u021beles \u0219i concis, deoarece \u00een timpul unui concurs de algoritmic\u0103, ideile pe care le g\u0103se\u0219ti trebuie implementate destul de rapid \u0219i f\u0103r\u0103 a avea riscul de a suferi de pe urma unor bug-uri care iau mult mai mult timp s\u0103 fie rezolvate dec\u00e2t \u00een cazul folosirii unui stil de cod concis.</p>","tags":["C++","introducere","coding style"]},{"location":"cppintro/coding-style/#coding-style-ul-arhivei-educationale-roalgo","title":"Coding style-ul Arhivei Educa\u021bionale RoAlgo","text":"<p>De-a lungul acestei arhive, solu\u021biile prezentate de noi vor folosi stilul de cod Google, cu urm\u0103toarele caracteristici:</p> <ul> <li>4 spa\u021bii la indentare;</li> <li>Folosirea acoladelor pentru orice structur\u0103 alternativ\u0103 \u0219i repetitiv\u0103;</li> <li>Acolada deschis\u0103 se pune \u00een acela\u0219i r\u00e2nd cu defini\u021bia structurii;</li> <li>Acolada \u00eenchis\u0103 se pune \u00een r\u00e2ndul de dup\u0103 finalul structurii;</li> <li>Folosirea extensiv\u0103 a spa\u021biilor pentru separarea diverselor instruc\u021biuni sau   chiar a expresiilor;</li> <li>Nume sugestive pentru variabile.</li> </ul> <p>Un astfel de exemplu \u00eel pute\u021bi g\u0103si \u00een acest cod \u00een care oper\u0103m cu cifrele unui num\u0103r \\(n\\) dat.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int n;\n    cin &gt;&gt; n;\n\n    if (n == 0) {\n        // Caz particular daca n = 0\n        // ...\n    }\n\n    while (n &gt; 0) {\n        int c = n % 10;\n        n = n / 10;\n    }\n    return 0;\n}\n</code></pre> <p>Se poate observa faptul c\u0103 acest cod este mult mai u\u0219or de citit, datorit\u0103 spa\u021biilor incluse \u0219i a pozi\u021biei logice a acoladelor \u0219i nu numai.</p>","tags":["C++","introducere","coding style"]},{"location":"cppintro/coding-style/#exemple-de-asa-nu","title":"Exemple de a\u0219a nu","text":"<p>\u00cen mod evident, orice exemplu de cod care nu respect\u0103 un stil clar poate fi considerat un exemplu de a\u0219a nu. Aici sunt c\u00e2teva exemple, luate din examene \u0219i concursuri de informatic\u0103 rom\u00e2ne\u0219ti, \u00eempreun\u0103 cu explica\u021bia pentru care nu sunt stiluri potrivite.</p> <pre><code>int s[100],n,p,x;\nvoid f(int k)\n{ int i;\n if(k==p+1) x++;\nif(k==1)\nfor(i=1;i&lt;=n;i++) f(k+1);\n else\nfor(i=1+s[k-1];i&lt;=n;i++)\n { s[k]=i;f(k+1); }}\n</code></pre> <p>Aceast\u0103 secven\u021b\u0103 de cod are un stil foarte inconsistent \u00een privin\u021ba acoladelor \u0219i a instruc\u021biunilor subordonate if-urilor, pe de o parte ap\u0103r\u00e2nd pe aceea\u0219i linie \u0219i apoi ap\u0103r\u00e2nd pe urm\u0103torul r\u00e2nd. De asemenea, nu se respect\u0103 vreo regul\u0103 de spa\u021biere ceea ce face codul (inten\u021bionat) mai greu de citit.</p> <pre><code>int a=2 ,n;\nn=16327;\nwhile(n!=0)\n{\nswitch(n%10){\ncase 0: case 2: case\n4:case 6: case 8:\na=a+n%2;break;\ncase 1: case 3: case\n5:case 7: case 9:\na=a-n%2; break;}\nn=n/10;\n}\ncout&lt;&lt;a&lt;&lt;endl;\n</code></pre> <p>\u00cen mod similar, acoladele sunt puse la \u00eent\u00e2mplare \u0219i instruc\u021biunile din switch sunt scrise cu scopul de a bate recordul de cel mai scurt cod de pe CSES, nu pentru a ajuta cititorul s\u0103 \u00een\u021beleag\u0103 ce se \u00eent\u00e2mpl\u0103 \u00een cod.</p> <pre><code>#include&lt;fstream&gt;\nusing namespace std;\nifstream f(\"numarare.in\"); ofstream g(\"numarare.out\");\nint n,a[100002],lg[100002];\ninline int Minim(int x,int y){ return x&lt;y ? x:y; }\nint main()\n{   int i,st,dr,sol;\n    f&gt;&gt;n;\n    for(i=1;i&lt;=n;++i) f&gt;&gt;a[i];\n    for(i=1;i&lt;=n;++i) a[i]-=a[i+1];\n    n--;\n    st=dr=1;\n    sol=n;\n    for(i=2;i&lt;=n;++i)\n    {   if(i&lt;=dr)\n        {   lg[i]=Minim(lg[dr+st-i],dr-i);\n            if(lg[i]==dr-i)\n            {   st=i-lg[i]; dr=i+lg[i];\n                while(st &amp;&amp; dr&lt;=n &amp;&amp; a[st]==a[dr] ) {st--; dr++;}\n                st++; dr--;\n                lg[i]=(dr-st+1)/2;\n            }\n        }\n        else\n        {   st=dr=i;\n            while(st &amp;&amp; dr&lt;=n &amp;&amp; a[st]==a[dr]) {st--; dr++;}\n            st++; dr--;\n            lg[i]=(dr-st+1)/2;\n        }\n        sol += lg[i];\n    }\n    g&lt;&lt;sol&lt;&lt;'\\n'; g.close(); return 0;\n}\n</code></pre> <p>Acest cod, de\u0219i are unele lucruri ce se \u00eent\u00e2mpl\u0103 \u00een mod constant, este foarte greu de citit din cauza inconsisten\u021bei la structurile repetitive \u0219i acolade, pe l\u00e2ng\u0103 r\u00e2ndurile scrise \u00eempreun\u0103.</p>","tags":["C++","introducere","coding style"]},{"location":"cppintro/coding-style/#alte-coding-style-uri-bune","title":"Alte coding style-uri bune","text":"<p>Dac\u0103 nu prefera\u021bi stilul nostru, un alt stil bun este stilul Allman, foarte similar dar acoladele apar mereu pe r\u00e2nduri separate.</p> <p>\u00cen general, orice stil folosi\u021bi trebuie s\u0103 aib\u0103 o logic\u0103 clar\u0103 \u0219i s\u0103 fie u\u0219or de citit pentru oricine vrea s\u0103 v\u0103 urmeze ideea la o problem\u0103, evident f\u0103r\u0103 a cauza dificult\u0103\u021bi majore \u00een ceea ce prive\u0219te debugging-ul.</p> <p>De asemenea, recomand\u0103m \u0219i acest ghid de pe Codeforces.</p>","tags":["C++","introducere","coding style"]},{"location":"cppintro/coding-style/#concluzii","title":"Concluzii","text":"<p>Formarea unui stil propriu de cod (sau utilizarea unuia din stilurile consacrate) este foarte important\u0103 \u00een dezvoltarea oric\u0103rui programator, deoarece aceste obiceiuri, odat\u0103 deprinse, servesc drept o unealt\u0103 puternic\u0103 indiferent de proiectul sau programul scris.</p>","tags":["C++","introducere","coding style"]},{"location":"cppintro/conditions-if/","title":"Structura alternativ\u0103","text":"","tags":["C++","introducere","if","structura alternativa"]},{"location":"cppintro/conditions-if/#introducere-si-instructiunile-ifelse-respectiv-switch-case","title":"Introducere \u0219i instruc\u021biunile if..else, respectiv switch-case","text":"<p>De multe ori, se impune luarea unor decizii diferite \u00een func\u021bie de situa\u021bie. Vrem s\u0103 ob\u021binem acela\u0219i lucru \u0219i \u00een programare, iar limbajul C++ are diverse op\u021biuni pentru realizarea acestui lucru.</p> <p>Defini\u021bie</p> <p>O structur\u0103 alternativ\u0103 este o structur\u0103 pe care o folosim pentru a coordona programul s\u0103 ia decizii diferite \u00een func\u021bie de rezultatul unei expresii logice.</p> <p>\u00cen limbajul C++, structura alternativ\u0103 este reprezentat\u0103 de blocul if..else, astfel \u00eenc\u00e2t putem s\u0103 direc\u021bion\u0103m programul \u00een func\u021bie de rezultatele expresiilor logice men\u021bionate.</p> <p>Pe l\u00e2ng\u0103 <code>if..else</code>, exist\u0103 \u0219i instruc\u021biunea <code>switch..case</code>, care func\u021bioneaz\u0103 \u00eentr-o manier\u0103 similar\u0103, trec\u00e2nd prin fiecare caz pe r\u00e2nd f\u0103r\u0103 a mai fi nevoie de <code>if</code>-uri \u0219i <code>else</code>-uri.</p> <p>Mai jos, g\u0103si\u021bi un exemplu pentru aplicarea acestei instruc\u021biuni.</p> <pre><code>if (n == 5) {\n    // Instruc\u021biune\n} else {\n    // Alt\u0103 instruc\u021biune\n}\n</code></pre> <p>Blocul <code>else</code> este op\u021bional.</p> <p>Dac\u0103 condi\u021bia nu este deja o valoare logic\u0103, cum este cea returnat\u0103 de operatorii de compara\u021bie, va fi considerat\u0103 adev\u0103rat\u0103 dac\u0103 aceasta este nenul\u0103.</p> <p>Acoladele nu sunt obligatorii, dar dac\u0103 nu le folosim putem scrie o singur\u0103 instruc\u021biune. Ne putem folosi de acest lucru pentru a scrie compact lan\u021buri de condi\u021bii:</p> <pre><code>if (x) {\n    // Dac\u0103 x este adev\u0103rat\n    // ...\n} else if (y) {\n    // Dac\u0103 x este fals, dar y este adev\u0103rat\n    // ...\n} else {\n    // Dac\u0103 \u0219i x, \u0219i y sunt false\n    // ...\n}\n</code></pre>","tags":["C++","introducere","if","structura alternativa"]},{"location":"cppintro/conditions-if/#operatori-de-comparatie","title":"Operatori de compara\u021bie","text":"<p>Pentru a compara dou\u0103 valori sau expresii, putem folosi operatorii obi\u0219nui\u021bi de compara\u021bie de la matematic\u0103, cu mici ajust\u0103ri.</p> <p>Astfel, operatorii de compara\u021bie sunt urm\u0103torii:</p> <ul> <li><code>==</code> - verific\u0103 prima expresie are o valoare mai egal\u0103 cu cea de-a doua   expresie.</li> <li><code>&lt;=</code> - verific\u0103 dac\u0103 prima expresie are o valoare mai mic\u0103 sau egal\u0103 dec\u00e2t cea   de-a doua expresie.</li> <li><code>&gt;=</code> - verific\u0103 dac\u0103 prima expresie are o valoare mai mare sau egal\u0103 dec\u00e2t cea   de-a doua expresie.</li> <li><code>&gt;</code> - verific\u0103 dac\u0103 prima expresie are o valoare strict mai mare dec\u00e2t cea   de-a doua expresie.</li> <li><code>&lt;</code> - verific\u0103 dac\u0103 prima expresie are o valoare strict mai mic\u0103 dec\u00e2t cea   de-a doua expresie.</li> <li><code>!=</code> - verific\u0103 dac\u0103 cele dou\u0103 expresii au o valoare diferit\u0103.</li> </ul> <p>Observa\u021bie</p> <p>Pentru a verifica egalitatea, este nevoie de dou\u0103 semne <code>=</code>; o instruc\u021biune de tipul <code>if (n = 5)</code> atribuie mai \u00eent\u00e2i valoarea 5 lui \\(n\\), iar mai apoi verific\u0103 dac\u0103 \\(n\\) este diferit de 0.</p>","tags":["C++","introducere","if","structura alternativa"]},{"location":"cppintro/conditions-if/#operatori-logici","title":"Operatori logici","text":"<p>De cele mai multe ori, ve\u021bi vedea c\u0103 expresiile logice apar grupate folosind operatorii logici. Operatorii logici sunt de trei feluri, dup\u0103 cum urmeaz\u0103:</p> <ul> <li> <p>Nega\u021bia - notat\u0103 cu <code>!</code> sau <code>not</code>, inverseaz\u0103 valoarea de   adev\u0103r a unei expresii.</p> <code>x</code> <code>not x</code> 0 1 1 0 <pre><code>int a = 5;\nint b = 8;\n\n// 1. a &lt; 5 == 5 &lt; 5 == false\n// 2. not false == true\n//\n// =&gt; not (a &lt; 5) == true\n\ncout &lt;&lt; not(a &lt; 5);  // 1\n\n// 1. (a == b) == (5 == 8) == false\n// 2. !false == true\n//\n// =&gt; !(a == b) == true\n\ncout &lt;&lt; !(a == b);  // 1\n\n// 1. \u00een !a, a este transformat \u00een true sau false\n//    (0 este false, \u00een rest este true)\n// 2. !a == !5 == !true == false\n// 3. false este convertit la 0, iar true la 1\n// 4. 0 &lt; 1 == true\n// 5. not true == false\n//\n// =&gt; not (!a &gt; 1) == false\n\ncout &lt;&lt; not(!a &lt; 1);  // 0\n</code></pre> </li> <li> <p>Conjunc\u021bia - notat\u0103 cu <code>&amp;&amp;</code> sau <code>and</code>, reprezint\u0103 \u201e\u0219i\u201d logic.   Pentru ca o expresie compus\u0103 s\u0103 fie adev\u0103rat\u0103, to\u021bi membrii ei trebuie s\u0103   fie adev\u0103ra\u021bi.</p> <code>x</code> <code>y</code> <code>x and y</code> 0 0 0 0 1 0 1 0 0 1 1 1 <pre><code>int a = 1;\nint b = 3;\n\n// 1. a &lt; 1 == 1 &lt; 1 == false\n// 2. b &gt; 3 == 3 &gt; 3 == false\n// 3. false &amp;&amp; false == false\n//\n// =&gt; (a &lt; 1) &amp;&amp; (b &gt; 3) == false\n\ncout &lt;&lt; (a &lt; 1) &amp;&amp; (b &gt; 3);  // 0\n\n// 1. b &lt; 5 == 3 &lt; 5   == true\n// 2. a &gt; -4 == 1 &gt; -4 == true\n//\n// 3. not (b &lt; 5)      == false\n// 4. not (a &gt; -4)     == false\n//\n// 5. false &amp;&amp; false   == false\n//\n// =&gt; not (b &lt; 5) and not (a &gt; -4) == false\n\ncout &lt;&lt; not(b &lt; 5) and not(a &gt; -4);  // 0\n\n// 1. b &gt;= 3 == 3 &gt;= 3   == true\n// 2. a &gt; 4  == 1 &gt; 4    == false\n//\n// 3. !(a &gt; 4) == !false == true\n//\n// 4. true &amp;&amp; true       == true\n//\n// =&gt; (b &gt;= 3) &amp;&amp; !(a &gt; 4) == true\n\ncout &lt;&lt; (b &gt;= 3) &amp;&amp; !(a &gt; 4);  // 1\n</code></pre> </li> <li> <p>Disjunc\u021bia - notat\u0103 cu <code>||</code> sau <code>or</code>, reprezint\u0103 \u201esau\u201d logic.   Pentru ca o expresie compus\u0103 s\u0103 fie adev\u0103rat\u0103, este suficient ca cel pu\u021bin   un membru s\u0103 fie adev\u0103rat.</p> <code>x</code> <code>y</code> <code>x or y</code> 0 0 0 0 1 1 1 0 1 1 1 1 <pre><code>int x = 0;\nint y = 5;\n\n// 1. x != 0 == 0 != 0  == false\n// 2. y == 0 == 5 == 0  == false\n//\n// 3. false or false    == false\n//\n// =&gt; (x != 0) or (y == 0) == false\n\ncout &lt;&lt; (x != 0) or (y == 0);  // 0\n\n// 1. x + y &gt; 10 == 0 + 5 &gt; 10 == false\n// 2. x - y &lt; 0 == 0 - 5 &lt; 0   == true\n//\n// 3. not (x - y &lt; 0)          == !true == false\n//\n// 4. false or false           == false\n//\n// =&gt; (x + y &gt; 10) or !(x - y &lt; 0) == false\n\ncout &lt;&lt; (x + y &gt; 10) or not(x - y &lt; 0);  // 0\n\n// 1. x == 1 == 0 == 1      == false\n// 2. y == 10 == 5 == 10    == false\n//\n// 3. false || false        == false\n//\n// =&gt; (x == 1) || (y == 10) == false\n\ncout &lt;&lt; (x == 1) || (y == 10);  // 0\n\n// 1. x &lt; 0 == 0 &lt; 0        == false\n// 2. y &gt; 10 == 5 &gt; 10      == false\n//\n// 3. !(x &lt; 0) == !false    == true\n// 4. !(y &gt; 10) == !false   == true\n//\n// 5. true || true          == true\n//\n// =&gt; !(x &lt; 0) || !(y &gt; 10) == true\n\ncout &lt;&lt; !(x &lt; 0) || !(y &gt; 10);  // 1\n</code></pre> </li> </ul>","tags":["C++","introducere","if","structura alternativa"]},{"location":"cppintro/conditions-if/#exemplu","title":"Exemplu","text":"<p>Mai jos pute\u021bi g\u0103si un asemenea exemplu, \u00een care rezolv\u0103m problema cumparaturi1 de pe pbinfo folosind diverse if-uri \u0219i else-uri. O solu\u021bie alternativ\u0103 folose\u0219te switch-case.</p> if-elseswitch-case <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int s, c, n;\n    cin &gt;&gt; s &gt;&gt; c &gt;&gt; n;\n\n    if (s % n == 0 &amp;&amp; s % c == 0) {\n        // Dac\u0103 ambele condi\u021bii sunt \u00eendeplinite\n        cout &lt;&lt; \"CN\" &lt;&lt; '\\n';\n    } else {\n        if (s % n == 0) {\n            // Dac\u0103 prima condi\u021bie este \u00eendeplinit\u0103\n            cout &lt;&lt; \"N\" &lt;&lt; '\\n';\n        } else {\n            if (s % c == 0) {\n                // Dac\u0103 a doua condi\u021bie este \u00eendeplinit\u0103\n                cout &lt;&lt; \"C\" &lt;&lt; '\\n';\n            } else {\n                // Dac\u0103 nicio condi\u021bie nu este \u00eendeplinit\u0103\n                cout &lt;&lt; \"nimic\" &lt;&lt; '\\n';\n            }\n        }\n    }\n    return 0;\n}\n</code></pre> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int s, c, n;\n    cin &gt;&gt; s &gt;&gt; c &gt;&gt; n;\n\n    // Combin\u0103m condi\u021bia \u00eentr-o singur\u0103 valoare\n    int condition = (s % n == 0) * 1 + (s % c == 0) * 2;\n\n    /*-----------------------------------*\\\n    | s % n == 0 | s % c == 0 | condition |\n    |------------|------------|-----------|\n    | 0          | 0          | 0         |\n    | 1          | 0          | 1         |\n    | 0          | 1          | 2         |\n    | 1          | 1          | 3         |\n    \\*-----------------------------------*/\n\n    switch (condition) {\n    case 3:\n        // Dac\u0103 ambele condi\u021bii sunt \u00eendeplinite\n        // (s % n == 0 &amp;&amp; s % c == 0)\n        cout &lt;&lt; \"CN\" &lt;&lt; '\\n';\n        break;\n    case 1:\n        // Dac\u0103 prima condi\u021bie este \u00eendeplinit\u0103\n        // (s % n == 0)\n        cout &lt;&lt; \"N\" &lt;&lt; '\\n';\n        break;\n    case 2:\n        // Dac\u0103 a doua condi\u021bie este \u00eendeplinit\u0103\n        // (s % c == 0)\n        cout &lt;&lt; \"C\" &lt;&lt; '\\n';\n        break;\n    default:\n        // Dac\u0103 nicio condi\u021bie este \u00eendeplinit\u0103\n        cout &lt;&lt; \"nimic\" &lt;&lt; '\\n';\n        break;\n    }\n\n    return 0;\n}\n</code></pre>","tags":["C++","introducere","if","structura alternativa"]},{"location":"cppintro/conditions-if/#prioritatea-operatorilor","title":"Prioritatea operatorilor","text":"<p>Este important s\u0103 \u021binem cont de ordinea de evaluare a operatorilor logici atunci c\u00e2nd folosim combina\u021bii de <code>&amp;&amp;</code>, <code>||</code>, <code>!</code>. \u00cen general, operatorii logici urmeaz\u0103 urm\u0103toarea ordine de prioritate:</p> <ul> <li><code>!</code> (nega\u021bia) - are prioritate mai mare</li> <li><code>&amp;&amp;</code> (conjunc\u021bia) - are prioritate mai mic\u0103 dec\u00e2t <code>!</code>, dar mai mare dec\u00e2t <code>||</code></li> <li><code>||</code> (disjunc\u021bia) - are prioritatea cea mai mic\u0103</li> </ul> <p>De exemplu:</p> <pre><code>int x = 1;\nint y = 0;\nint z = 2;\n\ncout &lt;&lt; !(x &amp;&amp; y) || z;  // 1\n</code></pre> <ol> <li><code>x &amp;&amp; y</code> este evaluat mai \u00eent\u00e2i: <code>1 &amp;&amp; 0 == false</code>.</li> <li><code>!false == true</code>, deci <code>!(x &amp;&amp; y) == true</code>.</li> <li><code>true || z</code> se evalueaz\u0103, iar <code>true || 2</code> d\u0103 <code>true</code>.    Rezultatul va fi 1.</li> </ol> <pre><code>cout &lt;&lt; A || B &amp;&amp; C;       // A || (B &amp;&amp; C)\ncout &lt;&lt; A &amp;&amp; B || C &amp;&amp; D;  // (A &amp;&amp; B) || (C &amp;&amp; D)\ncout &lt;&lt; A &amp;&amp; B &amp;&amp; C || D;  // ((A &amp;&amp; B) &amp;&amp; C) || D\ncout &lt;&lt; !A &amp;&amp; B || C;      // ((!A) &amp;&amp; B) || C\n</code></pre> <p>Ca s\u0103 fie priorit\u0103\u021bile mai u\u0219or de \u021binut minte, putem face analogie cu algebra normal\u0103:</p> <ul> <li>Nega\u021bia (<code>!</code>) este la fel ca nega\u021bia numerelor.</li> <li>Conjunc\u021bia (<code>&amp;&amp;</code>) este la fel ca \u00eenmul\u021birea.</li> <li>Disjunc\u021bia (<code>||</code>) este la fel ca adunarea (cu excep\u021bia c\u0103 <code>1 + 1 == 1</code>).</li> </ul> <p>Observa\u021bie</p> <p>Dac\u0103 lu\u0103m <code>true</code> ca 1 \u0219i <code>false</code> ca 0, atunci putem defini toate opera\u021biile pur algebric astfel:</p> <ul> <li><code>!x == 1 - x</code></li> <li><code>x || y == x + y - x * y == x + y * (1 - x) == max(x, y)</code></li> <li><code>x &amp;&amp; y == x * y == min(x, y)</code></li> </ul> <p>Cu aceast\u0103 analogie putem merge mai departe la a descoperi ni\u0219te propriet\u0103\u021bi importante.</p>","tags":["C++","introducere","if","structura alternativa"]},{"location":"cppintro/conditions-if/#proprietatile-operatorilor-logici","title":"Propriet\u0103\u021bile operatorilor logici","text":"<p>O proprietate imediat util\u0103 pe care o putem vedea este c\u0103 disjunc\u021bia \u0219i conjunc\u021bia sunt asociative:</p> <ul> <li><code>x &amp;&amp; (y &amp;&amp; z) == (x &amp;&amp; y) &amp;&amp; z == x &amp;&amp; y &amp;&amp; z</code></li> <li><code>x || (y || z) == (x || y) || z == x || y || z</code></li> </ul> <p>Asta este util pentru c\u0103 ne permite s\u0103 nu mai scriem paranteze dac\u0103 avem un \u0219ir de conjunc\u021bii \u0219i disjunc\u021bii. \u00cen plus, ele sunt comutative (adic\u0103 nu conteaz\u0103 ordinea):</p> <ul> <li><code>x &amp;&amp; y == y &amp;&amp; x</code></li> <li><code>x || y == y || x</code></li> </ul> <p>Momentan, ele se comport\u0103 la fel ca adunarea \u0219i \u00eenmul\u021birea. La fel ca acestea, are loc \u0219i distributivitatea:</p> <ul> <li><code>x &amp;&amp; (y || z) == (x &amp;&amp; y) || (x &amp;&amp; z)</code>.</li> <li><code>x || (y &amp;&amp; z) == (x || y) &amp;&amp; (x || z)</code>.</li> </ul> <p>Ne putem aduce aminte de ea dac\u0103 lu\u0103m expresia echivalent\u0103 \\(x \\cdot (y + z) = x \\cdot y + x \\cdot z\\). Dac\u0103 o privim \u00een sens invers, ne permite s\u0103 \u201ed\u0103m \u00een factori\u201d expresii logice. Aceea\u0219i rela\u021bie are loc \u0219i dac\u0103 invers\u0103m conjunc\u021bia cu disjunc\u021bia, chiar dac\u0103 nu merge \u00een algebra normal\u0103 (\\(x + yz \\neq (x + y)(x + z)\\)). Urm\u0103toarele exemple sunt echivalente:</p> <pre><code>if ((a &amp;&amp; b) || (a &amp;&amp; c)) {\n    // ...\n}\n\nif (a &amp;&amp; b) {\n    if (a &amp;&amp; c) {\n        // ...\n    }\n}\n\nif (a) {\n    if (b || c) {\n        // ...\n    }\n}\n\nif (a &amp;&amp; (b || c)) {\n    // ...\n}\n</code></pre> <pre><code>if ((a || b) &amp;&amp; (a || c)) {\n    // ...\n}\n\nif (a || b) {\n    if (a || c) {\n        // ...\n    }\n}\n\nif (a || (b &amp;&amp; c)) {\n    // ...\n}\n</code></pre> <p>\u00cen plus, avem \u0219i identit\u0103\u021bi:</p> <ul> <li><code>x || false == x</code></li> <li><code>x &amp;&amp; true == x</code></li> </ul> <p>Asta o putem lua ca pe \\(x + 0 = x\\) \u0219i \\(x \\cdot 1 = x\\). Asta ne permite s\u0103 simplific\u0103m expresiile logice dac\u0103 \u0219tim de dinainte c\u0103 o parte este redundant\u0103. De exemplu, <code>x &amp;&amp; (1 == 1)</code> este echivalent\u0103 cu <code>x</code> oricare ar fi x.</p> <p>De la matematic\u0103, \u0219tim \u0219i c\u0103 \\(x \\cdot 0 = 0\\), care este adev\u0103rat \u0219i aici:</p> <ul> <li><code>x &amp;&amp; false == false</code>.</li> </ul> <p>C++ folose\u0219te scurtcircuitarea pentru a evalua expresiile logice \u00een mod eficient. Din moment ce \u0219tim c\u0103 <code>x &amp;&amp; false == false</code> (\u0219i c\u0103 <code>false &amp;&amp; x == false</code>), dac\u0103 avem <code>x &amp;&amp; y</code> \u0219i <code>x</code> este evaluat la fals, atunci nu mai este nevoie s\u0103 evalu\u0103m \u0219i <code>y</code>. Aici este un exemplu:</p> <pre><code>int b = 0;\nif (b != 0 &amp;&amp; a / b != 0) {\n    // ...\n}\n</code></pre> <p>Dac\u0103 <code>b</code> este 0, atunci toat\u0103 expresia devine fals\u0103 f\u0103r\u0103 a evalua <code>a / b != 0</code>, unde ar putea avea loc o \u00eemp\u0103r\u021bire la zero dac\u0103 nu ar fi scurtcircuitat\u0103 condi\u021bia.</p> <p>Observa\u021bie</p> <p>Din moment ce tot ce nu este zero se transform\u0103 \u00een <code>true</code> \u0219i 0 se transform\u0103 \u00een <code>false</code>, putem \u00eenlocui <code>x != 0</code> cu <code>x</code>, ceva comun \u00een C++. Analog, <code>x == 0</code> poate fi scris ca <code>!x</code>.</p> <p>Scurtcircuitarea se aplic\u0103 \u0219i pentru disjunc\u021bie (<code>||</code>). Dac\u0103 prima parte a <code>x || y</code> este adev\u0103rat\u0103, atunci toat\u0103 expresia este adev\u0103rat\u0103.</p> <p>Mai avem urm\u0103toarele rela\u021bii, care arat\u0103 idempoten\u021ba celor dou\u0103 opera\u021bii:</p> <ul> <li><code>x &amp;&amp; x == x</code></li> <li><code>x || x == x</code></li> </ul> <p>Acest lucru este evident, deoarece <code>false || false == false &amp;&amp; false == false</code> \u0219i <code>true || true == true &amp;&amp; true == true</code>. Ce \u00eenseamn\u0103 concret este c\u0103 dac\u0103 avem dou\u0103 expresii identice prin <code>||</code> sau <code>&amp;&amp;</code>, putem p\u0103stra doar una din ele, deci nu mai facem calcule redundante.</p> <p>Urm\u0103toarele rela\u021bii se numesc legea absorb\u021biei:</p> <ul> <li><code>x || (x &amp;&amp; y) == x</code></li> <li><code>x &amp;&amp; (x || y) == x</code></li> </ul> <p>Pe scurt, dac\u0103 <code>x</code> e adev\u0103rat, e irelevant c\u0103 \u0219i <code>x &amp;&amp; y</code> e adev\u0103rat. De asemenea, dac\u0103 pe noi ne intereseaz\u0103 proprietatea <code>x</code>, nu conteaz\u0103 ca <code>x || y</code> e adev\u0103rat, pentru c\u0103 noi vrem doar <code>x</code>. De pild\u0103, dac\u0103 noi vrem s\u0103 c\u0103ut\u0103m toate numerele pare, nu ne intereseaz\u0103 ca unele din ele sunt \u0219i multipli de 10. Dac\u0103 avem <code>(x &lt;= 10) &amp;&amp; (x &lt;= 10 || x % 2 == 0)</code>, atunci ori avem numere mai mici dec\u00e2t 10, ori numere pari mai mici dec\u00e2t 10, dar acestea tot sunt mai mici dec\u00e2t 10, deci doar prima condi\u021bie conteaz\u0103. Analog, pentru <code>(x &gt; 5) || (x &gt; 5 &amp;&amp; x &lt; 10)</code>, \u0219tim c\u0103 <code>x &gt; 5</code> este fie adev\u0103rat \u00een ambele expresii, fie \u00een niciuna din ele.</p> <p>\u0218i nega\u021bia are ni\u0219te propriet\u0103\u021bi utile. \u00cen primul r\u00e2nd, avem:</p> <ul> <li><code>!(!x) == x</code></li> </ul> <p>Logic vorbind, are sens: dac\u0103 un lucru e adev\u0103rat, \u00eenseamn\u0103 c\u0103 opusul s\u0103u este fals. E u\u0219or de v\u0103zut: <code>!(!false) == !true == false</code> \u0219i <code>!(!true) == !false == true</code>.</p> <p>Nega\u021bia poate fi definit\u0103 exclusiv prin urm\u0103toarele dou\u0103 legi importante:</p> <ul> <li><code>x &amp;&amp; !x == false</code></li> <li><code>x || !x == true</code></li> </ul> <p>Ce ne spune prima regul\u0103 e c\u0103 este imposibil s\u0103 satisfaci \u0219i s\u0103 nu satisfaci o proprietate \u00een acela\u0219i timp. \u201eA fi \u0219i a nu fi\u201d este imposibil. \u00cen schimb, \u00eentrebarea lui Shakespeare \u201ea fi sau a nu fi\u201d este \u00eentotdeauna adev\u0103rat\u0103.</p> <p>\u00cen final, avem legile lui DeMorgan, foarte folositoare:</p> <ul> <li><code>!(x || y) == !x &amp;&amp; !y</code></li> <li><code>!(x &amp;&amp; y) == !x || !y</code></li> </ul> <p>Prima lege zice c\u0103 singurul mod prin care <code>x || y</code> poate fi fals este dac\u0103 <code>x</code> \u0219i <code>y</code> sunt false. Dac\u0103 nu \u00eemi place ciocolata sau vanilia, este clar c\u0103 este acela\u0219i lucru cu a zice c\u0103 nu \u00eemi place ciocolata \u0219i nu \u00eemi place vanilia. Dac\u0103 am dou\u0103 condi\u021bii \u0219i nu ambele se \u00eendeplinesc, \u00eenseamn\u0103 c\u0103 una dintre condi\u021bii nu se \u00eendepline\u0219te. Pentru un exemplu mai matematic la a doua lege, dac\u0103 \\(x \\not\\in [2, 3]\\) (\\(x\\) nu este \u00eentre 2 \u0219i 3), atunci este adev\u0103rat fie c\u0103 \\(x &lt; 2\\), fie c\u0103 \\(x &gt; 3\\). Dac\u0103 am rescrie-o \u00een termeni de C++, ar fi: <code>!(x &gt;= 2 &amp;&amp; x &lt;= 3) == !(x &gt;= 2) || !(x &lt;= 3) == (x &lt; 2) || (x &gt; 3)</code>.</p> <p>Cea mai simpl\u0103 metod\u0103 s\u0103 \u021bii minte legile de mai sus este:</p> <ul> <li>schimb\u0103 <code>&amp;&amp;</code> \u00een <code>||</code> \u0219i viceversa</li> <li>neag\u0103 fiecare termen</li> <li>neag\u0103 toat\u0103 expresia</li> </ul> <p>Altfel spus:</p> <ul> <li><code>!(!x || !y) == x &amp;&amp; y</code></li> <li><code>!(!x &amp;&amp; !y) == x || y</code></li> </ul> <p>Urm\u0103toarele dou\u0103 exemple sunt echivalente, iar aceast\u0103 rescriere poate fi util\u0103 \u00een anumite circumstan\u021be pentru a face codul mai curat (de obicei c\u00e2nd a doua ramur\u0103 este scurt\u0103 sau dac\u0103 nega\u021bia este altfel \u00eentortochiat\u0103):</p> <pre><code>if (!A &amp;&amp; !B) {\n    fa_ceva();\n} else {\n    fa_altceva();\n}\n\nif (A || B) {\n    fa_altceva();\n} else {\n    fa_ceva();\n}\n</code></pre> <p>Exist\u0103 \u0219i ni\u0219te echivalen\u021be cu nega\u021bia care sunt utile \u00een manipularea expresiilor rela\u021bionale:</p> <ul> <li><code>!(x == y) == (x != y)</code></li> <li><code>!(x != y) == (x == y)</code></li> <li><code>!(x &lt; y) == (x &gt;= y)</code></li> <li><code>!(x &lt;= y) == (x &gt; y)</code></li> <li><code>!(x &gt; y) == (x &lt;= y)</code></li> <li><code>!(x &gt;= y) == (x &lt; y)</code></li> </ul> <p>Combinat cu legile lui DeMorgan \u0219i celelalte legi de mai sus, putem simplifica cu succes orice condi\u021bie, ob\u021bin\u00e2nd ceva mai scurt de scris \u0219i mai eficient.</p>","tags":["C++","introducere","if","structura alternativa"]},{"location":"cppintro/conditions-if/#concluzii","title":"Concluzii","text":"<p>Odat\u0103 cu \u00eenv\u0103\u021barea structurii alternative, putem acum s\u0103 incorpor\u0103m structuri repetitive, a\u0219a cum pute\u021bi vedea \u00een articolele ulterioare. De asemenea, putem s\u0103 le \u0219i simplific\u0103m.</p>","tags":["C++","introducere","if","structura alternativa"]},{"location":"cppintro/conditions-if/#resurse-suplimentare","title":"Resurse suplimentare","text":"<ul> <li>Articolul despre structuri alternative de pe   pbinfo</li> <li>Learning to code - USACO   Guide</li> </ul>","tags":["C++","introducere","if","structura alternativa"]},{"location":"cppintro/conditions-if/#probleme-suplimentare","title":"Probleme suplimentare","text":"<ul> <li>Probleme usoare si medii din capitolul Structura de   decizie</li> </ul>","tags":["C++","introducere","if","structura alternativa"]},{"location":"cppintro/data-types/","title":"Variabile \u0219i tipuri de date simple","text":"<p>A\u0219a cum a\u021bi observat atunci c\u00e2nd am prezentat primul program \u00een articolul precedent, fiecare component\u0103 are mai multe caracteristici, una dintre cele mai importante fiind variabilele, respectiv tipul de date al acestora.</p> <p>Ulterior, voi \u00eemp\u0103r\u021bi \u00een cele ce urmeaz\u0103 tipurile de date simple \u00een func\u021bie de valorile care sunt p\u0103strate.</p> <p>Totu\u0219i, unele tipuri de date mai complexe, cum ar fi vectorii sau matricile, vor fi discutate \u00een articolele lor corespunz\u0103toare.</p>","tags":["C++","introducere","variabile","tipuri de date"]},{"location":"cppintro/data-types/#variabile","title":"Variabile","text":"<p>Defini\u021bie</p> <p>O variabil\u0103 este o loca\u021bie de memorie care stocheaz\u0103 o valoare de un anumit tip. Aceasta este caracterizat\u0103 printr-o adres\u0103, un identificator, un tip de date \u0219i un domeniu de vizibilitate.</p> <p>Orice variabil\u0103 este caracterizat\u0103 de:</p> <ol> <li> <p>Adresa memoriei: Este loca\u021bia din memorie unde este stocat\u0103 variabila. Nu    lucr\u0103m cu ea \u00een timpul programelor, dar aceasta poate fi util\u0103 \u00een    diagnosticarea problemelor de memorie. Adresa este exprimat\u0103 \u00een hexazecimal    (de exemplu, <code>0x7ffe3278f424</code>).</p> </li> <li> <p>Identificatorul (numele): Reprezint\u0103 leg\u0103tura \u00eentre variabil\u0103 \u0219i valoarea    sa din memorie. Un identificator trebuie s\u0103 respecte urm\u0103toarele reguli:</p> <ul> <li>Poate con\u021bine litere ale alfabetului englez (a-z, A-Z), cifre (0-9) \u0219i     caracterul underscore (bar\u0103 jos, <code>_</code>).</li> <li>Trebuie s\u0103 \u00eenceap\u0103 cu o liter\u0103 sau <code>_</code>, dar niciodat\u0103 cu o cifr\u0103.</li> <li>Nu poate fi un cuv\u00e2nt rezervat al limbajului (ex.: <code>int</code>, <code>return</code>, <code>while</code> etc.).</li> <li>Identificatorul este case-sensitive, astfel \u00eenc\u00e2t <code>Varsta</code>, <code>varsta</code> \u0219i     <code>VARSTA</code> sunt trei identificatori diferi\u021bi.</li> </ul> </li> <li> <p>Tipul de date: Determin\u0103 ce tip de valori poate s\u0103 stocheze variabila \u0219i    limitele acestor valori (ex.: numere \u00eentregi, numere \u00een virgul\u0103 mobil\u0103,    caractere etc.).</p> </li> <li> <p>Domeniul de vizibilitate (scope): Define\u0219te partea programului \u00een care    variabila este accesibil\u0103. Variabilele pot fi:</p> <ul> <li>Globale: disponibile \u00een \u00eentregul program, sau</li> <li>Locale: disponibile doar \u00een cadrul func\u021biei sau blocului \u00een care     sunt definite.</li> </ul> </li> </ol> <p>\u00cen C/C++, este necesar s\u0103 specific\u0103m tipul variabilei la momentul declara\u021biei. Sintaxa general\u0103 este:</p> <pre><code>tip_de_date identificator1, identificator2, ...;\n</code></pre> <p>unde:</p> <ul> <li><code>tip_de_date</code> specific\u0103 tipul valorii pe care o poate stoca variabila (ex.:   <code>int</code>, <code>float</code>, <code>double</code>, <code>char</code>).</li> <li><code>identificator1, identificator2, ...</code> reprezint\u0103 numele variabilelor.</li> </ul> <p>Example</p> <pre><code>int numar;\ndouble pret, tva;\nchar litera;\n</code></pre> <p>Observa\u021bii</p> <ul> <li> <p>Dimensiunea memoriei ocupate de o variabil\u0103 depinde de   tipul de date (ex.: <code>int</code> ocup\u0103 4 bytes \u00een majoritatea sistemelor).</p> </li> <li> <p>Dac\u0103 o variabil\u0103 consum\u0103 mai mult\u0103 memorie dec\u00e2t este disponibil\u0103, ve\u021bi primi   verdictul limit\u0103 de memorie dep\u0103\u0219it\u0103 sau, \u00een limba englez\u0103, memory limit   exceeded.</p> </li> </ul>","tags":["C++","introducere","variabile","tipuri de date"]},{"location":"cppintro/data-types/#tipuri-de-date-ce-pastreaza-numere-intregi","title":"Tipuri de date ce p\u0103streaz\u0103 numere \u00eentregi","text":"<p>Tipurile de date numerice sunt folosite pentru a stoca valori \u00eentregi. Unele dintre aceste tipuri pot avea aplica\u021bii suplimentare; de exemplu, tipul <code>char</code> poate fi folosit \u0219i pentru a opera cu caractere, fiecare valoare av\u00e2nd drept corespondent un caracter din codul ASCII (mai multe detalii vor fi oferite \u00een sec\u021biunea dedicat\u0103 \u0219irurilor de caractere).</p> <p>\u00cen ordinea popularit\u0103\u021bii lor, tipurile de date \u00eentregi sunt urm\u0103toarele:</p> <ol> <li> <p><code>int</code></p> <ul> <li>Cel mai frecvent folosit tip de date pentru a stoca numere \u00eentregi.</li> <li>Stocheaz\u0103 valori \u00eentre -2<sup>31</sup> \u0219i 2<sup>31</sup> - 1 (echivalent     cu -2,147,483,648 \u0219i 2,147,483,647).</li> <li>Ocup\u0103 32 de bi\u021bi (4 bytes) \u00een memorie.</li> </ul> </li> <li> <p><code>long long</code></p> <ul> <li>Un tip de date folosit pentru numerele \u00eentregi mai mari.</li> <li>Av\u00e2nd limite \u00eentre -2<sup>63</sup> \u0219i 2<sup>63</sup> - 1     (-9,223,372,036,854,775,808 \u0219i 9,223,372,036,854,775,807).</li> <li>Numere de maxim 19 cifre, stocate pe 64 de bi\u021bi (8 bytes).</li> </ul> </li> <li> <p><code>char</code></p> <ul> <li>Tipul de date folosit pentru lucrul cu caractere.</li> <li>Av\u00e2nd limite \u00eentre -128 \u0219i 127.</li> <li>Ocup\u0103 1 byte.</li> </ul> </li> <li> <p><code>bool</code></p> <ul> <li>Folosit pentru a p\u0103stra doar valori binare.</li> <li>Valori posibile: 1 sau 0 (corespunz\u0103tor st\u0103rilor de <code>true</code>     (adev\u0103rat) \u0219i <code>false</code> (fals)).</li> </ul> </li> <li> <p><code>short</code></p> <ul> <li>Un tip de date pentru numere \u00eentregi mai mici.</li> <li>Av\u00e2nd limite \u00eentre -2<sup>15</sup> \u0219i 2<sup>15</sup> - 1 (-32,768 \u0219i     32,767).</li> <li>Ocup\u0103 16 bi\u021bi (2 bytes).</li> </ul> </li> </ol> <p>Observa\u021bie</p> <p>Printre altele, exist\u0103 \u0219i tipul de date <code>__int128</code>, care ne permite s\u0103 p\u0103str\u0103m numere pe 128 de bi\u021bi, despre care vom vorbi ulterior \u00een articol, deoarece cunoa\u0219terea lui nu este necesar\u0103 dec\u00e2t pentru aplica\u021bii mai avansate de la olimpiad\u0103.</p>","tags":["C++","introducere","variabile","tipuri de date"]},{"location":"cppintro/data-types/#tipurile-de-date-unsigned","title":"Tipurile de date <code>unsigned</code>","text":"<p>Uneori, putem fi \u00een situa\u021bia \u00een care s\u0103 avem nevoie de numere un pic mai mari dec\u00e2t limitele acestor tipuri de date, f\u0103r\u0103 a avea memoria s\u0103 folosim tipul de date superior. Aici devin utile tipurile <code>unsigned</code>.</p> <p>Pentru toate aceste tipuri, cu excep\u021bia tipului <code>bool</code>, exist\u0103 \u0219i varianta <code>unsigned</code>, care ne d\u0103 posibilitatea s\u0103 p\u0103str\u0103m numere de dou\u0103 ori mai mari cu aceea\u0219i memorie, pre\u021bul fiind faptul c\u0103 nu mai avem cum s\u0103 p\u0103str\u0103m valori negative.</p> <p>De exemplu, tipul de date <code>unsigned int</code> poate p\u0103stra \u00een memorie valori \u00eentre 0 \u0219i 2<sup>32</sup> - 1, intervalul fiind [0, 4.294.967.295].</p> <p>De cele mai multe ori, tipurile de date pe care le folosim sunt <code>unsigned int</code>, respectiv <code>unsigned long long</code>.</p>","tags":["C++","introducere","variabile","tipuri de date"]},{"location":"cppintro/data-types/#tipul-de-date-void","title":"Tipul de date <code>void</code>","text":"<p>Pe l\u00e2ng\u0103 tipurile de date men\u021bionate anterior, exist\u0103 \u0219i tipul de date void, care de\u0219i nu are valori \u0219i opera\u021bii, este necesar pentru a indica faptul c\u0103 o metod\u0103, o func\u021bie sau un program nu returneaz\u0103 nimic, a\u0219a cum ve\u021bi vedea ulterior c\u00e2nd studia\u021bi func\u021biile.</p>","tags":["C++","introducere","variabile","tipuri de date"]},{"location":"cppintro/data-types/#sfaturi-practice-si-evitarea-overflow-ului","title":"Sfaturi practice \u0219i evitarea overflow-ului","text":"<p>De regul\u0103, at\u00e2ta timp c\u00e2t ne permite memoria, folosirea tipului <code>int</code> este mai mult dec\u00e2t suficient\u0103, asigur\u00e2nd echilibrul perfect \u00eentre un consum optim de timp \u0219i memorie pentru opera\u021bii, respectiv stocarea unor valori suficient de mari pentru calculele noastre.</p> <p>Overflow</p> <p>Atunci c\u00e2nd valoarea p\u0103strat\u0103 \u00eentr-un tip de date dep\u0103\u0219e\u0219te valoarea maxim\u0103 permis\u0103, se \u00eent\u00e2mpl\u0103 ceea ce numim overflow. Cu alte cuvinte, valoarea se \u00eentoarce la valoarea minim\u0103 permis\u0103, ceea ce face calculele viitoare s\u0103 devin\u0103 eronate.</p> <p>Underflow</p> <p>\u00cen mod similar, putem vorbi \u0219i de underflow, c\u00e2nd valorile devin mai mici dec\u00e2t valorile minime permise, dar aceast\u0103 situa\u021bie se \u00eent\u00e2lne\u0219te mult mai rar \u00een practic\u0103.</p> <p>Un exemplu tipic de overflow se poate \u00eent\u00e2lni atunci c\u00e2nd adun\u0103m sau \u00eenmul\u021bim dou\u0103 valori care de\u0219i ambele se \u00eencadreaz\u0103 \u00een <code>int</code>, suma (sau produsul lor) dep\u0103\u0219e\u0219te valoarea maxim\u0103 a tipului de date <code>int</code>.</p> <pre><code>cout &lt;&lt; 594943 * 204232 &lt;&lt; '\\n';        // overflow\ncout &lt;&lt; 1LL * 594943 * 204232 &lt;&lt; '\\n';  // ok\ncout &lt;&lt; 594943LL * 204232 &lt;&lt; '\\n';      // ok\n\ncout &lt;&lt; 1000000000 + 2000000000 &lt;&lt; '\\n';        // overflow\ncout &lt;&lt; 0LL + 1000000000 + 2000000000 &lt;&lt; '\\n';  // ok\ncout &lt;&lt; 1000000000LL + 2000000000 &lt;&lt; '\\n';      // ok\n</code></pre> <p>Cele mai populare dou\u0103 solu\u021bii pentru evitarea overflow-ului sunt fie folosirea tipului de date long long pentru p\u0103strarea termenilor din opera\u021bii, fie folosirea operatorului <code>1LL</code>, fie folosirea <code>(long long)</code> pentru convertirea datelor.</p> <p>Numere mai mari</p> <p>\u00cen unele probleme, chiar \u0219i numerele pe 64 (sau 128) de bi\u021bi nu sunt \u00eendeajuns de mari, a\u0219a c\u0103 se impune p\u0103strarea datelor sub form\u0103 de vectori, mai multe detalii despre asta pute\u021bi g\u0103si \u00een acest articol, dup\u0103 ce v\u0103 familiariza\u021bi cu lucrul cu algoritmi mai dificili dec\u00e2t scopul acestui articol.</p>","tags":["C++","introducere","variabile","tipuri de date"]},{"location":"cppintro/data-types/#tipuri-de-date-reale","title":"Tipuri de date reale","text":"<p>Tipurile de date reale sunt folosite pentru a stoca valori reale. Acestea sunt folosite mai ales \u00een unele calcule matematice mai complexe, precum calculele geometrice sau \u00een privin\u021ba unor ecua\u021bii.</p> <p>Tipurile de date reale sunt urm\u0103toarele:</p> <ul> <li>tipul <code>float</code> - limite \u00eentre aproximativ -10<sup>38</sup> \u0219i   10<sup>38</sup>.</li> <li>tipul <code>double</code> - limite \u00eentre aproximativ -10<sup>208</sup> \u0219i   10<sup>208</sup>, precizie crescut\u0103.</li> <li>tipul <code>long double</code> - limite mai mari dec\u00e2t cele de la <code>double</code>,   precizie variabil\u0103.</li> </ul> <p>\u00cen general, atunci c\u00e2nd oper\u0103m cu numerele reale, vrem s\u0103 avem grij\u0103 la erorile de precizie care ar putea ap\u0103rea. Cel mai bun mod de a face acest lucru, \u00een special c\u00e2nd lucr\u0103m cu valori foarte mari \u00een modul, este acela de a include o valoare real\u0103 foarte mic\u0103, \\(eps\\), care s\u0103 serveasc\u0103 drept etalon \u00een ceea ce prive\u0219te verificarea egalit\u0103\u021bii.</p> <p>Observa\u021bie</p> <p>Atunci c\u00e2nd scriem coduri mai simple sau avem de-a face cu un examen de tipul celui de bacalaureat, nu este nevoie s\u0103 folosim aceast\u0103 metod\u0103 pentru a verifica egalitatea dintre numere, putem verifica folosind metoda uzual\u0103.</p> <p>Astfel, pentru a verifica egalitatea dintre dou\u0103 numere reale mai mari, putem incorpora <code>eps</code> astfel:</p> <pre><code>#include &lt;cmath&gt;\n#include &lt;iostream&gt;\n\nusing namespace std;\n\n// 10\u207b\u2079, o valoare real\u0103 foarte mic\u0103.\ndouble eps = 1e-9;\n\nint main() {\n    double a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    if (abs(a - b) &lt;= eps) {\n        cout &lt;&lt; \"Egale\" &lt;&lt; '\\n';\n    } else {\n        cout &lt;&lt; \"Inegale\" &lt;&lt; '\\n';\n    }\n    return 0;\n}\n</code></pre>","tags":["C++","introducere","variabile","tipuri de date"]},{"location":"cppintro/data-types/#tipul-__int128","title":"Tipul <code>__int128</code>","text":"<p>Pe l\u00e2ng\u0103 aceste tipuri, exist\u0103 \u0219i tipul de date <code>__int128</code> care ne permite s\u0103 stoc\u0103m valori pe 128 de bi\u021bi, av\u00e2nd limite \u00eentre -2<sup>127</sup> si 2<sup>127</sup> - 1 (numere de aproximativ 37 de cifre). Acest tip poate fi folosit doar pe compilatorul GCC.</p> <p>Noi nu putem s\u0103 citim \u0219i s\u0103 afi\u0219\u0103m direct <code>__int128</code>, deci va trebui s\u0103 ne implement\u0103m noi citirea \u0219i afi\u0219area. Pentru simplitate, dac\u0103 implement\u0103m cum este mai jos, vom putea s\u0103 folosim <code>std::cin &gt;&gt; x</code> chiar dac\u0103 \\(x\\) este <code>__int128</code>.</p> <pre><code>#include &lt;algorithm&gt;  // Pentru std::reverse\n#include &lt;iostream&gt;\n#include &lt;string&gt;  // Pentru std::string\n\n// Citire\nstd::istream &amp;operator&gt;&gt;(std::istream &amp;in, __int128 &amp;num) {\n    num = 0;\n\n    std::string s;\n    in &gt;&gt; s;\n\n    if (s.empty()) {\n        return in;\n    }\n\n    bool neg = (s[0] == '-');\n    int start = (neg ? 1 : 0);\n\n    for (int i = start; i &lt; s.size(); ++i) {\n        num = num * 10 + (s[i] - '0');\n    }\n\n    if (neg) {\n        num = -num;\n    }\n\n    return in;\n}\n\n// Afi\u0219are\nstd::ostream &amp;operator&lt;&lt;(std::ostream &amp;out, __int128 num) {\n    if (num == 0) {\n        out &lt;&lt; \"0\";\n        return out;\n    }\n\n    bool neg = (num &lt; 0);\n    if (neg) {\n        num = -num;\n    }\n\n    std::string s;\n    while (num &gt; 0) {\n        s.push_back('0' + num % 10);\n        num /= 10;\n    }\n\n    if (neg) {\n        s.push_back('-');\n    }\n\n    std::reverse(s.begin(), s.end());\n    out &lt;&lt; s;\n    return out;\n}\n</code></pre>","tags":["C++","introducere","variabile","tipuri de date"]},{"location":"cppintro/data-types/#concluzii","title":"Concluzii","text":"<p>Tipurile de date simple sunt cele cu care oper\u0103m \u00een aproape toate programele pe care le scriem vreodat\u0103 \u00een C++ (\u0219i \u00een alte limbaje de programare care au aceste tipuri de date), iar \u00een\u021belegerea lor este fundamental\u0103 pentru a putea deveni programatori tot mai buni.</p>","tags":["C++","introducere","variabile","tipuri de date"]},{"location":"cppintro/data-types/#resurse-suplimentare","title":"Resurse suplimentare","text":"<ul> <li>Data types - USACO Guide</li> <li>Tipuri de date - pbinfo</li> </ul>","tags":["C++","introducere","variabile","tipuri de date"]},{"location":"cppintro/fast-io/","title":"Citire rapid\u0103. Parsarea datelor","text":"","tags":["input","output","implementare","parsare","optimizare"]},{"location":"cppintro/fast-io/#introducere","title":"Introducere","text":"<p>Obiectivul fiec\u0103rui competitor atunci c\u00e2nd rezolv\u0103 o problem\u0103 este s\u0103 ob\u021bin\u0103 c\u00e2t mai multe puncte folosind un algoritm c\u00e2t mai eficient din punct de vedere al timpului de execu\u021bie \u0219i al memoriei folosite. De\u0219i aceast\u0103 abordare este cea mai bun\u0103 pentru realizarea acestui obiectiv, uneori restric\u021biile impuse de autorii problemelor \u00eencurajeaz\u0103 folosirea unor metode suplimentare pentru c\u00e2\u0219tigarea unui timp pre\u021bios care poate fi folosit pentru a avea o marj\u0103 mai larg\u0103 la dispozi\u021bie.</p> <p>Una dintre cele mai populare optimiz\u0103ri de constant\u0103 care se poate aplica mai ales la problemele mai grele const\u0103 \u00een citirea c\u00e2t mai rapid\u0103 a datelor de intrare (precum \u0219i afi\u0219area c\u00e2t mai rapid\u0103 a datelor de ie\u0219ire, chiar dac\u0103 de regul\u0103 inputul este mult mai cuprinz\u0103tor dec\u00e2t outputul).</p> <p>\u00cen acest articol vom prezenta c\u00e2teva situa\u021bii specifice, precum \u0219i alte sfaturi care trebuie avute \u00een vedere.</p>","tags":["input","output","implementare","parsare","optimizare"]},{"location":"cppintro/fast-io/#optimizarea-citirii-si-afisarii-standard","title":"Optimizarea citirii \u0219i afi\u0219\u0103rii standard","text":"<p>Atunci c\u00e2nd citi\u021bi \u0219i afi\u0219a\u021bi date de intrare \u0219i ie\u0219ire folosind metoda standard, aproape \u00een fiecare situa\u021bie folosi\u021bi instruc\u021biuni de tip <code>std::cin</code> \u0219i <code>std::cout</code>. De\u0219i acestea sunt instruc\u021biuni foarte bune \u0219i utile, din p\u0103cate se pot dovedi a fi foarte \u00eencete atunci c\u00e2nd volumul datelor este foarte mare. Astfel, se impune g\u0103sirea unor \u00eembun\u0103t\u0103\u021biri pe care le vom prezenta mai jos.</p> <p>Prima \u0219i cea mai important\u0103 optimizare pe care o vom face este s\u0103 folosim urm\u0103toarele linii pentru a desincroniza streamurile de date din C \u0219i C++, f\u0103c\u00e2nd citirea datelor mult mai rapid\u0103 (factorul de optimizare este de cel pu\u021bin 2-3 ori, \u00een anumite cazuri fiind chiar \u0219i de 5 ori mai rapid).</p> <pre><code>ios_base::sync_with_stdio(false);\ncin.tie(NULL);\n</code></pre> <p>Observa\u021bie</p> <p>Este de remarcat faptul c\u0103 linia <code>cout.tie(NULL);</code>, de\u0219i prezent\u0103 \u00een   foarte multe coduri, inclusiv solu\u021bii oficiale, nu face nimic deoarece   streamul de afi\u0219are este deja desincronizat.</p> <p>Folosind aceast\u0103 metod\u0103, preveni\u021bi aproape toate tipurile de erori din punct de vedere al timpului de execu\u021bie cauzate de citirea \u00eenceat\u0103. Totu\u0219i, mai putem face \u00eembun\u0103t\u0103\u021biri \u00een ceea ce prive\u0219te acest aspect.</p>","tags":["input","output","implementare","parsare","optimizare"]},{"location":"cppintro/fast-io/#citirea-folosind-buffere-fread","title":"Citirea folosind buffere (fread)","text":"<p>Vom presupune pentru simplitate c\u0103 atunci c\u00e2nd rezolv\u0103m probleme folosind intrarea \u0219i ie\u0219irea standard, folosim instruc\u021biuni de tip <code>std::cin</code> \u0219i <code>std::cout</code>, iar atunci c\u00e2nd citim datele din fi\u0219iere, folosim metode de tip <code>std::ifstream</code> \u0219i <code>std::ofstream</code>.</p> <p>De\u0219i aceste metode sunt destul de rapide folosind optimiz\u0103rile men\u021bionate anterior, putem ob\u021bine \u00eembun\u0103t\u0103\u021biri semnificative apel\u00e2nd la citirea unui bloc de caractere deodat\u0103, iar mai apoi s\u0103 proces\u0103m datele pe m\u0103sur\u0103 ce avem nevoie de ele, \u021bin\u00e2nd datele \u00een bufere (zone de date mai mari). Avantajul acestei metode este acela c\u0103 acces\u0103m streamurile de intrare \u0219i ie\u0219ire mult mai rar, astfel evit\u00e2nd una dintre cele mai \u00eencete p\u0103r\u021bi ale citirii \u0219i afi\u0219\u0103rii datelor, folosirea bufferelor.</p> <p>Aceast\u0103 metod\u0103 este numit\u0103 colocvial \u0219i parsarea datelor, acesta fiind un nume popularizat de articolele de pe infoarena \u00een care aceast\u0103 metod\u0103 a fost descris\u0103 \u00een urm\u0103 cu mul\u021bi ani.</p> <p>Observa\u021bie</p> <p>Parsarea este necesar\u0103 mai ales atunci c\u00e2nd avem de-a face cu un \u0219ir cu foarte multe numere, deoarece atunci c\u00e2nd citim un \u0219ir de caractere, deja acces\u0103m bufferul de pu\u021bine ori.</p> <p>De regul\u0103, se recomand\u0103 folosirea unor buffere de lungime puteri ale lui 2, fiind folosite foarte des lungimi precum 4096 sau 65536. Mai jos pute\u021bi g\u0103si un exemplu de aplicare al acestei metode pentru a citi \u0219i afi\u0219a un \u0219ir de numere naturale. Adaptarea acestui parser la fi\u0219iere se poate face \u00een multe moduri, o metod\u0103 care merge este folosirea unei declar\u0103ri \u00een stilul C, iar mai apoi folosirea printf pentru afi\u0219area mai multor valori deodat\u0103.</p> <pre><code>#include &lt;cassert&gt;\n#include &lt;cstring&gt;\n#include &lt;iostream&gt;\n\nconst int MOD = 1e9 + 7;\nconst int BUF_SZ = 1 &lt;&lt; 15;\n\ninline namespace Input {\nchar buf[BUF_SZ];\nint pos, len;\nchar next_char() {  // se citeste un caracter\n    if (pos == len) {\n        pos = 0;\n        len = (int)fread(buf, 1, BUF_SZ, stdin);\n        if (!len) {\n            return EOF;\n        }\n    }\n    return buf[pos++];\n}\n\nint read_int() {  // se citeste un numar intreg, eventual negativ\n    int x;\n    char ch;\n    int sgn = 1;\n    while (!isdigit(ch = next_char())) {\n        if (ch == '-') {\n            sgn *= -1;\n        }\n    }\n    x = ch - '0';\n    while (isdigit(ch = next_char())) {\n        x = x * 10 + (ch - '0');\n    }\n    return x * sgn;\n}\n}  // namespace Input\n\ninline namespace Output {\nchar buf[BUF_SZ];\nint pos;\n\nvoid flush_out() {\n    fwrite(buf, 1, pos, stdout);\n    pos = 0;\n}\n\nvoid write_char(char c) {  // se afiseaza un caracter\n    if (pos == BUF_SZ) {\n        flush_out();\n    }\n    buf[pos++] = c;\n}\n\nvoid write_int(int x) {  // se afiseaza un numar intreg\n    static char num_buf[100];\n    if (x &lt; 0) {\n        write_char('-');\n        x *= -1;\n    }\n    int len = 0;\n    for (; x &gt;= 10; x /= 10) {\n        num_buf[len++] = (char)('0' + (x % 10));\n    }\n    write_char((char)('0' + x));\n    while (len) {\n        write_char(num_buf[--len]);\n    }\n    write_char('\\n');\n}\n\n// se da flush la output cand se termina programul\nvoid init_output() { assert(atexit(flush_out) == 0); }\n}  // namespace Output\n\nint main() {\n    init_output();\n    int M = read_int();\n    int N = read_int();\n    int ans = 0;\n    for (int i = 0; i &lt; N; i++) {\n        ans = (ans + read_int()) % MOD;\n        if (M == 1) {\n            write_int(ans);\n        }\n    }\n    if (M == 0) {\n        write_int(ans);\n    }\n    return 0;\n}\n</code></pre>","tags":["input","output","implementare","parsare","optimizare"]},{"location":"cppintro/fast-io/#concluzii","title":"Concluzii","text":"<p>Citirea rapid\u0103 a datelor este foarte important\u0103 \u00een multe situa\u021bii pentru a evita problemele cu limita de timp cauzat\u0103 de metodele \u00eencete de a citi datele. Chiar dac\u0103 \u00een aproape nicio situa\u021bie nu este nevoie s\u0103 folosim cele mai rapide metode de citire a datelor folosind buffere, poate fi util s\u0103 \u0219ti\u021bi s\u0103 face\u021bi acest lucru pentru a c\u00e2\u0219tiga c\u00e2teve zecimi de secund\u0103 \u00een cazul unor probleme cu date foarte mari.</p> <p>Totu\u0219i, pe m\u0103sur\u0103 ce tot mai multe concursuri apeleaz\u0103 la citirea \u0219i afi\u0219area standard, precum \u0219i citirea din func\u021bii, aceast\u0103 metod\u0103 va fi tot mai pu\u021bin relevant\u0103, dar niciodat\u0103 nu va ie\u0219i din uz.</p>","tags":["input","output","implementare","parsare","optimizare"]},{"location":"cppintro/fast-io/#resurse-suplimentare","title":"Resurse suplimentare","text":"<ul> <li>Significance of ios_base::sync_with_stdio(false); cin.tie(NULL);</li> <li>Parsare fi\u0219ier intrare -   infoarena</li> <li>Parsare fi\u0219ier ie\u0219ire -   infoarena</li> <li>Parsarea fi\u0219ierelor \u0219i citirea rapid\u0103 a datelor \u00een C++</li> <li>Citire/scriere rapid\u0103 - Algopedia</li> <li>Fast IO - USACO Guide</li> </ul>","tags":["input","output","implementare","parsare","optimizare"]},{"location":"cppintro/functions/","title":"Subprograme","text":"","tags":["C++","functii","implementare","recursivitate"]},{"location":"cppintro/functions/#introducere","title":"Introducere","text":"<p>Atunci c\u00e2nd scrie\u021bi un program \u00een orice limbaj de programare, exist\u0103 situa\u021bii \u00een care sunte\u021bi nevoi\u021bi s\u0103 executa\u021bi anumite tipuri de opera\u021bii de mai multe ori. Pentru a evita scrierea acestor secven\u021be de un num\u0103r mare de ori, se impune folosirea unor secven\u021be de cod pe care s\u0103 le putem refolosi. Acestea vor fi ceea ce numim \u00een limbajul C++ func\u021bii sau subprograme.</p> <p>Func\u021bie</p> <p>O func\u021bie sau un subprogram reprezint\u0103 o secven\u021b\u0103 de cod care poate fi apelat\u0103 de utilizator pentru a fi executat\u0103 de mai multe ori, f\u0103r\u0103 a fi nevoie s\u0103 rescriem acel cod. Aceasta poate fi apelat\u0103 fie din programul principal, fie dintr-o alt\u0103 func\u021bie.</p> <p>\u00cen limbajul C++, avem at\u00e2t func\u021bii de sistem (deja cunoscute de biblioteci) \u0219i func\u021bii definite de utilizator.</p>","tags":["C++","functii","implementare","recursivitate"]},{"location":"cppintro/functions/#functii-de-sistem","title":"Func\u021bii de sistem","text":"<p>Chiar dac\u0103 acest articol nu se va concentra pe func\u021biile de sistem, cel mai probabil a\u021bi folosit p\u00e2n\u0103 acum aceste func\u021bii pentru a afla valorile diverselor func\u021bii.</p> <p>Un astfel de exemplu este func\u021bia <code>sqrt(x)</code>, care ne ajut\u0103 s\u0103 afl\u0103m valoarea lui \\(\\sqrt n\\), func\u021bie ce se reg\u0103se\u0219te \u00een biblioteca <code>&lt;cmath&gt;</code>. \u00cen mod similar, probabil a\u021bi folosit p\u00e2n\u0103 acum func\u021bia <code>std::sort</code>, func\u021bie ce se reg\u0103se\u0219te \u00een biblioteca <code>&lt;algorithm&gt;</code>, iar exemplele pot continua.</p> <p>De\u0219i nu trebuie s\u0103 rescriem aceste func\u021bii, acestea se bazeaz\u0103 pe acela\u0219i principiu (refolosirea unor coduri deja scrise), singura diferen\u021b\u0103 fiind aceea c\u0103 codul din spatele acestor func\u021bii face deja parte din standardul bibliotecilor \u0219i nu trebuie reprodus.</p>","tags":["C++","functii","implementare","recursivitate"]},{"location":"cppintro/functions/#avantajele-folosirii-functiilor","title":"Avantajele folosirii func\u021biilor","text":"<p>Deoarece putem refolosi codul scris de noi, acestea se dovedesc a fi un instrument foarte bun \u00een privin\u021ba reducerii cantit\u0103\u021bii de cod scris\u0103. Acest lucru ne ajut\u0103 \u0219i atunci c\u00e2nd facem debugging, deoarece dac\u0103 avem o func\u021bie gre\u0219it\u0103, trebuie s\u0103 schimb\u0103m lucruri \u00eentr-un singur loc \u00een loc s\u0103 trebuiasc\u0103 s\u0103 schimb\u0103m \u00een mai multe locuri.</p> <p>Func\u021biile pot fi scrise \u00een mai multe moduri, dar mai \u00eent\u00e2i ne vom concentra pe p\u0103r\u021bile componente ale unei func\u021bii \u0219i sintaxa ei. Pe parcurs, vom folosi diverse exemple care s\u0103 ilustreze diversele moduri \u00een care putem scrie o func\u021bie care face acela\u0219i lucru.</p> <p>Pe l\u00e2ng\u0103 avantajele evidente pe care cunoa\u0219terea func\u021biilor le ofer\u0103, acestea reprezint\u0103 \u0219i un capitol fundamental \u00een studiul limbajului C++ \u0219i a multor algoritmi, fiind necesare pentru \u00een\u021belegerea multor algoritmi \u0219i metode de programare.</p>","tags":["C++","functii","implementare","recursivitate"]},{"location":"cppintro/functions/#partile-componente-ale-unei-functii","title":"P\u0103r\u021bile componente ale unei func\u021bii","text":"<p>\u00cen general, o func\u021bie are urm\u0103torul \u0219ablon:</p> <pre><code>tip nume(tip_1 nume_1, tip_2 nume_2, ..., tip_k nume_k) {\n    // Instruc\u021biuni\n}\n</code></pre> <p>O func\u021bie este format\u0103 din dou\u0103 p\u0103r\u021bi principale: antetul (declararea func\u021biei) \u0219i corpul (implementarea func\u021biei).</p> <ol> <li> <p>Antetul func\u021biei</p> <p>Antetul unei func\u021bii este format din urm\u0103toarele componente:</p> <ul> <li> <p>Tipul de returnare (tip). Reprezint\u0103 tipul valorii \u00eentoarse de   func\u021bie. Poate fi orice tip de date cunoscut \u00een limbajul C++, inclusiv   containere din STL.</p> <p>Dac\u0103 func\u021bia nu \u00eentoarce nicio valoare, se utilizeaz\u0103 tipul <code>void</code>, care semnific\u0103 un tip gol.</p> <p>Aten\u021bie</p> <p>\u00cen cazul func\u021biilor cu tipul de returnare diferit de <code>void</code>, omisiunea unei valori returnate genereaz\u0103, de obicei, un warning la compilare. \u00cen unele cazuri, comportamentul programului devine imprevizibil (undefined behavior).</p> </li> <li> <p>Numele func\u021biei. Este ales de utilizator \u0219i trebuie s\u0103 respecte   regulile de numire ale identificatorilor (de exemplu, s\u0103 nu \u00eenceap\u0103 cu   cifre, s\u0103 nu con\u021bin\u0103 caractere speciale, etc.).</p> </li> <li> <p>Parametrii func\u021biei. Sunt variabilele pe care func\u021bia le prime\u0219te la   apel. Fiecare parametru are un tip de date \u0219i un nume.</p> <p>Observa\u021bie</p> <p>Parametrii func\u021biei nu sunt obligatorii. Totu\u0219i, ace\u0219tia fac func\u021bia mai flexibil\u0103 \u0219i reutilizabil\u0103 \u00een diverse contexte.</p> </li> </ul> </li> <li> <p>Corpul func\u021biei.</p> <p>Corpul func\u021biei include instruc\u021biunile specifice care determin\u0103  comportamentul func\u021biei. Acestea pot fi orice instruc\u021biuni C++ valide,  respect\u00e2nd regulile de sintax\u0103 \u0219i compilare.</p> </li> <li> <p>Returnarea valorii.</p> <p>O func\u021bie poate \u00eentoarce o valoare folosind instruc\u021biunea <code>return</code>. Aceasta finalizeaz\u0103 execu\u021bia func\u021biei \u0219i trimite o valoare c\u0103tre codul care a apelat func\u021bia (dac\u0103 func\u021bia are un tip de returnare diferit de <code>void</code>).</p> <ul> <li> <p>Pentru func\u021bii cu tip non-<code>void</code>:</p> <p>Instruc\u021biunea <code>return</code> trebuie s\u0103 fie urmat\u0103 de o expresie sau o valoare compatibil\u0103 cu tipul declarat al func\u021biei. Absen\u021ba unei valori returnate va genera, de obicei, un warning la compilare \u0219i poate duce la un comportament imprevizibil (undefined behavior).</p> <pre><code>int aduna(int a, int b) { return a + b; }\n</code></pre> <p>Aten\u021bie</p> <p>\u00centr-o func\u021bie cu tip non-<code>void</code>, toate c\u0103ile posibile de execu\u021bie trebuie s\u0103 aib\u0103 o valoare returnat\u0103. Pe scurt, nu po\u021bi avea unele locuri de unde returnezi \u0219i altele de unde nu. Deci, a\u0219a ceva nu e posibil:</p> <pre><code>char c(int n) {\n    if (n &lt;= 80) {\n        return 'C';\n    }\n    // Pentru n &gt; 80, func\u021bia nu returneaz\u0103 nimic,\n    // deci func\u021bia are undefined behavior \u00een acel\n    // domeniu.\n}\n</code></pre> </li> <li> <p>Pentru func\u021bii de tip <code>void</code>:</p> <p>Func\u021biile declarate cu tipul <code>void</code> nu \u00eentorc nicio valoare, iar utilizarea instruc\u021biunii return este op\u021bional\u0103. \u00cen acest caz, <code>return;</code> poate fi folosit doar pentru a \u00eencheia executarea func\u021biei mai devreme.</p> <pre><code>void afiseaza_mesaj() {\n    cout &lt;&lt; \"Salut!\" &lt;&lt; endl;\n\n    // Op\u021bional:\n    // return;\n}\n</code></pre> </li> </ul> </li> </ol>","tags":["C++","functii","implementare","recursivitate"]},{"location":"cppintro/functions/#utilizarea-functiilor","title":"Utilizarea func\u021biilor","text":"<p>\u00cen general, func\u021biile trebuie scrise \u00eentr-o ordine care s\u0103 faciliteze accesul \u0219i utilizarea lor. De regul\u0103, o func\u021bie trebuie declarat\u0103 sau definit\u0103 \u00eenainte de a fi folosit\u0103 \u00een cod. \u00cen caz contrar, compilatorul nu va recunoa\u0219te func\u021bia respectiv\u0103 \u0219i va genera o eroare.</p> Cod corect (definirea \u00eenainte de folosire)Cod gre\u0219it (lipsa defini\u021biei \u00eenainte de apel) <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nlong long sum_div(int numar) {\n    long long suma = 0;\n    for (int divizor = 1; divizor * divizor &lt;= numar; divizor++) {\n        if (numar % divizor == 0) {\n            suma += divizor;\n\n            if (divizor * divizor != numar) {\n                suma += numar / divizor;\n            }\n        }\n    }\n    return suma;\n}\n\nint main() {\n    int numar;\n    cin &gt;&gt; numar;\n\n    cout &lt;&lt; sum_div(numar) &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre> <p>\u00cen acest exemplu, func\u021bia <code>sum_div</code> este definit\u0103 deasupra func\u021biei <code>main</code>, ceea ce face ca aceasta s\u0103 poat\u0103 fi utilizat\u0103 f\u0103r\u0103 alte declara\u021bii suplimentare.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int numar;\n    cin &gt;&gt; numar;\n\n    // Eroare! Func\u021bia `sum_div` nu este cunoscut\u0103 \u00een acest moment.\n    cout &lt;&lt; sum_div(numar) &lt;&lt; '\\n';\n    return 0;\n}\n\nlong long sum_div(int numar) {\n    long long suma = 0;\n    for (int divizor = 1; divizor * divizor &lt;= numar; divizor++) {\n        if (numar % divizor == 0) {\n            suma += divizor;\n\n            if (divizor * divizor != numar) {\n                suma += numar / divizor;\n            }\n        }\n    }\n    return suma;\n}\n</code></pre> <p>\u00cen acest caz, func\u021bia <code>sum_div</code> este definit\u0103 dup\u0103 func\u021bia <code>main</code>, dar f\u0103r\u0103 o declara\u021bie prealabil\u0103 (antet). Din aceast\u0103 cauz\u0103, compilatorul genereaz\u0103 o eroare, deoarece nu poate identifica func\u021bia <code>sum_div</code>.</p> <p>Dac\u0103 dorim s\u0103 definim func\u021biile dup\u0103 func\u021bia <code>main</code>, putem folosi o declara\u021bie prealabil\u0103 (prototip) care s\u0103 indice existen\u021ba func\u021biei \u0219i semn\u0103tura acesteia.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nlong long sum_div(int numar);\n\nint main() {\n    int numar;\n    cin &gt;&gt; numar;\n\n    cout &lt;&lt; sum_div(numar) &lt;&lt; '\\n';\n    return 0;\n}\n\nlong long sum_div(int numar) {\n    long long suma = 0;\n    for (int divizor = 1; divizor * divizor &lt;= numar; divizor++) {\n        if (numar % divizor == 0) {\n            suma += divizor;\n\n            if (divizor * divizor != numar) {\n                suma += numar / divizor;\n            }\n        }\n    }\n    return suma;\n}\n</code></pre>","tags":["C++","functii","implementare","recursivitate"]},{"location":"cppintro/functions/#clasificarea-functiilor-dupa-valorile-pe-care-le-intorc","title":"Clasificarea func\u021biilor dup\u0103 valorile pe care le \u00eentorc","text":"<p>\u00cen func\u021bie de ce valori ne \u00eentoarce func\u021bia, acestea sunt de dou\u0103 feluri:</p>","tags":["C++","functii","implementare","recursivitate"]},{"location":"cppintro/functions/#functii-care-returneaza-o-valoare-sau-mai-multe","title":"Func\u021bii care returneaz\u0103 o valoare (sau mai multe)","text":"<p>Acestea sunt cele mai frecvent \u00eent\u00e2lnite func\u021bii. Ele preiau una sau mai multe valori, le proceseaz\u0103 \u0219i \u00eentorc rezultatul.</p> <p>De exemplu, urm\u0103toarea func\u021bie prime\u0219te un num\u0103r \u00eentreg ca parametru \u0219i returneaz\u0103 suma divizorilor s\u0103i:</p> <pre><code>long long sum_div(int numar) {\n    long long suma = 0;\n    for (int divizor = 1; divizor * divizor &lt;= numar; divizor++) {\n        if (numar % divizor == 0) {\n            suma += divizor;\n\n            if (divizor * divizor != numar) {\n                suma += numar / divizor;\n            }\n        }\n    }\n    return suma;\n}\n</code></pre> <p>Observa\u021bie</p> <p>Variabilele declarate \u00eentr-o func\u021bie sunt locale \u0219i nu influen\u021beaz\u0103 programul principal sau alte func\u021bii (excep\u021bie f\u0103c\u00e2nd valorile returnate). Dac\u0103 o variabil\u0103 cu acela\u0219i nume este declarat\u0103 \u00een alt context, nu exist\u0103 interferen\u021be.</p>","tags":["C++","functii","implementare","recursivitate"]},{"location":"cppintro/functions/#functii-care-nu-returneaza-nimic-functii-void","title":"Func\u021bii care nu returneaz\u0103 nimic (func\u021bii <code>void</code>)","text":"<p>\u00cen limbajul C++, o func\u021bie care nu returneaz\u0103 nimic are \u00eentotdeauna tipul <code>void</code>.</p> <p>Acest tip de func\u021bii este utilizat, de exemplu, pentru a realiza opera\u021bii care nu necesit\u0103 un rezultat \u00eentors, cum ar fi modificarea unor variabile globale sau trecerea prin anumite pa\u0219i recursivi.</p> <p>De exemplu, putem scrie o func\u021bie care s\u0103 afle suma cifrelor unui num\u0103r, iar rezultatul s\u0103 fie \u021binut fie cu ajutorul unei variabile globale, fie cu ajutorul unei variabile care va prelua rezultatul prin referin\u021b\u0103.</p>","tags":["C++","functii","implementare","recursivitate"]},{"location":"cppintro/functions/#functii-care-intorc-valori-prin-parametri","title":"Func\u021bii care \u00eentorc valori prin parametri","text":"<p>Aceste func\u021bii, de obicei de tip void, nu returneaz\u0103 valori direct prin utilizarea cuv\u00e2ntului cheie <code>return</code>. \u00cen schimb, ele modific\u0103 valorile unor variabile transmise ca parametri prin referin\u021b\u0103. Acest lucru permite ca variabilele utilizate \u00een alte p\u0103r\u021bi ale programului s\u0103 fie actualizate direct, f\u0103r\u0103 a necesita o valoare returnat\u0103 explicit.</p> <p>Se folose\u0219te nota\u021bia <code>&amp;nume</code> pentru a indica faptul c\u0103 func\u021bia va opera asupra adresei de memorie a variabilei transmise, reflect\u00e2nd astfel orice modificare la nivel global \u00een program.</p> <p>Observa\u021bie</p> <p>Atunci c\u00e2nd utiliz\u0103m parametri transmi\u0219i prin referin\u021b\u0103, este important ca variabilele s\u0103 fie ini\u021bializate \u00eenainte de a fi trimise func\u021biei. Altfel, exist\u0103 riscul apari\u021biei unor erori cauzate de utilizarea unor valori neini\u021bializate.</p> <p>Mai jos este exemplificat\u0103 o func\u021bie care calculeaz\u0103 suma cifrelor unui num\u0103r, actualiz\u00e2nd direct variabila care va stoca rezultatul:</p> <pre><code>void sum_cif(int numar, int &amp;suma) {\n    suma = 0;\n\n    while (numar &gt; 0) {\n        suma += numar % 10;\n        numar /= 10;\n    }\n}\n</code></pre>","tags":["C++","functii","implementare","recursivitate"]},{"location":"cppintro/functions/#functii-care-folosesc-variabile-auxiliare","title":"Func\u021bii care folosesc variabile auxiliare","text":"<p>Acest tip de func\u021bie se bazeaz\u0103 pe utilizarea unor variabile globale pentru stocarea rezultatelor. Aceste func\u021bii modific\u0103 variabile declarate \u00een afara func\u021biei \u0219i pot fi utile \u00een situa\u021bii complexe, cum ar fi rezolvarea problemelor care implic\u0103 mai multe func\u021bii interdependente. Totu\u0219i, utilizarea variabilelor globale poate duce la dificult\u0103\u021bi \u00een men\u021binerea codului, fiind recomandat\u0103 doar \u00een cazuri bine justificate.</p> <pre><code>int suma = 0;\n\nvoid sum_cif(int numar) {\n    suma = 0;\n\n    while (numar &gt; 0) {\n        suma += numar % 10;\n        numar /= 10;\n    }\n}\n</code></pre> <p>\u00cen acest caz, variabila global\u0103 <code>suma</code> este actualizat\u0103 direct \u00een func\u021bie, permi\u021b\u00e2nd p\u0103strarea rezultatului \u0219i accesarea sa oriunde \u00een program.</p>","tags":["C++","functii","implementare","recursivitate"]},{"location":"cppintro/functions/#functii-iterative","title":"Func\u021bii iterative","text":"<p>O func\u021bie iterativ\u0103 execut\u0103 un set de instruc\u021biuni \u00een mod repetitiv, folosind structuri precum buclele, f\u0103r\u0103 a apela alte instan\u021be ale func\u021biei proprii. Func\u021biile prezentate p\u00e2n\u0103 acum sunt toate exemple de func\u021bii iterative.</p> <p>Exemplul urm\u0103tor prezint\u0103 o implementare iterativ\u0103 pentru calcularea sumei cifrelor unui num\u0103r \\(n\\):</p> <pre><code>int sum_cif(int numar) {\n    int suma = 0;\n\n    while (numar &gt; 0) {\n        suma += numar % 10;\n        numar /= 10;\n    }\n\n    return suma;\n}\n</code></pre> <p>\u00cen general, func\u021biile iterative tind s\u0103 fie mai rapide dec\u00e2t cele recursive \u0219i sunt de preferat atunci c\u00e2nd putem implementa un program folosind ambele metode.</p>","tags":["C++","functii","implementare","recursivitate"]},{"location":"cppintro/functions/#functii-recursive","title":"Func\u021bii recursive","text":"<p>Cuno\u0219tin\u021be necesare</p> <ul> <li>Func\u021bii recursive</li> </ul> <p>Spre deosebire de func\u021biile iterative, cele recursive se pot auto-apela \u0219i acest lucru poate fi foarte folositor atunci c\u00e2nd avem nevoie s\u0103 afl\u0103m r\u0103spunsul folosind o instan\u021b\u0103 mai simpl\u0103 a func\u021biei curente. Acest tip de func\u021bie utilizeaz\u0103 stiva de execu\u021bie a programului pentru a memora starea fiec\u0103rui apel, p\u00e2n\u0103 la rezolvarea cazurilor de baz\u0103.</p> <p>Cazurile de baz\u0103</p> <p>Pe l\u00e2ng\u0103 instruc\u021biunile obi\u0219nuite oric\u0103rei func\u021bii, o func\u021bie recursiv\u0103 are \u0219i unul sau mai multe cazuri de baz\u0103, care sunt obligatorii pentru a evita apelarea la infinit a aceleia\u0219i func\u021bii.</p> <p>Astfel, pentru fiecare apel al unei func\u021bii se adaug\u0103 pe stiv\u0103 o zon\u0103 de memorie \u00een care se memoreaz\u0103 variabilele locale \u0219i parametrii pentru apelul curent. Aceast\u0103 zon\u0103 a stivei va exista p\u00e2n\u0103 la finalul apelului, dup\u0103 care se va elibera. Dac\u0103 din apelul curent se face un alt apel, se adaug\u0103 pe stiv\u0103 o nou\u0103 zon\u0103 de memorie, iar con\u021binutul zonei anterioare este inaccesibil p\u00e2n\u0103 la finalul acelui apel. Aceste opera\u021bii se fac la fel \u0219i dac\u0103 al doilea apel este un auto-apel al unei func\u021bii recursive.</p> <p>Aici pute\u021bi vedea cum afl\u0103m \u00een mod recursiv valoarea lui \\(n!\\) folosind o func\u021bie recursiv\u0103.</p> <pre><code>int factorial(int n) {\n    // Cazul de baz\u0103\n    if (n &lt;= 1) {\n        return 1;\n    }\n\n    // Apel recursiv\n    return factorial(n - 1) * n;\n}\n</code></pre> <p>Se poate observa faptul c\u0103 ne folosim de defini\u021bia lui \\(n!\\), iar pentru a afla \\(n!\\), avem nevoie de \\((n-1)!\\) \u0219i a\u0219a mai departe. Dac\u0103 vrem s\u0103 calcul\u0103m valoarea lui \\(5!\\), aceasta se ob\u021bine \u00een felul urm\u0103tor (pentru brevitate, <code>factorial(n)</code> este \\(n!\\)):</p> <ul> <li>\\(5! = 4! \\cdot 5\\)</li> <li>\\(4! = 3! \\cdot 4\\)</li> <li>\\(3! = 2! \\cdot 3\\)</li> <li>\\(2! = 1! \\cdot 2\\)</li> <li>\\(1! = 1\\), caz de baz\u0103</li> </ul> <p>Pentru a calcula \\(n!\\), trebuie s\u0103 afl\u0103m toate factorialele p\u00e2n\u0103 la \\(1!\\), iar mai apoi folosim aceste rezultate invers pentru a primi r\u0103spunsul \u00een valoarea cerut\u0103.</p> <p>Acest mod de a scrie func\u021biile este foarte folosit \u00een multe tipuri de aplica\u021bii, cum ar fi metoda divide et impera, programarea dinamic\u0103, teoria grafurilor \u0219.a.m.d.</p>","tags":["C++","functii","implementare","recursivitate"]},{"location":"cppintro/functions/#exercitii-rezolvate","title":"Exerci\u021bii rezolvate","text":"<p>Adesea, \u00een variantele de examen pentru bacalaureat \u0219i admitere, \u00eent\u00e2lnim exerci\u021bii care necesit\u0103 evaluarea rezultatelor unor func\u021bii, iar majoritatea acestora sunt recursive.</p> <p>Pentru a evalua aceste func\u021bii, recomand\u0103m citirea codului cu aten\u021bie \u0219i notarea apelurilor de func\u021bie \u00een ordinea \u00een care apar, \u021bin\u00e2nd cont de locul \u00een func\u021bie unde apelurile urm\u0103toare au loc.</p>","tags":["C++","functii","implementare","recursivitate"]},{"location":"cppintro/functions/#exercitiu-bacalaureat-care-este-valoarea-lui-f38","title":"Exerci\u021biu bacalaureat - Care este valoarea lui \\(f(38)\\)?","text":"<pre><code>void f(int x) {\n    if (x) {\n        if (x % 3 == 0) {\n            cout &lt;&lt; 3;\n            f(x / 3);\n        } else {\n            f(x / 3);\n            cout &lt;&lt; x % 3;\n        }\n    }\n}\n</code></pre> <ul> <li>\\(f(38)\\) - \\(38 \\% 3 = 2\\), deci intr\u0103m \u00een else \u0219i apel\u0103m \\(f(12)\\).</li> <li>\\(f(12)\\) - \\(12 \\% 3 = 0\\), deci intr\u0103m \u00een if, afi\u0219\u0103m 3 \u0219i apel\u0103m \\(f(4)\\).</li> <li>\\(f(4)\\) - \\(4 \\% 3 = 1\\), deci intr\u0103m \u00een else \u0219i apel\u0103m \\(f(1)\\).</li> <li>\\(f(1)\\) - \\(1 \\% 3 = 1\\), deci intr\u0103m \u00een else \u0219i apel\u0103m \\(f(0)\\).</li> <li>\\(f(0)\\) - deoarece \\(x = 0\\), nu se face niciun apel suplimentar, iar func\u021bia se   \u00eentoarce.</li> <li>\\(f(1)\\) - dup\u0103 apelul lui \\(f(0)\\), afi\u0219\u0103m \\(1 \\% 3 = 1\\).</li> <li>\\(f(4)\\) - dup\u0103 apelul lui \\(f(1)\\), afi\u0219\u0103m \\(4 \\% 3 = 1\\).</li> <li>\\(f(12)\\) - dup\u0103 apelul lui \\(f(4)\\), secven\u021ba se termin\u0103.</li> <li>\\(f(38)\\) - dup\u0103 apelul lui \\(f(12)\\), afi\u0219\u0103m \\(38 \\% 3 = 2\\).</li> </ul> <p>Astfel, secven\u021ba final\u0103 afi\u0219at\u0103 va fi 3112.</p>","tags":["C++","functii","implementare","recursivitate"]},{"location":"cppintro/functions/#exercitiu-admitere-care-este-valoarea-lui-g2-1","title":"Exerci\u021biu admitere - Care este valoarea lui \\(g(2, 1)\\)?","text":"<pre><code>int g(int x, int y) {\n    if (x &gt; 0) {\n        if (y == 0) {\n            return g(x - 1, 1);\n        }\n        if (y &gt; 0) {\n            return g(x - 1, g(x, y - 1));\n        }\n    }\n    return y + 1;\n}\n</code></pre> <ul> <li>\\(g(2, 1)\\): \\(x &gt; 0\\), \\(y &gt; 0\\) \\(\\rightarrow\\) se va returna \\(g(1, g(2, 0))\\).</li> <li>\\(g(2, 0)\\): \\(x &gt; 0\\), \\(y = 0\\) \\(\\rightarrow\\) se va returna \\(g(1, 1)\\).</li> <li>\\(g(1, 1)\\): \\(x &gt; 0\\), \\(y &gt; 0\\) \\(\\rightarrow\\) se va returna \\(g(0, g(1, 0))\\).</li> <li>\\(g(1, 0)\\): \\(x &gt; 0\\), \\(y = 0\\) \\(\\rightarrow\\) se va returna \\(g(0, 1)\\).</li> <li>\\(g(0, 1)\\): \\(x = 0\\) \\(\\rightarrow\\) se va returna \\(1 + 1 = 2\\), deci \\(g(1, 0) =   2\\), deci \\(g(0, g(1, 0)) = g(0, 2)\\) .</li> <li>\\(g(0, 2)\\): \\(x = 0\\) \\(\\rightarrow\\) se va returna \\(2 + 1 = 3\\), deci \\(g(1, 1) =   g(2, 0) = 3\\).</li> <li>Astfel, \\(g(1, g(2, 0)) = g(1, 3)\\).</li> <li>\\(g(1, 3)\\): \\(x &gt; 0\\), \\(y &gt; 0\\) \\(\\rightarrow\\) se va returna \\(g(0, g(1, 2))\\).</li> <li>\\(g(1, 2)\\): \\(x &gt; 0\\), \\(y &gt; 0\\) \\(\\rightarrow\\) se va returna \\(g(0, g(1, 1))\\).</li> <li>Deja \u0219tim c\u0103 \\(g(1, 1) = 3\\), deci \\(g(0, 3) = g(1, 2) = 4\\). Astfel, \\(g(0, 4) =   g(1, 3) = 5\\).</li> </ul> <p>Cu alte cuvinte, valoarea lui \\(g(2, 1) = 5\\).</p> <p>Calculul func\u021biei</p> <p>Se poate observa c\u0103 pentru a calcula eficient \u0219i corect aceste valori, trebuie o gr\u0103mad\u0103 de aten\u021bie \u0219i mult exerci\u021biu \u00een contextul examenelor de admitere \u0219i bacalaureat, lucru ce \u00eel vom aborda \u00een detaliu \u00een capitolul specific acestor examene.</p>","tags":["C++","functii","implementare","recursivitate"]},{"location":"cppintro/functions/#problema-rezolvata-cifminrec-de-pe-pbinfo","title":"Problem\u0103 rezolvat\u0103 - cifminrec de pe pbinfo","text":"<p>Pentru a rezolva aceast\u0103 problem\u0103, se aplic\u0103 recursivitatea, iar algoritmul folose\u0219te faptul c\u0103 num\u0103rul \\(n\\) este format din num\u0103rul \\(\\frac{n}{10}\\) (f\u0103r\u0103 ultima cifr\u0103) \u0219i ultima cifr\u0103 \\(n~\\%~10\\). Acest principiu face implementarea recursiv\u0103 mult mai simpl\u0103.</p> <pre><code>int cifmin(int numar) {\n    if (numar &lt; 10) {\n        return numar;\n    }\n\n    int ultima_cifra = numar % 10;\n    int min_rest = cifmin(numar / 10);\n\n    if (ultima_cifra &lt; min_rest) {\n        return ultima_cifra;\n    } else {\n        return min_rest;\n    }\n}\n</code></pre>","tags":["C++","functii","implementare","recursivitate"]},{"location":"cppintro/functions/#alte-tipuri-de-functii","title":"Alte tipuri de func\u021bii","text":"","tags":["C++","functii","implementare","recursivitate"]},{"location":"cppintro/functions/#functii-cu-parametru-implicit","title":"Func\u021bii cu parametru implicit","text":"<p>Uneori, atunci c\u00e2nd scriem func\u021bii, avem parametri care primesc aceea\u0219i valoare implicit\u0103. Acesta este cazul func\u021biilor cu parametru implicit. Parametrii implici\u021bi se mai numesc \u0219i op\u021bionali, pentru c\u0103 nu este nevoie s\u0103-i scriem c\u00e2nd apel\u0103m func\u021bia.</p> <p>\u00cen C++, pentru a specifica un parametru implicit, acesta trebuie definit dup\u0103 parametrii obi\u0219nui\u021bi (sau \u201eobligatorii\u201d, dac\u0103 men\u021binem analogia). De exemplu:</p> <pre><code>// Gre\u0219it!\nint medie(int a = 0, int b) {\n    // ...\n}\n</code></pre> <pre><code>// Corect\nint medie(int b, int a = 0) {\n    // ...\n}\n</code></pre> <p>Motivul este urm\u0103torul: dac\u0103 am avea urm\u0103toarea func\u021bie:</p> <pre><code>int fun(int y = 1, int x, int k = 4);\n</code></pre> <p>atunci \u00een momentul \u00een care apel\u0103m <code>fun(10, 2)</code>, este ambiguu ce valoare ia <code>y</code>, <code>x</code> \u0219i <code>k</code>. \u00cen C++ nu putem scrie <code>fun(y=10, x=2)</code> ca \u00een Python, \u0219i nici nu avem o metod\u0103 s\u0103 omitem parametrii implici\u021bi (adic\u0103 nu putem scrie <code>fun(??, 10, 2)</code>).</p>","tags":["C++","functii","implementare","recursivitate"]},{"location":"cppintro/functions/#problema-div3-de-pe-pbinfo","title":"Problema div3 de pe pbinfo","text":"<p>Pentru a explica aceast\u0103 no\u021biune, am folosit o func\u021bie care preia suma cifrelor drept parametru implicit \u0219i afl\u0103 recursiv suma cifrelor unui num\u0103r, folosind parametrul implicit care trebuie men\u021bionat acum.</p> <p>Se remarc\u0103 faptul c\u0103 atunci c\u00e2nd apel\u0103m aceast\u0103 func\u021bie din main, men\u021bionarea valorii parametrului \\(s\\) nu este necesar\u0103.</p> <pre><code>#include &lt;fstream&gt;\nusing namespace std;\n\nint suma_cifre(int numar, int suma = 0) {\n    if (numar == 0) {\n        return suma;\n    }\n\n    return suma_cifre(numar / 10, suma + numar % 10);\n}\n\nint main() {\n    ifstream fin(\"div3.in\");\n    ofstream fout(\"div3.out\");\n\n    int n;\n    fin &gt;&gt; n;\n\n    for (int i = 0; i &lt; n; i++) {\n        int numar;\n        fin &gt;&gt; numar;\n\n        if (suma_cifre(numar) % 3 == 0) {\n            fout &lt;&lt; numar &lt;&lt; \" \";\n        }\n    }\n    return 0;\n}\n</code></pre>","tags":["C++","functii","implementare","recursivitate"]},{"location":"cppintro/functions/#optional-functiile-lambda","title":"(Op\u021bional) Func\u021biile lambda","text":"<p>Func\u021biile lambda</p> <p>Cunoa\u0219terea acestora este op\u021bional\u0103 \u00een contextul examenelor de bacalaureat \u0219i admitere, dar se recomand\u0103 \u00een\u021belegerea lor \u00een contextul claselor mai mari la olimpiad\u0103. Totu\u0219i, acestea nu reprezint\u0103 un element care trebuie obligatoriu \u00eenv\u0103\u021bat.</p> <p>Versiunile mai recente ale limbajului C++ permit utilizatorilor folosirea unor func\u021bii pe stilul celor din limbajele func\u021bionale. Acestea se numesc func\u021bii lambda.</p> <p>Vezi pagina dedicat\u0103 func\u021biilor lambda.</p>","tags":["C++","functii","implementare","recursivitate"]},{"location":"cppintro/functions/#concluzii","title":"Concluzii","text":"<p>Func\u021biile scrise de utilizator sunt unul din cele mai importante unelte pe care le poate folosi un programator, fiind concepute pentru a fi u\u0219or de folosit \u0219i reutilizabile, astfel \u00eenc\u00e2t ne permit simplificarea semnificativ\u0103 a programelor scrise.</p>","tags":["C++","functii","implementare","recursivitate"]},{"location":"cppintro/functions/#probleme-suplimentare","title":"Probleme suplimentare","text":"<ul> <li>sumciff pbinfo</li> <li>oglindit2 pbinfo</li> <li>celmaimicnr pbinfo</li> <li>zerof pbinfo</li> <li>sumciff pbinfo</li> <li>factorialrec pbinfo</li> <li>cmmdcrec pbinfo</li> <li>Manna - Pnueli pbinfo</li> <li>c\u00e2t mai multe probleme din acest capitol pentru subprograme   iterative</li> <li>c\u00e2t mai multe probleme din acest capitol pentru subprograme   recursive</li> </ul>","tags":["C++","functii","implementare","recursivitate"]},{"location":"cppintro/functions/#resurse-suplimentare","title":"Resurse suplimentare","text":"<ul> <li>Subprograme - pbinfo</li> <li>Recursivitate - pbinfo</li> <li>Subprograme - CPPI   Sync</li> <li>Recursivitate - CPPI   Sync</li> <li>Recursivitate cu mai multe autoapeluri - CPPI   Sync</li> <li>Material subprograme - CNI Tudor   Vianu</li> <li>Functii in C/C++ -   Algopedia</li> <li>Functions -   w3schools</li> </ul>","tags":["C++","functii","implementare","recursivitate"]},{"location":"cppintro/input-output/","title":"Citirea \u0219i afi\u0219area datelor","text":"<p>\u00cen acest articol, vom explora metodele de citire \u0219i afi\u0219are a datelor \u00een limbajul C++.</p>","tags":["C++","introducere","citire","afisare"]},{"location":"cppintro/input-output/#tipurile-de-citire-si-afisare","title":"Tipurile de citire \u0219i afi\u0219are","text":"<p>Datele pot fi preluate \u0219i afi\u0219ate fie prin intrarea \u0219i ie\u0219irea standard (folosind terminalul \u2013 \u201ede la tastatur\u0103\u201d \u0219i \u201epe ecran\u201d), fie din fi\u0219iere externe, unde citirea se face dintr-un fi\u0219ier \u0219i afi\u0219area \u00eentr-un alt fi\u0219ier.</p> <p>Aceste metode pot fi utilizate \u00eempreun\u0103 \u00eentr-un mod hibrid, fiind foarte frecvent utilizate \u00een diverse probleme de programare \u00een care se citesc date dintr-un fi\u0219ier \u0219i se afi\u0219eaz\u0103 pe ecran.</p>","tags":["C++","introducere","citire","afisare"]},{"location":"cppintro/input-output/#intrarea-si-iesirea-standard","title":"Intrarea \u0219i ie\u0219irea standard","text":"<p>Pentru a folosi intrarea \u0219i ie\u0219irea standard (a citi \"de la tastatur\u0103\", respectiv a afi\u0219a \"pe ecran\"), vom avea nevoie de biblioteca <code>&lt;iostream&gt;</code>.</p> <p>Citirea datelor se face folosind <code>std::cin</code> \u0219i operatorul <code>&gt;&gt;</code>, iar afi\u0219area datelor se face folosind <code>std::cout</code> \u0219i operatorul <code>&lt;&lt;</code>, c\u00e2teva exemple fiind reg\u0103site mai jos.</p> <p>Observa\u021bie</p> <p>De\u0219i exist\u0103 \u0219i metode de citire \u0219i afi\u0219are din C (cum ar fi func\u021biile <code>scanf</code> \u0219i <code>printf</code>), utilizarea metodelor din C++ este mult mai intuitiv\u0103 \u0219i simpl\u0103.</p> <p>Dup\u0103 ce compila\u021bi programul \u0219i nu apar erori, va trebui s\u0103 rula\u021bi executabilul \u0219i s\u0103 introduce\u021bi datele de intrare conform descrierii problemei. Dac\u0103 totul este corect, ve\u021bi ob\u021bine rezultatul a\u0219teptat.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    // Declaram variabilele\n    int n, a, b;\n\n    // Citim o singur\u0103 valoare\n    cin &gt;&gt; n;\n\n    // Citim dou\u0103 valori separate prin spa\u021biu\n    cin &gt;&gt; a &gt;&gt; b;\n\n    /* Alternativ, putem s\u0103 citim toate cele 3 variabile pe acela\u0219i r\u00e2nd:\n    cin &gt;&gt; n &gt;&gt; a &gt;&gt; b;\n    */\n\n    // Afi\u0219\u0103m o singur\u0103 valoare\n    cout &lt;&lt; n;\n\n    // Afi\u0219\u0103m dou\u0103 valori separate prin spa\u021biu, urmate de o linie nou\u0103\n    cout &lt;&lt; a &lt;&lt; \" \" &lt;&lt; b &lt;&lt; '\\n';\n\n    // Afi\u0219\u0103m din nou n, urmat de o linie nou\u0103\n    cout &lt;&lt; n &lt;&lt; endl;\n\n    return 0;\n}\n</code></pre> <p>Dac\u0103 \\(n = 9\\), \\(a = 11\\) \u0219i \\(b = 14\\), programul va afi\u0219a urm\u0103toarele date:</p> <pre><code>911 14\n9\n</code></pre> <p><code>endl</code> vs <code>'\\n'</code></p> <p>A\u021bi observat probabil c\u0103 pentru a introduce o linie nou\u0103, am folosit at\u00e2t <code>'\\n'</code> c\u00e2t \u0219i <code>endl</code>. De\u0219i par a fi echivalente, exist\u0103 diferen\u021be semnificative. Instruc\u021biunea <code>endl</code> nu doar c\u0103 introduce o linie nou\u0103, dar \u0219i cur\u0103\u021b\u0103 buffer-ul (unde sunt stocate temporar datele afi\u0219ate), ceea ce o face mai lent\u0103 dec\u00e2t <code>'\\n'</code>. Acest lucru devine important atunci c\u00e2nd lucr\u0103m cu un volum mare de date.</p>","tags":["C++","introducere","citire","afisare"]},{"location":"cppintro/input-output/#citirea-si-afisarea-folosind-fisiere","title":"Citirea \u0219i afi\u0219area folosind fi\u0219iere","text":"<p>Pentru a citi \u0219i afi\u0219a din fi\u0219iere, vom avea nevoie de biblioteca <code>&lt;fstream&gt;</code>.</p> <p>Mai \u00eent\u00e2i, trebuie s\u0103 specific\u0103m programului de unde s\u0103 preia datele \u0219i de unde s\u0103 le afi\u0219eze. Tipul <code>ifstream</code> declar\u0103 un flux de citire din fi\u0219ier, <code>ofstream</code> declar\u0103 unul de scriere \u00een fi\u0219ier.</p> <pre><code>ifstream fin(\"date.in\");\nofstream fout(\"date.out\");\n</code></pre> <p>Numele fi\u0219ierelor</p> <p>De\u0219i aici am folosit <code>fin</code> \u0219i <code>fout</code> pentru a putea men\u021biona aceste fluxuri (stream-uri) de date, putem folosi orice nume vrem at\u00e2ta timp c\u00e2t nu avem \u0219i alte variabile numite astfel. \u00cen mod particular, putem numi acestea chiar \u0219i <code>cin</code>, respectiv <code>cout</code> at\u00e2ta timp c\u00e2t nu avem inclus\u0103 biblioteca <code>&lt;iostream&gt;</code>.</p> <p>Programul de mai sus va fi identic, singura diferen\u021b\u0103 fiind ad\u0103ugarea facilit\u0103\u021bilor care ne permit s\u0103 citim datele din fi\u0219iere.</p> <pre><code>#include &lt;fstream&gt;\nusing namespace std;\n\nifstream fin(\"date.in\");\nofstream fout(\"date.out\");\n\nint main() {\n    // Declaram variabilele\n    int n, a, b;\n\n    // Citim o singur\u0103 valoare\n    fin &gt;&gt; n;\n\n    // Citim dou\u0103 valori separate prin spa\u021biu\n    fin &gt;&gt; a &gt;&gt; b;\n\n    /* Alternativ, putem s\u0103 citim toate cele 3 variabile pe acela\u0219i r\u00e2nd:\n    fin &gt;&gt; n &gt;&gt; a &gt;&gt; b;\n    */\n\n    // Afi\u0219\u0103m o singur\u0103 valoare\n    fout &lt;&lt; n;\n\n    // Afi\u0219\u0103m dou\u0103 valori separate prin spa\u021biu, urmate de o linie nou\u0103\n    fout &lt;&lt; a &lt;&lt; \" \" &lt;&lt; b &lt;&lt; '\\n';\n\n    // Afi\u0219\u0103m din nou n, urmat de o linie nou\u0103\n    fout &lt;&lt; n &lt;&lt; endl;\n\n    return 0;\n}\n</code></pre> <p>Citirea unui num\u0103r necunoscut de valori</p> <p>Dac\u0103 avem de citit un num\u0103r necunoscut de valori, trebuie s\u0103 folosim structura repetitiv\u0103 <code>while</code>, a\u0219a cum ve\u021bi observa \u00een articolul nostru pe aceast\u0103 tem\u0103.</p>","tags":["C++","introducere","citire","afisare"]},{"location":"cppintro/input-output/#afisarea-specializata","title":"Afi\u0219area specializat\u0103","text":"<p>\u00cen unele probleme, suntem nevoi\u021bi s\u0103 afi\u0219\u0103m datele respect\u00e2nd un oarecare format (de exemplu, s\u0103 se afi\u0219eze cu exact \\(x\\) zecimale). Pentru a opera acest lucru, este necesar\u0103 cunoa\u0219terea bibliotecii <code>&lt;iomanip&gt;</code>.</p> <p>Aceast\u0103 bibliotec\u0103 poate fi folosit\u0103 \u0219i pentru a prelucra datele \u00eentr-o manier\u0103 mai prietenoas\u0103 cu cititorii, folosind func\u021biile de lungime, aliniere sau umplere:</p> <ul> <li>lungimea: <code>setw(int n)</code>, num\u0103rul de caractere folosit pentru afi\u0219area   datelor;</li> <li>alinierea: <code>left</code>, <code>right</code>, <code>internal</code>;</li> <li>caracterul de umplere: <code>setfill(char f)</code>, caracterele care s\u0103 fie   folosite pentru a umple un element afi\u0219at;</li> <li>baza de numera\u021bie (<code>dec</code>, <code>oct</code>, <code>hex</code>) \u00een care sunt scrise   valorile de tip \u00eentreg. \u00cen cele mai multe cazuri, nu vom avea nevoie s\u0103 afi\u0219\u0103m   altfel dec\u00e2t \u00een formatul zecimal.</li> </ul> <p>Ne vom concentra \u00een cele ce urmeaz\u0103 pe func\u021bia <code>setprecision</code>, fiind de departe cea mai relevant\u0103 func\u021bie dintre cele pe care le folosim \u00een algoritmic\u0103.</p> <p>Sintaxa ei este <code>setprecision(int n)</code>, unde \\(n\\) este num\u0103rul de cifre folosite pentru afi\u0219area valorilor reale; \u00een func\u021bie de context, poate reprezenta num\u0103rul total de cifre sau num\u0103rul de cifre de dup\u0103 punctul zecimal.</p> <p>De exemplu, dac\u0103 vrem s\u0103 afi\u0219\u0103m primele 7 zecimale ale lui \\(\\pi\\), putem face asta folosind urm\u0103toarele instruc\u021biuni:</p> <pre><code>#include &lt;cmath&gt;\n#include &lt;iomanip&gt;\n#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    double pi = atan(1) * 4;  // pi in functie de arctg\n                              // arctg(1) = \u03c0/4\n\n    cout &lt;&lt; setprecision(7) &lt;&lt; pi &lt;&lt; '\\n';           // 3.141593\n    cout &lt;&lt; setprecision(7) &lt;&lt; 10 * pi &lt;&lt; '\\n';      // 31.41593\n    cout &lt;&lt; fixed &lt;&lt; setprecision(7) &lt;&lt; pi &lt;&lt; '\\n';  // 3.1415927\n    cout &lt;&lt; setprecision(7) &lt;&lt; pi * 10 &lt;&lt; '\\n';      // 31.4159265\n    return 0;\n}\n</code></pre> <p>Observa\u021bie</p> <p>F\u0103r\u0103 manipulatorul <code>fixed</code>, <code>setprecision</code> controleaz\u0103 num\u0103rul total de cifre. Dup\u0103 aplicarea lui <code>fixed</code>, controleaz\u0103 doar num\u0103rul de zecimale afi\u015fate.</p>","tags":["C++","introducere","citire","afisare"]},{"location":"cppintro/input-output/#concluzii","title":"Concluzii","text":"<p>Aceste concepte v\u0103 permit s\u0103 citi\u021bi \u0219i s\u0103 afi\u0219a\u021bi eficient date \u00een aplica\u021biile voastre. Citirea din fi\u0219iere \u0219i formatarea precis\u0103 a valorilor sunt esen\u021biale \u00een multe aplica\u021bii algoritmice.</p>","tags":["C++","introducere","citire","afisare"]},{"location":"cppintro/input-output/#resurse-suplimentare","title":"Resurse suplimentare","text":"<ul> <li>Intr\u0103ri/Ie\u0219iri \u00een   C++</li> <li>Opera\u021bii de intrare/ie\u0219ire cu fi\u0219iere \u00een   C++</li> <li>Citiri \u0219i scrieri cu format \u00een   C++</li> <li>Learning to code - USACO   Guide</li> </ul>","tags":["C++","introducere","citire","afisare"]},{"location":"cppintro/intro/","title":"Primul program \u00een C++","text":"<p>Observa\u021bie</p> <p>Dac\u0103 nu \u021bi-ai instalat un compilator sau un editor, te invit\u0103m s\u0103 accesezi mai \u00eent\u00e2i acest articol pentru a putea \u00eencepe s\u0103 scrii cod corect  \u0219i eficient.</p> <p>\u00cen continuare, vom explora c\u00e2teva aspecte introductive ale limbajului de programare C++ (sintaxa, compilarea, structura de baz\u0103 a unui program), \u00eenso\u021bite de un exemplu simplu de program.</p>","tags":["C++","introducere"]},{"location":"cppintro/intro/#ce-este-un-limbaj-de-programare","title":"Ce este un limbaj de programare?","text":"<p>Limbajele de programare reprezint\u0103 un sistem de nota\u021bii pe care le folosim pentru a scrie programe destinate calculatoarelor. Aceste limbaje permit oamenilor s\u0103 comunice cu calculatoarele \u00eentr-o manier\u0103 asem\u0103n\u0103toare cu limbajul uman.</p> <p>Exist\u0103 multe limbaje de programare, care pot fi \u00eemp\u0103r\u021bite \u00een categorii, \u00een func\u021bie de modul \u00een care le utiliz\u0103m \u0219i cum interac\u021bioneaz\u0103 cu procesorul sau alte criterii.</p> <p>Unul dintre cele mai populare moduri de a \u00eemp\u0103r\u021bi limbajele de programare este \u00een func\u021bie de cum interac\u021bioneaz\u0103 cu procesorul. De exemplu, unele limbaje necesit\u0103 un compilator care s\u0103 genereze cod executabil ce poate fi rulat de procesor (ex: C, C++, Pascal), iar altele se folosesc cu un interpret care execut\u0103 codul linie cu linie (ex: Python, JavaScript).</p> <p>O alt\u0103 metod\u0103 de a clasifica limbajele de programare este \u00een func\u021bie de modul principal \u00een care oper\u0103m cu ele, put\u00e2nd vorbi astfel de limbaje imperative, func\u021bionale, logice \u0219i orientate pe obiecte.</p> <p>Limbajele de programare pot fi, de asemenea, clasificate \u00een func\u021bie de modul principal \u00een care sunt folosite:</p> <ul> <li>Limbaje imperative: Definirea unui algoritm pas cu pas, \u00een care fiecare   comand\u0103 execut\u0103 o ac\u021biune specific\u0103 (ex: C, Pascal).</li> <li>Limbaje func\u021bionale: Se concentreaz\u0103 pe aplicarea unor func\u021bii asupra   datelor, evit\u00e2nd modificarea lor direct\u0103 (ex: Haskell, Lisp).</li> <li>Limbaje logice: Bazate pe reguli \u0219i logica propozi\u021bional\u0103, unde sistemul   decide ordinea de execu\u021bie (ex: Prolog).</li> <li>Limbaje orientate pe obiecte: Permite structurarea codului \u00een clase ce   con\u021bin date \u0219i func\u021bii pentru a opera pe aceste date (ex: Java, Python).</li> </ul> <p>Unele limbaje combin\u0103 aceste paradigme, devenind limbaje multiparadigm\u0103. De exemplu, C++ combin\u0103 paradigma imperativ\u0103 cu programarea orientat\u0103 pe obiecte, iar Python este un limbaj orientat pe obiecte, dar permite \u0219i programarea imperativ\u0103 \u0219i func\u021bional\u0103.</p> <p>Observa\u021bie</p> <p>Pe parcursul studiului informaticii, fie c\u0103 ve\u021bi studia doar la liceu sau ve\u021bi ajunge s\u0103 ave\u021bi o carier\u0103, mai lung\u0103 sau mai scurt\u0103 \u00een domeniu, ve\u021bi avea de-a face cu foarte multe limbaje de programare, iar de\u0219i arhiva noastr\u0103 se concentreaz\u0103 pe limbajul C++ datorit\u0103 avantajelor sale \u00een ceea ce prive\u0219te algoritmica, nu exist\u0103 vreun limbaj de programare care s\u0103 fie \u00een totalitate inutil.</p>","tags":["C++","introducere"]},{"location":"cppintro/intro/#limbajul-de-programare-c","title":"Limbajul de programare C++","text":"<p>Articolele din aceast\u0103 arhiv\u0103 se vor axa pe limbajul C++, iar acest articol va introduce cititorii \u00een elementele de baz\u0103 ale acestui limbaj.</p> <p>Limbajul C++ a fost creat de Bjarne Stroustrup \u00een 1979 ca o extindere a limbajului C, care fusese dezvoltat \u00eentre 1969 \u0219i 1973 de Dennis Ritchie pentru a crea sistemul de operare Unix. Astfel, aproape orice program scris \u00een C poate fi compilat \u0219i \u00een C++, de obicei cu modific\u0103ri minime.</p>","tags":["C++","introducere"]},{"location":"cppintro/intro/#primul-program-in-c","title":"Primul program \u00een C++","text":"<p>\u00cen continuare, vom scrie un program simplu care calculeaz\u0103 \u0219i afi\u0219eaz\u0103 valorile generate de conjectura lui Collatz, prelu\u00e2nd un num\u0103r natural de la tastatur\u0103.</p> <p>Observa\u021bie</p> <p>Scopul acestui articol este acela de a v\u0103 ajuta s\u0103 fi\u021bi capabili s\u0103 \u00een\u021belege\u021bi \u0219i s\u0103 reproduce\u021bi programe similare folosind cuno\u0219tin\u021bele pe care le ve\u021bi acumula mai jos.</p> <p>Comentarii</p> <p>Pentru a explica diverse p\u0103r\u021bi din cod, vom folosi de-a lungul arhivei comentariile, acestea fiind o instruc\u021biune din limbajul C++. Pentru a pune un comentariu pe un singur r\u00e2nd, vom folosi <code>//</code>, iar pentru a comenta mai multe r\u00e2nduri, vom folosi perechea <code>/* */</code>.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int n;\n    cin &gt;&gt; n;\n\n    while (n &gt; 1) {\n        cout &lt;&lt; n &lt;&lt; \" \";\n        if (n % 2 == 0) {\n            n = n / 2;\n        } else {\n            n = n * 3 + 1;\n        }\n    }\n\n    cout &lt;&lt; n &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["C++","introducere"]},{"location":"cppintro/intro/#elemente-de-baza-ale-sintaxei-c","title":"Elemente de baz\u0103 ale sintaxei C++","text":"<p>Dup\u0103 cum observi, majoritatea liniilor de cod din acest program se \u00eencheie cu un semn de punctua\u021bie \u201e;\u201d (punct \u0219i virgul\u0103). Acesta semnaleaz\u0103 finalul instruc\u021biunii respective. Excep\u021bie fac liniile \u00een care declar\u0103m biblioteci, func\u021bii, structuri alternative \u0219i repetitive.</p> <p>De asemenea, folosim acolade pentru a grupa blocuri de cod. Acestea ajut\u0103 la \u00eembun\u0103t\u0103\u021birea lizibilit\u0103\u021bii programului \u0219i sunt necesare pentru a marca instruc\u021biunile subordonate structurilor alternative (de ex., <code>if</code>) \u0219i repetitive (de ex., <code>while</code>).</p> <p>Un alt element foarte important care, de\u0219i nu e obligatoriu, este foarte util \u0219i face scrierea codurilor mult mai u\u0219oar\u0103, reprezint\u0103 spa\u021bierea instruc\u021biunilor. Chiar dac\u0103 vom intra ulterior \u00een detaliu \u00een ceea ce prive\u0219te coding style-ul, acesta este un element de baz\u0103 pentru a scrie coduri c\u00e2t mai de calitate, obicei care dac\u0103 \u00eel deprinde\u021bi de la \u00eenceput, v\u0103 va fi mult mai u\u0219or s\u0103 \u00eel adapta\u021bi oric\u0103rui limbaj de programare pe care \u00eel ve\u021bi folosi.</p>","tags":["C++","introducere"]},{"location":"cppintro/intro/#compilarea-programului","title":"Compilarea programului","text":"<p>Dup\u0103 finalizarea scrierii codului, compilatorul va verifica corectitudinea sintactic\u0103. Dac\u0103 exist\u0103 erori, editorul \u00ee\u021bi va indica exact unde se afl\u0103 gre\u0219elile.</p> <p>Atunci c\u00e2nd programul este corect, compilatorul va genera un fi\u0219ier obiect (.o), pe care \u00eel po\u021bi utiliza pentru a crea un executabil (*.exe). Dup\u0103 rularea acestuia, programul va prelua datele de la tastatur\u0103, va efectua calculele \u0219i va afi\u0219a rezultatele.</p> <p>Observa\u021bie</p> <p>Pentru a vedea modific\u0103rile la r\u0103spunsurile generate, trebuie s\u0103 compila\u021bi \u0219i s\u0103 rula\u021bi din nou executabilul, \u00een caz contrar datele vor fi afi\u0219ate conform cu versiunea anterioar\u0103 a programului. Pare a fi o observa\u021bie banal\u0103, \u00eens\u0103 este o gre\u0219eal\u0103 comun\u0103 s\u0103 ui\u021bi s\u0103 recompilezi codul surs\u0103.</p>","tags":["C++","introducere"]},{"location":"cppintro/intro/#initializarea-programului","title":"Ini\u021bializarea programului","text":"<p>Primul element pe care \u00eel \u00eent\u00e2lnim este linia <code>#include &lt;iostream&gt;</code>, care import\u0103 o bibliotec\u0103. Aceste biblioteci sunt colec\u021bii de func\u021bii \u0219i clase ce ne permit s\u0103 reutiliz\u0103m cod deja scris, f\u0103r\u0103 a-l regenera. Un echivalent \u00een via\u021ba de zi reprezint\u0103 utilizarea unei c\u0103r\u021bi de re\u021bete pentru prepararea unui fel de m\u00e2ncare, astfel noi putem folosi acele metode f\u0103r\u0103 a fi nevoie s\u0103 le reinvent\u0103m.</p> <p>Observa\u021bie</p> <p>Exist\u0103 \u0219i biblioteca <code>&lt;bits/stdc++.h&gt;</code>, care include toate bibliotecile necesare \u00een programul t\u0103u. De\u0219i aceast\u0103 abordare este recomandat\u0103 doar la competi\u021bii de algoritmic\u0103 (de exemplu, olimpiade), exist\u0103 dezavantaje precum un timp mai mare de compilare.</p> <p>Urm\u0103toarea linie, <code>using namespace std;</code> ne permite s\u0103 folosim direct toate elementele din spa\u021biul de nume standard (standard namespace). Un namespace (spa\u021biu de nume) este un mecanism de organizare a codului, care face posibil\u0103 gruparea func\u021biilor, variabilelor, claselor \u0219i altor identificatori sub un nume comun. Aceasta ajut\u0103 la evitarea conflictelor \u00eentre nume, mai ales atunci c\u00e2nd se folosesc biblioteci multiple care ar putea s\u0103 defineasc\u0103 acelea\u0219i identificatori.</p> <p>Observa\u021bie</p> <p>Aproape toate programele scrise \u00een limbajul C++ vor avea aceste dou\u0103 linii, eventual \u00eempreun\u0103 cu alte biblioteci \u0219i namespace-uri, detalii pe care le vom l\u0103sa ulterior pe m\u0103sur\u0103 ce v\u0103 ve\u021bi obi\u0219nui mai bine cu limbajul \u00een sine.</p>","tags":["C++","introducere"]},{"location":"cppintro/intro/#functia-main","title":"Func\u021bia <code>main()</code>","text":"<p>Func\u021bia <code>int main()</code> este esen\u021bial\u0103 \u00een orice program C++, fiind prima func\u021bie apelat\u0103 de compilator.</p> <p>Ea este cea \u00een care vom scrie toate instruc\u021biunile, inclusiv a\u0219a cum ve\u021bi vedea \u00eentr-un articol ulterior, cele care vor fi folosite pentru a apela func\u021bii auxiliare.</p> <p>De asemenea, aici vom avea toate instruc\u021biunile \u0219i structurile de care avem nevoie pentru a citi \u0219i afi\u0219a datele, prelucrarea lor, precum \u0219i multe alte facilit\u0103\u021bi specifice, precum manipularea lor folosind structuri logice, alternative \u0219i repetitive.</p>","tags":["C++","introducere"]},{"location":"cppintro/intro/#concluzie","title":"Concluzie","text":"<p>Pe parcursul studiilor, prin scrierea mai multor programe, vei deveni mai familiarizat cu aceste concepte \u0219i vei putea s\u0103 le folose\u0219ti corect \u0219i eficient. Vom explora detalii suplimentare despre C++ \u0219i bunele practici de scriere a codului \u00een articolele viitoare.</p>","tags":["C++","introducere"]},{"location":"cppintro/intro/#resurse-suplimentare","title":"Resurse suplimentare","text":"<ul> <li>Sectiunile Elemente de baz\u0103 ale limbajului C++ si Structuri de control de pe   pbinfo</li> <li>Linkurile de pe w3schools</li> <li>Learning to code - USACO   Guide</li> </ul>","tags":["C++","introducere"]},{"location":"cppintro/intro/#probleme-suplimentare","title":"Probleme suplimentare","text":"<ul> <li>Probleme usoare si medii din capitolul Operatori \u0219i   expresii</li> </ul>","tags":["C++","introducere"]},{"location":"cppintro/lambda/","title":"Func\u021bii Lambda","text":"","tags":["C++","functii","lambda"]},{"location":"cppintro/lambda/#un-ghid-pentru-incepatori-despre-functii-lambda-in-c","title":"Un ghid pentru \u00eencep\u0103tori despre func\u021bii lambda \u00een C++","text":"<p>Func\u021biile lambda au fost introduse \u00een C++ odat\u0103 cu C++11 \u0219i au devenit rapid una dintre cele mai puternice caracteristici ale limbajului. Ele fac codul mai expresiv, concis \u0219i, adesea, mai u\u0219or de citit. Dar dac\u0103 e\u0219ti nou \u00een C++ sau chiar un programator experimentat care abia acum exploreaz\u0103 aceste instrumente utile, ele pot p\u0103rea pu\u021bin intimidante la \u00eenceput. \u00cen aceast\u0103 postare, vom analiza ce sunt func\u021biile lambda, cum s\u0103 le folose\u0219ti \u0219i c\u00e2nd pot fi utile.</p>","tags":["C++","functii","lambda"]},{"location":"cppintro/lambda/#ce-este-o-functie-lambda","title":"Ce este o func\u021bie lambda?","text":"<p>O func\u021bie lambda este, \u00een esen\u021b\u0103, o func\u021bie anonim\u0103 - o func\u021bie f\u0103r\u0103 nume - pe care o po\u021bi defini \u00een linie, adesea \u00een punctul \u00een care este utilizat\u0103. Ele sunt deosebit de utile pentru fragmente scurte de cod care sunt pu\u021bin probabil s\u0103 fie reutilizate, cum ar fi comparatoare personalizate \u00een sortare sau callback-uri.</p>","tags":["C++","functii","lambda"]},{"location":"cppintro/lambda/#sintaxa-unei-functii-lambda","title":"Sintaxa unei func\u021bii lambda","text":"<p>Sintaxa de baz\u0103 a unei func\u021bii lambda \u00een C++ arat\u0103 astfel:</p> <pre><code>[/*capture*/](/*params*/) -&gt; /*return type*/ {\n    /*function body*/\n}\n</code></pre> <p>Dac\u0103 dorim s\u0103 d\u0103m un nume unei lambda, atunci putem ad\u0103uga \u00een fa\u021b\u0103 <code>auto nume = /*lambda*/;</code>. Aceast\u0103 sintax\u0103 poate p\u0103rea ciudat\u0103, a\u0219a c\u0103 hai s\u0103 o descompunem \u00een buc\u0103\u021bi pentru a explica p\u0103r\u021bile diferite \u00een compara\u021bie cu o func\u021bie normal\u0103.</p>","tags":["C++","functii","lambda"]},{"location":"cppintro/lambda/#captura-capture","title":"Captura (capture)","text":"<p>Captura permite copierea sau modificarea unor valori. Exist\u0103 mai multe variante de a defini captura, fiecare cu scop specific.</p> <ul> <li> <p><code>[x]</code> copiaz\u0103 valoarea ca <code>const</code>:</p> <pre><code>int main() {\n    int x = 15;\n    auto add = [x](int cnt) -&gt; int { return x + cnt; };\n    std::cout &lt;&lt; add(10);  // 25\n}\n</code></pre> <p>Dac\u0103 \u00eencerc\u0103m s\u0103 compil\u0103m varianta de mai sus, aceasta va func\u021biona corect, \u00eens\u0103 varianta de mai jos nu va func\u021biona.</p> <pre><code>int main() {\n    int x = 15;\n    auto add = [x](int cnt) -&gt; void {\n        x += cnt;\n        // nu va merge pentru c\u0103 valoarea este constant\u0103\n    };\n    std::cout &lt;&lt; x;\n}\n</code></pre> </li> <li> <p><code>[&amp;x]</code> face referin\u021b\u0103 la valoarea ini\u021bial\u0103, permi\u021b\u00e2nd s\u0103 fie modificat\u0103 :</p> <pre><code>int main() {\n    int x = 15;\n    auto add = [&amp;x](int cnt) -&gt; void { x += cnt; };\n    add(10);\n    std::cout &lt;&lt; x;  // 25\n}\n</code></pre> </li> <li> <p><code>[=]</code> copiaz\u0103 toate valorile, similar cu <code>[x]</code>:</p> <pre><code>int main() {\n    int x = 15;\n    auto add = [=](int cnt) -&gt; int { return x + cnt; };\n    std::cout &lt;&lt; add(10);  // 25\n}\n</code></pre> </li> <li> <p><code>[&amp;]</code> face referin\u021b\u0103 la toate valorile, similar cu <code>[&amp;x]</code>:</p> <pre><code>int main() {\n    int x = 15;\n    auto add = [&amp;](int cnt) -&gt; void { x += cnt; };\n    add(10);\n    std::cout &lt;&lt; x;  // 25\n}\n</code></pre> <p>Putem defini \u0219i mai multe valori care s\u0103 fie capturate:</p> <pre><code>int main() {\n    int x = 10, y = 15;\n    // x poate fi modificat, y e constant\n    auto add = [&amp;x, y]() { \n        x += y;\n    };\n\n    add();\n    std::cout &lt;&lt; x; // 25\n}\n</code></pre> </li> </ul>","tags":["C++","functii","lambda"]},{"location":"cppintro/lambda/#mutable","title":"<code>mutable</code>","text":"<p>Exist\u0103 o situa\u021bie \u00een care nici o variant\u0103 de captur\u0103 nu acoper\u0103 ce dorim, \u0219i anume atunci c\u00e2nd vrem s\u0103 modific\u0103m valoarea f\u0103r\u0103 a o afecta pe cea ini\u021bial\u0103. \u00cen aceast\u0103 situa\u021bie exist\u0103 <code>mutable</code>.</p> <pre><code>int main() {\n    int x = 15;\n    auto add = [=](int cnt) -&gt; int mutable {\n        x += 10;\n        std::cout &lt;&lt; x;  // 25\n        return x;\n    };\n\n    int y = add(10);\n    std::cout &lt;&lt; x &lt;&lt; ' ' &lt;&lt; y;  // 15 25\n\n    // Observ\u0103m c\u0103 x r\u0103m\u00e2ne valoarea ini\u021bial\u0103 \u00een\n    // afara func\u021biei, dar e diferit\u0103 \u00een func\u021bie\n}\n</code></pre>","tags":["C++","functii","lambda"]},{"location":"cppintro/lambda/#tipul-de-retur","title":"Tipul de retur","text":"<p>O func\u021bie lambda trebuie s\u0103 defineasc\u0103 tipul de retur, similar cu o func\u021bie normal\u0103. Acesta este definit prin a ad\u0103uga <code>-&gt; tip</code> dup\u0103 parametri.</p> <pre><code>int main() {\n    auto gauss = [](int n) -&gt; int { return n * (n + 1) / 2; };\n\n    std::cout &lt;&lt; gauss(10);  // 55\n}\n</code></pre> <p>Totu\u0219i, func\u021biile lambda suport\u0103 \u0219i auto-determinarea tipului de retur. De re\u021binut, totu\u0219i, c\u0103 o func\u021bie nu poate returna dou\u0103 tipuri diferite, chiar dac\u0103 tipul de return este determinat automat.</p> <pre><code>int main() {\n    // tipul a fost determinat de compilator\n    auto gauss = [](int n) { return n * (n + 1) / 2; };\n\n    cout &lt;&lt; gauss(10);  // 55\n}\n</code></pre>","tags":["C++","functii","lambda"]},{"location":"cppintro/lambda/#utilizari-practice-ale-lambda-urilor","title":"Utiliz\u0103ri practice ale lambda-urilor","text":"<p>Cea mai comun\u0103 utilizare a func\u021biilor lambda este pentru a putea ad\u0103uga sortare personalizat\u0103 la sort-ul din STL.</p> <pre><code>int main() {\n    int n;\n    std::cin &gt;&gt; n;\n    std::vector&lt;std::pair&lt;int, int&gt;&gt; v(n);\n    for (auto &amp;[x, y] : v) {\n        std::cin &gt;&gt; x &gt;&gt; y;\n    }\n\n    std::sort(v.begin(), v.end(),\n              [](std::pair&lt;int, int&gt; a, std::pair&lt;int, int&gt; b) {\n                  // sort\u0103m descresc\u0103tor dup\u0103 a doua valoare, dac\u0103 sunt identice\n                  // altfel cresc\u0103tor dup\u0103 prima\n                  if (a.second == b.second) {\n                      return a.first &lt; b.first;\n                  }\n                  return a.second &gt; b.second;\n              });\n}\n</code></pre>","tags":["C++","functii","lambda"]},{"location":"cppintro/lambda/#resurse-suplimentare","title":"Resurse suplimentare","text":"<ul> <li>Lambda expressions   (cppreference.com)</li> <li>On lambdas, C++ and otherwise: the what, the why, and the   how</li> </ul>","tags":["C++","functii","lambda"]},{"location":"cppintro/linked-lists/","title":"Liste \u00eenl\u0103n\u021buite","text":"<p>Daca vreti sa ne ajutati cu acest articol, ne puteti gasi pe github sau pe serverul nostru de discord</p> <p>Mai jos g\u0103si\u021bi resurse pe care le pute\u021bi citi p\u00e2n\u0103 atunci.</p>","tags":["implementare","C++"]},{"location":"cppintro/linked-lists/#introducere","title":"Introducere","text":"","tags":["implementare","C++"]},{"location":"cppintro/linked-lists/#problema-exemplu","title":"Problema exemplu","text":"","tags":["implementare","C++"]},{"location":"cppintro/linked-lists/#concluzii","title":"Concluzii","text":"","tags":["implementare","C++"]},{"location":"cppintro/linked-lists/#probleme-suplimentare","title":"Probleme suplimentare","text":"","tags":["implementare","C++"]},{"location":"cppintro/linked-lists/#resurse-suplimentare","title":"Resurse suplimentare","text":"<ul> <li>Liste liniare simplu \u00eenl\u0103n\u021buite alocate dinamic -   pbinfo</li> <li>Liste \u00eenl\u0103n\u021buite -   UPB</li> </ul>","tags":["implementare","C++"]},{"location":"cppintro/linux/","title":"Linux","text":"<p>\u00cenainte de a instala un editor/IDE, avem nevoie de un compilator. Pe Linux, cele mai populare op\u021biuni sunt:</p> <ul> <li> <p> GCC</p> <p>GCC (GNU Compiler Collection) este o suit\u0103 de compilatoare libere \u0219i gratuite. Este standardul de facto pentru dezvoltarea C++ pe Linux. GCC este disponibil \u00een majoritatea distribu\u021biilor Linux \u0219i poate fi instalat direct din managerul de pachete al sistemului.</p> <p> Vezi instruc\u021biuni pentru GCC</p> </li> <li> <p> Clang</p> <p>Clang este un compilator rapid \u0219i modular, parte a proiectului LLVM. Este o alternativ\u0103 popular\u0103 la GCC, oferind uneori mesaje de eroare mai clare \u0219i o compatibilitate excelent\u0103 cu standardele moderne C++.</p> <p> Vezi instruc\u021biuni pentru Clang</p> </li> </ul> <p>Dac\u0103 ai deja un compilator instalat pe sistem, aici ai unele op\u021biuni de editoare pentru a \u00eencepe s\u0103 dezvol\u021bi \u00een C++:</p> <p>Vezi op\u021biuni de editoare </p>"},{"location":"cppintro/loops/","title":"Structura repetitiv\u0103","text":"<p>Defini\u021bie</p> <p>O structur\u0103 repetitiv\u0103 este o structur\u0103 pe care o folosim pentru a coordona programul s\u0103 ia acelea\u0219i decizii de mai multe ori, at\u00e2ta timp c\u00e2t o anumit\u0103 condi\u021bie este \u00eendeplinit\u0103. Acest lucru se poate \u00eent\u00e2mpla de un num\u0103r fixat de ori sau de un num\u0103r variat de ori.</p> <p>Cele trei structuri repetitive din C++ sunt while, do..while \u0219i for. De\u0219i acestea au \u00een mare parte acela\u0219i rol, func\u021bioneaz\u0103 \u00eentr-un mod diferit \u0219i trebuie \u0219tiute pentru a putea folosi cea mai potrivit\u0103 variant\u0103 \u00een func\u021bie de ce ne cere problema. De\u0219i majoritatea programelor pot fi scrise folosind toate cele trei structuri repetitive, sunt situa\u021bii \u00een care nu este practic s\u0103 folosim anumite structuri, deci ne vom concentra pe a ar\u0103ta cele mai potrivite exemple \u00een func\u021bie de situa\u021bie.</p>","tags":["C++","introducere","for","while","do-while","structura repetitiva"]},{"location":"cppintro/loops/#structura-while","title":"Structura while","text":"<p>Defini\u021bie</p> <p>Structura repetitiv\u0103 while este o structur\u0103 repetitiv\u0103 cu test ini\u021bial \u0219i num\u0103r necunoscut de pa\u0219i pe care o folosim pentru a coordona programul s\u0103 ia acelea\u0219i decizii at\u00e2ta timp c\u00e2t o anumit\u0103 condi\u021bie este \u00eendeplinit\u0103 \u0219i nu \u0219tim num\u0103rul de pa\u0219i pe care vrem s\u0103-l facem.</p> <p>Sintaxa while-ului este de regul\u0103, urm\u0103toarea:</p> <pre><code>while (conditie) {\n    // instructiuni\n}\n</code></pre> <p>Observa\u021bie</p> <p>\u00cen mod particular, aceast\u0103 structur\u0103 repetitiv\u0103 este folosit\u0103 pentru a citi un num\u0103r necunoscut de date atunci c\u00e2nd lucr\u0103m cu fi\u0219iere text, lucru ce se poate vedea mai ales \u00een problemele ce se dau \u00een variantele de bacalaureat la informatic\u0103.</p> <pre><code>int x;\nwhile (fin &gt;&gt; x) {\n    // instructiuni\n}\n</code></pre>","tags":["C++","introducere","for","while","do-while","structura repetitiva"]},{"location":"cppintro/loops/#structura-dowhile","title":"Structura do..while","text":"<p>Defini\u021bie</p> <p>Structura repetitiv\u0103 do-while este o structur\u0103 repetitiv\u0103 cu test final \u0219i num\u0103r necunoscut de pa\u0219i pe care o folosim pentru a coordona programul s\u0103 ia acelea\u0219i decizii at\u00e2ta timp c\u00e2t o anumit\u0103 condi\u021bie este \u00eendeplinit\u0103 \u0219i nu \u0219tim num\u0103rul de pa\u0219i pe care vrem s\u0103-l facem, dar vrem s\u0103 rul\u0103m instruc\u021biunile m\u0103car o dat\u0103.</p> <p>Sintaxa do..while-ului este de regul\u0103, urm\u0103toarea:</p> <pre><code>do {\n    // instructiuni\n} while (conditie);\n</code></pre>","tags":["C++","introducere","for","while","do-while","structura repetitiva"]},{"location":"cppintro/loops/#structura-for","title":"Structura for","text":"<p>Defini\u021bie</p> <p>Structura repetitiv\u0103 for este o structur\u0103 repetitiv\u0103 cu test ini\u021bial \u0219i num\u0103r cunoscut de pa\u0219i pe care o folosim pentru a coordona programul s\u0103 ia acelea\u0219i decizii c\u00e2nd \u0219tim num\u0103rul de pa\u0219i pe care vrem s\u0103-l facem. De\u0219i for se poate scrie \u0219i folosind rigorile while-ului, av\u00e2nd num\u0103r necunoscut de pa\u0219i, se prefer\u0103 folosirea for-ului c\u00e2nd \u0219tim c\u00e2\u021bi pa\u0219i vrem s\u0103 facem, respectiv a while-ului \u00een caz contrar.</p> <pre><code>for (instructiune_initiala; conditie; actualizare) {\n    // instructiuni\n}\n</code></pre> <p>Un astfel de exemplu ar fi cel de mai jos. Se poate remarca c\u0103 putem actualiza valoarea lui \\(i\\) a\u0219a cum vrem noi, nefiind limita\u021bi la operatorii de incrementare \u0219i decrementare.</p> <pre><code>int s = 0;\nfor (int i = 1; i &lt;= n; i = i + 2) {\n    s = s + i;\n}\n</code></pre>","tags":["C++","introducere","for","while","do-while","structura repetitiva"]},{"location":"cppintro/loops/#exemplu","title":"Exemplu","text":"<p>Mai jos pute\u021bi g\u0103si un asemenea exemplu, \u00een care rezolv\u0103m problema AfisareNumerePare de pe pbinfo folosind diverse structuri repetitive.</p> whilefordo..while <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int n;\n    cin &gt;&gt; n;\n\n    int x = 1;\n    while (x &lt;= n) {\n        cout &lt;&lt; x * 2 &lt;&lt; \" \";\n        x++;\n    }\n    return 0;\n}\n</code></pre> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int n;\n    cin &gt;&gt; n;\n\n    for (int i = 1; i &lt;= n; i++) {\n        cout &lt;&lt; i * 2 &lt;&lt; \" \";\n    }\n    return 0;\n}\n</code></pre> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int n;\n    cin &gt;&gt; n;\n\n    int x = 1;\n    do {\n        cout &lt;&lt; x * 2 &lt;&lt; \" \";\n        x++;\n    } while (x &lt;= n);\n    return 0;\n}\n</code></pre>","tags":["C++","introducere","for","while","do-while","structura repetitiva"]},{"location":"cppintro/loops/#structuri-repetitive-imbricate","title":"Structuri repetitive imbricate","text":"<p>Aceste structuri repetitive pot fi \u0219i imbricate, a\u0219a cum se poate observa \u00een exemplul de mai jos. Cu alte cuvinte, putem s\u0103 le scriem una \u00een alta, astfel \u00eenc\u00e2t vom executa un num\u0103r de pa\u0219i de un alt num\u0103r de pa\u0219i. Putem scrie un num\u0103r nelimitat de structuri repetitive imbricate, bine\u00een\u021beles \u00een limita vitezei computa\u021bionale a programului dat.</p> <p>\u00cen codul de mai jos, ve\u021bi observa solu\u021bia noastr\u0103 pentru problema piramida de pe pbinfo. Se poate observa faptul c\u0103 primul for va avea \\(n\\) pa\u0219i, dar \u00een cadrul acestui for, avem un alt for care are \\(i\\) pa\u0219i.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int n;\n    cin &gt;&gt; n;\n\n    for (int i = 1; i &lt;= n; i++) {\n        for (int j = 1; j &lt;= i; j++) {\n            cout &lt;&lt; j &lt;&lt; \" \";\n        }\n        cout &lt;&lt; '\\n';\n    }\n    return 0;\n}\n</code></pre>","tags":["C++","introducere","for","while","do-while","structura repetitiva"]},{"location":"cppintro/loops/#resurse-suplimentare","title":"Resurse suplimentare","text":"<ul> <li>Articolul despre structuri repetitive de pe   pbinfo</li> <li>Learning to code - USACO   Guide</li> </ul>","tags":["C++","introducere","for","while","do-while","structura repetitiva"]},{"location":"cppintro/loops/#probleme-suplimentare","title":"Probleme suplimentare","text":"<ul> <li>Probleme usoare si medii din capitolul Structuri repetitive de pe   pbinfo</li> </ul>","tags":["C++","introducere","for","while","do-while","structura repetitiva"]},{"location":"cppintro/macOS/","title":"macOS","text":"<p>\u00cenainte de a instala un editor/IDE, avem nevoie de un compilator. Exist\u0103 urm\u0103toarele op\u021biuni:</p> <ul> <li> <p> Apple Clang</p> <p>Apple Clang este compilatorul implicit pe macOS, fiind inclus \u00een Xcode Command Line Tools. Acesta este o variant\u0103 modificat\u0103 de Clang/LLVM, optimizat\u0103 pentru ecosistemul Apple.</p> <p>Dac\u0103 vrei cea mai simpl\u0103 solu\u021bie pentru dezvoltare pe macOS, alege aceast\u0103 op\u021biune. Este recomandat pentru majoritatea utilizatorilor.</p> <p> Vezi instruc\u021biuni pentru XCode</p> </li> <li> <p> GCC</p> <p>GCC (GNU Compiler Collection) este o suit\u0103 de compilatoare libere \u0219i gratuite. Cel mai folosit compilator din aceast\u0103 suit\u0103 este GCC (GNU C Compiler).</p> <p>Pe macOS, cea mai u\u0219oar\u0103 metod\u0103 de a instala GCC este folosind Homebrew. Dac\u0103 ai nevoie de GCC sau nu vrei s\u0103 instalezi XCode, alege aceast\u0103 op\u021biune.</p> <p> Vezi instruc\u021biuni pentru GCC</p> </li> </ul> <p>Dac\u0103 ai deja un compilator instalat pe sistem (fie Clang, fie GCC), atunci aici ai unele op\u021biuni de editoare:</p> <p>Vezi op\u021biuni de editoare </p>"},{"location":"cppintro/matrices/","title":"Matrici (tablouri bidimensionale)","text":"","tags":["matrici","implementare"]},{"location":"cppintro/matrices/#introducere","title":"Introducere","text":"<p>Dup\u0103 ce v-a\u021bi obi\u0219nuit cu tablourile unidimensionale, a venit timpul s\u0103 generaliz\u0103m lucrurile \u0219i pentru tablourile bidimensionale (cunoscute colocvial ca matrici) \u0219i cele cu mai multe dimensiuni.</p> <p>O matrice este, \u00een esen\u021b\u0103, un vector de vectori. \u00cen memorie, matricea este stocat\u0103 astfel \u00eenc\u00e2t liniile s\u0103 fie plasate una dup\u0103 alta \u00een ordine consecutiv\u0103.</p> <p>De-a lungul acestui articol, vom discuta diferite moduri de a parcurge matricile, precum \u0219i elemente care apar des \u00een exerci\u021bii probleme \u0219i cum s\u0103 le identifica\u021bi cu u\u0219urin\u021b\u0103 \u00een diverse contexte. Ulterior, vom discuta \u0219i tehnici mai avansate, care pot fi utile atunci c\u00e2nd ave\u021bi de lucrat \u00een contexte mai dificile, precum \u0219i tablourile multidimensionale.</p>","tags":["matrici","implementare"]},{"location":"cppintro/matrices/#declararea-parcurgerea-si-umplerea-matricilor-statice","title":"Declararea, parcurgerea \u0219i umplerea matricilor statice","text":"<p>\u00cen C++, matricele pot fi declarate \u00een dou\u0103 moduri:</p> <ul> <li>Forma clasic\u0103, specific\u0103 limbajului C.</li> <li>Variante moderne bazate pe biblioteci din STL (abordat\u0103 \u00eentr-un articol   separat).</li> </ul> <p>\u00cen acest articol, ne concentr\u0103m pe matricile statice, adic\u0103 matrici care au dimensiuni fixe \u0219i nu pot fi extinse.</p>","tags":["matrici","implementare"]},{"location":"cppintro/matrices/#declaratie-si-structura","title":"Declara\u021bie \u0219i structur\u0103","text":"<p>Pentru declararea unei matrice statice, ave\u021bi nevoie de:</p> <ol> <li>Tipul de date al elementelor (e.g., <code>int</code>, <code>float</code>).</li> <li>Dimensiunile matricei.</li> </ol> <pre><code>int matrice[101][101];\n</code></pre> <p>Aceasta define\u0219te o matrice cu 101 linii \u0219i 101 coloane, fiecare element fiind de tip <code>int</code>. Indicii sunt numerota\u021bi de la 0 la 100.</p> <p>Urm\u0103toarea matrice are 5 r\u00e2nduri \u0219i 8 coloane \u0219i este indexat\u0103 de la 0. Pentru a accesa elementul de pe al treilea r\u00e2nd \u0219i a cincea coloan\u0103, folosim <code>matrice[2][4]</code>. A\u0219a ar ar\u0103ta pe matricea noastr\u0103:</p> <p>Reprezentarea matricii</p> <p>\u00cen terminologia uzual\u0103:</p> <ul> <li>Liniile sunt numerotate de sus \u00een jos.</li> <li>Coloanele sunt numerotate de la st\u00e2nga la dreapta.</li> </ul> <p>Spre deosebire de sistemul de coordonate cartezian (xOy) din geometrie, axa liniilor corespunde \u201everticalei\u201d, iar axa coloanelor \u201eorizontalului\u201d. Dac\u0103 \u00een matematic\u0103 elementul pozi\u021bionat x unit\u0103\u021bi la dreapta \u0219i y unit\u0103\u021bi \u00een sus este \\(a_{x,y}\\), \u00een cazul C++ avem y unit\u0103\u021bi \u00een jos \u0219i x unit\u0103\u021bi la dreapta \u0219i  not\u0103m elementul cu <code>a[y][x]</code>. Ca un ghid, \u021bine\u021bi minte indexarea din  C++ ca fiind <code>a[rand][coloana]</code>.</p> <p>Observa\u021bie</p> <p>Dac\u0103 prefera\u021bi s\u0103 lucra\u021bi cu indici numerota\u021bi de la 1, pur \u0219i simplu ad\u0103uga\u021bi 1 la dimensiunile declarate \u0219i folosi\u021bi direct num\u0103rul ca atare, exact ca \u00een cazul vectorilor uzuali.</p> <pre><code>// Numerotare de la 1 la 101.\nint matrice[102][102];\n</code></pre> <p>\u00cen acel caz, matricea va fi stocat\u0103 astfel:  </p>","tags":["matrici","implementare"]},{"location":"cppintro/matrices/#parcurgere-si-atribuire-de-valori","title":"Parcurgere \u0219i atribuire de valori","text":"<p>Valorile matricei pot fi accesate \u0219i modificate similar cu variabilele obi\u0219nuite, utiliz\u00e2nd indicii.</p> <pre><code>// Pe linia 1 \u0219i coloana 5 vom avea acum valoarea 7.\nmatrice[1][5] = 7;\n</code></pre> <p>Pentru a parcurge elementele, de regul\u0103 se folosesc structuri repetitive imbricate.</p> <p>Exemplu de parcurgere \u0219i afi\u0219are</p> <pre><code>// r semnific\u0103 r\u00e2ndul \u0219i c semnific\u0103 coloana.\nfor (int r = 0; r &lt; n; ++r) {\n    for (int c = 0; c &lt; m; ++c) {\n        cout &lt;&lt; matrice[r][c] &lt;&lt; \" \";\n    }\n    cout &lt;&lt; '\\n';\n}\n</code></pre> <p>Not\u0103</p> <p>Cea mai comun\u0103 conven\u021bie este <code>i</code> pentru r\u00e2nd \u0219i <code>j</code> pentru coloan\u0103. Am ales <code>r</code> \u0219i <code>c</code> pentru c\u0103 e mai simplu de re\u021binut de la ce vin.</p>","tags":["matrici","implementare"]},{"location":"cppintro/matrices/#problema-exemplu-sumapare2-de-pe-pbinfo","title":"Problem\u0103 exemplu - sumapare2 de pe pbinfo","text":"<p>Problema presupune citirea unei matrice \u0219i calcularea sumei tuturor elementelor pare din ea. Solu\u021bia poate fi implementat\u0103 astfel:</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    // Citirea dimensiunilor matricei\n    int randuri, coloane;\n    cin &gt;&gt; randuri &gt;&gt; coloane;\n\n    // Declararea matricei\n    int mat[randuri][coloane];\n\n    // Citirea elementelor\n    for (int r = 0; r &lt; randuri; r++) {\n        for (int c = 0; c &lt; coloane; c++) {\n            cin &gt;&gt; mat[r][c];\n        }\n    }\n\n    // Calculul sumei numerelor pare\n    int suma = 0;\n    for (int r = 0; r &lt; randuri; r++) {\n        for (int c = 0; c &lt; coloane; c++) {\n            if (mat[r][c] % 2 == 0) {\n                suma += mat[r][c];\n            }\n        }\n    }\n\n    // Afi\u0219area rezultatului\n    cout &lt;&lt; suma &lt;&lt; '\\n';\n\n    return 0;\n}\n</code></pre> <p>Not\u0103</p> <p>O alt\u0103 conven\u021bie comun\u0103 este <code>n</code> pentru num\u0103rul de r\u00e2nduri \u0219i <code>m</code> pentru num\u0103rul de coloane. Dac\u0103 \u00een matematic\u0103 am avea o matrice de <code>m</code> coloane \u0219i <code>n</code> r\u00e2nduri ca fiind de dimensiune m \u00d7 n, \u00een informatic\u0103 va fi <code>mat[n][m]</code>. Pentru a fi explici\u021bi, folosim <code>randuri</code> \u0219i <code>coloane</code> \u00een acest articol.</p>","tags":["matrici","implementare"]},{"location":"cppintro/matrices/#matrici-patratice","title":"Matrici p\u0103tratice","text":"<p>Defini\u021bie</p> <p>O matrice unde num\u0103rul de r\u00e2nduri \u0219i num\u0103rul de coloane coincid se nume\u0219te matrice p\u0103tratic\u0103.</p> <p>\u00cen acest caz, folosim pentru ambele dimensiuni o singur\u0103 variabil\u0103. De obicei se folose\u0219te <code>n</code>, \u00eens\u0103 \u00een acest articol vom folosi <code>dim</code> (de la dimensiune). A\u0219a arat\u0103 una:</p> <p>\u00centr-o matrice p\u0103tratic\u0103 avem diagonale. Distingem dou\u0103 diagonale:</p> <ul> <li>Diagonala principal\u0103 este diagonala care \u00eencepe din col\u021bul st\u00e2nga-sus \u0219i   se termin\u0103 \u00een col\u021bul dreapta-jos.</li> <li>Diagonala secundar\u0103 este diagonala care \u00eencepe din col\u021bul dreapta-sus \u0219i   se termin\u0103 \u00een cel st\u00e2nga-jos.</li> </ul> <p>Urm\u0103toarea poz\u0103 arat\u0103 diagonala principal\u0103 a matricei de mai sus:</p> <p>Elementele care apar\u021bin acestei diagonale se afl\u0103 la (0, 0), (1, 1), (2, 2), (3, 3), (4, 4). De aici, putem deriva faptul c\u0103 elementele diagonalei principale sunt cele pentru care r\u00e2ndul coincide cu coloana. Asta ne permite s\u0103 scriem urm\u0103torul cod care parcurge diagonala principal\u0103:</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    // Citirea dimensiunilor matricei\n    int randuri, coloane;\n    cin &gt;&gt; randuri &gt;&gt; coloane;\n\n    // Declararea matricei\n    int mat[randuri][coloane];\n\n    // Citirea elementelor\n    for (int r = 0; r &lt; randuri; r++) {\n        for (int c = 0; c &lt; coloane; c++) {\n            cin &gt;&gt; mat[r][c];\n        }\n    }\n\n    // Calculul sumei numerelor pare\n    int suma = 0;\n    for (int r = 0; r &lt; randuri; r++) {\n        for (int c = 0; c &lt; coloane; c++) {\n            if (mat[r][c] % 2 == 0) {\n                suma += mat[r][c];\n            }\n        }\n    }\n\n    // Afi\u0219area rezultatului\n    cout &lt;&lt; suma &lt;&lt; '\\n';\n\n    return 0;\n}\n</code></pre> <p>Din moment ce r\u00e2ndul coincide cu coloana, putem sc\u0103pa de al doilea <code>for</code>, pentru a ob\u021bine acest cod:</p> <pre><code>for (int i = 0; i &lt; dim; ++i) {\n    // F\u0103 ceva cu matrice[i][i]\n}\n</code></pre> <p>Acela\u0219i lucru se aplic\u0103 pentru indexarea de la 1, doar c\u0103 va fi <code>for (int i = 1; i &lt;= dim; ++i)</code>.</p> <p>Pentru matricea noastr\u0103, a\u0219a va ar\u0103ta diagonala secundar\u0103:</p> <p>Elementele care apar\u021bin acestei diagonale se afl\u0103 la (0, 4), (1, 3), (2, 2), (3, 1), (4, 0). Remarc\u0103m c\u0103 dac\u0103 adun\u0103m r\u00e2ndul \u0219i coloana, ob\u021binem 4, care este cu unu mai mic dec\u00e2t dimensiunea matricei. Asta ne permite s\u0103 scriem urm\u0103torul cod care parcurge diagonala secundar\u0103:</p> <pre><code>for (int r = 0; r &lt; dim; ++r) {\n    for (int c = 0; c &lt; dim; ++c) {\n        if (r + c == dim - 1) {\n            // F\u0103 ceva cu matrice[r][c]\n        }\n    }\n}\n</code></pre> <p>La fel ca \u00een cazul diagonalei principale, putem folosi un singur <code>for</code>. Din condi\u021bia de mai sus putem scoate <code>c</code>. Mai exact, putem muta <code>r</code> \u00een partea cealalt\u0103 pentru a ob\u021bine <code>c == dim - r + 1</code>. Acum putem scrie codul:</p> <pre><code>for (int r = 0; r &lt; dim; ++r) {\n    int c = dim - r - 1;\n\n    // F\u0103 ceva cu matrice[r][c]\n}\n</code></pre> <p>Dac\u0103 matricea este indexat\u0103 de la 1, atunci at\u00e2t <code>r</code>, c\u00e2t \u0219i <code>c</code> vor avea un 1 \u00een plus, a\u0219adar condi\u021bia devine <code>r - 1 + c - 1 == dim - 1</code> sau <code>r + c == dim + 1</code>, sau <code>c == dim - r + 1</code>. Pentru indexare de la 1, a\u0219a va ar\u0103ta codul:</p> <pre><code>for (int r = 1; r &lt;= dim; ++r) {\n    int c = dim - r + 1;\n\n    // F\u0103 ceva cu matrice[r][c]\n}\n</code></pre> <p>Cu indexarea la 0, sc\u0103dem 1, iar cu indexare de la 1, ad\u0103ug\u0103m 1.</p> <p>Observa\u021bie</p> <p>Dac\u0103 dimensiunea este impar\u0103, atunci cele dou\u0103 diagonale au un element comun. \u00cen caz contrar, diagonalele nu vor avea elemente comune.</p> <p>Fire\u0219te, dac\u0103 avem o diagonal\u0103, putem vorbi \u0219i despre elementele de deasupra sau de sub ea.</p> <p>A\u0219a arat\u0103 elementele de deasupra, respectiv de sub diagonala principal\u0103:</p> <p>A\u0219a arat\u0103 elementele de deasupra, respectiv de sub diagonala secundar\u0103:</p> <p>Indicii urmeaz\u0103 urm\u0103toarele reguli:</p> Deasupra Sub Diag. principal\u0103 <code>r &lt; c</code> <code>r &gt; c</code> Diag. secundar\u0103 <code>r + c &lt; dim - 1</code> <code>r + c &gt; dim - 1</code> <p>Este u\u0219or s\u0103 \u021bine\u021bi minte urm\u0103toarea regul\u0103: deasupra e mai mic, sub e mai mare.</p> <p>Intersec\u021bia acestor regiuni formeaz\u0103 patru regiuni: de nord, sud, vest \u0219i est. Elementele din aceste regiuni sunt determinate de aceste condi\u021bii:</p> <ul> <li>Nord:</li> <li>Deasupra diagonalei principale \u0219i deasupra diagonalei secundare.</li> <li>Formula: <code>r &lt; c &amp;&amp; r + c &lt; dim - 1</code>.</li> <li>Sud:</li> <li>Sub diagonala principal\u0103 \u0219i sub diagonala secundar\u0103.</li> <li>Formula: <code>r &gt; c &amp;&amp; r + c &gt; dim - 1</code>.</li> <li>Vest:</li> <li>Sub diagonala principal\u0103 \u0219i deasupra diagonalei secundare.</li> <li>Formula: <code>r &gt; c &amp;&amp; r + c &lt; dim - 1</code>.</li> <li>Est:</li> <li>Deasupra diagonalei principale \u0219i sub diagonala secundar\u0103.</li> <li>Formula: <code>r &lt; c &amp;&amp; r + c &gt; dim - 1</code>.</li> </ul>","tags":["matrici","implementare"]},{"location":"cppintro/matrices/#generari-de-matrice","title":"Gener\u0103ri de matrice","text":"<p>Multe probleme ce implic\u0103 matrici, \u00een special cele \u00eent\u00e2lnite la examenele de bacalaureat \u0219i admitere, necesit\u0103 generarea \u0219i construc\u021bia de matrici specifice. \u00cen aceast\u0103 sec\u021biune, vom prezenta c\u00e2teva exerci\u021bii \u0219i probleme rezolvate, oferind explica\u021bii clare \u0219i optimiz\u0103ri acolo unde este cazul.</p> <p>O list\u0103 foarte bun\u0103 cu probleme suplimentare de acest tip se g\u0103se\u0219te aici.</p>","tags":["matrici","implementare"]},{"location":"cppintro/matrices/#exercitiu-adaptat-dintr-un-model-al-examenului-de-bacalaureat","title":"Exerci\u021biu adaptat dintr-un model al examenului de bacalaureat","text":"<p>Enun\u021b</p> <p>S\u0103 se genereze o matrice cu dimensiunea 7 \u00d7 7 cu urm\u0103toarea form\u0103:</p> <pre><code>2 2 2 2 2 2 2\n2 2 2 2 2 2 2\n2 2 2 2 2 2 2\n2 2 2 2 2 2 2\n2 2 2 4 2 2 2\n2 2 4 4 4 2 2\n2 4 4 4 4 4 2\n</code></pre> <p>Pentru a rezolva acest exerci\u021biu, putem observa faptul c\u0103 toat\u0103 matricea este umplut\u0103 cu 2, cu excep\u021bia regiunii de sud unde avem 4. La problemele de bacalaureat de obicei indexarea este de la 1, a\u0219a c\u0103 vom urma \u0219i noi aceast\u0103 regul\u0103.</p> <pre><code>for (int r = 1; r &lt;= 7; r++) {\n    for (int c = 1; c &lt;= 7; c++) {\n        if (r &gt; c &amp;&amp; r + c &gt; 7 + 1) {\n            mat[r][c] = 4;\n        } else {\n            mat[r][c] = 2;\n        }\n    }\n}\n</code></pre>","tags":["matrici","implementare"]},{"location":"cppintro/matrices/#problema-exemplu-genmat25-de-pe-pbinfo","title":"Problem\u0103 exemplu - genmat25 de pe pbinfo","text":"<p>Pentru a rezolva aceast\u0103 problem\u0103, trebuie s\u0103 urm\u0103m cu aten\u021bie instruc\u021biunile din enun\u021b, \u00een ordinea \u00een care sunt date. Ulterior, vom afi\u0219a matricea rezultat\u0103.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    // Citirea dimensiunii\n    int dim;\n    cin &gt;&gt; dim;\n\n    int mat[21][21];\n\n    for (int i = 1; i &lt;= dim; i++) {\n        // Prima coloan\u0103\n        mat[i][1] = i;\n\n        // Ultima linie\n        mat[dim][i] = dim;\n    }\n\n    // De la penultima linie la prima\n    for (int r = dim - 1; r &gt;= 1; r--) {\n        // De la a doua coloan\u0103 la ultima\n        for (int c = 2; c &lt;= dim; c++) {\n            mat[r][c] = mat[r][c - 1] + mat[r + 1][c - 1];\n        }\n    }\n\n    // Afi\u0219are matrice\n    for (int i = 1; i &lt;= dim; i++) {\n        for (int j = 1; j &lt;= dim; j++) {\n            cout &lt;&lt; mat[i][j] &lt;&lt; \" \";\n        }\n        cout &lt;&lt; '\\n';\n    }\n\n    return 0;\n}\n</code></pre>","tags":["matrici","implementare"]},{"location":"cppintro/matrices/#problema-exemplu-genmat23-de-pe-pbinfo","title":"Problem\u0103 exemplu - genmat23 de pe pbinfo","text":"<p>Pentru a rezolva aceast\u0103 problem\u0103, vom vrea s\u0103 afl\u0103m pentru fiecare pozi\u021bie distan\u021ba fa\u021b\u0103 de marginea matricii \u0219i apoi vom colora p\u0103tratele cu 0 sau 1 dup\u0103 caz.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int dim;\n    cin &gt;&gt; dim;\n\n    int mat[dim + 1][dim + 1];\n\n    for (int r = 1; r &lt;= dim; r++) {\n        for (int c = 1; c &lt;= dim; c++) {\n            int sus = r - 1;\n            int stanga = c - 1;\n            int jos = dim - r;\n            int dreapta = dim - c;\n\n            // Determin\u0103m distan\u021ba minim\u0103 fa\u021b\u0103 de margini\n            int distanta = sus;\n            if (stanga &lt; distanta) {\n                distanta = stanga;\n            }\n            if (jos &lt; distanta) {\n                distanta = jos;\n            }\n            if (dreapta &lt; distanta) {\n                distanta = dreapta;\n            }\n\n            // Dac\u0103 distan\u021ba este par\u0103, punem 1, altfel punem 0\n            if (distanta % 2 == 0) {\n                mat[r][c] = 1;\n            } else {\n                mat[r][c] = 0;\n            }\n        }\n    }\n\n    for (int r = 1; r &lt;= dim; r++) {\n        for (int c = 1; c &lt;= dim; c++) {\n            cout &lt;&lt; mat[r][c] &lt;&lt; \" \";\n        }\n        cout &lt;&lt; '\\n';\n    }\n\n    return 0;\n}\n</code></pre>","tags":["matrici","implementare"]},{"location":"cppintro/matrices/#problema-exemplu-zona1-de-pe-pbinfo","title":"Problem\u0103 exemplu - zona1 de pe pbinfo","text":"<p>Aceast\u0103 problem\u0103 se concentreaz\u0103 pe zona de sud a matricii. Dup\u0103 ce parcurgem elementele matricii, le vom ad\u0103uga \u00eentr-un vector de frecven\u021b\u0103 pentru a ob\u021bine r\u0103spunsul cerut.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int dim;\n    cin &gt;&gt; dim;\n\n    int frecventa[1000] = {0};\n    for (int r = 1; r &lt;= dim; r++) {\n        for (int c = 1; c &lt;= dim; c++) {\n            int elem;\n            cin &gt;&gt; elem;\n\n            // Verific\u0103m dac\u0103 este \u00een zona de sud:\n            // sub diagonala principal\u0103 \u0219i sub diagonala secundar\u0103.\n            if (r &gt; c &amp;&amp; r + c &gt; dim + 1) {\n                frecventa[elem]++;\n            }\n        }\n    }\n\n    for (int i = 0; i &lt; 1000; i++) {\n        if (frecventa[i] &gt;= 2) {\n            cout &lt;&lt; i &lt;&lt; \" \";\n        }\n    }\n\n    return 0;\n}\n</code></pre>","tags":["matrici","implementare"]},{"location":"cppintro/matrices/#problema-exemplu-diagonal-de-pe-nerdarena","title":"Problem\u0103 exemplu - diagonal de pe nerdarena","text":"<p>Aici, vrem s\u0103 ne folosim de structura matricii pentru a procesa diagonalele, de jos \u00een sus \u0219i de la st\u00e2nga la dreapta. Mai \u00eent\u00e2i, mergem prin punctele de pe prima coloan\u0103 \u0219i apoi cele de pe prima linie, iar pentru diagonala secundar\u0103, punctele de pe prima linie \u0219i apoi cele de pe ultima coloan\u0103. Indiferent de parcurgere, vom merge \u00een jos ulterior.</p> <pre><code>#include &lt;fstream&gt;\n#include &lt;iostream&gt;\n\nusing namespace std;\n\nint main() {\n    ifstream in(\"diagonal.in\");\n    ofstream out(\"diagonal.out\");\n\n    char mat[100][100];\n\n    int dim = 0;\n    while (in &gt;&gt; mat[dim]) {\n        dim++;\n    }\n\n    // Diagonala principal\u0103\n\n    for (int start = dim - 1; start &gt;= 0; start--) {\n        int r = start, c = 0;\n        while (r &lt; dim &amp;&amp; c &lt; dim) {\n            out &lt;&lt; mat[r][c];\n            r++;\n            c++;\n        }\n    }\n\n    for (int start = 1; start &lt; dim; start++) {\n        int r = 0, c = start;\n        while (r &lt; dim &amp;&amp; c &lt; dim) {\n            out &lt;&lt; mat[r][c];\n            r++;\n            c++;\n        }\n    }\n\n    out &lt;&lt; '\\n';\n\n    // Diagonala secundar\u0103\n\n    for (int start = 0; start &lt; dim; start++) {\n        int r = 0, c = start;\n        while (r &lt; dim &amp;&amp; c &gt;= 0) {\n            out &lt;&lt; mat[r][c];\n            r++;\n            c--;\n        }\n    }\n\n    for (int start = 1; start &lt; dim; start++) {\n        int r = start, c = dim - 1;\n        while (r &lt; dim &amp;&amp; c &gt;= 0) {\n            out &lt;&lt; mat[r][c];\n            r++;\n            c--;\n        }\n    }\n\n    return 0;\n}\n</code></pre>","tags":["matrici","implementare"]},{"location":"cppintro/matrices/#alte-parcurgeri-si-modificari-in-matrice","title":"Alte parcurgeri \u0219i modific\u0103ri \u00een matrice","text":"","tags":["matrici","implementare"]},{"location":"cppintro/matrices/#parcurgerea-in-spirala","title":"Parcurgerea \u00een spiral\u0103","text":"<p>Parcurgerea matricii \u00een spiral\u0103 este un tip de cerin\u021b\u0103 ce apare des \u00een problemele de informatic\u0103 \u0219i este de multe ori, un tip de cerin\u021b\u0103 care pun mari dificult\u0103\u021bi celor care vor s\u0103 devin\u0103 mai pricepu\u021bi la implementare.</p> <p></p> <p>Exist\u0103 foarte multe moduri de a implementa corect algoritmul de parcurgere \u00een spiral\u0103, dar aici ne vom concentra pe dou\u0103 dintre variante.</p>","tags":["matrici","implementare"]},{"location":"cppintro/matrices/#varianta-1-acoperim-fiecare-zona-concentrica","title":"Varianta 1 - acoperim fiecare zon\u0103 concentric\u0103","text":"<p>O prim\u0103 variant\u0103 const\u0103 \u00een a simula cele patru mut\u0103ri pentru fiecare zon\u0103 concentric\u0103 \u0219i s\u0103 folosim bucle imbricate pentru a avea scrise parcurgerile.</p> <p>Cu alte cuvinte, acoperim fiecare zon\u0103 colorat\u0103 diferit \u00een imaginea de mai jos \u0219i \u00eencepem mereu de pe linia \u0219i coloana i.</p> <p></p> <p>Aici pute\u021bi g\u0103si implementarea din limbajul C++ a solu\u021biei pentru problema spirala de pe pbinfo care folose\u0219te aceast\u0103 tehnic\u0103.</p> <pre><code>#include &lt;fstream&gt;\nusing namespace std;\n\nifstream in(\"spirala.in\");\nofstream fout(\"spirala.out\");\n\nint main() {\n    int dim;\n    in &gt;&gt; dim;\n\n    int mat[dim + 1][dim + 1];\n\n    // Citirea matricei\n    for (int i = 1; i &lt;= dim; i++) {\n        for (int j = 1; j &lt;= dim; j++) {\n            in &gt;&gt; mat[i][j];\n        }\n    }\n\n    int N = dim / 2 + dim % 2;\n\n    // Iter\u0103m pentru fiecare zon\u0103 concentric\u0103\n    for (int r = 1; r &lt;= N; r++) {\n        // Dreapta\n        for (int c = r; c &lt;= dim - r + 1; c++) {\n            fout &lt;&lt; mat[r][c] &lt;&lt; \" \";\n        }\n\n        // Jos\n        for (int c = r + 1; c &lt;= dim - r + 1; c++) {\n            fout &lt;&lt; mat[c][dim - r + 1] &lt;&lt; \" \";\n        }\n\n        // St\u00e2nga\n        for (int c = dim - r; c &gt;= r; c--) {\n            fout &lt;&lt; mat[dim - r + 1][c] &lt;&lt; \" \";\n        }\n\n        // Dreapta\n        for (int c = dim - r; c &gt;= r + 1; c--) {\n            fout &lt;&lt; mat[c][r] &lt;&lt; \" \";\n        }\n    }\n\n    return 0;\n}\n</code></pre>","tags":["matrici","implementare"]},{"location":"cppintro/matrices/#varianta-2-folosind-vectori-de-directie","title":"Varianta 2 - folosind vectori de direc\u021bie","text":"<p>O variant\u0103 alternativ\u0103 este aceea de a observa modul \u00een care se execut\u0103 mi\u0219c\u0103rile de c\u0103tre algoritmul explicat la primul pas.</p> <p>Vom lua drept exemplu n = 4.</p> <ul> <li>4 pa\u0219i la dreapta</li> <li>3 pa\u0219i \u00een jos</li> <li>3 pa\u0219i la st\u00e2nga</li> <li>2 pa\u0219i \u00een sus</li> <li>2 pa\u0219i la dreapta</li> <li>1 pas \u00een jos</li> <li>1 pas la st\u00e2nga</li> </ul> <p>Se poate observa faptul c\u0103 dup\u0103 ce facem primul pas \u0219i avem n mut\u0103ri, lungimile mut\u0103rilor se repet\u0103 c\u00e2te dou\u0103, astfel putem folosi vectorii de direc\u021bie pentru a implementa aceste mut\u0103ri foarte u\u0219or, f\u0103r\u0103 mari probleme.</p> <p>Aici pute\u021bi g\u0103si implementarea din limbajul C++ a solu\u021biei pentru problema spirala de pe pbinfo care folose\u0219te aceast\u0103 tehnic\u0103.</p> <pre><code>#include &lt;fstream&gt;\nusing namespace std;\n\n// Dreapta, jos, st\u00e2nga, sus\nint deltaX[4] = {0, 1, 0, -1};\nint deltaY[4] = {1, 0, -1, 0};\n\nint main() {\n    ifstream in(\"spirala.in\");\n    ofstream out(\"spirala.out\");\n\n    int dim;\n    in &gt;&gt; dim;\n\n    int mat[dim + 1][dim + 1];\n    for (int r = 1; r &lt;= dim; r++) {\n        for (int c = 1; c &lt;= dim; c++) {\n            in &gt;&gt; mat[r][c];\n        }\n    }\n\n    // R\u00e2ndul curent\n    int rand = 1;\n\n    // Coloana curent\u0103 (pornind din afara matricii)\n    int coloana = 0;\n\n    // Direc\u021bia curent\u0103 (0: dreapta, 1: jos, 2: st\u00e2nga, 3: sus)\n    int directie = 0;\n\n    // Num\u0103rul de pa\u0219i pe care trebuie s\u0103 \u00eei facem \u00eenainte de\n    // a schimba direc\u021bia\n    int pasiRamasi = dim;\n\n    // Num\u0103rul de schimb\u0103ri de direc\u021bie r\u0103mase pentru acest num\u0103r de pa\u0219i\n    int schimbari = 1;\n\n    // Algoritmul de parcurgere \u00een spiral\u0103\n    while (pasiRamasi &gt; 0) {\n        // Mergem \u00een direc\u021bia curent\u0103 pentru pa\u0219ii r\u0103ma\u0219i\n        for (int pas = 1; pas &lt;= pasiRamasi; pas++) {\n            rand += deltaX[directie];\n            coloana += deltaY[directie];\n\n            out &lt;&lt; mat[rand][coloana] &lt;&lt; \" \";\n        }\n\n        // Schimb\u0103m direc\u021bia \u00een sensul acelor de ceasornic\n        directie = (directie + 1) % 4;\n\n        // Un set de mut\u0103ri r\u0103mase este gata\n        schimbari--;\n\n        // Dac\u0103 s-au efectuat dou\u0103 schimb\u0103ri, reducem num\u0103rul de pa\u0219i r\u0103ma\u0219i\n        if (schimbari == 0) {\n            schimbari = 2;\n            // Reducem dimensiunea spiralei\n            pasiRamasi--;\n        }\n    }\n\n    return 0;\n}\n</code></pre>","tags":["matrici","implementare"]},{"location":"cppintro/matrices/#transpunerea-elementelor-in-matrice","title":"Transpunerea elementelor \u00een matrice","text":"<p>\u00cen unele probleme, suntem nevoi\u021bi s\u0103 rotim matricea pentru a lucra mai u\u0219or cu ea.</p> <p>De obicei, cele mai frecvente rota\u021bii sunt cele la st\u00e2nga sau la dreapta, dar avem de-a face \u0219i cu alte tipuri de mi\u0219c\u0103ri, precum transpozi\u021biile sau oglindirea valorilor.</p> <p>Se poate observa faptul c\u0103 dup\u0103 o rotire a matricii cu 90\u00b0, prima linie va deveni prima coloan\u0103 scris\u0103 invers, a doua coloan\u0103 va deveni a doua coloan\u0103 scris\u0103 invers \u0219.a.m.d.</p> <p>Rota\u021bii mai mari</p> <p>Dac\u0103 vrem s\u0103 rotim matricea cu valori mai mari de 90\u00b0, putem simula rotirile de 90\u00b0 de mai multe ori, ajung\u00e2nd la acela\u0219i rezultat.</p> <p>Rota\u021bii la dreapta</p> <p>Dac\u0103 vrem s\u0103 rotim matricea la dreapta, vom folosi aceea\u0219i logic\u0103, unde prima linie va deveni ultima coloan\u0103, a doua linie va deveni penultima coloan\u0103 \u0219.a.m.d.</p> <p>Aici se poate g\u0103si solu\u021bia problemei rotire de pe pbinfo, unde trebuie s\u0103 rotim matricea la st\u00e2nga cu 90\u00b0.</p> <pre><code>#include &lt;fstream&gt;\nusing namespace std;\n\nint main() {\n    ifstream in(\"rotire.in\");\n    ofstream out(\"rotire.out\");\n\n    int randuri, coloane;\n    in &gt;&gt; randuri &gt;&gt; coloane;\n\n    int mat[11][11];\n    int matRot[11][11];\n\n    for (int r = 1; r &lt;= randuri; r++) {\n        for (int c = 1; c &lt;= coloane; c++) {\n            in &gt;&gt; mat[r][c];\n        }\n    }\n\n    for (int r = 1; r &lt;= randuri; r++) {\n        for (int c = 1; c &lt;= coloane; c++) {\n            matRot[coloane - c + 1][r] = mat[r][c];\n        }\n    }\n\n    for (int r = 1; r &lt;= coloane; r++) {\n        for (int c = 1; c &lt;= randuri; c++) {\n            out &lt;&lt; matRot[r][c] &lt;&lt; \" \";\n        }\n        out &lt;&lt; '\\n';\n    }\n    return 0;\n}\n</code></pre>","tags":["matrici","implementare"]},{"location":"cppintro/matrices/#bordarea-unei-matrici","title":"Bordarea unei matrici","text":"<p>Pentru a borda o matrice, putem s\u0103 marc\u0103m cu o valoare care s\u0103 ne marcheze faptul c\u0103 nu vrem s\u0103 trecem prin acele pozi\u021bii (de exemplu, -1).</p> <pre><code>for (int c = 0; c &lt;= coloane + 1; c++) {\n    // Bordarea liniei 0\n    mat[0][c] = -1;\n\n    // Bordarea ultimei linii\n    mat[randuri + 1][c] = -1;\n}\n\nfor (int r = 0; r &lt;= randuri + 1; r++) {\n    // Bordarea primei coloane\n    mat[r][0] = -1;\n\n    // Bordarea ultimei coloane\n    mat[r][coloane + 1] = -1;\n}\n</code></pre>","tags":["matrici","implementare"]},{"location":"cppintro/matrices/#cautarea-unor-elemente-si-secvente-in-matrici","title":"C\u0103utarea unor elemente \u0219i secven\u021be \u00een matrici","text":"<p>Pentru a c\u0103uta elementele \u00een matrici, vom procesa mai mult sau mai pu\u021bin ca la vectori, put\u00e2nd aplica algoritmii \u00eenv\u0103\u021ba\u021bi la vectori \u0219i pentru matrici.</p> <p>O tehnic\u0103 care merit\u0103 \u0219tiut\u0103 este aceea c\u0103 \u00een cazul multor probleme, dac\u0103 vrem s\u0103 alegem o submatrice cu o anumit\u0103 proprietate, de multe ori este optim s\u0103 fix\u0103m linia de \u00eenceput \u0219i de final, iar mai apoi s\u0103 proces\u0103m valorile dintre cele dou\u0103 linii presupun\u00e2nd c\u0103 acestea formeaz\u0103 un vector, ulterior aplic\u00e2nd tehnicile \u0219i algoritmii \u00eenv\u0103\u021ba\u021bi la vectori.</p> <p>Un astfel de exemplu de problem\u0103 este Submatrix SumMax, discutat\u0103 \u00een articolul cu secven\u021be.</p>","tags":["matrici","implementare"]},{"location":"cppintro/matrices/#tablouri-multidimensionale","title":"Tablouri multidimensionale","text":"<p>\u00cen general, c\u00e2nd vine vorba de tablouri cu mai multe dimensiuni, putem s\u0103 le declar\u0103m fie la fel cum declar\u0103m matricile, fie folosind variantele din STL, care vor fi detaliate \u00een articolul corespunz\u0103tor.</p> <p>De exemplu, <code>int v[101][101][101];</code> reprezint\u0103 un \"cub\" de dimensiuni 101 \u00d7 101 \u00d7 101. La fel ca la celelalte tablouri, cu c\u00e2t avem mai multe dimensiuni, cu at\u00e2t cantitatea de memorie cre\u0219te, iar \u00een cele mai multe cazuri, nu vom avea nevoie de mai mult de 3\u20134 dimensiuni.</p>","tags":["matrici","implementare"]},{"location":"cppintro/matrices/#concluzii","title":"Concluzii","text":"<p>Lucrul cu matrici \u0219i tablouri multidimensionale este un pas \u00eenainte pentru aprofundarea principiilor program\u0103rii \u00een oricare limbaj de programare. Foarte mul\u021bi algoritmi pe matrici sunt aplica\u021bi \u00een diverse moduri \u0219i a\u0219a cum se poate vedea \u00een metodele de mai sus, aplica\u021biile sunt foarte r\u0103sp\u00e2ndite.</p>","tags":["matrici","implementare"]},{"location":"cppintro/matrices/#probleme-suplimentare","title":"Probleme suplimentare","text":"<ul> <li>cntlinii pbinfo</li> <li>ordlin pbinfo</li> <li>lincol pbinfo</li> <li>chenar pbinfo</li> <li>zone1 pbinfo</li> <li>serpuire pbinfo</li> <li>spirala1 pbinfo</li> <li>spirala2 pbinfo</li> <li>eroziune pbinfo</li> <li>memory001 pbinfo</li> <li>OJI 2007 cartele</li> <li>infoarena mostenire2</li> <li>infoarena marmote</li> <li>Problemele recomandate \u00een cele 4 articole de   aici</li> <li>Probleme de la parcurgerea matricelor oarecare -   pbinfo</li> <li>Probleme de la parcurgerea matricelor p\u0103tratice -   pbinfo</li> <li>Probleme diverse cu matrici -   pbinfo</li> </ul>","tags":["matrici","implementare"]},{"location":"cppintro/matrices/#resurse-suplimentare","title":"Resurse suplimentare","text":"<ul> <li>Tablouri bidimensionale -   pbinfo</li> <li>Articolele din sec\u021biunea tablouri bidimensionale (matrice) - CPPI   Sync</li> <li>Matrici -   InfoGym</li> <li>Tablouri p\u0103tratice -   pbinfo</li> </ul>","tags":["matrici","implementare"]},{"location":"cppintro/stl/","title":"Introducere \u00een STL","text":"","tags":["C++","implementare","structuri de date"]},{"location":"cppintro/stl/#introducere","title":"Introducere","text":"<p>P\u00e2n\u0103 acum, programele pe care le-a\u021bi scris, de\u0219i sunt corecte \u0219i compileaz\u0103 \u00een limbajul C++, respect\u0103 \u00een mare parte din cazuri sintaxa din C, exemple fiind tablourile, anumite func\u021bii de sistem \u0219i \u00een general, modul \u00een care am lucrat cu variabilele \u0219i tipurile de date men\u021bionate anterior, cu o singur\u0103 excep\u021bie - citirea \u0219i afi\u0219area, care s-au f\u0103cut conform limbajului C++.</p> <p>Cu alte cuvinte, putem spune c\u0103 programele scrise sunt programe de C care au cin \u0219i cout. Astfel, pentru a putea folosi limbajul C++ la adev\u0103rata sa valoare, se impune folosirea structurilor de date \u0219i celorlalte facilit\u0103\u021bi ale acestui limbaj. O mare parte dintre ele sunt \u00eenglobate \u00een ceea ce vom numi STL (Standard Template Library) \u0219i ne vor ajuta s\u0103 lucr\u0103m cu foarte multe tipuri de valori \u00eentr-un mod dinamic, astfel evit\u00e2nd marea majoritate a neajunsurilor lucrului cu structuri din C, chiar \u0219i adaptate la limbajul C++.</p> <p>\u00cen acest articol, ne vom concentra pe cele mai folosite facilit\u0103\u021bi, \u00eempreun\u0103 cu modul \u00een care le putem folosi \u00een probleme.</p>","tags":["C++","implementare","structuri de date"]},{"location":"cppintro/stl/#structuri-de-date-de-tip-tablou","title":"Structuri de date de tip tablou","text":"<p>\u00cen aceast\u0103 sec\u021biune, ne vom concentra pe structurile de date care pot fi reprezentate \u00een sintaxa din C sub form\u0103 de tablouri. Fie c\u0103 e vorba de vectori, cozi, stive sau tipuri de date mai complexe, toate acestea vor fi men\u021bionate \u00een cele ce urmeaz\u0103.</p> <p>De\u0219i acest articol poate fi parcurs f\u0103r\u0103 cuno\u0219tin\u021be anterioare, se recomand\u0103 parcurgerea articolului anterior despre vectori.</p>","tags":["C++","implementare","structuri de date"]},{"location":"cppintro/stl/#structura-stdvector","title":"Structura std::vector","text":"<p>Aceasta este cea mai simpl\u0103 structur\u0103 de date din STL, fiind un tablou cu lungime dinamic\u0103, care este indexat de la 0. Pentru a putea folosi aceast\u0103 structur\u0103 de date, va trebui s\u0103 includem biblioteca <code>&lt;vector&gt;</code>.</p> <p>Sintaxa unui vector va fi de tipul <code>vector&lt;tip&gt; nume;</code>, unde tip poate fi orice tip de date cunoscut, inclusiv cele pe care le ve\u021bi studia \u00een acest articol. Cel mai frecvent, ve\u021bi folosi un vector drept un \u00eenlocuitor pentru tablourile de tip array cu care sunte\u021bi obi\u0219nui\u021bi din codurile scrise anterior.</p> <p>Mai jos, pute\u021bi vedea diverse exemple de folosire a acestei structuri de date \u00een limbajul C++.</p>","tags":["C++","implementare","structuri de date"]},{"location":"cppintro/stl/#declararile-vectorilor","title":"Declar\u0103rile vectorilor","text":"<p>\u00cen ceea ce prive\u0219te declar\u0103rile, avem o flexibilitate unic\u0103 pentru limbajul C++, put\u00e2nd declara \u0219i atribui vectorul \u00een foarte moduri, a\u0219a cum vom prezenta mai jos. \u00cen mod particular, putem s\u0103 asign\u0103m \u0219i chiar s\u0103 compar\u0103m vectori, folosind operatorii <code>=</code> \u0219i <code>==</code>.</p> <p>\u00cen general, complexitatea opera\u021biilor descrise aici este liniar\u0103 raportat la num\u0103rul de valori cu care se lucreaz\u0103.</p> <p>Observa\u021bie</p> <p>Pentru a compara doi vectori, va trebui s\u0103 aib\u0103 aceea\u0219i dimensiune \u0219i tip de date, iar dac\u0103 acest lucru este adev\u0103rat, trebuie s\u0103 aib\u0103 toate valorile egale pe aceea\u0219i pozi\u021bie. \u00cen mod similar, atribuirea se va face cur\u0103\u021b\u00e2nd eventual pozi\u021biile \u00een plus existente \u0219i ad\u0103ug\u00e2nd pozi\u021bii noi dac\u0103 e nevoie.</p> <pre><code>// Declararea vectorului\nvector&lt;int&gt; v;\n\n// Ini\u021bializ\u0103m un vector cu 6 valori\nvector&lt;int&gt; vals = {1, 4, 0, 1, 3, 5};\n\n// Ini\u021bializ\u0103m un vector cu 12 valori, toate 0\nvector&lt;int&gt; v2(12);\n\nvector&lt;int&gt; copie = v2;\nif (v2 == copie) {\n    cout &lt;&lt; \"Egal\\n\";\n} else {\n    cout &lt;&lt; \"Inegal\\n\";\n}\n</code></pre> <p>Pentru a declara tablouri bidimensionale, sau chiar tablouri multidimensionale, putem folosi aceea\u0219i logic\u0103, deoarece acestea sunt vectori de vectori. Aceste tipuri de structuri vor fi folosite \u0219i ulterior, \u00een ceea ce prive\u0219te implement\u0103rile unor modele matematice sau a unor structuri de date mai complexe despre care ve\u021bi \u00eenv\u0103\u021ba dup\u0103 ce prinde\u021bi mai mult\u0103 experien\u021b\u0103.</p> <pre><code>// Declararea matricii cu 3 linii \u0219i 2 coloane\nvector&lt;vector&lt;int&gt;&gt; grid(3, vector&lt;int&gt;(2));\n\n// Declararea cubului\nvector&lt;vector&lt;vector&lt;int&gt;&gt;&gt; cube;\n\n// Declar\u0103m n linii\nvector&lt;vector&lt;int&gt;&gt; grid2(n);\n\n// Matrice triunghiular\u0103\nfor (int i = 0; i &lt; n; i++) {\n    grid2.resize(i + 1);\n}\n</code></pre>","tags":["C++","implementare","structuri de date"]},{"location":"cppintro/stl/#inserari-stergeri-si-alte-ajustari","title":"Inser\u0103ri, \u0219tergeri \u0219i alte ajust\u0103ri","text":"<p>Pe l\u00e2ng\u0103 declar\u0103ri, atribuiri \u0219i compar\u0103ri, putem \u0219i s\u0103 ajust\u0103m vectorii, folosind foarte multe tipuri de opera\u021bii care adaug\u0103 \u0219i scot valori sau chiar fac inser\u0103ri \u00een diverse pozi\u021bii, f\u0103r\u0103 a mai fi nevoie de implementarea manual\u0103 a opera\u021biilor. Totu\u0219i, se remarc\u0103 faptul c\u0103 opera\u021biile de insert \u0219i erase vor fi liniare, exact cum sunt \u0219i pe tablourile statice.</p> <p>Iteratori</p> <p>Valori precum <code>v.begin()</code>, <code>v.end()</code> se numesc iteratori, ace\u0219tia vor fi prezenta\u021bi ulterior. Ace\u0219tia reprezint\u0103 adresa de memorie de la \u00eenceput \u0219i de sf\u00e2r\u0219it din vector.</p> <pre><code>// Urm\u0103toarele opera\u021bii sunt liniare.\n\n// * `grid` va avea 5 linii \u0219i 8 coloane\ngrid.resize(5, vector&lt;int&gt;(8));\n// * Redimension\u0103m vectorul s\u0103 aib\u0103 7 valori, toate -3\nv2.resize(7, -3);\n// * Redimension\u0103m vectorul s\u0103 aib\u0103 5 elemente\nv.resize(5);\n\n// Urm\u0103toarele opera\u021bii se fac \u00een timp constant.\n\n// * Ad\u0103ugarea elementului x de la final\nv.push_back(x);\n// * Eliminarea elementului de la final\nv.pop_back();\n\n// Urm\u0103toarele opera\u021bii sunt liniare.\n\n// * Inser\u0103m 6 la pozi\u021bia 2\nv.insert(v.begin() + 2, 6);\n// * Inser\u0103m 9 de 5 ori \u00eencep\u00e2nd de la pozi\u021bia 3\nv.insert(v.begin() + 3, 5, 9);\n// * \u0218tergem valoarea de pe pozi\u021bia 4\nv.erase(v.begin() + 4);\n// * \u0218tergem valorile de la pozi\u021bia 2 la pozi\u021bia 4\nv.erase(v.begin() + 2, v.begin() + 5);\n</code></pre>","tags":["C++","implementare","structuri de date"]},{"location":"cppintro/stl/#afisari-in-vector","title":"Afi\u0219\u0103ri \u00een vector","text":"<p>Pentru a afi\u0219a diverse valori din vector, vom putea proceda la fel ca \u00een cazul tablourilor din C. Se remarc\u0103 folosirea func\u021biei size pentru a afla dimensiunea vectorului, aceast\u0103 func\u021bie fiind de tip unsigned, lucru ce necesit\u0103 prelucrarea cu aten\u021bie a acestor valori.</p> <p>\u00cen mod particular, se remarc\u0103 folosirea tipului de date auto, care este folosit pentru a evita o declarare specific\u0103 a unei variabile, fiind folosit \u00een acest caz pentru a parcurge valorile din vectorul vals.</p> <p>Tipuri unsigned</p> <p>Dac\u0103 vrem s\u0103 avem un loop care va rula de <code>v.size() - 3</code> ori, vom avea de-a face cu un loop infinit \u00een cazul \u00een care <code>v.size() &lt; 3</code>, deoarece rezultatul expresiei va fi si el unsigned, rezultatul d\u00e2nd underflow. Pentru a evita asta, putem fie s\u0103 rescriem expresiile pentru a con\u021bine adun\u0103ri, fie prin a folosi indicatorul (int) pentru a schimba tipul de date la int, care este un tip de date signed.</p> <pre><code>// Afi\u0219\u0103ri \u0219i prelucr\u0103ri\n\n// Afi\u0219\u0103m vals[3], al patrulea element\ncout &lt;&lt; vals[3] &lt;&lt; '\\n';\n// Afi\u0219\u0103m dimensiunea vectorului (7)\ncout &lt;&lt; v2.size() &lt;&lt; '\\n';\n\nvals[1] = -9;\n\n// Afi\u0219\u0103m vectorul vals\nfor (int i = 0; i &lt; (int)vals.size(); i++) {\n    cout &lt;&lt; vals[i] &lt;&lt; \" \";\n}\n\n// Afi\u0219\u0103m vectorul vals folosind iteratori\nfor (auto it = vals.begin(); it != vals.end(); ++it) {\n    cout &lt;&lt; *it &lt;&lt; \" \";\n}\n\n// Afi\u0219\u0103m vectorul vals folosind auto\nfor (auto nr : vals) {\n    cout &lt;&lt; nr &lt;&lt; \" \";\n}\n</code></pre>","tags":["C++","implementare","structuri de date"]},{"location":"cppintro/stl/#structura-stdarray","title":"Structura std::array","text":"<p>Aceast\u0103 structur\u0103 de date este folosit\u0103 mai rar, dar poate fi util\u0103 \u00een cazul \u00een care vrem s\u0103 lucr\u0103m cu un array care are avantajele array-urilor din C, dar f\u0103r\u0103 majoritatea dezavantajelor acestora.</p> <p>Sintaxa unui array va fi de tipul <code>array&lt;tip, dimensiune&gt; nume;</code>. De regul\u0103, nu exist\u0103 diferen\u021be semnificative de performan\u021b\u0103 \u00eentre <code>std::vector</code> \u0219i <code>std::array</code>, deci \u00een aproape toate cazurile, putem folosi <code>std::vector</code> f\u0103r\u0103 probleme, func\u021biile pe care <code>std::array</code> le are sunt incluse \u00een func\u021biile vectorului.</p> <pre><code>// Tablou cu 25 de elemente de tip int\narray&lt;int, 25&gt; arr;\n\narr[4] = 3;\ncout &lt;&lt; arr[5] &lt;&lt; '\\n';\n</code></pre>","tags":["C++","implementare","structuri de date"]},{"location":"cppintro/stl/#structura-stdstring","title":"Structura std::string","text":"<p>Aceast\u0103 structur\u0103 de date este echivalentul <code>std::vector</code> pentru \u0219irurile de caractere, remarc\u00e2ndu-se prin faptul c\u0103 spre deosebire de \u0219irurile de caractere din C, func\u021bia de aflare a lungimii este \\(\\mathcal{O}(1)\\), \u00een loc de \\(\\mathcal{O}(n)\\).</p> <p>Se recomand\u0103 citirea \u00een prealabil a articolului urm\u0103tor despre \u0219iruri de caractere.</p> <p>De asemenea, toate propriet\u0103\u021bile vectorului se aplic\u0103 \u0219i pentru <code>std::string</code>. Pentru a putea folosi aceast\u0103 structur\u0103 de date, va trebui s\u0103 includem biblioteca <code>&lt;string&gt;</code>. Se remarc\u0103 faptul c\u0103 exist\u0103 anumite diferen\u021be fa\u021b\u0103 de cum folosim \u0219irurile de caractere din C.</p> <p>Sintaxa unui string va fi de tipul <code>string nume;</code></p> <pre><code>string s = \"abacaba\";\ns[0] = 'c';\n\ncout &lt;&lt; s.size() &lt;&lt; '\\n';  // 7\n\ns[6] = '\\0';  // caracterul nul\n\n// abacab 7\n// (nu se schimb\u0103 m\u0103rimea)\ncout &lt;&lt; s &lt;&lt; \" \" &lt;&lt; s.size() &lt;&lt; '\\n';\n</code></pre> <p>\u00cen mod particular, pe l\u00e2ng\u0103 func\u021biile vectorului, vom putea concatena dou\u0103 \u0219iruri de caractere cu u\u0219urin\u021b\u0103, folosind operatorul +. Totu\u0219i, trebuie s\u0103 fim aten\u021bi cum folosim acest operator, pentru a evita efectuarea prea \u00eenceat\u0103 a opera\u021biilor.</p> <pre><code>string s = \"roalgo\";\nstring t = \"top\";\ns += t;     // roalgotop\ns = s + t;  // roalgotoptop\n</code></pre> <p>De\u0219i \u00een cazul numerelor naturale, aceste opera\u021bii sunt echivalente, \u00een cazul stringurilor, <code>+=</code> \u0219i <code>+</code> sunt complet diferite. Prima dintre ele concateneaz\u0103 \u0219irul primit la \u0219irul existent, cea de-a doua copiaz\u0103 cele dou\u0103 \u0219iruri, le une\u0219te \u0219i apoi atribuie rezultatul \u0219irului. Aceast\u0103 diferen\u021b\u0103 devine mai dramatic\u0103 \u00een situa\u021bii precum cea de mai jos.</p> <pre><code>string s;\nfor (int i = 1; i &lt;= 1000000; i++) {  // O(n)\n    s += 'a';\n}\nstring t;\nfor (int i = 1; i &lt;= 1000000; i++) {  // O(n^2)\n    t = t + 'a';\n}\n</code></pre>","tags":["C++","implementare","structuri de date"]},{"location":"cppintro/stl/#structura-stdpair","title":"Structura std::pair","text":"<p>Aceast\u0103 structur\u0103 de date v\u0103 permite s\u0103 folosi\u021bi o combina\u021bie de tipuri de date mai complexe, \u00een mod similar cu tipul de date struct pe care l-a\u021bi \u00eenv\u0103\u021bat anterior. Un mare avantaj pe care <code>std::pair</code> (\u0219i ulterior, <code>std::tuple</code>) \u00eel au este acela c\u0103 permit instruc\u021biunilor de sortare s\u0103 compare dou\u0103 instan\u021be ale acestui tip de date f\u0103r\u0103 a mai fi nevoie s\u0103 scriem o func\u021bie suplimentar\u0103 de comparare a valorilor.</p> <p>Sintaxa este <code>pair&lt;tip1, tip2&gt; nume;</code>, unde tip1 \u0219i tip2 sunt tipuri de date, care pot fi de toate felurile, inclusiv alte perechi. Pentru a putea accesa tip1, respectiv tip2, va trebui s\u0103 folosim comenzile nume.first \u0219i nume.second. Ini\u021bializarea unui pair se poate face similar cu cea a unui vector.</p> <p>\u00cen cazul elementelor de tip pair compuse, \u00een mod similar cu struct, nota\u021biile vor fi la fel compuse.</p> <p>De exemplu, dac\u0103 avem <code>pair&lt;pair&lt;int, int&gt;, pair&lt;int, int&gt;&gt; p = {{2, 4}, {1, 3}};</code>, cele patru elemente vor putea fi declarate \u0219i accesate dup\u0103 cum urmeaz\u0103:</p> <pre><code>pair&lt;int, int&gt; pr = make_pair(5, 8);\n\ncout &lt;&lt; pr.first &lt;&lt; '\\n';   // 5\ncout &lt;&lt; pr.second &lt;&lt; '\\n';  // 8\n\npair&lt;int, int&gt; p2 = {10, 12};\ncout &lt;&lt; p2.first &lt;&lt; '\\n';   // 10\ncout &lt;&lt; p2.second &lt;&lt; '\\n';  // 12\n\npair&lt;pair&lt;int, int&gt;, pair&lt;int, int&gt;&gt; p = {\n    {2, 4},\n    {1, 3}\n};\ncout &lt;&lt; p.first.first &lt;&lt; '\\n';    // 2\ncout &lt;&lt; p.first.second &lt;&lt; '\\n';   // 4\ncout &lt;&lt; p.second.first &lt;&lt; '\\n';   // 1\ncout &lt;&lt; p.second.second &lt;&lt; '\\n';  // 3\n</code></pre>","tags":["C++","implementare","structuri de date"]},{"location":"cppintro/stl/#structura-stdtuple","title":"Structura std::tuple","text":"<p>Aceast\u0103 structur\u0103 de date reprezint\u0103 o generalizare a structurii <code>std::pair</code> v\u0103 permite s\u0103 folosi\u021bi o combina\u021bie de tipuri de date mai complexe, \u00eentr-o manier\u0103 mult mai u\u0219oar\u0103 dec\u00e2t a\u021bi face-o dac\u0103 a\u021bi folosi <code>pair</code> sau <code>vector</code>, profit\u00e2nd de avantajul c\u0103 putem \u021bine tipuri de date diferite \u00een fiecare dintre pozi\u021bii. Pentru a folosi tuple, va trebui s\u0103 include\u021bi <code>&lt;tuple&gt;</code>.</p> <p>Chiar dac\u0103 putem \u021bine valori multiple folosind pair-uri imbricate, tuplurile vor face acest lucru mult mai u\u0219or.</p> <ul> <li><code>tuple&lt;tip1, tip2, ..., tipN&gt; t</code>: Cre\u0103m un tuplu cu \\(N\\) valori, a \\(i\\)-a   valoare av\u00e2nd \\(tip_i\\).</li> <li><code>make_tuple(a, b, c, ..., d)</code>: Returneaz\u0103 un tuplu cu valorile scrise \u00een   parantez\u0103</li> <li><code>tie(a, b, c, ..., d) = t</code>: Set\u0103m \\(a, b, c, \\dots, d\\) la valorile din tuplul   \\(t\\) \u00een ordinea dat\u0103.</li> <li><code>get&lt;i&gt;(t)</code>: Returneaz\u0103 cea de-a \\(i\\)-a valoare din tuplul \\(t\\). Putem folosi   aceast\u0103 sintax\u0103 \u0219i pentru a schimba valoarea din \\(t\\).</li> </ul> <p>Aceast\u0103 opera\u021bie merge doar dac\u0103 \\(i\\) este o constant\u0103, nu putem schimba valorile dac\u0103 \\(i\\) nu este o constant\u0103.</p> <pre><code>tuple&lt;int, int, int&gt; t{3, 4, 5};\n\nint i = 1;\ncout &lt;&lt; get&lt;i&gt;(t) &lt;&lt; '\\n';  // eroare\n</code></pre> <p>Mai jos pute\u021bi g\u0103si un exemplu de folosire a acestor instruc\u021biuni.</p> <pre><code>int a = 3, b = 4, c = 5;\ntuple&lt;int, int, int&gt; t = tie(a, b, c);\n\ncout &lt;&lt; get&lt;0&gt;(t) &lt;&lt; \" \" &lt;&lt; get&lt;1&gt;(t) &lt;&lt; \" \" &lt;&lt; get&lt;2&gt;(t) &lt;&lt; '\\n';  // 3 4 5\n\nget&lt;0&gt;(t) = 7;\ncout &lt;&lt; get&lt;0&gt;(t) &lt;&lt; \" \" &lt;&lt; get&lt;1&gt;(t) &lt;&lt; \" \" &lt;&lt; get&lt;2&gt;(t) &lt;&lt; '\\n';  // 7 4 5\n\ntuple&lt;string, string, int&gt; tp2 = make_tuple(\"Hello\", \"world\", 100);\n\nstring s1, s2;\nint x;\ntie(s1, s2, x) = tp2;\n\ncout &lt;&lt; s1 &lt;&lt; \" \" &lt;&lt; s2 &lt;&lt; \" \" &lt;&lt; x &lt;&lt; '\\n';  // Hello world 100\n</code></pre>","tags":["C++","implementare","structuri de date"]},{"location":"cppintro/stl/#iteratori","title":"Iteratori","text":"<p>Iteratorii sunt structuri care pot fi utilizate s\u0103 identifice \u0219i traverseze elementele unui container STL. Ei sunt implementa\u021bi numai la structurile cu acces aleatoriu (toate mai pu\u021bin <code>queue</code>, <code>stack</code> \u0219i <code>priority_queue</code>).</p>","tags":["C++","implementare","structuri de date"]},{"location":"cppintro/stl/#glosar-iteratori","title":"Glosar iteratori","text":"<ul> <li>range reprezint\u0103 un interval de elemente de tip <code>[start, end)</code>.</li> <li>iterator de \u00eenceput: iterator care marcheaz\u0103 \u00eenceputul unui range.</li> <li>iterator past-the-end: iterator care marcheaz\u0103 finalul unui range. De\u0219i uneori   poate fi accesat, \u00een cele mai multe cazuri accesarea lui duce la erori (de   exemplu, rezultatul pentru <code>.end()</code>).</li> </ul>","tags":["C++","implementare","structuri de date"]},{"location":"cppintro/stl/#cum-obtin-un-iterator","title":"Cum ob\u021bin un iterator?","text":"<ul> <li><code>.begin()</code> - iterator la primul element din structur\u0103;</li> <li><code>.end()</code> - iterator past-the-end pentru structur\u0103;</li> <li><code>.rbegin()</code> - iterator invers la ultimul element din structur\u0103;</li> <li><code>.rend()</code> - iterator invers past-the-beginning pentru structur\u0103.</li> </ul>","tags":["C++","implementare","structuri de date"]},{"location":"cppintro/stl/#ce-pot-face-cu-un-iterator","title":"Ce pot face cu un iterator?","text":"<ul> <li>S\u0103 parcurgi structura</li> <li>Fiecare iterator permite s\u0103 \u00eel incrementezi (<code>++it</code>) s\u0103 se duc\u0103 mai departe.</li> <li>Putem folosi \u0219i <code>it++</code>, dar de obicei este mai lent.</li> <li>S\u0103 \u00eel pui drept parametru la o func\u021bie</li> <li>Multe func\u021bii din <code>&lt;algorithm&gt;</code> care merg pe range-uri cer un iterator de     \u00eenceput \u0219i un iterator \"past-the-end\".<ul> <li>De exemplu, func\u021bia <code>sort()</code> cere doi iteratori: unul care marcheaz\u0103   \u00eenceputul \u0219i elementul de dup\u0103 sf\u00e2r\u0219it (cum ar fi <code>begin()</code> \u0219i   <code>end()</code>).</li> </ul> </li> <li>Structurile <code>std::vector</code> \u0219i <code>std::deque</code> ofer\u0103 \u0219i func\u021biile <code>.erase()</code>     \u0219i <code>.insert()</code><ul> <li>Func\u021bia <code>.insert()</code> adaug\u0103 un element \u00eenaintea elementului iteratorului.</li> <li>Func\u021bia <code>.erase()</code> poate primi un singur argument, elementul care s\u0103 fie   \u0219ters, sau dou\u0103 argumente, range-ul pe care s\u0103 \u00eel \u0219tearg\u0103.</li> </ul> </li> <li>Foarte multe func\u021bii returneaz\u0103 iteratori, exemple fiind func\u021biile   <code>lower_bound()</code> \u0219i <code>upper_bound()</code> din diverse structuri de date precum   <code>std::set</code>, <code>std::map</code>.</li> </ul>","tags":["C++","implementare","structuri de date"]},{"location":"cppintro/stl/#structuri-de-date-liniare","title":"Structuri de date liniare","text":"<p>Observa\u021bie</p> <p>Toate aceste structuri de date au \u00een spatele implement\u0103rii lor din STL o structur\u0103 de tip deque.</p>","tags":["C++","implementare","structuri de date"]},{"location":"cppintro/stl/#structura-stdqueue","title":"Structura std::queue","text":"<p>\u00cen general, folosim aceast\u0103 structur\u0103 de date pentru a simula func\u021bionalit\u0103\u021bile unei cozi. Pentru a folosi std::queue, avem nevoie de biblioteca <code>&lt;queue&gt;</code>.</p> <p>De\u0219i pentru mai multe detalii, pute\u021bi accesa articolul nostru despre cozi, mai jos pute\u021bi g\u0103si un exemplu de folosire a acestor instruc\u021biuni.</p> <pre><code>queue&lt;int&gt; q;\nq.push(2);\nq.push(4);\n\nwhile (!q.empty()) {\n    // Acces\u0103m v\u00e2rful cozii cu front()\n    int val = q.front();\n    q.pop();\n\n    cout &lt;&lt; val &lt;&lt; \" \";\n}\ncout &lt;&lt; '\\n';\n\n// Se va afi\u0219a 2 4\n</code></pre>","tags":["C++","implementare","structuri de date"]},{"location":"cppintro/stl/#structura-stdstack","title":"Structura std::stack","text":"<p>\u00cen general, folosim aceast\u0103 structur\u0103 de date pentru a simula func\u021bionalit\u0103\u021bile unei stive. Pentru a folosi std::stack, avem nevoie de biblioteca <code>&lt;stack&gt;</code>.</p> <p>De\u0219i pentru mai multe detalii, pute\u021bi accesa articolul nostru despre stive, mai jos pute\u021bi g\u0103si un exemplu de folosire a acestor instruc\u021biuni.</p> <pre><code>stack&lt;int&gt; s;\ns.push(5);\ns.push(8);\n\nwhile (!s.empty()) {\n    // Acces\u0103m v\u00e2rful cozii cu top()\n    int val = s.top();\n    s.pop();\n\n    cout &lt;&lt; val &lt;&lt; \" \";\n}\ncout &lt;&lt; '\\n';\n\n// Se va afi\u0219a 8 5\n</code></pre>","tags":["C++","implementare","structuri de date"]},{"location":"cppintro/stl/#structura-stddeque","title":"Structura std::deque","text":"<p>\u00cen general, folosim aceast\u0103 structur\u0103 de date pentru a simula func\u021bionalit\u0103\u021bile unui deque. Pentru a folosi std::deque, avem nevoie de biblioteca <code>&lt;deque&gt;</code>.</p> <p>De\u0219i pentru mai multe detalii, pute\u021bi accesa articolul nostru despre deques, mai jos pute\u021bi g\u0103si un exemplu de folosire a acestor instruc\u021biuni.</p> <p>Accesarea pozi\u021biilor oarecare</p> <p>Spre deosebire de <code>stack</code> \u0219i <code>queue</code>, <code>deque</code> permite accesarea pozi\u021biilor oarecare, la fel ca la <code>vector</code>. \u00cen multe contexte, putem spune c\u0103 <code>deque</code> este un <code>vector</code> mai complex, cu toate c\u0103 un dezavantaj ar fi viteza un pic mai redus\u0103 a instruc\u021biunilor la <code>deque</code> spre deosebire de <code>vector</code>.</p> <pre><code>deque&lt;int&gt; d;\nd.push_front(4);\nd.push_front(5);\nd.push_back(7);\nd.push_back(8);\nd.push_front(3);\n\n// Deque-ul con\u021bine 3 5 4 7 8\n\n// Putem accesa valori din pozi\u021bii oarecare, ca la vector\nint x = d[3];\n\nwhile (!d.empty()) {\n    // Acces\u0103m prima valoare\n    int val = d.front();\n    cout &lt;&lt; val &lt;&lt; \" \";\n\n    // \u0218tergem prima valoare\n    d.pop_front();\n\n    // Dac\u0103 mai avem elemente...\n    if (d.size() &gt; 0) {\n        // Acces\u0103m ultima valoare...\n        val = d.back();\n\n        // ...\u0219i o \u0219tergem\n        d.pop_back();\n\n        cout &lt;&lt; val &lt;&lt; \" \";\n    }\n}\n\ncout &lt;&lt; '\\n';\n// Afi\u0219\u0103m 3 8 5 7 4\n</code></pre>","tags":["C++","implementare","structuri de date"]},{"location":"cppintro/stl/#structuri-de-date-arborescente","title":"Structuri de date arborescente","text":"<p>Structurile de date arborescente ne permit s\u0103 putem lucra cu valori ordonate \u00een mod dinamic, av\u00e2nd o performan\u021b\u0103 foarte bun\u0103, complexitatea opera\u021biilor fiind \u00een cele mai multe cazuri logaritimic\u0103, deoarece se bazeaz\u0103 pe diver\u0219i arbori binari care permit sort\u0103ri dintre cele mai rapide.</p>","tags":["C++","implementare","structuri de date"]},{"location":"cppintro/stl/#structura-stdmap","title":"Structura std::map","text":"<p>Un map este o structur\u0103 de date arborescent\u0103 care ne permite s\u0103 p\u0103str\u0103m pentru fiecare cheie o valoare specific\u0103, fiind foarte similar ca principiu cu func\u021biile de la matematic\u0103. Pentru a putea folosi <code>std::map</code>, va trebui s\u0103 includem biblioteca <code>&lt;map&gt;</code>. Sintaxa acestuia va fi <code>map &lt;tip1, tip2&gt; nume</code>, iar tipurile de date vor putea fi cele cunoscute, inclusiv vectori \u0219i stringuri. Cheile vor fi ordonate cresc\u0103tor, datorit\u0103 implement\u0103rii bazate pe red-black trees.</p> <p>Dintre cele mai importante func\u021bii, vom enumera urm\u0103toarele:</p> <ul> <li>Atribuirea: <code>mp[x] = y;</code> face valoarea cheii \\(x\\) s\u0103 devin\u0103 \\(y\\). \u00cen mod   particular, dac\u0103 \u00eencerc\u0103m s\u0103 lucr\u0103m cu o cheie \\(x_1\\) neini\u021bializat\u0103, ea va fi   ini\u021bializat\u0103 cu 0, a\u0219a cum se va putea vedea \u00een codul de mai jos.</li> <li>G\u0103sirea unui element: <code>mp.find(x) != mp.end()</code> verific\u0103 dac\u0103 \\(x\\) exist\u0103 \u00een   map, f\u0103r\u0103 a crea un element nou \u00een map.</li> <li>\u0218tergerea: <code>mp.erase(x)</code> \u0219terge instan\u021ba cheii \\(x\\) din map. Dac\u0103 \\(x\\) nu se   afl\u0103 \u00een map, nu se \u00eent\u00e2mpl\u0103 nimic.</li> <li>Cur\u0103\u021barea: <code>mp.clear()</code> \u0219terge toate cheile din map.</li> <li>Lower_bound: <code>mp.lower_bound(x)</code> returneaz\u0103 un iterator care \u021bine cea mai mic\u0103   valoare mai mare sau egal\u0103 cu valoarea \\(x\\) sau <code>mp.end()</code> dac\u0103 nu avem o   asemenea valoare.</li> <li>Upper_bound: <code>mp.upper_bound(x)</code> returneaz\u0103 un iterator care \u021bine cea mai mic\u0103   valoare strict mai mare dec\u00e2t valoarea \\(x\\) sau <code>mp.end()</code> dac\u0103 nu avem o   asemenea valoare.</li> <li>Afi\u0219area valorilor se poate face \u00een dou\u0103 moduri, fie cu iteratori specifici,   fie cu tipul auto.</li> </ul> <p>Cea mai simpl\u0103 utilizare a unui map va fi drept un vector de frecven\u021b\u0103 dinamic, deoarece vom putea stoca valori oric\u00e2t de mari \u00eentr-o complexitate logaritmic\u0103 per opera\u021bie. Mai jos g\u0103si\u021bi exemple de utilizare a map-ului.</p> <pre><code>map&lt;int, int&gt; mp;\n\nmp[2] = 5;\nmp[4] = 6;\n\ncout &lt;&lt; mp[2] &lt;&lt; '\\n';  // 2\ncout &lt;&lt; mp[3] &lt;&lt; '\\n';  // 0\n\n// Not\u0103: it este de tipul map&lt;int,int&gt;::iterator.\n// Nimeni nu vrea s\u0103 scrie asta, a\u0219a c\u0103 este mai comun s\u0103\n// se scrie cu auto.\n\n// Se va afi\u0219a:\n//\n//   2 5\n//   3 0\n//   4 6\n\nfor (auto it = mp.begin(); it != mp.end(); it++) {\n    cout &lt;&lt; it-&gt;first &lt;&lt; \" \" &lt;&lt; it-&gt;second &lt;&lt; '\\n';\n}\nmp.erase(3);\n\nmp.clear();\n\nmp[3] = 4;\nmp[3] = 5;\nmp[6] = 1;\n\nfor (auto it : mp) {\n    cout &lt;&lt; it.first &lt;&lt; \" \" &lt;&lt; it.second &lt;&lt; '\\n';\n}\n\nif (mp.find(10) != mp.end()) {\n    cout &lt;&lt; \"Cheia 10 este in map\\n\";\n} else {\n    cout &lt;&lt; \"Cheia 10 nu este in map\\n\";\n}\n</code></pre>","tags":["C++","implementare","structuri de date"]},{"location":"cppintro/stl/#structura-stdset","title":"Structura std::set","text":"<p>Un set este o structur\u0103 de date arborescent\u0103 care ne permite s\u0103 p\u0103str\u0103m o list\u0103 de valori care apare, ordonat\u0103 cresc\u0103tor, fiind foarte similar ca principiu cu mul\u021bimile de la matematic\u0103. Pentru a putea folosi std::set, va trebui s\u0103 includem biblioteca <code>&lt;set&gt;</code>. Sintaxa acestuia va fi <code>set &lt;tip&gt; nume</code>, iar tipurile de date vor putea fi cele cunoscute, inclusiv vectori \u0219i stringuri.  </p> <p>Dintre cele mai importante func\u021bii, vom enumera urm\u0103toarele:</p> <ul> <li>Inserarea: <code>s.insert(x)</code> adaug\u0103 \\(x\\) \u00een setul \\(s\\). \u00cen mod particular, dac\u0103   \u00eencerc\u0103m s\u0103 inser\u0103m o valoare care deja este \u00een set, nu se va \u00eent\u00e2mpla nimic.</li> <li>G\u0103sirea unui element: La fel ca la map, <code>s.find(x) != s.end()</code> verific\u0103 dac\u0103   \\(x\\) exist\u0103 \u00een set, f\u0103r\u0103 a crea un element nou \u00een set.</li> <li>\u0218tergerea: <code>s.erase(x)</code> \u0219terge \\(x\\) din set. Dac\u0103 \\(x\\) nu se afl\u0103 \u00een set, nu se   \u00eent\u00e2mpl\u0103 nimic.</li> <li>Cur\u0103\u021barea: <code>s.clear()</code> \u0219terge toate cheile din set.</li> <li>Lower_bound: <code>s.lower_bound(x)</code> returneaz\u0103 un iterator care \u021bine cea mai mic\u0103   valoare mai mare sau egal\u0103 cu valoarea \\(x\\) sau <code>s.end()</code> dac\u0103 nu avem o   asemenea valoare.</li> <li>Upper_bound: <code>s.upper_bound(x)</code> returneaz\u0103 un iterator care \u021bine cea mai mic\u0103   valoare strict mai mare dec\u00e2t valoarea \\(x\\) sau <code>s.end()</code> dac\u0103 nu avem o   asemenea valoare.</li> <li>Afi\u0219area valorilor se poate face \u00een dou\u0103 moduri, fie cu iteratori specifici,   fie cu tipul auto.</li> </ul> <p>Cea mai simpl\u0103 utilizare a unui set va fi drept o mul\u021bime dinamic\u0103, deoarece vom putea stoca valori oric\u00e2t de mari \u00eentr-o complexitate logaritmic\u0103 per opera\u021bie. Mai jos g\u0103si\u021bi exemple de utilizare a setului. Totu\u0219i, nu vom putea p\u0103stra informa\u021bii mai avansate, precum pozi\u021bia relativ\u0103, acestea fiind discutate ulterior \u00een articol, c\u00e2nd vorbim despre policy based data structures.</p> <pre><code>set&lt;int&gt; s;\n\ns.insert(1);   // [1]\ns.insert(14);  // [1, 14]\ns.insert(9);   // [1, 9, 14]\ns.insert(2);   // [1, 2, 9, 14]\n\ncout &lt;&lt; *s.upper_bound(7) &lt;&lt; '\\n';  // 9\ncout &lt;&lt; *s.upper_bound(9) &lt;&lt; '\\n';  // 14\n\ncout &lt;&lt; *s.lower_bound(5) &lt;&lt; '\\n';  // 9\ncout &lt;&lt; *s.lower_bound(9) &lt;&lt; '\\n';  // 9\n\ncout &lt;&lt; *s.begin() &lt;&lt; '\\n';   // 1\ncout &lt;&lt; *s.rbegin() &lt;&lt; '\\n';  // 14\n\nauto it = s.end();\ncout &lt;&lt; *(--it) &lt;&lt; '\\n';  // 14\n\ns.erase(s.upper_bound(6));  // [1, 2, 14]\n\nfor (auto it = s.begin(); it != s.end(); it++) {\n    cout &lt;&lt; *it &lt;&lt; '\\n';  // 1, 2, 14\n}\n\nfor (auto it = s.rbegin(); it != s.rend(); it++) {\n    cout &lt;&lt; *it &lt;&lt; '\\n';  // 14, 2, 1\n}\n</code></pre>","tags":["C++","implementare","structuri de date"]},{"location":"cppintro/stl/#stdunordered_map-si-stdunordered_set","title":"std::unordered_map \u0219i std::unordered_set","text":"<p>At\u00e2t <code>std::set</code> c\u00e2t \u0219i <code>std::map</code> au versiuni unordered ale acestora, care ac\u021bioneaz\u0103 \u00een mod similar cu structuri de tip hashmap, codific\u00e2nd valorile sub diverse forme pentru a evita coliziuni de diverse moduri. Totu\u0219i, aici nu vom discuta teoria din spatele hashurilor, ci doar containerele \u00een sine articolul nostru despre hashing. De\u0219i func\u021biile pe care cele dou\u0103 structuri de date le au sunt identice cu cele ale echivalentelor lor sortate, uneori pot deveni foarte utile \u00een concursuri.</p> <p><code>std::unordered_map</code> este versiunea nesortat\u0103 a map-ului, fiind inclus \u00een biblioteca <code>&lt;unordered_map&gt;</code>. Sintaxa acestuia va fi <code>unordered_map &lt;tip1, tip2&gt; nume</code>.</p> <p><code>std::unordered_set</code> este versiunea nesortat\u0103 a set-ului, fiind inclus \u00een biblioteca <code>&lt;unordered_set&gt;</code>. Sintaxa acestuia va fi <code>unordered_set &lt;tip&gt; nume</code>.</p> <p>Complexitatea opera\u021biilor descrise la map, respectiv set pentru cele dou\u0103 structuri este \u00een medie \\(\\mathcal{O}(1)\\) amortizat, dar \u00een cel mai r\u0103u caz, complexitatea final\u0103 este \\(\\mathcal{O}(n)\\) per opera\u021bie, unde \\(n\\) este dimensiunea structurii de date \u00een cauz\u0103. Totu\u0219i, a\u0219a cum este explicat \u0219i \u00een articolul despre hashing, aceast\u0103 problem\u0103 poate fi rezolvat\u0103 folosind un hash custom, dar constanta devine \u00een multe cazuri suficient de slab\u0103 \u00eenc\u00e2t s\u0103 nu mai fie optim\u0103 folosirea structurilor de tip unordered.</p>","tags":["C++","implementare","structuri de date"]},{"location":"cppintro/stl/#stdmultimap-si-stdmultiset","title":"std::multimap \u0219i std::multiset","text":"<p>De asemenea, <code>std::set</code> \u0219i <code>std::map</code> au \u0219i versiuni care ne permit s\u0103 \u021binem mai multe instan\u021be ale aceleia\u0219i valori, <code>std::multiset</code> fiind de departe cel mai utilizat \u00een practic\u0103. Acestea au acelea\u0219i func\u021bii specifice cu cele \u00eent\u00e2lnite la set \u0219i map, dar trebuie s\u0103 fim aten\u021bi la un aspect foarte important, sintaxa fiind la fel (<code>multiset &lt;tip&gt; nume</code>).</p> <p>Erase \u0219i multiseturile</p> <p>Dac\u0103 folosim erase \u00een acela\u0219i mod cum am explicat la set, toate valorile egale cu \\(x\\) se \u0219terg, deci trebuie s\u0103 folosim <code>ms.erase(ms.find(val))</code>.</p> <ul> <li><code>ms.erase(x)</code> - \u0219terge toate apari\u021biile lui \\(x\\) din multiset.</li> <li><code>ms.erase(ms.find(x))</code> - \u0219terge o singur\u0103 apari\u021bie a lui \\(x\\) din multiset.</li> </ul> <p>La fel ca la set \u0219i map, complexitatea opera\u021biilor este logaritimic\u0103, cu o singur\u0103 excep\u021bie, aceasta fiind func\u021bia count, care num\u0103r\u0103 valorile egale cu x. Totu\u0219i, complexitatea lui count este liniar\u0103, fapt pentru care nu se recomand\u0103 folosirea acestei func\u021bii.</p>","tags":["C++","implementare","structuri de date"]},{"location":"cppintro/stl/#structura-stdpriority_queue","title":"Structura std::priority_queue","text":"<p>O coad\u0103 de priorit\u0103\u021bi este o coad\u0103 pe care o folosim pentru a p\u0103stra datele \u00eentr-o ordine dat\u0103 (by default, descresc\u0103toare). Implementarea ei este bazat\u0103 pe o structur\u0103 de date de tip heap, permi\u021b\u00e2nd opera\u021bii de push, pop \u0219i top, \u00een mod similar cu cele de la coad\u0103, cu diferen\u021ba c\u0103 valorile sunt \u021binute ordonat. Complexitatea opera\u021biilor este \\(\\mathcal{O}(\\log n)\\). Chiar dac\u0103 aceast\u0103 structur\u0103 de date este un pic mai rapid\u0103 dec\u00e2t set \u0219i map, un mare dezavantaj este dat de faptul c\u0103 doar elementul din v\u00e2rf poate fi accesat, \u00een mod similar cu func\u021bionalitatea heap-ului.</p> <p>\u00cen general, vom vrea s\u0103 folosim o coad\u0103 de priorit\u0103\u021bi atunci c\u00e2nd vrem s\u0103 afl\u0103m mai rapid cel mai mare sau cel mai mic element, constanta fiind bun\u0103, fapt ce face aceast\u0103 structur\u0103 de date principala metod\u0103 de a implementa diver\u0219i algoritmi de tip greedy mai complica\u021bi, cel mai cunoscut fiind algoritmul lui Dijkstra pe grafuri cu costuri.</p> <p>Pentru a folosi aceast\u0103 structur\u0103 de date, biblioteca <code>&lt;queue&gt;</code> este necesar\u0103. Sintaxa unei cozi de priorit\u0103\u021bi este <code>priority_queue&lt;tip&gt; nume</code>. Mai jos g\u0103si\u021bi un exemplu de implementare a acestei structuri de date.</p> <pre><code>priority_queue&lt;int&gt; pq;\npq.push(5);\npq.push(9);\npq.push(1);\n\nwhile (!pq.empty()) {\n    int val = pq.top();\n    pq.pop();\n\n    cout &lt;&lt; val &lt;&lt; \" \";\n}\n\n// Se va afi\u0219a 9 5 1\n</code></pre> <p>Accesarea valorilor \u00een ordine cresc\u0103toare</p> <p>Pentru a accesa valorile \u00een ordine cresc\u0103toare, avem dou\u0103 op\u021biuni: Fie le ad\u0103ug\u0103m cu semn schimbat, f\u0103r\u0103 a schimba sintaxa structurii de date, fie ad\u0103ug\u0103m un comparator custom. Mai jos ave\u021bi sintaxa cu comparator custom.</p> <pre><code>struct cmp {\n    bool operator()(int a, int b) { return a &gt; b; }\n};\n\npriority_queue&lt;int, vector&lt;int&gt;, cmp&gt; q;\n</code></pre>","tags":["C++","implementare","structuri de date"]},{"location":"cppintro/stl/#policy-based-data-structures","title":"Policy based data structures","text":"<p>Structurile de date men\u021bionate anterior, de\u0219i puternice, nu ne permit s\u0103 r\u0103spundem la \u00eentreb\u0103ri de tipul:</p> <ul> <li>Care este a \\(k\\)-a valoare \u00een ordine cresc\u0103toare prezent\u0103 \u00een set/map?</li> <li>C\u00e2te valori sunt mai mici dec\u00e2t \\(x\\) \u00een set/map?</li> </ul> <p>De\u0219i aceste \u00eentreb\u0103ri pot fi rezolvate folosind structuri de date complexe, precum arborii de intervale dinamici sau eventual folosind normaliz\u0103ri dificil de implementat, exist\u0103 o op\u021biune inbuilt destul de u\u0219or de folosit \u0219i destul de rapid\u0103, complexitatea opera\u021biilor fiind \\(\\mathcal{O}(\\log n)\\), la fel ca la set \u0219i map.</p> <p>Aten\u021bie la constante</p> <p>Totu\u0219i, se remarc\u0103 faptul c\u0103 constanta este una foarte mare, fiind mult mai \u00eenceat\u0103 dec\u00e2t alte metode care ar fi mai greu de implementat.</p> <p>Aceast\u0103 structur\u0103 de date ne va permite s\u0103 folosim facilit\u0103\u021bile setului, \u00eempreun\u0103 cu dou\u0103 func\u021bii noi:</p> <ul> <li><code>find_by_order(k)</code> - Al \\(k\\)-lea cel mai mare element, \u00eencep\u00e2nd de la 0.</li> <li><code>order_of_key(x)</code> - Num\u0103rul de valori strict mai mici dec\u00e2t \\(x\\).</li> </ul> <p>Pentru a putea folosi aceast\u0103 structur\u0103 de date, trebuie s\u0103 declar\u0103m urm\u0103toarele biblioteci, namespace-uri \u0219i typedefs:</p> <pre><code>#include &lt;ext/pb_ds/assoc_container.hpp&gt;\n#include &lt;ext/pb_ds/tree_policy.hpp&gt;\n\nusing namespace __gnu_pbds;\n\nusing order_set = tree&lt;int, null_type, less&lt;int&gt;, rb_tree_tag,\n                       tree_order_statistics_node_update&gt;;\n</code></pre> <p>Alte tipuri de date</p> <p>Pentru a folosi policy based data structures \u0219i cu alte tipuri de date, trebuie \u00eenlocuite cele dou\u0103 int-uri cu tipul de date potrivit. De exemplu,</p> <pre><code>using order_set = tree&lt;int, null_type, less&lt;int&gt;, rb_tree_tag,\n                       tree_order_statistics_node_update&gt;;\n</code></pre> <p>ne permite s\u0103 \u021binem pair-uri \u0219i s\u0103 oper\u0103m \u00een mod similar, fiind foarte util atunci c\u00e2nd vrem s\u0103 lucr\u0103m cu duplicate \u0219i eventual s\u0103 stoc\u0103m valori mai complexe.</p> <p>Mai jos g\u0103si\u021bi un exemplu de folosire a acestei structuri de date, a\u0219a cum a fost folosit\u0103 \u00een problema AIB de pe pbinfo.</p> <pre><code>#include &lt;ext/pb_ds/assoc_container.hpp&gt;\n#include &lt;ext/pb_ds/tree_policy.hpp&gt;\n#include &lt;iostream&gt;\n\nusing namespace std;\nusing namespace __gnu_pbds;\n\nusing order_set = tree&lt;int, null_type, less&lt;int&gt;, rb_tree_tag,\n                       tree_order_statistics_node_update&gt;;\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(nullptr);\n\n    int n;\n    cin &gt;&gt; n;\n\n    order_set X;\n\n    for (int i = 1; i &lt;= n; i++) {\n        int x;\n        cin &gt;&gt; x;\n\n        cout &lt;&lt; X.order_of_key(x) &lt;&lt; \" \";\n        X.insert(x);\n\n        // X.find_by_order(x) ar afla al x-lea cel mai mare element\n    }\n    return 0;\n}\n</code></pre> <p>Pe l\u00e2ng\u0103 o mare parte din problemele cu structuri de date, aceast\u0103 structur\u0103 de date poate fi aplicat\u0103 \u0219i pentru a rezolva problema Greetings de pe Codeforces.</p>","tags":["C++","implementare","structuri de date"]},{"location":"cppintro/stl/#concluzii","title":"Concluzii","text":"<p>Structurile de date din STL sunt unul dintre cele mai importante unelte pe care le pute\u021bi folosi \u00een programare \u0219i cunoa\u0219terea lor este esen\u021bial\u0103 pentru a putea fi programatori c\u00e2t mai buni. De asemenea, flexibilitatea lor u\u0219ureaz\u0103 multe implement\u0103ri \u00een special \u00een condi\u021bii de concurs, unde timpul este limitat.</p> <p>Totu\u0219i, trebuie s\u0103 ave\u021bi \u00een vedere faptul c\u0103 este de preferat \u00een\u021belegerea con\u021binuturilor, pentru a evita folosirea lor oric\u00e2nd \u0219i oricum, f\u0103r\u0103 a avea \u00een vedere abord\u0103rile alternative care ar putea exista la probleme, lucru care se remarc\u0103 mai ales la structurile de date arborescente, precum <code>std::set</code> \u0219i <code>std::map</code>.</p>","tags":["C++","implementare","structuri de date"]},{"location":"cppintro/stl/#resurse-suplimentare","title":"Resurse suplimentare","text":"<ul> <li>STL - Alex Vasiluta</li> <li>STL - infoarena</li> <li>Introduction to Data Structures - USACO   Guide</li> <li>Introduction to Sets &amp; Maps - USACO   Guide</li> <li>More Operations on Sorted Sets - USACO   Guide</li> <li>STL -   pbinfo</li> <li>Policy Based Data Structures -   Codeforces</li> </ul>","tags":["C++","implementare","structuri de date"]},{"location":"cppintro/strings/","title":"\u0218iruri de caractere","text":"","tags":["C++","implementare","optimizare","siruri de caractere"]},{"location":"cppintro/strings/#introducere","title":"Introducere","text":"<p>Un \u0219ir de caractere este un tablou care stocheaz\u0103 caractere. \u00cen limbajul C++, putem stoca aceste \u0219iruri \u00een dou\u0103 moduri: fie folosind un tablou static, similar limbajului C, fie folosind tipul de date <code>std::string</code>. \u00cen acest articol, vom analiza ambele op\u021biuni, incluz\u00e2nd avantajele \u0219i dezavantajele lor.</p>","tags":["C++","implementare","optimizare","siruri de caractere"]},{"location":"cppintro/strings/#tipul-char-si-tabelul-ascii","title":"Tipul <code>char</code> \u0219i tabelul ASCII","text":"<p>A\u0219a cum a\u021bi v\u0103zut c\u00e2nd am discutat despre tipurile de date, limbajul C++ dispune de tipul de date <code>char</code>, utilizat pentru a stoca caractere. De\u0219i valorile stocate \u00eentr-un <code>char</code> sunt \u00een intervalul [-128, 127] (pentru reprezent\u0103ri cu semn), cele mai utilizate caractere sunt cele afi\u0219abile, care apar\u021bin intervalului [32, 127].</p> <p>Codificarea caracterelor</p> <p>Standardul care atribuie valori caracterelor se nume\u0219te ASCII (American Standard Code for Information Interchange). Caracterele din intervalul [0, 31] nu sunt afi\u0219abile, fiind utilizate pentru instruc\u021biuni de sistem.</p> <p>Printre cele mai importante coduri ASCII sunt:</p> <ul> <li>32 (spa\u021biu)</li> <li>48-57: cifrele 0-9</li> <li>65-90: literele mari ale alfabetului englez (A-Z)</li> <li>97-122: literele mici ale alfabetului englez (a-z)</li> </ul>","tags":["C++","implementare","optimizare","siruri de caractere"]},{"location":"cppintro/strings/#transformari-intre-litere-si-cifre","title":"Transform\u0103ri \u00eentre litere \u0219i cifre","text":"<p>Putem simplifica lucrul cu caractere folosind valorile ASCII, f\u0103r\u0103 a gestiona direct codurile. De exemplu:</p> <ul> <li>Cifre: Sc\u0103de\u021bi '0' din caracter.</li> <li>Litere: Ad\u0103uga\u021bi sau sc\u0103de\u021bi 32 pentru a transforma \u00eentre litere mari \u0219i   mici.</li> </ul> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    char c = '5';\n    cout &lt;&lt; (int)c &lt;&lt; '\\n';          // 53 - ASCII pentru '5'\n    cout &lt;&lt; (int)(c - '0') &lt;&lt; '\\n';  // 5  - converte\u0219te caracterul '5' \u00een num\u0103r\n\n    c = 'P';\n    cout &lt;&lt; (int)c &lt;&lt; '\\n';          // 80 - ASCII pentru 'P'\n    cout &lt;&lt; (int)(c - 'A') &lt;&lt; '\\n';  // 15 - indexul 'P' \u00een alfabet\n\n    c += 32;                         // 'P' -&gt; 'p'\n    cout &lt;&lt; (int)c &lt;&lt; '\\n';          // 112 - ASCII pentru 'p'\n    cout &lt;&lt; (int)(c - 'a') &lt;&lt; '\\n';  // 15  - indexul 'p' \u00een alfabetul mic\n\n    c = 'g';\n    cout &lt;&lt; (int)c &lt;&lt; '\\n';          // 103 - ASCII pentru 'g'\n    cout &lt;&lt; (int)(c - 'a') &lt;&lt; '\\n';  // 6   - indexul 'g' \u00een alfabetul mic\n\n    c -= 32;                         // 'g' -&gt; 'G'\n    cout &lt;&lt; (int)c &lt;&lt; '\\n';          // 71  - ASCII pentru 'G'\n    cout &lt;&lt; (int)(c - 'A') &lt;&lt; '\\n';  // 6   - indexul 'G' \u00een alfabetul mare\n\n    c = 35;             // caracterul '#'\n    cout &lt;&lt; c &lt;&lt; '\\n';  // #\n\n    c = 99;             // caracterul 'c'\n    cout &lt;&lt; c &lt;&lt; '\\n';  // c\n\n    return 0;\n}\n</code></pre> <p>Lista complet\u0103 a codurilor pentru caractere se g\u0103se\u0219te aici. Pentru convenien\u021b\u0103, o voi reproduce aici:</p> Dec Caracter Dec Caracter Dec Caracter Dec Caracter 0 NUL 32 `` 64 @ 96 ` 1 SOH 33 ! 65 A 97 a 2 STX 34 \" 66 B 98 b 3 ETX 35 # 67 C 99 c 4 EOT 36 $ 68 D 100 d 5 ENQ 37 % 69 E 101 e 6 ACK 38 &amp; 70 F 102 f 7 BEL 39 ' 71 G 103 g 8 BS 40 ( 72 H 104 h 9 TAB 41 ) 73 I 105 i 10 LF 42 * 74 J 106 j 11 VT 43 + 75 K 107 k 12 FF 44 , 76 L 108 l 13 CR 45 - 77 M 109 m 14 SO 46 . 78 N 110 n 15 SI 47 / 79 O 111 o 16 DLE 48 0 80 P 112 p 17 DC1 49 1 81 Q 113 q 18 DC2 50 2 82 R 114 r 19 DC3 51 3 83 S 115 s 20 DC4 52 4 84 T 116 t 21 NAK 53 5 85 U 117 u 22 SYN 54 6 86 V 118 v 23 ETB 55 7 87 W 119 w 24 CAN 56 8 88 X 120 x 25 EM 57 9 89 Y 121 y 26 SUB 58 : 90 Z 122 z 27 ESC 59 ; 91 [ 123 { 28 FS 60 &lt; 92 \\ 124 | 29 GS 61 = 93 ] 125 } 30 RS 62 &gt; 94 ^ 126 ~ 31 US 63 ? 95 _ 127 DEL","tags":["C++","implementare","optimizare","siruri de caractere"]},{"location":"cppintro/strings/#functii-pe-tipul-char","title":"Func\u021bii pe tipul <code>char</code>","text":"<p>Biblioteca standard <code>&lt;cctype&gt;</code> din C++ ofer\u0103 un set de func\u021bii predefinite utile pentru verificarea propriet\u0103\u021bilor caracterelor individuale. Aceste func\u021bii simplific\u0103 validarea \u0219i manipularea stringurilor, fiind ideale pentru lucrul cu date de tip text.</p>","tags":["C++","implementare","optimizare","siruri de caractere"]},{"location":"cppintro/strings/#functia-isdigit","title":"Func\u021bia <code>isdigit</code>","text":"<pre><code>int isdigit(int ch);\n</code></pre> <p>Verific\u0103 dac\u0103 un caracter anume este una din cele zece cifre zecimale: (0123456789).</p>","tags":["C++","implementare","optimizare","siruri de caractere"]},{"location":"cppintro/strings/#parametri","title":"Parametri","text":"<ul> <li><code>ch</code> - caracterul de clasificat</li> </ul>","tags":["C++","implementare","optimizare","siruri de caractere"]},{"location":"cppintro/strings/#valoare-returnata","title":"Valoare returnat\u0103","text":"<p>O valoare diferit\u0103 de zero \u00een cazul \u00een care caracterul este un caracter numeric, zero \u00een caz contrar.</p>","tags":["C++","implementare","optimizare","siruri de caractere"]},{"location":"cppintro/strings/#exemplu","title":"Exemplu","text":"<pre><code>cout &lt;&lt; isdigit('5') &lt;&lt; '\\n';  // 1\ncout &lt;&lt; isdigit('z') &lt;&lt; '\\n';  // 0\ncout &lt;&lt; isdigit('Q') &lt;&lt; '\\n';  // 0\ncout &lt;&lt; isdigit('.') &lt;&lt; '\\n';  // 0\n</code></pre>","tags":["C++","implementare","optimizare","siruri de caractere"]},{"location":"cppintro/strings/#functia-isalpha","title":"Func\u021bia <code>isalpha</code>","text":"<pre><code>int alpha(int ch);\n</code></pre> <p>Verific\u0103 dac\u0103 un caracter anume este alfabetic. Urm\u0103toarele caractere sunt considerate alfabetice:</p> <ul> <li>literele mari ABCDEFGHIJKLMNOPQRSTUVWXYZ</li> <li>literele mici abcdefghijklmnopqrstuvwxyz</li> </ul>","tags":["C++","implementare","optimizare","siruri de caractere"]},{"location":"cppintro/strings/#parametri_1","title":"Parametri","text":"<ul> <li><code>ch</code> - caracterul de clasificat</li> </ul>","tags":["C++","implementare","optimizare","siruri de caractere"]},{"location":"cppintro/strings/#valoare-returnata_1","title":"Valoare returnat\u0103","text":"<p>O valoare diferit\u0103 de zero \u00een cazul \u00een care caracterul este alfabetic, zero \u00een caz contrar.</p>","tags":["C++","implementare","optimizare","siruri de caractere"]},{"location":"cppintro/strings/#exemplu_1","title":"Exemplu","text":"<pre><code>cout &lt;&lt; isalpha('3') &lt;&lt; '\\n';  // 0\ncout &lt;&lt; isalpha('A') &lt;&lt; '\\n';  // 1\ncout &lt;&lt; isalpha('a') &lt;&lt; '\\n';  // 1\ncout &lt;&lt; isalpha('?') &lt;&lt; '\\n';  // 0\n</code></pre>","tags":["C++","implementare","optimizare","siruri de caractere"]},{"location":"cppintro/strings/#functia-isalnum","title":"Func\u021bia <code>isalnum</code>","text":"<pre><code>int isalnum(int ch);\n</code></pre> <p>Verific\u0103 dac\u0103 un caracter anume este alfanumeric. Urm\u0103toarele caractere sunt considerate alfanumerice:</p> <ul> <li>literele mari ABCDEFGHIJKLMNOPQRSTUVWXYZ</li> <li>literele mici abcdefghijklmnopqrstuvwxyz</li> <li>cifrele 0123456789</li> </ul> <p>Observa\u021bie</p> <p><code>isalnum(ch)</code> este echivalent cu <code>isdigit(ch) &amp;&amp; isalpha(ch)</code>.</p>","tags":["C++","implementare","optimizare","siruri de caractere"]},{"location":"cppintro/strings/#parametri_2","title":"Parametri","text":"<ul> <li><code>ch</code> - caracterul de clasificat</li> </ul>","tags":["C++","implementare","optimizare","siruri de caractere"]},{"location":"cppintro/strings/#valoare-returnata_2","title":"Valoare returnat\u0103","text":"<p>O valoare diferit\u0103 de zero \u00een cazul \u00een care caracterul este alfanumeric, zero \u00een caz contrar.</p>","tags":["C++","implementare","optimizare","siruri de caractere"]},{"location":"cppintro/strings/#exemplu_2","title":"Exemplu","text":"<pre><code>cout &lt;&lt; isalnum('7') &lt;&lt; '\\n';  // 1\ncout &lt;&lt; isalnum('z') &lt;&lt; '\\n';  // 1\ncout &lt;&lt; isalnum('@') &lt;&lt; '\\n';  // 0\ncout &lt;&lt; isalnum('P') &lt;&lt; '\\n';  // 1\n</code></pre>","tags":["C++","implementare","optimizare","siruri de caractere"]},{"location":"cppintro/strings/#functiile-islower-si-isupper","title":"Func\u021biile <code>islower</code> \u0219i <code>isupper</code>","text":"<pre><code>int islower(int ch);\nint isupper(int ch);\n</code></pre> <p>Verific\u0103 dac\u0103 un caracter anume este clasificat ca fiind unul mic, respectiv mare. Implicit, C consider\u0103 literele mari ca fiind ABCDEFGHIJKLMNOPQRSTUVWXYZ, iar cele mici ca abcdefghijklmnopqrstuvwxyz.</p>","tags":["C++","implementare","optimizare","siruri de caractere"]},{"location":"cppintro/strings/#parametri_3","title":"Parametri","text":"<ul> <li><code>ch</code> - caracterul de clasificat</li> </ul>","tags":["C++","implementare","optimizare","siruri de caractere"]},{"location":"cppintro/strings/#valoare-returnata_3","title":"Valoare returnat\u0103","text":"<p>O valoare diferit\u0103 de zero \u00een cazul \u00een care caracterul este mic, respectiv mare, zero \u00een caz contrar.</p>","tags":["C++","implementare","optimizare","siruri de caractere"]},{"location":"cppintro/strings/#exemplu_3","title":"Exemplu","text":"<pre><code>cout &lt;&lt; islower('a') &lt;&lt; '\\n';  // 1\ncout &lt;&lt; islower('?') &lt;&lt; '\\n';  // 0\n\ncout &lt;&lt; isupper('3') &lt;&lt; '\\n';  // 0\ncout &lt;&lt; isupper('A') &lt;&lt; '\\n';  // 1\n</code></pre>","tags":["C++","implementare","optimizare","siruri de caractere"]},{"location":"cppintro/strings/#functiile-tolower-si-toupper","title":"Func\u021biile <code>tolower</code> \u0219i <code>toupper</code>","text":"<pre><code>int toupper(int ch);\nint tolower(int ch);\n</code></pre> <p>Converte\u0219te un caracter dat \u00eentr-o liter\u0103 mare, respectiv mic\u0103, respectiv mare. C consider\u0103 literele mari ca fiind ABCDEFGHIJKLMNOPQRSTUVWXYZ, iar cele mici ca abcdefghijklmnopqrstuvwxyz.</p>","tags":["C++","implementare","optimizare","siruri de caractere"]},{"location":"cppintro/strings/#parametri_4","title":"Parametri","text":"<ul> <li><code>ch</code> - caracterul de convertit</li> </ul>","tags":["C++","implementare","optimizare","siruri de caractere"]},{"location":"cppintro/strings/#valoare-returnata_4","title":"Valoare returnat\u0103","text":"<p>Caracterul convertit sau <code>ch</code> dac\u0103 nu se poate efectua conversia.</p>","tags":["C++","implementare","optimizare","siruri de caractere"]},{"location":"cppintro/strings/#exemplu_4","title":"Exemplu","text":"<pre><code>cout &lt;&lt; (char)tolower('a') &lt;&lt; '\\n';  // a\ncout &lt;&lt; (char)tolower('A') &lt;&lt; '\\n';  // a\ncout &lt;&lt; (char)tolower('3') &lt;&lt; '\\n';  // 3\ncout &lt;&lt; (char)tolower('@') &lt;&lt; '\\n';  // @\n\ncout &lt;&lt; (char)toupper('a') &lt;&lt; '\\n';  // A\ncout &lt;&lt; (char)toupper('A') &lt;&lt; '\\n';  // A\ncout &lt;&lt; (char)toupper('3') &lt;&lt; '\\n';  // 3\ncout &lt;&lt; (char)toupper('@') &lt;&lt; '\\n';  // @\n</code></pre>","tags":["C++","implementare","optimizare","siruri de caractere"]},{"location":"cppintro/strings/#siruri-de-caractere-si-biblioteca-cstring","title":"\u0218iruri de caractere \u0219i biblioteca <code>&lt;cstring&gt;</code>","text":"<p>Biblioteca <code>&lt;cstring&gt;</code> ofer\u0103 o suit\u0103 de func\u021bii utile pentru lucrul cu \u0219iruri de caractere \u00een stilul C. Aceasta poate fi utilizat\u0103 pentru manipularea \u0219irurilor de caractere (vectori de tip <code>char</code>) prin func\u021bii standardizate.</p>","tags":["C++","implementare","optimizare","siruri de caractere"]},{"location":"cppintro/strings/#initializarea-sirurilor-de-caractere","title":"Ini\u021bializarea \u0219irurilor de caractere","text":"<p>Un \u0219ir de caractere poate fi ini\u021bializat \u00een diferite moduri. Exemplele de mai jos ilustreaz\u0103 c\u00e2teva tehnici comune:</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    // Automat adaug\u0103 '\\0' (caracterul nul).\n    // Din acest motiv, lungimea lui `c` este dat\u0103 de lungimea\n    // \u0219irului de caractere + 1, pentru '\\0'.\n    char nume[7] = \"roalgo\";\n    cout &lt;&lt; nume &lt;&lt; '\\n';\n\n    // Cre\u0103m un vector de caractere manual. C++ poate determina\n    // automat m\u0103rimea vectorului, deci nu este nevoie s\u0103 \u00eel\n    // scriem.\n    char caractere[] = {'r', 'o', 'a', 'l', 'g', 'o', '\\0'};\n    cout &lt;&lt; caractere &lt;&lt; '\\n';\n\n    // Putem atribui \u0219i un \u0219ir de caractere direct, ca la primul\n    // exemplu.\n    char adevar[] = \"roalgo este cel mai bun server de informatica\";\n    cout &lt;&lt; adevar &lt;&lt; '\\n';\n\n    // Afi\u0219eaz\u0103 't'\n    cout &lt;&lt; adevar[9] &lt;&lt; '\\n';\n\n    // Afi\u0219eaz\u0103 'roalgo'.\n    for (int i = 0; i &lt; 6; i++) {\n        cout &lt;&lt; adevar[i];\n    }\n    cout &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["C++","implementare","optimizare","siruri de caractere"]},{"location":"cppintro/strings/#citirea-sirurilor-de-caractere","title":"Citirea \u0219irurilor de caractere","text":"<p>\u00cen C++, exist\u0103 mai multe moduri de a citi \u0219iruri de caractere, \u00een func\u021bie de ce anume dorim s\u0103 citim (un cuv\u00e2nt, o linie complet\u0103 sau un num\u0103r specificat de caractere). Alegerea metodei de citire poate afecta rezultatul, \u00een func\u021bie de modul \u00een care sunt delimitate datele (spa\u021biu, newline etc.).</p> <p>Un \u0219ir de caractere poate fi citit \u00een diverse moduri, fie la fel ca la vectori (caracter cu caracter), fie putem citi toate valorile deodat\u0103, iar \u00een func\u021bie de modul cum facem citirea, vom putea citi fie p\u00e2n\u0103 la \u00eent\u00e2lnirea primului spa\u021biu, fie p\u00e2n\u0103 la sf\u00e2r\u0219itul liniei.</p> <p>De asemenea, se va putea observa faptul c\u0103 putem citi o \u00eentreag\u0103 linie folosind func\u021bia getline \u0219i fix\u00e2nd num\u0103rul de caractere pe care vrem s\u0103-l citim.</p> <p>S\u0103 presupunem c\u0103 \u0219irul de caractere este <code>roalgo este cel mai bun server de informatica</code>. \u00cen func\u021bie de cum citim acest \u0219ir, vom avea rezultate diferite.</p> <p>Func\u021bia <code>cin.getline</code> are ca parametri \u0219irul \u00een care se va stoca rezultatul citirii \u0219i num\u0103rul maxim de caractere permis, citind \u0219irul p\u00e2n\u0103 la \u00eent\u00e2lnirea caracterului de newline, un exemplu ar fi <code>cin.getline(s, x)</code>, unde s este \u0219irul dat \u0219i x este lungimea lui.</p> <p>Citirea f\u0103r\u0103 o func\u021bie specific\u0103 se poate face cu cin, dar se va citi p\u00e2n\u0103 la primul spa\u021biu.</p> <p>Exist\u0103 \u0219i func\u021bia <code>cin.get()</code>, care poate fi folosit fie pentru un singur caracter, fie pentru a citi \\(x\\) caractere, dar de obicei vom avea nevoie s\u0103 citim o linie complet\u0103, deci func\u021bia <code>cin.getline()</code> devine mai util\u0103.</p> <pre><code>#include &lt;iostream&gt;\n#include &lt;string&gt;\nusing namespace std;\n\nint main() {\n    char s[100];\n    cin &gt;&gt; s;\n\n    cout &lt;&lt; s &lt;&lt; '\\n';\n\n    // Sare peste urm\u0103torul caracter, de obicei spa\u021biu sau newline.\n    cin.get();\n\n    // Cite\u0219te cel mult 100 de caractere, p\u00e2n\u0103 la newline,\n    // dar sare \u0219i de acesta.\n    cin.getline(s, 100);\n\n    cout &lt;&lt; s &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["C++","implementare","optimizare","siruri de caractere"]},{"location":"cppintro/strings/#functia-strlen","title":"Func\u021bia strlen","text":"<p>Func\u021bia strlen ia drept parametru un \u0219ir de caractere \u0219i returneaz\u0103 lungimea acestuia.</p> <pre><code>char message[] = \"roalgo este cel mai bun server de informatica\";\ncout &lt;&lt; strlen(message) &lt;&lt; '\\n';  // 45\n</code></pre>","tags":["C++","implementare","optimizare","siruri de caractere"]},{"location":"cppintro/strings/#functia-strcpy-si-strncpy","title":"Func\u021bia strcpy \u0219i strncpy","text":"<p>Func\u021bia <code>strcpy</code> copiaz\u0103 un \u0219ir de caractere \u00een alt \u0219ir, numit destina\u021bie. Asem\u0103n\u0103tor, func\u021bia <code>strncpy</code> copiaz\u0103 doar primele n caractere dintr-un \u0219ir. Aceste func\u021bii nu adaug\u0103 caracterul <code>\\0</code> la finalul \u0219irului.</p> strcpystrncpy <pre><code>char sursa[11] = \"hello\";\nchar destinatie[11] = \"world\";\n\n// Se va afi\u0219a \"hello world\"\ncout &lt;&lt; sursa &lt;&lt; \" \" &lt;&lt; destinatie &lt;&lt; '\\n';\n\nstrcpy(destinatie, sursa);\n\n// Se va afi\u0219a \"hello hello\"\ncout &lt;&lt; sursa &lt;&lt; \" \" &lt;&lt; destinatie &lt;&lt; '\\n';\n</code></pre> <pre><code>char sursa[11] = \"caine\";\nchar destinatie[11] = \"paine\";\n\n// Se va afi\u0219a \"caine paine\"\ncout &lt;&lt; sursa &lt;&lt; \" \" &lt;&lt; destinatie &lt;&lt; '\\n';\n\nstrncpy(destinatie, sursa, 1);\n\n// Se va afi\u0219a \"caine caine\"\ncout &lt;&lt; sursa &lt;&lt; \" \" &lt;&lt; destinatie &lt;&lt; '\\n';\n</code></pre>","tags":["C++","implementare","optimizare","siruri de caractere"]},{"location":"cppintro/strings/#functiile-strcat-si-strncat","title":"Func\u021biile strcat \u0219i strncat","text":"<p>Func\u021bia <code>strcat</code> concateneaz\u0103 un \u0219ir 'destinatie' cu o copie a unui \u0219ir 'sursa'. Concatenarea a dou\u0103 \u0219iruri \u00eenseamn\u0103 alipirea acestora. Func\u021bia <code>strncat</code> func\u021bioneaz\u0103 asem\u0103n\u0103tor, numai c\u0103 alipe\u0219te doar primele n caractere ale \u0219irului surs\u0103. Iat\u0103 un exemplu:</p> strcatstrncat <pre><code>char sursa[11] = \"hello \";\nchar destinatie[11] = \"world\";\n\n// Se va afi\u0219a \"hello world\"\ncout &lt;&lt; sursa &lt;&lt; \" \" &lt;&lt; destinatie &lt;&lt; '\\n';\n\nstrcat(destinatie, sursa);\n\n// Se va afi\u0219a \"worldhello\"\ncout &lt;&lt; destinatie;\n</code></pre> <pre><code>char sursa[20] = \"informatica\";\nchar destinatie[20] = \"mate\";\n\n// Se va afi\u0219a \"informatica mate\"\ncout &lt;&lt; sursa &lt;&lt; \" \" &lt;&lt; destinatie &lt;&lt; '\\n';\n\nstrncat(destinatie, sursa, 4);\n\n// Se va afi\u0219a \"mateinfo\"\ncout &lt;&lt; destinatie;\n</code></pre>","tags":["C++","implementare","optimizare","siruri de caractere"]},{"location":"cppintro/strings/#functia-strchr-si-strrchr","title":"Func\u021bia strchr \u0219i strrchr","text":"<p>Func\u021biile <code>strchr</code> \u0219i <code>strrchr</code> returneaz\u0103 un pointer la prima apari\u021bie, respectiv ultima apari\u021bie a unui caracter \u00eentr-un \u0219ir. Mai exact se va afi\u0219a \u0219irul de \u00eencep\u00e2nd cu prima, respectiv ultima apari\u021bie a caracterului.</p> strchrstrrchr <pre><code>char str[] = \"serverul roalgo este plin de persoane pasionate de algoritmica\";\nchar *p = strchr(str, 'p');\n\nif (p != nullptr) {\n    // Se va afi\u0219a \"plin de persoane pasionate de algoritmica\"\n    cout &lt;&lt; p;\n}\n</code></pre> <pre><code>char str[] = \"serverul roalgo este plin de persoane pasionate de algoritmica\";\nchar *p = strrchr(str, 'p');\n\nif (p != nullptr) {\n    // Se va afi\u0219a \"pasionate de algoritmica\"\n    cout &lt;&lt; p;\n}\n</code></pre>","tags":["C++","implementare","optimizare","siruri de caractere"]},{"location":"cppintro/strings/#functia-strcmp","title":"Func\u021bia strcmp","text":"<p>Func\u021bia <code>strcmp</code> este folosit\u0103 pentru a compara dou\u0103 \u0219iruri de caractere. Aceasta poate returna 3 valori:</p> <ul> <li><code>0</code> - dac\u0103 \u0219irurile sunt exact la fel;</li> <li><code>-1</code> sau o valoare mai mic\u0103 dec\u00e2t 0 - dac\u0103 primul \u0219ir este \u00eenaintea celuilalt,   alfabetic vorbind;</li> <li><code>1</code> sau o valoare mai mare dec\u00e2t 0 - dac\u0103 primul \u0219ir este dup\u0103 cel\u0103lalt,   alfabetic vorbind.</li> </ul> <pre><code>char str1[] = \"abc\";\nchar str2[] = \"abc\";\n\n// Se va afi\u0219a 0 deoarece \u0219irurile sunt la fel\ncout &lt;&lt; strcmp(str1, str2) &lt;&lt; '\\n';\n\nchar str3[] = \"def\";\nchar str4[] = \"ghi\";\n\n// Se va afi\u0219a -1 deoarece primul \u0219ir este \u00eenaintea celui de al doilea\ncout &lt;&lt; strcmp(str3, str4) &lt;&lt; '\\n';\n\n// Se va afi\u0219a 1 deoarece primul \u0219ir este dup\u0103 cel de al doilea\ncout &lt;&lt; strcmp(str4, str3) &lt;&lt; '\\n';\n</code></pre>","tags":["C++","implementare","optimizare","siruri de caractere"]},{"location":"cppintro/strings/#functia-strstr","title":"Func\u021bia strstr","text":"<p>Aceast\u0103 func\u021bie prime\u0219te dou\u0103 \u0219iruri de caractere, s1 \u0219i s2, ca argumente \u0219i g\u0103se\u0219te prima apari\u021bie a \u0219irului s2 \u00een \u0219irul s1.</p> <pre><code>char str1[] = \"abcdefghijklmnop\";\nchar str2[] = \"fgh\";\n\n// Se va afi\u0219a \"fghijklmnop\"\ncout &lt;&lt; strstr(str1, str2);\n</code></pre>","tags":["C++","implementare","optimizare","siruri de caractere"]},{"location":"cppintro/strings/#functia-strtok","title":"Func\u021bia strtok","text":"<p>Func\u021bia <code>strtok</code> \u00eemparte <code>str[]</code> conform delimitatorilor da\u021bi \u0219i returneaz\u0103 urm\u0103torul token. Trebuie apelat\u0103 \u00eentr-o structur\u0103 repetitiv\u0103 pentru a ob\u021bine toate token-urile.</p> <pre><code>char str[] = \"wow-ce-multe-cuvinte-in-acest-sir\";\nchar *token = strtok(str, \"-\");\n\n// Se va afi\u0219a \"wow ce multe cuvinte in acest sir\"\nwhile (token != nullptr) {\n    cout &lt;&lt; token &lt;&lt; \" \";\n    token = strtok(nullptr, \"-\");\n}\n</code></pre>","tags":["C++","implementare","optimizare","siruri de caractere"]},{"location":"cppintro/strings/#tipul-de-date-stdstring","title":"Tipul de date std::string","text":"<p>Aceast\u0103 structur\u0103 de date este echivalentul std::vector pentru \u0219irurile de caractere, remarc\u00e2ndu-se prin faptul c\u0103 spre deosebire de \u0219irurile de caractere din C, func\u021bia de aflare a lungimii este \\(\\mathcal{O}(1)\\), \u00een loc de \\(\\mathcal{O}(n)\\). Tipul string este unul din tipurile prezente \u00een STL, foarte multe func\u021bii fiind similare cu cele pe care le putem folosi cu vectori.</p> <p>Pentru a putea folosi aceast\u0103 structur\u0103 de date, va trebui s\u0103 includem biblioteca <code>&lt;string&gt;</code>. Se remarc\u0103 faptul c\u0103 exist\u0103 diferen\u021be semnificative fa\u021b\u0103 de cum folosim \u0219irurile de caractere din C.</p> <p>\u00cen ceea ce prive\u0219te citirea, func\u021bia getline va avea o sintax\u0103 un pic diferit\u0103, fiind scris\u0103 astfel:</p> <pre><code>string s;\ngetline(cin, s);\ncout &lt;&lt; s &lt;&lt; '\\n';\n</code></pre> <p>Sintaxa unui string va fi de tipul <code>string nume;</code></p> <pre><code>string s = \"abacaba\";\ns[0] = 'c';\n\ncout &lt;&lt; s.size() &lt;&lt; '\\n';  // 7\n\ns[6] = '\\0';  // caracterul nul\n\n// abacab 7\n// (nu se schimba m\u0103rimea)\ncout &lt;&lt; s &lt;&lt; \" \" &lt;&lt; s.size() &lt;&lt; '\\n';\n</code></pre> <p>\u00cen mod particular, vom putea concatena dou\u0103 \u0219iruri de caractere cu u\u0219urin\u021b\u0103, folosind operatorul <code>+</code>. Totu\u0219i, trebuie s\u0103 fim aten\u021bi cum folosim acest operator, pentru a evita efectuarea prea \u00eenceat\u0103 a opera\u021biilor.</p> <pre><code>string s = \"roalgo\";\nstring t = \"top\";\ns += t;     // roalgotop\ns = s + t;  // roalgotoptop\n</code></pre> <p>De\u0219i \u00een cazul numerelor naturale, aceste opera\u021bii sunt echivalente, \u00een cazul stringurilor, <code>+=</code> \u0219i <code>+</code> sunt complet diferite. Prima dintre ele concateneaz\u0103 \u0219irul primit la \u0219irul existent, cea de-a doua copiaz\u0103 cele dou\u0103 \u0219iruri, le une\u0219te \u0219i apoi atribuie rezultatul \u0219irului. Aceast\u0103 diferen\u021b\u0103 devine mai dramatic\u0103 \u00een situa\u021bii precum cea de mai jos.</p> <pre><code>string s;\nfor (int i = 1; i &lt;= 1000000; i++) {  // O(n)\n    s += 'a';\n}\n\nstring t;\nfor (int i = 1; i &lt;= 1000000; i++) {  // O(n^2)\n    t = t + 'a';\n}\n</code></pre> <p>Putem folosi \u0219i func\u021bii specifice care caut\u0103 prima sau ultima apari\u021bie a unui anumit caracter \u00een \u0219ir, precum find sau find_last_of, care au complexitate liniar\u0103. Tipul returnat este size_t, dar acesta poate fi folosit \u0219i ca int.</p> <pre><code>#include &lt;iostream&gt;\n#include &lt;string&gt;\n\nusing namespace std;\n\nint main() {\n    string str = \"roalgo este cel mai bun server din romania\";\n\n    size_t first = str.find('e');         // 7\n    size_t last = str.find_last_of('e');  // 28\n\n    if (first != string::npos) {\n        cout &lt;&lt; first &lt;&lt; '\\n';\n    }\n\n    if (last != string::npos) {\n        cout &lt;&lt; last &lt;&lt; '\\n';\n    }\n\n    return 0;\n}\n</code></pre>","tags":["C++","implementare","optimizare","siruri de caractere"]},{"location":"cppintro/strings/#concluzii","title":"Concluzii","text":"<p>Caracterele \u0219i \u0219irurile de caractere sunt foarte folosite \u00een multe aplica\u021bii, fiind des \u00eent\u00e2lnite \u00een probleme de toate dificult\u0103\u021bile, \u00een special la examenele de bacalaureat \u0219i admitere, dar \u0219i \u00een multe dintre problemele ce se dau la olimpiada de informatic\u0103, \u00een clasa a X-a \u0219i clasa a VIII-a.</p> <p>Cunoa\u0219terea func\u021biilor specifice este esen\u021bial\u0103 deoarece foarte multe \u00eentreb\u0103ri gril\u0103 la admitere implic\u0103 elemente mai dificile din sintaxa lor \u0219i orice detaliu minor poate face diferen\u021ba.</p>","tags":["C++","implementare","optimizare","siruri de caractere"]},{"location":"cppintro/strings/#probleme-suplimentare","title":"Probleme suplimentare","text":"<ul> <li>Prelucr\u0103ri elementare pe \u0219iruri de caractere -   pbinfo</li> <li>Func\u021bii predefinite cu \u0219iruri de caractere -   pbinfo</li> <li>Probleme diverse -   pbinfo</li> <li>Probleme cu stringuri de pe kilonova</li> </ul>","tags":["C++","implementare","optimizare","siruri de caractere"]},{"location":"cppintro/strings/#resurse-suplimentare","title":"Resurse suplimentare","text":"<ul> <li>Clasificarea caracterelor -   geeksforgeeks</li> <li>Opera\u021bii specifice datelor de tip char - CPPI   Sync</li> <li>\u0218iruri de caractere, citire, parcurgeri - CPPI   Sync</li> <li>\u0218iruri de caractere C++ -   pbinfo</li> <li>Stringuri -   Infogym</li> <li>Siruri de caractere \u00een C++ - infoscience   3x</li> </ul>","tags":["C++","implementare","optimizare","siruri de caractere"]},{"location":"cppintro/windows/","title":"Windows 10/11","text":"<p>\u00cenainte de a instala un editor/IDE, avem nevoie de un compilator. Exist\u0103 urm\u0103toarele op\u021biuni:</p> <ul> <li> <p> MSVC</p> <p>MSVC (Microsoft Visual C++) este un compilator proprietar f\u0103cut de Microsoft \u0219i este parte din IDE-ul Visual Studio 2022.</p> <p>Dac\u0103 e\u0219ti sigur(\u0103) c\u0103 vrei s\u0103 folose\u0219ti acest IDE \u00een particular, alege aceast\u0103 op\u021biune. Dac\u0103 l-ai instalat deja, atunci alege aceast\u0103 op\u021biune, deoarece articolul include \u0219i ni\u0219te sfaturi de performan\u021b\u0103.</p> <p> Vezi instruc\u021biuni pentru Visual Studio</p> </li> <li> <p> GCC (MinGW)</p> <p>GCC (GNU Compiler Collection) este o suit\u0103 de compilatoare libere \u0219i gratuite. Cel mai folosit compilator din aceast\u0103 suit\u0103 este GCC (GNU C Compiler).</p> <p>Pe Windows, cea mai u\u0219oar\u0103 metod\u0103 de a instala compilatorul GCC este folosind MinGW-w64. \u00cen caz c\u0103 nu folose\u0219ti Visual Studio 2022, ci alt editor (de pild\u0103, Code::Blocks sau Visual Studio Code), alege aceast\u0103 op\u021biune.</p> <p> Vezi instruc\u021biuni pentru MinGW</p> </li> </ul> <p>Dac\u0103 ai deja un compilator instalat pe sistem (fie MSVC, fie GCC prin MinGW), atunci aici ai unele op\u021biuni de editoare:</p> <p>Vezi op\u021biuni de editoare </p>"},{"location":"cppintro/compilers/linux/clang/","title":"Clang","text":"<p>TODO</p>"},{"location":"cppintro/compilers/linux/gcc/","title":"GCC","text":"<p>TODO</p>"},{"location":"cppintro/compilers/windows/mingw64/","title":"Compilatorul GCC (MinGW-w64)","text":"<p>Proiectul MinGW-w64 este continuarea proiectului MinGW (Minimalist GNU for Windows), f\u0103cut ca s\u0103 suporte compilatorul GCC pe Windows, cu suport pentru 64 de bi\u021bi (ceea ce este cel mai probabil ce folose\u0219ti acum). Acest compilator poate fi folosit inclusiv pe Linux pentru a compila binare pentru Windows.</p> <p>Pentru a instala MinGW-w64, avem urm\u0103torii pa\u0219i:</p> <ol> <li> <p>Deschide pagina https://winlibs.com/. Aceast\u0103 pagin\u0103 ofer\u0103 binare    executabile pre-compilate pentru GCC \u0219i optimizate pentru a crea executabile    native pe Windows.</p> <p>Deschide pagina </p> </li> <li> <p>D\u0103 scroll p\u00e2n\u0103 c\u00e2nd o s\u0103 vezi versiunile de GCC. Alegem varianta cu UCRT    (Universal C Runtime) pentru c\u0103 este f\u0103cut\u0103 de la zero pentru Windows 10 \u0219i    11 \u0219i este g\u00e2ndit\u0103 s\u0103 aib\u0103 suport mai bun pentru standardul de C \u0219i C++.</p> </li> <li> <p>Dintre lista de op\u021biuni pe care o ai pentru UCRT runtime, ne intereseaz\u0103    ultima versiune (la data scrierii, versiunea este GCC 14.2.0).</p> </li> <li> <p>Selecteaz\u0103 din prima op\u021biune (cea care scrie POSIX threads) fie Win64 (dac\u0103    ai un sistem pe 64 de bi\u021bi, care este cam orice calculator lansat \u00een ultimul    deceniu \u0219i jum\u0103tate), fie Win32, \u00een formatul t\u0103u de preferin\u021b\u0103 (7-Zip are    nevoie de programul cu acela\u0219i nume, dar are executabile mai mici, \u00een timp ce    Zip poate fi deschis din Explorer). La data scrierii, asta este arhiva    potrivit\u0103:</p> <p>Descarc\u0103 GCC 14.2.0 </p> <p> </p> </li> <li> <p>Dup\u0103 ce s-a terminat de desc\u0103rcat arhiva, deschide-o \u0219i extrage directorul     <code>mingw64</code> \u00eentr-un loc u\u0219or accesibil (de preferin\u021b\u0103 \u00een <code>C:\\</code>). \u021aine minte     aceast\u0103 loca\u021bie! O s\u0103 m\u0103 refer la aceast\u0103 loca\u021bie \u00een text ca <code>$MINGW</code> (de     pild\u0103, dac\u0103 ai dezarhivat \u00een <code>C:\\</code>, atunci <code>$MINGW = C:\\mingw64</code>). O s\u0103 ia     ceva timp s\u0103 se dezarhiveze tot, deoarece are peste 1GB. Indiferent unde s-a     dezarhivat, con\u021binutul directorului <code>$MINGW</code> ar trebui s\u0103 arate astfel:</p> <p></p> <p></p> </li> <li> <p>Acum avem un compilator de C++ \u00een sistem. Pentru a-l face disponibil global,    trebuie s\u0103 ad\u0103ug\u0103m \u00een calea sistemului ca s\u0103 poat\u0103 recunoa\u0219te executabilele.    Pentru acest lucru:</p> <ol> <li>Apas\u0103 Win+R \u0219i scrie <code>sysdm.cpl</code> \u0219i apas\u0103 OK. Dac\u0103 totul a fost cu     succes, o s\u0103 vezi o fereastr\u0103 de genul:       </li> <li>Navigheaz\u0103 c\u0103tre tab-ul Complex \u0219i apas\u0103 pe ultimul buton (Environment     variables sau Variabile de mediu):      </li> <li>Apas\u0103 dublu clic pe variabila <code>Path</code> de la sec\u021biunea cu variabile de     utilizator (partea de sus).       </li> <li>Apas\u0103 pe \"Navigare...\" (aten\u021bie, f\u0103r\u0103 s\u0103 ai vreo cale selectat\u0103 deja,     apas\u0103 oriunde \u00eentr-un spa\u021biu gol din list\u0103) \u0219i caut\u0103 calea <code>$MINGW\\bin</code>     (unde <code>$MINGW</code> e locul unde ai instalat MinGW). \u00cen cazul meu, calea va fi     <code>C:\\mingw64\\bin</code>. Dac\u0103 totul a decurs cum trebuie, ar trebui s\u0103 fie o     cale \u00een plus \u00een list\u0103:      </li> <li>Apas\u0103 OK p\u00e2n\u0103 c\u00e2nd se \u00eenchid toate ferestrele.</li> </ol> </li> <li> <p>Pentru a face sistemul s\u0103 recunoasc\u0103 noile noastre executabile,    deconecteaz\u0103-te \u0219i conecteaz\u0103-te \u00eenapoi la utilizatorul curent. Felicit\u0103ri!</p> </li> </ol> <p>Acum navigheaz\u0103 aici pentru a vedea ce editoare ai la dispozi\u021bie:</p> <p>Vezi op\u021biuni de editoare </p>"},{"location":"cppintro/editors/linux/editoare-text/","title":"Op\u021biuni de editoare text (Linux)","text":"<p>La capitolul editoare de text, exist\u0103 multe op\u021biuni. Totu\u0219i, dorim urm\u0103toarele calit\u0103\u021bi de la un editor de text pentru C++:</p> <ul> <li>Syntax highlighting (eviden\u021bierea sintaxei), pentru a putea distinge u\u0219or   cuvintele cheie \u0219i a putea citi codul mai u\u0219or;</li> <li>Completare automat\u0103 (\u0219i sugestii) pentru a putea completa rapid \u0219i   eficient codul;</li> <li>Indentare automat\u0103 (\u0219i formatare), pentru a p\u0103stra un stil   consistent;</li> <li>Func\u021bii de c\u0103utare \u0219i \u00eenlocuire;</li> <li>Num\u0103rarea liniilor \u0219i coloanelor;</li> <li>Suport pentru extensii;</li> <li>S\u0103 fie u\u0219or de folosit \u0219i s\u0103 consume pu\u021bine resurse.</li> </ul> <p>Urm\u0103toarele editoare \u00eendeplinesc criteriile de mai sus:</p> <ul> <li> <p>Visual Studio Code</p> <p>Visual Studio Code este un editor de cod gratuit \u0219i open-source, dezvoltat de Microsoft. Este extrem de popular datorit\u0103 integr\u0103rii sale cu multe instrumente de dezvoltare \u0219i suportului pentru extensii, oferind o experien\u021b\u0103 de codare puternic\u0103 \u0219i flexibil\u0103.</p> <p> Instalare \u0219i configurare</p> </li> <li> <p>Sublime Text 4</p> <p>Sublime Text 4 este un editor de text rapid \u0219i versatil, cunoscut pentru interfa\u021ba sa curat\u0103 \u0219i performan\u021ba excelent\u0103. Este ideal pentru dezvoltatori datorit\u0103 func\u021biilor avansate precum eviden\u021bierea sintaxei \u0219i completarea automat\u0103, al\u0103turi de un sistem robust de plugin-uri.</p> <p> Instalare \u0219i configurare</p> </li> <li> <p>Kate</p> <p>Kate este un editor de text puternic, parte a KDE. Este extensibil prin plugin-uri \u0219i suport\u0103 o gam\u0103 larg\u0103 de limbaje de programare, incluz\u00e2nd C++. Este rapid \u0219i u\u0219or de utilizat, fiind o alegere popular\u0103 pentru utilizatorii de Linux care folosesc KDE \u0219i nu numai.</p> <p> Instalare \u0219i configurare</p> </li> <li> <p>Geany</p> <p>Geany este un editor de text u\u0219or \u0219i puternic, care ofer\u0103 un echilibru excelent \u00eentre func\u021bionalitate \u0219i performan\u021b\u0103. Este proiectat s\u0103 fie rapid \u0219i s\u0103 consume pu\u021bine resurse, fiind ideal pentru dezvoltarea de aplica\u021bii C++. Geany ofer\u0103 suport pentru eviden\u021bierea sintaxei, completarea automat\u0103 \u0219i un terminal integrat. Este foarte potrivit pentru dezvoltatorii care doresc un editor simplu, dar capabil, care poate fi folosit f\u0103r\u0103 a instala multe extensii.</p> <p> Instalare \u0219i configurare</p> </li> </ul> <p>Not\u0103</p> <p>\u00cen afar\u0103 de aceste editoare, mai exist\u0103 \u0219i altele, precum eternele Vim/Neovim \u0219i Emacs. De\u0219i autorul folose\u0219te ambele editoare (Emacs \u00eendeosebi), procesul de a le configura este mai anevoios \u0219i sunt \u00een afara scopului acestui articol introductiv.</p>"},{"location":"cppintro/editors/linux/ide/","title":"Op\u021biuni de IDE-uri (Linux)","text":"<p>La capitolul IDE-uri, nu avem a\u0219a de multe op\u021biuni, pentru c\u0103 un IDE este fundamental mai complex. Totu\u0219i, cele mai bune op\u021biuni sunt:</p> <ul> <li> <p>Code::Blocks</p> <p>Code::Blocks este un IDE gratuit \u0219i open-source, dedicat dezvolt\u0103rii de aplica\u021bii \u00een limbajul C \u0219i C++. Este cunoscut pentru flexibilitatea sa, fiind extensibil prin plugin-uri \u0219i suport\u00e2nd diverse compilatoare. Interfa\u021ba sa prietenoas\u0103 \u0219i u\u0219urin\u021ba de utilizare \u00eel fac o alegere popular\u0103 printre programatorii C/C++. \u00cen plus, acesta este editorul implicit pentru olimpiad\u0103. Ruleaz\u0103 pe Windows, macOS, Linux, FreeBSD \u0219i OpenBSD.</p> <p> Instalare \u0219i configurare</p> </li> <li> <p>Qt Creator</p> <p>Qt Creator este un IDE cross-platform dezvoltat de Qt Company, perfect pentru dezvoltarea \u00een C++. Acesta ofer\u0103 integrare complet\u0103 cu Qt Framework, un designer vizual pentru interfe\u021be grafice \u0219i suport pentru sistemele de build CMake \u0219i QMake. Qt Creator vine cu instrumente avansate de navigare \u0219i refactorizare a codului, un debugger integrat \u0219i instrumente de profilare pentru identificarea \u0219i rezolvarea problemelor de performan\u021b\u0103. De asemenea, este foarte flexibil \u0219i poate fi extins prin plugin-uri, f\u0103c\u00e2ndu-l potrivit pentru diverse nevoi ale dezvoltatorilor. Ruleaz\u0103 pe Windows, macOS, Linux, FreeBSD, OpenBSD \u0219i NetBSD.</p> <p> Instalare \u0219i configurare</p> </li> <li> <p>CLion</p> <p>CLion este un IDE dezvoltat de JetBrains, specializat \u00een dezvoltarea de aplica\u021bii \u00een C \u0219i C++. Acesta ofer\u0103 o gam\u0103 larg\u0103 de func\u021bionalit\u0103\u021bi avansate, cum ar fi refactorizarea codului, navigarea inteligent\u0103 \u0219i suportul pentru CMake. CLion include un debugger integrat \u0219i instrumente de analiz\u0103 a codului care ajut\u0103 la men\u021binerea unui cod curat \u0219i eficient. Este apreciat pentru productivitatea pe care o ofer\u0103 dezvoltatorilor, datorit\u0103 instrumentelor sale avansate \u0219i integr\u0103rii cu diverse sisteme de control al versiunilor. Ruleaz\u0103 pe Windows, macOS \u0219i Linux.</p> <p> Instalare \u0219i configurare</p> </li> </ul> <p>Aten\u021bie</p> <p>CLion, spre deosebire de celelalte op\u021biuni, nu este gratis. Totu\u0219i, dac\u0103 e\u0219ti eligibil, po\u021bi avea un cont de student ceea ce \u00ee\u021bi ofer\u0103 acces la CLion, precum \u0219i la alte produse marca JetBrains.</p>"},{"location":"cppintro/editors/linux/optiuni-editoare/","title":"Op\u021biuni de editoare (Linux)","text":"<p>Exist\u0103 dou\u0103 tipuri de editoare folosite pentru a scrie cod (nu doar \u00een C++):</p> <ul> <li> <p> Editoare de text</p> <p>Un editor de text este un program simplu folosit pentru scrierea \u0219i editarea codului surs\u0103 C++. Exemple de astfel de editoare includ Vim, Emacs, Geany, Kate, Sublime Text, \u0219i Visual Studio Code, printre altele. Acestea sunt ideale pentru editarea de fi\u0219iere de cod C++ simple, oferind func\u021bionalit\u0103\u021bi de baz\u0103 precum eviden\u021bierea sintaxei \u0219i completarea automat\u0103.</p> <p>Editoarele de text consum\u0103 mai pu\u021bin\u0103 memorie dec\u00e2t un IDE, \u00eens\u0103 trebuie s\u0103 fie configurate pentru a putea suporta C++ la un nivel satisf\u0103c\u0103tor.</p> <p> Vezi op\u021biuni</p> </li> <li> <p> IDE</p> <p>Un mediu de dezvoltare integrat (IDE) pentru C++ este un software complex care ofer\u0103 dezvoltatorilor un set complet de instrumente pentru scrierea, compilarea, testarea \u0219i depanarea codului C++. Exemple de IDE-uri pentru C++ includ CLion, Qt Creator \u0219i Code::Blocks. Acestea includ func\u021bionalit\u0103\u021bi avansate precum depanare interactiv\u0103, integrare cu sisteme de control al versiunilor, instrumente de profilare \u0219i optimizare a codului, \u0219i multe alte instrumente care faciliteaz\u0103 dezvoltarea de aplica\u021bii complexe \u00een C++. Fiind programe mai complexe, ele consum\u0103 mai mult\u0103 memorie \u0219i mai mult spa\u021biu, \u00eens\u0103 ofer\u0103 toate uneltele necesare.</p> <p> Vezi op\u021biuni</p> </li> </ul>"},{"location":"cppintro/editors/macos/editoare-text/","title":"Op\u021biuni de editoare text (macOS)","text":"<p>La capitolul editoare de text, exist\u0103 multe op\u021biuni. Totu\u0219i, dorim urm\u0103toarele calit\u0103\u021bi de la un editor de text pentru C++:</p> <ul> <li>Syntax highlighting (eviden\u021bierea sintaxei), pentru a putea distinge u\u0219or   cuvintele cheie \u0219i a putea citi codul mai u\u0219or;</li> <li>Completare automat\u0103 (\u0219i sugestii) pentru a putea completa rapid \u0219i   eficient codul;</li> <li>Indentare automat\u0103 (\u0219i formatare), pentru a p\u0103stra un stil   consistent;</li> <li>Func\u021bii de c\u0103utare \u0219i \u00eenlocuire;</li> <li>Num\u0103rarea liniilor \u0219i coloanelor;</li> <li>Suport pentru extensii;</li> <li>S\u0103 fie u\u0219or de folosit \u0219i s\u0103 consume pu\u021bine resurse.</li> </ul> <p>Urm\u0103toarele editoare \u00eendeplinesc criteriile de mai sus:</p> <ul> <li> <p> Visual Studio Code</p> <p>Visual Studio Code este un editor de cod gratuit \u0219i open-source, dezvoltat de Microsoft. Este extrem de popular datorit\u0103 integr\u0103rii sale cu multe instrumente de dezvoltare \u0219i suportului pentru extensii, oferind o experien\u021b\u0103 de codare puternic\u0103 \u0219i flexibil\u0103.</p> <p> Instalare \u0219i configurare</p> </li> <li> <p> Sublime Text 4</p> <p>Sublime Text 4 este un editor de text rapid \u0219i versatil, cunoscut pentru interfa\u021ba sa curat\u0103 \u0219i performan\u021ba excelent\u0103. Este ideal pentru dezvoltatori datorit\u0103 func\u021biilor avansate precum eviden\u021bierea sintaxei \u0219i completarea automat\u0103, al\u0103turi de un sistem robust de plugin-uri.</p> <p> Instalare \u0219i configurare</p> </li> <li> <p> TextMate</p> <p>TextMate este un editor de text gratuit, renumit pentru viteza \u0219i u\u0219urin\u021ba sa de utilizare. Ofer\u0103 eviden\u021bierea sintaxei pentru o gam\u0103 larg\u0103 de limbaje de programare \u0219i suport pentru plugin-uri, fiind o alegere excelent\u0103 pentru dezvoltatorii care au nevoie de un editor eficient \u0219i u\u0219or de folosit.</p> <p> Instalare \u0219i configurare</p> </li> </ul> <p>Not\u0103</p> <p>\u00cen afar\u0103 de aceste editoare, mai exist\u0103 \u0219i altele, precum eternele Vim/Neovim \u0219i Emacs. De\u0219i autorul le folose\u0219te pe ultimele dou\u0103 (Emacs \u00eendeosebi), procesul de a le configura este mai anevoios \u0219i nu sunt cele mai bune pe Windows \u0219i sunt \u00een afara scopului acestui articol introductiv. De asemenea, o alternativ\u0103 pl\u0103tit\u0103 pentru TextMate este \u0219i BBEdit, iar una gratuit\u0103 este CotEditor, \u00eens\u0103 autorul nu are experien\u021b\u0103 personal\u0103 cu acestea.</p>"},{"location":"cppintro/editors/macos/ide/","title":"Op\u021biuni de IDE-uri (macOS)","text":"<p>La capitolul IDE-uri, nu avem a\u0219a de multe op\u021biuni, pentru c\u0103 un IDE este fundamental mai complex. Totu\u0219i, cele mai bune op\u021biuni sunt:</p> <ul> <li> <p> XCode</p> <p>XCode este mediul oficial de dezvoltare integrat (IDE) pentru macOS, dezvoltat de Apple. Este gratuit \u0219i ofer\u0103 suport complet pentru C, C++, Swift \u0219i Objective-C. XCode vine cu un debugger puternic, un editor de cod avansat \u0219i suport pentru instrumente de profilare.</p> <p> Instalare \u0219i configurare</p> </li> <li> <p> CLion</p> <p>CLion este un IDE dezvoltat de JetBrains, specializat \u00een dezvoltarea de aplica\u021bii \u00een C \u0219i C++. Acesta ofer\u0103 o gam\u0103 larg\u0103 de func\u021bionalit\u0103\u021bi avansate, cum ar fi refactorizarea codului, navigarea inteligent\u0103 \u0219i suportul pentru CMake. CLion include un debugger integrat \u0219i instrumente de analiz\u0103 a codului care ajut\u0103 la men\u021binerea unui cod curat \u0219i eficient.</p> <p> Instalare \u0219i configurare</p> </li> </ul> <p>Aten\u021bie</p> <p>CLion, spre deosebire de XCode, nu este gratis. Totu\u0219i, dac\u0103 e\u0219ti eligibil, po\u021bi avea un cont de student ceea ce \u00ee\u021bi ofer\u0103 acces la CLion, precum \u0219i la alte produse marca JetBrains.</p>"},{"location":"cppintro/editors/macos/optiuni-editoare/","title":"Op\u021biuni de editoare (macOS)","text":"<p>Exist\u0103 dou\u0103 tipuri de editoare folosite pentru a scrie cod (nu doar \u00een C++):</p> <ul> <li> <p> Editoare de text</p> <p>Un editor de text este un program simplu folosit pentru scrierea \u0219i editarea codului surs\u0103 C++. Exemple de astfel de editoare includ Vim, Emacs, TextMate, BBEdit, Sublime Text, \u0219i Visual Studio Code, printre altele. Acestea sunt ideale pentru editarea de fi\u0219iere de cod C++ simple, oferind func\u021bionalit\u0103\u021bi de baz\u0103 precum eviden\u021bierea sintaxei \u0219i completarea automat\u0103.</p> <p>Editoarele de text consum\u0103 mai pu\u021bin\u0103 memorie dec\u00e2t un IDE, \u00eens\u0103 trebuie s\u0103 fie configurate pentru a putea suporta C++ la un nivel satisf\u0103c\u0103tor.</p> <p> Vezi op\u021biuni</p> </li> <li> <p> IDE</p> <p>Un mediu de dezvoltare integrat (IDE) pentru C++ este un software complex care ofer\u0103 dezvoltatorilor un set complet de instrumente pentru scrierea, compilarea, testarea \u0219i depanarea codului C++. Exemple de IDE-uri pentru C++ includ XCode \u0219i CLion. Acestea includ func\u021bionalit\u0103\u021bi avansate precum depanare interactiv\u0103, integrare cu sisteme de control al versiunilor, instrumente de profilare \u0219i optimizare a codului, \u0219i multe alte instrumente care faciliteaz\u0103 dezvoltarea de aplica\u021bii complexe \u00een C++. Fiind programe mai complexe, ele consum\u0103 mai mult\u0103 memorie \u0219i mai mult spa\u021biu, \u00eens\u0103 ofer\u0103 toate uneltele necesare.</p> <p> Vezi op\u021biuni</p> </li> </ul>"},{"location":"cppintro/editors/windows/clion/","title":"CLion (Windows)","text":"<p>TODO</p>"},{"location":"cppintro/editors/windows/codeblocks/","title":"Code::Blocks (Windows)","text":""},{"location":"cppintro/editors/windows/codeblocks/#instalare","title":"Instalare","text":"<p>Pentru a instala Code::Blocks:</p> <ol> <li> <p>Mergi pe site-ul oficial, la sec\u021biunea Downloads \u0219i apoi apas\u0103 \"Download the    binary release\".</p> <p>Link direct </p> </li> <li> <p>Alege <code>codeblocks-20.03-setup.exe</code>. Ambele mirror-uri sunt bune, \u00eens\u0103    recomand Sourceforge. Dac\u0103 vrei s\u0103 ai o instalare portabil\u0103, alege    <code>codeblocks-20.03-nosetup.zip</code>.</p> <p>Descarc\u0103 Code::Blocks 20.03 </p> <p>Aten\u021bie</p> <p>Nu alege variantele cu MinGW. Acele installere vin cu o versiune \u00eenvechit\u0103 de MinGW (vin cu GCC 8.1, mai precis). Pentru cea mai bun\u0103 experien\u021b\u0103, avem nevoie de cel mai nou compilator.</p> <p>Vezi instruc\u021biuni aici  pentru cum po\u021bi instala ultima versiune de GCC.</p> </li> <li> <p>Dup\u0103 ce s-a desc\u0103rcat, ruleaz\u0103 installerul (care ar trebui s\u0103 fie numit    <code>codeblocks-20.03-setup.exe</code>). Procesul nu dureaz\u0103 mult, de cele mai multe    ori este un minut. Set\u0103rile implicite sunt bune, a\u0219a c\u0103 po\u021bi ap\u0103sa Next p\u00e2n\u0103    c\u00e2nd s-a terminat de instalat.</p> </li> </ol>"},{"location":"cppintro/editors/windows/codeblocks/#configurare-si-utilizare","title":"Configurare \u0219i utilizare","text":"<p>De fiecare dat\u0103 c\u00e2nd vei deschide Code::Blocks, vei vedea asta:</p> <p>Selecteaz\u0103 GNU GCC Compiler (care ar trebui s\u0103 fie implicit), apas\u0103 pe Set as default \u0219i apoi apas\u0103 OK.</p> <p>Prima dat\u0103 c\u00e2nd deschizi acest editor, aceast\u0103 fereastr\u0103 va ap\u0103rea:</p> <p>Selecteaz\u0103 \"Yes, associate Code::Blocks with C/C++ file types\", care \u00eenseamn\u0103 faptul c\u0103 fiecare fi\u0219ier C++ se va deschide \u00een Code::Blocks. Apoi apas\u0103 OK.</p> <p>E\u0219ti \u00eent\u00e2mpinat de aceast\u0103 fereastr\u0103 alb\u0103 orbitoare:</p> <p>Pa\u0219ii pentru a crea un proiect sunt:</p> <ol> <li>Fie te po\u021bi duce \u00een bara de meniu \u0219i s\u0103 alegi File &gt; New &gt; Project, fie po\u021bi     din Start here (prima fereastr\u0103 care apare) \u0219i apoi apas\u0103 Create a new     project.</li> <li>Indiferent de metoda aleas\u0103, ajungi la aceast\u0103 fereastr\u0103:           Alege prin dublu clic Console application (engl. Aplica\u021bie \u00een consol\u0103).</li> <li>\u00cen acest stadiu, vei fi \u00eent\u00e2mpinat de \"wizard\". Acesta te va ghida \u00een     crearea unei aplica\u021bii noi. A\u0219a arat\u0103:           Apas\u0103 Next.</li> <li>De aici, alege C++ (este o introducere de C++, la urma urmei) \u0219i apas\u0103 Next.      </li> <li> <p>Aici este pasul unde alegi titlul proiectului, precum \u0219i folderul     proiectului.      </p> <p>Sfat</p> <p>F\u0103 numele proiectului sugestiv, chiar numele problemei la care lucrezi acum, pentru c\u0103 nu este prea dr\u0103gu\u021b s\u0103 umpli printr-o mare de proiecte care au nume similare cu \"fsdjkfdkjdfsjhsdaf\".</p> <p>De asemenea, recomand s\u0103 grupezi toate proiectele \u00eentr-un folder special. Este mult mai u\u0219or s\u0103 g\u0103se\u0219ti un proiect dac\u0103 se afl\u0103 \u00eentr-un singur loc. Numele sugestive ajut\u0103 \u0219i ele aici.</p> <p>\u00cen cazul meu, eu am completat astfel:  </p> </li> <li> <p>Aici este pasul unde alegem compilatorul. Dac\u0103 ai instalat GCC \u0219i \u00eel recunoa\u0219te corespunz\u0103tor, atunci prima op\u021biune va fi GNU GCC Compiler. Las\u0103 tot bifat a\u0219a cum e implicit \u0219i apas\u0103 Next \u0219i apoi Finish la urm\u0103torul ecran.</p> </li> </ol> <p>Dac\u0103 ai f\u0103cut totul corect, fereastra ta ar trebui s\u0103 arate astfel:</p> <p>Pentru a vedea dac\u0103 totul merge, apas\u0103 pe <code>main.cpp</code> din bara lateral\u0103. Ar trebui s\u0103 vezi urm\u0103torul cod \u00een editor:</p> <pre><code>#include &lt;iostream&gt;\n\nusing namespace std;\n\nint main()\n{\n    cout &lt;&lt; \"Hello world!\" &lt;&lt; endl;\n    return 0;\n}\n</code></pre> <p>Apas\u0103 pe F9 (sau Build &gt; Build and Run din bara de meniu). Acest pas va compila \u0219i rula programul t\u0103u, \u0219i este o tast\u0103 foarte folosit\u0103 de c\u0103tre tine \u00een viitor. Dac\u0103 ai un compilator func\u021bional \u0219i nu ai erori, o s\u0103 vezi urm\u0103toarea fereastr\u0103:</p> <p>Felicit\u0103ri! Compilatorul GCC func\u021bioneaz\u0103 \u0219i ai rulat primul t\u0103u program de C++.</p> <p>Acum a venit timpul s\u0103 configur\u0103m Code::Blocks. \u00cen primul r\u00e2nd, vrem s\u0103 facem experien\u021ba de editat mai bun\u0103. Pentru acest lucru, mergem la Settings &gt; Editor din bara de mediu.</p> <ol> <li> <p>Courier New nu este un font prea legibil, a\u0219a c\u0103 recomand s\u0103 \u00eel schimbi,    ap\u0103s\u00e2nd pe butonul Choose, \u00een Cascadia Mono, Cascadia Code (adaug\u0103 ligaturi,    dar \u00een rest este identic cu Cascadia Mono) sau Consolas. Po\u021bi seta de    asemenea \u0219i m\u0103rimea implicit\u0103 (10 este mult prea pu\u021bin, chiar \u0219i dac\u0103 ai pe    un monitor mare, ar trebui 12 minim).</p> </li> <li> <p>\u00cen acela\u0219i loc, la Indent Options bifeaz\u0103 Show indentation guides. Setarea    aceasta face ca fiecare nivel de indentare s\u0103 fie marcat cu o linie gri    vertical\u0103, deci este mai u\u0219or s\u0103 vezi unde \u00eencepe \u0219i se termin\u0103 o acolad\u0103.</p> </li> <li> <p>Bifeaz\u0103 \u0219i \"Ensure consistent EOLs\", ca s\u0103 nu se amestece sf\u00e2r\u0219iturile de    linii.</p> </li> </ol> <p>\u00cen total, a\u0219a ar trebui s\u0103 arate momentan pagina:      </p> <p>Acum ne mut\u0103m pe tab-ul cu Other editor settings. Aici vom configura urm\u0103toarele chestii:</p> <ol> <li>Bifeaz\u0103 Word Wrap. Aceast\u0103 func\u021bie \u00eencadreaz\u0103 textul automat \u00een caz c\u0103 este    prea lung.</li> <li>Este op\u021bional, \u00eens\u0103 po\u021bi bifa Highlight line under caret, care eviden\u021biaz\u0103    linia pe care e\u0219ti \u00een momentul de fa\u021b\u0103.</li> <li>Acest lucru este preferin\u021b\u0103 personal\u0103, \u00eens\u0103 po\u021bi face fontul s\u0103 se randeze    mai bine pe ecran. La Technology alege DirectWrite, \u0219i la Font quality alege    LCD optimized (m\u0103 \u00eendoiesc c\u0103 ai un monitor cu tub ca pe vremuri).</li> </ol> <p>Acum mergem la Margins and caret, unde vom face dou\u0103 schimb\u0103ri:</p> <ol> <li>Activ\u0103m Dynamic setting, deoarece bara care arat\u0103 num\u0103rul de linie este mult    prea groas\u0103.</li> <li>La Right margin hint, selecteaz\u0103 Visible line. La a 80-a coloan\u0103, arat\u0103 o    linie vertical\u0103. Dac\u0103 nu treci de acea linie, atunci codul t\u0103u va fi mai u\u0219or    de citit, pentru c\u0103 nu vei avea linii kilometrice.</li> </ol> <p>Un aspect foarte disputat la Code::Blocks este tema sa implicit\u0103, cu albul orbitor. Din p\u0103cate, Code::Blocks nu vine cu o tem\u0103 \u00eentunecat\u0103, mai prietenoas\u0103 cu ochii noaptea (de fapt, nu vine cu alte teme \u00een afar\u0103 de cea standard). Din motive tehnice care nu sunt \u00een controlul proiectului Code::Blocks, nu o s\u0103 avem vreodat\u0103 interfa\u021ba cu tem\u0103 \u00eentunecat\u0103 (pe alte platforme \u00eens\u0103 se poate), dar putem schimba tema editorului. Pentru a rezolva aceast\u0103 problem\u0103:</p> <ol> <li>Mergi la    aceast\u0103 pagin\u0103 arhivat\u0103.    Acolo o s\u0103 vezi mai multe teme.</li> <li> <p>Descarc\u0103 urm\u0103torul fi\u0219ier de configurare (care este exact cel de pe site,    \u00eens\u0103 prezervat pentru convenien\u021ba cititorului):</p> <p>colour_themes.conf </p> </li> <li> <p>\u00cenchide Code::Blocks. Acest pas este critic, deci asigur\u0103-te c\u0103 nu ai    vreo fereastr\u0103 ascuns\u0103.</p> </li> <li>Caut\u0103 loca\u021bia unde este instalat Code::Blocks \u0219i deschide folderul    corespunz\u0103tor. Ar trebui s\u0103 fie \u00een <code>C:\\Program Files\\CodeBlocks</code>.</li> <li>Ai un executabil numit <code>cb_share_config.exe</code>. Ruleaz\u0103-l.</li> <li>\u00cen st\u00e2nga (la surs\u0103), selecteaz\u0103 fi\u0219ierul <code>colour_themes.conf</code> pe care l-ai    desc\u0103rcat mai \u00eenainte. \u00cen dreapta, alege fi\u0219ierul implicit. Acesta se afl\u0103 la    <code>C:\\Users\\{nume utilizator}\\AppData\\Roaming\\CodeBlocks\\default.conf</code>.</li> <li> <p>\u00cen partea st\u00e2ng\u0103, bifeaz\u0103 tot din list\u0103. Asigur\u0103-te c\u0103 fereastra ta arat\u0103     a\u0219a:</p> <p> </p> </li> <li> <p>Apas\u0103 Transfer \u0219i r\u0103spunde cu Yes c\u00e2nd \u021bi se cere.</p> </li> <li> <p>Apas\u0103 pe Save.</p> </li> <li> <p>\u00cenchide programul \u0219i deschide Code::Blocks \u00eenapoi.</p> </li> <li> <p>Alege o tem\u0103 din Settings &gt; Editor &gt; Syntax highlighting. Eu personal     folosesc Son of Obsidian, dar asta r\u0103m\u00e2ne la latitudinea ta.</p> </li> </ol> <p>Dup\u0103 to\u021bi ace\u0219ti pa\u0219i, a\u0219a arat\u0103 editorul cu tema Son of Obsidian:</p> <p>Este mai pu\u021bin alb, chiar dac\u0103 nu este tem\u0103 \u00eentunecat\u0103 peste tot.</p> <p>Legat de scurt\u0103turi, putem vedea scurt\u0103turile curente pentru tot editorul, dac\u0103 mergem la Settings &gt; Editor &gt; Keyboard Shortcuts. Unele din scurt\u0103turile pe care le vei folosi mai mult sau mai pu\u021bin sunt:</p> <ul> <li>La loc de cinste se afl\u0103 F9, de care am mai zis, care compileaz\u0103 \u0219i   ruleaz\u0103 codul t\u0103u.</li> <li>Pentru a crea un fi\u0219ier gol, apas\u0103 Ctrl+Shift+N (File &gt; New &gt; Empty   file);</li> <li>Ctrl+O pentru a deschide un fi\u0219ier;</li> <li>Ctrl+S pentru a salva fi\u0219ierul curent, \u0219i Ctrl+Shift+S pentru a salva   tot;</li> <li>Ctrl+W pentru a \u00eenchide fi\u0219ierul curent \u0219i Ctrl+Shift+W pentru a   \u00eenchide toate fi\u0219ierele;</li> <li>Clasicele Ctrl+Z pentru a reversa o schimbare \u0219i Ctrl+Shift+Z pentru a   face invers, precum \u0219i Ctrl+C \u0219i Ctrl+V care nu au nevoie de   introducere;</li> <li>Ctrl \u0219i roti\u021ba de la mouse m\u0103resc sau mic\u0219oreaz\u0103 fontul, \u00een func\u021bie de   mi\u0219care;</li> <li>Shift+Enter ca s\u0103 inserezi o linie nou\u0103 sub linia curent\u0103 (ceea ce este   diferit de a ap\u0103sa Enter) \u0219i Ctrl+Enter pentru a te duce la cap\u0103tul   unei linii;</li> <li>Ctrl+Shift+C pentru a comenta \u0219i Ctrl+Shift+X pentru a decomenta;</li> <li>Ctrl+Space pentru a completa codul (ceva ce folosesc tot timpul);</li> <li>Alt+N pentru a redenumi simboluri (nu subestima aceast\u0103 scurt\u0103tur\u0103, c\u0103ci   va fi extrem de util\u0103 dac\u0103 vrei s\u0103 redenume\u0219ti o variabil\u0103 sau o func\u021bie);</li> <li>Dac\u0103 ai selectat un text, Ctrl+E selecteaz\u0103 urm\u0103toarea apari\u021bie a   selec\u021biei;</li> <li>F2 pentru a ascunde log-urile (ce se afl\u0103 \u00een partea de jos) \u0219i   Shift+F2 pentru a ascunde managerul (bara lateral\u0103). Po\u021bi ap\u0103sa acelea\u0219i   scurt\u0103turi pentru a le aduce \u00eenapoi. Dac\u0103 nu \u0219tii unde s-a dus managerul,   apas\u0103 Shift+F2;</li> <li>Shift+F11 dac\u0103 vrei s\u0103 m\u0103re\u0219ti pe tot ecranul \u0219i s\u0103 reduci distragerile;</li> <li>Uneori, \u00eenchizi un tab din gre\u0219eal\u0103. Nicio problem\u0103, apas\u0103 Ctrl+Shift+T \u0219i   revine ca prin magie la via\u021b\u0103;</li> <li>Ctrl+Tab pentru a te plimba prin tab-uri;</li> <li>Ctrl+F (\u0219i Ctrl+Shift+F) pentru a c\u0103uta textul \u00een fi\u0219ierul curent,   respectiv \u00een toate fi\u0219ierele;</li> <li>Ctrl+R (\u0219i Ctrl+Shift+R) pentru a \u00eenlocui textul \u00een fi\u0219ierul curent,   respectiv \u00een toate fi\u0219ierele.</li> </ul> <p>Totu\u0219i, exist\u0103 c\u00e2teva scurt\u0103turi pe care le vom seta noi:</p> <ul> <li>\u00cen Settings &gt; Editor &gt; Keyboard shortcuts, mergem la Edit, apoi la Toggle   comment \u0219i ad\u0103ug\u0103m scurt\u0103tura Ctrl+/. Practic ne scute\u0219te din a \u021bine   minte Ctrl+Shift+C \u0219i Ctrl+Shift+X;</li> <li>Tot aici, mergem la Plugins &gt; Source code formatter (AStyle) \u0219i punem   scurt\u0103tura Shift+Alt+F5 (sau ceva care \u00ee\u021bi este convenabil, dar care nu   mai este folosit de altceva).</li> </ul> <p>Aten\u021bie</p> <p>Dac\u0103 exist\u0103 dou\u0103 scurt\u0103turi pe care vreau s\u0103 le \u021bii minte, \u00een afar\u0103 de chestiile tipice pentru salvat, deschis fi\u0219iere etc., acestea sunt:</p> <ul> <li>F9 pentru a compila \u0219i rula codul;</li> <li>Shift+Alt+F5 (sau ce \u021bi-ai setat) pentru a formata codul. Chiar insist   pe aceast\u0103 scurt\u0103tur\u0103, \u0219i ar trebui s\u0103 o rulezi la fiecare schimbare. \u00cen   majoritatea timpului tu vei ajunge s\u0103 cite\u0219ti codul t\u0103u sau codul altora,   deci este esen\u021bial s\u0103 ai un stil consistent \u0219i u\u0219or de citit. Nimeni nu   st\u0103 s\u0103 ajusteze acolade, deci po\u021bi l\u0103sa Code::Blocks s\u0103 \u00ee\u0219i fac\u0103 treaba.   Nu pot sublinia destul importan\u021ba acestui lucru.</li> </ul>"},{"location":"cppintro/editors/windows/codeblocks/#formatare","title":"Formatare","text":"<p>Ce urmeaz\u0103 aici este strict p\u0103rere personal\u0103, \u00eens\u0103 consider c\u0103 ofer\u0103 un stil lizibil. Voi explica ra\u021bionamentul pentru fiecare alegere. Mergem la Settings &gt; Editor &gt; Source formatter.</p> <p>La tab-ul Style, alegem 1TBS (One True Brace Style). Acest stil arat\u0103 astfel:</p> <pre><code>int Foo(bool isBar)\n{\n    if (isFoo) {\n        bar();\n        return 1;\n    } else {\n        return 0;\n    }\n}\n</code></pre> <p>Ca s\u0103 nu zic prea multe (deoarece se intersecteaz\u0103 cu lec\u021bia viitoare), motivul pentru care aleg 1TBS este s\u0103 evit\u0103m urm\u0103toarea situa\u021bie:</p> <pre><code>if (isFoo)\n  bar();\n  return 1;\n</code></pre> <p>Acel <code>return 1;</code> nu este asociat cu linia de dinaintea ei sau cu <code>if</code>, deci este un dezastru care o s\u0103 se \u00eent\u00e2mple la un moment dat. Prin ad\u0103ugarea acoladelor, suntem explici\u021bi, \u0219i este mai u\u0219or de extins codul.</p> <p>Pentru consisten\u021b\u0103 la acolade cu stilul nostru (1TBS), select\u0103m toate op\u021biunile de la Brackets.</p> <p>La Indentation, nu avem de schimbat multe. Set\u0103m Indentation size la 4 (nu recomand un num\u0103r sub 4, \u00een mod special 2, \u0219i nici 8). Activ\u0103m doar Indent C++ comments beginning in column one. Este util pentru a alinia comentariile care se afl\u0103 \u00een prima coloan\u0103.</p> <pre><code>void Foo()\n{\n// comentariu\n    if (isFoo)\n        bar();\n}\n</code></pre> <p>devine</p> <pre><code>void Foo()\n{\n    // comentariu\n    if (isFoo) {\n        bar();\n    }\n}\n</code></pre> <p>La Formatting schimb\u0103m urm\u0103toarele set\u0103ri:</p> <ol> <li> <p>Select\u0103m \"Break one-line headers\". Un \"header\" \u00een acest context este orice    instruc\u021biune (<code>if</code>, <code>while</code>, <code>else</code> etc.). Cu aceast\u0103 op\u021biune, \u0219i cele pe    care le-am setat mai \u00eenainte, transform\u0103m:</p> <pre><code>void Foo(bool isFoo)\n{\n    if (isFoo1) bar1();\n\n    if (isFoo2) { bar2(); }\n}\n</code></pre> <p>\u00een</p> <pre><code>void Foo(bool isFoo)\n{\n    if (isFoo1) {\n        bar1();\n    }\n\n    if (isFoo2) {\n        bar2();\n    }\n}\n</code></pre> <p>Acoladele fac inten\u021bia noastr\u0103 mai clar\u0103 \u0219i ne permit s\u0103 ad\u0103ug\u0103m mai multe instruc\u021biuni \u00een viitor f\u0103r\u0103 mult efort. \u00cen plus, este mai uniform.</p> </li> <li> <p>Select\u0103m \"Closes whitespace in the angle brackets of template definitions\".    Pe vremuri, din cauza unui defect \u00een standard \u0219i \u00een compilatoare, nu puteai    scrie asta:</p> <pre><code>Stack&lt;int, List&lt;int&gt;&gt; stack1;\n</code></pre> <p>\u0219i trebuia \u00een schimb:</p> <pre><code>Stack&lt; int, List&lt;int&gt; &gt; stack1;\n</code></pre> <p>Acum toate compilatoarele au evoluat, deci este sigur s\u0103 activezi op\u021biunea asta. De asemenea, activeaz\u0103 \"Enable line breaking\". Acest lucru garanteaz\u0103 faptul c\u0103 o linie va fi \u00eemp\u0103r\u021bit\u0103 dac\u0103 trece de o lungime anume. Eu setez valoarea la 80 de obicei, \u00eens\u0103 120 este acceptabil dac\u0103 ai mai mult spa\u021biu orizontal.</p> </li> </ol> <p>La Padding select\u0103m:</p> <ol> <li> <p>Pad empty lines around header blocks (e.g. 'if', 'while'...). Ce face setarea    pe scurt este c\u0103 \u00eenconjoar\u0103 cu o linie nou\u0103 \u00eenainte de \u0219i dup\u0103 fiecare    header. Transform\u0103:</p> <pre><code>isFoo = true;\nif (isFoo) {\n    bar();\n} else {\n    anotherBar();\n}\nisBar = false;\n</code></pre> <p>\u00een</p> <pre><code>isFoo = true;\n\nif (isFoo) {\n    bar();\n} else {\n    anotherBar();\n}\n\nisBar = false;\n</code></pre> </li> <li> <p>Insert space padding around operators. A\u0219a cum zice \u0219i numele, pune spa\u021bii \u00een    jurul operatorilor. \u00cen loc de <code>1+1</code>, devine <code>1 + 1</code>.</p> </li> <li>Insert space padding between a header and the following paren. Dac\u0103 activ\u0103m    asta, \"dezlipim\" paranteza de <code>if</code>/<code>while</code>/...</li> <li> <p>Remove extra space padding around parentheses. Combinat cu ultima setare,    avem un singur spa\u021biu. Ele transform\u0103:</p> <pre><code>if ( isFoo( ( a+2 ), b ) ) {\n    bar ( a, b );\n}\n</code></pre> <p>\u00een</p> <pre><code>if (isFoo((a + 2), b)) {\n    bar(a, b);\n}\n</code></pre> <p>Aceast\u0103 op\u021biune nu va \u0219terge spa\u021biile \u00een plus \u00een jurul operatorilor, din p\u0103cate. Exist\u0103 op\u021biunea \u00een versiunile beta de Code::Blocks, \u00eens\u0103 nu sunt stabile.</p> </li> <li> <p>Set\u0103m Pointer alignment \u0219i Reference alignment la Name. S-au purtat r\u0103zboaie    seculare pe aceast\u0103 tem\u0103, \u00eens\u0103 le prefer pe c\u00e2t posibil s\u0103 fie la fel,    indiferent de alinierea aleas\u0103.</p> </li> </ol> <p>Acum c\u0103 am f\u0103cut aceste set\u0103ri, acest exemplu:</p> <pre><code>#include &lt;iostream&gt;\n#include &lt;cmath&gt;\nint main(){\n    int v[10];\n    for(int i=0;i&lt;10;++i) v[i]=i*sin(i);\n     for(int i=0;i&lt;10;++i) std::cout&lt;&lt;v[i]&lt;&lt;\" \"; std::cout&lt;&lt;\"\\n\";\n    bool sortat; do{\n        sortat=true;\n      for(int i=0;i&lt;9;++i){\n      if(v[i]&gt;v[i+1]){\n        int aux=v[i];\n        v[i]=v[i+1];\n        v[i+1]=aux;\n        sortat=false;\n      }}\n    } while(!sortat);\n    for(int i=0;i&lt;10;++i) std::cout&lt;&lt;v[i]&lt;&lt;\" \";  std::cout&lt;&lt;\"\\n\";\n    return 0;\n}\n</code></pre> <p>se va transforma \u00een:</p> <pre><code>#include &lt;iostream&gt;\n#include &lt;cmath&gt;\nint main()\n{\n    int v[10];\n\n    for (int i = 0; i &lt; 10; ++i) {\n        v[i] = i * sin(i);\n    }\n\n    for (int i = 0; i &lt; 10; ++i) {\n        std::cout &lt;&lt; v[i] &lt;&lt; \" \";\n    }\n\n    std::cout &lt;&lt; \"\\n\";\n    bool sortat;\n\n    do {\n        sortat = true;\n\n        for (int i = 0; i &lt; 9; ++i) {\n            if (v[i] &gt; v[i + 1]) {\n                int aux = v[i];\n                v[i] = v[i + 1];\n                v[i + 1] = aux;\n                sortat = false;\n            }\n        }\n    } while (!sortat);\n\n    for (int i = 0; i &lt; 10; ++i) {\n        std::cout &lt;&lt; v[i] &lt;&lt; \" \";\n    }\n\n    std::cout &lt;&lt; \"\\n\";\n    return 0;\n}\n</code></pre>"},{"location":"cppintro/editors/windows/codeblocks/#alte-configurari","title":"Alte configur\u0103ri","text":"<p>\u00cen primul r\u00e2nd, recomand s\u0103 activezi func\u021bia de Autosave. A\u0219a cum zice \u0219i numele, salveaz\u0103 automat proiectele la un interval anume, ca s\u0103 nu pierzi toat\u0103 munca depus\u0103 la o problem\u0103. Pentru a activa asta, du-te la Settings, apoi la Environment \u0219i la Autosave bifeaz\u0103 ambele c\u0103su\u021be. 1 minut este mai mult dec\u00e2t suficient.</p> <p>Pentru a ad\u0103uga op\u021biuni pentru compilator, mergem la Settings &gt; Compiler &gt; Other compiler options (deoarece Code::Blocks 20.03 din motive tehnice dubioase nu afi\u0219eaz\u0103 toate op\u021biunile pe care GCC le suport\u0103) \u0219i ad\u0103ug\u0103m urm\u0103toarele op\u021biuni:</p> <pre><code>-std=c++20 -Wall -Wextra -Wpedantic\n</code></pre> <p>Aceste op\u021biuni zic compilatorului s\u0103 suporte o versiune mai nou\u0103 de C++ \u0219i activ\u0103m majoritatea avertiz\u0103rilor, pentru a prinde poten\u021biale erori din timp.</p> <p>Asta este tot cu configurarea. Po\u021bi acum s\u0103 mergi c\u0103tre urm\u0103torul articol:</p> <p>Mergi la introducere</p>"},{"location":"cppintro/editors/windows/editoare-text/","title":"Op\u021biuni de editoare text (Windows)","text":"<p>La capitolul editoare de text, exist\u0103 multe op\u021biuni. Totu\u0219i, dorim urm\u0103toarele calit\u0103\u021bi de la un editor de text pentru C++:</p> <ul> <li>Syntax highlighting (eviden\u021bierea sintaxei), pentru a putea distinge u\u0219or   cuvintele cheie \u0219i a putea citi codul mai u\u0219or;</li> <li>Completare automat\u0103 (\u0219i sugestii) pentru a putea completa rapid \u0219i eficient   codul;</li> <li>Indentare automat\u0103 (\u0219i formatare), pentru a p\u0103stra un stil consistent;</li> <li>Func\u021bii de c\u0103utare \u0219i \u00eenlocuire;</li> <li>Num\u0103rarea liniilor \u0219i coloanelor;</li> <li>Suport pentru extensii;</li> <li>S\u0103 fie u\u0219or de folosit \u0219i s\u0103 consume pu\u021bine resurse.</li> </ul> <p>Urm\u0103toarele editoare \u00eendeplinesc criteriile de mai sus:</p> <ul> <li> <p> Visual Studio Code</p> <p>Visual Studio Code este un editor de cod gratuit \u0219i open-source, dezvoltat de Microsoft. Este extrem de popular datorit\u0103 integr\u0103rii sale cu multe instrumente de dezvoltare \u0219i suportului pentru extensii, oferind o experien\u021b\u0103 de codare puternic\u0103 \u0219i flexibil\u0103.</p> <p> Instalare \u0219i configurare</p> </li> <li> <p> Sublime Text 4</p> <p>Sublime Text 4 este un editor de text rapid \u0219i versatil, cunoscut pentru interfa\u021ba sa curat\u0103 \u0219i performan\u021ba excelent\u0103. Este ideal pentru dezvoltatori datorit\u0103 func\u021biilor avansate precum eviden\u021bierea sintaxei \u0219i completarea automat\u0103, al\u0103turi de un sistem robust de plugin-uri.</p> <p> Instalare \u0219i configurare</p> </li> <li> <p> Notepad++</p> <p>Notepad++ este un editor de text gratuit \u0219i open-source, renumit pentru viteza \u0219i u\u0219urin\u021ba sa de utilizare. Ofer\u0103 eviden\u021bierea sintaxei pentru o gam\u0103 larg\u0103 de limbaje de programare \u0219i suport pentru plugin-uri, fiind o alegere excelent\u0103 pentru dezvoltatorii care au nevoie de un editor eficient \u0219i u\u0219or de folosit.</p> <p> Instalare \u0219i configurare</p> </li> </ul> <p>Not\u0103</p> <p>\u00cen afar\u0103 de aceste editoare, mai exist\u0103 \u0219i altele, precum Netbeans \u0219i eternele Vim/Neovim \u0219i Emacs. De\u0219i autorul le folose\u0219te pe ultimele dou\u0103 (Emacs \u00eendeosebi), procesul de a le configura este mai anevoios \u0219i nu sunt cele mai bune pe Windows \u0219i sunt \u00een afara scopului acestui articol introductiv. De asemenea, exist\u0103 Kate \u0219i Geany, ambele cu suport bun pentru C++ \u0219i alternative solide pentru Notepad++, pe care autorul le recomand\u0103.</p>"},{"location":"cppintro/editors/windows/ide/","title":"Op\u021biuni de IDE-uri (Windows)","text":"<p>La capitolul IDE-uri, nu avem a\u0219a de multe op\u021biuni, pentru c\u0103 un IDE este fundamental mai complex. Totu\u0219i, cele mai bune op\u021biuni sunt:</p> <ul> <li> <p> Code::Blocks</p> <p>Code::Blocks este un IDE gratuit \u0219i open-source, dedicat dezvolt\u0103rii de aplica\u021bii \u00een limbajul C \u0219i C++. Este cunoscut pentru flexibilitatea sa, fiind extensibil prin plugin-uri \u0219i suport\u00e2nd diverse compilatoare. Interfa\u021ba sa prietenoas\u0103 \u0219i u\u0219urin\u021ba de utilizare \u00eel fac o alegere popular\u0103 printre programatorii C/C++. \u00cen plus, acesta este editorul implicit pentru olimpiad\u0103. Ruleaz\u0103 pe Windows, macOS, Linux, FreeBSD \u0219i OpenBSD.</p> <p> Instalare \u0219i configurare</p> </li> <li> <p> Visual Studio</p> <p>Visual Studio este un mediu de dezvoltare integrat (IDE) puternic \u0219i extensibil, dezvoltat de Microsoft. Acesta suport\u0103 o gam\u0103 larg\u0103 de limbaje de programare \u0219i tehnologii, fiind folosit pe scar\u0103 larg\u0103 pentru dezvoltarea aplica\u021biilor desktop, web \u0219i mobile. Printre caracteristicile sale se num\u0103r\u0103 un editor de cod avansat, debuger integrat, suport pentru controlul versiunilor \u0219i multe altele. Ruleaz\u0103 doar pe Windows.</p> <p> Instalare \u0219i configurare</p> </li> </ul> <ul> <li> <p> CLion</p> <p>CLion este un IDE dezvoltat de JetBrains, specializat \u00een dezvoltarea de aplica\u021bii \u00een C \u0219i C++. Acesta ofer\u0103 o gam\u0103 larg\u0103 de func\u021bionalit\u0103\u021bi avansate, cum ar fi refactorizarea codului, navigarea inteligent\u0103 \u0219i suportul pentru CMake. CLion include un debugger integrat \u0219i instrumente de analiz\u0103 a codului care ajut\u0103 la men\u021binerea unui cod curat \u0219i eficient. Este apreciat pentru productivitatea pe care o ofer\u0103 dezvoltatorilor, datorit\u0103 instrumentelor sale avansate \u0219i integr\u0103rii cu diverse sisteme de control al versiunilor. Ruleaz\u0103 pe Windows, macOS \u0219i Linux.</p> <p> Instalare \u0219i configurare</p> </li> </ul> <p>Aten\u021bie</p> <p>CLion, spre deosebire de celelalte op\u021biuni, nu este gratis. Totu\u0219i, dac\u0103 e\u0219ti eligibil, po\u021bi avea un cont de student ceea ce \u00ee\u021bi ofer\u0103 acces la CLion, precum \u0219i la alte produse marca JetBrains.</p>"},{"location":"cppintro/editors/windows/notepadpp/","title":"Notepad++","text":""},{"location":"cppintro/editors/windows/notepadpp/#instalare","title":"Instalare","text":"<p>Pentru a instala Notepad++:</p> <ol> <li> <p>Mergem pe site-ul oficial la sec\u021biunea de Downloads:</p> <p>Deschide pagina </p> <p>Alegem ultima versiune (la momentul scrierii, Notepad++ 8.6.9). Aici este link direct c\u0103tre installerul de 64 de bi\u021bi, pentru convenien\u021ba ta:</p> <p>Descarc\u0103 Notepad++ 8.6.9 </p> </li> <li> <p>Ruleaz\u0103 installerul. Procesul de instalare este simplu \u0219i set\u0103rile implicite    sunt de ajuns pentru toat\u0103 lumea, deci po\u021bi da Next \u00een continuare p\u00e2n\u0103 c\u00e2nd    se termin\u0103 procesul.</p> </li> </ol>"},{"location":"cppintro/editors/windows/notepadpp/#configurare","title":"Configurare","text":"<p>Acum vremea s\u0103-l configur\u0103m, pentru c\u0103 nu ne este prea utilizabil \u00een acest moment.</p> <ol> <li>Fontul implicit, Courier New... nu este prea bun. Pentru a schimba fontul,    mergem la Set\u0103ri \u0219i apoi la Configurator de stiluri. De acolo, putem modifica    orice legat de tema curent\u0103. Notepad++ are mai multe teme din care po\u021bi    alege, a\u0219a c\u0103 po\u021bi experimenta cu asta. Selecteaz\u0103 tema Default    (stylers.xml), \u0219i la stil font alege fontul Cascadia Mono sau Consolas (sau    alt font monospa\u021biat, dac\u0103 ai alte preferin\u021be). Po\u021bi cre\u0219te m\u0103rimea fontului    (eu \u021bin la 12, consider c\u0103 10 este o m\u0103rime prea mic\u0103). Dup\u0103 ce ai f\u0103cut    aceste lucruri, bifeaz\u0103 Activare global\u0103 font \u0219i Activare global\u0103 m\u0103rime    font. F\u0103 acela\u0219i set\u0103ri pentru tema DarkModeDefault (sau ce alt\u0103 tem\u0103 dore\u0219ti    s\u0103 ai).</li> <li>Acum vom vedea set\u0103rile din Set\u0103ri &gt; Preferin\u021be. Un prim lucru pe care \u00eel    putem face este s\u0103 avem ni\u0219te icoane mai moderne. Selecteaz\u0103 din Generale    op\u021biunea UI fluent umplut: mic (de\u0219i po\u021bi experimenta cu icoanele).</li> <li>Ca s\u0103 nu fim orbi\u021bi, mergi la Modul \u00eentunecat \u0219i alege fie Modul \u00eentunecat,    fie Urmarea ferestrelor, care ajusteaz\u0103 modul \u00een func\u021bie de set\u0103rile globale    din Windows. Po\u021bi s\u0103 personalizezi \u0219i culoarea temei, dar \"Negru\" arat\u0103 cel    mai bine, dup\u0103 p\u0103rerea mea.</li> <li>Implicit, Notepad++ indenteaz\u0103 folosind tab-uri. Pentru a schimba acest    comportament, mergem la Limbaje \u0219i alegem Indenteaz\u0103 folosind: Caracter(e)    spa\u021biu. Recomand indentare cu 4 spa\u021bii (setarea implicit\u0103), \u00eens\u0103 alte valori    comune includ 2, 3 \u0219i 8 (nu recomand ultima op\u021biune). At\u00e2ta timp c\u00e2t este o    valoare peste 1, este \u00een regul\u0103.</li> <li>Acum ajust\u0103m autocompletarea (rudimentar\u0103 \u00een Notepad++, dar exist\u0103 cel    pu\u021bin). Implicit ofer\u0103 sugestii pentru func\u021bii \u0219i cuvinte. Recomand s\u0103 bifezi    tot ce se afl\u0103 la autoinserare (fiecare grup de paranteze \u0219i ghilimele)    pentru c\u0103 \u00een marea majoritate a cazurilor le vei g\u0103si \u00een perechi \u0219i    economise\u0219te ceva timp.</li> </ol> <p>Dup\u0103 toate aceste schimb\u0103ri, editorul ar trebui s\u0103 arate astfel:</p> <p>\u00cen acest moment, Notepad++ este doar un editor simplu \u0219i nu este potrivit program\u0103rii \u00een C++, deci mai trebuie s\u0103 facem configur\u0103ri. Trebuie s\u0103 instal\u0103m ni\u0219te module \u00eenainte. Pentru asta, mergem la Module &gt; Administrare module. De acolo, select\u0103m urm\u0103toarele module:</p> <ul> <li>AutoSave, pentru a salva automat fi\u0219ierele;</li> <li>BracketsCheck, pentru a verifica dac\u0103 am balansat acoladele sau parantezele   (riscul ar trebui s\u0103 fie minimizat de autocompletarea parantezelor, dar nu se   \u0219tie);</li> <li>CodeAlignment, \u00een caz c\u0103 vrei s\u0103 aliniezi codul dup\u0103 semnele de egal   (op\u021bional, dar dr\u0103gu\u021b de avut);</li> <li>Comment Toggler \u0219i CommentWrap pentru comentarii, face lucrul cu acestea mai   u\u0219or;</li> <li>ComparePlus, folosit pentru a compara dou\u0103 fi\u0219iere (mai puternic dec\u00e2t s\u0103 tot   schimbi \u00eentre tab-uri pentru a vedea diferen\u021ba dintre dou\u0103 fi\u0219iere);</li> <li>Discord Rich Presence, dac\u0103 sim\u021bi nevoia s\u0103 te lauzi pe Discord c\u0103 ai   Notepad++ (nu \u0219tiu de ce ai face asta);</li> <li>MenuIcons, dac\u0103 vrei s\u0103 ai icoane \u0219i \u00een meniuri (op\u021bional, dar recomandat);</li> <li>Cel mai important modul, NppExec, care ne permite s\u0103 execut\u0103m script-uri   f\u0103r\u0103 s\u0103 p\u0103r\u0103sim Notepad++. Cu asta vom compila \u0219i executa C++;</li> <li>Pentru cei care doresc, exist\u0103 NppOpenAI, ca s\u0103-l conectezi la ChatGPT.</li> </ul> <p>Dup\u0103 ce ai selectat acele module, apas\u0103 butonul de Instalare (dac\u0103 totu\u0219i ie\u0219i accidental, selec\u021bia va r\u0103m\u00e2ne). Notepad++ se va \u00eenchide pentru a-\u0219i putea instala modulele. Acum pentru a configura fiecare modul. Fiecare setare se afl\u0103 \u00een Module, sub numele fiec\u0103rui modul.</p> <ol> <li>Pentru AutoSave, select\u0103m Notepad++ loses focus (\u00een caz c\u0103 dai Alt+Tab)    \u0219i At timed intervals every 10 minutes. Po\u021bi configura ultima op\u021biune s\u0103 fie    c\u00e2t de des vrei tu. Este la alegerea ta dac\u0103 vrei s\u0103 se autosalveze \u0219i c\u00e2nd    schimbi tab-ul (File tab changes) sau c\u00e2nd \u00eenchizi programul (Notepad++    exists).</li> <li>Pentru CodeAlignment, cea mai util\u0103 scurt\u0103tur\u0103 este Ctrl+Shift+=,    care te las\u0103 s\u0103 aliniezi selec\u021bia dup\u0103 ce vrei tu (de obicei o vei folosi    pentru egaluri sau virgule);</li> <li>Pentru Comment Toggler, po\u021bi folosi scurt\u0103tura Ctrl+Q pentru a comenta    sau decomenta selec\u021bia curent\u0103. Po\u021bi explora ce face Comment Wrap \u0219i chiar s\u0103    adaugi propriile tale scurt\u0103turi pentru fiecare func\u021bionalitate;</li> <li> <p>Cel mai complicat pas va fi la NppExec, pentru c\u0103 acesta va compila    propriu-zis codul nostru. Du-te la Module &gt; NppExec &gt; Execute NppExec Script    (alternativ, F6, scurt\u0103tur\u0103 pe care o vei folosi mult) \u0219i scrie    urm\u0103toarea comand\u0103 (voi explica fiecare pas imediat):</p> <pre><code>npp_save\ng++ -std=c++20 -O2 \"$(FULL_CURRENT_PATH)\" -o \"$(CURRENT_DIRECTORY)\\$(NAME_PART).exe\"\ncmd /c start cmd /c \"$(CURRENT_DIRECTORY)\\$(NAME_PART).exe &amp; pause\"\n</code></pre> <ol> <li>Prima linie salveaz\u0103 fi\u0219ierul curent;</li> <li>A doua linie folose\u0219te g++, pe care l-am instalat la sec\u021biunea cu GCC    (MinGW). Compileaz\u0103 folosind standardul C++20 \u0219i optimizat pentru    performan\u021b\u0103. Ia fi\u0219ierul curent (<code>calea/catre/nume.cpp</code>) \u0219i creeaz\u0103 un    executabil numit <code>nume.exe</code> \u00een directorul curent.</li> <li>A treia linie pur \u0219i simplu porne\u0219te un terminal extern, ca s\u0103 putem    interac\u021biona cu programul. Din p\u0103cate, Windows Defender scaneaz\u0103    executabilul nostru, deci va \u00eenghe\u021ba timp de c\u00e2teva secunde. Po\u021bi ad\u0103uga    o excep\u021bie din Windows Defender (ca s\u0103 nu faci 100 de directoare pentru    fiecare proiect, adaug\u0103 tot \u00eentr-un director \u0219i adaug\u0103-l pe \u0103la ca    excep\u021bie).</li> </ol> <p>Acum tot ce trebuie s\u0103 faci este s\u0103 ape\u0219i Save \u0219i d\u0103-i numele C++. Dup\u0103 aceea, po\u021bi s\u0103 ape\u0219i secven\u021ba F6+Enter ca s\u0103 compilezi \u0219i rulezi codul.</p> </li> </ol> <p>Ai tot ce trebuie pentru a putea compila C++. Nu este o experien\u021b\u0103 la fel de bun\u0103 ca pe alte editoare, din moment ce ai autocompletare rudimentar\u0103, dar este suficient \u00een majoritatea cazurilor dac\u0103 \u0219tii ce faci. Legat de proiecte, nu prea ai propriu-zis conceptul \u0103sta, a\u0219a c\u0103 doar creezi un fi\u0219ier cu extensia <code>.cpp</code>, eventual \u0219i alte fi\u0219iere de care ai nevoie, \u0219i compilezi direct.</p> <p>Asta este tot cu configurarea. Po\u021bi acum s\u0103 mergi c\u0103tre urm\u0103torul articol:</p> <p>Mergi la introducere</p>"},{"location":"cppintro/editors/windows/optiuni-editoare/","title":"Op\u021biuni de editoare (Windows)","text":"<p>Exist\u0103 dou\u0103 tipuri de editoare folosite pentru a scrie cod (nu doar \u00een C++):</p> <ul> <li> <p> Editoare de text</p> <p>Un editor de text este un program simplu folosit pentru scrierea \u0219i editarea codului surs\u0103 C++. Exemple de astfel de editoare includ Vim, Emacs, Notepad++, Geany, Kate, Sublime Text, \u0219i Visual Studio Code, printre altele. Acestea sunt ideale pentru editarea de fi\u0219iere de cod C++ simple, oferind func\u021bionalit\u0103\u021bi de baz\u0103 precum eviden\u021bierea sintaxei \u0219i completarea automat\u0103.</p> <p>Editoarele de text consum\u0103 mai pu\u021bin\u0103 memorie dec\u00e2t un IDE, \u00eens\u0103 trebuie s\u0103 fie configurate pentru a putea suporta C++ la un nivel satisf\u0103c\u0103tor.</p> <p> Vezi op\u021biuni</p> </li> <li> <p> IDE</p> <p>Un mediu de dezvoltare integrat (IDE) pentru C++ este un software complex care ofer\u0103 dezvoltatorilor un set complet de instrumente pentru scrierea, compilarea, testarea \u0219i depanarea codului C++. Exemple de IDE-uri pentru C++ includ Visual Studio 2022, CLion, Qt Creator \u0219i Code::Blocks. Acestea includ func\u021bionalit\u0103\u021bi avansate precum depanare interactiv\u0103, integrare cu sisteme de control al versiunilor, instrumente de profilare \u0219i optimizare a codului, \u0219i multe alte instrumente care faciliteaz\u0103 dezvoltarea de aplica\u021bii complexe \u00een C++. Fiind programe mai complexe, ele consum\u0103 mai mult\u0103 memorie \u0219i mai mult spa\u021biu, \u00eens\u0103 ofer\u0103 toate uneltele necesare.</p> <p> Vezi op\u021biuni</p> </li> </ul>"},{"location":"cppintro/editors/windows/qt-creator/","title":"Qt Creator (Windows)","text":"<p>TODO</p>"},{"location":"cppintro/editors/windows/sublime-text-4/","title":"Sublime Text 4 (Windows)","text":""},{"location":"cppintro/editors/windows/sublime-text-4/#instalare","title":"Instalare","text":"<p>Procesul de instalare este unul foarte simplu:</p> <ol> <li> <p>Descarc\u0103 installerul de Sublime Text 4:</p> <p>Link direct </p> </li> <li> <p>Dup\u0103 ce s-a desc\u0103rcat, ruleaz\u0103 installerul (care ar trebui s\u0103 fie numit     <code>sublime_text_build_{versiune}_x64_setup.exe</code>) \u0219i urm\u0103re\u0219te pa\u0219ii de pe     ecran.</p> </li> </ol> <p>Alternativ, po\u021bi desc\u0103rca varianta portabil\u0103 de aici. Ea este util\u0103 de pild\u0103 la \u0219coal\u0103, unde nu ai drepturi de administrator pentru a putea instala Sublime Text 4 \u00een mod normal.</p> <p>Descarc\u0103 arhiva .zip </p>"},{"location":"cppintro/editors/windows/sublime-text-4/#configurare-si-utilizare","title":"Configurare \u0219i utilizare","text":"<p>Ca orice editor de text, Sublime Text 4 nu vine implicit cu suport de C++, \u00eens\u0103 putem s\u0103 configur\u0103m editorul folosind pachetele pe care le avem la dispozi\u021bie. Pachetele se g\u0103sesc prin Package Control. Pentru a instala suportul de pachete, ap\u0103s\u0103m Ctrl+Shift+P (Tools &gt; Command Palette) \u0219i tast\u0103m \"ipc\" (Install Package Control) \u0219i ap\u0103s\u0103m Enter. Dac\u0103 apare un pop-up care zice \"Package Control was successfully installed\", atunci s-a instalat cu succes.</p> <p>Command Palette ne va fi de folos \u00een majoritatea timpului nostru pe ST4, deci este bine s\u0103 te obi\u0219nuie\u0219ti cu el. Din Command Palette, tast\u0103m \"pip\" (Package Control: Install Package) \u0219i ap\u0103s\u0103m Enter. Avem nevoie de urm\u0103toarele pachete:</p> <ol> <li>SideBarEnhancements, care adaug\u0103 mai multe op\u021biuni pentru manipularea    fi\u0219ierelor din bara lateral\u0103 (vizibil\u0103 cu Ctrl+K, Ctrl+B). \u00cen esen\u021b\u0103,    face bara lateral\u0103 s\u0103 fie mult mai util\u0103;</li> <li>LSP, care transform\u0103 ST4 \u00eentr-un editor mult mai avansat. Interfa\u021beaz\u0103    \u00eentre diverse servere pentru a putea oferi autocompletare, redenumirea    simbolurilor etc. De acolo, instal\u0103m \u0219i LSP-clangd, care ofer\u0103 suport    pentru serverul <code>clangd</code>;</li> <li>BracketHighlighter, care are scopul de a eviden\u021bia perechile de paranteze    (<code>()</code>, <code>[]</code>, <code>&lt;&gt;</code>, <code>{}</code>);</li> <li>Terminus, care ofer\u0103 un terminal real \u00een ST4;</li> <li>A File Icon, care ofer\u0103 icoane mai bune. Este ceva mai mult estetic;</li> <li>SublimeLinter, care ofer\u0103 suport pentru linting. Ce \u00eenseamn\u0103 asta,    mai pe larg, este c\u0103 pachetul acesta \u00ee\u021bi permite s\u0103 vezi erorile \u0219i    avertiz\u0103rile de la compilator \u0219i \u00ee\u021bi verific\u0103 sintaxa. Pentru C++, mai    trebuie s\u0103 instal\u0103m    \u0219i SublimeLinter-contrib-clang, SublimeLinter-contrib-clang-tidy \u0219i SublimeLinter-contrib-cppcheck;</li> <li>CMakeBuilder, pentru a putea compila \u0219i rula codul mai u\u0219or;</li> <li>CppFastOlympicCoding, care este f\u0103cut pentru a optimiza ST4 pentru concursuri    \u0219i olimpiade. Este op\u021bional, \u00eens\u0103 \u00eel recomand pe viitor.</li> </ol> <p>Acum c\u0103 avem toate aceste pachete, s\u0103 le configur\u0103m.</p> <p>Pentru <code>clangd</code>, <code>clang-tidy</code>, <code>cmake</code> \u0219i <code>clang-format</code>, dac\u0103 ai instalat compilatorul MinGW cum am indicat \u00een articolul trecut \u0219i nu ai exclus LLVM, nu trebuie s\u0103 faci nimic pentru a instala aceste programe. Pentru <code>cppcheck</code>, alege installerul de pe aceast\u0103 pagin\u0103 \u0219i urm\u0103re\u0219te instruc\u021biunile de pe ecran.</p> <p>Pentru a configura <code>clangd</code>, mergem la Preferences &gt; Package Settings &gt; LSP &gt; Servers &gt; LSP-clangd (sau Preferences: LSP-clangd settings din Command Palette). Se va deschide o nou\u0103 fereastr\u0103 \u00eemp\u0103r\u021bit\u0103 \u00een dou\u0103. Pe partea st\u00e2ng\u0103 se afl\u0103 toate configur\u0103rile pe care le avem la dispozi\u021bie, iar pe partea dreapt\u0103 se afl\u0103 configurarea utilizatorului, adic\u0103 set\u0103rile pe care vrem s\u0103 le aplic\u0103m. Eu folosesc aceste set\u0103ri: <pre><code>{\n   \"initializationOptions\": {\n      \"clangd.compile-commands-dir\": \"build\",\n      \"clangd.background-index\": true,\n      \"clangd.clang-tidy\": true,\n      \"clangd.completion-style\": \"detailed\",\n      \"clangd.function-arg-placeholders\": true,\n      \"clangd.header-insertion\": \"iwyu\",\n      \"clangd.header-insertion-decorators\": true,\n      \"clangd.malloc-trim\": true,\n   }\n}\n</code></pre></p> <p>Mai trebuie s\u0103 configur\u0103m \u0219i plugin-ul LSP. Pentru acest lucru, mergem la Preferences: LSP settings din Command Palette. <pre><code>{\n   \"lsp_format_on_save\": true,\n}\n</code></pre></p> <p>Urmeaz\u0103 s\u0103 configur\u0103m \u0219i formatarea codului. Dup\u0103 p\u0103rerea mea, stilul implicit pe care \u00eel are <code>clangd</code> mai mult \u00eencurc\u0103. Pentru a schimba stilul, putem l\u0103sa un fi\u0219ier \u00een fiecare proiect pe care \u00eel avem numit <code>.clang-format</code> (numit exact a\u0219a!). Stilul arhivei (\u0219i un stil pe care \u00eel recomand, de altfel) este acesta: <pre><code>---\nBasedOnStyle: Google\nAccessModifierOffset: -4\nAlignArrayOfStructures: Left\nAlignOperands: AlignAfterOperator\nAllowShortBlocksOnASingleLine: Empty\nAllowShortIfStatementsOnASingleLine: AllIfsAndElse\nAllowShortLoopsOnASingleLine: false\nBreakBeforeBinaryOperators: NonAssignment\nIndentCaseLabels: false\nIndentPPDirectives: BeforeHash\nIndentWidth: 4\nInsertBraces: true\nPointerAlignment: Right\nQualifierAlignment: Left\nSortIncludes: CaseInsensitive\nTabWidth: 4\n</code></pre></p> <p>Aten\u021bie</p> <p><code>clang-format</code> trebuie s\u0103 fie cel pu\u021bin la versiunea 15. Po\u021bi vedea acest lucru cu <code>clang-format --version</code> \u00eentr-un terminal. Dac\u0103 ai instalat compilatorul de pe Winlibs, el se afl\u0103 curent la versiunea 18, deci este totul \u00een regul\u0103.</p> <p>Ca s\u0103 func\u021bioneze optim, avem nevoie s\u0103 facem un proiect CMake. Din fericire, este un proces simplu. Avem nevoie doar de dou\u0103 fi\u0219iere \u00eentr-un folder: <code>main.cpp</code> (unde vei scrie codul) \u0219i <code>CMakeLists.txt</code> (numele trebuie s\u0103 fie exact acesta!).</p> <p>Ca s\u0103 te duci la un folder, du-te la File &gt; Open Folder. Dac\u0103 nu l-ai creat deja, acum ar fi momentul. Apas\u0103 Ctrl+N pentru a crea un fi\u0219ier \u0219i copiaz\u0103 urm\u0103torul con\u021binut (eu schimb doar <code>PROJECT_NAME</code> s\u0103 reflecte proiectul curent/problema curent\u0103): <pre><code>cmake_minimum_required(VERSION 3.10..3.99)\n\nset(PROJECT_NAME \"problema_interesanta\")\n\nproject(${PROJECT_NAME}\n   VERSION 0.1.0\n   LANGUAGES CXX)\n\nset(CMAKE_CXX_STANDARD 20)\nset(CMAKE_CXX_STANDARD_REQUIRED ON)\nset(CMAKE_CXX_EXTENSIONS OFF)\n\nset(CMAKE_EXPORT_COMPILE_COMMANDS ON)\n\nadd_executable(${PROJECT_NAME} main.cpp)\n\nset_target_properties(${PROJECT_NAME} PROPERTIES\n    RUNTIME_OUTPUT_DIRECTORY \"${CMAKE_BINARY_DIR}/bin\"\n)\n</code></pre></p> <p>Aten\u021bie</p> <p><code>PROJECT_NAME</code> nu poate s\u0103 con\u021bin\u0103 spa\u021bii. \u00cenlocuie\u0219te-le cu bar\u0103 jos (<code>_</code>) ca \u00een exemplu sau <code>-</code>.</p> <p>Salveaz\u0103-l \u00een <code>CMakeLists.txt</code> (trebuie s\u0103 fie exact acest nume!).</p> <p>Adaug\u0103 asta \u00een <code>main.cpp</code>: <pre><code>#include &lt;iostream&gt;\n\nint main() {\n    std::cout &lt;&lt; \"Hello, world!\" &lt;&lt; std::endl;\n    return 0;\n}\n</code></pre></p> <p>Din Command Palette, execut\u0103 \"CMakeBuilder: Configure\". Dac\u0103 apare ceva \u00een josul ecranului care are un mesaj similar cu: <pre><code>-- Configuring done\n-- Generating done\n-- Build files have been written to: ...\n[Finished in 64ms]\n</code></pre> atunci procesul a reu\u0219it.</p> <p>Acum te po\u021bi duce pe <code>main.cpp</code> \u0219i s\u0103 rulezi \"LSP: Enable Language Server Globally\" (sau In Project) din Command Palette \u0219i selecteaz\u0103 clangd. Dac\u0103 totul merge cum trebuie, ar trebui ca <code>iostream</code> s\u0103 fie subliniat \u0219i \u00een bara de status (cea de jos) s\u0103 scrie <code>clangd</code>.</p> <p>Pentru a rula proiectul, apas\u0103 pe Ctrl+Shift+B \u0219i alege op\u021biunea \"Default: Run - ...\" (unde ... este numele proiectului (ales la <code>PROJECT_NAME</code>)). Dup\u0103 asta, apas\u0103 Enter (nu avem argumente) \u0219i, dac\u0103 totul a mers \u00een regul\u0103, vei vedea un ecran similar cu acesta:</p> <pre><code>[ 50%] Building CXX object CMakeFiles/testspatii.dir/main.cpp.o\n[100%] Linking CXX executable bin/problema_interesanta\n[100%] Built target problema_interesanta\nHello, world!\nprocess is terminated with return code 0.\n</code></pre> <p>Prima linie poate s\u0103 difere.</p> <p>\u00cen momentul de fa\u021b\u0103, ai o experien\u021b\u0103 acceptabil\u0103 \u0219i po\u021bi s\u0103 continui mai departe, \u00eens\u0103 o s\u0103 \u00eembun\u0103t\u0103\u021bim experien\u021ba \u0219i mai mult.</p> <p>Deschide Preferences: Settings din Command Palette. Aici se afl\u0103 preferin\u021bele globale ale utilizatorului, \u0219i acestea sunt cele care ne intereseaz\u0103 momentan. Tot ce vom scrie se va afla \u00eentre acolade, la fel ca la celelalte set\u0103ri.</p> <ol> <li>Vom schimba m\u0103rimea fontului, deoarece ea este prea mic\u0103 \u00een mod normal:    <pre><code>\"font_size\": 12,\n</code></pre></li> <li>A\u0219a cum putem schimba m\u0103rimea fontului, putem schimba \u0219i fontul \u00een sine.    Recomand Cascadia Code/Mono sau Consolas, de\u0219i po\u021bi g\u0103si alte fonturi care    \u00ee\u021bi plac pe internet:    <pre><code>\"font_face\": \"Cascadia Code\",\n</code></pre></li> <li>Cel mai probabil nu vei tr\u0103i \u00een Sublime Text 4 pentru totdeauna, deci va    trebui s\u0103 schimbi tabul sau fereastra. Setarea <code>save_on_focus_lost</code> salveaz\u0103    fi\u0219ierul automat, ca s\u0103 nu pierzi progresul \u00een cazul \u00een care \u00eenchizi din gre\u0219eal\u0103    editorul:    <pre><code>\"save_on_focus_lost\": true,\n</code></pre></li> <li>Setarea <code>highlight_line</code> va eviden\u021bia linia curent\u0103, ceea ce poate fi util dac\u0103 nu vezi    unde ai cursorul:    <pre><code>\"highlight_line\": true,\n</code></pre></li> <li>Implicit, totul este cam \u00eengr\u0103m\u0103dit, a\u0219a c\u0103 putem l\u0103sa editorul s\u0103 respire pu\u021bin:    <pre><code>\"line_padding_bottom\": 4,\n\"line_padding_top\": 4,\n</code></pre>    Evident, po\u021bi ajusta dac\u0103 \u021bi se pare prea mult, \u00eens\u0103 consider c\u0103 4 este o setare adecvat\u0103.</li> <li>ST4 arat\u0103 destul de modern, \u00eens\u0103 putem s\u0103 \u00eembun\u0103t\u0103\u021bim tema \u0219i mai mult.    Pentru interfa\u021b\u0103, prefer s\u0103 \u00eel \u021bin pe Adaptive, deoarece se integreaz\u0103 mai    bine cu bara de meniu \u0219i cu restul interfe\u021bei:    <pre><code>\"theme\": \"Adaptive.sublime-theme\",\n</code></pre></li> </ol> <p>Pentru editor, aici este o decizie personal\u0103 \u0219i au avut loc b\u0103t\u0103lii    seculare (bine, nu la fel de mari ca la Vim vs Emacs), a\u0219a c\u0103 vom instala    pachetul Colorsublime, pentru a vedea \u00een timp real cum va ar\u0103ta interfa\u021ba.    Acesta are \u0219i un site (https://colorsublime.github.io) unde po\u021bi vedea    aceste teme \u00een timp real. Dup\u0103 ce ai instalat pachetul, ruleaz\u0103    Colorsublime: Install Theme din Command Palette \u0219i deruleaz\u0103 prin zecile    de teme pe care le ai la dispozi\u021bie. 7. Urm\u0103toarele set\u0103ri au de-a face cu spa\u021biile albe:    <pre><code>\"translate_tabs_to_spaces\": true,\n\"trim_trailing_white_space_on_save\": \"all\",\n</code></pre> 8. Pentru a avea \u00een vedere limita de 80 caractere setat\u0103 la sec\u021biunea de formatare,    putem ad\u0103uga urm\u0103toarea setare:    <pre><code>\"rulers\": [80],\n</code></pre></p> <p>\u00cen final, configurarea ta ar trebui s\u0103 arate similar cu asta: <pre><code>{\n   \"font_size\": 12,\n   \"font_face\": \"Cascadia Code\",\n   \"save_on_focus_lost\": true,\n   \"highlight_line\": true,\n   \"line_padding_bottom\": 4,\n   \"line_padding_top\": 4,\n   \"theme\": \"Adaptive.sublime-theme\",\n   \"color_scheme\": \"Packages/Colorsublime - Themes/Tomorrow_Night.tmTheme\",\n   \"translate_tabs_to_spaces\": true,\n   \"trim_trailing_white_space_on_save\": \"all\",\n   \"rulers\": [80],\n}\n</code></pre></p> <p>Asta este tot cu configurarea. Po\u021bi acum s\u0103 mergi c\u0103tre urm\u0103torul articol:</p> <p>Mergi la introducere</p>"},{"location":"cppintro/editors/windows/visual-studio-2022/","title":"Visual Studio 2022","text":""},{"location":"cppintro/editors/windows/visual-studio-2022/#instalare","title":"Instalare","text":"<p>Pentru a instala:</p> <ol> <li> <p>Descarc\u0103 executabilul de setup de aici (Visual Studio 2022 Community, este    varianta gratuit\u0103 \u0219i arhisuficient\u0103 pentru nevoile tale):</p> <p>Descarc\u0103 Visual Studio 2022 Community </p> </li> <li> <p>Ruleaz\u0103 executabilul. La prima fereastr\u0103 cu titlul Visual Studio Installer,    apas\u0103 pe butonul Continue. Dup\u0103 ce se descarc\u0103 installer-ul oficial, o s\u0103 ai    o fereastr\u0103 similar\u0103 cu asta:</p> <p> </p> </li> <li> <p>Visual Studio 2022 are conceptul de workload. Fiecare workload este    specializat pe un anumit domeniu sau limbaj \u0219i instaleaz\u0103 un set anume de    componente. Majoritatea workload-urilor sunt \u021bintate c\u0103tre cei pe C#, \u00eens\u0103 pe    noi ne intereseaz\u0103 workload-ul Desktop development with C++. A\u0219a ar    trebui s\u0103 arate fereastra ta dup\u0103 ce ai selectat op\u021biunea asta:</p> <p> </p> </li> <li> <p>Apas\u0103 butonul de install \u0219i a\u0219teapt\u0103 s\u0103 se instaleze. Dup\u0103 cum se poate vedea    \u00een ultima poz\u0103, este destul de mare Visual Studio. Totu\u0219i, dup\u0103 ce se termin\u0103    de instalat, se deschide singur. La aceast\u0103 fereastr\u0103, ori te po\u021bi loga cu    contul de GitHub sau Microsoft, ori po\u021bi s\u0103 dai skip, nu e necesar s\u0103 ai un    cont pentru a putea folosi Visual Studio.</p> <p> </p> </li> <li> <p>La urm\u0103toarea fereastr\u0103, po\u021bi s\u0103 la\u0219i set\u0103rile implicite sau s\u0103 schimbi tema.    Tot ce mai r\u0103m\u00e2ne s\u0103 faci este s\u0103 ape\u0219i pe \"Start Visual Studio\" \u0219i s\u0103    a\u0219tep\u021bi pu\u021bin \u00een timp ce se configureaz\u0103. Dac\u0103 tot procesul a mers cum    trebuie, se va deschide aceast\u0103 fereastr\u0103:</p> <p> </p> </li> </ol>"},{"location":"cppintro/editors/windows/visual-studio-2022/#configurare-si-utilizare","title":"Configurare \u0219i utilizare","text":"<p>Felicit\u0103ri! Ai instalat Visual Studio 2022. Acum vremea s\u0103 \u00eel configur\u0103m \u0219i folosim.</p> <p>Pentru a crea un proiect C++, facem urm\u0103torii pa\u0219i:</p> <ol> <li>La fereastra de mai sus (care apare \u00een momentul \u00een care deschizi Visual    Studio 2022), apas\u0103 pe \"Create a new project\".</li> <li> <p>O s\u0103 fii \u00eent\u00e2mpinat de mai multe \u0219abloane pe care le po\u021bi folosi:</p> <p> </p> </li> <li> <p>Avem dou\u0103 \u0219abloane care ni-s utile:</p> <ol> <li>Console App, care gestioneaz\u0103 proiectul folosind MSBuild \u0219i este specific    Visual Studio;</li> <li>CMake Project, care poate rula pe mai multe platforme (oriunde este    suportat CMake, inclusiv Linux \u0219i *BSD) \u0219i nu este limitat de Visual    Studio.</li> </ol> <p>Dac\u0103 nu ai nevoie s\u0103 editezi proiectul \u0219i cu alte editoare/IDE-uri sau pe alte platforme, Console App este suficient, a\u0219a c\u0103 asta vom folosi \u0219i noi acum. D\u0103 dublu click pe Console App (sau selecteaz\u0103-l, apoi apas\u0103 Next).</p> </li> <li> <p>Ajungem la aceast\u0103 fereastr\u0103:</p> <p> </p> <p>\u00cen primul r\u00e2nd, avem numele proiectului.</p> <p>Sfat</p> <p>F\u0103 numele proiectului sugestiv, chiar numele problemei la care lucrezi acum, pentru c\u0103 nu este prea dr\u0103gu\u021b s\u0103 umpli printr-o mare de proiecte care \u00eencep cu ConsoleApplication.</p> <p>Apoi avem loca\u021bia acestuia. Calea implicit\u0103 este <code>$USER\\source\\repos</code>, dar po\u021bi s\u0103-l pui undeva separat (recomand acest lucru). Dup\u0103 loca\u021bie avem numele solu\u021biei. O solu\u021bie este un container pentru unul sau mai multe proiecte. Po\u021bi selecta \u0219i dac\u0103 vrei s\u0103 fie solu\u021bia \u0219i proiectul \u00een acela\u0219i director (caz \u00een care numele proiectului este acela\u0219i cu cel al solu\u021biei).</p> <p>Aten\u021bie</p> <p>Nu exist\u0103 solu\u021bii dac\u0103 alegi \u0219ablonul cu CMake. Exist\u0103 moduri prin care po\u021bi emula acest lucru, dar cea mai simpl\u0103 cale (f\u0103r\u0103 integrarea de care ai parte cu Console App) este s\u0103 pui \u00een directoare separate (de fapt, asta face \u0219i o solu\u021bie).</p> <p>Sfat</p> <p>Nu este obligatoriu, \u00eens\u0103 dac\u0103 lucrezi de pe un site (e.g. Kilonova) sau faci probleme de la un concurs, recomand s\u0103 le grupezi \u00eentr-o solu\u021bie. Zece solu\u021bii sunt mult mai u\u0219or de gestionat dec\u00e2t 40 de proiecte, dac\u0103 este nevoie s\u0103 cau\u021bi pe viitor rezolv\u0103rile la o problem\u0103.</p> <p>De dragul exemplului, voi numi proiectul \"ConsoleApplication1\" sub loca\u021bia implicit\u0103 \u0219i pun proiectul \u00een acela\u0219i loc cu solu\u021bia. Dac\u0103 totul a mers cum trebuie, vei vedea o fereastr\u0103 similar\u0103 cu asta:</p> <p> </p> </li> </ol> <p>Po\u021bi acum s\u0103 ape\u0219i Ctrl+F5 (Start without Debugging) \u0219i vei vedea c\u0103 ruleaz\u0103 programul \u0219i afi\u0219eaz\u0103 Hello World. Asta \u00eenseamn\u0103 \u0219i c\u0103 ai compilatorul MSVC func\u021bional.</p> <p>Sfat</p> <p>Obi\u0219nuie\u0219te-te cu aceast\u0103 scurt\u0103tur\u0103 (Ctrl+F5), o s\u0103 o folose\u0219ti foarte des. \u00cen timp, uit\u0103-te prin meniuri \u0219i \u00eenva\u021b\u0103 ni\u0219te scurt\u0103turi comune pentru ac\u021biunile pe care le faci cele mai des, a\u0219a vei deveni mai rapid \u0219i mai fluid la a folosi Visual Studio. Vezi aceast\u0103 pagin\u0103 care este cheatsheet de la Microsoft cu cele mai comune scurt\u0103turi specifice VS. Scurt\u0103turile generale gen Ctrl+C, Ctrl+V, Ctrl+S etc. le po\u021bi g\u0103si \u0219i din VS \u0219i sunt \u00een mare parte general valabile.</p> <p>Acum, timpul pentru ni\u0219te chestii pe care le po\u021bi face ca s\u0103 \u00eembun\u0103t\u0103\u021be\u0219ti performan\u021ba (VS este un program mare \u0219i ia mult\u0103 memorie, deci poate fi uneori \u00eencet):</p> <ol> <li> <p>Visual Studio deschide automat fi\u0219ierele care au fost deschise \u00een vechea    sesiune. Din aceast\u0103 pricin\u0103, o solu\u021bie poate lua mai mult s\u0103 se deschid\u0103,    pentru c\u0103 toate fi\u0219ierele sunt analizate \u00een paralel. Pentru a dezactiva acest    comportament:</p> <ol> <li>Apas\u0103 \u00een meniu pe Tools, apoi Options (ultima din dropdown, cea cu o    roti\u021b\u0103 zim\u021bat\u0103);</li> <li> <p>Du-te la Projects and Solutions, apoi la General \u0219i dezactiveaz\u0103 \"Reopen    documents on solution load\". \u00cen final, ar trebui s\u0103 arate similar cu    asta:</p> <p> </p> </li> </ol> <p>\u00cen schimb, putem s\u0103 ne folosim de ce se afl\u0103 la Edit &gt; Go To. Aici se afl\u0103 toate op\u021biunile:</p> <p> </p> <p>Cea mai important\u0103 din ele este Ctrl+T care func\u021bioneaz\u0103 ca un Go To generalizat. Pentru fi\u0219iere recente avem Ctrl+1, Ctrl+R, \u0219i pentru fi\u0219iere \u00een general avem Ctrl+Shift+T. Ocazional folosesc \u0219i Ctrl+1, Ctrl+S ca s\u0103 caut un simbol (o func\u021bie, o variabil\u0103 etc.), ceea ce se poate dovedi util la fi\u0219iere mari.</p> </li> <li> <p>Dac\u0103 instalezi extensii, acestea sunt activate c\u00e2nd este nevoie. Problema la    aceast\u0103 abordare este c\u0103 dac\u0103 ai una sau mai multe extensii care ruleaz\u0103    imediat la pornire, atunci programul se va \u00eencetini. Po\u021bi folosi Help &gt;    Visual Studio Performance Manager pentru a inspecta de ce VS este \u00eencet.</p> </li> <li> <p>Visual Studio \u00ee\u0219i ajusteaz\u0103 efectele bazat pe performan\u021ba clientului, \u00eens\u0103    acest lucru de cele mai multe ori \u00eencetine\u0219te tot. Pentru a rezolva acest    lucru, mergem la Tools &gt; Options \u0219i apoi la Environment &gt; General. Op\u021biunea    pe care vrem s\u0103 o dezactiv\u0103m se cheam\u0103 \"Automatically adjust visual    experience based on client performance\", \u00eempreun\u0103 cu \"Enable rich client    visual experience\". Ultima op\u021biune, cea cu accelerarea hardware, trebuie s\u0103    r\u0103m\u00e2n\u0103 activ\u0103, pentru a nu randa software Visual Studio (excep\u021bie fiind dac\u0103    ai un calculator cu o plac\u0103 video foarte slab\u0103 sau dac\u0103 e\u0219ti pe ma\u0219in\u0103    virtual\u0103). Dup\u0103 ce ai terminat, fereastra trebuie s\u0103 fie similar\u0103 cu asta:</p> <p> </p> </li> <li> <p>Windows Defender ruleaz\u0103 constant \u00een fundal pentru a ne proteja de viru\u0219i.    Totu\u0219i, asta impacteaz\u0103 negativ performan\u021ba pentru c\u0103 scaneaz\u0103 toate    directoarele din sistem, inclusiv cele ale lui Visual Studio \u0219i cele ale    proiectelor noastre. Pentru acest lucru, trebuie s\u0103 facem excep\u021bii. Am creat    un script de PowerShell care s\u0103 automatizeze acest proces. Acesta poate fi    desc\u0103rcat de aici:</p> <p>Descarc\u0103 script </p> <p>Scriptul complet ImproveVS2022.ps1<pre><code>if (-not ([Security.Principal.WindowsPrincipal] [Security.Principal.WindowsIdentity]::GetCurrent()).IsInRole([Security.Principal.WindowsBuiltInRole] \"Administrator\")) \n{\n    Write-Host \"Ruleaza acest script ca Administrator.\" -ForegroundColor Red\n    exit\n}\n\n$userPath = $env:USERPROFILE\n$appdataLocal = \"$userPath\\AppData\\Local\"\n$appdataRoaming = \"$userPath\\AppData\\Roaming\"\n$programData = \"C:\\ProgramData\"\n$programFiles = \"C:\\Program Files\"\n$programFilesX86 = \"$programFiles (x86)\"\n\n$pathExclusions = @(\n    'C:\\Windows\\Microsoft.NET',\n    'C:\\Windows\\assembly',\n    \"$userPath\\.dotnet\",\n    \"$userPath\\.librarymanager\",\n    \"$appdataLocal\\Microsoft\\VisualStudio\",\n    \"$appdataLocal\\Microsoft\\VisualStudio Services\",\n    \"$appdataLocal\\GitCredentialManager\",\n    \"$appdataLocal\\GitHubVisualStudio\",\n    \"$appdataLocal\\Microsoft\\dotnet\",\n    \"$appdataLocal\\Microsoft\\VSApplicationInsights\",\n    \"$appdataLocal\\Microsoft\\VSCommon\",\n    \"$appdataLocal\\Temp\\VSFeedbackIntelliCodeLogs\",\n    \"$appdataRoaming\\Microsoft\\VisualStudio\",\n    \"$appdataRoaming\\NuGet\",\n    \"$appdataRoaming\\Visual Studio Setup\",\n    \"$appdataRoaming\\vstelemetry\",\n    \"$programData\\Microsoft\\VisualStudio\",\n    \"$programData\\Microsoft\\NetFramework\",\n    \"$programData\\Microsoft Visual Studio\",\n    \"$programFiles\\Microsoft Visual Studio\",\n    \"$programFiles\\dotnet\",\n    \"$programFiles\\Microsoft SDKs\",\n    \"$programFiles\\Microsoft SQL Server\",\n    \"$programFiles\\IIS\",\n    \"$programFiles\\IIS Express\",\n    \"$programFilesX86\\Microsoft Visual Studio\",\n    \"$programFilesX86\\dotnet\",\n    \"$programFilesX86\\Microsoft SDKs\",\n    \"$programFilesX86\\Microsoft SQL Server\",\n    \"$programFilesX86\\IIS\",\n    \"$programFilesX86\\IIS Express\"\n)\n\n$processExclusions = @(\n    'ServiceHub.SettingsHost.exe',\n    'ServiceHub.IdentityHost.exe',\n    'ServiceHub.VSDetouredHost.exe',\n    'ServiceHub.Host.CLR.x86.exe',\n    'Microsoft.ServiceHub.Controller.exe',\n    'PerfWatson2.exe',\n    'sqlwriter.exe'\n)\n\nWrite-Host \"Acest script va crea excluderi pentru Windows Defender pentru folderele si procesele comune ale Visual Studio 2022.\"\nWrite-Host \"\"\n$projectsFolder = Read-Host \"Care este calea catre folderul proiectelor tale? (exemplu: $userPath\\source\\repos)\"\n\nif (-not (Test-Path $projectsFolder)) \n{\n    Write-Host \"Calea specificata pentru folderul proiectelor nu exista. Iesire din script.\" -ForegroundColor Red\n    exit\n}\n\nWrite-Host \"\"\nWrite-Host \"Adaugare excludere cale: $projectsFolder\"\nAdd-MpPreference -ExclusionPath $projectsFolder\n\nforeach ($exclusion in $pathExclusions) \n{\n    Write-Host \"Adaugare excludere cale: $exclusion\"\n    try \n    {\n        Add-MpPreference -ExclusionPath $exclusion\n    } \n    catch \n    {\n        Write-Host \"Nu s-a reusit adaugarea excluderii pentru calea: $exclusion - $_\" -ForegroundColor Yellow\n    }\n}\n\nforeach ($exclusion in $processExclusions) \n{\n    Write-Host \"Adaugare excludere proces: $exclusion\"\n    try \n    {\n        Add-MpPreference -ExclusionProcess $exclusion\n    } \n    catch \n    {\n        Write-Host \"Nu s-a reusit adaugarea excluderii pentru procesul: $exclusion - $_\" -ForegroundColor Yellow\n    }\n}\n\nWrite-Host \"\"\nWrite-Host \"Excluderile tale:\"\n$prefs = Get-MpPreference\n\nWrite-Host \"Caile excluse:\"\n$prefs.ExclusionPath\nWrite-Host \"\"\n\nWrite-Host \"Procesele excluse:\"\n$prefs.ExclusionProcess\n</code></pre> </p> <p>Pentru a-l folosi, trebuie f\u0103cu\u021bi urm\u0103torii pa\u0219i (presupun c\u0103 ai desc\u0103rcat scriptul \u00een <code>C:\\Users\\&lt;nume&gt;\\Downloads</code> (adic\u0103 \u00een folderul de Desc\u0103rc\u0103ri)):</p> <ol> <li> <p>Deschide o fereastr\u0103 de PowerShell ca administrator. Pentru a face acest    lucru, fie po\u021bi ap\u0103sa incanta\u021bia Win+X, A \u0219i apoi Enter, fie    po\u021bi s\u0103 cau\u021bi Windows Powershell (sau doar Terminal, dac\u0103 e\u0219ti pe Windows    11) \u00een meniu, apoi selectezi Executare ca administrator.</p> </li> <li> <p>Navigheaz\u0103 p\u00e2n\u0103 la calea unde ai desc\u0103rcat cu <code>cd C:\\Users\\&lt;cale&gt;</code>. \u00cen    cazul meu, va fi <code>cd C:\\Users\\RoAlgo\\Downloads</code>.</p> </li> <li> <p>Scrie <code>.\\ImproveVS2022.ps1</code> (presupun\u00e2nd c\u0103 a\u0219a ai numit fi\u0219ierul).</p> </li> <li> <p>Trebuie doar s\u0103 furnizezi calea unde \u00ee\u021bi stochezi proiectele de obicei.    Dac\u0103 e\u0219ti cu set\u0103rile implicite, atunci po\u021bi scrie exact ce \u00ee\u021bi zice    exemplul (adic\u0103 <code>C:\\Users\\&lt;nume&gt;\\source\\repos</code>). Dac\u0103 nu exist\u0103 calea,    atunci programul iese.</p> </li> <li> <p>Ape\u0219i Enter \u0219i a\u0219tep\u021bi s\u0103 \u00ee\u0219i fac\u0103 treab\u0103 (termin\u0103 repede).</p> </li> </ol> </li> </ol> <p>Asta este tot cu configurarea. Po\u021bi acum s\u0103 mergi c\u0103tre urm\u0103torul articol:</p> <p>Mergi la introducere</p>"},{"location":"cppintro/editors/windows/visual-studio-code/","title":"Visual Studio Code (Windows)","text":""},{"location":"cppintro/editors/windows/visual-studio-code/#instalare","title":"Instalare","text":"<p>Procesul de instalare este unul foarte simplu:</p> <ol> <li> <p>Descarc\u0103 installerul de Visual Studio Code:</p> <p>Link direct </p> </li> <li> <p>Dup\u0103 ce s-a desc\u0103rcat, ruleaz\u0103 installerul (care ar trebui s\u0103 fie numit     <code>VSCodeUserSetup-x64-{versiune}.exe</code>). Procesul nu dureaz\u0103 mult, de cele mai     multe ori este un minut.</p> </li> <li> <p>Implicit, VS Code este instalat sub <code>C:\\Users\\{nume utilizator}\\AppData\\Local\\Programs\\Microsoft VS Code</code>.</p> </li> </ol> <p>Alternativ, po\u021bi desc\u0103rca o arhiv\u0103 .zip, s\u0103 o extragi \u0219i s\u0103 rulezi VS Code de acolo. Acest lucru este util \u00een caz c\u0103 vrei s\u0103 rulezi portabil (de pild\u0103, la \u0219coal\u0103, unde nu ai drepturi de administrator pentru a putea instala VS Code \u00een mod normal).</p> <p>Descarc\u0103 arhiva .zip </p>"},{"location":"cppintro/editors/windows/visual-studio-code/#configurare-si-utilizare","title":"Configurare \u0219i utilizare","text":"<p>\u00cenainte de a continua, p\u0103r\u021bile principale ale interfe\u021bei sunt:</p> <ul> <li>Editorul, unde deschizi \u0219i schimbi fi\u0219iere surs\u0103 (\u0219i nu numai). Aici \u00ee\u021bi vei   petrece majoritatea timpului. Po\u021bi avea mai mult de un fi\u0219ier deschis.</li> <li>Bara lateral\u0103 (sidebar) arat\u0103 fi\u0219ierele \u0219i directoarele cu care lucrezi. Poate   fi ascuns\u0103 pentru a vedea mai mult din cod.</li> <li>Bara de status, care se afl\u0103 \u00een partea de jos, \u0219i arat\u0103 informa\u021bii precum   linia \u0219i coloana pe care te afli, tipul de fi\u0219ier, num\u0103rul de erori \u0219.a.m.d.</li> <li>Panel-uri, care sunt arii care apar pentru sarcini specifice precum c\u0103utare,   inspectarea erorilor, gestionarea extensiilor \u0219.a.m.d.</li> </ul> <p>Implicit nu vine cu suport integrat pentru C++. Totu\u0219i, Visual Studio Code are o gam\u0103 larg\u0103 de extensii (pe care le putem accesa folosind butonul de extensii care arat\u0103 ca patru cuburi dintre care unul este desprins, dar poate fi accesat \u0219i cu scurt\u0103tura Ctrl+Shift+X). De acolo, caut\u0103 \"C/C++ Extension Pack\" \u0219i apas\u0103 pe prima extensie de la Microsoft (nu este greu s\u0103 o recuno\u0219ti).</p> <p>Acum s\u0103 facem un fi\u0219ier de C++ pentru a putea continua procesul. Creeaz\u0103 un fi\u0219ier nou, fie din File &gt; New Text File, fie folosind scurt\u0103tura Ctrl+N. \u00cel salv\u0103m imediat undeva (Ctrl+S), loca\u021bia nu este important\u0103 pe moment. Numele fi\u0219ierului trebuie s\u0103 se termine cu <code>.cpp</code> la final, s\u0103-i zicem <code>main.cpp</code>. Imediat ce ai salvat, O s\u0103 vezi c\u0103 Visual Studio Code a recunoscut fi\u0219ierul nostru gol ca unul de C++ \u0219i a activat extensia pe care tocmai am instalat-o. Dac\u0103 \u00ee\u021bi cere \u00eentr-un pop-up s\u0103 te duci la o versiune de pre-release a extensiei de C++, refuz\u0103.</p> <p>Apas\u0103 Ctrl+Shift+P pentru a activa Command Palette (o s\u0103 folose\u0219ti asta foarte des). Scrie \"Intellisense\" \u0219i selecteaz\u0103 op\u021biunea \"C/C++: Select IntelliSense Configuration...\". Alege g++. \u00cen cazul \u00een care ai instalat \u0219i Visual Studio 2022, o s\u0103 ai op\u021biunea de cl.exe. Dac\u0103 nu ai instalat GCC cu MinGW, este bun\u0103 \u0219i aceast\u0103 op\u021biunea, de\u0219i ar fi bine s\u0103 ai g++ \u00een schimb.</p> <p>Ca s\u0103 testezi dac\u0103 a mers, scrie <code>#include &lt;ios</code>. Dac\u0103 \u00ee\u021bi ofer\u0103 sugestii precum <code>ios</code>, <code>iostream</code> \u0219i <code>iso646.h</code>, atunci este func\u021bional.</p> <p>Creeaz\u0103 un director gol \u00eentr-un loc pe care \u00eel \u0219tii \u0219i apoi navigheaz\u0103 p\u00e2n\u0103 la el folosind File &gt; Open Folder (Ctrl+K Ctrl+O). Dac\u0103 ai un popup cu \"Do you trust the authors of the files in this folder?\", apas\u0103 \"Yes, I trust the authors\" (pentru c\u0103 tu e\u0219ti autorul, logic). Po\u021bi op\u021bional s\u0103 bifezi s\u0103 aib\u0103 \u00eencredere \u0219i \u00een fi\u0219ierele din directorul p\u0103rinte. Apoi po\u021bi crea un nou fi\u0219ier pe care s\u0103-l nume\u0219ti tot <code>main.cpp</code>, ca data trecut\u0103. Adaug\u0103 aceste linii \u00een fi\u0219ier:</p> <pre><code>#include &lt;iostream&gt;\n\nint main() {\n    std::cout &lt;&lt; \"Hello from VSCode!\" &lt;&lt; std::endl;\n    return 0;\n}\n</code></pre> <p>Interfa\u021ba ta ar trebui s\u0103 arate similar cu asta:</p> <p>Apoi po\u021bi s\u0103 rulezi fi\u0219ierul astfel:</p> <ol> <li> <p>Du-te la butonul de debug din tab bar (este un triunghi cu un g\u00e2ndac) \u0219i     extinde-l. Din lista aceea, selecteaz\u0103 Run C/C++ code. A\u0219a ar trebui s\u0103     arate:</p> <p> </p> </li> <li> <p>Selecteaz\u0103 de acolo \"C/C++: g++.exe build and debug active file\", ca s\u0103    poat\u0103 compila folosind G++. Este posibil s\u0103 vezi \u0219i op\u021biuni cu Clang sau    cl.exe, dar po\u021bi s\u0103 le ignori. Dac\u0103 \u00ee\u021bi cere extensia de CMake Tools ceva    legat de vizibilitate, d\u0103-i Do not show again, nu \u00ee\u021bi este relevant\u0103 \u021bie    acum.</p> </li> <li> <p>Dac\u0103 totul a mers cum trebuie, ar trebui s\u0103 vezi undeva jos \u00een terminal    mesajul \"Hello from VSCode!\".</p> </li> </ol> <p>Metoda pe care o folosesc eu c\u00e2nd folosesc Visual Studio Code este urm\u0103toarea:</p> <ol> <li> <p>C\u00e2nd ai instalat extensia, \u021bi-a instalat \u0219i suport pentru CMake. Pentru a     crea un proiect de CMake, du-te \u00een Command Palette prin Ctrl+Shift+P \u0219i     apoi scrie \"CMake: Quick Start\" \u0219i selecteaz\u0103 acea op\u021biune;</p> </li> <li> <p>Scrie numele proiectului t\u0103u. De obicei este la fel ca numele problemei pe     care o faci, dar poate fi orice. Nu trebuie s\u0103 con\u021bin\u0103 spa\u021bii (doar linii     sau bar\u0103 jos).</p> <p> </p> </li> <li> <p>Aici te pune s\u0103 alegi limbajul \u00een care va fi proiectul. Cum este o     introducere \u00een C++, noi vom alege C++, fire\u0219te.</p> <p> </p> </li> <li> <p>Noi dorim s\u0103 avem un executabil, deci vom alege op\u021biunea corespunz\u0103toare.</p> <p> </p> </li> <li> <p>Niciuna din aceste op\u021biuni (CPack sau CTest) nu ne este relevant\u0103, deci nu     alegem niciuna \u0219i trecem mai departe.</p> <p> </p> </li> <li> <p>Alegem fi\u0219ierele pe care dorim s\u0103 le avem \u00een target. \u00cen cele mai multe     cazuri, va fi doar un singur fi\u0219ier, probabil numit <code>main.cpp</code>. Este     important s\u0103 existe acest fi\u0219ier \u00eenainte de a folosi Quick Start.</p> <p> </p> </li> <li> <p>\u00cen aceast\u0103 faz\u0103 trebuie s\u0103 configur\u0103m un preset. \u00cen acest caz, este un     preset de configurare, care \u00eei zice lui CMake cum s\u0103 configureze proiectul     nostru. Printre altele, dicteaz\u0103 generatorul, fi\u0219ierul de toolchain (care     detecteaz\u0103 efectiv care este compilatorul \u0219i face disponibile toate     fi\u0219ierele antet) \u0219i locul unde se va da build. Apas\u0103 Enter.</p> <p> </p> </li> <li> <p>Cea mai simpl\u0103 op\u021biune de a crea un preset de configurare este de la     compilator, deci vom selecta \"Create from Compilers\".</p> <p> </p> </li> <li> <p>Aici select\u0103m kit-ul nostru. \u00cen esen\u021b\u0103, un kit este un compilator. Alegem     GCC (sau Visual Studio 17 2022 x64, dac\u0103 ai instalat Visual Studio 2022     \u00eenainte).</p> <p> </p> </li> <li> <p>Acest preset are nevoie de un nume, \u00eel putem numi simplu GCC (sau MSVC, dac\u0103     ai ales VS).</p> <p> </p> </li> </ol> <p>Cel mai important fi\u0219ier este <code>CMakeLists.txt</code>. El arat\u0103 a\u0219a \u00een momentul de fa\u021b\u0103:</p> <pre><code>cmake_minimum_required(VERSION 3.5.0)\nproject(cppintro VERSION 0.1.0 LANGUAGES C CXX)\nadd_executable(cppintro main.cpp)\n</code></pre> <p>Mai trebuie s\u0103 ad\u0103ug\u0103m unele chestii. Un CMakeLists.txt adecvat arat\u0103 astfel:</p> <pre><code>cmake_minimum_required(VERSION 3.27)\nproject(cppintro VERSION 0.1.0 LANGUAGES C CXX)\nset(CMAKE_CXX_STANDARD 20)\nset(CMAKE_CXX_EXTENSIONS OFF)\nset(CMAKE_CXX_STANDARD_REQUIRED ON)\nadd_executable(${PROJECT_NAME} main.cpp)\nif (MSVC)\n    target_compile_options(${PROJECT_NAME} PUBLIC /W4 /WX)\n    target_compile_options(${PROJECT_NAME} PRIVATE $&lt;$&lt;CONFIG:Debug&gt;:/Od /Zi&gt; $&lt;$&lt;CONFIG:Release&gt;:/O2&gt;)\n    target_link_options(${PROJECT_NAME} PRIVATE $&lt;$&lt;CONFIG:Debug&gt;:/DEBUG&gt; $&lt;$&lt;CONFIG:Release&gt;:/DEBUG:NONE&gt;)\nelse()\n    target_compile_options(${PROJECT_NAME} PUBLIC -Wall -Wextra -Wpedantic -Wfloat-conversion)\n    target_compile_options(${PROJECT_NAME} PRIVATE $&lt;$&lt;CONFIG:Debug&gt;:-O0 -g&gt; $&lt;$&lt;CONFIG:Release&gt;:-O3&gt;)\nendif()\n</code></pre> <p>\u00cen esen\u021b\u0103, ce face acest CMakeLists.txt nou este c\u0103 seteaz\u0103 standardul la C++20 \u0219i \u00eel face obligatoriu, \u0219i adaug\u0103 mai multe flag-uri pentru a afi\u0219a mai multe avertiz\u0103ri (ne ajut\u0103 s\u0103 g\u0103sim erori mai devreme) \u0219i a scoate optimiz\u0103rile \u00een momentul \u00een care depan\u0103m codul.</p> <p>Acum c\u0103 avem toate astea, apas\u0103 Shift+F5 \u0219i bucur\u0103-te de executabil.</p> <p>Aici sunt mai multe scurt\u0103turi \u0219i concepte utile care te pot ajuta \u00een a configura editorul:</p> <ol> <li>Po\u021bi s\u0103 \u00ee\u021bi schimbi tema folosind \"Preferences: Color Theme\" din Command    Palette sau folosind Ctrl+K Ctrl+T. De asemenea, po\u021bi g\u0103si alte teme    interesante ca extensii.</li> <li>Pentru a accesa set\u0103rile, folose\u0219te fie Ctrl+,, fie \"Preferences:    Open Settings (UI)\" din Command Palette. Unele set\u0103ri necesit\u0103 configurare    care nu se poate face din interfa\u021b\u0103, deci avem nevoie s\u0103 modific\u0103m un fi\u0219ier    JSON. Pentru acest lucru, avem \u00een partea de sus o icoan\u0103 cu o foaie de h\u00e2rtie    \u0219i o s\u0103geat\u0103. Alternativ, po\u021bi ajunge \u00een acela\u0219i loc din Command Palette,    dac\u0103 scrii \"Preferences: Open User Settings (JSON)\".      </li> <li>Din set\u0103ri, po\u021bi ajusta fontul. Adaug\u0103 fonturile pe care vrei s\u0103 le ai, \u00een    ordinea descresc\u0103toare a preferin\u021bei. Dac\u0103 numele fontului are spa\u021biu,    trebuie s\u0103 pui \u00eentre ghilimele. De asemenea, po\u021bi modifica \u0219i m\u0103rimea    fontului, \u00een func\u021bie de preferin\u021be.</li> <li>Recomand s\u0103 activezi func\u021bia de auto-save. Aceasta \u00ee\u021bi salveaz\u0103 automat    codul. Seteaz\u0103-l pe afterDelay.</li> <li>Pentru a ascunde bara lateral\u0103, apas\u0103 Ctrl+B. Pentru a o aduce \u00eenapoi,    apas\u0103 aceea\u0219i scurt\u0103tur\u0103. Poate fi util \u00een cazul \u00een care lucrezi pe jum\u0103tate    din ecran sau dac\u0103 vrei s\u0103 ai mai mult loc.</li> <li>Po\u021bi ap\u0103sa F11 pentru a face editorul s\u0103 fie fullscreen. Un efect    secundar este c\u0103 dispare bara de meniu, dar este \u00een regul\u0103. Pentru a ie\u0219i din    modul fullscreen, apas\u0103 din nou F11.</li> <li>Uneori, \u0219i modul fullscreen are prea multe distrageri. Po\u021bi activa modul Zen    cu Ctrl+K, Z pentru a ascunde tot \u00een afar\u0103 de editor.</li> <li>Po\u021bi s\u0103 \u00eempar\u021bi editorul \u00een dou\u0103 folosind fie butonul dedicat din bara de    tab-uri (arat\u0103 ca un p\u0103trat \u00eemp\u0103r\u021bit \u00een dou\u0103), fie cu Ctrl+\\.    Alternativ, po\u021bi trage un fi\u0219ier \u00een editor \u0219i vei avea o indica\u021bie vizual\u0103.</li> <li>Pentru a ne asigura c\u0103 avem un stil consistent, putem l\u0103sa Visual Studio Code    s\u0103 formateze codul. Pentru acest lucru, putem ap\u0103sa Shift+Alt+F. Dac\u0103 nu    e\u0219ti sigur de scurt\u0103tura pe platforma ta, po\u021bi c\u0103uta \"Format Document\" din    Command Palette.</li> <li>Uneori, ai nevoie s\u0103 cau\u021bi un \u0219ir \u00eentr-un fi\u0219ier. Pentru acest lucru, apas\u0103    Ctrl+F (sau Ctrl+Shift+F pentru a c\u0103uta \u00een toate fi\u0219ierele). Dac\u0103 \u00een    loc de F ape\u0219i H \u00een combina\u021biile respective, po\u021bi s\u0103 \u0219i \u00eenlocuie\u0219ti    text.</li> <li>La capitolul de c\u0103utat fi\u0219iere, dac\u0103 ape\u0219i Ctrl+P, po\u021bi s\u0103 cau\u021bi numele     unui fi\u0219ier. Dac\u0103 adaugi <code>:</code>, po\u021bi s\u0103 sari la o linie anume \u00een fi\u0219ierul     curent (de pild\u0103, \u00een cazul unei erori de la compilator) sau la un simbol     anume cu <code>@</code> (dac\u0103 trebuie s\u0103 ajungi la o variabil\u0103 sau la o func\u021bie anume).</li> <li>Deseori vei avea nevoie s\u0103 modifici \u00een mai multe locuri simultan. Visual     Studio Code are suport nativ pentru mai multe cursoare. Pentru a crea mai     multe cursoare, apas\u0103 Ctrl+Alt+Up (sau Ctrl+Alt+Down).</li> <li>Pentru a selecta cuv\u00e2ntul curent, apas\u0103 Ctrl+D. Po\u021bi s\u0103 ape\u0219i de mai     multe ori pentru a g\u0103si mai multe apari\u021bii.</li> </ol> <p>Sfat</p> <p>Sunt at\u00e2tea set\u0103ri pe care le po\u021bi modifica \u0219i at\u00e2tea extensii pe care s\u0103 le po\u021bi instala, \u00eens\u0103 recomand s\u0103 \u00eenve\u021bi mai multe scurt\u0103turi pentru ac\u021biuni pe care le faci \u00een mod comun. Dac\u0103 folose\u0219ti mai mult tastatura, devii mai  eficient pentru c\u0103 nu este nevoie s\u0103 \u00ee\u021bi mu\u021bi m\u00e2na spre mouse. </p> <p>Asta este tot cu configurarea. Po\u021bi acum s\u0103 mergi c\u0103tre urm\u0103torul articol:</p> <p>Mergi la introducere</p>"},{"location":"dificil/bitsets/","title":"Bitsets","text":"","tags":["implementare","biti","optimizare"]},{"location":"dificil/bitsets/#introducere","title":"Introducere","text":"<p>In C++, clasa bitset constituie o succesiune de bi\u021bi, put\u00e2nd fi asociat\u0103 cu un vector, \u00eens\u0103 num\u0103rul de elemente este constant pe parcursul rul\u0103rii programului. \u00cen linii mari, bitset nu aduce o contribu\u021bie mare asupra corectitudinii unui algoritm, sau nu reprezint\u0103 o tehnic\u0103 propriu-zis\u0103, fiind folosit de cele mai multe ori doar pentru a face optimiz\u0103ri semnificative asupra timpului sau memoriei.</p>","tags":["implementare","biti","optimizare"]},{"location":"dificil/bitsets/#sintaxa","title":"Sintax\u0103","text":"<ul> <li><code>std::bitset</code> se reg\u0103se\u0219te in libr\u0103riile<code>&lt;bitset&gt;</code> sau <code>&lt;bits/stdc++.h&gt;</code>.</li> <li>Linia <code>bitset&lt;N&gt; b;</code> declar\u0103 un bitset cu exact \\(N\\) bi\u021bi, \\(N\\) este constant\u0103,   i.e. se specific\u0103 explicit valoarea acesteia la declarare.</li> <li>De asemenenea putem declara un bitset care s\u0103 con\u021bin\u0103 bi\u021bii unui num\u0103r:   <code>bitset&lt;10&gt; b(13)</code>.</li> </ul> <pre><code>bitset&lt;10&gt; b;\nint main() {\n    b[0] = 1;\n    b[3] = 1;\n    b[9] = 1;\n\n    cout &lt;&lt; b;\n}\n</code></pre> <pre><code>1000001001\n</code></pre> <p>Observa\u021bii</p> <ul> <li>Elementele sunt indexate de la 0.</li> <li><code>cout &lt;&lt; b;</code> va afi\u0219a toate elementele de la dreapta la stanga.</li> <li>Este prezent <code>operator[]</code>.</li> </ul>","tags":["implementare","biti","optimizare"]},{"location":"dificil/bitsets/#operatori-permisi","title":"Operatori permi\u0219i","text":"<ul> <li><code>operator==</code> \u0219i <code>operator!=</code> compar\u0103 con\u021binutul cu alt <code>bitset</code>.</li> <li><code>operator[]</code> acceseaz\u0103 valoarea unui bit la o pozi\u021bie anume.</li> <li><code>operator&amp;=</code> operator binar \u0218I.</li> <li><code>operator|=</code> operator binar SAU.</li> <li><code>operator^=</code> operator binar XOR.</li> <li><code>operator~</code> operator binar NOT.</li> <li><code>operator&lt;&lt;=</code> shift pe bi\u021bi la stanga.</li> <li><code>operator&gt;&gt;=</code> shift pe bi\u021bi la dreapta.</li> </ul> <pre><code>bitset&lt;10&gt; b;\nint main() {\n    b[0] = 1;\n    b &lt;&lt;= 1;\n    cout &lt;&lt; b &lt;&lt; '\\n';\n\n    b ^= 13;\n    cout &lt;&lt; b &lt;&lt; '\\n';\n\n    b &gt;&gt;= 100;\n    cout &lt;&lt; b;\n}\n</code></pre> <pre><code>0000000010\n0000001111\n0000000000\n</code></pre> <p>Observa\u021bie</p> <p>Dac\u0103 shiftarea, \u00eentr-o oarecare direc\u021bie, presupune pentru unele elemente egale cu 1 s\u0103 \"ias\u0103\" din bitset, atunci valorile de 1 aferente se vor pierde permanent.</p>","tags":["implementare","biti","optimizare"]},{"location":"dificil/bitsets/#functii-permise","title":"Func\u021bii permise","text":"<ul> <li><code>_Find_first()</code> returneaz\u0103 prima pozi\u021bie a unui bit setat (cea cu index   minim).</li> <li><code>_Find_next(int pos)</code> returneaz\u0103 urm\u0103torul bit setat dup\u0103 poz, iar \u00een cazul \u00een   care nu exist\u0103 va returna lungimea bitsetului</li> <li><code>.count()</code> returneaz\u0103 num\u0103rul de bi\u021bi seta\u021bi.</li> <li><code>.reset()</code> reseteaz\u0103 to\u021bi bi\u021bii la 0.</li> <li><code>.flip(int pos)</code>: \\(b[pos]\\) devine \\(b[pos]\\) xor 1, i.e. schimb\u0103 bitul   \\(pos\\) din 0 \u00een 1 \u0219i invers.</li> <li><code>.to_string()</code> va converti bitsetul \u00eentr-un string.</li> <li><code>.to_ulong()</code> va converti bitsetul \u00eentr-un <code>unsigned long</code>.</li> <li><code>.to_ullong()</code> va converti bitsetul \u00eentr-un <code>unsigned long long</code>.</li> </ul> <pre><code>bitset&lt;10&gt; b;\nint main() {\n    b[3] = 1;\n    cout &lt;&lt; b._Find_next(0) &lt;&lt; '\\n';\n\n    b.flip(0);\n    cout &lt;&lt; b.to_string() &lt;&lt; '\\n';\n\n    b = 13;\n    cout &lt;&lt; b._Find_first() &lt;&lt; '\\n';\n    cout &lt;&lt; b &lt;&lt; '\\n';\n\n    cout &lt;&lt; b.to_ullong();\n}\n</code></pre> <pre><code>3\n0000001001\n0\n0000001101\n13\n</code></pre> <p>Observa\u021bie</p> <p>La fel cum putem declara <code>bitset&lt;N&gt; b(val)</code>, la fel de bine putem atribui <code>b = val</code>, dar \u00een ambele cazuri se vor copia doar primii \\(N\\) bi\u021bi.</p>","tags":["implementare","biti","optimizare"]},{"location":"dificil/bitsets/#stdbitset-in-programare-competitiva","title":"<code>std::bitset</code> \u00een programare competitiv\u0103","text":"<p>Opera\u021biile binare func\u021bioneaz\u0103 la fel ca atunci c\u00e2nd le folosim pe alte tipuri de date cum ar fi <code>int</code>, dar datorit\u0103 dimensiunilor mari pe care le poate suporta un bitset, acestea vin de cele mai multe ori cu o optimizare crucial\u0103 ce const\u0103 \u00een gruparea bi\u021bilor \u00een grupe de c\u00e2te 32 elemente, convertirea acestora \u00een int, aplicarea opera\u021biei \u0219i \u00eenlocuirea num\u0103rului \u00een bitset. Cum pe un num\u0103r \u00eentreg o opera\u021bie binar\u0103 este constant\u0103, putem deduce deci c\u0103 complexitatea pentru o astfel de opera\u021bie este \\(O ( \\frac{N}{w} )\\) , unde \\(w\\) de regul\u0103 seminific\u0103 constanta cu care este \u00eemp\u0103r\u021bit num\u0103rul de elemente \\(N\\).</p> <p>Aten\u021bie</p> <p>Nota\u021bii de tipul \\(O (\\frac{N}{32})\\) sau \\(O (\\frac{N}{64})\\) nu sunt corecte, pentru c\u0103 de cele mai multe ori constantele sunt ignorate, de aceea se folose\u0219te variabila \\(w\\).</p>","tags":["implementare","biti","optimizare"]},{"location":"dificil/bitsets/#problema-somnoros","title":"Problema somnoros","text":"<p>Un prim exemplu este o problem\u0103 destul de clasic\u0103 care ne cere s\u0103 determin\u0103m dac\u0103 \u00eentr-un graf orientat aciclic avem drum de la un nod la altul.</p> <p>Consider\u0103m urm\u0103toare abordare: \\(dp[u][v] = 1\\) dac\u0103 afirma\u021bia este adevarat\u0103. Pentru a calcula eficient dinamica am putea sorta topologic graful. Astfel dac\u0103 fix\u0103m o r\u0103d\u0103cin\u0103, i.e. un nod cu gradul interior 0 neeliminat p\u00e2n\u0103 \u00een prezent, atunci putem \"propaga\" dp-ul \u00een fiecare fiu al s\u0103u, adic\u0103 <code>dp[f_j][x] |= dp[r_i][x]</code>, cu condi\u021bia c\u0103 muchia dintre \\(r_i\\) \u0219i \\(f_j\\) s\u0103 nu fie eliminat\u0103. Observ\u0103m c\u0103 pentru 2 noduri \\(u\\) \u0219i \\(v\\), <code>dp[u][x] |= dp[v][x]</code> este echivalentul la <code>b1 |= b2</code>, unde \\(b1\\) \u0219i \\(b2\\) reprezint\u0103 2 <code>std::bitset</code>-uri. Deci dac\u0103 \u00een loc de <code>vector&lt;vector&lt;int&gt;&gt; dp(n + 1, vector&lt;int&gt;(n + 1))</code> am pune <code>vector&lt;bitset&lt;const int&gt;&gt; dp(n + 1)</code>, am putea face tranzi\u021biile \u00een \\(O ( \\frac{N}{w} )\\), complexitatea final\u0103 fiind \\(O ( \\frac{N^2}{w} )\\).</p> <pre><code>const int N = 5e4 + 1;\nvector&lt;bitset&lt;N&gt;&gt; v(N);\nbitset&lt;N&gt; viz;\nvector&lt;int&gt; liste[N], d(N);\nint n, m;\n\nvoid topsort() {\n    queue&lt;int&gt; q;\n    for (int i = 1; i &lt;= n; i++) {\n        if (d[i] == 0) {\n            q.push(i);\n        }\n    }\n\n    while (!q.empty()) {\n        int nod = q.front();\n        q.pop();\n        for (auto i : liste[nod]) {\n            v[i][nod] = 1;\n            v[i] |= v[nod];\n            if (--d[i] == 0) {\n                q.push(i);\n            }\n        }\n    }\n}\nint main() {\n    cin.tie(0)-&gt;sync_with_stdio(0);\n    cin &gt;&gt; n &gt;&gt; m;\n    for (int i = 1; i &lt;= m; i++) {\n        int u, v;\n        cin &gt;&gt; u &gt;&gt; v;\n        liste[u].push_back(v);\n        d[v]++;\n    }\n\n    topsort();\n\n    int q;\n    cin &gt;&gt; q;\n    while (q--) {\n        int u, a;\n        cin &gt;&gt; u &gt;&gt; a;\n        cout &lt;&lt; v[a][u] &lt;&lt; '\\n';\n    }\n}\n</code></pre>","tags":["implementare","biti","optimizare"]},{"location":"dificil/bitsets/#problema-strehaia","title":"Problema strehaia","text":"<p>Avem \\(n\\) probleme, a \\(i\\)-a av\u00e2nd \\(k_i\\) subtask-uri, fiecare cu un num\u0103r de puncte \u00eentre 1 \u0219i 100. Problema ne cere s\u0103 calcul\u0103m num\u0103rul total de punctaje distincte care se pot forma \u00een urma rezolv\u0103ri celor \\(n\\) probleme.</p> <p>O prim\u0103 observa\u021bie este c\u0103 problemele pot fi luate independent, ceea ce \u00eenseamn\u0103 c\u0103 nu conteaz\u0103 ce subtask-uri are o anumit\u0103 problem\u0103, ci c\u00e2te subtask-uri au un anumit punctaj. Fie \\(fr[i]\\) num\u0103rul de subtask-uri cu \\(i\\) puncte, \u0219i \\(dp[i] = 1\\) dac\u0103 exist\u0103 un set de subtask-uri cu suma \\(i\\). Este destul de clar c\u0103 putem constitui urm\u0103torul rucsac:</p> <pre><code>vector&lt;int&gt; dp(maxsum + 1);\ndp[0] = 1;\nfor (int i = 1; i &lt;= 100; i++) {\n    for (int j = 1; j &lt;= fr[i]; j++) {\n        for (int s = 0; s &lt;= maxsum; s++) {\n            if (s + i &lt;= maxsum) {\n                dp[s + i] |= dp[s];\n            }\n        }\n    }\n}\n</code></pre> <p>Complexitatea de timp este \\(\\mathcal{O}(S \\cdot maxsum)\\), unde \\(S = \\sum_{i=1}^{n} k_i\\).</p> <p>Ar trebui s\u0103 fie destul de evident c\u0103 putem folosi bitset pentru a optimiza problema:</p> <pre><code>bitset&lt;maxsum + 1&gt; dp;\ndp[0] = 1;\nfor (int i = 1; i &lt;= 100; i++) {\n    for (int j = 1; j &lt;= fr[i]; j++) {\n        dp |= (dp &lt;&lt; i);\n    }\n}\n</code></pre> <p>Cu operatorul <code>|=</code> p\u0103str\u0103m sumele deja calculate \u00een dp, iar cu operatorul <code>&lt;&lt;</code> vom face tranzi\u021biile, cu alte cuvinte dac\u0103 shift\u0103m fiecare bit cu \\(i\\) pozi\u021bii, toate sumele prezente \u00een dp vor cre\u0219te cu \\(i\\), sintax\u0103 echivalent\u0103 cu <code>dp[s + i] |= dp[s];</code>.</p> <p>Complexitatea devine \\(O ( S \\cdot maxsum \\cdot \\frac{1}{w} )\\), care este \u00eenc\u0103 prea mare. Putem s\u0103 o optimiz\u0103m \"comprim\u00e2nd\" fiecare \\(fr_i\\) \u00een puteri de 2. Consider\u0103m cel mai mic \\(p\\) pentru care \\(2^p \\leq fr_i\\), astfel \\(fr_i = \\sum_{j = 0}^{p-1} 2^j + fr_i - 2^p + 1\\). Folosind primele \\(p-1\\) puteri de 2 putem s\u0103 construim fiecare num\u0103r de la 1 la \\(2^{p}-1\\), \u0219i cu ajutorul la \\(fr_i - 2^p + 1\\), vom putea reprezenta fiecare num\u0103r de la 1 la \\(fr_i\\), ceea ce implic\u0103 faptul c\u0103 \u0219i \u00een dp-ul nostru vor fi prezentate toate combina\u021biile de a lua num\u0103rul \\(i\\).</p> <pre><code>dp[0] = 1;\nfor (int i = 1; i &lt;= 100; i++) {\n    int mask = 1;\n    while (fr[i]) {\n        fr[i] -= mask;\n        dp |= (dp &lt;&lt; (i * mask));\n        mask *= 2;\n        if (mask &gt; fr[i]) {\n            mask = fr[i];\n        }\n    }\n}\n</code></pre> <p>Programul complet</p> <pre><code>int n;\nvector&lt;int&gt; fr(101);\nbitset&lt;(int)1e6 + 200&gt; dp;\nint main() {\n    cin.tie(0)-&gt;sync_with_stdio(0);\n    cin &gt;&gt; n;\n    for (int i = 1; i &lt;= n; i++) {\n        int w;\n        cin &gt;&gt; w;\n        for (int j = 1; j &lt;= w; j++) {\n            int val;\n            cin &gt;&gt; val;\n            fr[val]++;\n        }\n    }\n\n    dp[0] = 1;\n    for (int i = 1; i &lt;= 100; i++) {\n        int mask = 1;\n        while (fr[i]) {\n            fr[i] -= mask;\n            dp |= (dp &lt;&lt; (i * mask));\n            mask *= 2;\n            if (mask &gt; fr[i]) {\n                mask = fr[i];\n            }\n        }\n    }\n    cout &lt;&lt; dp.count();\n}\n</code></pre> <p>Timpul se reduce la \\(O ( log(S) \\cdot maxsum \\cdot \\frac{1}{w} )\\)</p>","tags":["implementare","biti","optimizare"]},{"location":"dificil/bitsets/#problema-copaci-lot-2024-baraj-2-juniori","title":"Problema Copaci, Lot 2024 Baraj 2 Juniori","text":"<p>Ni se d\u0103 o matrice (o vom nota \\(M\\)) cu \\(N \\cdot N\\) elemente \u0219i un string \\(S\\), ambele con\u021bin\u00e2nd cifre de la 0 la 9. Problema ne cere s\u0103 afl\u0103m care e cel mai mare prefix al \u0219irului \\(S\\) care poate fi reprezentat ca un drum valid \u00een matricea noastr\u0103. Un drum este valid dac\u0103 \u00eencepe \u00een oricare pozi\u021bie din matrice \u0219i urm\u0103torul element are exact o latur\u0103 comun\u0103 cu cel actual, iar fiecare element din drum este egal cu reprezentantul lui \u00een \u0219ir. Citi\u021bi problema pentru a \u00een\u021belege mai bine.</p> <p>Vom aborda o metod\u0103 similar\u0103 cu prima problema, unde vom re\u021bine \u00eentr-un tablou dac\u0103 o pozi\u021bie anume a fost \"atins\u0103\" p\u00e2n\u0103 acuma sau nu.</p> <p>Pentru a \u00een\u021belege mai bine haide\u021bi s\u0103 vizualiz\u0103m concret ce se \u00eent\u00e2mpl\u0103 pe unul dintre exemple:</p> \\[ \\begin{array}{ccccc} \\textcolor{gray}{3} &amp; \\textcolor{blue}{6} &amp; \\textcolor{gray}{2} &amp; \\textcolor{gray}{3} &amp; \\textcolor{gray}{1} \\\\ \\textcolor{gray}{9} &amp; \\textcolor{gray}{2} &amp; \\textcolor{gray}{9} &amp; \\textcolor{gray}{2} &amp; \\textcolor{gray}{8} \\\\ \\textcolor{gray}{0} &amp; \\textcolor{gray}{8} &amp; \\textcolor{gray}{0} &amp; \\textcolor{gray}{4} &amp; \\textcolor{gray}{4} \\\\ \\textcolor{gray}{5} &amp; \\textcolor{gray}{1} &amp; \\textcolor{gray}{8} &amp; \\textcolor{blue}{6} &amp; \\textcolor{gray}{8} \\\\ \\textcolor{gray}{4} &amp; \\textcolor{gray}{3} &amp; \\textcolor{gray}{3} &amp; \\textcolor{gray}{0} &amp; \\textcolor{gray}{1} \\\\ \\end{array} \\] <p>\\(S = \\textcolor{blue}{6} \\text{281864292913}\\)</p> <p>Cu albastru sunt marcate elementele care coincid cu prefixul de lungime 1. \u00cen momentul \u00een care decidem s\u0103 ne mut\u0103m pozi\u021bia din matrice, ar trebui luat \u00een considerare fiecare element adiacent cu m\u0103car o pozi\u021bie colorat\u0103 deja. Pentru o linie, acest lucru presupune \"shiftarea\" la st\u00e2nga \u0219i la dreapta a fiecarui element deja marcat. Mai concret, dac\u0103 \\(G_l\\) reprezint\u0103 mul\u021bimea de puncte \\((a_1, a_2, a_3, \\dots , a_k)\\), astfel \u00eenc\u00e2t \\(M_{l,a_i}\\) este albastru, dup\u0103 un update \\(G\\) va fi egal cu \\(( (a_1 - 1), (a1 + 1), (a_2 - 1), (a_2 + 1), \\dots, (a_k-1), (a_k + 1) )\\).</p> <p>Pentru prima linie, procesul descris mai sus ar ar\u0103ta \u00een felul urm\u0103tor:</p> \\[ \\textcolor{gray}{3} \\quad \\textcolor{blue}{6} \\quad \\textcolor{gray}{2} \\ \\textcolor{gray}{3} \\ \\textcolor{gray}{1} \\Rightarrow \\textcolor{blue}{3} \\quad \\textcolor{gray}{6} \\quad \\textcolor{blue}{2} \\quad \\textcolor{gray}{3} \\quad \\textcolor{gray}{1} \\] <p>Singura problem\u0103 pe care o \u00eent\u00e2mpin\u0103m este dat\u0103 de corelarea corect\u0103 a fiecarei pozi\u021bi din drum cu cea din \u0219irul \\(S\\). Adic\u0103, elementul cu valoarea 3 nu ar trebui marcat, deoarece \\(S_2 = 2\\). Exist\u0103 o solu\u021bie totu\u0219i pentru problema noastr\u0103, care const\u0103 \u00een re\u021binerea \u00een alt bitset , \u00een func\u021bie de sensul \u00een care shift\u0103m, dac\u0103 exist\u0103 o pozi\u021bie \\(p\\) pentru care \\(M_{l,p} = S_i\\) \u0219i \\(M_{l,p-1} = S_{i-1}\\) (\u00een cazul \u00een care vrem s\u0103 shift\u0103m la dreapta).</p> <p>De exemplu, <code>left[l][a][b][p] = 1</code> dac\u0103 pe linia \\(l\\) exist\u0103 \\(p+1\\) pentru care \\(M_{l,p+1} = a\\) \u0219i \\(M_{l,p} = b\\) (facem tranzi\u021bie de la \\(a\\) la \\(b\\)), \u0219i <code>right[l][a][b][p] = 1</code> dac\u0103 exist\u0103 \\(p-1\\) pentru care \\(M_{l,p-1} = a\\) \u0219i \\(M_{l,p} = b\\). Cu astea fiind spuse, definim <code>dp[a][b] = 1</code> dac\u0103 putem atinge elementul \\((a,b)\\) dup\u0103 un num\u0103r de pa\u0219i, atunci: <code>dp[a] = ((dp[a] &lt;&lt; 1) &amp; left[a][x][y]) | ((dp[a] &gt;&gt; 1) &amp; right[a][x][y])</code> unde \\(S_i = y, S_{i-1} = x\\).</p> <p>Pentru a tranzi\u021biona de pe o linie pe alta (mergem \u00een sus sau \u00een jos), proced\u0103m la fel doar c\u0103 de data asta vom re\u021bine <code>up[l][a][b][p], down[l][a][b][p]</code>.</p> <p>Complexitatea este \\(\\mathcal{O}(|S| \\cdot \\frac{N^2}{w})\\).</p>","tags":["implementare","biti","optimizare"]},{"location":"dificil/bitsets/#o-parte-din-cod-cpp","title":"O parte din cod (cpp)","text":"<pre><code>int ans = 0;\nvector&lt;bitset&lt;101&gt;&gt; dp(n + 1), new_dp(n + 1);\nfor (int i = 1; i &lt;= n; i++) {\n    for (int j = 1; j &lt;= n; j++) {\n        if (M[i][j] == s[1] - '0') {\n            dp[i][j] = 1;\n            ans = 1;\n        }\n    }\n}\n\nbitset&lt;101&gt; rest;\nfor (int l = 2; l &lt; s.size(); l++) {\n    int nr1 = s[l - 1] - '0', nr2 = s[l] - '0';\n    for (int i = 1; i &lt;= n; i++) {\n        new_dp[i] = (new_dp[i] | ((dp[i] &gt;&gt; 1) &amp; right[i][nr1][nr2]));\n        new_dp[i] = (new_dp[i] | ((dp[i] &lt;&lt; 1) &amp; left[i][nr1][nr2]));\n        if (i &gt; 1) {\n            new_dp[i - 1] = (new_dp[i - 1] | (dp[i] &amp; up[i - 1][nr1][nr2]));\n        }\n        if (i &lt; n) {\n            new_dp[i + 1] = (new_dp[i + 1] | (dp[i] &amp; down[i + 1][nr1][nr2]));\n        }\n    }\n\n    for (int i = 1; i &lt;= n; i++) {\n        if (new_dp[i]._Find_first() != 101) {\n            ans = l;\n        }\n\n        swap(dp[i], new_dp[i]);\n        new_dp[i] &amp;= rest;\n    }\n    if (ans != l) {\n        break;\n    }\n}\n\ncout &lt;&lt; ans &lt;&lt; '\\n';\n</code></pre> <p>Aceasta reprezint\u0103 doar o solu\u021bie, se poate \u0219i mai simplu.</p>","tags":["implementare","biti","optimizare"]},{"location":"dificil/bitsets/#bitset-dinamic","title":"Bitset dinamic","text":"<p>Prin dinamic \u00een\u021belegem faptul c\u0103 bitsetul \u00ee\u0219i poate modifica num\u0103rul de elemente pe parcursul execu\u021biei programului, sau \u00eel putem declara direct cu c\u00e2t vrem noi (<code>bitset&lt;&gt;a(n)</code>?). De ce am avea nevoie oare de a\u0219a ceva? Pentru eficien\u021b\u0103, poate. Este destul de tedious s\u0103 facem toate opera\u021biile pe acee\u0219i constan\u0103 \\(N\\) \u0219tiind clar c\u0103 \u00een unele cazuri nu avem nevoie de to\u021bi bi\u021bii. De pild\u0103, exist\u0103 probleme care necesit\u0103 folosirea unui <code>bitset</code> dinamic. Un exemplu bun ar fi:</p>","tags":["implementare","biti","optimizare"]},{"location":"dificil/bitsets/#problema-permutetree-hard","title":"Problema PermuteTree-Hard","text":"<p>Pentru un arbore cu \\(n\\) noduri (r\u0103d\u0103cin\u0103 este nodul 1) \u0219i o permutare \\(a\\), definim \\(f(a)\\) ca fiind num\u0103rul de perechi \\((u,v)\\) pentru care \\(a_u &lt; a_{lca(u,v)} &lt; a_v\\). Aici, \\(lca(u,v)\\) reprezint\u0103 cel mai jos str\u0103mo\u0219 comun al celor dou\u0103 noduri. Problema ne cere s\u0103 afl\u0103m care ar fi valoarea maxim\u0103 pe care o poate lua \\(f(a)\\), pentru oricare permutare de \\(n\\) numere.</p> <p>Ne vom folosi de un ra\u021bionament tipic program\u0103rii dinamice \u0219i vom calcula pentru fiecare nod rezultatul dac\u0103 am considera arborele ca fiind subarborele nodului respectiv, iar permutarea va con\u021bine doar nodurile din subarborele actual. Adic\u0103 daca \\(sz_u\\) = num\u0103rul de noduri din subarborele lui \\(u\\), \\(a\\) va fi egal cu \\((1,2,\\dots, sz_u)\\). C\u00e2nd facem tranzi\u021bie de la \\(u\\) la p\u0103rintele lui, o sa avem , astfel, pentru fiecare fiu \u00eemparte c\u00e2te o permutare care va fi indepdent\u0103 de restul permut\u0103rilor. Cu alte cuvinte, dac\u0103 not\u0103m cu \\(f_i\\) al \\(i\\)-lea fiu al unui nod \\(v\\), atunci permutarile vor fi \\(a_1, a_2, \\dots, a_k\\). Din aceste permut\u0103ri noi vom dori s\u0103 construim permutarea necesar\u0103 nodului \\(v\\) adk \\(a_v = (1, 2, \\dots, sz_v)\\). Ca s\u0103 facem asta trebuie s\u0103 \u021binem cont de :</p> <ul> <li>Permut\u0103rile deja existente (i.e. permut\u0103rile fiilor);</li> <li>Ce valoare va primi nodul \\(v\\).</li> </ul> <p>Pentru a forma \\(a_v\\) din permut\u0103rile deja existente, putem efectiv incrementa un num\u0103r de permut\u0103ri cu constante diferite astfel \u00eenc\u00e2t \\((1) \\ \\ a_1 \\cup a_2 \\cup \\dots \\cup a_k = a_v / \\{ x \\}\\), unde \\(x\\) va fi valoarea nodului \\(v\\). Putem incrementa o permutare pentru c\u0103 p\u00e2n\u0103 la urm\u0103 nu conteaz\u0103 valorile propriu-zise, ci doar cum sunt ordonate.</p> <p>Rela\u021bia \\((1)\\) implic\u0103 faptul c\u0103 fiecare permutare reprezint\u0103 un interval continuu de elemente din \\(a_v\\). Dac\u0103 nu avem nicio permutare \\(a_i\\) care s\u0103 con\u021bin\u0103 pe \\(x\\), \u00eenseamn\u0103 efectiv ca fie toate elementele din \\(a_i\\) sunt mai mici ca \\(x\\), fie sunt mai mari ca \\(x\\). Uit\u00e2ndu-ne la rela\u021bia din enun\u021b \\(a_{f_i} &lt; a_v = x &lt; a_{f_j}\\), \u00eempreun\u0103 cu ce-am dedus p\u00e2n\u0103 acum, deducem c\u0103 contribu\u021bia nodului \\(v\\) la rezultat este \\((sz_v - S - 1) \\cdot S\\) , cu condi\u021bia c\u0103 exist\u0103 o submul\u021bime a fiilor cu \\(\\sum_{r} sz_{f_r} = S\\).</p> <p>Problema se rezum\u0103 la : afl\u0103 pentru fiecare nod care este \\(S\\)-ul care maximizeaz\u0103 contribu\u021bia, adun\u0103 rezultatele \u0219i afi\u0219eaz\u0103 r\u0103spunsul.</p> <p>Pentru varianta u\u0219oar\u0103 a problemei putem afl\u0103 dac\u0103 \\(S\\) constituie o sum\u0103 valida folosind dp. Similar cu a doua problem\u0103 discutat\u0103, putem optimiza dp-ul cu ajutorul unui bitset, complexitatea final\u0103 fiind \\(\\mathcal{O}(\\frac{N^2}{w})\\).</p>","tags":["implementare","biti","optimizare"]},{"location":"dificil/bitsets/#program-cpp","title":"Program Cpp","text":"<pre><code>int n;\ncin &gt;&gt; n;\nvector&lt;int&gt; sz(n + 1);\nvector&lt;vector&lt;int&gt;&gt; liste(n + 1);\nfor (int i = 2; i &lt;= n; i++) {\n    int p;\n    cin &gt;&gt; p;\n    liste[p].push_back(i);\n    liste[i].push_back(p);\n}\nlong long ans = 0;\nfunction&lt;void(int, int)&gt; dfs = [&amp;](int nod, int p) {\n    sz[nod] = 1;\n    bitset&lt;5001&gt; b;\n    b[0] = 1;\n    for (auto i : liste[nod]) {\n        if (i == p) {\n            continue;\n        }\n        dfs(i, nod);\n        sz[nod] += sz[i];\n        b |= (b &lt;&lt; sz[i]);\n    }\n    long long maxim = 0;\n    for (int i = 1; i &lt;= sz[nod] - 1; i++) {\n        if (b[i]) {\n            maxim = max(maxim, 1LL * i * (sz[nod] - 1 - i));\n        }\n    }\n    ans += maxim;\n};\ndfs(1, 1);\ncout &lt;&lt; ans &lt;&lt; '\\n';\n</code></pre> <p>Valori pentru \\(n\\) care dep\u0103\u0219esc \\(10^5\\) cu greu \u00eentr\u0103 \u00een timp, iar pentru \\(n = 10^6\\) este destul de clar c\u0103 trebuie s\u0103 optimiz\u0103m algoritmul.</p> <p>O optimizare important\u0103, care nu \u021bine de bitset, ci mai mult de programarea dinamic\u0103, este similar\u0103 (daca nu chiar identic\u0103) cu algoritmul de comprimare explicat la problema strehaia. Dac\u0103 un element apare de mai mult de 3 ori : \\(x, x, x\\) , putem s\u0103 lipim pe 2 dintre ei : \\(x, 2x\\), f\u0103r\u0103 ca s\u0103 stric\u0103m corectitudinea la dp. Dac\u0103 repet\u0103m procesul p\u00e2n\u0103 c\u00e2nd un element apare de maxim 2 ori, iar \u00eempreun\u0103 cu o proprietate care zice c\u0103 : \"Pentru un \u0219ir \\(S\\) cu \\(N\\) elemente \u0219i suma elementelor \\(R\\) \\(\\Rightarrow\\) sunt maxim \\(\\mathcal{O}(\\sqrt R)\\) elemente distincte\", rezult\u0103 ca \u00een vectorul pe care aplic\u0103m noi bitset nu vor fi mai mult de \\(2 \\cdot \\sqrt{sz_v}\\) elemente. Complexitatea se reduce la \\(\\mathcal{O}(\\frac{N \\sqrt N}{w})\\).</p> <p>Dac\u0103 face\u021bi doar at\u00e2t, s-ar putea s\u0103 v\u0103 lua\u021bi TLE pe testul 5. A\u0219adar ne vom folosi de bitset dinamic, iar \u00een loc s\u0103 declar\u0103m bitsetul mereu cu \\(10^6\\) elemente, \u00eel vom declara cu \\(sz_v\\) elemente. Foarte suprinz\u0103tor dar chestia asta \u00eentr\u0103 destul de lejer \u00een timp (sunt ironic lol) .</p>","tags":["implementare","biti","optimizare"]},{"location":"dificil/bitsets/#cum-facem-un-bitset-sa-fie-dinamic","title":"Cum facem un bitset s\u0103 fie dinamic?","text":"<p>Avem (cred) 2 metode:</p> <ul> <li>\u00cel scriem noi de m\u00e2n\u0103;</li> <li>(Mai nou) \u00cel putem folosi pe acela introdus \u00een libr\u0103ria   <code>&lt;tr2/dynamic_bitset&gt;</code>.</li> </ul> <p>Un bitset dinamic scris de m\u00e2n\u0103 arat\u0103 \u00een felul urm\u0103tor:</p> <pre><code>template &lt;int len = 1&gt;\nvoid dynamic_bitset(int n) {\n    if (n &gt;= len) {\n        dynamic_bitset&lt;std::min(len * 2, maxn)&gt;(n);\n        return;\n    }\n\n    bitset&lt;len&gt; dp;\n\n    // do somethine with dp\n}\n</code></pre> <p>Dac\u0103 nu este evident, ne folosim de template-uri pentru a ajunge la o lungime minim\u0103 care dep\u0103\u0219este pe \\(n\\) \u00een timp logaritmic.</p> <p>Iar un bitset dinamic din libr\u0103ria <code>&lt;tr2/dynamic_bitset&gt;</code> arat\u0103 a\u0219a:</p> <pre><code>#include &lt;iostream&gt;\n#include &lt;tr2/dynamic_bitset&gt;\nusing namespace tr2 using namespace std;\n\nint main() {\n    dynamic_bitset&lt;&gt; dp(n);\n\n    // do something with dp\n}\n</code></pre> <p>Care este mai bun?</p> <p>P\u00e2i, ambele! Depinde foarte mult de ce vrei s\u0103 faci cu el.</p> <p>O diferen\u021b\u0103 la <code>tr2::dynamic_bitset</code> este func\u021bia <code>resize()</code>. \u00cen consecin\u021b\u0103, <code>tr2::dynamic_bitset</code> este mai lent dec\u00e2t un bitset normal sau un bitset dinamic cu template-uri. \u00cens\u0103, prima variant\u0103 de bitset dinamic nu-\u0219i poate da resize, adic\u0103 e mult spus dinamic. Dac\u0103 ve\u021bi avea nevoie s\u0103 reutiliza\u021bi acela\u0219i bitset dar cu lungime diferit\u0103, folosi\u021bi <code>tr2::dynamic_bitset</code>, altfel varianta cu template-uri este superioar\u0103 din punct de vedere al timpului de execu\u021bie. Iar dac\u0103 nu ave\u021bi \u00een general nevoie de bitset dinamic, folosi\u021bi bitsetul normal.</p>","tags":["implementare","biti","optimizare"]},{"location":"dificil/bitsets/#cum-eficientizam-memoria","title":"Cum eficientiz\u0103m memoria","text":"<p>Putem s\u0103 copiem ce face bitset cel mai import (faptul c\u0103 \u00eemparte num\u0103rul de bi\u021bi \u00een grupe de c\u00e2te \\(w\\)) \u0219i s\u0103 rezolv\u0103m problema pentru grupe de \\(w\\) elemente consecutive ca la final s\u0103 d\u0103m merge la rezultate.</p>","tags":["implementare","biti","optimizare"]},{"location":"dificil/bitsets/#problema-infinity-war-rmi-2015","title":"Problema Infinity War, RMI 2015","text":"<p>Avem \\(N\\) armate care sunt \u00een r\u0103zboi una cu alta, iar fiecare armat\u0103 este alc\u0103tuit\u0103 din solda\u021bi cu diferite puteri (o armat\u0103 are maxim un soldat cu o anumit\u0103 putere) numerotate de la 1 la \\(P\\). Dac\u0103 2 armate se lupt\u0103, vor r\u0103m\u00e2ne \u00een via\u021b\u0103 doar solda\u021bii care nu \u00ee\u0219i reg\u0103sesc puterea \u00een armata inamic\u0103. De exemplu, dac\u0103 reprezent\u0103m armatele ca un \u0219ir de bi\u021bi (unde bitul \\(i\\) este setat dac\u0103 exist\u0103 un soldat cu puterea \\(i\\)), atunci solda\u021bii care r\u0103m\u00e2n \u00een via\u021b\u0103 sunt prezen\u021bi \u00een suma xor a celor doua \u0219iruri.</p> <p>Avem \\(Q\\) query-uri \\((l,r)\\) \u0219i trebuie s\u0103 afl\u0103m c\u00e2\u021bi solda\u021bi r\u0103m\u00e2n \u00een via\u021b\u0103 dac\u0103 se vor lupta armatele \\(l, l + 1, \\dots, r\\).</p> <p>Fie \\(b_i\\) un bitset cu solda\u021bii armatei \\(i\\). R\u0103spunsul este practic num\u0103rul de bi\u021bi \u00een \\(b_l \\oplus b_{l+1} \\oplus \\dots \\oplus b_r\\), unde \\(\\oplus\\) reprezint\u0103 opera\u021bia XOR. Putem face asta folosindu-ne de sumele xor pe prefixe, \\(sp_i = b_i \\oplus b_{i-1} \\oplus \\dots \\oplus b_1\\). Nu putem re\u021bine din p\u0103cate fiecare bitset, nu \u00eencape \\(N \\cdot P\\) bi\u021bi \u00een 8MB.</p> <p>\u00cens\u0103 putem s\u0103 lu\u0103m pe r\u00e2nd secven\u021be de c\u00e2te \\(w\\) elemente \u0219i s\u0103 calcul\u0103m rezultatul doar pentru ele, ca apoi s\u0103 adun\u0103m rezultatele pentru un query.</p>","tags":["implementare","biti","optimizare"]},{"location":"dificil/bitsets/#program-cpp_1","title":"Program Cpp","text":"<pre><code>const int N = 5e4 + 1, P = 1e4 + 1;\n\nifstream fin(\"infinitywar.in\");\nofstream fout(\"infinitywar.out\");\n#define cin fin\n#define cout fout\nint n, q, p = 1, maxim;\n\n// bitset&lt;P&gt; b[N];\nvector&lt;int&gt; v[N];\nint main() {\n    cin.tie(0)-&gt;sync_with_stdio(0);\n    cin &gt;&gt; n &gt;&gt; q;\n    vector&lt;pair&lt;int, int&gt;&gt; qr(q + 1);\n    vector&lt;int&gt; ans(q + 1);\n    for (int i = 1; i &lt;= n; i++) {\n        int k;\n        cin &gt;&gt; k;\n        for (int j = 1; j &lt;= k; j++) {\n            int x;\n            cin &gt;&gt; x;\n            maxim = max(maxim, x);\n            v[i].push_back(x);\n        }\n    }\n    for (int i = 1; i &lt;= q; i++) {\n        int l, r;\n        cin &gt;&gt; l &gt;&gt; r;\n        qr[i] = {l, r};\n    }\n    while (p &lt;= maxim) {\n        vector&lt;unsigned long long&gt; b(n + 1);\n        for (int i = 1; i &lt;= n; i++) {\n            for (auto j : v[i]) {\n                if (p &lt;= j &amp;&amp; j &lt;= p + 63) {\n                    b[i] = 1ULL * b[i] + (1ULL &lt;&lt; (j - p));\n                }\n            }\n            b[i] ^= b[i - 1];\n        }\n        for (int i = 1; i &lt;= q; i++) {\n            unsigned long long nr = b[qr[i].second] ^ b[qr[i].first - 1];\n            ans[i] += __builtin_popcountll(nr);\n        }\n        p++;\n        p += 63;\n    }\n    for (int i = 1; i &lt;= q; i++) {\n        cout &lt;&lt; ans[i] &lt;&lt; '\\n';\n    }\n    // cout &lt;&lt; 'a';\n}\n</code></pre> <p>Complexitatea de timp r\u0103m\u00e2ne tot \\(\\mathcal{O}(\\frac{N \\cdot P}{w})\\) doar c\u0103 acum memoria e \\(\\mathcal{O}(N)\\).</p>","tags":["implementare","biti","optimizare"]},{"location":"dificil/bitsets/#concluzii","title":"Concluzii","text":"<p>Este de apreciat cu c\u00e2t poate \u00eembun\u0103t\u0103\u021bii execu\u021bia unui algoritm un bitset. Pute\u021bi s\u0103 \u00eencerca\u021bi s\u0103 v\u0103 construi\u021bi voi un bitset custom, s\u0103 experimenta\u021bi cu diferite valori ale lui \\(w\\), cu diferite func\u021bii etc.. \u00cen general nu ar trebui s\u0103 abuza\u021bi de un bitset, dar nici s\u0103-l desconsidera\u021bi. G\u0103si\u021bi o cale de mijloc.</p>","tags":["implementare","biti","optimizare"]},{"location":"dificil/bitsets/#probleme-suplimentare","title":"Probleme suplimentare","text":"<ul> <li>atcoder - Triangle</li> <li>cses - Reachable Nodes</li> <li>atcoder - Balancing Network   (T=1)</li> <li>Tzaph &amp; Number Line</li> <li>Baltic OI 2019 - Nautil</li> <li>Baltic OI 2010 - Candies</li> <li>COCI 2015 - Uzastopni</li> <li>Platinum - Equilateral   Triangles</li> <li>IZhO 2017 - Bootfall</li> <li>Baltic OI 2015 - Tug of War</li> <li>codeforces - Rectangular   Polyline</li> <li>Lot Seniori 2022 - erinaceida</li> <li>Lot Seniori 2014 - Switch5</li> <li>Lot Seniori 2024 - Matrice Palindrom   (pute\u021bi 60 puncte cu bitset, eu nu \u0219tiu s\u0103 fac mai bine de at\u00e2t)</li> <li>holmesc</li> </ul>","tags":["implementare","biti","optimizare"]},{"location":"dificil/bitsets/#resurse-suplimentare","title":"Resurse suplimentare","text":"<ul> <li>How to get actual 64 bit bitsets on   Codeforces</li> <li>Bitset - USACO Guide</li> <li>Bitwise operations 2 \u2014 popcount &amp; bitsets -   Codeforces</li> <li>Dynamic Bitsets in GCC</li> </ul>","tags":["implementare","biti","optimizare"]},{"location":"dificil/componente-biconexe/","title":"Componente biconexe","text":"<p>\u00cen cele ce urmeaz\u0103, vom prezenta componentele biconexe, algoritmul prin care le afl\u0103m \u0219i cum putem folosi aceste informa\u021bii \u00een probleme.</p>","tags":["grafuri neorientate","programare dinamica","parcurgeri","cicluri"]},{"location":"dificil/componente-biconexe/#introducere","title":"Introducere","text":"<p>\u00cen cele ce urmeaz\u0103, vom prezenta componentele biconexe, elementele principale asociate componentelor biconexe \u0219i cum putem implementa algoritmul specific pentru aflarea lor. De asemenea, vom prezenta \u0219i alte tehnici asociate, \u00eempreun\u0103 cu probleme exemplu.</p> <p>Ca \u0219i cuno\u0219tin\u021be necesare pentru \u00een\u021belegerea componentelor biconexe, se recomand\u0103 studiul parcurgerii grafurilor \u0219i dinamicilor pe arbore.</p> <p>Defini\u021bie</p> <p>\u00centr-un graf neorientat, componentele biconexe sunt submul\u021bimi maximale de noduri cu proprietatea c\u0103 pentru oricare pereche de noduri \\((a, b)\\) care apar\u021bin unei astfel de componente, se poate ajunge de la \\(a\\) la \\(b\\) chiar \u0219i dac\u0103 scoatem un nod din graful rezultat.</p> <p>Observa\u021bie</p> <p>Se poate observa c\u0103 componentele biconexe sunt o versiune mai avansat\u0103 a componentelor conexe, prelucrarea lor va fi una mai specific\u0103 \u0219i a\u0219a cum ve\u021bi vedea \u00een acest articol, destul de u\u0219or de aplicat dup\u0103 c\u00e2teva exemple explicate.</p> <p>Exemplu</p> <p>De exemplu, dac\u0103 avem urm\u0103torul graf: \\(n = 8\\), \\(m = 9\\) \u0219i urm\u0103toarele muchii de tip \\((a, b)\\): \\((1, 2)\\),$ (2, 3)\\(,\\) (3, 4)\\(,\\) (4, 1)\\(,\\) (1, 5)\\(,\\) (5, 6)\\(,\\) (6, 7)\\(,\\) (7, 5)\\(,\\) (7, 8)$, componentele biconexe sunt \\(\\{1, 2, 3, 4\\}\\), \\(\\{7, 8\\}\\), \\(\\{5, 6, 7\\}\\) \u0219i \\(\\{1, 5\\}\\). Mai jos g\u0103si\u021bi un desen reprezentativ.</p> <p></p> <p>Pentru aflarea componentelor biconexe, exist\u0103 mai multe metode de a le afla, dar aici vom prezenta una dintre ele, care se bazeaz\u0103 pe o parcurgere DFS \u0219i \u00eemp\u0103r\u021birea muchiilor \u00een dou\u0103 categorii, cre\u00e2ndu-se ceea ce vom numi un arbore DFS.</p>","tags":["grafuri neorientate","programare dinamica","parcurgeri","cicluri"]},{"location":"dificil/componente-biconexe/#arborele-dfs-dfs-tree","title":"Arborele DFS (DFS Tree)","text":"<p>Observa\u021bie</p> <p>Recomand\u0103m \u00een mod special acest blog de pe Codeforces pentru \u00een\u021belegerea conceptului \u0219i chiar pentru explica\u021bii suplimentare pentru unele con\u021binuturi care vor fi prezentate ulterior \u00een acest articol.</p> <p>Defini\u021bie</p> <p>Un arbore DFS este un arbore pe care \u00eel ob\u021binem parcurg\u00e2nd un graf neorientat folosind o parcurgere DFS, dac\u0103 p\u0103str\u0103m doar muchiile care au fost folosite pentru a apela DFS din noduri noi.</p> <p>Deoarece grafurile cu care lucr\u0103m nu sunt arbori, se impune \u00eemp\u0103r\u021birea muchiilor grafului \u00een func\u021bie de apartenen\u021ba la arborele DFS.</p> <p>Defini\u021bie</p> <p>Muchiile care nu apar\u021bin arborelui DFS, dar apar\u021bin grafului ini\u021bial reprezint\u0103 muchii de \u00eentoarcere.</p> <p>Observa\u021bie</p> <p>Se poate observa c\u0103 \u00een func\u021bie de ordinea \u00een care se realizeaz\u0103 parcurgerea DFS, unele muchii principale pot deveni muchii de \u00eentoarcere \u0219i invers, dar exist\u0103 muchii care nu vor fi niciodat\u0103 muchii de \u00eentoarcere, acestea devenind subiectul nostru de discu\u021bie ulterior \u00een articol.</p> <p>\u00cen desenul de mai jos, muchiile \u00eengro\u0219ate reprezint\u0103 arborele DFS. Muchiile care nu sunt \u00eengro\u0219ate reprezint\u0103 muchiile de \u00eentoarcere.</p> <p></p>","tags":["grafuri neorientate","programare dinamica","parcurgeri","cicluri"]},{"location":"dificil/componente-biconexe/#elemente-esentiale","title":"Elemente esen\u021biale","text":"<p>\u00cen cele ce urmeaz\u0103, vom prezenta c\u00e2teva dintre cele mai importante no\u021biuni care se reg\u0103sesc atunci c\u00e2nd lucr\u0103m cu componente biconexe.</p>","tags":["grafuri neorientate","programare dinamica","parcurgeri","cicluri"]},{"location":"dificil/componente-biconexe/#muchii-critice","title":"Muchii critice","text":"<p>Muchiile critice (numite \u00een englez\u0103 bridges) reprezint\u0103 muchiile care dac\u0103 le scoatem din graf, acesta nu va mai fi conex. Un astfel de exemplu \u00een desenul de mai sus este muchia \\((2, 4)\\).</p> <p>Observa\u021bie</p> <p>O muchie de \u00eentoarcere nu va fi niciodata o muchie critic\u0103, arborele DFS s-a putut construi deja f\u0103r\u0103 ea.</p>","tags":["grafuri neorientate","programare dinamica","parcurgeri","cicluri"]},{"location":"dificil/componente-biconexe/#puncte-de-articulatie","title":"Puncte de articula\u021bie","text":"<p>Punctele de articula\u021bie reprezint\u0103 nodurile care dac\u0103 le scoatem din graf, acesta nu va mai fi conex. Un astfel de exemplu \u00een desenul de mai sus este nodul 9.</p>","tags":["grafuri neorientate","programare dinamica","parcurgeri","cicluri"]},{"location":"dificil/componente-biconexe/#algoritmul-de-aflare-a-componentelor-biconexe","title":"Algoritmul de aflare a componentelor biconexe","text":"<p>Pentru a afla componentele biconexe, precum \u0219i celelalte valori relevante (muchiile critice \u0219i punctele de articula\u021bie), vom folosi un algoritm bazat pe o parcurgere DFS \u0219i o abordare specific\u0103 program\u0103rii dinamice.</p> <p>\u00cen primul r\u00e2nd, vom avea nevoie s\u0103 \u0219tim pentru fiecare nod, nivelul la care se afl\u0103 conform arborelui DFS, lucru ce se poate afla foarte u\u0219or.</p> <p>\u00cen al doilea r\u00e2nd, \u0219i poate cel mai important aspect al acestui algoritm, reprezint\u0103 recuren\u021ba prin care afl\u0103m pentru fiecare nod care este cel mai mic nivel pe care \u00eel putem accesa folosind nodurile din subarborele s\u0103u, \u00eempreun\u0103 cu muchiile de \u00eentoarcere ale nodurilor din acesta, recuren\u021b\u0103 care va fi numit\u0103 \\(low\\).</p> <p>Pentru a calcula valoarea lui \\(low\\) pentru fiecare nod, ne vom folosi de valorile lui \\(low\\) calculate pentru fiecare fiu al nodului curent, \u00eempreun\u0103 cu nivelele la care se afl\u0103 nodurile din muchiile de \u00eentoarcere corespunz\u0103toare nodului curent. Cu alte cuvinte, aceast\u0103 recuren\u021b\u0103 este foarte similar\u0103 cu alte recuren\u021be cu care sunte\u021bi obi\u0219nui\u021bi de la dinamicile pe arbore, scopul acesteia reprezint\u0103 aflarea nivelului la care se afl\u0103 cel mai apropiat nod de r\u0103d\u0103cin\u0103 pe care \u00eel putem accesa.</p> <p>Un alt aspect de implementare foarte important reprezint\u0103 memorarea nodurilor \u00eentr-o stiv\u0103, \u00een ordinea \u00een care au fost accesate, scopul fiind acela de a identifica componentele biconexe, deoarece de fiecare dat\u0103 c\u00e2nd d\u0103m de un punct de articula\u021bie, putem separa nodurile ce fac parte din componenta biconex\u0103 curent\u0103 de restul grafului, \u00een ordinea invers\u0103 celei \u00een care au fost ad\u0103ugate \u00een stiv\u0103.</p>","tags":["grafuri neorientate","programare dinamica","parcurgeri","cicluri"]},{"location":"dificil/componente-biconexe/#implementare","title":"Implementare","text":"<p>Pentru a implementa acest algoritm, tot ce trebuie s\u0103 facem este s\u0103 aplic\u0103m pa\u0219ii de mai sus, aten\u021bia la implementare fiind necesar\u0103.</p> <p>Pentru a afla punctele de articula\u021bie, avem dou\u0103 cazuri care trebuie avute \u00een vedere:</p> <ul> <li>Fie nodul este r\u0103d\u0103cina \u0219i are cel pu\u021bin doi copii</li> <li>Fie nodul nu este r\u0103d\u0103cina, iar unul din copii are valoarea lui \\(low\\) mai mare   sau egal\u0103 dec\u00e2t cea a nivelului nodului curent.</li> </ul> <p>Pentru a afla muchiile critice, trebuie s\u0103 g\u0103sim leg\u0103turile de tip \\((a, b)\\) astfel \u00eenc\u00e2t \\(low[b] = niv[a]\\).</p> <p>Implementarea de mai jos este bazat\u0103 pe problema Strongly Connected Edges, unde ne baz\u0103m pe diferen\u021bele dintre nivelurile nodurilor pentru a fixa direc\u021biile muchiilor.</p> <pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n\nint n, m, cnt;\nvector&lt;vector&lt;int&gt; &gt; v;\n\nvector&lt;int&gt; vis, lvl, low;\ndeque&lt;int&gt; d;\n\nset&lt;pair&lt;int, int&gt; &gt; edges;  // pentru a fixa directiile\n\nvector&lt;vector&lt;int&gt; &gt; bccs;\n\nvoid dfs(int parent, int node) {\n    vis[node] = 1;\n    low[node] = lvl[node];\n    d.push_back(node);\n\n    bool articulation = 0;\n\n    int children = 0;\n    for (int i = 0; i &lt; (int)v[node].size(); ++i) {\n        int nxt = v[node][i];\n        if (nxt == parent) {\n            continue;\n        }\n        if (vis[nxt]) {\n            low[node] = min(low[node], lvl[nxt]);\n\n            if (lvl[node] &gt; lvl[nxt]) {\n                edges.insert({node, nxt});\n            } else {\n                edges.insert({nxt, node});\n            }\n            continue;\n        }\n\n        lvl[nxt] = lvl[node] + 1;\n        children++;\n        dfs(node, nxt);\n        low[node] = min(low[node], low[nxt]);\n\n        if (lvl[node] &lt; lvl[nxt]) {\n            edges.insert({node, nxt});\n        } else {\n            edges.insert({nxt, node});\n        }\n\n        if (low[nxt] &gt;= lvl[node]) {\n            cnt++;\n\n            if (parent != 0) {\n                articulation = 1;\n            }\n            int lst;\n            do {\n                lst = d.back();\n                sol[cmt].push_back(d.back());\n                d.pop_back();\n            } while (!d.empty() &amp;&amp; lst != nxt);\n        }\n\n        if (low[nxt] &gt; lvl[node]) {\n            // muchiile critice sunt intre nod si nxt\n            cout &lt;&lt; \"IMPOSSIBLE\\n\";\n            exit(0);\n        }\n    }\n\n    if (parent == 0 &amp;&amp; children &gt;= 2) {\n        articulation = 1;\n    }\n}\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n\n    cin &gt;&gt; n &gt;&gt; m;\n\n    v.resize(n + 1);\n    vis.resize(n + 1);\n    lvl.resize(n + 1);\n    low.resize(n + 1);\n\n    for (int i = 1; i &lt;= m; ++i) {\n        int a, b;\n        cin &gt;&gt; a &gt;&gt; b;\n        v[a].push_back(b);\n        v[b].push_back(a);\n    }\n\n    dfs(0, 1);\n\n    if (edges.size() != m) {\n        cout &lt;&lt; \"IMPOSSIBLE\\n\";\n        return 0;\n    }\n\n    for (auto x : edges) {\n        cout &lt;&lt; x.first &lt;&lt; \" \" &lt;&lt; x.second &lt;&lt; '\\n';\n    }\n    return 0;\n}\n</code></pre>","tags":["grafuri neorientate","programare dinamica","parcurgeri","cicluri"]},{"location":"dificil/componente-biconexe/#concluzii","title":"Concluzii","text":"<p>Componentele biconexe, la fel ca \u0219i componentele tare conexe, sunt un concept al c\u0103ror implementare, odat\u0103 ce este \u0219tiut\u0103, face procesul de rezolvare al problemelor mult mai u\u0219or. Totu\u0219i, trebuie avut \u00een vedere faptul c\u0103 acestea apar de multe ori \u0219i combinate cu alte tehnici, precum programarea dinamic\u0103 sau al\u021bi algoritmi pe grafuri.</p> <p>O alt\u0103 aplica\u021bie a acestei metode reprezint\u0103 algoritmul lui Tarjan, explicat aici.</p>","tags":["grafuri neorientate","programare dinamica","parcurgeri","cicluri"]},{"location":"dificil/componente-biconexe/#probleme-suplimentare","title":"Probleme suplimentare","text":"<ul> <li>biconex infoarena</li> <li>Strongly Connected Edges - CSES</li> <li>Componente biconexe -   pbinfo</li> <li>Non-academic problem -   Codeforces</li> <li>CSES Forbidden Cities</li> <li>ONI 2014 clepsidra</li> <li>ONI 2022 regate</li> <li>infoarena santa</li> <li>Tourism - Codeforces</li> <li>ONI 2019 linegraph</li> <li>Tourist reform - Codeforces</li> <li>Pursuit for artifacts -   Codeforces</li> <li>APIO 2018 Duathlon</li> <li>TLE 2017 Investment</li> <li>Probleme cu componente biconexe de pe Kilonova</li> </ul>","tags":["grafuri neorientate","programare dinamica","parcurgeri","cicluri"]},{"location":"dificil/componente-biconexe/#lectura-suplimentara","title":"Lectur\u0103 suplimentar\u0103","text":"<ul> <li>Biconnected Components - USACO   Guide</li> <li>Biconexitate - pbinfo</li> <li>DFS Tree and Bridges - Codeforces</li> <li>Biconnected component -   wikipedia</li> <li>Finding Bridges in O(n+m) -   cpalgorithms</li> <li>Finding articulations -   cpalgorithms</li> </ul>","tags":["grafuri neorientate","programare dinamica","parcurgeri","cicluri"]},{"location":"dificil/componente-tare-conexe/","title":"Componente tare conexe","text":"","tags":["grafuri orientate","parcurgeri","cicluri"]},{"location":"dificil/componente-tare-conexe/#introducere","title":"Introducere","text":"<p>\u00cen cele ce urmeaz\u0103, vom prezenta componentele tare conexe, algoritmii principali \u0219i cum \u00eei putem aplica.</p> <p>Defini\u021bie</p> <p>\u00centr-un graf orientat, componentele tare conexe sunt submul\u021bimi maximale de noduri cu proprietatea c\u0103 pentru oricare pereche de noduri \\((a, b)\\) care apar\u021bin unei astfel de componente, se poate ajunge \u0219i de la \\(a\\) la \\(b\\), \u0219i de la \\(b\\) la \\(a\\) folosind muchiile existente.</p> <p>Observa\u021bie</p> <p>Se poate observa c\u0103 componentele tare conexe sunt versiunea componentelor conexe pentru grafurile orientate. De\u0219i defini\u021biile sunt similare, se va observa c\u0103 aflarea lor va fi mai dificil\u0103 dec\u00e2t cea a componentelor conexe, care const\u0103 \u00eentr-o simpl\u0103 parcurgere.</p> <p>Exemplu</p> <p>De exemplu, dac\u0103 avem urm\u0103torul graf: \\(n = 8\\), \\(m = 12\\) \u0219i urm\u0103toarele muchii de tip \\((a, b)\\): \\((1, 2)\\),$ (2, 6)\\(,\\) (6, 7)\\(,\\) (7, 6)\\(,\\) (3, 1)\\(,\\) (3, 4)\\(,\\) (2, 3)\\(,\\) (4, 5)\\(,\\) (5, 4)\\(,\\) (6, 5)\\(,\\) (5, 8)\\(,\\) (8, 7)$, componentele tare conexe sunt \\(\\{1, 2, 3\\}\\) \u0219i \\(\\{4, 5, 6, 7, 8\\}\\). Mai jos g\u0103si\u021bi un desen reprezentativ.  </p> <p></p> <p>Pentru aflarea componentelor tare conexe, exist\u0103 doi algoritmi la fel de eficien\u021bi, algoritmul lui Tarjan \u0219i algoritmul lui Kosaraju, ambii fiind algoritmi ce ruleaz\u0103 \u00een timp liniar.</p> <p>\u00cen general, deoarece nu exist\u0103 vreo diferen\u021b\u0103 \u00eentre ei \u00een practic\u0103, se prefer\u0103 folosirea algoritmului lui Kosaraju, deoarece este mai u\u0219or de \u021binut minte \u0219i poate fi aplicat foarte u\u0219or \u00een aplica\u021biile viitoare.</p>","tags":["grafuri orientate","parcurgeri","cicluri"]},{"location":"dificil/componente-tare-conexe/#algoritmul-lui-kosaraju","title":"Algoritmul lui Kosaraju","text":"<p>Algoritmul lui Kosaraju este un algoritm care se va baza pe dou\u0103 parcurgeri de tip DFS, una pe graful ini\u021bial \u0219i cealalt\u0103 pe graful transpus pentru a afla componentele tare conexe.</p> <p>Graf transpus</p> <p>\u00centr-un graf orientat, un graf transpus \\(G'\\) este un graf care are proprietatea c\u0103 pentru fiecare muchie \\((a, b)\\) care se afl\u0103 \u00een \\(G\\), \\(G'\\) va con\u021bine muchia \\((b, a)\\). Cu alte cuvinte, muchiile sunt inversate. Pentru mai multe informa\u021bii, pute\u021bi accesa acest link.</p> <p>Pe scurt, algoritmul va parcurge mai \u00eent\u00e2i nodurile \u00eentr-o manier\u0103 similar\u0103 cu cea de la algoritmul pentru aflarea componentelor conexe, singura diferen\u021b\u0103 fiind aceea c\u0103 la finalizarea pa\u0219ilor efectua\u021bi \u00een func\u021bie pentru un nod dat, acesta va fi ad\u0103ugat \u00eentr-o stiv\u0103.</p> <p>Ulterior, nodurile din stiv\u0103 vor fi luate pe r\u00e2nd, iar pentru fiecare nod nevizitat la acest pas, vom avea o parcurgere similar\u0103 cu cea de la primul pas, parcurgere efectuat\u0103 pe graful transpus care ne va da componentele tare conexe, acelea fiind cele care sunt vizitate de nodul curent la pasul dat.</p> <p>Acest algoritm are complexitate \\(\\mathcal{O}(n + m)\\) \u0219i implementarea lui, folosit\u0103 la problema Planets and Kingdoms poate fi citit\u0103 mai jos:</p> <pre><code>#include &lt;iostream&gt;\n#include &lt;stack&gt;\n#include &lt;vector&gt;\n\nusing namespace std;\n\nstack&lt;int&gt; s;\n\nvoid dfs(int node, vector&lt;vector&lt;int&gt;&gt; &amp;v, vector&lt;int&gt; &amp;vis) {\n    vis[node] = 1;\n    for (int j = 0; j &lt; (int)v[node].size(); ++j) {\n        int nxt = v[node][j];\n        if (!vis[nxt]) {\n            dfs(nxt, v, vis);\n        }\n    }\n    s.push(node);\n}\nvoid dfs2(int node, int cnt, vector&lt;vector&lt;int&gt;&gt; &amp;tr, vector&lt;int&gt; &amp;vis2,\n          vector&lt;int&gt; &amp;scc) {\n    vis2[node] = 1;\n    scc[node] = cnt;\n    for (int j = 0; j &lt; (int)tr[node].size(); ++j) {\n        int nxt = tr[node][j];\n        if (!vis2[nxt]) {\n            dfs2(nxt, cnt, tr, vis2, scc);\n        }\n    }\n}\n\nint main() {\n    int n, m;\n    cin &gt;&gt; n &gt;&gt; m;\n\n    vector&lt;int&gt; vis(n + 1), vis2(n + 1), scc(n + 1);\n    vector&lt;vector&lt;int&gt;&gt; v(n + 1), tr(n + 1);\n\n    for (int i = 1; i &lt;= m; ++i) {\n        int a, b;\n        cin &gt;&gt; a &gt;&gt; b;\n        v[a].push_back(b);\n        tr[b].push_back(a);\n    }\n    for (int i = 1; i &lt;= n; ++i) {\n        if (!vis[i]) {\n            dfs(i, v, vis);\n        }\n    }\n\n    int cnt = 0;\n    while (!s.empty()) {\n        int node = s.top();\n        s.pop();\n        if (!vis2[node]) {\n            ++cnt;\n            dfs2(node, cnt, tr, vis2, scc);\n        }\n    }\n    cout &lt;&lt; cnt &lt;&lt; '\\n';\n    for (int i = 1; i &lt;= n; ++i) {\n        cout &lt;&lt; scc[i] &lt;&lt; \" \";\n    }\n    return 0;\n}\n</code></pre>","tags":["grafuri orientate","parcurgeri","cicluri"]},{"location":"dificil/componente-tare-conexe/#algoritmul-lui-tarjan","title":"Algoritmul lui Tarjan","text":"<p>Ideea de baz\u0103 a algoritmului este urm\u0103toarea: Se \u00eencepe cu o parcurgere DFS dintr-un nod oarecare (parcurgerile viitoare vor fi efectuate pe noduri care nu au fost vizitate \u00eenc\u0103). Aceste parcurgeri ne vor oferi ni\u0219te arbori par\u021biali, construi\u021bi din muchiile care au fost folosite pentru a vizita nodurile \u00een cauz\u0103.</p> <p>Pentru a afla componentele tare conexe, ne vom folosi de arborii crea\u021bi pentru a g\u0103si subarbori care vor avea proprietatea c\u0103 nivelul minim la care se poate ajunge folosind muchiile de \u00eentoarcere este egal cu nivelul nodului curent, unde nivelul nodului este num\u0103rul s\u0103u de ordine din parcurgerea DFS. Un tutorial foarte bun poate fi accesat aici.</p> <p>Pentru cei familiariza\u021bi \u0219i cu componentele biconexe, se vor putea observa destule similarit\u0103\u021bi \u00eentre algoritmul acesta \u0219i cel de la componentele biconexe, ambii fiind inventa\u021bi de Tarjan. Mai jos pute\u021bi g\u0103si o solu\u021bie care rezolv\u0103 aceea\u0219i problem\u0103 de mai sus.</p> <pre><code>#include &lt;iostream&gt;\n#include &lt;stack&gt;\n#include &lt;vector&gt;\n\nusing namespace std;\n\nvector&lt;vector&lt;int&gt;&gt; graph;\nvector&lt;int&gt; idx, lowlink, instack, scc;\nint ptr, ncomp;\n\nstack&lt;int&gt; stk;\n\nvoid dfs(int node) {\n    int aux;\n\n    lowlink[node] = idx[node] = ++ptr;\n    instack[node] = 1;\n    stk.push(node);\n\n    for (int i = 0; i &lt; (int)graph[node].size(); i++) {\n        int nxt = graph[node][i];\n        if (idx[nxt] == 0) {\n            dfs(nxt);\n            lowlink[node] = min(lowlink[node], lowlink[nxt]);\n        } else if (instack[graph[node][i]]) {\n            lowlink[node] = min(lowlink[node], lowlink[nxt]);\n        }\n    }\n\n    if (idx[node] == lowlink[node]) {\n        do {\n            aux = stk.top();\n            stk.pop();\n            instack[aux] = 0;\n            scc[aux] = ncomp;\n        } while (aux != node);\n        ncomp++;\n    }\n}\n\nint solve(int n) {\n    idx.resize(n + 1, 0);\n    instack.resize(n + 1, 0);\n    lowlink.resize(n + 1, 0);\n    scc.resize(n + 1, 0);\n\n    for (int i = 1; i &lt;= n; i++) {\n        if (idx[i] == 0) {\n            dfs(i);\n        }\n    }\n    return ncomp;\n}\n\nint main() {\n    int n, m;\n    cin &gt;&gt; n &gt;&gt; m;\n\n    graph.resize(n + 1);\n\n    for (int i = 1; i &lt;= m; i++) {\n        int a, b;\n        cin &gt;&gt; a &gt;&gt; b;\n        graph[a].push_back(b);\n    }\n\n    cout &lt;&lt; solve(n) &lt;&lt; '\\n';\n    for (int i = 1; i &lt;= n; i++) {\n        cout &lt;&lt; scc[i] + 1 &lt;&lt; \" \";\n    }\n    return 0;\n}\n</code></pre>","tags":["grafuri orientate","parcurgeri","cicluri"]},{"location":"dificil/componente-tare-conexe/#aplicatii","title":"Aplica\u021bii","text":"<p>De regul\u0103, componentele tare conexe apar destul de rar \u00een probleme de sine st\u0103t\u0103toare, din cauza faptului c\u0103 cunoa\u0219terea lor ar face diferen\u021ba dintre cei care ar lua punctajul maxim \u0219i cei care nu ar lua puncte. Totu\u0219i, se poate remarca prezen\u021ba lucrului cu componentele tare conexe \u00een unele dinamici pe grafuri, \u00een care putem folosi o proprietate foarte important\u0103, pe care o vom enun\u021ba mai jos.</p> <p>Compresarea componentelor tare conexe</p> <p>Dac\u0103 compres\u0103m componentele tari conexe \u00eentr-un singur nod, noul graf rezultat devine aciclic, fapt care ne ajut\u0103 s\u0103 aplic\u0103m dinamicile specifice grafurilor orientate aciclice.</p> <p>Observa\u021bie</p> <p>Algoritmul lui Kosaraju ne ofer\u0103 componentele tare conexe \u00een ordinea sort\u0103rii topologice din graful rezultat.</p>","tags":["grafuri orientate","parcurgeri","cicluri"]},{"location":"dificil/componente-tare-conexe/#problema-coin-collector","title":"Problema Coin Collector","text":"<p>Pentru a rezolva aceast\u0103 problem\u0103, va trebui s\u0103 afl\u0103m componentele tare conexe, iar mai apoi, s\u0103 le compres\u0103m folosind unul din algoritmii descri\u0219i mai sus. Ulterior, vom construi noul graf \u0219i vom aplica o sortare topologic\u0103 pe noul graf rezultat, \u021bin\u00e2nd o dinamic\u0103, \u00een care vom \u0219ti pentru fiecare component\u0103 tare conex\u0103, suma maxim\u0103 a costurilor ce pot fi luate pe un asemenea drum.</p> <p>Solu\u021bia va fi din nou, una liniar\u0103 raportat\u0103 la dimensiunile grafului.</p> <pre><code>#include &lt;iostream&gt;\n#include &lt;queue&gt;\n#include &lt;stack&gt;\n#include &lt;vector&gt;\n\nusing namespace std;\n\nstack&lt;int&gt; s;\n\nvoid dfs(int node, vector&lt;vector&lt;int&gt;&gt; &amp;v, vector&lt;int&gt; &amp;vis) {\n    vis[node] = 1;\n    for (int j = 0; j &lt; (int)v[node].size(); ++j) {\n        int nxt = v[node][j];\n        if (!vis[nxt]) {\n            dfs(nxt, v, vis);\n        }\n    }\n    s.push(node);\n}\nvoid dfs2(int node, int cnt, vector&lt;vector&lt;int&gt;&gt; &amp;tr, vector&lt;int&gt; &amp;vis2,\n          vector&lt;int&gt; &amp;scc) {\n    vis2[node] = 1;\n    scc[node] = cnt;\n    for (int j = 0; j &lt; (int)tr[node].size(); ++j) {\n        int nxt = tr[node][j];\n        if (!vis2[nxt]) {\n            dfs2(nxt, cnt, tr, vis2, scc);\n        }\n    }\n}\n\nint main() {\n    int n, m;\n    cin &gt;&gt; n &gt;&gt; m;\n\n    vector&lt;long long&gt; vals(n + 1), sum(n + 1), dp(n + 1);\n    for (int i = 1; i &lt;= n; i++) {\n        cin &gt;&gt; vals[i];\n    }\n\n    vector&lt;int&gt; vis(n + 1), vis2(n + 1), scc(n + 1);\n    vector&lt;vector&lt;int&gt;&gt; v(n + 1), tr(n + 1);\n\n    for (int i = 1; i &lt;= m; ++i) {\n        int a, b;\n        cin &gt;&gt; a &gt;&gt; b;\n        v[a].push_back(b);\n        tr[b].push_back(a);\n    }\n    for (int i = 1; i &lt;= n; ++i) {\n        if (!vis[i]) {\n            dfs(i, v, vis);\n        }\n    }\n\n    int cnt = 0;\n    while (!s.empty()) {\n        int node = s.top();\n        s.pop();\n        if (!vis2[node]) {\n            ++cnt;\n            dfs2(node, cnt, tr, vis2, scc);\n        }\n    }\n\n    long long ans = 0;\n\n    for (int i = 1; i &lt;= n; i++) {\n        sum[scc[i]] += vals[i];\n    }\n\n    vector&lt;vector&lt;int&gt;&gt; sccgraph(n + 1);\n    vector&lt;int&gt; degree(n + 1);\n    for (int i = 1; i &lt;= n; i++) {\n        for (auto nxt : v[i]) {\n            if (scc[i] != scc[nxt]) {\n                sccgraph[scc[i]].push_back(scc[nxt]);\n                degree[scc[nxt]]++;\n            }\n        }\n    }\n\n    queue&lt;int&gt; q;\n    for (int i = 1; i &lt;= cnt; i++) {\n        if (degree[i] == 0) {\n            q.push(i);\n        }\n    }\n\n    while (!q.empty()) {\n        int node = q.front();\n        q.pop();\n        dp[node] += sum[node];\n        ans = max(ans, dp[node]);\n\n        for (auto nxt : sccgraph[node]) {\n            degree[nxt]--;\n            if (degree[nxt] == 0) {\n                q.push(nxt);\n            }\n            dp[nxt] = max(dp[nxt], dp[node]);\n        }\n    }\n\n    cout &lt;&lt; ans &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["grafuri orientate","parcurgeri","cicluri"]},{"location":"dificil/componente-tare-conexe/#concluzii-si-alte-aplicatii","title":"Concluzii \u0219i alte aplica\u021bii","text":"<p>Componentele tare conexe sunt o no\u021biune fundamental\u0103 foarte important\u0103 care apare \u00een probleme la diverse competi\u021bii, dar \u00een contextul olimpiadelor, se reg\u0103sesc mai ales \u00een dinamicile pe grafuri orientate, precum \u0219i ulterior, atunci c\u00e2nd ve\u021bi studia 2-SAT, problem\u0103 ce se rezolv\u0103 cu ajutorul componentelor tare conexe generate de graful special creat din expresiile logice date.</p> <p>Se recomand\u0103 implementarea clar\u0103 a algoritmului ales (nu ave\u021bi nevoie s\u0103 \u0219ti\u021bi ambii algoritmi, dar cunoa\u0219terea ambilor e un plus) pentru a putea face rezolvarea problemelor ulterioare mai u\u0219oar\u0103.</p>","tags":["grafuri orientate","parcurgeri","cicluri"]},{"location":"dificil/componente-tare-conexe/#probleme-suplimentare","title":"Probleme suplimentare","text":"<ul> <li>ctc infoarena</li> <li>Checkposts Codeforces</li> <li>Ralph and Mushrooms Codeforces</li> <li>IIOT 2023-24 Dogtrick 2</li> <li>Transitive Graph Codeforces</li> <li>Flight Routes Check CSES</li> <li>Grass Cownoisseur USACO   Gold</li> <li>obiective infoarena</li> <li>dep Baraj Seniori 2008</li> <li>network Baraj Seniori 2016</li> <li>Probleme cu componente tare conexe de pe   kilonova</li> </ul>","tags":["grafuri orientate","parcurgeri","cicluri"]},{"location":"dificil/componente-tare-conexe/#lectura-suplimentara","title":"Lectur\u0103 suplimentar\u0103","text":"<ul> <li>Strongly Connected Components - USACO   Guide</li> <li>Tare conexitate -   pbinfo</li> <li>Strongly Connected Components -   CP-algorithms</li> <li>Algoritmul lui Kosaraju -   Wikipedia</li> <li>Algoritmul lui Tarjan - Codeforces</li> <li>Algoritmul lui Tarjan -   Wikipedia</li> <li>Graph (IV) - slides 61-83 -   HKOI</li> <li>Alt algoritm pentru componente tare conexe de la   Radewoosh</li> </ul>","tags":["grafuri orientate","parcurgeri","cicluri"]},{"location":"dificil/convex-hull/","title":"\u00cenf\u0103\u0219ur\u0103toare convex\u0103","text":"<p>Daca vreti sa ne ajutati cu acest articol, ne puteti gasi pe github sau pe serverul nostru de discord</p> <p>Mai jos g\u0103si\u021bi resurse pe care le pute\u021bi citi p\u00e2n\u0103 atunci.</p>","tags":["geometrie","stiva","infasuratoare convexa","sortare"]},{"location":"dificil/convex-hull/#introducere","title":"Introducere","text":"","tags":["geometrie","stiva","infasuratoare convexa","sortare"]},{"location":"dificil/convex-hull/#problema-exemplu","title":"Problema exemplu","text":"","tags":["geometrie","stiva","infasuratoare convexa","sortare"]},{"location":"dificil/convex-hull/#concluzii","title":"Concluzii","text":"","tags":["geometrie","stiva","infasuratoare convexa","sortare"]},{"location":"dificil/convex-hull/#probleme-suplimentare","title":"Probleme suplimentare","text":"<ul> <li>infasuratoare infoarena</li> </ul>","tags":["geometrie","stiva","infasuratoare convexa","sortare"]},{"location":"dificil/convex-hull/#resurse-suplimentare","title":"Resurse suplimentare","text":"<ul> <li>Convex Hull - USACO Guide</li> <li>Convex hull construction - Graham's scan Algorithm - CP   Algorithms</li> <li>Infasuratoare convexa - CPPI Sync</li> </ul>","tags":["geometrie","stiva","infasuratoare convexa","sortare"]},{"location":"dificil/cuplaj-maxim-pe-graf-bipartit/","title":"Cuplaj maxim pe graf bipartit","text":"<p>Daca vreti sa ne ajutati cu acest articol, ne puteti gasi pe github sau pe serverul nostru de discord</p> <p>Mai jos g\u0103si\u021bi resurse pe care le pute\u021bi citi p\u00e2n\u0103 atunci.</p>","tags":["grafuri","cuplaj"]},{"location":"dificil/cuplaj-maxim-pe-graf-bipartit/#introducere","title":"Introducere","text":"","tags":["grafuri","cuplaj"]},{"location":"dificil/cuplaj-maxim-pe-graf-bipartit/#problema-exemplu","title":"Problema exemplu","text":"","tags":["grafuri","cuplaj"]},{"location":"dificil/cuplaj-maxim-pe-graf-bipartit/#concluzii","title":"Concluzii","text":"","tags":["grafuri","cuplaj"]},{"location":"dificil/cuplaj-maxim-pe-graf-bipartit/#probleme-suplimentare","title":"Probleme suplimentare","text":"","tags":["grafuri","cuplaj"]},{"location":"dificil/cuplaj-maxim-pe-graf-bipartit/#resurse-suplimentare","title":"Resurse suplimentare","text":"","tags":["grafuri","cuplaj"]},{"location":"dificil/data-structures-dp/","title":"Programare dinamic\u0103 cu structuri de date","text":"","tags":["programare dinamica","optimizare","structuri de date"]},{"location":"dificil/data-structures-dp/#introducere","title":"Introducere","text":"<p>Programarea dinamic\u0103 \u0219i structurile de date reprezint\u0103 dou\u0103 dintre capitolele cele mai populare \u00een r\u00e2ndul elevilor, precum \u0219i \u00een r\u00e2ndul problemelor date la competi\u021bii, de multe ori acestea formeaz\u0103 o parte esen\u021bial\u0103 a seturilor de probleme \u0219i de cuno\u0219tin\u021be care departajeaz\u0103 cei mai buni concuren\u021bi la olimpiade \u0219i concursuri.</p> <p>\u00cen multe situa\u021bii, atunci c\u00e2nd ne g\u00e2ndim la solu\u021bii care folosesc dinamici \u0219i alte recuren\u021be similare, ajungem s\u0103 ne g\u00e2ndim la optimiz\u0103ri care ne duc cu g\u00e2ndul la probleme care se pot rezolva u\u0219or folosind structuri de date. Astfel, se d\u0103 na\u0219tere unui tip nou de probleme, dinamicile cu structuri de date.</p> <p>\u00cen acest articol, vom prezenta c\u00e2teva exemple de probleme, \u00eempreun\u0103 cu modul \u00een care aplic\u0103m structurile de date \u0219i utilitatea \u00eembin\u0103rii celor dou\u0103 seturi de cuno\u0219tin\u021be. Fie c\u0103 este vorba de structuri precum arbori de intervale, arbori indexa\u021bi binar, stive, cozi sau deques, aceste tipuri de dinamici sunt foarte utile \u0219i importante de \u0219tiut.</p>","tags":["programare dinamica","optimizare","structuri de date"]},{"location":"dificil/data-structures-dp/#problema-exemplu-projects-cses","title":"Problema exemplu - Projects CSES","text":"<p>\u00cen aceast\u0103 problem\u0103, trebuie s\u0103 alegem un num\u0103r de proiecte care nu se suprapun \u0219i ne aduc suma profiturilor maxim\u0103. Aceast\u0103 problem\u0103 reprezint\u0103 o dinamic\u0103 clasic\u0103, dar dat fiind faptul c\u0103 avem restric\u021bii foarte mari, nu putem s\u0103 o rezolv\u0103m folosind metodele obi\u0219nuite. Astfel, vom avea nevoie s\u0103 normaliz\u0103m mai \u00eent\u00e2i datele, iar mai apoi ne putem g\u00e2ndi la o recuren\u021b\u0103 \u00een care avem \\(dp[i]\\) ca fiind suma maxim\u0103 a profiturilor pentru un proiect care se termin\u0103 la al i-lea moment distinct de timp.</p> <p>\u00cen mod evident, pentru a calcula aceast\u0103 dinamic\u0103, vom avea nevoie de un maxim par\u021bial pentru primele \\(j\\) pozi\u021bii, unde \\(j\\) este pozi\u021bia cea mai mare din \u0219irul de momente de timp cu proprietatea c\u0103 acel moment de timp nu se suprapune cu intervalul pe care \u00eel alegem.</p> <p>Pentru a optimiza aceast\u0103 dinamic\u0103, vom putea folosi fie o structur\u0103 de date (arbore de intervale sau indexat binar), fie chiar un maxim par\u021bial care ar reduce \u0219i mai mult complexitatea solu\u021biei cerute.</p> <p>Mai jos pute\u021bi g\u0103si o solu\u021bie care ob\u021bine accepted.</p> <pre><code>#include &lt;algorithm&gt;\n#include &lt;iostream&gt;\n#include &lt;vector&gt;\n\nint n;\nlong long fen[400002], positions[400001];\n\nvoid add(int node, long long val) {\n    for (; node &lt;= n + n; node += (node &amp; (-node))) {\n        fen[node] = std::max(fen[node], val);\n    }\n}\n\nlong long compute(int node) {\n    long long ans = 0;\n    for (; node; node -= (node &amp; (-node))) {\n        ans = std::max(ans, fen[node]);\n    }\n    return ans;\n}\n\nstruct projects {\n    int L, R, val;\n};\n\nbool cmp(projects a, projects b) { return a.L &lt; b.L; }\n\nint bs(int x) {\n    int L = 1;\n    int R = n + n;\n    int ans = 0;\n    while (L &lt;= R) {\n        int mid = (L + R) / 2;\n        if (positions[mid] &lt;= x) {\n            ans = mid;\n            L = mid + 1;\n        } else {\n            R = mid - 1;\n        }\n    }\n    return ans;\n}\nint main() {\n    std::ios_base::sync_with_stdio(false);\n    std::cin.tie(NULL);\n\n    std::cin &gt;&gt; n;\n    std::vector&lt;projects&gt; v(n + 1);\n\n    for (int i = 1; i &lt;= n; i++) {\n        std::cin &gt;&gt; v[i].L &gt;&gt; v[i].R &gt;&gt; v[i].val;\n        positions[i * 2 - 1] = v[i].L;\n        positions[i * 2] = v[i].R;\n    }\n\n    std::sort(positions + 1, positions + n + n + 1);\n    std::sort(v.begin() + 1, v.begin() + n + 1, cmp);\n\n    long long ans = 0;\n\n    for (int i = 1; i &lt;= n; i++) {\n        int pa = bs(v[i].L - 1);\n        int pb = bs(v[i].R);\n\n        ans = std::max(ans, compute(pa) + v[i].val);\n        add(pb, compute(pa) + v[i].val);\n    }\n\n    std::cout &lt;&lt; ans &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["programare dinamica","optimizare","structuri de date"]},{"location":"dificil/data-structures-dp/#problema-subsequences-codeforces","title":"Problema Subsequences - Codeforces","text":"<p>\u00cen aceast\u0103 problem\u0103, trebuie s\u0103 num\u0103r\u0103m c\u00e2te sub\u0219iruri cresc\u0103toare cu lungimea \\(k+1\\) are \u0219irul dat, iar o proprietate important\u0103 este aceea c\u0103 valorile formeaz\u0103 o permutare a primelor \\(n\\) numere naturale.</p> <p>Deoarece lungimea c\u0103utat\u0103 este mic\u0103, ne putem g\u00e2ndi la a p\u0103stra o dinamic\u0103 pe dou\u0103 dimensiuni, care s\u0103 ne p\u0103streze num\u0103rul de sub\u0219iruri de lungime \\(i\\) care se termin\u0103 cu valoarea \\(j\\).</p> <p>Pentru a calcula aceast\u0103 dinamic\u0103, vom vrea s\u0103 \u0219tim pentru o pereche \\((i, j)\\) num\u0103rul de moduri corespunz\u0103toare tuturor perechilor eligibile de forma \\((i-1, x)\\) cu proprietatea c\u0103 \\(x &lt; j\\), iar \\(poz[x] &lt; poz[j]\\), unde \\(poz[x]\\) reprezint\u0103 unde apare \\(x\\) \u00een \u0219irul dat.</p> <p>Aceast\u0103 recuren\u021b\u0103 se poate din nou calcula relativ u\u0219or folosind arbori de intervale sau arbori indexa\u021bi binar, mai jos pute\u021bi g\u0103si o solu\u021bie care rezolv\u0103 problema.</p> <pre><code>#include &lt;iostream&gt;\n\nint n, k, v[100002];\nlong long dp[13][100002], segtree[13][400002];\n\nvoid update(int Number, int Node, int Left, int Right, int Position,\n            long long Value) {\n    if (Left == Right) {\n        segtree[Number][Node] = Value;\n        return;\n    }\n    int mid = (Left + Right) / 2;\n    if (Position &lt;= mid) {\n        update(Number, Node * 2, Left, mid, Position, Value);\n    } else {\n        update(Number, Node * 2 + 1, mid + 1, Right, Position, Value);\n    }\n    segtree[Number][Node] =\n        segtree[Number][Node * 2] + segtree[Number][Node * 2 + 1];\n}\nlong long query(int Number, int Node, int Left, int Right, int L, int R) {\n    if (L &lt;= Left &amp;&amp; Right &lt;= R) {\n        return segtree[Number][Node];\n    }\n    if (Right &lt; L || Left &gt; R) {\n        return 0;\n    }\n    int mid = (Left + Right) / 2;\n    return query(Number, Node * 2, Left, mid, L, R)\n         + query(Number, Node * 2 + 1, mid + 1, Right, L, R);\n}\nint main() {\n    std::ios_base::sync_with_stdio(false);\n    std::cin.tie(NULL);\n\n    std::cin &gt;&gt; n &gt;&gt; k;\n    k++;\n    for (int i = 1; i &lt;= n; ++i) {\n        std::cin &gt;&gt; v[i];\n    }\n    for (int i = 1; i &lt;= n; ++i) {\n        for (int j = 1; j &lt;= k; ++j) {\n            int Z = v[i];\n            if (j == 1) {\n                dp[1][Z] = 1;\n                update(1, 1, 1, n, Z, 1);\n            } else {\n                if (i != 1) {\n                    dp[j][Z] = query(j - 1, 1, 1, n, 1, Z - 1);\n                    update(j, 1, 1, n, Z, dp[j][Z]);\n                }\n            }\n        }\n    }\n    long long sum = 0;\n    for (int i = 1; i &lt;= n; ++i) {\n        sum += dp[k][i];\n    }\n    std::cout &lt;&lt; sum &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["programare dinamica","optimizare","structuri de date"]},{"location":"dificil/data-structures-dp/#problema-tulip-bouquet-iiot","title":"Problema Tulip Bouquet - IIOT","text":"<p>Pentru a rezolva aceast\u0103 problem\u0103, ne putem g\u00e2ndi \u00een primul r\u00e2nd la dinamica relativ simpl\u0103, dar \u00eenceat\u0103 \u00een \\(\\mathcal{O}(n \\cdot k^2)\\) care are tranzi\u021bii \u00een \\(\\mathcal{O}(k)\\).</p> <p>Obiectivul principal va fi s\u0103 optimiz\u0103m aceast\u0103 solu\u021bie, iar cel mai simplu mod de a face acest lucru este s\u0103 \u021binem o stiv\u0103 cu pozi\u021biile cele mai relevante pentru tranzi\u021biile noastre.</p> <p>Chiar dac\u0103 acest lucru nu va fi \u00eendeajuns, ne putem g\u00e2ndi un pas mai departe \u0219i s\u0103 \u021binem pentru fiecare pozi\u021bie relevant\u0103 din stiv\u0103 maximul tuturor pozi\u021biilor acoperite de acel interval, iar mai apoi pentru acele intervale, s\u0103 ne g\u00e2ndim la un maxim par\u021bial care s\u0103 ne permit\u0103 s\u0103 p\u0103str\u0103m toate valorile maxime rapid \u0219i eficient.</p> <p>C\u00e2nd unim dou\u0103 intervale, vom \u021bine valorile maxime din fiecare din ele \u0219i apoi vom combina noile valori pentru a putea insera din nou acel r\u0103spuns \u00een stiv\u0103.</p> <p>Mai jos pute\u021bi g\u0103si solu\u021bia de 100 de puncte, unde sunt mai multe detalii incluse.</p> <pre><code>#include &lt;iostream&gt;\n#include &lt;stack&gt;\n#include &lt;vector&gt;\n\nint main() {\n    std::ios_base::sync_with_stdio(false);\n    std::cin.tie(NULL);\n\n    int n, k;\n    std::cin &gt;&gt; n &gt;&gt; k;\n\n    std::vector&lt;long long&gt; v(n + 1);\n    for (int i = 1; i &lt;= n; i++) {\n        std::cin &gt;&gt; v[i];\n    }\n\n    std::vector&lt;std::vector&lt;long long&gt; &gt; dp(n + 1,\n                                            std::vector&lt;long long&gt;(k + 1));\n    for (int i = 1; i &lt;= n; i++) {\n        if (i == 1) {\n            dp[1][1] = v[1];\n        } else {\n            dp[i][1] = std::min(dp[i - 1][1], v[i]);\n        }\n    }\n\n    for (int i = 2; i &lt;= k; i++) {\n        // value, max total, maxprefix\n        std::stack&lt;std::pair&lt;int, std::pair&lt;long long, long long&gt; &gt; &gt; st;\n        for (int j = i; j &lt;= n; j++) {\n            std::pair&lt;int, std::pair&lt;long long, long long&gt; &gt; px = {\n                j, {dp[j - 1][i - 1], dp[j - 1][i - 1] + v[j]}\n            };\n            while (!st.empty() &amp;&amp; v[j] &lt;= v[st.top().first]) {\n                std::pair&lt;int, std::pair&lt;long long, long long&gt; &gt; py = st.top();\n                st.pop();\n                px.second.first = std::max(px.second.first, py.second.first);\n                if (!st.empty()) {\n                    px.second.second = std::max(st.top().second.second,\n                                                px.second.first + v[j]);\n                } else {\n                    px.second.second = px.second.first + v[j];\n                }\n            }\n            if (!st.empty()) {\n                px.second.second =\n                    std::max(st.top().second.second, px.second.first + v[j]);\n            }\n            st.push(px);\n            dp[j][i] = px.second.second;\n        }\n    }\n\n    std::cout &lt;&lt; dp[n][k] &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["programare dinamica","optimizare","structuri de date"]},{"location":"dificil/data-structures-dp/#problema-pictures-with-kittens-codeforces","title":"Problema Pictures with Kittens - Codeforces","text":"<p>Observatie</p> <p>Aceast\u0103 problem\u0103 se poate rezolva \u0219i folosind \u0219menul de la Aliens dar aici ne vom concentra pe solu\u021bia \u00een \\(\\mathcal{O}(n \\cdot k)\\).</p> <p>La o prim\u0103 citire este evident faptul c\u0103 putem g\u0103si repede o dinamic\u0103 de tipul \\(dp[i][j]\\) ca fiind suma maxim\u0103 dac\u0103 pentru primele \\(i\\) pozi\u021bii, am folosit \\(j\\) astfel de valori. Aceast\u0103 recuren\u021b\u0103 poate fi descris\u0103 ca fiind maximul ultimelor \\(k\\) pozi\u021bii de pe coloana precedent\u0103, \\(j-1\\), lucru ce poate fi optimizat \u00een modul cel mai eficient folosind o structur\u0103 de date de tip deque, a\u0219a cum se poate vedea \u0219i \u00een solu\u021bia prezentat\u0103 mai jos.</p> <pre><code>#include &lt;deque&gt;\n#include &lt;iostream&gt;\n\nlong long n, x, k, dp[5002][5002], v[5002];\nint main() {\n    std::ios_base::sync_with_stdio(false);\n    std::cin.tie(NULL);\n    std::cin &gt;&gt; n &gt;&gt; k &gt;&gt; x;\n    for (int i = 1; i &lt;= n; ++i) {\n        std::cin &gt;&gt; v[i];\n    }\n    for (int i = 1; i &lt;= k; ++i) {\n        dp[1][i] = v[i];\n    }\n    for (int i = 2; i &lt;= x; ++i) {\n        std::deque&lt;int&gt; d;\n        for (int j = 1; j &lt;= n; ++j) {\n            if (!d.empty() &amp;&amp; d.front() == j - k - 1) {\n                d.pop_front();\n            }\n            if (!d.empty()) {\n                dp[i][j] = dp[i - 1][d[0]] + v[j];\n            }\n            while (!d.empty() &amp;&amp; dp[i - 1][j] &gt; dp[i - 1][d.back()]) {\n                d.pop_back();\n            }\n            if (dp[i - 1][j] != 0) {\n                d.push_back(j);\n            }\n        }\n    }\n    long long maxans = 0;\n    for (int i = n - k + 1; i &lt;= n; ++i) {\n        if (dp[x][i]) {\n            maxans = std::max(maxans, dp[x][i]);\n        }\n    }\n    if (maxans == 0) {\n        std::cout &lt;&lt; -1;\n    } else {\n        std::cout &lt;&lt; maxans;\n    }\n    return 0;\n}\n</code></pre>","tags":["programare dinamica","optimizare","structuri de date"]},{"location":"dificil/data-structures-dp/#problema-interstellar-intervals-usaco-gold","title":"Problema Interstellar Intervals USACO Gold","text":"<p>Observa\u021bie</p> <p>Aceast\u0103 problem\u0103 are o solu\u021bie video f\u0103cut\u0103 de autor, care poate fi accesat\u0103 aici. \u00cen acest articol vom explica doar ideile principale din spatele solu\u021biei.</p> <p>Aceast\u0103 problem\u0103 duce foarte repede cu g\u00e2ndul la o dinamic\u0103 prin care putem num\u0103ra c\u00e2te \u0219iruri distincte exist\u0103 cu proprietatea c\u0103 toate restric\u021biile date p\u00e2n\u0103 la un punct sunt respectate. Deoarece avem dou\u0103 tipuri de culori \u00een practic\u0103 (albastru \u0219i alb, ro\u0219u este dedus din pozi\u021biile colorate \u00een albastru), ne putem g\u00e2ndi mai \u00eent\u00e2i s\u0103 p\u0103str\u0103m dou\u0103 dinamici, dup\u0103 cum urmeaz\u0103:</p> <ul> <li>dp[i] = nr de moduri de a umple primele \\(i\\) pozi\u021bii dac\u0103 pe pozi\u021bia \\(i\\) avem albastru</li> <li>dp2[i] = nr de moduri de a umple primele \\(i\\) pozi\u021bii dac\u0103 pe pozi\u021bia \\(i\\) avem alb</li> </ul> <p>Solu\u021bia \u00een \\(\\mathcal{O}(n^2)\\) este relativ simpl\u0103, pentru alb putem avea o tranzi\u021bie de la \\(i-1\\) la \\(i\\), iar pentru albastru, putem fixa un interval \u0219i verific\u0103m dac\u0103 \u00eel putem plasa conform restric\u021biilor date, ad\u0103ug\u00e2nd \\(dp[x-1]\\) dac\u0103 am putut plasa un interval \u00eentre \\(x\\) \u0219i \\(i\\).</p> <p>Pentru a optimiza solu\u021bia, putem observa pentru fiecare pozi\u021bie \\(i\\) c\u00e2t de mult ne putem duce la st\u00e2nga cu un interval din cauza restric\u021biilor colorate \u00een ro\u0219u, precum \u0219i c\u00e2t de mult ne putem duce la dreapta de la acea pozi\u021bie din cauza restric\u021biilor colorate cu albastru.</p> <p>Dup\u0103 calcularea acestor valori, putem \u021bine o structur\u0103 de date (\u00een solu\u021bia de mai jos, un AIB) care s\u0103 \u021bin\u0103 suma valorilor de pe un interval pentru a putea folosi restric\u021biile cu albastru \u00een avantajul nostru.</p> <p>\u00cen cele din urm\u0103, complexitatea devine \\(\\mathcal{O}(n \\log n)\\). Pute\u021bi citi solu\u021bia de mai jos pentru mai multe detalii, precum \u0219i s\u0103 viziona\u021bi videoul de mai sus.</p> <pre><code>#include &lt;iostream&gt;\n#include &lt;set&gt;\n#include &lt;vector&gt;\n\nusing namespace std;\n\nvector&lt;long long&gt; fenwickeven, fenwickodd;\n\nvoid add(int node, int val, int n, vector&lt;long long&gt; &amp;fenwick) {\n    for (; node &lt;= n; node += (node &amp; (-node))) {\n        fenwick[node] += val;\n    }\n}\n\nlong long compute(int node, vector&lt;long long&gt; &amp;fenwick) {\n    if (node &lt; 0) {\n        return 0;\n    }\n    long long ans = 0;\n    for (; node; node -= (node &amp; (-node))) {\n        ans += fenwick[node];\n    }\n    return ans % 1000000007;\n}\n\nvoid solve() {\n    int n;\n    cin &gt;&gt; n;\n\n    string st;\n    cin &gt;&gt; st;\n\n    int mod = 1000000007;\n\n    fenwickeven.resize(n + 1);\n    fenwickodd.resize(n + 1);\n\n    vector&lt;int&gt; cntR(n + 1), cntB(n + 1);\n    for (int i = 1; i &lt;= n; i++) {\n        cntR[i] = cntR[i - 1];\n        cntB[i] = cntB[i - 1];\n        if (st[i - 1] == 'B') {\n            cntB[i]++;\n        }\n        if (st[i - 1] == 'R') {\n            cntR[i]++;\n        }\n    }\n\n    vector&lt;long long&gt; dpW(n + 1), dp(n + 1);\n    vector&lt;long long&gt; dpW2(n + 1), dp2(n + 1);\n    dpW[0] = 1;\n    dpW2[0] = 1;\n    set&lt;pair&lt;int, int&gt; &gt; s;\n    for (int i = 1; i &lt;= n; i++) {\n        while (!s.empty() &amp;&amp; (*s.begin()).first == i) {\n            pair&lt;int, int&gt; val = *s.begin();\n            s.erase(val);\n            if (val.second % 2 == 0) {\n                add(val.second, -(dp2[val.second] + dpW2[val.second]), n,\n                    fenwickeven);\n            } else {\n                add(val.second, -(dp2[val.second] + dpW2[val.second]), n,\n                    fenwickodd);\n            }\n        }\n        if (i &gt;= 2) {\n            int L2 = 0;\n            int R2 = i / 2;\n            int ans2 = n;\n            while (L2 &lt;= R2) {\n                int mid = (L2 + R2) / 2;\n                if (cntR[i] - cntR[i - mid]) {\n                    ans2 = mid;\n                    R2 = mid - 1;\n                } else {\n                    L2 = mid + 1;\n                }\n            }\n            int trueend = i - ans2 * 2;\n            if (i % 2 == 0) {\n                dp2[i] = compute(i, fenwickeven) - compute(trueend, fenwickeven)\n                       + mod;\n            } else {\n                dp2[i] =\n                    compute(i, fenwickodd) - compute(trueend, fenwickodd) + mod;\n            }\n        }\n        if (i % 2 == 0) {\n            if (cntR[i] - cntR[i / 2] == 0 &amp;&amp; cntB[i / 2] == 0) {\n                dp2[i] += dpW2[0] + dp2[0];\n            }\n        }\n        if (st[i - 1] == 'X') {\n            dpW2[i] = dp2[i - 1] + dpW2[i - 1];\n        }\n        dp2[i] %= mod;\n        dpW2[i] %= mod;\n\n        int L = i + 1;\n        int R = n;\n        int ans = n + 1;\n        while (L &lt;= R) {\n            int mid = (L + R) / 2;\n            if (cntB[mid] - cntB[i]) {\n                ans = mid;\n                R = mid - 1;\n            } else {\n                L = mid + 1;\n            }\n        }\n        s.insert({ans + (ans - i), i});\n        if (i % 2 == 0) {\n            add(i, dp2[i] + dpW2[i], n, fenwickeven);\n        } else {\n            add(i, dp2[i] + dpW2[i], n, fenwickodd);\n        }\n    }\n\n    cout &lt;&lt; (dp2[n] + dpW2[n]) % mod &lt;&lt; '\\n';\n}\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n\n    int t = 1;\n    while (t--) {\n        solve();\n    }\n    return 0;\n}\n</code></pre>","tags":["programare dinamica","optimizare","structuri de date"]},{"location":"dificil/data-structures-dp/#concluzii","title":"Concluzii","text":"<p>Aceste probleme reprezint\u0103 o intersec\u021bie a dou\u0103 arii care sunt frecvent \u00eent\u00e2lnite la concursurile de algoritmic\u0103 \u0219i nu numai. Cunoa\u0219terea celor mai frecvent \u00eent\u00e2lnite observa\u021bii, \u00eempreun\u0103 cu \u00eensu\u0219irea tipurilor de implement\u0103ri face acest capitol important \u0219i util pentru studiul vostru individual.</p>","tags":["programare dinamica","optimizare","structuri de date"]},{"location":"dificil/data-structures-dp/#probleme-suplimentare","title":"Probleme suplimentare","text":"<ul> <li>IIOT 2024 Planning Excursions</li> <li>ONI 2010 Stalpi</li> <li>RCPC 2023 Yet Another Colored Tree Problem</li> <li>Lot 2024 Juniori Pokemoni</li> <li>Codeforces WI-FI</li> <li>Codeforces Pathwalks</li> <li>ONI 2015 Baraj Seniori s2c</li> <li>ONI 2005 Baraj Seniori Evantai</li> <li>Codeforces Yunlin's Subarray Queries (hard)</li> <li>Codeforces Culture Code</li> <li>JOI 2022 Railway Trip 2</li> <li>Lot 2008 Seniori turnuri</li> <li>Probleme cu dinamici si structuri de date de pe Codeforces</li> <li>Probleme cu dinamica si deque de pe kilonova</li> <li>Alte probleme similare de pe kilonova</li> </ul>","tags":["programare dinamica","optimizare","structuri de date"]},{"location":"dificil/data-structures-dp/#resurse-suplimentare","title":"Resurse suplimentare","text":"<ul> <li>Data Structures in Dynamic Programming Week - Codeforces</li> <li>Monotone Queue optimization - robert1003</li> </ul>","tags":["programare dinamica","optimizare","structuri de date"]},{"location":"dificil/digit-dp/","title":"Programare dinamic\u0103 pe cifre (digit DP)","text":"<p>\u00cen acest articol vom prezenta modul \u00een care aplic\u0103m tehnica program\u0103rii dinamice atunci c\u00e2nd vine vorba de a num\u0103ra c\u00e2te numere au o anumit\u0103 proprietate \u00eentr-un interval, sau care este al \\(k\\)-lea num\u0103r cu o proprietate anume, aceast\u0103 tehnic\u0103 fiind g\u0103sit\u0103 \u0219i sub numele de dinamic\u0103 pe cifre sau digit dp.</p> <p>De\u0219i \u00een cazul unora dintre problemele pe care le vom prezenta exist\u0103 solu\u021bii folosind diverse formule matematice sau combinatoriale, ne vom concentra pe modul general de implementare a acestor probleme, mod care va fi similar \u00een cazul majorit\u0103\u021bii acestor probleme.</p> <p>\u00cen cele ce urmeaz\u0103, vom prezenta c\u00e2teva probleme care se rezolv\u0103 cu aceast\u0103 tehnic\u0103, men\u021bion\u00e2nd aspecte de implementare \u0219i tehnici pentru rezolvarea problemelor. Spre deosebire de alte varia\u021bii ale program\u0103rii dinamice, problemele ce implic\u0103 digit dp vor avea aproape mereu acela\u0219i mod de a fi abordate.</p>","tags":["programare dinamica","cifre"]},{"location":"dificil/digit-dp/#counting-numbers-cses","title":"Counting Numbers - CSES","text":"<p>Pentru a afla c\u00e2te numere din intervalul \\([a, b]\\) respect\u0103 proprietatea c\u0103 oricare dou\u0103 cifre adiacente sunt diferite, vom introduce mai \u00eent\u00e2i o proprietate foarte important\u0103:</p> <p>Observa\u021bie</p> <p>\u00cen majoritatea problemelor cu digit dp, pentru a afla r\u0103spunsul \u00een intervalul \\([a, b]\\), vom sc\u0103dea din r\u0103spunsul pentru intervalul \\([1, b]\\), r\u0103spunsul pentru intervalul \\([1, a-1]\\), \u00eentr-o manier\u0103 similar\u0103 cu cea de la sumele par\u021biale.</p> <p>\u00cen cazul acestei probleme, vom defini \\(dp[i][j]\\) drept num\u0103rul de numere cu \\(i\\) cifre care au ultima cifr\u0103 \\(j\\). \u00cen mod evident, din \\(dp[i][j]\\) vom avea tranzi\u021biile spre \\(dp[i+1][x]\\), cu proprietatea c\u0103 \\(j \\neq x\\).</p> <p>Pentru a implementa aceast\u0103 solu\u021bie, avem dou\u0103 variante principale pentru a o implementa:</p>","tags":["programare dinamica","cifre"]},{"location":"dificil/digit-dp/#prima-varianta-calcularea-separat-pentru-numerele-cu-mai-putine-cifre-si-numerele-cu-acelasi-numar-de-cifre","title":"Prima variant\u0103 - Calcularea separat pentru numerele cu mai pu\u021bine cifre \u0219i numerele cu acela\u0219i num\u0103r de cifre","text":"<p>A\u0219a cum este sugerat \u0219i \u00een titlu, vom afla cifrele num\u0103rului, iar mai apoi vom avea de f\u0103cut doi pa\u0219i:</p> <ul> <li>Mai \u00eent\u00e2i, vom ini\u021bializa st\u0103rile pentru prima cifr\u0103 \u0219i vom extinde calculele   pentru numerele cu cel mult \\(x-1\\) cifre, unde \\(x\\) este num\u0103rul de cifre al   num\u0103rului dat.</li> <li>Apoi, vom fixa cifra care va reprezenta departajarea dintre numere \u0219i vom   calcula pentru fiecare interval generat separat. De exemplu, dac\u0103 \\(n = 90124\\),   aceste intervale ar fi \\([10000, 89999]\\), \\([90000, 90099]\\), \\([90100, 90119]\\),   \\([90120, 90123]\\), \\([90124, 90124]\\). Cu alte cuvinte, fiecare cifr\u0103 nenul\u0103 va   crea un nou interval, iar la final, vom calcula r\u0103spunsul \u0219i pentru num\u0103rul   dat.</li> </ul> <p>Aici pute\u021bi g\u0103si implementarea, care acoper\u0103 ambele p\u0103r\u021bi ale algoritmului descris.</p> <pre><code>#include &lt;algorithm&gt;\n#include &lt;iostream&gt;\n#include &lt;vector&gt;\n\nusing namespace std;\n\nlong long solve(long long n) {\n    if (n &lt;= 9) {\n        return n + 1;\n    }\n\n    vector&lt;int&gt; d;  // cifrele lui n\n    long long n2 = n;\n    while (n2) {\n        d.push_back(n2 % 10);\n        n2 /= 10;\n    }\n    reverse(d.begin(), d.end());\n\n    long long ans = 1;\n\n    vector&lt;vector&lt;long long&gt; &gt; dp(20, vector&lt;long long&gt;(10));\n\n    // lucram cu numerele cu mai putine cifre ca n\n\n    for (int i = 1; i &lt;= 9; ++i) {\n        dp[1][i] = 1;\n    }\n\n    for (int pos = 2; pos &lt; (int)d.size(); ++pos) {\n        for (int digit = 0; digit &lt;= 9; ++digit) {\n            for (int nxt = 0; nxt &lt;= 9; ++nxt) {\n                if (digit == nxt) {\n                    continue;\n                }\n                dp[pos][nxt] += dp[pos - 1][digit];\n            }\n        }\n    }\n\n    for (int pos = 1; pos &lt; (int)d.size(); ++pos) {\n        for (int digit = 0; digit &lt;= 9; ++digit) {\n            ans += dp[pos][digit];\n        }\n    }\n\n    for (int i = 0; i &lt; 20; i++) {\n        for (int j = 0; j &lt; 10; j++) {\n            dp[i][j] = 0;\n        }\n    }\n\n    // fixam prefixul pentru numerele cu acelasi numar de cifre ca n\n\n    bool ok = 1;\n\n    for (int prf = 0; prf &lt; (int)d.size(); ++prf) {\n        // daca proprietatea nu mai este respectata, oprim algoritmul\n        if (prf &gt;= 2 &amp;&amp; d[prf - 1] == d[prf - 2]) {\n            ok = 0;\n            break;\n        }\n\n        if (prf == 0) {\n            for (int dg = 1; dg &lt; d[prf]; ++dg) {\n                dp[prf + 1][dg] = 1;\n            }\n        } else {\n            for (int dg = 0; dg &lt; d[prf]; ++dg) {\n                if (dg != d[prf - 1]) {\n                    dp[prf + 1][dg] = 1;\n                }\n            }\n        }\n\n        for (int pos = 2; pos &lt;= (int)d.size(); ++pos) {\n            for (int digit = 0; digit &lt; 10; ++digit) {\n                for (int nxt = 0; nxt &lt; 10; ++nxt) {\n                    if (digit == nxt) {\n                        continue;\n                    }\n                    dp[pos][nxt] += dp[pos - 1][digit];\n                }\n            }\n        }\n\n        for (int digit = 0; digit &lt;= 9; ++digit) {\n            ans += dp[d.size()][digit];\n        }\n\n        for (int i = 0; i &lt; 20; i++) {\n            for (int j = 0; j &lt; 10; j++) {\n                dp[i][j] = 0;\n            }\n        }\n    }\n\n    // verificam proprietatea pentru n\n    if (d[(int)d.size() - 2] == d[(int)d.size() - 1]) {\n        ok = 0;\n    }\n\n    return ans + ok;\n}\n\nint main() {\n    long long a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; solve(b) - solve(a - 1) &lt;&lt; '\\n';  // [a, b] = [0, b] - [0, a-1]\n\n    return 0;\n}\n</code></pre>","tags":["programare dinamica","cifre"]},{"location":"dificil/digit-dp/#a-doua-varianta-folosirea-unei-dimensiuni-in-plus-pentru-a-simplifica-calculele","title":"A doua variant\u0103 - Folosirea unei dimensiuni \u00een plus pentru a simplifica calculele","text":"<p>Vom introduce o a treia dimensiune, care va \u021bine pentru prefixul de p\u00e2n\u0103 acum informa\u021bii cu privire la diferen\u021ba fa\u021b\u0103 de num\u0103rul de p\u00e2n\u0103 acum (mai mare, egal sau mai mic). Se poate observa c\u0103 implementarea va fi mult mai simpl\u0103, a\u0219a cum ve\u021bi putea vedea mai jos.</p> <p>Acum, dinamica noastr\u0103 va fi de forma \\(dp[i][j][x]\\), unde \\(x\\) va fi egal cu 0, 1 sau 2 \u00een func\u021bie de prefixul de p\u00e2n\u0103 acum \u0219i prefixul lui \\(n\\). La final, vom aduna st\u0103rile corespunz\u0103toare numerelor cu mai pu\u021bine cifre \u0219i cele cu acela\u0219i num\u0103r de cifre, dar cu prefix mai mic sau egal.</p> <pre><code>#include &lt;algorithm&gt;\n#include &lt;iostream&gt;\n#include &lt;vector&gt;\n\nusing namespace std;\n\n// comparam cifrele pentru a vedea starea pe care o actualizam\nint cmp(int a, int b) {\n    if (a &lt; b) {\n        return 0;\n    }\n    if (a &gt; b) {\n        return 1;\n    }\n    return 2;\n}\n\nlong long solve(long long n) {\n    if (n &lt;= 9) {\n        return n + 1;\n    }\n\n    vector&lt;int&gt; d;  // cifrele lui n\n    long long n2 = n;\n    while (n2) {\n        d.push_back(n2 % 10);\n        n2 /= 10;\n    }\n    reverse(d.begin(), d.end());\n\n    long long ans = 1;\n\n    vector&lt;vector&lt;vector&lt;long long&gt; &gt; &gt; dp(\n        20, vector&lt;vector&lt;long long&gt; &gt;(10, vector&lt;long long&gt;(3)));\n\n    for (int i = 1; i &lt; 10; i++) {\n        dp[1][i][cmp(i, d[0])] = 1;\n    }\n\n    for (int i = 1; i &lt; (int)d.size(); i++) {\n        for (int curr = 0; curr &lt; 10; curr++) {\n            for (int state = 0; state &lt; 3; state++) {\n                for (int nxt = 0; nxt &lt; 10; nxt++) {\n                    if (curr == nxt) {\n                        continue;\n                    }\n                    if (state == 2) {\n                        dp[i + 1][nxt][cmp(nxt, d[i])] += dp[i][curr][state];\n                    } else {\n                        dp[i + 1][nxt][state] += dp[i][curr][state];\n                    }\n                }\n            }\n        }\n    }\n\n    for (int i = 1; i &lt;= (int)d.size(); i++) {\n        for (int curr = 0; curr &lt; 10; curr++) {\n            for (int state = 0; state &lt; 3; state++) {\n                if (i &lt; (int)d.size() || state != 1) {\n                    ans = ans + dp[i][curr][state];\n                }\n            }\n        }\n    }\n\n    return ans;\n}\n\nint main() {\n    long long a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; solve(b) - solve(a - 1) &lt;&lt; '\\n';  // [a, b] = [0, b] - [0, a-1]\n\n    return 0;\n}\n</code></pre>","tags":["programare dinamica","cifre"]},{"location":"dificil/digit-dp/#probleme-de-tipul-al-k-lea-numar-cu-o-proprietate-data","title":"Probleme de tipul al \\(k\\)-lea num\u0103r cu o proprietate dat\u0103","text":"<p>Pentru a rezolva acest tip de probleme, de cele mai multe ori vom c\u0103uta binar r\u0103spunsul, calcul\u00e2nd la fiecare pas num\u0103rul de asemenea numere din intervalul \\([1, x]\\) cu proprietatea din enun\u021b. Un astfel de exemplu \u00eel putem reg\u0103si \u00een problema Bug Lot Juniori 2024, problem\u0103 care dup\u0103 unele simplific\u0103ri ajunge la o c\u0103utare binar\u0103 pe stilul celei men\u021bionate, aici pute\u021bi g\u0103si o surs\u0103 pe aceast\u0103 idee.  </p>","tags":["programare dinamica","cifre"]},{"location":"dificil/digit-dp/#probleme-suplimentare","title":"Probleme suplimentare","text":"<ul> <li>CSES Counting Numbers</li> <li>Bug Lot Juniori 2024</li> <li>AtCoder Digit Sum</li> <li>Perfect Number</li> <li>USACO Silver   Odometer</li> <li>SPOJ Digit Sum</li> <li>Codeforces Segment Sum</li> <li>Infoarena simpla</li> <li>Infoarena peluzanord</li> <li>ONI 2012 Baraj Juniori cifreco</li> <li>Codeforces Magic Numbers</li> <li>Probleme cu digit dp de pe kilonova</li> </ul>","tags":["programare dinamica","cifre"]},{"location":"dificil/digit-dp/#lectura-suplimentara","title":"Lectur\u0103 suplimentar\u0103","text":"<ul> <li>Introduction to Digit Dynamic Programming -   Youtube</li> <li>Digit DP - USACO Guide</li> <li>Digit DP - Codeforces (+ probleme)</li> </ul>","tags":["programare dinamica","cifre"]},{"location":"dificil/euler-tour/","title":"Structuri de date pe arbore (Euler tour)","text":"<p>Daca vreti sa ne ajutati cu acest articol, ne puteti gasi pe github sau pe serverul nostru de discord</p> <p>Mai jos g\u0103si\u021bi resurse pe care le pute\u021bi citi p\u00e2n\u0103 atunci.</p>","tags":["arbori","structuri de date"]},{"location":"dificil/euler-tour/#introducere","title":"Introducere","text":"","tags":["arbori","structuri de date"]},{"location":"dificil/euler-tour/#problema-exemplu","title":"Problema exemplu","text":"","tags":["arbori","structuri de date"]},{"location":"dificil/euler-tour/#concluzii","title":"Concluzii","text":"","tags":["arbori","structuri de date"]},{"location":"dificil/euler-tour/#probleme-suplimentare","title":"Probleme suplimentare","text":"","tags":["arbori","structuri de date"]},{"location":"dificil/euler-tour/#resurse-suplimentare","title":"Resurse suplimentare","text":"","tags":["arbori","structuri de date"]},{"location":"dificil/fenwick-tree/","title":"Arbori indexa\u021bi binar","text":"","tags":["structuri de date","arbori indexati binar","optimizare"]},{"location":"dificil/fenwick-tree/#ce-este-un-arbore-indexat-binar","title":"Ce este un arbore indexat binar?","text":"<p>Arborii indexa\u021bi binar (prescurta\u021bi de regul\u0103, AIB) sunt o structur\u0103 de date ce poate fi folosit\u0103 pentru a actualiza eficient valori \u0219i pentru a calcula sume par\u021biale \u00eentr-un tablou de valori ce poate avea una sau mai multe dimensiuni.</p> <p>De\u0219i arborii indexa\u021bi binar nu \u00eenlocuiesc vreo structur\u0103 de date propriu-zis\u0103 (tot ce poate face un AIB poate face \u0219i un arbore de intervale), marele lor avantaj este dat de faptul c\u0103 implementarea lor este foarte u\u0219oar\u0103 \u0219i constanta folosit\u0103 de ace\u0219tia este una mult redus\u0103 fa\u021b\u0103 de arborii de intervale, fiind de c\u00e2teva ori mai rapizi \u0219i consum\u00e2nd de \\(2-4\\) ori mai pu\u021bin\u0103 memorie, \u00een func\u021bie de implementare.</p>","tags":["structuri de date","arbori indexati binar","optimizare"]},{"location":"dificil/fenwick-tree/#cum-functioneaza-un-arbore-indexat-binar","title":"Cum func\u021bioneaz\u0103 un Arbore Indexat Binar?","text":"<p>Pentru a putea folosi un AIB, trebuie s\u0103 folosim un vector, unde aib[i] reprezint\u0103 valoarea pe care o stoc\u0103m pe pozi\u021bia \\(i\\). A\u0219a cum \u00eei zice \u0219i numele, fiecare pozi\u021bie \\(i\\) va \u021bine rezultatele pe un interval egal cu \\(2^{zeroes}\\), unde \\(zeroes\\) reprezint\u0103 num\u0103rul de zerouri de la finalul reprezent\u0103rii binare a lui \\(i\\). Aceast\u0103 expresie ne ajut\u0103 s\u0103 adun\u0103m sau s\u0103 sc\u0103dem valoarea celui mai nesemnificativ bit de 1 din \\(i\\) pentru a putea opera actualiz\u0103rile \u0219i interog\u0103rile.</p> <p>Motivul pentru care se folose\u0219te reprezentarea binar\u0103 a nodurilor este acela c\u0103 \u00een acest mod, se garanteaz\u0103 complexitatea logaritmic\u0103 a opera\u021biilor men\u021bionate mai sus (update \u0219i query), precum \u0219i \u00een practic\u0103 o constant\u0103 foarte bun\u0103 datorit\u0103 num\u0103rului redus de bi\u021bi pe care \u00eel au numerele \u00een binar.</p> <p>Observa\u021bie</p> <p>Arborii indexa\u021bi binar sunt mereu indexa\u021bi de la 1, deoarece altfel, am avea de-a face cu 0, care nu are un bit nesemnificativ egal cu 1.</p>","tags":["structuri de date","arbori indexati binar","optimizare"]},{"location":"dificil/fenwick-tree/#cum-functioneaza-operatia-de-update","title":"Cum func\u021bioneaz\u0103 opera\u021bia de update?","text":"<p>S\u0103 presupunem c\u0103 avem un AIB cu 16 noduri \u0219i vrem s\u0103 actualiz\u0103m valoarea de la pozi\u021bia 3. Pentru a putea face asta, vom rula urm\u0103torul algoritm, c\u00e2t timp valoarea curent\u0103 nu e mai mare dec\u00e2t num\u0103rul de noduri:</p> <ul> <li>actualiz\u0103m valoarea curent\u0103</li> <li>afl\u0103m pozi\u021bia celui mai nesemnificativ bit, s\u0103 o not\u0103m \\(lsb\\)</li> <li>adun\u0103m \\(2^{lsb}\\) la valoarea curent\u0103</li> </ul> <p>De exemplu, pentru nodul 3 vom trece prin urm\u0103toarele pozi\u021bii, dup\u0103 cum se poate vedea pe desen:</p> <ul> <li>3 - pozi\u021bia celui mai nesemnificativ bit este 0, adun\u0103m \\(2^0 = 1\\) la   pozi\u021bie</li> <li>4 - pozi\u021bia celui mai nesemnificativ bit este 2, adun\u0103m \\(2^2 = 4\\) la   pozi\u021bie</li> <li>8 - pozi\u021bia celui mai nesemnificativ bit este 3, adun\u0103m \\(2^3 = 8\\) la   pozi\u021bie</li> <li>16 - pozi\u021bia celui mai nesemnificativ bit este 3, adun\u0103m \\(2^4 = 16\\) la   pozi\u021bie, algoritmul ia sf\u00e2r\u0219it.</li> </ul> <p></p> <p>Complexitatea opera\u021biei de update este \\(\\mathcal{O}(\\log n)\\), unde \\(n\\) este dimensiunea arborelui indexat binar.</p>","tags":["structuri de date","arbori indexati binar","optimizare"]},{"location":"dificil/fenwick-tree/#cum-functioneaza-operatia-de-query","title":"Cum func\u021bioneaz\u0103 opera\u021bia de query?","text":"<p>\u00cen mod similar fa\u021b\u0103 de opera\u021bia de update, opera\u021bia de query va rula folosindu-se de reprezentarea binar\u0103 a pozi\u021biei de la care vrem s\u0103 facem query-ul. Este de remarcat faptul c\u0103 dac\u0103 vrem s\u0103 rul\u0103m un query pe intervalul \\([L, R]\\), va trebui s\u0103 sc\u0103dem din rezultatul ob\u021binut p\u00e2n\u0103 la pozi\u021bia \\(R\\), rezultatul ob\u021binut la pozi\u021bia \\(L - 1\\), din cauza faptului c\u0103 informa\u021bia stocat\u0103 \u00een nodurile din AIB nu este suficient de complex\u0103 pentru a putea fi ob\u021binut\u0103 cu o singur\u0103 rutin\u0103 de interogare. Totodat\u0103, aceast\u0103 abordare este similar\u0103 cu cea de la sumele par\u021biale, unde ob\u021binerea lor presupune din nou dou\u0103 calcule, \u00een loc de unul singur.</p> <p>Mai jos prezint algoritmul general \u0219i un exemplu de aplicare al acestuia, pentru valoarea 13.</p> <ul> <li>adun\u0103m la rezultat valoarea curent\u0103</li> <li>afl\u0103m pozi\u021bia celui mai nesemnificativ bit, s\u0103 o not\u0103m \\(lsb\\)</li> <li>sc\u0103dem \\(2^{lsb}\\) din valoarea curent\u0103.</li> </ul> <p>De exemplu, pentru nodul 13 vom trece prin urm\u0103toarele pozi\u021bii, dup\u0103 cum se poate vedea pe desen:</p> <ul> <li>13 - pozi\u021bia celui mai nesemnificativ bit este 0, sc\u0103dem \\(2^0 = 1\\) din   pozi\u021bie</li> <li>12 - pozi\u021bia celui mai nesemnificativ bit este 2, sc\u0103dem \\(2^2 = 4\\) din   pozi\u021bie</li> <li>8 - pozi\u021bia celui mai nesemnificativ bit este 3, sc\u0103dem \\(2^3 = 8\\) din   pozi\u021bie, am ajuns la 0, deci calculul ia sf\u00e2r\u0219it.</li> </ul> <p></p> <p>Complexitatea opera\u021biei de query este \\(\\mathcal{O}(\\log n)\\), unde \\(n\\) este dimensiunea arborelui indexat binar.</p>","tags":["structuri de date","arbori indexati binar","optimizare"]},{"location":"dificil/fenwick-tree/#implementarea-in-c","title":"Implementarea \u00een C++","text":"<p>Un mare avantaj al arborilor indexa\u021bi binar este acela c\u0103 implementarea lor este una foarte scurt\u0103, fiind necesare doar c\u00e2teva r\u00e2nduri pentru a putea fi implementa\u021bi.</p> <pre><code>long long fenwick[100002];\nvoid update(int node, int value) {\n    for (int i = node; i &lt;= n; i += (i &amp; (-i))) {\n        fenwick[i] += value;\n    }\n}\nlong long compute(int node) {\n    long long ans = 0;\n    for (int i = node; i &gt; 0; i -= (i &amp; (-i))) {\n        ans += fenwick[i];\n    }\n\n    return ans;\n}\n</code></pre>","tags":["structuri de date","arbori indexati binar","optimizare"]},{"location":"dificil/fenwick-tree/#probleme-rezolvate","title":"Probleme rezolvate","text":"","tags":["structuri de date","arbori indexati binar","optimizare"]},{"location":"dificil/fenwick-tree/#problema-inv","title":"Problema inv","text":"<p>Se d\u0103 un \u015fir \\(S\\) de lungime \\(n\\) cu numere \u00eentregi. Numim o inversiune o pereche de indici \\((i, j)\\) astfel \u00eenc\u00e2t \\(1 \\leq i &lt; j \\leq n\\) \u015fi \\(S_i &gt; S_j\\). S\u0103 se determine c\u00e2te inversiuni sunt \u00een \u015firul dat.</p> <p>Pentru a rezolva aceast\u0103 problem\u0103, putem folosi orice structur\u0103 de date ce ne permite s\u0103 actualiz\u0103m valoarea unei pozi\u021bii \u0219i s\u0103 rul\u0103m interog\u0103ri de sum\u0103 pe un interval. \u00cen cazul problemei noastre, vom vrea pentru fiecare valoare din \u0219ir s\u0103 afl\u0103m num\u0103rul de valori de la st\u00e2nga care sunt mai mari dec\u00e2t valoarea curent\u0103, lucru ce se poate realiza afl\u00e2nd pentru valoarea curent\u0103, pozi\u021bia ei \u00een \u0219irul sortat \u0219i proces\u00e2nd un query de sum\u0103 pe intervalul \\([poz + 1, n]\\), unde \\(poz\\) este pozi\u021bia \u00een vectorul sortat a celei mai din dreapta valori din \u0219ir egal\u0103 cu valoarea de la pozi\u021bia curent\u0103.</p> <p>Deoarece valorile din \u0219ir sunt destul de mari, trebuie s\u0103 normaliz\u0103m datele, iar mai apoi s\u0103 folosim AIB pentru a rezolva problema.</p> <pre><code>#include &lt;algorithm&gt;\n#include &lt;fstream&gt;\n#include &lt;vector&gt;\n\nusing namespace std;\n\nvector&lt;int&gt; fenwick, vals, sorted, pos;\n\nbool cmp(int a, int b) { return vals[a] &lt; vals[b]; }\n\nvoid add(int n, int node, int val) {\n    for (; node &lt;= n; node += (node &amp; (-node))) {\n        fenwick[node] += val;\n    }\n}\n\nint compute(int node) {\n    int ans = 0;\n    for (; node; node -= (node &amp; (-node))) {\n        ans += fenwick[node];\n    }\n    return ans;\n}\n\nint main() {\n    ifstream cin(\"inv.in\");\n    ofstream cout(\"inv.out\");\n\n    int n;\n    cin &gt;&gt; n;\n\n    fenwick.resize(n + 1);\n    vals.resize(n + 1);\n    sorted.resize(n + 1);\n    pos.resize(n + 1);\n\n    for (int i = 1; i &lt;= n; i++) {\n        cin &gt;&gt; vals[i];\n        sorted[i] = i;\n    }\n\n    sort(sorted.begin() + 1, sorted.begin() + n + 1, cmp);\n    int cnt = 0;\n    for (int i = 1; i &lt;= n; i++) {\n        if (i == 1 || vals[sorted[i]] &gt; vals[sorted[i - 1]]) {\n            cnt++;\n        }\n        pos[sorted[i]] = cnt;\n    }\n\n    long long ans = 0;\n    for (int i = 1; i &lt;= n; i++) {\n        ans += i - compute(pos[i]) - 1;\n        add(n, pos[i], 1);\n    }\n\n    cout &lt;&lt; ans % 9917 &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["structuri de date","arbori indexati binar","optimizare"]},{"location":"dificil/fenwick-tree/#problema-goal-statistics","title":"Problema Goal Statistics","text":"<p>Se dau \\(q\\) opera\u021bii, opera\u021bia de update adaug\u0103 o valoare egal\u0103 cu \\(k\\), iar opera\u021bia de query cere suma celor mai mici \\(p\\) valori din \u0219ir.</p> <p>Aceast\u0103 problem\u0103 este din nou un exemplu clasic de folosire a structurilor de date, iar \u00eenc\u0103 o dat\u0103, arborii indexa\u021bi binari se dovedesc a fi solu\u021bia potrivit\u0103 pentru aceast\u0103 problem\u0103, datorit\u0103 vitezei de implementare \u0219i a u\u0219urin\u021bei de folosire. Pentru a afla suma celor mai mici \\(p\\) valori din \u0219ir, vom c\u0103uta binar r\u0103spunsul, folosind o metod\u0103 similar\u0103 cu cea descris\u0103 mai sus. De\u0219i c\u0103utarea binar\u0103 naiv\u0103 \u00een \\(\\mathcal{O}(\\log^2 n)\\) ia punctajul maxim, se recomand\u0103 c\u0103utarea binar\u0103 \u00een \\(\\mathcal{O}(\\log n)\\).</p> <p>Pentru a c\u0103uta binar \u00een AIB \u00een \\(\\mathcal{O}(\\log n)\\), vom folosi o tehnic\u0103 similar\u0103 cu c\u0103utarea binar\u0103 pe bi\u021bi, verific\u00e2nd dac\u0103 ad\u0103ugarea a \\(2^k\\) pozi\u021bii \u00een AIB ne-ar duce peste valoarea cerut\u0103 sau nu.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nconst int max_val = 1000000;\nint q;\n\nint fen[max_val + 2];\nlong long sum[max_val + 2];\n\nvoid upd(int pos) {\n    int init = pos;\n    for (; pos &lt;= max_val; pos += (pos &amp; (-pos))) {\n        fen[pos]++;\n        sum[pos] += init;\n    }\n}\n\nlong long solve(int k) {\n    int stp = (1 &lt;&lt; 19);\n    int poz = 0;\n    long long sol = 0;\n    while (stp &gt; 0) {\n        if (poz + stp &lt;= max_val &amp;&amp; fen[poz + stp] &lt; k) {\n            k -= fen[poz + stp], sol += sum[poz + stp], poz += stp;\n        }\n        stp &gt;&gt;= 1;\n    }\n    return sol + 1LL * k * (poz + 1);\n}\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n\n    cin &gt;&gt; q;\n    for (; q; --q) {\n        int type, k;\n        cin &gt;&gt; type &gt;&gt; k;\n        if (type == 1) {\n            upd(k);\n        } else {\n            cout &lt;&lt; solve(k) &lt;&lt; '\\n';\n        }\n    }\n    return 0;\n}\n</code></pre>","tags":["structuri de date","arbori indexati binar","optimizare"]},{"location":"dificil/fenwick-tree/#probleme-suplimentare","title":"Probleme suplimentare","text":"<ul> <li>infoarena aib</li> <li>Kilonova Fenwick Tree</li> <li>IIOT Goal Statistics</li> <li>Inversions - Codeforces   Edu</li> <li>Inversions 2 - Codeforces   Edu</li> <li>K-th one - Codeforces   Edu</li> <li>Segment Tree for the Sum - Codeforces   Edu</li> <li>infoarena inv</li> </ul>","tags":["structuri de date","arbori indexati binar","optimizare"]},{"location":"dificil/fenwick-tree/#resurse-suplimentare","title":"Resurse suplimentare","text":"<ul> <li>Fenwick Tree - CP   Algorithms</li> <li>Binary Indexed Trees - Stefan   Dascalescu</li> <li>Understanding Fenwick Trees -   Codeforces</li> <li>Binary Indexed Trees - USACO   Guide</li> <li>A simple introduction to Fenwick Trees - robert1003</li> </ul>","tags":["structuri de date","arbori indexati binar","optimizare"]},{"location":"dificil/graph-dp/","title":"Programare dinamic\u0103 pe grafuri","text":"<p>Daca vreti sa ne ajutati cu acest articol, ne puteti gasi pe github sau pe serverul nostru de discord</p> <p>Mai jos g\u0103si\u021bi resurse pe care le pute\u021bi citi p\u00e2n\u0103 atunci.</p>","tags":["programare dinamica","grafuri"]},{"location":"dificil/graph-dp/#introducere","title":"Introducere","text":"","tags":["programare dinamica","grafuri"]},{"location":"dificil/graph-dp/#problema-exemplu","title":"Problema exemplu","text":"","tags":["programare dinamica","grafuri"]},{"location":"dificil/graph-dp/#concluzii","title":"Concluzii","text":"","tags":["programare dinamica","grafuri"]},{"location":"dificil/graph-dp/#probleme-suplimentare","title":"Probleme suplimentare","text":"","tags":["programare dinamica","grafuri"]},{"location":"dificil/graph-dp/#resurse-suplimentare","title":"Resurse suplimentare","text":"","tags":["programare dinamica","grafuri"]},{"location":"dificil/interactive/","title":"Probleme interactive","text":"","tags":["interactive"]},{"location":"dificil/interactive/#introducere","title":"Introducere","text":"<p>La concursurile de informatic\u0103, pe l\u00e2ng\u0103 problemele obi\u0219nuite \u00een care trebuie s\u0103 citi\u021bi inputul (sau eventual \u00eel primi\u021bi ca parametri \u00eentr-o func\u021bie) \u0219i trebuie s\u0103 genera\u021bi outputul (denumite de regul\u0103 probleme batch), mai exist\u0103 \u0219i alte tipuri de probleme, pe care le voi numi \u00een cele ce urmeaz\u0103 probleme speciale.</p> <p>Aceste probleme sunt preferate de autori deoarece de multe ori implic\u0103 idei non standard care ajung s\u0103 se aplice pentru a g\u0103si solu\u021biile, iar folosirea unor \u0219abloane tipice altor categorii de probleme este mult mai dificil\u0103.</p> <p>Acestea sunt de 3 tipuri:</p> <ul> <li>Probleme interactive: Probleme \u00een care vi se d\u0103 un num\u0103r limitat de query-uri \u0219i trebuie fie s\u0103 g\u0103si\u021bi o anumit\u0103 valoare/\u0219ir, fie s\u0103 g\u0103si\u021bi r\u0103spunsul la o cerin\u021b\u0103 mai complex\u0103, r\u0103spunsurile la query-uri fiind date de un alt program creat de comisie.</li> <li>Probleme output-only: Probleme \u00een care se dau toate datele posibile de intrare \u0219i trebuie generate r\u0103spunsuri c\u00e2t mai apropiate de r\u0103spunsul optim, de regul\u0103 inspirate din probleme NP-complete.</li> <li>Probleme de tip two-step (communication tasks): Probleme \u00een care trebuie scrise dou\u0103 programe care pot comunica de regul\u0103 \u00eentre ele doar printr-un output codificat care trebuie generat de primul program pentru a putea ajuta cel de-al doilea program s\u0103 rezolve problema.</li> </ul> <p>\u00cen acest articol, vom discuta despre problemele interactive, deoarece acestea sunt problemele speciale care apar cel mai des \u00een competi\u021biile de programare, mai ales \u00een fazele superioare \u0219i \u00een cadrul etapelor mai dificile.</p>","tags":["interactive"]},{"location":"dificil/interactive/#tipuri-de-probleme-interactive","title":"Tipuri de probleme interactive","text":"<p>C\u00e2nd vine vorba de problemele interactive, exist\u0103 foarte multe tipuri de probleme ale c\u0103ror solu\u021bii se folosesc de tot felul de observa\u021bii \u00een ceea ce prive\u0219te optimizarea num\u0103rului de \u00eentreb\u0103ri, precum \u0219i de tehnici care \u021bin de diversele rela\u021bii \u0219i defini\u021bii care sunt prezente \u00een probleme.</p> <p>Exist\u0103 trei tipuri de probleme interactive:</p> <ul> <li>Probleme \u00een care ni se zice direct complexitatea cerut\u0103 (de exemplu, IOI 2014 Rail).</li> <li>Probleme \u00een care doar \u0219tim num\u0103rul maxim de \u00eentreb\u0103ri ce pot fi folosite (de exemplu, IOI 2013 Cave).</li> <li>Probleme care au o limit\u0103 ascuns\u0103 a num\u0103rului de \u00eentreb\u0103ri (de exemplu, IOI 2015 Scales).</li> </ul> <p>Deoarece putem deduce \u00een principiu complexitatea cerut\u0103 de problem\u0103, de cele mai multe ori nu are sens s\u0103 \u00eencerc\u0103m s\u0103 ob\u021binem o complexitate mai bun\u0103 dec\u00e2t cea de care avem nevoie (dac\u0103 num\u0103rul de \u00eentreb\u0103ri este \\(n^2\\), nu are deloc sens s\u0103 ob\u021binem \\(\\log n\\) query-uri).</p>","tags":["interactive"]},{"location":"dificil/interactive/#problema-exemplu-guess-the-number","title":"Problema exemplu - Guess the Number","text":"<p>Aceasta este o problem\u0103 introductiv\u0103 pentru acest tip de probleme. De cele mai multe ori, vi se dau instruc\u021biunile \u00een enun\u021b legat de modul \u00een care interac\u021biona\u021bi cu platforma. De cele mai multe ori, trebuie s\u0103 fi\u021bi aten\u021bi s\u0103 nu folosi\u021bi liniile de cod care implic\u0103 fast input <code>ios_base::sync_with_stdio(false); cin.tie(NULL);</code> \u0219i s\u0103 folosi\u021bi flush la finalul fiec\u0103rei linii pe care o afi\u0219a\u021bi (pute\u021bi folosi endl pentru asta).</p> <p>Pentru a rezolva problema dat\u0103, trebuie s\u0103 simul\u0103m c\u0103utarea binar\u0103 folosind protocolul de interac\u021biune. \u00cen func\u021bie de r\u0103spunsurile primite de programul vostru, ve\u021bi accesa jum\u0103tatea din st\u00e2nga sau jum\u0103tatea din dreapta. Trebuie s\u0103 fim aten\u021bi la cazurile care sunt impuse de tipul r\u0103spunsurilor date de enun\u021b.</p> <pre><code>#include &lt;iostream&gt;\n\nint main() {\n    int low = 1;\n    int high = 1000000;\n    int tgt = 0;\n    for (int pw = 19; pw &gt;= 0; pw--) {\n        int guess = low + (1 &lt;&lt; pw);\n        if (guess &gt; 1000000) {\n            continue;\n        }\n        std::cout &lt;&lt; guess &lt;&lt; std::endl;  // interogam numarul curent\n        std::string s;\n        std::cin &gt;&gt; s;\n        if (s[0] == '&lt;') {  // daca este mai mic, stim valoarea maxima\n            high = guess - 1;\n        } else {  // altfel, stim valoarea minima\n            low = guess;\n        }\n    }\n    std::cout &lt;&lt; \"! \" &lt;&lt; low &lt;&lt; std::endl;\n    return 0;\n}\n</code></pre>","tags":["interactive"]},{"location":"dificil/interactive/#sfaturi-practice-pentru-problemele-interactive","title":"Sfaturi practice pentru problemele interactive","text":"<p>Observa\u021bie</p> <p>\u00cen cele ce urmeaz\u0103, voi folosi exemple din acest material, lu\u00e2nd de acolo cele mai esen\u021biale sfaturi \u0219i problemele la care se reg\u0103sesc. O mare parte dintre solu\u021biile problemelor men\u021bionate sunt explicate \u00een detaliu \u00een acel document.</p> <ul> <li>Exist\u0103 foarte multe probleme interactive care se bazeaz\u0103 pe c\u0103ut\u0103ri binare sau ternare, exemplele cele mai simple fiind bazate pe aceste tehnici, dar se pot reg\u0103si \u0219i exemple mai complicate care \u021bin de diverse optimiz\u0103ri sau de tehnici conexe precum divide et impera, continuitatea func\u021biilor (c\u0103utarea ternar\u0103 poate fi folosit\u0103 pentru aceste probleme).</li> <li>Nu rata\u021bi rela\u021biile u\u0219or de dedus - De exemplu, pentru problema Chocolate Bunny, o solu\u021bie u\u0219or de dedus este aceea de a afla mai \u00eent\u00e2i maximul, iar mai apoi s\u0103 afl\u0103m valorile pe r\u00e2nd \u00een \\(3 \\cdot (n-1)\\) query-uri. Totu\u0219i, dat fiind c\u0103 determin\u0103m pe r\u00e2nd valorile, putem reduce num\u0103rul de \u00eentreb\u0103ri la \\(2 \\cdot (n-1)\\) query-uri, ceea ce e \u00eendeajuns de bine.</li> <li>\u00cencerca\u021bi s\u0103 g\u0103si\u021bi diferite valori extreme - Putem \u00eemperechea diferite tipuri de obiecte folosind stive, cum se poate face la aceast\u0103 problem\u0103 dat\u0103 la un AtCoder Regular Contest. O alt\u0103 problem\u0103 \u00een care putem \u00eemperechea diferite tipuri de obiecte este IOI 2015 Towns.</li> <li>C\u00e2teodat\u0103, g\u0103sirea unui singur obiect e important\u0103, deoarece \u00een unele probleme interactive, putem elimina pe r\u00e2nd obiecte p\u00e2n\u0103 ce ajungem la r\u0103spuns.</li> <li>Rezolvarea cazurilor particulare poate ajuta la o solu\u021bie general\u0103</li> <li>Probleme \u00een care ne folosim de reprezent\u0103rile binare pentru a reduce num\u0103rul de query-uri. Fie c\u0103 e vorba de opera\u021bii pe bi\u021bi sau de \u00eemp\u0103r\u021biri precum meet in the middle sau aflarea anumitor submul\u021bimi, aceste tipuri de probleme se pot transpune cu u\u0219urin\u021b\u0103 \u00een probleme interactive.</li> <li>Structurile de date pot ap\u0103rea \u0219i ele drept unealt\u0103 esen\u021bial\u0103 pentru g\u0103sirea solu\u021biilor la aceste tipuri de probleme, a\u0219a cum putem observa \u00een problema Minimum and Maximum sau dac\u0103 vorbim de un exemplu mai dificil, Ehab and the Big Finale.</li> <li>De ce nu, putem vorbi \u0219i de grafuri mai generale, de multe ori arborii DFS sau arborii par\u021biali fiind foarte importan\u021bi pentru deducerea r\u0103spunsurilor cerute de probleme.</li> <li>Nu \u00een ultimul r\u00e2nd, \u0219i abord\u0103rile probabilistice se g\u0103sesc \u00een aceste tipuri de probleme, mai ales pe Codeforces, exemple put\u00e2nd fi g\u0103site acolo \u00een sec\u021biunile mai dificile ale concursurilor de div2 \u0219i div1.</li> </ul>","tags":["interactive"]},{"location":"dificil/interactive/#problema-rezolvata-word-by-word-iiot-2024-25","title":"Problem\u0103 rezolvat\u0103 - Word by Word - IIOT 2024-25","text":"<p>Primul pas \u00een g\u0103sirea cuv\u00e2ntului ascuns este determinarea literelor care \u00eel compun. Av\u00e2nd 26 de litere, \u00eemp\u0103r\u021bim alfabetul \u00een blocuri de c\u00e2te 5 caractere. Putem verifica dac\u0103 literele a, b, c, d sau e apar \u00een cuv\u00e2ntul ascuns prin interogarea cuv\u00e2ntului \"abcde\". Apoi, facem interog\u0103ri pentru \"fghij\", \"klmno\" \u0219i a\u0219a mai departe. Observ\u0103m c\u0103 5 interog\u0103ri sunt suficiente, deoarece putem omite interogarea pentru \"z\", fiind singura liter\u0103 din ultimul bloc.</p> <p>Urm\u0103torul pas este determinarea pozi\u021biei exacte a fiec\u0103rei litere. S\u0103 presupunem c\u0103 literele identificate sunt a, b, c, d \u0219i e. Putem interoga \"aaaaa\", \"bbbbb\", \"ccccc\" \u0219i \"ddddd\" pentru a afla pozi\u021biile exacte ale acestor patru litere. Ultima pozi\u021bie r\u0103mas\u0103 trebuie s\u0103 con\u021bin\u0103 litera e, permi\u021b\u00e2ndu-ne astfel s\u0103 determin\u0103m cuv\u00e2ntul ascuns \u00een cel mult 5 + 4 = 9 interog\u0103ri.</p> <p>Aceea\u0219i tehnic\u0103 func\u021bioneaz\u0103 \u0219i \u00een cazul \u00een care cuv\u00e2ntul con\u021bine mai pu\u021bin de cinci litere distincte.</p> <pre><code>#include &lt;string&gt;\n\n#include \"word-by-word.h\"\n\nchar lit[5];\n\nstd::string solve() {\n    int i, j, n, m;\n    std::string a, b, ans = \"?????\";\n    char ch;\n    n = 0;\n    for (i = 0; i &lt; 5; i++) {\n        a = \"\";\n        for (j = 0; j &lt; 5; j++) {\n            ch = 5 * i + j + 'a';\n            a += ch;\n        }\n        b = guess(a);\n        for (j = 0; j &lt; 5; j++) {\n            if (b[j] != 'W') {\n                ch = 5 * i + j + 'a';\n                lit[n++] = ch;\n            }\n        }\n    }\n    if (n &lt; 5) {\n        lit[n++] = 'z';\n    }\n    m = std::min(n, 4);\n    for (i = 0; i &lt; m; i++) {\n        a = \"\";\n        for (j = 0; j &lt; 5; j++) {\n            a += lit[i];\n        }\n        b = guess(a);\n        for (j = 0; j &lt; 5; j++) {\n            if (b[j] == 'G') {\n                ans[j] = lit[i];\n            }\n        }\n    }\n    if (n == 5) {\n        for (i = 0; i &lt; 5; i++) {\n            if (ans[i] == '?') {\n                ans[i] = lit[4];\n            }\n        }\n    }\n    return ans;\n}\n</code></pre>","tags":["interactive"]},{"location":"dificil/interactive/#concluzii","title":"Concluzii","text":"<p>Problemele interactive reprezint\u0103 un tip de probleme care apar tot mai des la concursurile de informatic\u0103 rom\u00e2ne\u0219ti, chiar \u0219i la nivelul olimpiadelor interna\u021bionale de juniori, ceea ce le face tot mai utile \u0219i importante pentru studiul individual. La fel ca la problemele ad-hoc, aten\u021bia va sta la modul \u00een care g\u0103sim idei noi \u0219i originale pentru aceste probleme.</p>","tags":["interactive"]},{"location":"dificil/interactive/#probleme-suplimentare","title":"Probleme suplimentare","text":"<ul> <li>kilonova magie</li> <li>Codeforces Lost Numbers</li> <li>Codeforces Kachina's Favorite Binary String</li> <li>Codeforces Chocolate Bunny</li> <li>CCO 2018 Gradient Descent</li> <li>kilonova dragonul</li> <li>Codeforces Minimum and Maximum</li> <li>IIOT 2022 Battle</li> <li>RMI 2018 Password</li> <li>Info1Cup 2023 Caesar</li> <li>ONI 2010 conex</li> <li>JOI 2020 Stray Cat</li> <li>Info1Cup 2018 Hidden</li> <li>AtCoder HonestOrUnkind</li> <li>Codeforces Ehab and the Big Finale</li> <li>IOI 2015 Towns</li> <li>Round 64 - CsAcademy</li> <li>Probleme interactive de pe kilonova</li> <li>Probleme interactive de pe codeforces</li> </ul>","tags":["interactive"]},{"location":"dificil/interactive/#resurse-suplimentare","title":"Resurse suplimentare","text":"<ul> <li>Introduction to Interactive Problems</li> <li>Interactive Problems: Guide for Participants</li> <li>Interactive and Communication Problems</li> <li>Interactive, output only &amp; Communication Task - HKOI</li> </ul>","tags":["interactive"]},{"location":"dificil/intro-linalg/","title":"Introducere \u00een algebr\u0103 liniar\u0103","text":"<p>Daca vreti sa ne ajutati cu acest articol, ne puteti gasi pe github sau pe serverul nostru de discord</p> <p>Mai jos g\u0103si\u021bi resurse pe care le pute\u021bi citi p\u00e2n\u0103 atunci.</p>","tags":["matematica","algebra liniara"]},{"location":"dificil/intro-linalg/#introducere","title":"Introducere","text":"","tags":["matematica","algebra liniara"]},{"location":"dificil/intro-linalg/#problema-exemplu","title":"Problema exemplu","text":"","tags":["matematica","algebra liniara"]},{"location":"dificil/intro-linalg/#concluzii","title":"Concluzii","text":"","tags":["matematica","algebra liniara"]},{"location":"dificil/intro-linalg/#probleme-suplimentare","title":"Probleme suplimentare","text":"","tags":["matematica","algebra liniara"]},{"location":"dificil/intro-linalg/#resurse-suplimentare","title":"Resurse suplimentare","text":"","tags":["matematica","algebra liniara"]},{"location":"dificil/kmp/","title":"Knuth-Morris-Pratt (KMP)","text":"<p>Daca vreti sa ne ajutati cu acest articol, ne puteti gasi pe github sau pe serverul nostru de discord</p> <p>Mai jos g\u0103si\u021bi resurse pe care le pute\u021bi citi p\u00e2n\u0103 atunci.</p>","tags":["siruri de caractere","potrivire"]},{"location":"dificil/kmp/#introducere","title":"Introducere","text":"","tags":["siruri de caractere","potrivire"]},{"location":"dificil/kmp/#problema-exemplu","title":"Problema exemplu","text":"","tags":["siruri de caractere","potrivire"]},{"location":"dificil/kmp/#concluzii","title":"Concluzii","text":"","tags":["siruri de caractere","potrivire"]},{"location":"dificil/kmp/#probleme-suplimentare","title":"Probleme suplimentare","text":"","tags":["siruri de caractere","potrivire"]},{"location":"dificil/kmp/#resurse-suplimentare","title":"Resurse suplimentare","text":"","tags":["siruri de caractere","potrivire"]},{"location":"dificil/lmsr/","title":"Rota\u021bie lexicografic\u0103 minim\u0103","text":"<p>Daca vreti sa ne ajutati cu acest articol, ne puteti gasi pe github sau pe serverul nostru de discord</p> <p>Mai jos g\u0103si\u021bi resurse pe care le pute\u021bi citi p\u00e2n\u0103 atunci.</p>","tags":["implementare","siruri de caractere","optimizare"]},{"location":"dificil/lmsr/#introducere","title":"Introducere","text":"","tags":["implementare","siruri de caractere","optimizare"]},{"location":"dificil/lmsr/#problema-exemplu","title":"Problema exemplu","text":"","tags":["implementare","siruri de caractere","optimizare"]},{"location":"dificil/lmsr/#concluzii","title":"Concluzii","text":"","tags":["implementare","siruri de caractere","optimizare"]},{"location":"dificil/lmsr/#probleme-suplimentare","title":"Probleme suplimentare","text":"<ul> <li>Minimal Rotation CSES</li> <li>IIOT 2022 Casino</li> </ul>","tags":["implementare","siruri de caractere","optimizare"]},{"location":"dificil/lmsr/#resurse-suplimentare","title":"Resurse suplimentare","text":"<ul> <li>Rotatie lexicografic minima -   infoarena</li> <li>Lexicographically Minimal String Rotation - Codeforces</li> <li>Lexicographically minimal string rotation - Wikipedia</li> </ul>","tags":["implementare","siruri de caractere","optimizare"]},{"location":"dificil/lowest-common-ancestor/","title":"Binary lifting. Lowest common ancestor (LCA)","text":"","tags":["arbori","grafuri","structuri de date"]},{"location":"dificil/lowest-common-ancestor/#introducere","title":"Introducere","text":"<p>Pentru a putea folosi acest articol la adev\u0103rata lui valoare, se recomand\u0103 citirea articolului despre arbori pentru a v\u0103 familiariza cu no\u021biunile discutate aici. De asemenea, pentru anumite concepte, vor fi necesare cuno\u0219tin\u021be suplimentare \u00een ceea ce prive\u0219te structurile de date, programarea dinamic\u0103 \u0219i lucrul cu STL. \u00cen cele ce urmeaz\u0103, vom discuta problema afl\u0103rii celui mai mic str\u0103mo\u0219 comun, \u00eempreun\u0103 cu c\u00e2teva tehnici necesare pentru \u00een\u021belegerea ei.</p>","tags":["arbori","grafuri","structuri de date"]},{"location":"dificil/lowest-common-ancestor/#liniarizarea-arborelui","title":"Liniarizarea arborelui","text":"<p>Prima no\u021biune care este necesar\u0103 pentru \u00een\u021belegerea unei mari p\u0103r\u021bi din cuno\u0219tin\u021bele de aici este dat\u0103 de liniarizarea arborelui. Acest procedeu este esen\u021bial pentru a putea transpune informa\u021bia din arbore pentru integrarea structurilor de date \u00eempreun\u0103 cu informa\u021biile deja existente \u00een arbore. Cel mai frecvent algoritm de liniarizare const\u0103 \u00een folosirea unei parcurgeri DFS pentru a trece prin nodurile din arbore \u00een ordinea \u00een care apar, not\u00e2nd pentru fiecare din ele pozi\u021bia la care am intrat \u00een subarborele acelui nod, precum \u0219i pozi\u021bia la care am ie\u0219it din subarborele acelui nod. De aici, putem aplica orice structur\u0103 de date preferat\u0103 pentru a aplica query-urile pe un anumit subarbore.</p> <pre><code>vector&lt;vector&lt;int&gt;&gt; v;\n\nint n, pos, L[200002], R[200002];\nvoid dfs(int parent, int node) {\n    pos++;\n    L[node] = pos;\n\n    for (auto nxt : v[node]) {\n        if (nxt != parent) {\n            dfs(node, nxt);\n        }\n    }\n\n    R[node] = pos;\n}\n</code></pre>","tags":["arbori","grafuri","structuri de date"]},{"location":"dificil/lowest-common-ancestor/#binary-lifting","title":"Binary Lifting","text":"<p>De multe ori, avem nevoie s\u0103 g\u0103sim \u00eentr-un arbore (sau \u00eentr-o construc\u021bie pe care o putem modela ca un arbore) cu \\(n\\) noduri cel de-al \\(k\\)-lea str\u0103mo\u0219 pentru un nod dat. Dup\u0103 cum \u0219ti\u021bi din articolul anterior, un str\u0103mo\u0219 este un nod la care putem ajunge dac\u0103 urc\u0103m de-a lungul arbore, din nod \u00een nod p\u00e2n\u0103 la r\u0103d\u0103cin\u0103. O prim\u0103 metod\u0103 de a afla acest str\u0103mo\u0219 este de a merge fie folosind un vector de p\u0103rin\u021bi calculat anterior, fie folosind o parcurgere, merg\u00e2nd prin to\u021bi cei \\(k\\) str\u0103mo\u0219i. Totu\u0219i, complexitatea acestui algoritm este \\(\\mathcal{O}(k)\\), fiind mult prea \u00eencet \u00een cazul \u00een care avem de calculat aceste r\u0103spunsuri pentru mai multe asemenea noduri.</p> <p>\u00cen acest caz, se pune problema parcurgerii celor \\(k\\) mut\u0103ri \u00eentr-o manier\u0103 care s\u0103 ne permit\u0103 aflarea acestui r\u0103spuns \u00eentr-un timp c\u00e2t mai rapid, aici pun\u00e2ndu-se problema cum putem scrie un anumit num\u0103r \u00eentr-o sum\u0103 de c\u00e2t mai pu\u021bine numere pentru a putea r\u0103spunde la aceste \u00eentreb\u0103ri, f\u0103r\u0103 s\u0103 folosim prea mult\u0103 memorie. A\u0219a cum sugereaz\u0103 \u0219i numele articolului, vom folosi reprezentarea binar\u0103 a numerelor pentru a putea calcula aceste r\u0103spunsuri. Cu alte cuvinte, pentru fiecare nod \u0219tim deja primul lui str\u0103mo\u0219, ceea ce ne d\u0103 ideea de a afla str\u0103mo\u0219ii pentru pozi\u021biile corespunz\u0103toare puterilor lui 2 mai mici sau egale cu \\(n\\).</p> <p>Astfel, vom integra \u00een parcurgerea DFS obi\u0219nuit\u0103 construc\u021bia acestei matrici, unde <code>anc[i][j]</code> va reprezenta cel de-al \\(2^i\\)-lea str\u0103mo\u0219 al nodului \\(j\\). Pentru a afla <code>anc[i][j]</code>, dac\u0103 \\(i = 0\\), atunci <code>anc[i][j]</code> va fi p\u0103rintele nodului \\(j\\), altfel, va fi <code>anc[i-1][anc[i-1][nod]]</code>, practic va fi cel de-al \\(2^{i-1}\\)-lea str\u0103mo\u0219 al celui de-al \\(2^{i-1}\\) lea str\u0103mo\u0219 al nodului curent, astfel folosind proprietatea c\u0103 o putere a lui 2 e dublul puterii precedente a lui 2, construind acest \u0219ir din aproape \u00een aproape.</p> <p>Pentru a afla apoi un str\u0103mo\u0219 situat la pozi\u021bia \\(x\\) fa\u021b\u0103 de un nod \\(y\\), tot ce va trebui s\u0103 facem va fi s\u0103 parcurgem invers, \u00eencep\u00e2nd de la nodul curent, folosindu-ne de reprezentarea binar\u0103 a nodului dat.</p> <pre><code>// anc[i][j] = nodul situat la distanta 2^i de nodul j\n\nint n, q, anc[20][200002], lvl[200002];\nvector&lt;int&gt; v[200002];\n\nvoid dfs(int tata, int nod) {\n    // Primul stramos este parintele nodului curent\n    anc[0][nod] = tata;\n\n    // Al 2^i-lea stramos al nodului curent e al 2^(i-1)\n    // lea stramos al 2^(i-1) lea stramos al nodului curent\n    for (int i = 1; i &lt;= 18; ++i) {\n        anc[i][nod] = anc[i - 1][anc[i - 1][nod]];\n    }\n\n    for (int i = 0; i &lt; v[nod].size(); ++i) {\n        int vecin = v[nod][i];\n        if (vecin == tata) {\n            continue;\n        }\n\n        // Avem nevoie de nivelul nodului pe arbore pentru cazul cu -1\n        lvl[vecin] = lvl[nod] + 1;\n        dfs(nod, vecin);\n    }\n}\n\n// Cel de-al k-lea stramos al lui nod\nint solve(int nod, int stp) {\n    // Parcurgem nivelele pentru a afla stramosul dorit\n    for (int i = 18; i &gt;= 0; --i) {\n        if (stp &gt;= (1 &lt;&lt; i)) {\n            nod = anc[i][nod], stp -= (1 &lt;&lt; i);\n        }\n    }\n    return nod;\n}\n</code></pre>","tags":["arbori","grafuri","structuri de date"]},{"location":"dificil/lowest-common-ancestor/#lowest-common-ancestor","title":"Lowest Common Ancestor","text":"<p>De foarte multe ori, se pune problema afl\u0103rii celui mai mic str\u0103mo\u0219 comun \u00eentre dou\u0103 sau mai multe noduri, \u00eentr-un timp c\u00e2t mai eficient. De\u0219i la fel ca la subproblema precedent\u0103, putem g\u0103si r\u0103spunsul folosind o metod\u0103 brut\u0103, folosirea binary lifting se va dovedi instrumental\u0103 pentru aflarea LCA-ului \u00een \\(\\mathcal{O}(\\log n)\\). Cu alte cuvinte, mai \u00eent\u00e2i vom vrea s\u0103 aducem nodurile la acela\u0219i nivel, iar mai apoi, urc\u0103m \u00een arbore p\u00e2n\u0103 c\u00e2nd ajungem fix \u00eenainte de nodul care ne va da r\u0103spunsul. Cazul c\u00e2nd un nod este str\u0103mo\u0219ul altuia se trateaz\u0103 anterior. Codul de mai jos se bazeaz\u0103 pe precalcul\u0103rile men\u021bionate mai sus.</p> <p>Observa\u021bie</p> <p>LCA-ul \u00eentre mai multe noduri se poate afla ca fiind LCA-ul \u00eentre primele dou\u0103, apoi rezultatul cu al treilea nod \u0219i a\u0219a mai departe.</p> <pre><code>int solve(int a, int b) {\n    if (lvl[a] &lt; lvl[b]) {\n        swap(a, b);\n    }\n\n    for (int i = 18; i &gt;= 0; --i) {\n        if (lvl[a] - (1 &lt;&lt; i) &gt;= lvl[b]) {\n            a = anc[i][a];\n        }\n    }\n\n    if (a == b) {\n        return a;\n    }\n\n    for (int i = 18; i &gt;= 0; --i) {\n        if (dp[i][a] != dp[i][b]) {\n            a = anc[i][a], b = anc[i][b];\n        }\n    }\n\n    return anc[0][a];\n}\n</code></pre> <p>Observa\u021bie</p> <p>LCA-ul \u00eentre dou\u0103 noduri se poate afla \u0219i \u00een \\(\\mathcal{O}(1)\\) per query, folosind o precalculare de tipul RMQ, care se bazeaz\u0103 pe liniarizarea arborelui (TO-DO)</p>","tags":["arbori","grafuri","structuri de date"]},{"location":"dificil/lowest-common-ancestor/#probleme-suplimentare","title":"Probleme suplimentare","text":"<ul> <li>Milk Visits USACO   Silver</li> <li>CSES Planet Queries I</li> <li>CSES Planet Queries II</li> <li>USACO Platinum Max   Flow</li> <li>RoAlgo Contest #6 Sap</li> <li>IIOT 2022 Sum Tree</li> <li>MST for Each Edge - Codeforces</li> <li>Lot 2016 Seniori maxdist</li> <li>Probleme cu LCA de pe Kilonova</li> </ul>","tags":["arbori","grafuri","structuri de date"]},{"location":"dificil/lowest-common-ancestor/#resurse-suplimentare","title":"Resurse suplimentare","text":"<ul> <li>Euler Tour Technique - USACO Guide</li> <li>Binary Lifting + LCA - USACO   Guide</li> <li>LCA - CPPI   Sync</li> <li>Tutorial - Binary lifting -   Codeforces</li> <li>Tutorial video Errichto (Binary   lifting)</li> </ul>","tags":["arbori","grafuri","structuri de date"]},{"location":"dificil/mobius/","title":"Func\u021bia M\u00f6bius","text":"","tags":["matematica","combinatorica","multimi","implementare"]},{"location":"dificil/mobius/#notiuni-introductive","title":"No\u021biuni introductive","text":"<p>\u00cen teoria numerelor, o func\u021bie aritmetic\u0103 este o func\u021bie \\(f(n) : \\mathbb{N} \\to \\mathbb{C}\\). O func\u021bie aritmetic\u0103 exprim\u0103 propriet\u0103\u021bi aritmetice pentru \\(n\\).</p> <p>Pentru \\(m, n\\) numere prime \u00eentre ele (adic\u0103 \\(cmmdc(m, n) = 1\\)), avem dou\u0103 feluri de func\u021bii aritmetice:</p> <ul> <li>func\u021bii aditive, unde \\(f(mn) = f(n) + f(m)\\);</li> <li>func\u021bii multiplicative, unde \\(f(mn)\\) = \\(f(m)f(n)\\).</li> </ul> <p>Pentru simplitate vom defini urm\u0103toarele aspecte:</p> <ul> <li>\\([p] = 1\\) dac\u0103 \\(p\\) este o propozi\u021bie adev\u0103rat\u0103 sau 0 \u00een caz contrar.</li> <li>\\(\\lfloor n \\rfloor\\) = partea \u00eentreag\u0103 a lui \\(n\\).</li> </ul> <p>C\u00e2t \u0219i urm\u0103toarele propriet\u0103\u021bi celebre:</p> <ul> <li>\\(\\sum_{k = 1}^{N} \\frac{1}{k} \\approx \\log{N}\\).</li> <li>\u0218irul $ a_i = \\lfloor \\frac{N}{i} \\rfloor $, cu \\(\\leq N\\), are \\(\\mathcal{O}(\\sqrt N)\\)   valori distincte.</li> </ul> <p>Pentru \\(\\forall p \\in \\mathbb{N}\\), \\(p\\) num\u0103r prim, \u0219i \\(\\forall k \\in \\mathbb{N}\\), definim urm\u0103toarele func\u021bii multiplicative:</p> <ul> <li>func\u021bia identic\u0103 \\(I(p^k) = p^k\\);</li> <li>func\u021bia putere \\(P_a(p^k) = p^{ka}\\), unde \\(a\\) este constant\u0103 (nu confund\u0103m cu   func\u021bia exponen\u021bial\u0103 \\(f_a(p^k) = a^{p^k}\\));</li> <li>func\u021bia unitate \\(U(p^k) = [p^k = 1]\\);</li> <li>func\u021bia divizorilor \\(\\sigma (p^k)\\) = num\u0103rul de divizori ai lui \\(p^k\\);</li> <li>indicatorul lui Euler \\(\\varphi(p^k) = p^{k} - p^{k-1}\\), c\u00e2te numere \\(x\\), cu \\(1   \\leq x \\leq p^k\\) \u0219i \\(\\operatorname{cmmdc}(x, p^k) = 1\\) exist\u0103</li> <li>func\u021bia M\u00f6bius \\(\\mu(p^k) = [k = 0] - [k = 1]\\).</li> </ul> <p>Defini\u021bie</p> <p>Dou\u0103 func\u021bii multiplicative, \\(f(n)\\) \u0219i \\(g(n)\\), sunt identice dac\u0103 pentru oricare \\(p\\) num\u0103r prim \u0219i oricare \\(k \\geq 0\\), \\(g(p^k) = f(p^k)\\).</p>","tags":["matematica","combinatorica","multimi","implementare"]},{"location":"dificil/mobius/#precalcularea-functiilor-multiplicative","title":"Precalcularea func\u021biilor multiplicative","text":"<p>\u00cen contextul nostru, vom lucra cel mai des cu func\u021bii multiplicative, iar de cele mai multe ori avem nevoie s\u0103 \u0219tim valorile unei func\u021bii pentru un set mai larg de elemente. \u0218i se dovede\u0219te c\u0103 Ciurul \u00eenv\u0103\u021bat \u00een clasa a 6-a este bun nu numai la aflarea numerelor prime.</p>","tags":["matematica","combinatorica","multimi","implementare"]},{"location":"dificil/mobius/#ciurul-lui-eratostene","title":"Ciurul lui Eratostene","text":"<p>Acest algoritm este poate cel mai popular printre elevii de liceu \u0219i gimnaziu pentru a afla numerele prime \u00eentr-un interval.</p> <pre><code>vector&lt;int&gt; ciur(N + 1);\nciur[0] = ciur[1] = 1;\nfor (int i = 2; i &lt;= N; i++) {\n    if (ciur[i] == 0) {  // numarul i este prim\n        for (int j = 2 * i; j &lt;= N; j += i) {\n            ciur[j] = 1;  // j se scrie ca i * p\n        }\n    }\n}\n</code></pre> <p>La finalul programului, \\(k\\) va fi num\u0103r prim doar dac\u0103 \\(\\operatorname{ciur}(k) = 0\\).</p> <p>Complexitatea de timp este \\(\\mathcal{O}(\\sum_{k=1}^N \\frac{N}{k}) = O(N \\log{N})\\).</p>","tags":["matematica","combinatorica","multimi","implementare"]},{"location":"dificil/mobius/#ciur-liniar","title":"Ciur liniar","text":"<p>Observ\u0103m c\u0103 fiecare num\u0103r compus \\(X\\) este parcurs de c\u0103tre cel de-al doilea for de mai multe ori. Dac\u0103 am putea s\u0103 iter\u0103m prin fiecare num\u0103r compus exact o singur\u0103 dat\u0103 am ajunge la complexitatea de \\(\\mathcal{O}(N)\\). Re\u021binem \u00eentr-un vector auxiliar numerele prime, \u0219i pentru un \\(i\\) fixat vom parcurge numerele prime p\u00e2n\u0103 c\u00e2nd un num\u0103r prim divide \\(i\\).</p> <pre><code>vector&lt;int&gt; prime;\nvector&lt;int&gt; is_composite(N + 1);\n\nfor (int i = 2; i &lt;= n; i++) {\n    if (!is_composite[i]) {\n        prime.push_back(i);\n    }\n    for (int j = 0; j &lt; prime.size() &amp;&amp; i * prime[j] &lt;= n; j++) {\n        is_composite[i * prime[j]] = 1;\n        if (i % prime[j]) {\n            break;\n        }\n    }\n}\n</code></pre> <p>Demonstra\u021bie</p> <p>Ca s\u0103 demonstr\u0103m faptul c\u0103 ciurul de mai sus itereaz\u0103 prin fiecare num\u0103r compus exact odat\u0103 avem nevoie de cel mai mic factor prim al acestuia, \\(p\\). S\u0103 presupunem c\u0103 \\(q = i \\cdot p\\). Pentru oricare \\(j &gt; i\\), \\(j\\) este divizor a lui \\(q\\), presupunem ca \\(k = \\frac{q}{j}\\) este prim. Cum \\(i &lt; j\\), atunci \\(k &lt; p\\), \u00eens\u0103 \\(p\\) este cel mai mic num\u0103r prim care divide \\(q\\), deci nu exist\u0103 un astfel \\(k\\). Deci odat\u0103 luat\u0103 \u00een considerare perechea \\((i, p)\\),\\, \\(i \\cdot p\\) va fi calculat doar o singur\u0103 dat\u0103, transform\u00e2nd complexitatea final\u0103 \u00een \\(\\mathcal{O}(N)\\).</p>","tags":["matematica","combinatorica","multimi","implementare"]},{"location":"dificil/mobius/#precalcularea-indicatorului-lui-euler-folosind-ciurul-liniar","title":"Precalcularea indicatorului lui Euler folosind Ciurul Liniar","text":"<p>Pentru a calcula \\(\\varphi(n)\\) trebuie s\u0103 luam \u00een considerare 3 cazuri:</p> <ul> <li>\\(n\\) este prim, deci \\(\\varphi(n) = n-1\\)</li> <li>\\(n = i \\cdot p\\) \u0219i \\(p \\nmid i\\), deci \\(\\varphi(n) = \\varphi(i) \\varphi(p)\\).   (prin \\(a \\nmid b\\) \u00een\u021belegem: \"a nu divide pe b\").</li> <li>\\(n = i \\cdot p\\) \u0219i \\(p \\mid i\\). Acest caz este uneori greu de tratat, dar din   fericire \u0219tim sigur c\u0103 \\(\\varphi(ip) = p\\varphi(i)\\ \\forall i, p\\).</li> </ul> <pre><code>vector&lt;int&gt; prime;\nvector&lt;int&gt; phi(N), compus(N);\nphi[1] = 1;\nfor (int i = 2; i &lt;= N; i++) {\n    if (!compus[i]) {\n        prime.push_back(i);\n        phi[i] = i - 1;\n    }\n    for (int j = 0; j &lt; prime.size() &amp;&amp; i * prime[j] &lt;= N; j++) {\n        compus[i * prime[j]] = 1;\n        if (i % prime[j]) {\n            phi[i * prime[j]] = phi[i] * phi[prime[j]];\n        } else {\n            phi[i * prime[j]] = prime[j] * phi[i];\n        }\n    }\n}\n</code></pre>","tags":["matematica","combinatorica","multimi","implementare"]},{"location":"dificil/mobius/#generalizare-a-ciurului-liniar","title":"Generalizare a ciurului liniar","text":"<p>Totu\u0219i, putem s\u0103 generaliz\u0103m algoritmul prezentat mai sus pentru a func\u021biona pentru oricare func\u021bie multiplicativ\u0103. Fie \\(\\operatorname{sml}(n)\\) puterea celui mai mic factor din descompunerea \u00een factori primi a lui \\(n\\). Pentru oricare \\(i\\) \u0219i \\(p\\), \\(p\\) cel mai mic num\u0103r prim care divide \\(i\\), putem scrie \\(f(ip) = f(\\frac{i}{p^{\\operatorname{sml}(i)}}) \\cdot f(p^{\\operatorname{sml}(i) + 1})\\).</p> <pre><code>vector&lt;int&gt; prime, phi(N + 1), compus(N + 1), sml(N + 1);\nphi[1] = 1;\nfor (int i = 2; i &lt;= N; i++) {\n    if (!compus[i]) {\n        prime.push_back(i);\n        phi[i] = i - 1;\n        sml[i] = 1;\n    }\n    for (int j = 0; j &lt; prime.size() &amp;&amp; i * prime[j] &lt;= N; j++) {\n        compus[i * prime[j]] = 1;\n        if (i % prime[j]) {\n            phi[i * prime[j]] = phi[i] * phi[prime[j]];\n            sml[i * prime[j]] = 1;\n        } else {\n            phi[i * prime[j]] =\n                (phi[i] / (pow(prime[j], sml[i]) - pow(prime[j], sml[i] - 1)));\n            phi[i * prime[j]] *=\n                (pow(prime[j], sml[i] + 1) - pow(prime[j], sml[i]));\n            sml[i * prime[j]] = sml[i] + 1;\n        }\n    }\n}\n</code></pre> <p>Aten\u021bie</p> <p>Func\u021bia pow din cod este o func\u021bie scris\u0103 de m\u00e2n\u0103. Nu recomand\u0103m folosirea func\u021biei pow din cmath, din cauza erorilor de precizie.</p> <p>G\u00e2ndim similar pentru func\u021bia M\u00f6bius:</p> <ul> <li>\\(n\\) prim \\(\\Rightarrow \\mu(n) = -1\\)</li> <li>\\(n = i \\cdot p\\), \\(p \\nmid i\\), deci \\(\\mu(n) = \\mu(i) \\cdot \\mu(p)\\)</li> <li>\\(n = i \\cdot p\\), \\(p \\mid i\\), deci \\(\\mu(n) =   \\frac{\\mu(i)}{[sml(i)=0]-[sml(i)=1]} \\cdot ([sml(i)+1=0]-[sml(i)+1=1])\\).</li> </ul> <p>Observa\u021bie</p> <p>\u00cen cazul \u00een care frac\u021bia de mai sus nu este definit\u0103 (numitorul este 0), putem spune din start c\u0103 \\(\\mu(n) = 0\\).</p> <pre><code>vector&lt;int&gt; prime;\nvector&lt;int&gt; sml(N), mobius(N), composite(N);\n\nmobius[1] = 1;\nfor (int i = 2; i &lt; N; i++) {\n    if (!composite[i]) {\n        prime.push_back(i);\n        mobius[i] = -1;\n        sml[i] = 1;\n    }\n    for (int j = 0; j &lt; prime.size() &amp;&amp; i * prime[j] &lt; N; j++) {\n        composite[i * prime[j]] = 1;\n        if (i % prime[j]) {\n            mobius[i * prime[j]] = mobius[i] * mobius[prime[j]];\n            sml[i * prime[j]] = 1;\n        } else {\n            int cltr = (sml[i] == 0) - (sml[i] == 1);\n            int pl = (sml[i] + 1 == 0) - (sml[i] + 1 == 1);\n            if (cltr == 0) {\n                mobius[i] = 0;\n            } else {\n                mobius[i * prime[j]] = (mobius[i] / cltr) * pl;\n            }\n            sml[i * prime[j]] = sml[i] + 1;\n        }\n    }\n}\n</code></pre>","tags":["matematica","combinatorica","multimi","implementare"]},{"location":"dificil/mobius/#implementare-mai-populara","title":"Implementare mai popular\u0103","text":"<p>Rareori avem nevoie de ciur liniar, \u0219i dac\u0103 nu intr\u0103 \u00een timp \\(\\mathcal{O}(N \\log{N})\\) pentru precalculare, de ce ar intra \\(\\mathcal{O}(N)\\)?</p> <pre><code>vector&lt;int&gt; phi(N), mobius(N);\nphi[1] = mobius[1] = 1;\n\nfor (int i = 2; i &lt; N; i++) {\n    phi[i] = i - 1;\n}\nfor (int i = 1; i &lt; N; i++) {\n    for (int j = 2 * i; j &lt; N; j += i) {\n        mobius[j] -= mobius[i];\n        if (i &gt; 1) {\n            phi[j] -= phi[i];\n        }\n    }\n}\n</code></pre>","tags":["matematica","combinatorica","multimi","implementare"]},{"location":"dificil/mobius/#inversiunea-lui-mobius","title":"Inversiunea lui M\u00f6bius","text":"<p>Ultimele din cele 3 func\u021bii prezentate la \u00eenceputul articolului sunt mai cunoscute ca restul, \u00eens\u0103 noi ne vom folosi cel mai mult de ultimele 2, anume indicatorul lui Euler \u0219i func\u021bia M\u00f6bius.</p> <p>Fie \\(g(n)\\) = \\(\\sum_{d\\mid n} f(d)\\). Inversiunea lui M\u00f6bius ne spune:</p> \\[     f(n) = \\sum_{d\\mid n} g(d) \\cdot \\mu \\left(\\frac{n}{d}\\right) \\] <p>Cu toate astea, o proprietate mai important\u0103 este \\(\\sum_{d\\mid n} \\mu(d) = U(n)\\). Ceea ce sugereaz\u0103 expresia este c\u0103 pentru oricare num\u0103r natural \\(n\\) suma va da 1 doar dac\u0103 \\(n = 1\\). Pare nesemnificativ\u0103 proprietatea, \u00eens\u0103 este foarte util\u0103 \u00een rezolvarea multor probleme de informatic\u0103.</p> <p>Exerci\u021biu 1: Calculeaz\u0103 c\u00e2te perechi \\((a,b)\\) (\\(1 \\leq a,b \\leq n\\)) exist\u0103 cu proprietatea c\u0103 \\(\\operatorname{cmmdc}(a,b) = 1\\).</p> <p>Rezolvare: Noi trebuie s\u0103 calcul\u0103m \\(\\sum_{i=1}^{n} \\sum_{j=1}^{n} [\\operatorname{cmmdc}(i, j) = 1]\\). Ne putem folosi de proprietatea de mai sus \u0219i s\u0103 scriem rela\u021bia astfel:</p> \\[ \\sum_{i=1}^{n} \\sum_{j=1}^{n} \\sum_{d \\mid \\operatorname{cmmdc}(i,j)} \\mu(d) \\] <p>Iter\u0103m prin toate numerele \\(\\leq n\\) \u00een loc de divizorii lui \\(n\\) \u0219i ob\u021binem</p> \\[ \\sum_{i=1}^{n} \\sum_{j=1}^{n} \\sum_{d = 1}^{n} \\mu(d) \\cdot [d\\mid \\operatorname{cmmdc}(i,j)] = \\sum_{i=1}^{n} \\sum_{j=1}^{n} \\sum_{d = 1}^{n} \\mu(d) \\cdot [d\\mid i] \\cdot [d\\mid j] \\] <p>Rearanj\u0103m termenii \u0219i ob\u021binem</p> \\[ \\sum_{d=1}^{n} \\mu(d) \\left(\\sum_{i=1}^{n} [d\\mid i]\\right) \\left(\\sum_{j=1}^{n} [d\\mid j]\\right) \\] <p>Observ\u0103m c\u0103</p> \\[ \\sum_{i=1}^{n} [d\\mid i] = \\sum_{j=1}^{n} [d\\mid j] = \\left\\lfloor \\frac{n}{d} \\right\\rfloor \\] <p>deci rela\u021bia final\u0103 devine \\(\\sum_{d=1}^{n} \\mu(d) \\cdot (\\frac{n}{d})^2\\), care poate fi calculat\u0103 \u00een \\(\\mathcal{O}(n)\\).</p> <p>Exerci\u021biu 2: Calculeaz\u0103 c\u00e2te perechi \\((a,b)\\) exis\u0103, astfel \u00eenc\u00e2t \\(1 \\leq a,b \\leq n\\) \u0219i \\(\\operatorname{cmmdc}(a, b)\\) = \\(P\\).</p> <p>Rezolvare:</p> \\[     \\sum_{i=1}^{n} \\sum_{j=1}^{n} [\\operatorname{cmmdc}(i,j) = P] = \\sum_{i=1}^{\\frac{n}{P}} \\sum_{j=1}^{\\frac{n}{P}} [\\operatorname{cmmdc}(i,j) = 1] \\] <p>Observ\u0103m c\u0103 e identic cu exerci\u021biul precedent, rezultatul fiind \\(\\sum_{d=1}^{\\frac{n}{P}} \\mu(d) \\cdot \\left(\\frac{n}{dP}\\right)^2\\).\\</p> <p>Exerci\u021biul 3: Calculeaz\u0103 \\(\\sum_{1 \\leq i,j \\leq N} lcm(i,j)\\), unde $lcm(i,j) = $ cel mai mic multiplu comun al numerelor \\(i\\) \u0219i \\(j\\).</p> <p>Rezolvare: \u0218tim totu\u0219i c\u0103 \\(lcm(i,j) = \\dfrac{i\\cdot j}{\\operatorname{cmmdc}(i,j)}\\), astfel problema ne cere s\u0103 calcul\u0103m suma:</p> \\[     \\sum_{1 \\leq i, j \\leq N} \\dfrac{i \\cdot j}{\\operatorname{cmmdc}(i,j)} \\] <p>Pentru a ne u\u0219ura calculul, putem defini:</p> \\[     f(k) = \\sum_{1 \\leq i, j \\leq N} \\dfrac{i \\cdot j}{\\operatorname{cmmdc}(i,j)} \\cdot [\\operatorname{cmmdc}(i,j) = k] \\] <p>Observ\u0103m deci c\u0103 dac\u0103 \u0219tim suma produselor \\(i \\cdot j\\), cu \\(\\operatorname{cmmdc}(i,j) = k\\), fie aceast\u0103 sum\u0103 \\(p(k)\\), atunci rezultatul devine:</p> \\[     f(k) = \\dfrac{p(k)}{k} \\] <p>Pentru a calcula \\(p(k)\\) ne putem folosi de func\u021bia mobius astfel:</p> \\[ \\begin{align*} p(k) &amp;= \\sum_{1 \\leq i,j \\leq N} i \\cdot j \\cdot [\\operatorname{cmmdc}(i,j) = k] \\\\ &amp;= \\sum_{a = 1}^{\\frac{N}{k}} \\sum_{b = 1}^{\\frac{N}{k}} a \\cdot b \\cdot k^2 \\cdot [\\operatorname{cmmdc}(a,b) = 1] \\\\ &amp;= \\sum_{a = 1}^{\\frac{N}{k}} \\sum_{b = 1}^{\\frac{N}{k}} a \\cdot b \\cdot k^2 \\cdot \\sum_{d = 1}^{\\frac{N}{k}} \\mu(d) \\cdot [d \\mid a] \\cdot [d \\mid b] \\\\ &amp;= k^2 \\cdot \\sum_{d=1}^{\\frac{N}{k}} \\mu(d) \\cdot \\left(\\sum_{a = 1}^{\\frac{N}{k}} a \\cdot [d \\mid a] \\right) \\cdot \\left(\\sum_{b=1}^{\\frac{N}{k}} b \\cdot [d \\mid b] \\right) \\end{align*} \\] <p>Observ\u0103m c\u0103:</p> \\[ \\begin{align*} \\sum_{a=1}^{\\frac{N}{k}} a \\cdot [d \\mid a] &amp;= \\sum_{b=1}^{\\frac{N}{k}} b \\cdot [d \\mid b] \\\\ &amp;= \\left(d \\cdot (1 + 2 + \\dots + \\frac{N}{kd}) \\right)^2 \\\\ &amp;= \\left( d \\cdot \\frac{\\frac{N}{kd} \\cdot \\left(\\frac{N}{kd} + 1\\right)}{2} \\right)^2 \\end{align*} \\] <p>Deci:</p> \\[ p(k) = k^2 \\cdot \\sum_{d = 1}^{\\frac{N}{k}} \\mu(d) \\cdot \\left( d \\cdot \\dfrac{\\frac{N}{kd} \\cdot (\\frac{N}{kd} + 1)}{2} \\right)^2 \\] <p>Revenim la problema noastr\u0103 ini\u021bial\u0103: $$ f(k) = \\frac{p(k)}{k} = k \\cdot \\sum_{d = 1}^{\\frac{N}{k}} \\mu(d) \\cdot \\left( d \\cdot \\dfrac{\\frac{N}{kd} \\cdot (\\frac{N}{kd} + 1)}{2} \\right)^2 $$</p> <p>Iar r\u0103spunsul final este \\(\\sum_{k=1}^{N} f(k)\\), care este calculabil \u00een \\(\\mathcal{O}(N \\log N)\\).</p>","tags":["matematica","combinatorica","multimi","implementare"]},{"location":"dificil/mobius/#probleme-propuse-spre-rezolvare","title":"Probleme propuse spre rezolvare","text":"","tags":["matematica","combinatorica","multimi","implementare"]},{"location":"dificil/mobius/#problema-sumgcd-de-pe-kilonova","title":"Problema sumgcd de pe Kilonova","text":"<p>Pentru \\(N\\) \u0219i \\(M\\) date la tastatur\u0103, trebuie s\u0103 calcula\u021bi \\(\\sum_{V} \\operatorname{cmmdc}(V)\\), unde \\(V\\) reprezint\u0103 un \\(M\\)-tuplu. Un \\(M\\)-tuplu reprezint\u0103 o mul\u021bime de \\(M\\) elemente nu neap\u0103rat distincte cu valori cuprinse \u00eentre 1 \u0219i \\(N\\). Formal, noi trebuie s\u0103 calculam \\(\\sum_{i_1 = 1}^{N} \\sum_{i_2 = 1}^{N} \\dots \\sum_{i_M = 1}^{N} \\operatorname{cmmdc}(i_1, i_2, \\dots, i_M)\\).</p> <p>Dac\u0103 pentru un \\(K\\) fixat afl\u0103m c\u00e2te M-tupluri exist\u0103 cu cmmdc-ul egal cu \\(K\\), atunci putem rezolva foarte u\u0219or problema. Fie \\(f(K)\\) num\u0103rul de tupluri \\((m, n)\\) pentru care \\(\\operatorname{cmmdc}(m, n) = K\\):</p> \\[ \\begin{align*} f(K) &amp;= \\sum_{i_1 = 1}^{N} \\sum_{i_2 = 1}^{N} \\dots \\sum_{i_M = 1}^{N} [\\text{cmmdc}(i_1, i_2, \\dots, i_M) = K] \\\\ &amp;= \\sum_{i_1 = 1}^{\\frac{N}{K}} \\sum_{i_2 = 1}^{\\frac{N}{K}} \\dots \\sum_{i_M = 1}^{\\frac{N}{K}} [\\text{cmmdc}(i_1, i_2, \\dots, i_M) = 1] \\\\ &amp;= \\sum_{i_1 = 1}^{\\frac{N}{K}} \\sum_{i_2 = 1}^{\\frac{N}{K}} \\dots \\sum_{i_M = 1}^{\\frac{N}{K}} \\sum_{d = 1}^{\\frac{N}{K}} \\mu(d) \\cdot [d \\mid i_1] \\cdots [d \\mid i_M] \\\\ &amp;= \\sum_{d = 1}^{\\frac{N}{K}} \\mu(d) \\cdot \\left(\\sum_{i_1 = 1}^{\\frac{N}{K}} [d \\mid i_1]\\right) \\cdots \\left(\\sum_{i_M = 1}^{\\frac{N}{K}} [d \\mid i_M]\\right) \\\\ &amp;= \\sum_{d = 1}^{\\frac{N}{K}} \\mu(d) \\cdot \\left(\\frac{N}{Kd}\\right)^M. \\end{align*} \\] <p>Rezultatul problemei este dat de \\(\\sum_{i=1}^{N} f(i) \\cdot i\\). Complexitatea de timp pentru a calcula \\(f(K)\\) este $\\mathcal{O}(\\frac{N}{K}\\log{M}), astfel complexitatea final\u0103 este</p> \\[ \\begin{align*} \\sum_{i=1}^{N} O\\left(\\frac{N}{i} \\log{M}\\right) &amp;= O\\left(N + \\frac{N}{2} + \\frac{N}{3} + \\cdots + \\frac{N}{N}\\right) \\log{M} \\\\ &amp;= O\\left(N \\left(1 + \\frac{1}{2} + \\frac{1}{3} + \\cdots + \\frac{1}{N}\\right) \\log{M}\\right) \\\\ &amp;= O\\left(N \\log{N} \\log{M}\\right). \\end{align*} \\] <p>Alt\u0103 solu\u021bie este urm\u0103toarea:</p> <p>Vom pune pe cele \\(M\\) pozi\u021bii doar multiplii de \\(K\\), astfel se formeaz\u0103 \\(M^{\\lfloor\\frac{N}{K} \\rfloor}\\) \u0219iruri posibile, dintre care sc\u0103dem \\(f(K \\cdot Q), Q \\geq 1\\).</p> \\[ \\begin{align*} f(K) &amp;= M^{\\left\\lfloor \\frac{N}{K} \\right\\rfloor} - \\sum_{K \\mid i} f(i) \\\\ &amp;= M^{\\left\\lfloor \\frac{N}{K} \\right\\rfloor} - \\sum_{i=1}^{N} f(i) \\cdot [K \\mid i] \\\\ &amp;= M^{\\left\\lfloor \\frac{N}{K} \\right\\rfloor} - \\sum_{i=1}^{\\frac{N}{K}} f(K \\cdot i). \\end{align*} \\] <p>Complexitatea devine:</p> \\[ \\begin{align*} \\sum_{i=1}^{N} O(\\left\\lfloor \\frac{N}{i} \\right\\rfloor + \\log{M}) &amp;= O(N \\left(1 + \\frac{1}{2} + \\frac{1}{3} + \\dots \\frac{1}{N}\\right) + N \\log{M}) \\\\ &amp;= O(N \\log{N} + N \\log{M}) \\\\ &amp;= O(N\\left(\\log{N} + \\log{M}\\right)) \\\\ &amp;= O(N\\log{(MN)}) \\end{align*} \\] <p>Putem precalcula puterile lui \\(M\\), ob\u021binem astfel \\(\\mathcal{O}(N \\log{N})\\). Ambele iau 100 puncte.</p>","tags":["matematica","combinatorica","multimi","implementare"]},{"location":"dificil/mobius/#problema-cntgcd","title":"Problema cntgcd","text":"<p>Se dau dou\u0103 numere naturale \\(N\\) \u0219i \\(D\\). Calcula\u021bi c\u00e2te perechi de numere \\(A\\) \u0219i \\(B\\) mai mici ca \\(N\\) exist\u0103, astfel \u00eenc\u00e2t \\(cmmdc(A,B) = D\\). Perechea \\((A,B)\\) este la fel ca perechea \\((B, A)\\).</p> <p>Putem s\u0103 lu\u0103m rezultatul de la primul exerci\u021biu, pentru c\u0103 probleme sunt echivalente. Singura restric\u021bie este faptul c\u0103 perechea \\((A,B) = (B,A)\\), dar putem efectiv s\u0103 \u00eemp\u0103r\u021bim rezultatul la 2.</p> \\[ ans = \\frac{\\sum_{d=1}^{\\frac{N}{D}} \\mu(d) \\cdot \\left(\\frac{N}{dD}\\right)^2 + 1}{2} \\] <p>Solu\u021bia ia undeva la 45 puncte, datorit\u0103 faptului c\u0103 \\(D \\leq N \\leq 10^9\\).</p> <p>Fie \\(f(n)\\) = num\u0103rul de perechi \\((A,B)\\), unde \\(\\operatorname{cmmdc}(A,B) = 1\\). Noi trebuie s\u0103 calcul\u0103m practic \\(f(\\left\\lfloor \\frac{N}{D} \\right\\rfloor ) = \\sum_{d = 1}^{\\left\\lfloor \\frac{N}{D} \\right\\rfloor } \\varphi(d)\\).</p> <p>Pentru \\(N \\leq 10^6\\) putem calcula suma brut. Pentru \\(N &gt; 10^6\\) putem elimina perechile care au cmmdc-ul 2, 3 etc.</p> \\[ f(n) = \\frac{n^2 - n}{2} - \\sum_{d=2}^{n} f\\left(\\left\\lfloor \\frac{n}{d} \\right\\rfloor\\right) \\] <p>Datorit\u0103 faptului c\u0103 \u0219irul \\(a_i = \\lfloor \\frac{N}{i} \\rfloor\\) are \\(\\mathcal{O}(\\sqrt{N})\\) elemente diferite, putem doar s\u0103 calcul\u0103m c\u00e2te numere \\(d_1\\) exist\u0103, astfel \u00eenc\u00e2t \\(\\frac{n}{d} = \\frac{n}{d_1}\\) \u0219i s\u0103 adun\u0103m la rezultat \\(f(\\lfloor \\frac{n}{d} \\rfloor) \\cdot nr\\).</p> <p>Observa\u021bie</p> <p>Fie \\(d\\) cel mai mic num\u0103r astfel \u00eenc\u00e2t \\(\\frac{n}{d} = x\\). Atunci cel mai mare num\u0103r care \u00eendepline\u0219te aceea\u0219i proprietate este \\(\\left\\lfloor \\frac{n}{\\lfloor \\frac{n}{d} \\rfloor} \\right\\rfloor\\).</p> <pre><code>long long f(long long n) {\n    // cout &lt;&lt; n &lt;&lt; '\\n';\n    if (n &lt;= 1000000) {\n        return sum_phi[n];  // phi(1) + phi(2) + ... + phi(n)\n    }\n    if (dp[n]) {\n        return dp[n];\n        // am calculat deja rezultatul pt n\n    }\n    long long ans = 1LL * (1LL * n * (n + 1)) / 2;\n    for (int i = 2, dr; i &lt;= n; i = dr + 1) {\n        dr = (n / (n / i));\n        if (dr &gt; n) {\n            break;\n        }\n        ans -= (dr - i + 1) * f(n / i);\n    }\n    dp[n] = ans;\n    return ans;\n}\n</code></pre> <p>Complexitatea algoritmului de mai sus este foarte interesant\u0103, ea fiind \\(\\mathcal{O}(N^\\frac{2}{3})\\).</p>","tags":["matematica","combinatorica","multimi","implementare"]},{"location":"dificil/mobius/#problema-tupleco","title":"Problema tupleco","text":"<p>Se dau dou\u0103 numere \\(K\\) \u0219i \\(N\\). S\u0103 se afle \\(T\\), num\u0103rul de tupluri formate din \\(K\\) elemente \\((X_1, X_2, X_3, \\dots , X_K)\\) cu proprietatea c\u0103:</p> <ul> <li>\\(1 \\leq X_1 \\leq X_2 \\leq \\dots \\leq X_K \\leq N\\).</li> <li>\\(\\operatorname{cmmdc}(X_1, X_2, \\dots, X_K) = 1\\).</li> </ul>","tags":["matematica","combinatorica","multimi","implementare"]},{"location":"dificil/mobius/#solutie-de-75-rightarrow-80-sau-chiar-100-de-puncte","title":"Solu\u021bie de \\(75 \\rightarrow 80\\) (sau chiar 100) de puncte","text":"<p>Ne vom folosi de func\u021bia M\u00f6bius pentru a calcula rezultatul. Dac\u0103 facem abstrac\u021bie de prima proprietate, r\u0103spunsul nostru devine:</p> \\[ \\sum_{d=1}^{N} \\mu(d) \\cdot \\lfloor \\frac{N}{d} \\rfloor ^K \\] <p>Ce \u00eenseamn\u0103 \u00eens\u0103 \\(\\lfloor \\dfrac{N}{d} \\rfloor ^ K\\)? Reprezint\u0103 num\u0103rul de \u0219iruri de lungime \\(K\\) , unde \\(X_i\\) este multiplu de \\(d\\). Ca s\u0103 num\u0103r\u0103m doar num\u0103rul de \u0219iruri care sunt sortate, ne vom folosi de Stars and Bars, astfel num\u0103rul de \u0219iruri \\((X_1, X_2, X_3, .. ,X_K)\\) cu \\(X_i \\leq X_{i+1} \\leq N\\) este egal cu \\(N-K+1 \\choose K\\).</p> <p>Rezultatul nostru devine:</p> \\[ \\sum_{d=1}^{N} \\mu(d) \\cdot {\\left\\lfloor \\frac{N}{d} \\right\\rfloor - K + 1 \\choose K} \\] <p>Solu\u021bia ruleaz\u0103 \u00een \\(\\mathcal{O}(N)\\) cu \\(\\mathcal{O}(N)\\) sau \\(\\mathcal{O}(N \\cdot \\log N)\\) precalcularea.</p> <pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\nconst int N = 1e7 + 1, mod = 3000017;\nint n, k;\nifstream fin(\"tupleco.in\");\nofstream fout(\"tupleco.out\");\n#define cin fin\n#define cout fout\nlong long C(int n, int k, vector&lt;long long&gt; &amp;f, vector&lt;long long&gt; &amp;invf) {\n    return (1ULL * f[n] * (1ULL * invf[k] * invf[n - k] % mod) % mod) % mod;\n}\nint main() {\n    cin.tie(0)-&gt;sync_with_stdio(0);\n    cin &gt;&gt; k &gt;&gt; n;\n    vector&lt;long long&gt; f(n + k + 1), inv(n + k + 1), invf(n + k + 1);\n    vector&lt;short&gt; mobius(n + 1);\n    f[0] = f[1] = inv[0] = inv[1] = invf[0] = invf[1] = 1;\n    for (int i = 2; i &lt;= n + k; i++) {\n        f[i] = (1ULL * f[i - 1] * i) % mod;\n        inv[i] = (1ULL * inv[mod % i] * (mod - mod / i)) % mod;\n        invf[i] = (1ULL * invf[i - 1] * inv[i]) % mod;\n    }\n\n    mobius[1] = 1;\n    for (int i = 1; i &lt;= n; i++) {\n        if (mobius[i]) {\n            for (int j = i + i; j &lt;= n; j += i) {\n                mobius[j] -= mobius[i];\n            }\n        }\n    }\n\n    long long ans = 0;\n    for (int d = 1; d &lt;= n; d++) {\n        int lt = n / d;\n        long long plt = C(lt + k - 1, k, f, invf);\n        if (mobius[d] == -1) {\n            ans = (1ULL * ans + mod - plt) % mod;\n        } else if (mobius[d] == 1) {\n            ans = (1ULL * ans + plt) % mod;\n        }\n    }\n    cout &lt;&lt; ans;\n}\n</code></pre>","tags":["matematica","combinatorica","multimi","implementare"]},{"location":"dificil/mobius/#ok-dar-putem-mai-bine","title":"Ok, dar putem mai bine?","text":"<p>Ne folosim de ideea prezentat\u0103 la problema anterioar\u0103.</p> \\[ f(n) = {n-k+1 \\choose k} - \\sum_{d=2}^{n} f\\left(\\left\\lfloor \\frac{n}{d} \\right\\rfloor \\right). \\] <p>Observa\u021bie</p> <p>Deducem cu puternicele noastre sim\u021buri c\u0103 modulul (\\(M\\)) \u00een problema asta este mult mai mic dec\u00e2t \\(N\\), astfel putem s\u0103 calcul\u0103m combin\u0103rile mult mai rapid:</p> <ul> <li>\\(n \\leq M\\), deci putem precalcula combin\u0103rile \u00een \\(\\mathcal{O}(M)\\). </li> <li>\\(n &gt; M\\), deci \\({n \\choose k} \\%\\ M = {\\lfloor \\frac{n}{mod} \\rfloor \\choose   \\lfloor \\frac{k}{mod} \\rfloor} \\cdot {n \\bmod M \\choose k \\bmod M}\\ \\%\\ M\\)</li> </ul> <pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\nconst int mod = 3e6 + 17, N = 1e6 + 2;\nifstream fin(\"tupleco.in\");\nofstream fout(\"tupleco.out\");\n#define cin fin\n#define cout fout\nstruct Mint {\n    int val;\n    Mint(int x = 0) { val = x % mod; }\n    Mint(long long x) { val = x % mod; }\n    Mint operator+(Mint oth) { return val + oth.val; }\n    Mint operator*(Mint oth) { return 1LL * val * oth.val; }\n    Mint operator-(Mint oth) { return val - oth.val + mod; }\n    Mint fp(Mint a, long long n) {\n        Mint p = 1;\n        while (n) {\n            if (n &amp; 1) {\n                p = p * a;\n            }\n            a = a * a;\n            n /= 2;\n        }\n        return p;\n    }\n    Mint operator/(Mint oth) {\n        Mint invers = fp(oth, mod - 2);\n        return 1LL * val * invers.val;\n    }\n    friend ostream &amp;operator&lt;&lt;(ostream &amp;os, const Mint &amp;lol) {\n        os &lt;&lt; lol.val;\n        return os;\n    }\n};\nvector&lt;Mint&gt; f(mod), invf(mod), inv(mod);\nMint C(int n, int k) {\n    if (n &lt; 0 || k &lt; 0 || n &lt; k) {\n        return 0;\n    }\n    if (n &gt;= mod) {\n        return C(n / mod, k / mod) * C(n % mod, k % mod);\n    }\n    return f[n] * invf[n - k] * invf[k];\n}\nint n, k;\nunordered_map&lt;int, Mint&gt; mp;\nMint fr(int n) {\n    if (mp[n].val) {\n        return mp[n];\n    }\n    int dr = 2;\n    Mint total = C(n + k - 1, k);\n    while (dr &lt;= n) {\n        int ptr = n / (n / dr);\n        int lt = n / dr;\n        total = total - (fr(lt) * (ptr - dr + 1));\n        dr = ptr + 1;\n    }\n    mp[n] = total;\n    return total;\n}\nint main() {\n    f[0] = f[1] = inv[0] = inv[1] = invf[1] = invf[0] = 1;\n    for (int i = 2; i &lt; mod; i++) {\n        f[i] = f[i - 1] * i;\n        inv[i] = inv[mod % i] * (mod - mod / i);\n        invf[i] = invf[i - 1] * inv[i];\n    }\n\n    cin &gt;&gt; k &gt;&gt; n;\n    cout &lt;&lt; fr(n);\n}\n</code></pre>","tags":["matematica","combinatorica","multimi","implementare"]},{"location":"dificil/mobius/#probleme-suplimentare","title":"Probleme suplimentare","text":"<ul> <li>ONI 2021 Baraj Seniori Pastile</li> <li>Lot 2023 Juniori countall</li> <li>RoAlgo Contest #8 Gya-chan and the gcd   operation</li> <li>USACO Gold   Cowpability</li> <li>List\u0103 de probleme cu Mobius</li> <li>Sum of gcd of Tuples   (Hard)</li> </ul>","tags":["matematica","combinatorica","multimi","implementare"]},{"location":"dificil/mobius/#bibliografie-si-lectura-suplimentara","title":"Bibliografie \u0219i lectur\u0103 suplimentar\u0103","text":"<ul> <li>Math note \u2014 M\u00f6bius inversion</li> <li>M\u00f6bius Function</li> <li>Prefix Sums of Multiplicative   Functions</li> <li>M\u00f6bius inversion   formula</li> </ul>","tags":["matematica","combinatorica","multimi","implementare"]},{"location":"dificil/output-only/","title":"Probleme output only","text":"","tags":["output only"]},{"location":"dificil/output-only/#introducere","title":"Introducere","text":"<p>La olimpiadele de informatic\u0103, de\u0219i apar mult mai rar fa\u021b\u0103 de problemele de tip batch sau chiar \u0219i problemele interactive, problemele output-only \u0219i communication se reg\u0103sesc \u00een anumite olimpiade de informatic\u0103, \u00eempreun\u0103 cu aplica\u021biile lor specifice.</p> <p>La fel ca la problemele interactive, avem de-a face cu un stil specific, \u00een care trebuie s\u0103 folosim informa\u021bia dat\u0103 \u00een enun\u021b pentru a g\u0103si optimiz\u0103ri, de regul\u0103 bazate pe abord\u0103ri de tip brute-force, euristici, uneori chiar \u0219i abord\u0103ri randomizate, care s\u0103 ne duc\u0103 la r\u0103spunsuri c\u00e2t mai bune sau optime.</p> <p>De asemenea, aceste probleme testeaz\u0103 la maxim creativitatea concuren\u021bilor, reg\u0103sindu-se la concursurile de cel mai \u00eenalt nivel, precum IOI, CEOI, JOI.</p>","tags":["output only"]},{"location":"dificil/output-only/#probleme-output-only","title":"Probleme output-only","text":"<p>De\u0219i acest tip de probleme nu apare prea des la concursuri, totu\u0219i \u00een ultimii ani au \u00eenceput s\u0103 apar\u0103 tot mai des aceste tipuri de probleme, cel mai notabil exemplu fiind IOI 2017 Nowruz.</p> <p>Aceste tipuri de probleme, fiind complet diferite fa\u021b\u0103 de celelalte, necesit\u0103 o abordare special\u0103. C\u00e2teva din cele mai utile sfaturi pentru aceste tipuri de probleme sunt urm\u0103toarele:</p> <ul> <li>Aceste probleme nu au \u00een general solu\u021bii optime \u0219i rapide.</li> <li>Trebuie g\u0103sit un echilibru \u00eentre acurate\u021be \u0219i viteza programului.</li> <li>Studia\u021bi formula de scor \u0219i datele de intrare cu aten\u021bie, iar pentru cazurile mici, rezolvarea de m\u00e2n\u0103 poate fi foarte util\u0103.</li> <li>Ob\u021binerea scorurilor par\u021biale este foarte u\u0219oar\u0103 \u0219i important\u0103.</li> <li>Abord\u0103ri precum greedy, brute force \u0219i algoritmi probabilistici/aproximativi sunt foarte populare pentru aceste probleme.</li> <li>E foarte important ca \u00een timp ce l\u0103sa\u021bi programul s\u0103 ruleze timp de acele c\u00e2teva minute bune, s\u0103 v\u0103 g\u00e2ndi\u021bi la celelalte probleme pentru a nu pierde timp de implementare \u0219i de g\u00e2ndire aiurea.</li> </ul>","tags":["output only"]},{"location":"dificil/output-only/#probleme-communication-two-step","title":"Probleme communication (two-step)","text":"<p>Pentru aceste probleme, trebuie scrise dou\u0103 programe care de multe ori se bazeaz\u0103 pe codificarea/decodificarea unor date de intrare care s\u0103 permit\u0103 celor dou\u0103 programe s\u0103 interac\u021bioneze \u00eentre ele respect\u00e2nd limite stricte \u00een ceea ce prive\u0219te cantitatea de informa\u021bie transmis\u0103, deci se impune transmiterea c\u00e2t mai eficient\u0103 pentru al doilea program a informa\u021biilor pe care primul program le prime\u0219te \u0219i le calculeaz\u0103.</p> <p>De\u0219i nu exist\u0103 foarte multe probleme de acest gen, ce se poate remarca la ele este faptul c\u0103 de multe ori, e bine s\u0103 \u00eencepem cu restric\u021bii mai relaxate \u0219i s\u0103 ajungem \u00eencet-\u00eencet la solu\u021bie. Totu\u0219i, problemele de acest gen tind s\u0103 fie mai dificile \u0219i mai degrab\u0103 ceva ce se reg\u0103sesc mai des la seniori dec\u00e2t la juniori. Dintre cele mai bune moduri de a aborda problema voi enumera urm\u0103toarele.</p> <ul> <li>Folosirea ideilor de la alte probleme rezolvate poate ajuta.</li> <li>De multe ori, dac\u0103 problema nu e chiar u\u0219oar\u0103, ob\u021binerea unui punctaj par\u021bial \u0219i revenirea la problem\u0103 dup\u0103 ob\u021binerea punctajelor mai bune la celelalte probleme poate fi o strategie rezonabil\u0103.</li> <li>Reprezent\u0103rile binare, folosirea diverselor opera\u021bii matematice sau gruparea valorilor \u00een diverse moduri de a le cripta sunt foarte utile la acest tip de probleme.</li> </ul> <p>Aici pute\u021bi g\u0103si exemple de probleme explicate.</p>","tags":["output only"]},{"location":"dificil/output-only/#concluzii","title":"Concluzii","text":"<p>Problemele de tip output only \u0219i communication des\u0103v\u00e2r\u0219esc lista de probleme ce pot ap\u0103rea \u00een concursurile de informatic\u0103, acestea fiind cele mai rare tipuri de probleme \u00eent\u00e2lnite la concursurile de programare \u0219i nu numai.</p>","tags":["output only"]},{"location":"dificil/output-only/#probleme-suplimentare","title":"Probleme suplimentare","text":"<ul> <li>JOI 2017 Broken Device</li> <li>Lot 2022 Seniori Registers</li> <li>IOI 2017 Nowruz</li> <li>Balkan 2011 cmp</li> <li>IATI 2020 PF</li> <li>CEOI 2014 Question</li> <li>IOI 2019 Data Transfer</li> <li>IOI 2012 Last Supper</li> <li>Lot 2019 Seniori Bribe</li> <li>Probleme output only de pe kilonova</li> </ul>","tags":["output only"]},{"location":"dificil/output-only/#resurse-suplimentare","title":"Resurse suplimentare","text":"<ul> <li>Two Way Tasks</li> <li>Personal view to output-only problem in IOI</li> <li>Interactive and Communication Problems - USACO Guide</li> <li>Interactive, output only &amp; Communication Task - HKOI</li> </ul>","tags":["output only"]},{"location":"dificil/permutations-dp/","title":"Programare dinamic\u0103 pe permut\u0103ri","text":"","tags":["programare dinamica","permutari","DP"]},{"location":"dificil/permutations-dp/#introducere","title":"Introducere","text":"<p>\u00cen acest articol, vom discuta o serie de probleme care implic\u0103 aplicarea diverselor recuren\u021be specifice program\u0103rii dinamice pentru problemele care au la baz\u0103 permut\u0103ri. \u00cen cele mai multe cazuri, problemele sunt de tipul celor de num\u0103rare, \u00een care vrem s\u0103 afl\u0103m fie c\u00e2te permut\u0103ri \u00eendeplinesc un anumit criteriu, fie care este a \\(k\\)-a permutare care \u00eendepline\u0219te un criteriu dat. De\u0219i articolul se va concentra pe aplica\u021biile din algoritmic\u0103, aceste tipuri de solu\u021bii pot fi utile \u0219i pentru anumite tipuri de probleme care se dau la competi\u021biile de matematic\u0103.</p> <p>Chiar dac\u0103 aceste probleme nu sunt dintre cele mai des \u00eent\u00e2lnite la competi\u021bii, modul de g\u00e2ndire a acestor rezolv\u0103ri poate deveni folositor \u0219i \u00een ceea ce prive\u0219te alte tipuri de aplica\u021bii, precum cele de la range dp.</p> <p>Ca o remarc\u0103, ne vom concentra mai ales pe probleme care nu pot fi rezolvate folosind formule combinatoriale, dar vom prezenta c\u00e2teva exemple care au mai multe abord\u0103ri, pentru a u\u0219ura \u00een\u021belegerea acestei metode. De asemenea, de\u0219i exist\u0103 \u0219i alte tipuri de probleme care se reduc la formalizarea permut\u0103rilor folosind recuren\u021be specifice program\u0103rii dinamice, le vom discuta \u00een articolele specifice lor, precum aflarea num\u0103rului de cicluri hamiltoniene, iar \u00een general, cunoa\u0219terea dinamicii pe st\u0103ri exponen\u021biale este necesar\u0103 pentru \u00een\u021belegerea acestei tehnice.</p> <p>\u00cen general, pentru a rezolva aceste tipuri de probleme, ne vom concentra pe c\u00e2teva tehnici care se reg\u0103sesc \u00een mare parte dintre aceste probleme. Dintre cele mai frecvente varia\u021bii, \u00eent\u00e2lnim urm\u0103toarele \u00een mod frecvent \u00een acest tip de probleme:</p> <ul> <li>Ad\u0103ugarea pe r\u00e2nd a valorilor \\(1, 2, 3, \\dots, n\\) \u00een permutare pe diverse   pozi\u021bii.</li> <li>Ad\u0103ugarea pe r\u00e2nd a valorilor \\(n, n-1, n-2, \\dots, 1\\) \u00een permutare pe diverse   pozi\u021bii.</li> <li>Construirea secven\u021bial\u0103 a permut\u0103rii folosindu-ne de ordinea relativ\u0103.</li> <li>Aflarea num\u0103rului de solu\u021bii gre\u0219ite \u0219i sc\u0103derea lor din cele corecte.</li> </ul> <p>\u00cen cele ce urmeaz\u0103, vom prezenta diverse exemple de probleme \u0219i modul de a aplica aceste principii. Uneori, vom avea nevoie de calcularea altor recuren\u021be, iar cunoa\u0219terea formulelor de la combinatoric\u0103 este obligatorie.</p>","tags":["programare dinamica","permutari","DP"]},{"location":"dificil/permutations-dp/#problema-1-perm-infoarena","title":"Problema 1 - perm - infoarena","text":"<p>Pentru a rezolva aceast\u0103 problem\u0103, vom \u00eencerca s\u0103 construim permutarea pas cu pas, cresc\u00e2ndu-i lungimea cu 1. Dup\u0103 cum \u0219tim, prima pozi\u021bie va fi mereu o valoare maxim\u0103, lucru ce va fi esen\u021bial \u00een solu\u021bia pe care o vom prezenta \u00een cele ce urmeaz\u0103.</p> <p>Astfel, dac\u0103 avem o permutare de lungime \\(i\\) cu \\(j\\) maxime, vrem s\u0103 putem construi o permutare de lungime \\(i+1\\) \u00eentr-un mod care s\u0103 ne u\u0219ureze calculul maximelor. Mai \u00eent\u00e2i, inserarea lui \\(i+1\\) \u00een permutare ar face lucrurile anevoioase, deoarece \u00een func\u021bie de pozi\u021bia \u00een care este inserat, num\u0103rul de maxime ar putea lua orice valoare de la 1 la \\(j+1\\), lucru ce face aceast\u0103 abordare nepractic\u0103.</p> <p>Totu\u0219i, ne putem g\u00e2ndi \u0219i altfel \u00een ceea ce prive\u0219te generarea unei permut\u0103ri de lungime \\(i+1\\). \u00cen loc s\u0103 inser\u0103m \\(i+1\\) undeva \u00een permutare, vrem s\u0103 plec\u0103m de la inserarea lui 1, lucru ce \u00eel putem face cu u\u0219urin\u021b\u0103 dac\u0103 ne g\u00e2ndim la permutarea pe care o avem, presupun\u00e2nd toate valorile mai mari cu 1. De exemplu, dac\u0103 permutarea curent\u0103 este \\([2, 1, 5, 3, 4]\\), noul \u0219ir ar fi \\([3, 2, 6, 4, 5]\\). Astfel, num\u0103rul de maxime, precum \u0219i pozi\u021bia lor r\u0103m\u00e2n identice, iar acum, tot ce trebuie s\u0103 facem este s\u0103 pozi\u021bion\u0103m 1 \u00een permutare.</p> <p>Deoarece 1 este cea mai mic\u0103 valoare, decizia este una foarte simpl\u0103, num\u0103rul de maxime cre\u0219te cu 1 doar dac\u0103 inser\u0103m aceast\u0103 valoare la \u00eenceputul permut\u0103rii, \u00een caz contrar acest num\u0103r r\u0103m\u00e2ne acela\u0219i. Astfel, putem s\u0103 calcul\u0103m num\u0103rul de permut\u0103ri de lungime \\(n\\) cu \\(k\\) maxime folosind urm\u0103toarea recuren\u021b\u0103:</p> \\[ dp[i][j] = (i-1) \\cdot dp[i-1][j] + dp[i-1][j-1] \\] <p>unde \\(dp[0][0] = 1\\).</p> <p>Deoarece problema necesit\u0103 numere mari, cunoa\u0219terea acestora este necesar\u0103. Mai jos pute\u021bi g\u0103si implementarea complet\u0103 a solu\u021biei problemei date.</p> <p>Solu\u021bie detaliat\u0103</p> <p>O demonstra\u021bie detaliat\u0103 a acestei abord\u0103ri, precum \u0219i leg\u0103tura cu numerele Stirling se poate g\u0103si aici.</p> <pre><code>#include &lt;cstring&gt;\n#include &lt;fstream&gt;\nusing namespace std;\nifstream f(\"perm.in\");\nofstream g(\"perm.out\");\nint k, n;\nint base = 1000 * 1000;\nint dp[202][202][202];\nint add(int A[], int B[]) {\n    for (int i = 1; i &lt;= A[0]; ++i) {\n        B[i] += A[i];\n    }\n    B[0] = max(A[0], B[0]);\n    for (int i = 1; i &lt;= B[0]; ++i) {\n        if (B[i] &gt;= base) {\n            B[i + 1]++;\n            B[i] %= base;\n            if (i == B[0]) {\n                ++B[0];\n            }\n        }\n    }\n}\nint C[202];\nvoid mul(int A[], int B[]) {\n    long long R[202];\n    memset(R, 0, sizeof(R));\n    R[0] = A[0] + B[0] - 1;\n    for (int i = 1; i &lt;= A[0]; ++i) {\n        for (int j = 1; j &lt;= B[0]; ++j) {\n            R[i + j - 1] += 1LL * A[i] * B[j];\n            if (R[i + j - 1] &gt;= base) {\n                R[0] = max(R[0], 1LL * (i + j));\n                R[i + j] += R[i + j - 1] / base;\n                R[i + j - 1] %= base;\n            }\n        }\n    }\n    for (int i = 1; i &lt;= R[0]; ++i) {\n        if (R[i] &gt;= base) {\n            R[i + 1] += R[i] / base;\n            R[i] %= base;\n            if (i == R[0]) {\n                ++R[0];\n            }\n        }\n    }\n    for (int i = 0; i &lt;= R[0]; ++i) {\n        B[i] = R[i];\n    }\n}\nint main() {\n    f &gt;&gt; n &gt;&gt; k;\n    dp[0][0][0] = dp[0][0][1] = 1;\n    for (int i = 1; i &lt;= n; ++i) {\n        for (int j = 1; j &lt;= i; ++j) {\n            add(dp[i - 1][j], dp[i][j]);\n            C[0] = 1;\n            C[1] = i - 1;\n            mul(C, dp[i][j]);\n            add(dp[i - 1][j - 1], dp[i][j]);\n        }\n    }\n    for (int i = dp[n][k][0]; i &gt;= 1; --i) {\n        if (i == dp[n][k][0]) {\n            g &lt;&lt; dp[n][k][i];\n        } else {\n            int val = base / 10;\n            while (val &gt; 1 &amp;&amp; val &gt; dp[n][k][i]) {\n                g &lt;&lt; \"0\", val /= 10;\n            }\n            g &lt;&lt; dp[n][k][i];\n        }\n    }\n    return 0;\n}\n</code></pre>","tags":["programare dinamica","permutari","DP"]},{"location":"dificil/permutations-dp/#problema-2-permutation-atcoder-dp","title":"Problema 2 - Permutation - AtCoder DP","text":"<p>Pentru a rezolva aceast\u0103 problem\u0103, vrem s\u0103 g\u0103sim o metod\u0103 de a plasa valorile \u00een permutare \u0219i de a p\u0103stra informa\u021bii suficiente pentru a putea grupa celelalte valori.</p> <p>Plasarea primei valori este u\u0219oar\u0103, putem presupune fiecare valoare de la 1 la \\(n\\) ca fiind ad\u0103ugat\u0103 \u00een permutare. Totu\u0219i, \u00eenc\u0103 nu am r\u0103spuns la \u00eentrebarea anterioar\u0103 legat de p\u0103strarea unor informa\u021bii suficiente pentru num\u0103rarea corect\u0103 a solu\u021biilor.</p> <p>Un prim pas ar fi s\u0103 ne g\u00e2ndim la p\u0103strarea num\u0103rului de valori mai mari, respectiv mai mici dec\u00e2t valoarea de la pozi\u021bia curent\u0103, astfel \u00eenc\u00e2t am putea avea o dinamic\u0103 de tipul <code>dp[i][sm][bg];</code> cu semnifica\u021bia c\u0103 am completat primele \\(i\\) valori, iar valoarea de pe pozi\u021bia \\(i\\) este mai mare dec\u00e2t \\(sm\\) valori \u0219i mai mic\u0103 dec\u00e2t \\(bg\\) valori.</p> <p>Pentru a trece de la aceast\u0103 stare la urm\u0103toarele, vom avea dou\u0103 cazuri \u00een func\u021bie de semnul de la pozi\u021bia curent\u0103.</p> <ul> <li>Dac\u0103 semnul este \\(&lt;\\), atunci vom pute actualiza toate valorile de forma   \\(dp[i][x][bg + sm - x - 1]\\), cu \\(x &lt; sm\\) (fiecare valoare nou ad\u0103ugat\u0103 este   mai mic\u0103 dec\u00e2t valoarea curent\u0103 \u00een ordinea relativ\u0103, deci poate fi mai mare   dec\u00e2t un num\u0103r mai mic de valori).</li> <li>Pe de alt\u0103 parte, dac\u0103 semnul este \\(&gt;\\), atunci vom pute actualiza toate   valorile de forma \\(dp[i][sm + bg - x - 1][x]\\), cu \\(x &lt; bg\\) (fiecare valoare   nou ad\u0103ugat\u0103 este mai mare dec\u00e2t valoarea curent\u0103 \u00een ordinea relativ\u0103, deci   poate fi mai mic\u0103 dec\u00e2t un num\u0103r mai mare de valori).</li> </ul> <p>Din p\u0103cate, complexitatea acestei abord\u0103ri este \\(\\mathcal{O}(n^4)\\), put\u00e2nd fi redus\u0103 la \\(\\mathcal{O}(n^3)\\) folosind sume par\u021biale.</p> <p>Totu\u0219i, exist\u0103 o proprietate foarte important\u0103 pe care nu am folosit-o \u00eenc\u0103, \u0219i anume faptul c\u0103 suma valorilor \\(bg\\) \u0219i \\(sm\\) va fi mereu egal\u0103 cu \\(n - i\\). Astfel, putem s\u0103 reducem num\u0103rul de dimensiuni \u0219i s\u0103 ne concentr\u0103m doar pe p\u0103strarea valorilor \\(sm\\) \u00een dinamica noastr\u0103, acest detaliu f\u0103c\u00e2nd optimizarea solu\u021biei mult mai u\u0219oar\u0103, complexitatea final\u0103 devenind \\(\\mathcal{O}(n^2)\\) dup\u0103 aplicarea sumelor par\u021biale.</p> <p>Pentru mai multe detalii de implementare, pute\u021bi citi solu\u021bia de mai jos.</p> <pre><code>#include &lt;iostream&gt;\n#include &lt;vector&gt;\n\nusing namespace std;\n\nconst int mod = 1000000007;\n\nint main() {\n    int n;\n    cin &gt;&gt; n;\n\n    string s;\n    cin &gt;&gt; s;\n\n    s = ' ' + s;\n\n    // dp[i][j] = cate permutari de lungime i exista astfel incat j valori sunt\n    // mai mici decat valoarea de pe pozitia i\n\n    vector&lt;vector&lt;long long&gt;&gt; dp(n + 1, vector&lt;long long&gt;(n + 1));\n    for (int i = 1; i &lt;= n; i++) {\n        dp[1][i - 1] = 1;\n    }\n\n    for (int i = 1; i &lt; n; i++) {\n        for (int j = 0; j &lt; n; j++) {\n            if (s[i] == '&lt;') {\n                // din dp[i][j] putem aduna in dp[i+1][0], dp[i+1][1], ...,\n                // dp[i+1][j-1]\n                dp[i + 1][0] += dp[i][j];\n                dp[i + 1][j] -= dp[i][j];\n            } else {\n                // din dp[i][j] putem aduna in dp[i+1][j], dp[i+1][j+1], ...,\n                // dp[i+1][n-i-1]\n                dp[i + 1][j] += dp[i][j];\n                dp[i + 1][n - i] -= dp[i][j];\n            }\n        }\n\n        for (int j = 0; j &lt; n; j++) {\n            if (j &gt; 0) {\n                dp[i + 1][j] += dp[i + 1][j - 1];\n            }\n            dp[i + 1][j] = dp[i + 1][j] % mod;\n            if (dp[i + 1][j] &lt; mod) {\n                dp[i + 1][j] += mod;\n            }\n        }\n    }\n\n    cout &lt;&lt; dp[n][0] % mod &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["programare dinamica","permutari","DP"]},{"location":"dificil/permutations-dp/#problema-3-kswap-lot-juniori-2015","title":"Problema 3 - kswap Lot juniori 2015","text":"<p>Pentru a rezolva aceast\u0103 problem\u0103, vom folosi din nou metoda program\u0103rii dinamice.</p> <p>Vom defini \\(dp[i][j]\\) ca fiind num\u0103rul de permut\u0103ri ale primelor \\(i\\) valori care au \\(j\\) inversiuni. Deoarece vom ad\u0103uga valorile de la 1 la \\(n\\), pentru fiecare valoare nou ad\u0103ugat\u0103, vom avea un num\u0103r de inversiuni corespunz\u0103tor cu pozi\u021bia pe care o ad\u0103ug\u0103m (dac\u0103 ad\u0103ug\u0103m pe pozi\u021bia 1, avem \\(i\\) inversiuni \u00een plus, apoi pentru pozi\u021bia 2, \\(i-1\\) etc.)</p> <p>Cu alte cuvinte, \\(dp[i][j] = \\sum_{j - i + 1}^j dp[i-1][x]\\), recuren\u021b\u0103 ce se poate calcula \u00een \\(\\mathcal{O}(n^3)\\) folosind sume par\u021biale, calculul complexit\u0103\u021bii fiind dat de num\u0103rul de elemente din permutare \\((n)\\) \u0219i de num\u0103rul maxim de inversiuni ale unei permut\u0103ri \\((\\frac{n \\cdot (n-1)}{2})\\).</p> <p>Deoarece limita de memorie este str\u00e2ns\u0103, trebuie s\u0103 p\u0103str\u0103m ultimele dou\u0103 linii ale recuren\u021bei.</p> <pre><code>#include &lt;fstream&gt;\nusing namespace std;\n\nifstream fin(\"kswap.in\");\nofstream fout(\"kswap.out\");\n\nint n, k;\n\nint dp[2][12002], sp[2][12002];\n\nconst int mod = 30103;\n\nint main() {\n    fin &gt;&gt; n &gt;&gt; k;\n\n    int mx = n * (n - 1) / 2;\n\n    dp[0][0] = 1;\n\n    for (int i = 0; i &lt;= mx; i++) {\n        sp[0][i] = dp[0][i];\n        if (i &gt; 0) {\n            sp[0][i] += sp[0][i - 1];\n        }\n    }\n\n    for (int i = 2; i &lt;= n; i++) {\n        int maxi = i * (i - 1) / 2;\n        for (int j = 0; j &lt;= maxi; j++) {\n            dp[1][j] = sp[0][j];\n\n            if (j &gt;= i) {\n                dp[1][j] -= sp[0][j - i];\n            }\n\n            if (dp[1][j] &lt; 0) {\n                dp[1][j] += mod;\n            }\n        }\n\n        for (int i = 0; i &lt;= mx; i++) {\n            sp[0][i] = dp[1][i];\n            if (i &gt; 0) {\n                sp[0][i] += sp[0][i - 1];\n            }\n\n            if (sp[0][i] &gt;= mod) {\n                sp[0][i] -= mod;\n            }\n\n            dp[0][i] = dp[1][i];\n            dp[1][i] = 0;\n        }\n    }\n\n    fout &lt;&lt; dp[0][k] &lt;&lt; '\\n';\n\n    return 0;\n}\n</code></pre>","tags":["programare dinamica","permutari","DP"]},{"location":"dificil/permutations-dp/#problema-4-kcons-lot-2010","title":"Problema 4 - kcons Lot 2010","text":"<p>Pentru a rezolva aceast\u0103 problem\u0103, putem \u00eencepe prin a analiza cazul special c\u00e2nd \\(K=1\\). Putem veni cu urm\u0103toarea solu\u021bie folosind programare dinamic\u0103:</p> <p>\\(dp[i][j]\\) = Num\u0103rul de permut\u0103ri de \\(i\\) elemente dac\u0103 exist\u0103 exact \\(j\\) perechi de elemente adiacente de forma \\(x, x+1\\).</p> <p>Solu\u021bia poate fi g\u0103sit\u0103 \u00een \\(dp[N][0]\\), iar cazul de baz\u0103 este \\(dp[1][0] = 1\\).</p> <p>C\u00e2t despre rela\u021bia de recuren\u021b\u0103, s\u0103 presupunem c\u0103 avem o stare \\((i,j)\\) \u0219i vrem s\u0103 inser\u0103m elementul \\(i+1\\). Distingem trei cazuri:</p> <ol> <li>Inser\u0103m elementul \\(i+1\\) imediat dup\u0103 elementul \\(i\\). Trebuie s\u0103 actualiz\u0103m    \\(dp[i+1][j+1]\\).</li> <li>Inser\u0103m elementul \\(i+1\\) \u00eentre una dintre cele \\(j\\) perechi de elemente    consecutive. Trebuie s\u0103 actualiz\u0103m \\(dp[i+1][j-1]\\).</li> <li>Inser\u0103m elementul \\(i+1\\) \u00een alt loc, trebuie s\u0103 actualiz\u0103m \\(dp[i+1][j]\\).</li> </ol> <p>Aceast\u0103 solu\u021bie are o complexitate de \\(\\mathcal{O}(N^2)\\).</p> <p>C\u00e2nd \\(K&gt;1\\), putem veni cu o alt\u0103 strategie de programare dinamic\u0103 pentru a reduce problema la cazul \u00een care \\(K=1\\).</p> <p>S\u0103 presupunem c\u0103 avem o permutare \u0219i o \u00eemp\u0103r\u021bim \u00een sub\u0219iruri maximale care con\u021bin elemente consecutive \u00een ordine cresc\u0103toare. De exemplu, pentru permutarea \\(7\\ 8\\ 4\\ 5\\ 6\\ 10\\ 1\\ 2\\ 9\\ 3\\), \u00eemp\u0103r\u021birea const\u0103 \u00een 6 sub\u0219iruri: \\(| 7\\ 8 | 4\\ 5\\ 6 | 10 | 1\\ 2 | 9 | 3 |\\). Trucul aici este s\u0103 num\u0103r\u0103m \u00eempreun\u0103 toate permut\u0103rile care \u00eempart acela\u0219i num\u0103r de sub\u0219iruri \u00eemp\u0103r\u021bite.</p> <p>Calcul\u0103m \\(partitions[i][j]\\) = Num\u0103rul de moduri de a \u00eemp\u0103r\u021bi primii \\(i\\) numere naturale \u00een \\(j\\) sub\u0219iruri, astfel \u00eenc\u00e2t niciunul dintre ele s\u0103 nu aib\u0103 lungimea mai mare dec\u00e2t \\(K\\). Recuren\u021ba direct\u0103 este \\(partitions[i][j] = \\sum(partitions[i-x][j-1], 1 \\leq x \\leq K)\\), dar aceasta poate fi redus\u0103 la \\(\\mathcal{O}(1)\\) u\u0219or prin calcularea sumelor par\u021biale. Acum putem num\u0103ra toate permut\u0103rile valide care constau \u00een \\(x\\) sub\u0219iruri \u00eemp\u0103r\u021bite prin calcularea \\(partitions[N][x] * dp[x][0]\\).</p> <pre><code>#include &lt;fstream&gt;\n#define mod 30013\nusing namespace std;\nifstream f(\"kcons.in\");\nofstream g(\"kcons.out\");\nint n, k, dp1[2002][2002], dp2[2002][2002], sp[2002];\nint main() {\n    f &gt;&gt; n &gt;&gt; k;\n    dp1[1][0] = 1;\n    for (int i = 2; i &lt;= n; ++i) {\n        for (int j = 0; j &lt;= i; ++j) {\n            dp1[i][j] = dp1[i - 1][j] * (i - j - 1)\n                      + (j &gt; 0) * dp1[i - 1][j - 1]\n                      + dp1[i - 1][j + 1] * (j + 1);\n            dp1[i][j] %= mod;\n        }\n    }\n    dp2[1][1] = 1;\n    dp2[0][0] = 1;\n    sp[0] = 1;\n    sp[1] = 1;\n    for (int i = 2; i &lt;= n; ++i) {\n        if (i &gt; k) {\n            for (int j = 0; j &lt;= i; ++j) {\n                sp[j] = sp[j] - dp2[i - k - 1][j];\n                if (sp[j] &lt; 0) {\n                    sp[j] += mod;\n                }\n            }\n        }\n        for (int j = i; j &gt;= 1; --j) {\n            dp2[i][j] = sp[j - 1];\n            sp[j] += dp2[i][j];\n            if (sp[j] &gt;= mod) {\n                sp[j] -= mod;\n            }\n        }\n    }\n    int ans = 0;\n    for (int i = 0; i &lt;= n; ++i) {\n        ans += dp2[n][i] * dp1[i][0];\n        ans %= mod;\n    }\n    g &lt;&lt; ans &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["programare dinamica","permutari","DP"]},{"location":"dificil/permutations-dp/#concluzii","title":"Concluzii","text":"<p>Aceste tipuri de probleme combin\u0103 dou\u0103 capitole, programarea dinamic\u0103 \u0219i combinatorica, iar modul de abordare a acestor recuren\u021be poate fi destul de dificil f\u0103r\u0103 experien\u021b\u0103 anterioar\u0103. Chiar dac\u0103 aceste probleme nu apar la fel de des precum alte probleme de programare dinamic\u0103, se dovedesc a fi provoc\u0103ri interesante \u0219i de multe ori, dificile, duc\u00e2nd \u0219i la alte idei interesante, a\u0219a cum vom discuta \u00een articolul despre subtehnica connected component DP, care are la baz\u0103 problemele din aceast\u0103 categorie.</p>","tags":["programare dinamica","permutari","DP"]},{"location":"dificil/permutations-dp/#probleme-suplimentare","title":"Probleme suplimentare","text":"<ul> <li>infoarena perm3</li> <li>ONI 2008 pviz</li> <li>ONI 2010 kmax</li> <li>Codeforces Greg and Caves</li> <li>Codeforces Positions in   Permutations</li> <li>Lot 2002 doipatru</li> <li>infoarena perm4</li> </ul>","tags":["programare dinamica","permutari","DP"]},{"location":"dificil/permutations-dp/#resurse-suplimentare","title":"Resurse suplimentare","text":"<ul> <li>[Tutorial] Non-trivial DP Tricks and Techniques -   Codeforces</li> </ul>","tags":["programare dinamica","permutari","DP"]},{"location":"dificil/pow-mat/","title":"Ridicare la putere a unei matrici","text":"<p>Daca vreti sa ne ajutati cu acest articol, ne puteti gasi pe github sau pe serverul nostru de discord</p> <p>Mai jos g\u0103si\u021bi resurse pe care le pute\u021bi citi p\u00e2n\u0103 atunci.</p>","tags":["matematica","exponentiere","matrici"]},{"location":"dificil/pow-mat/#introducere","title":"Introducere","text":"","tags":["matematica","exponentiere","matrici"]},{"location":"dificil/pow-mat/#problema-exemplu","title":"Problema exemplu","text":"","tags":["matematica","exponentiere","matrici"]},{"location":"dificil/pow-mat/#concluzii","title":"Concluzii","text":"","tags":["matematica","exponentiere","matrici"]},{"location":"dificil/pow-mat/#probleme-suplimentare","title":"Probleme suplimentare","text":"","tags":["matematica","exponentiere","matrici"]},{"location":"dificil/pow-mat/#resurse-suplimentare","title":"Resurse suplimentare","text":"","tags":["matematica","exponentiere","matrici"]},{"location":"dificil/problemsetting/","title":"Cum propui \u0219i preg\u0103te\u0219ti o problem\u0103?","text":"","tags":["meta","sfaturi","comisie","olimpiada"]},{"location":"dificil/problemsetting/#introducere","title":"Introducere","text":"<p>Ai rezolvat foarte multe probleme \u0219i poate \u021bi-ai pus \u00eentrebarea: \"Oare nu cumva pot \u0219i eu s\u0103 creez o problem\u0103 la r\u00e2ndul meu?\" R\u0103spunsul este afirmativ, oricine poate crea o problem\u0103 nou\u0103, dar a\u0219a cum se \u00eent\u00e2mpl\u0103 \u0219i atunci c\u00e2nd ne g\u00e2ndim la idei pentru rezolvarea problemelor, nu toate ideile sunt bune (a se citi originale), iar de asemenea, vrem de preferat s\u0103 evit\u0103m situa\u021bia \u00een care o problem\u0103 s\u0103 se reduc\u0103 la alt\u0103 problem\u0103, deja dat\u0103 la un concurs anterior.</p> <p>\u00cen acest articol voi discuta c\u00e2teva aspecte pe care le pute\u021bi avea \u00een vedere atunci c\u00e2nd crea\u021bi probleme noi, astfel \u00eenc\u00e2t acestea s\u0103 ajung\u0103 s\u0103 fie date fie la concursuri de informatic\u0103, fie de ce nu s\u0103 le folosi\u021bi \u00eentr-un mod mai educa\u021bional pentru diferite proiecte (inclusiv arhiva noastr\u0103!).</p>","tags":["meta","sfaturi","comisie","olimpiada"]},{"location":"dificil/problemsetting/#crearea-ideilor-pentru-probleme","title":"Crearea ideilor pentru probleme","text":"<p>De\u0219i aceasta este cea mai grea parte a propunerii unei probleme, este \u0219i cea mai interesant\u0103 \u0219i pl\u0103cut\u0103, deoarece de\u0219i nu multe idei sunt complet originale, exist\u0103 foarte moduri de a ajunge la idei valoroase care s\u0103 fie folosite \u00een competi\u021bii. De remarcat este faptul c\u0103 acest proces trebuie s\u0103 fie c\u00e2t mai natural, iar metodele artificiale trebuie evitate c\u00e2t de mult posibil.</p> <p>C\u00e2teva dintre cele mai frecvent \u00eent\u00e2lnite surse de inspira\u021bie pentru crearea unor probleme noi de algoritmic\u0103 sunt:</p> <ul> <li>imaginarea unui anumit proces (real sau imaginar) \u0219i adaptarea lui la un model informatic. Cu alte cuvinte, se poate \u00eent\u00e2mpla s\u0103 vede\u021bi ceva interesant \u00een via\u021ba real\u0103 sau \u00eentr-un joc video \u0219i pe baza acestei secven\u021be de evenimente, s\u0103 crea\u021bi o poveste care s\u0103 v\u0103 duc\u0103 la o idee de problem\u0103. Aceasta este una dintre cele mai naturale moduri \u00een care o problem\u0103 ajunge s\u0103 fie creat\u0103, iar multe dintre problemele foarte bune \u0219i apreciate de concuren\u021bi sunt create a\u0219a.</li> <li>rezolvarea unor probleme anterioare \u0219i dezvoltarea unor versiuni mai grele sau diferite fa\u021b\u0103 de cele originale, care uneori au chiar solu\u021bii complet diferite. \u00cen multe situa\u021bii, deoarece rezolva\u021bi multe probleme de algoritmic\u0103, ajunge\u021bi s\u0103 v\u0103 g\u00e2ndi\u021bi la multe idei \u0219i inevitabil, v\u0103 g\u00e2ndi\u021bi \u0219i la alte abord\u0103ri care chiar dac\u0103 nu sunt strict legate de problema pe care \u00eencerca\u021bi s\u0103 o rezolva\u021bi, v\u0103 pot duce la idei alternative care \u00een unele situa\u021bii, pot deveni chiar o problem\u0103 complet diferit\u0103. Aceast\u0103 abordare este folosit\u0103 foarte des de cei care sunt experimenta\u021bi \u0219i g\u0103sesc foarte u\u0219or varia\u021bii noi la problemele deja existente.</li> <li>crearea unei probleme pe baza unei pove\u0219ti sau idei \u00eentip\u0103rite \u00een minte (de exemplu, g\u00e2ndirea la o problem\u0103 de dinamic\u0103 care are leg\u0103tur\u0103 cu un anume joc). De\u0219i aceast\u0103 metod\u0103 ne ajut\u0103 s\u0103 cre\u0103m probleme care pot deveni bune, \u00een multe situa\u021bii problemele create prin aceast\u0103 metod\u0103 nu sunt la fel de valoroase ca cele create prin primele dou\u0103 metode, dar cu rafinare \u0219i eventual mici (sau mai mari) ajust\u0103ri, se pot ob\u021bine idei frumoase.</li> </ul> <p>Chiar dac\u0103 \u00een aceste paragrafe am men\u021bionat no\u021biunea de problem\u0103 original\u0103 \u0219i cea de problem\u0103 interesant\u0103, concursurile au nevoie de multe ori \u0219i de probleme care s\u0103 testeze \u00eentr-o anumit\u0103 m\u0103sur\u0103 cuno\u0219tin\u021be precum cea de implementare sau cele de casework, iar de aceea poate ve\u021bi vedea mai ales \u00een cadrul problemelor mai u\u0219oare, idei care de\u0219i par standard sau repetitive pentru concuren\u021bii experimenta\u021bi, sunt foarte utile pentru audien\u021ba \u021bint\u0103 a problemelor respective. Acest lucru se \u00eent\u00e2mpl\u0103 la rundele de Codeforces cu probleme u\u0219oare sau la competi\u021bii precum IIOT, unde comisia trebuie s\u0103 creeze un set de probleme cu o gam\u0103 de dificultate foarte larg\u0103.</p> <p>\u00cenainte de a propune o idee pentru un concurs, este indicat s\u0103 verifica\u021bi dac\u0103 s-a mai dat aceea\u0219i problem\u0103 anterior la un alt concurs, \u00een special la o competi\u021bie recent\u0103. Pentru verificarea \u00eentr-o baz\u0103 de date interna\u021bional\u0103, exist\u0103 siteul yuantiji unde se poate pune cerin\u021ba problemei \u00een englez\u0103 \u0219i \u00ee\u021bi potrive\u0219te enun\u021bul cu posibile probleme asem\u0103n\u0103toare.</p> <p>Apoi, po\u021bi trimite problema unui coordonator (de preferat, cu un enun\u021b scurt, 1-2 exemple \u0219i o idee a solu\u021biei) sau unor prieteni \u0219i poate ajunge chiar \u00een urm\u0103torul concurs de profil, fie c\u0103 este olimpiad\u0103, concurs online sau alt proiect.</p>","tags":["meta","sfaturi","comisie","olimpiada"]},{"location":"dificil/problemsetting/#crearea-unui-enunt-clar","title":"Crearea unui enun\u021b clar","text":"<p>S\u0103 presupunem c\u0103 problema a fost selectat\u0103 de unul sau mai mul\u021bi coordonatori \u0219i trebuie s\u0103 fie preg\u0103tit\u0103. Primul pas \u00een preg\u0103tirea problemei const\u0103 \u00een crearea unui enun\u021b c\u00e2t mai clar (de preferat \u00een format \\(\\LaTeX\\)), care s\u0103 con\u021bin\u0103 toate detaliile necesare pentru to\u021bi cititorii, precum restric\u021bii, preciz\u0103ri, eventuale punctaje par\u021biale \u0219i exemple clare \u0219i cuprinz\u0103toare \u00een limita preferin\u021bei propun\u0103torilor. De asemenea, este indicat ca exemplele s\u0103 vin\u0103 cu explica\u021bii care s\u0103 u\u0219ureze \u00een\u021belegerea lor.</p> <p>Un enun\u021b ideal este destul de scurt, la obiect \u0219i cu o poveste minim\u0103, dar care s\u0103 nu fie intruziv sau artificial ad\u0103ugat\u0103. Povestea poate fi s\u0103rit\u0103 dac\u0103 nu se dore\u0219te acest lucru, dar de multe ori, un anumit personaj din probleme poate deveni celebru \u00een acest fel (de exemplu, foarte multe probleme au un Gigel \u00een cerin\u021ba lor).</p>","tags":["meta","sfaturi","comisie","olimpiada"]},{"location":"dificil/problemsetting/#crearea-testelor","title":"Crearea testelor","text":"<p>Urm\u0103torul pas const\u0103 \u00een crearea unui set de date de intrare c\u00e2t mai cuprinz\u0103toare, care s\u0103 testeze sursele concuren\u021bilor c\u00e2t mai bine. Acest lucru se face cre\u00e2nd c\u00e2t mai multe teste care s\u0103 respecte c\u00e2t mai multe tipuri de restric\u021bii \u0219i de particularit\u0103\u021bi.</p> <p>\u00cen primul r\u00e2nd, trebuie s\u0103 ave\u021bi teste cu dimensiunile datelor c\u00e2t mai diverse, \u00eencep\u00e2nd de la cele mai mici seturi posibile (teste cu valori ale lui \\(N\\) foarte mici \u0219i alte valori mici), p\u00e2n\u0103 la teste cu valori maxime pentru datele de intrare.</p> <p>De asemenea, \u00een func\u021bie de tipul de probleme de care vorbim, ne putem g\u00e2ndi la cazuri particulare pe care trebuie s\u0103 le includem neap\u0103rat \u00een testele de evaluare, printre altele voi enumera urm\u0103toarele:</p> <ul> <li>teste cu \\(N = 1\\) \u0219i \\(N = 2\\) (cu alte cuvinte, teste cu \\(N\\) minim).</li> <li>teste cu valori foarte mici (v\u0103 pot ajuta s\u0103 detecta\u021bi eventualele gre\u0219eli \u00een solu\u021bia voastr\u0103 \u00een procesul de preg\u0103tire).</li> <li>dup\u0103 caz, teste care s\u0103 aib\u0103 o structur\u0103 particular\u0103 (multe valori distincte, pu\u021bine valori distincte, seturi cu multe valori egale etc.)</li> <li>dac\u0103 vorbim de probleme de grafuri, teste cu grafuri complete, arbori, lan\u021buri, grafuri de tip stea (un nod din care se creaz\u0103 mai multe lan\u021buri), grafuri aciclice etc.</li> <li>dac\u0103 vorbim de probleme de arbori, teste care s\u0103 includ\u0103 arbori binari, arbori lan\u021b, arbori stea, arbori cu o \u00een\u0103l\u021bime mare etc.</li> <li>dac\u0103 vorbim de probleme cu divizori \u0219i/sau teoria numerelor, vrem s\u0103 avem numere prime, numere cu mul\u021bi divizori, numere cu mul\u021bi factori primi etc.</li> <li>\u00een cazul problemelor cu structuri de date, vrem s\u0103 avem queryuri c\u00e2t mai variate, care s\u0103 aib\u0103 lungimi mari, lungimi mici, lungimi variate, care s\u0103 acopere c\u00e2t mai multe tipuri de restric\u021bii.</li> <li>dac\u0103 avem de-a face cu corner cases, acestea trebuie incluse \u00een \u00eentregime.</li> </ul> <p>Nu \u00een ultimul r\u00e2nd, dac\u0103 ave\u021bi posibilitatea \u0219i tipul problemei v\u0103 permite acest lucru, nu ezita\u021bi s\u0103 face\u021bi problema una de tip multi-test (cu un parametru \\(t\\) la \u00eenceputul datelor de intrare pentru a putea include un num\u0103r mare de teste, \u00een special cu date mici, \u00een cadrul unui singur fi\u0219ier test).</p>","tags":["meta","sfaturi","comisie","olimpiada"]},{"location":"dificil/problemsetting/#generatorul-de-teste","title":"Generatorul de teste","text":"<p>Pentru a genera teste, recomand\u0103m folosirea toolurilor din Polygon, fiind cel mai inovativ mod de a genera teste la ora actual\u0103.</p> <p>Tutorial Polygon</p> <p>Recomand\u0103m citirea acestui blog pentru o introducere scurt\u0103, sau a acestuia pentru ceva mai cuprinz\u0103tor.</p> <p>Polygon este o platform\u0103 dezvoltat\u0103 de Mike Mirzayanov, creatorul Codeforces \u0219i este unul dintre cele mai importante medii folosite \u00een zilele noastre pentru dezvoltarea problemelor date la concursurile de programare competitiv\u0103 din \u00eentreaga lume. Aceast\u0103 platform\u0103 face acest proces mult mai pu\u021bin anevoios, iar de asemenea permite \u0219i o adaptare u\u0219oar\u0103 la cerin\u021bele altor interfa\u021be de concurs (CMS / DomJudge etc.).</p> <p>Pe l\u00e2ng\u0103 platform\u0103 \u00een sine, exist\u0103 \u0219i biblioteca testlib.h care reprezint\u0103 resursa folosit\u0103 cel mai frecvent de cei care lucreaz\u0103 \u00een Polygon pentru crearea problemelor, bibliotec\u0103 care u\u0219ureaz\u0103 foarte mult procesul de generat date de intrare \u0219i generat teste, folosind interfa\u021ba Polygon.</p> <p>Pentru a apela un generator numit gen, trebuie s\u0103 folosim instruc\u021biuni de tipul \\(gen \\ par_1 \\ par_2 \\dots \\ par_k\\) &gt; $.</p> <p>Pentru codul de mai jos unde se genereaz\u0103 un \u0219ir de lungime \\(n\\), putem s\u0103 d\u0103m ca parametri \u00een sec\u021biunea tests urm\u0103toarele date.</p> <pre><code>#include &lt;iostream&gt;\n#include &lt;map&gt;\n#include &lt;vector&gt;\n\n#include \"testlib.h\"  // biblioteca necesara\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n    int n = atoi(argv[1]);   // parametrii in ordinea folositi\n    std::cout &lt;&lt; n &lt;&lt; endl;  // pentru a se sari la urmatoarea linie, se\n                             // foloseste neaparat endl\n\n    std::vector&lt;int&gt; v;\n\n    for (int i = 1; i &lt;= n; i++) {\n        int x = rnd.next(1, 1000);\n        std::cout &lt;&lt; x;\n        if (i\n            != n) {  // trebuie avut grija la spatiile suplimentare de la final\n            std::cout &lt;&lt; \" \";\n        }\n        v.push_back(x);\n    }\n\n    std::cout &lt;&lt; std::endl;\n    std::shuffle(v.begin(), v.end());  // amestecarea elementelor din vector\n    println(v);  // afisarea unui intreg vector, punandu-se si endl\n}\n</code></pre>","tags":["meta","sfaturi","comisie","olimpiada"]},{"location":"dificil/problemsetting/#checkere-si-validatoare","title":"Checkere \u0219i validatoare","text":"<p>Polygon pune la dispozi\u021bie o gam\u0103 larg\u0103 de checkere utlizatorilor, acestea av\u00e2nd \u0219i descrieri detaliate. De asemenea, se pot scrie \u0219i checkere manual, av\u00e2nd grij\u0103 s\u0103 se respecte diferite particularit\u0103\u021bi ale tipului de solu\u021bie cerut. Ideea de baz\u0103 este aceea de a se verifica dac\u0103 r\u0103spunsul dat de utilizator respect\u0103 toate restric\u021biile problemei \u0219i dac\u0103 este corect pentru testul dat.</p> <p>Checkerele puse la dispozi\u021bie de ei sunt urm\u0103toarele:</p> <ul> <li>fcmp.cpp - verific\u0103 liniile, nu ignor\u0103 spa\u021biile goale</li> <li>hcmp.cpp - potrivit pentru numere mari</li> <li>lcmp.cpp - verific\u0103 liniile, ignor\u0103 spa\u021biile goale</li> <li>ncmp.cpp - unul sau mai multe numere de tip long long, ignor\u0103 spa\u021biile goale</li> <li>nyesno.cpp - zero sau mai multe YES/NO, nu \u021bine cont de litere mari sau mici</li> <li>rcmp4.cpp - unul sau mai multe numere reale, eroarea maxim\u0103 \\(10^{-4}\\).</li> <li>rcmp6.cpp - unul sau mai multe numere reale, eroarea maxim\u0103 \\(10^{-6}\\).</li> <li>rcmp9.cpp - unul sau mai multe numere reale, eroarea maxim\u0103 \\(10^{-9}\\).</li> <li>wcmp.cpp - secven\u021b\u0103 de tokens</li> <li>yesno.cpp - un singur YES/NO, nu \u021bine cont de litere mari sau mici</li> </ul> <p>Cele mai des folosite checkere sunt lcmp, nyesno \u0219i rcmp9. Celelalte checkere sunt \u0219i ele utile dup\u0103 caz.</p> <p>Totu\u0219i, \u00een anumite situa\u021bii avem nevoie s\u0103 scriem ni\u0219te checkere mai specifice, pentru a verifica corectitudinea r\u0103spunsurilor date de participan\u021bi. Pentru a face asta, trebuie s\u0103 folosim un set de parametri specifici, care s\u0103 returneze -1 dac\u0103 avem un r\u0103spuns gre\u0219it.</p> <p>Mai jos ave\u021bi un exemplu de checker specific pentru codeforces. De asemenea, pute\u021bi consulta aici \u0219i exemple specifice pentru kilonova.</p> <pre><code>#include &lt;cassert&gt;\n#include &lt;iostream&gt;\n#include &lt;string&gt;\n#include &lt;vector&gt;\n\n#include \"testlib.h\"\n\nusing namespace std;\n\nint n, len;\nstring s;\nint main(int argc, char* argv[]) {\n    registerTestlibCmd(argc, argv);\n    n = inf.readInt();\n    len = ouf.readInt();\n    ouf.readEoln();\n    s = ouf.readLine();\n    if (len &gt; 2 * n) {\n        quitf(_wa, \"The length is too big\");\n    }\n    if (len != s.size()) {\n        quitf(_wa, \"Wrong length\");\n    }\n    if (s[0] == '0') {\n        quitf(_wa, \"The number has leading zeroes\");\n    }\n    int rest = 0;\n    for (int i = 0; i &lt; s.size(); ++i) {\n        rest = (rest * 10 + (s[i] - '0')) % n;\n    }\n    if (rest != 0) {\n        quitf(_wa, \"The number is not a multiple of n\");\n    }\n    quitf(_ok, \"The number is good\");\n    return 0;\n}\n</code></pre> <p>De\u0219i testlib.h nu d\u0103 erori \u00een ceea ce prive\u0219te generarea datelor, scrierea unui validator este o idee foarte bun\u0103 deoarece se previn erori nedorite la generarea datelor \u0219i posibile bug-uri la scrierea parametrilor pentru generarea valorilor prezente \u00een datele de intrare.</p> <p>Pentru mai multe informatii, se poate accesa acest blog.</p>","tags":["meta","sfaturi","comisie","olimpiada"]},{"location":"dificil/problemsetting/#testarea-solutiilor-si-incarcarea-testelor","title":"Testarea solu\u021biilor \u0219i \u00eenc\u0103rcarea testelor","text":"<p>Aceasta se poate face \u00een multe moduri, fie folosind infrastructura polygon, fie infrastructura platformei de evaluare, \u0219i este important ca de fiecare dat\u0103 c\u00e2nd g\u0103si\u021bi o solu\u021bie care ar trebui s\u0103 ob\u021bin\u0103 un anumit num\u0103r de puncte dar ob\u021bine mai multe puncte (sau trece testele c\u00e2nd nu ar trebui s\u0103 treac\u0103), atunci \u00eenseamn\u0103 c\u0103 trebuie \u00eembun\u0103t\u0103\u021bite testele.</p>","tags":["meta","sfaturi","comisie","olimpiada"]},{"location":"dificil/problemsetting/#concluzii","title":"Concluzii","text":"<p>Crearea unei probleme este un proces care de\u0219i pare complicat, este unul foarte frumos \u0219i plin de satisfac\u021bie. De asemenea, propusul de probleme te poate ajuta s\u0103 g\u0103se\u0219ti cazuri particulare \u0219i s\u0103-\u021bi \u00eembun\u0103t\u0103\u021be\u0219ti abilit\u0103\u021bile de depanare a solu\u021biilor. Nu \u00een ultimul r\u00e2nd, po\u021bi ajunge s\u0103 propui probleme la diferite concursuri sau poate chiar la olimpiadele de informatic\u0103, ceea ce poate fi o experien\u021b\u0103 frumoas\u0103 \u00een sine. Te a\u0219tept\u0103m \u0219i pe tine s\u0103 propui probleme, poate chiar la concursurile marca RoAlgo.</p>","tags":["meta","sfaturi","comisie","olimpiada"]},{"location":"dificil/problemsetting/#resurse-suplimentare","title":"Resurse suplimentare","text":"<ul> <li>Problem guide - kilonova</li> <li>Polygon Guide - Stefan Dascalescu</li> <li>Polygon.Codeforces Tutorial - A Guide to Problem Preparation [Part 1]</li> <li>Sectiunea testlib - codeforces</li> <li>On problemsetting - codeforces</li> <li>Problemsetting - oiwiki</li> </ul>","tags":["meta","sfaturi","comisie","olimpiada"]},{"location":"dificil/random-algorithms/","title":"Algoritmi randomiza\u021bi","text":"<p>Daca vreti sa ne ajutati cu acest articol, ne puteti gasi pe github sau pe serverul nostru de discord</p> <p>Mai jos g\u0103si\u021bi resurse pe care le pute\u021bi citi p\u00e2n\u0103 atunci.</p>","tags":["randomizare","euristici"]},{"location":"dificil/random-algorithms/#introducere","title":"Introducere","text":"","tags":["randomizare","euristici"]},{"location":"dificil/random-algorithms/#problema-exemplu","title":"Problema exemplu","text":"","tags":["randomizare","euristici"]},{"location":"dificil/random-algorithms/#concluzii","title":"Concluzii","text":"","tags":["randomizare","euristici"]},{"location":"dificil/random-algorithms/#probleme-suplimentare","title":"Probleme suplimentare","text":"","tags":["randomizare","euristici"]},{"location":"dificil/random-algorithms/#resurse-suplimentare","title":"Resurse suplimentare","text":"","tags":["randomizare","euristici"]},{"location":"dificil/range-dp/","title":"Programare dinamic\u0103 pe intervale (range DP)","text":"<p>\u00cen acest articol vom prezenta modul \u00een care aplic\u0103m tehnica program\u0103rii dinamice atunci c\u00e2nd vine vorba de a afla diverse r\u0103spunsuri minime sau maxime pentru \u0219iruri cu o lungime relativ mic\u0103 (de regul\u0103, cel mult 500), folosind drept st\u0103ri anterioare subsecven\u021be de lungime mai mic\u0103 ale \u0219irului dat.</p> <p>Aceast\u0103 tehnic\u0103 este numit\u0103 \u00een specialitate range dp, fiind g\u0103sit\u0103 \u00een articolele rom\u00e2ne\u0219ti \u0219i sub numele de metoda mixt\u0103 a program\u0103rii dinamice.</p>","tags":["programare dinamica","intervale"]},{"location":"dificil/range-dp/#conditii-necesare","title":"Condi\u021bii necesare","text":"<p>Aceast\u0103 tehnic\u0103 apare preponderent \u00een probleme care respect\u0103 c\u00e2t mai multe din condi\u021biile men\u021bionate aici, implementarea \u0219i modul de g\u00e2ndire al st\u0103rilor \u0219i tranzi\u021biilor fiind foarte similar de la o problem\u0103 la alta:</p> <ul> <li>Se pot g\u0103si solu\u021bii greedy destul de u\u0219or, dar f\u0103r\u0103 succes</li> <li>Dac\u0103 \u0219tim r\u0103spunsurile pentru subsecven\u021bele de lungime mai mic\u0103, putem calcula   r\u0103spunsul pentru orice subsecven\u021b\u0103 \\([L, R]\\) de o lungime mai mare</li> <li>Putem combina subsecven\u021be disjuncte \u00een mod independent</li> <li>De regul\u0103, \\(n\\) (dimensiunea \u0219irului) este cel mult 500.</li> </ul>","tags":["programare dinamica","intervale"]},{"location":"dificil/range-dp/#cum-aplicam-tehnica","title":"Cum aplic\u0103m tehnica?","text":"<p>Pe scurt, ceea ce vrem s\u0103 facem este s\u0103 avem o stare de tip \\(dp[i][j]\\) care s\u0103 ne \u021bin\u0103 r\u0103spunsul pentru intervalul \\([i, j]\\) \u0219i s\u0103 calcul\u0103m valoarea acestei st\u0103ri fix\u00e2nd pozi\u021bia \\(k\\) pe care o vom folosi pentru a \u00eemp\u0103r\u021bi subsecven\u021ba noastr\u0103 \u00een dou\u0103 subsecven\u021be disjuncte (de regul\u0103, \\([i, k]\\) \u0219i \\([k+1, j]\\)), a c\u0103ror reuniune s\u0103 fie subsecven\u021ba \\([i, j]\\).</p> <p>O alt\u0103 particularitate des \u00eent\u00e2lnit\u0103 va fi s\u0103 iter\u0103m subsecven\u021bele \u00een ordine cresc\u0103toare a lungimilor pentru a avea r\u0103spunsurile calculate \u00een ordine. Alternativ, vom putea implementa aceast\u0103 solu\u021bie \u0219i recursiv, f\u0103c\u00e2nd calculele mai u\u0219oare, a\u0219a cum ve\u021bi putea vedea \u00een exemplele ulterioare.</p>","tags":["programare dinamica","intervale"]},{"location":"dificil/range-dp/#un-prim-exemplu-problema-rectangle-cutting","title":"Un prim exemplu - Problema Rectangle Cutting","text":"<p>Aceast\u0103 problem\u0103 ne cere s\u0103 afl\u0103m num\u0103rul minim de t\u0103ieturi pe care le putem face astfel \u00eenc\u00e2t s\u0103 \u00eemp\u0103r\u021bim dreptunghiul ini\u021bial cu dimensiunile \\(a\\) \u0219i \\(b\\) \u00een p\u0103trate.</p> <p>Mai \u00eent\u00e2i, ne-am putea g\u00e2ndi la solu\u021bii de tip backtracking care sunt foarte \u00eencete sau solu\u021bii greedy care \u00eencearc\u0103 s\u0103 ob\u021bin\u0103 p\u0103trate c\u00e2t mai mari, dar aceste abord\u0103ri e\u0219ueaz\u0103 pe diverse teste.</p> <p>Deoarece dimensiunile dreptunghiurilor sunt cel mult 500, putem s\u0103 ne g\u00e2ndim la o dinamic\u0103 de dou\u0103 dimensiuni, unde \\(dp[i][j]\\) va \u021bine num\u0103rul minim de t\u0103ieturi necesare pentru a ajunge la un dreptunghi de dimensiunile \\(i\\) \u0219i \\(j\\).</p> <p>Un caz de baz\u0103 evident este acela c\u00e2nd \\(i = j\\), unde \\(dp[i][j] = 0\\). Acum, trebuie s\u0103 ne g\u00e2ndim la t\u0103ieturile pe care le putem face, acestea pot fi fie orizontale, fie verticale, at\u00e2ta timp c\u00e2t p\u0103str\u0103m laturile drept numere \u00eentregi.</p> <p>Cu alte cuvinte, vom putea fixa punctul \u00een care vom face t\u0103ietura \u0219i de acolo, vom folosi rezultatele calculate anterior, sau \u00een cazul solu\u021biei recursive, le vom calcula la r\u00e2ndul lor p\u00e2n\u0103 c\u00e2nd toate valorile au fost calculate. Complexitatea acestei solu\u021bii va fi \\(\\mathcal{O}(n^3)\\), unde \\(n\\) este maximul dintre \\(a\\) \u0219i \\(b\\).</p> <p>Mai jos pute\u021bi g\u0103si implement\u0103rile iterative \u0219i recursive ale acestei probleme.</p> RecursivIterativ <pre><code>#include &lt;iostream&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\nvector&lt;vector&lt;int&gt; &gt; dp;\n\nint solve(int n, int m) {\n    if (n == m) {\n        return 0;\n    }\n    if (dp[n][m] != (1 &lt;&lt; 20)) {\n        return dp[n][m];\n    }\n    for (int side = 1; side &lt; n; side++) {\n        dp[n][m] = min(dp[n][m], solve(side, m) + solve(n - side, m) + 1);\n    }\n    for (int side = 1; side &lt; m; side++) {\n        dp[n][m] = min(dp[n][m], solve(n, side) + solve(n, m - side) + 1);\n    }\n    return dp[n][m];\n}\n\nint main() {\n    int n, m;\n    cin &gt;&gt; n &gt;&gt; m;\n\n    dp.resize(n + 1, vector&lt;int&gt;(m + 1, (1 &lt;&lt; 20)));\n\n    cout &lt;&lt; solve(n, m) &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre> <pre><code>#include &lt;iostream&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\nint main() {\n    int n, m;\n    cin &gt;&gt; n &gt;&gt; m;\n\n    vector&lt;vector&lt;int&gt; &gt; dp(n + 1, vector&lt;int&gt;(m + 1, (1 &lt;&lt; 20)));\n\n    for (int i = 1; i &lt;= n; i++) {\n        for (int j = 1; j &lt;= m; j++) {\n            if (i == j) {\n                dp[i][j] = 0;\n                continue;\n            }\n            for (int side = 1; side &lt; i; side++) {\n                dp[i][j] = min(dp[i][j], dp[side][j] + dp[i - side][j] + 1);\n            }\n            for (int side = 1; side &lt; j; side++) {\n                dp[i][j] = min(dp[i][j], dp[i][side] + dp[i][j - side] + 1);\n            }\n        }\n    }\n\n    cout &lt;&lt; dp[n][m] &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["programare dinamica","intervale"]},{"location":"dificil/range-dp/#un-exemplu-mai-dificil-greedy-pie-eaters","title":"Un exemplu mai dificil - Greedy Pie Eaters","text":"<p>\u00cen aceast\u0103 problem\u0103, vrem s\u0103 ne asigur\u0103m c\u0103 putem folosi vaci cu o greutate total\u0103 c\u00e2t mai mare, \u0219tiind c\u0103 fiecare vac\u0103 va m\u00e2nca toate pr\u0103jiturile din intervalul corespunz\u0103tor.</p> <p>Vom \u00eencepe prin a precalcula pentru fiecare mod posibil de a t\u0103ia un interval, cea mai bun\u0103 variant\u0103 de a face asta, folosind o dinamic\u0103 de tipul \\(bstcut[i][j][p]\\), unde aceast\u0103 stare reprezint\u0103 suma maxim\u0103 pe care o putem ob\u021bine din intervalul \\([i, j]\\) dac\u0103 t\u0103iem intervalul \u00een pozi\u021bia \\(p\\).</p> <p>Dup\u0103 ce avem aceast\u0103 dinamic\u0103 calculat\u0103, vom putea rezolva aceast\u0103 problem\u0103 folosind o alt\u0103 dinamic\u0103 pe dou\u0103 dimensiuni, unde \\(dp[i][j]\\) reprezint\u0103 r\u0103spunsul optim pentru intervalul \\([i, j]\\). Aceast\u0103 dinamic\u0103 va putea fi implementat\u0103 recursiv, fix\u00e2nd pozi\u021biile \u00een care asign\u0103m o vac\u0103 sau fix\u00e2nd intervalele pe care le vom \u00eemp\u0103r\u021bi, acestea fiind calculate independent.</p> <pre><code>#include &lt;fstream&gt;\n#include &lt;vector&gt;\n\nusing namespace std;\n\nifstream cin(\"pieaters.in\");\nofstream cout(\"pieaters.out\");\n\nvector&lt;vector&lt;int&gt;&gt; mx, dp;\nvector&lt;vector&lt;vector&lt;int&gt;&gt;&gt; bstcut;\n\nint solve (int st, int dr) {\n    if(st &gt; dr) {\n        return 0;\n    }\n    if (dp[st][dr] != -1) {\n        return dp[st][dr];\n    }\n    dp[st][dr] = 0;\n    for (int i = st; i &lt; dr; ++i) {\n        dp[st][dr] = max(dp[st][dr], solve(st, i) + solve(i+1, dr));\n    }\n    for (int cut = st; cut &lt;= dr; ++cut) {\n        dp[st][dr] = max(dp[st][dr], bstcut[st][dr][cut] + solve(st, cut-1) + solve(cut+1, dr));\n    }\n    return dp[st][dr];\n}\nint main() {\n\n    int n, m;\n    cin &gt;&gt; n &gt;&gt; m;\n    mx.resize(n+2, vector&lt;int&gt; (n+2));\n    dp.resize(n+2, vector&lt;int&gt; (n+2, -1));\n    bstcut.resize(n+2, vector&lt;vector&lt;int&gt; &gt; (n+2, vector&lt;int&gt; (n+2, 0)));\n\n    for (int i = 1; i &lt;= m; ++i) {\n        int am, l, r;\n        cin &gt;&gt; am &gt;&gt; l &gt;&gt; r;\n        mx[l][r] = max(mx[l][r], am);\n    }\n    for (int len = 1; len &lt;= n; ++len) {\n        for (int j = 1; j + len - 1 &lt;= n; ++j) {\n            for (int x = j; x &lt;= j + len - 1; ++x) {\n                bstcut[j][j + len - 1][x] = max(bstcut[j][j + len - 2][x], mx[j][j + len - 1]);\n                bstcut[j][j + len - 1][x] = max(bstcut[j][j + len - 1][x], bstcut[j + 1][j + len - 1][x]);\n            }\n        }\n    }\n\n    cout &lt;&lt; solve(1, n) &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["programare dinamica","intervale"]},{"location":"dificil/range-dp/#un-alt-tip-de-range-dp-atcoder-dp-contest-deque","title":"Un alt tip de range dp - Atcoder DP Contest Deque","text":"<p>De\u0219i aceast\u0103 problem\u0103 nu se \u00eencadreaz\u0103 complet \u00een defini\u021bia dat\u0103 mai sus, modul relativ facil pe care \u00eel avem pentru calcularea rezultatelor st\u0103rilor o va putea \u00eencadra \u00een aceast\u0103 categorie.</p> <p>Din nou, o solu\u021bie greedy u\u0219or de g\u0103sit nu este fezabil\u0103, majoritatea greedy-urilor cunoscute av\u00e2nd cazuri pe care solu\u021bia pic\u0103. Astfel, suntem limita\u021bi la a avea o abordare bazat\u0103 pe metoda program\u0103rii dinamice, unde \\(dp[i][j]\\) reprezint\u0103 r\u0103spunsul maxim dac\u0103 \u00eencepem din subsecven\u021ba \\([i, j]\\). La fiecare pas, avem de fixat una din cele dou\u0103 valori pe care o folosim, r\u0103spunsul fiind preluat din secven\u021bele de lungime mai mic\u0103, a\u0219a cum se poate vedea \u00een codul de mai jos.</p> <p>Observa\u021bie</p> <p>Exist\u0103 totu\u0219i o solu\u021bie greedy corect\u0103 pentru aceast\u0103 problem\u0103, fiind una destul de dificil\u0103, \u00een ciuda codului scurt, detaliile fiind explicate \u00een acest paper, pe care \u00eel pute\u021bi g\u0103si aici</p> <pre><code>#include &lt;iostream&gt;\n#include &lt;vector&gt;\n\nusing namespace std;\n\nint main() {\n    int n;\n    cin &gt;&gt; n;\n\n    vector&lt;int&gt; v(n + 1);\n    for (int i = 1; i &lt;= n; ++i) {\n        cin &gt;&gt; v[i];\n    }\n\n    vector&lt;vector&lt;int&gt;&gt; dp(n + 1, vector&lt;int&gt;(n + 1));\n    for (int i = n; i &gt;= 1; --i) {\n        for (int j = i + 1; j &lt;= n + 1; ++j) {\n            dp[i][j] = max(v[i] - dp[i + 1][j], v[j - 1] - dp[i][j - 1]);\n        }\n    }\n    cout &lt;&lt; dp[1][n + 1];\n    return 0;\n}\n</code></pre>","tags":["programare dinamica","intervale"]},{"location":"dificil/range-dp/#concluzii","title":"Concluzii","text":"<p>Dup\u0103 cum se poate vedea, Range DP este o tehnic\u0103 care se dovede\u0219te a fi foarte util\u0103 \u00een multe contexte, iar faptul c\u0103 implement\u0103rile vor fi similare de la problem\u0103 la problem\u0103 va face \u00een\u021belegerea \u0219i aplicarea principiului mai u\u0219oar\u0103 dec\u00e2t \u00een cazul altor dinamici, unde este necesar\u0103 o experien\u021b\u0103 mai mare pentru a modifica st\u0103rile \u0219i modul de calcul.</p>","tags":["programare dinamica","intervale"]},{"location":"dificil/range-dp/#probleme-suplimentare","title":"Probleme suplimentare","text":"<ul> <li>podm infoarena</li> <li>Slimes AtCoder DP</li> <li>Space Jazz   SAPO</li> <li>Mean Info1Cup</li> <li>bmatrix infoarena</li> <li>redu infoarena</li> <li>ONI 2010 Triunghi</li> <li>Taming the Herd USACO   Gold</li> <li>ONI 2009 Baraj Seniori maxpal</li> <li>ONI 2008 Baraj Seniori stiva</li> <li>Zuma Codeforces</li> <li>ONI 2023 Baraj Seniori bt</li> <li>ONI 2005 Baraj Seniori evantai</li> <li>Empty String CSES</li> <li>Queries for Number of Palindromes   Codeforces</li> <li>3SUM USACO Gold</li> <li>Replace on Segment Codeforces</li> <li>Interesting Problem (Hard Version)   Codeforces</li> <li>Probleme de pe kilonova cu Range DP</li> <li>Probleme de pe pbinfo cu Range   DP</li> </ul>","tags":["programare dinamica","intervale"]},{"location":"dificil/range-dp/#lectura-suplimentara","title":"Lectur\u0103 suplimentar\u0103","text":"<ul> <li>Articolul despre Range DP de pe USACO   Guide</li> <li>Tehnici avansate de programare dinamic\u0103 -   Infoarena</li> <li>Some Interval DP Problems and State Reduction -   Codeforces</li> </ul>","tags":["programare dinamica","intervale"]},{"location":"dificil/rmq/","title":"Sparse Table. Binary Lifting. Range Minimum Query (RMQ)","text":"","tags":["structuri de date","RMQ","optimizare","sparse table","binary lifting"]},{"location":"dificil/rmq/#introducere","title":"Introducere","text":"<p>Sparse Table este o structur\u0103 de date care ne ajut\u0103, \u00een principal, s\u0103 r\u0103spundem la \u00eentreb\u0103ri pe un interval, fiecare r\u0103spuns fiind calculat \u00een \\(\\mathcal{O}(\\log n)\\) (mai pu\u021bin atunci c\u00e2nd folosim RMQ, despre care o s\u0103 discut\u0103m mai t\u00e2rziu \u00een acest articol).</p>","tags":["structuri de date","RMQ","optimizare","sparse table","binary lifting"]},{"location":"dificil/rmq/#sparse-table-binary-lifting","title":"Sparse Table. Binary Lifting","text":"<p>S\u0103 lu\u0103m ca exemplu problema Static Range Sum Queries de pe CSES. Desigur c\u0103 o putem rezolva folosind sume par\u021biale, dar haide\u021bi s\u0103 \u00eencerc\u0103m o metod\u0103 nou\u0103.</p> <p>Fie \\(spt_{i, j}\\) suma numerelor din intervalul \\([j, j + 2^i)\\). C\u00e2nd avem o \u00eentrebare pe intervalul \\([st, dr]\\), \u00eel vom \u00eemp\u0103r\u021bi \u00een intervale de lungimi puteri de 2. Lungimile acestor intervale vor fi egale cu bi\u021bii din reprezentarea \u00een baza 2 a lui \\(dr - st + 1\\). Aceast\u0103 metod\u0103 se cheam\u0103 binary lifting.</p> <p>Aten\u021bie</p> <p>Este foarte important ca, \u00een \\(spt_{i, j}\\), \\(2^i\\) s\u0103 fie lungimea intervalului \u0219i \\(j\\) s\u0103 fie primul element. Dac\u0103 implement\u0103m altfel, timpul implement\u0103rii va cre\u0219te foarte mult. Unoeri, acest lucru poate duce \u0219i la TLE. Mai multe detalii pute\u021bi g\u0103si \u00een acest blog.</p> <p>Observa\u021bie</p> <p>LCA este calculat, de asemenea, folosind binary lifting. C\u0103utarea binar\u0103 \u00een AIB folose\u0219te, de asemenea, binary lifting.</p> <p>Sursa de 100:</p> <pre><code>#include &lt;iostream&gt;\n\nconst int MAXN = 200'000;\nconst int LOGN = 18;\n\nint v[MAXN], n, q;\n\nstruct SparseTable {\n    long long spt[LOGN][MAXN];\n    int maxbit;\n\n    void init(int n) {\n        int i, j;\n        for (i = 0; i &lt; n; i++) {\n            spt[0][i] = v[i];\n        }\n        maxbit = 31 - __builtin_clz(n);  // i-ul maxim\n        for (i = 1; i &lt;= maxbit; i++) {\n            for (j = 0; j + (1 &lt;&lt; i) - 1 &lt; n; j++) {\n                spt[i][j] = spt[i - 1][j] + spt[i - 1][j + (1 &lt;&lt; (i - 1))];\n            }\n        }\n    }\n\n    long long query(int st, int dr) {\n        int len = dr - st + 1, i;\n        long long sum = 0;\n        for (i = maxbit; i &gt;= 0; i--) {\n            if (len &amp; (1 &lt;&lt; i)) {  // daca are bitul i\n                sum += spt[i][st];\n                st += 1 &lt;&lt; i;\n            }\n        }\n        return sum;\n    }\n} table;\n\nvoid readArray() {\n    int i;\n    std::cin &gt;&gt; n &gt;&gt; q;\n    for (i = 0; i &lt; n; i++) {\n        std::cin &gt;&gt; v[i];\n    }\n}\n\nvoid answerQueries() {\n    int i, st, dr;\n    for (i = 0; i &lt; q; i++) {\n        std::cin &gt;&gt; st &gt;&gt; dr;\n        std::cout &lt;&lt; table.query(st - 1, dr - 1) &lt;&lt; \"\\n\";\n    }\n}\n\nint main() {\n    readArray();\n    table.init(n);\n    answerQueries();\n    return 0;\n}\n</code></pre>","tags":["structuri de date","RMQ","optimizare","sparse table","binary lifting"]},{"location":"dificil/rmq/#range-minimum-query","title":"Range Minimum Query","text":"<p>A\u0219a cum \u00eei spune \u0219i numele, la Range Minimum Query (RMQ), avem \u00eentreb\u0103ri la care trebuie s\u0103 r\u0103spundem cu minimul pe un interval. Vom folosi un sparse table.</p> <p>Ideea principal\u0103 la RMQ este s\u0103 \u00eemp\u0103r\u021bim intervalul \\([st, dr]\\) \u00een dou\u0103 intervale: \\([st, st + 2^{lg}), (dr - 2^{lg}, dr]\\) (unde \\(lg\\) reprezint\u0103 cel mai mare num\u0103r astfel \u00eenc\u00e2t \\(2^{lg} \\leq dr - st + 1\\)). Aceste intervale au lungimea \\(2^{lg}\\), deci le putem afla r\u0103spunsurile \u00een \\(\\mathcal{O}(1)\\) (deoarece le avem deja precalculate).</p> <p>Observa\u021bie</p> <p>Noi repet\u0103m elementele din intervalul \\((st + 2^{lg}, dr - 2^{lg})\\). Acest lucru nu ne afecteaz\u0103, deoarece \\(min(x, x) = x\\).</p> <p>Observa\u021bie</p> <p>Vom precalcula un vector $lg2_i = $ cel mai mare \\(j\\) astfel \u00eenc\u00e2t \\(2^j \\leq i\\). Acest vector ne va ajuta s\u0103 calcul\u0103m \\(lg\\) u\u0219or.</p> <p>Tabloul \\(spt\\) se calculeaz\u0103 la fel ca \u00eenainte.</p> <p>Sursa de accepted (la problema Static Range Minimum Queries):</p> <pre><code>#include &lt;iostream&gt;\n\nconst int MAXN = 200'000;\nconst int LOGN = 18;\n\nint v[MAXN], n, q;\n\nint min(int a, int b) { return a &lt; b ? a : b; }\n\nstruct SparseTable {\n    int spt[LOGN][MAXN], lg2[MAXN + 1];\n\n    void init(int n) {\n        int i, j;\n        for (i = 2; i &lt;= n; i++) {\n            lg2[i] = 1 + lg2[i &gt;&gt; 1];\n        }\n        for (i = 0; i &lt; n; i++) {\n            spt[0][i] = v[i];\n        }\n        for (i = 1; i &lt;= lg2[n]; i++) {\n            for (j = 0; j + (1 &lt;&lt; i) - 1 &lt; n; j++) {\n                spt[i][j] = min(spt[i - 1][j], spt[i - 1][j + (1 &lt;&lt; (i - 1))]);\n            }\n        }\n    }\n\n    int query(int st, int dr) {\n        int lg = lg2[dr - st + 1];\n        return min(spt[lg][st], spt[lg][dr - (1 &lt;&lt; lg) + 1]);\n    }\n} rmq;\n\nvoid readArray() {\n    int i;\n    std::cin &gt;&gt; n &gt;&gt; q;\n    for (i = 0; i &lt; n; i++) {\n        std::cin &gt;&gt; v[i];\n    }\n}\n\nvoid answerQueries() {\n    int i, st, dr;\n    for (i = 0; i &lt; q; i++) {\n        std::cin &gt;&gt; st &gt;&gt; dr;\n        std::cout &lt;&lt; rmq.query(st - 1, dr - 1) &lt;&lt; \"\\n\";\n    }\n}\n\nint main() {\n    readArray();\n    rmq.init(n);\n    answerQueries();\n    return 0;\n}\n</code></pre> <p>Observa\u021bie</p> <p>RMQ poate fi folosit cu orice opera\u021bie \\(f\\) care este idempotent\u0103, adic\u0103 \\(f(x, x) = x\\) (minim, maxim, cmmdc etc). Avem nevoie de acest lucru, deoarece, cum am observat mai sus, noi repet\u0103m anumite elemente.</p>","tags":["structuri de date","RMQ","optimizare","sparse table","binary lifting"]},{"location":"dificil/rmq/#rmq-2d","title":"RMQ 2D","text":"<p>Putem face RMQ \u0219i pe matrice. S\u0103 luam ca exemplu problema CF 713D.</p> <p>S\u0103 calcul\u0103m, mai \u00eent\u00e2i $maxp_{i, j} = $ latura celui mai mare dreptunghi care are doar valori de 1 \u0219i are col\u021bul dreapta-jos \u00een \\((i, j)\\). Aceast\u0103 metod\u0103 se cheam\u0103 programare dinamic\u0103.</p> \\[ maxp_{i, j} = \\begin{cases} 0 &amp;\\text{dac\u0103 } i = 0 \\text{ sau } j = 0 \\\\ 0 &amp;\\text{dac\u0103 } i, j &gt; 0 \\text{ \u0219i } a_{i, j} = 0 \\\\ min(maxp_{i-1, j}, maxp_{i, j-1}, maxp_{i-1, j-1}) + 1 &amp;\\text{dac\u0103 } i, j &gt; 0 \\text{ \u0219i } a_{i, j} = 1 \\end{cases} \\] <p>Acum, s\u0103 vedem cum se calculeaz\u0103 \\(spt\\). Fie $spt_{i, j, l, c} = $ maximul elementelor din submatricea cu col\u021bul st\u00e2nga-sus la \\((i, j)\\) \u0219i cu col\u021bul dreapta-jos la \\((l+2^i-1, c+2^j-1)\\) din \\(maxp\\).</p> \\[ spt_{i, j, l, c} = \\begin{cases} maxp_{l, c} &amp;\\text{dac\u0103 } i = 0, j = 0 \\\\ max(spt_{i-1, j, l, c}, spt_{i-1, j, l, c + 2^{i-1}}) &amp;\\text{dac\u0103 } i = 0, j &gt; 0 \\\\ max(spt_{i, j-1, l, c}, spt_{i, j-1, l + 2^{i-1}, c}) &amp;\\text{dac\u0103 } i &gt; 0, j = 0 \\\\ max(spt_{i-1, j-1, l, c}, spt_{i-1, j-1, l + 2^{i-1}, c}, spt_{i-1, j-1, l, c + 2^{j-1}}, spt_{i-1, j-1, l + 2^{i-1}, c + 2^{j-1}}) &amp;\\text{dac\u0103 } i, j &gt; 0 \\end{cases} \\] <p>S\u0103 vedem cum se calculeaz\u0103 r\u0103spunsul pentru o \u00eentrebare pe un dreptunghi cu col\u021bul st\u00e2nga-sus \u00een \\((l_1, c_1)\\) \u0219i coltul dreapta-jos \u00een \\((l_2, c_2)\\). Fie $lgl = $ cel mai mare num\u0103r astfel \u00eenc\u00e2t \\(2^{lgl} \\leq l_2-l_1+1\\) \u0219i $lgc = $ cel mai mare num\u0103r astfel \u00eenc\u00e2t \\(2^lgc \\leq c_2-c_1+1\\).</p> \\[ query(l_1, c_1, l_2, c_2) = max(spt_{lgl, lgc, l_1, c_1}, spt_{lgl, lgc, l_2 - 2^{lgl} + 1, c_1}, spt_{lgl, lgc, l_1, c_2 - 2^{lgc} + 1}, spt_{lgl, lgc, l_2 - 2^{lgl} + 1, c_2 - 2^{lgc} + 1}) \\] <p>Mai departe, observ\u0103m c\u0103 noi nu avem cum sa afl\u0103m direct r\u0103spunsul, deoarece unele rezultate pot ie\u0219i din dreptunghiul \u00een care suntem \u00eentreba\u021bi. A\u0219a c\u0103, vom c\u0103uta binar r\u0103spunsul.</p> <p>Cum verific\u0103m dac\u0103 avem vreun p\u0103trat de latur\u0103 cel pu\u021bin \\(k\\)? Vom verifica dac\u0103:</p> \\[query(l_2-k+1, c_2-k+1, l_2, c-2) \\geq k\\] <p>Adic\u0103 vom verifica dac\u0103 exist\u0103 vreun col\u021b dreapta-jos care formeaz\u0103 un p\u0103trat de latur\u0103 cel pu\u021bin \\(k\\).</p> <p>Sursa de Accepted:</p> <pre><code>#include &lt;iostream&gt;\n\nconst int MAXN = 1'000;\nconst int LOGN = 11;\n\nint mat[MAXN + 1][MAXN + 1], maxp[MAXN + 1][MAXN + 1], n, m;\n\nint min(int a, int b) { return a &lt; b ? a : b; }\n\nint min(int a, int b, int c) { return min(min(a, b), c); }\n\nint max(int a, int b) { return a &gt; b ? a : b; }\n\nint max(int a, int b, int c, int d) { return max(max(a, b), max(c, d)); }\n\nstruct SparseTable2D {\n    int spt[LOGN][LOGN][MAXN + 1][MAXN + 1], lg2[MAXN + 1];\n\n    void init() {\n        int i, j, l, c;\n        for (i = 2; i &lt;= MAXN; i++) {\n            lg2[i] = 1 + lg2[i &gt;&gt; 1];\n        }\n        for (l = 1; l &lt;= n; l++) {\n            for (c = 1; c &lt;= m; c++) {\n                spt[0][0][l][c] = maxp[l][c];\n            }\n        }\n        for (i = 1; i &lt;= lg2[n]; i++) {\n            for (l = 1; l &lt;= n; l++) {\n                for (c = 1; c &lt;= m; c++) {\n                    spt[i][0][l][c] = max(spt[i - 1][0][l][c],\n                                          spt[i - 1][0][l + (1 &lt;&lt; (i - 1))][c]);\n                }\n            }\n        }\n        for (j = 1; j &lt;= lg2[m]; j++) {\n            for (l = 1; l &lt;= n; l++) {\n                for (c = 1; c &lt;= m; c++) {\n                    spt[0][j][l][c] = max(spt[0][j - 1][l][c],\n                                          spt[0][j - 1][l][c + (1 &lt;&lt; (j - 1))]);\n                }\n            }\n        }\n        for (i = 1; i &lt;= lg2[n]; i++) {\n            for (j = 1; j &lt;= lg2[m]; j++) {\n                for (l = 1; l + (1 &lt;&lt; i) - 1 &lt;= n; l++) {\n                    for (c = 1; c + (1 &lt;&lt; j) - 1 &lt;= m; c++) {\n                        spt[i][j][l][c] =\n                            max(spt[i - 1][j - 1][l][c],\n                                spt[i - 1][j - 1][l][c + (1 &lt;&lt; (j - 1))],\n                                spt[i - 1][j - 1][l + (1 &lt;&lt; (i - 1))][c],\n                                spt[i - 1][j - 1][l + (1 &lt;&lt; (i - 1))]\n                                   [c + (1 &lt;&lt; (j - 1))]);\n                    }\n                }\n            }\n        }\n    }\n\n    int query(int l1, int c1, int l2, int c2) {\n        int lgl = lg2[l2 - l1 + 1], lgc = lg2[c2 - c1 + 1];\n        return max(spt[lgl][lgc][l1][c1],\n                   spt[lgl][lgc][l1][c2 - (1 &lt;&lt; lgc) + 1],\n                   spt[lgl][lgc][l2 - (1 &lt;&lt; lgl) + 1][c1],\n                   spt[lgl][lgc][l2 - (1 &lt;&lt; lgl) + 1][c2 - (1 &lt;&lt; lgc) + 1]);\n    }\n} rmq2d;\n\nvoid fastReadWrite() {\n    std::ios_base::sync_with_stdio(0);\n    std::cin.tie(0);\n}\n\nvoid readMatrix() {\n    int l, c;\n    std::cin &gt;&gt; n &gt;&gt; m;\n    for (l = 1; l &lt;= n; l++) {\n        for (c = 1; c &lt;= m; c++) {\n            std::cin &gt;&gt; mat[l][c];\n        }\n    }\n}\n\nvoid computeMaxp() {\n    int l, c;\n    for (l = 1; l &lt;= n; l++) {\n        for (c = 1; c &lt;= m; c++) {\n            if (mat[l][c] == 0) {\n                maxp[l][c] = 0;\n            } else {\n                maxp[l][c] =\n                    1 + min(maxp[l - 1][c], maxp[l][c - 1], maxp[l - 1][c - 1]);\n            }\n        }\n    }\n}\n\nvoid answerQueries() {\n    int l1, c1, l2, c2, q, st, dr, mij;\n    std::cin &gt;&gt; q;\n    while (q--) {\n        std::cin &gt;&gt; l1 &gt;&gt; c1 &gt;&gt; l2 &gt;&gt; c2;\n        st = 0;  // intervalul este [) (inchis-deschis)\n        dr = min(l2 - l1 + 1, c2 - c1 + 1)\n           + 1;  // patratul maxim care este inclus\n        while (dr - st &gt; 1) {\n            mij = (st + dr) / 2;\n            if (rmq2d.query(l1 + mij - 1, c1 + mij - 1, l2, c2) &gt;= mij) {\n                st = mij;\n            } else {\n                dr = mij;\n            }\n        }\n        std::cout &lt;&lt; st &lt;&lt; \"\\n\";\n    }\n}\n\nint main() {\n    fastReadWrite();\n    readMatrix();\n    computeMaxp();\n    rmq2d.init();\n    answerQueries();\n    return 0;\n}\n</code></pre>","tags":["structuri de date","RMQ","optimizare","sparse table","binary lifting"]},{"location":"dificil/rmq/#reverse-rmq","title":"Reverse RMQ","text":"<p>Putem s\u0103 rezolv\u0103m \u0219i probleme \u00een care avem doar actualiz\u0103ri, f\u0103r\u0103 \u00eentreb\u0103ri, adica o problem\u0103 \u00een care avem actualiz\u0103ri de forma \\(a_i = max(a_i, x)\\), pentru \\(l \\leq i \\leq r\\). O putem rezolva asem\u0103n\u0103tor, folosind acelea\u0219i intervale ca la RMQ normal \u0219i modific\u00e2nd astfel:</p> \\[spt_{lg, st} = max(spt_{lg, st}, x) \\\\ spt_{lg, dr - 2^{lg} + 1} = max(spt_{lg, dr - 2^{lg} + 1}, x)\\] <p>Apoi, valoarea \\(a_i\\) final\u0103 va fi maximul dintre toate valorile din orice interval care este actualizat \u00een \\(spt\\) \u0219i include \\(i\\). Calcul\u0103m aceast\u0103 valoare folosind un proces similar cu propagarea lazy de la arbori de intervale. Rezultatul din \\(spt_{i, j}\\) va fi propagat doar \u00een \\(spt_{i - 1, j}\\) \u0219i \\(spt_{i - 1, j + 2^{i-1}}\\), deoarece acestea sunt singurele intervale necesare pentru a ne asigura c\u0103 rezultatul ajunge la toate pozi\u021biile din \u0219ir. Pentru mai multe detalii vede\u021bi implementarea.</p> <p>Sursa de accepted (la problema Glad You Came de pe codeforces)</p> <pre><code>#include &lt;iostream&gt;\n\nconst int MAXN = 100'000;\nconst int MAXVAL = 1 &lt;&lt; 30;\nconst int MAXLOG = 17;\n\nint n;\nunsigned int x, y, z;\n\nint max(int a, int b) { return a &gt; b ? a : b; }\n\nstruct SparseTable {\n    int spt[MAXLOG][MAXN], lg2[MAXN + 1];\n\n    void init(int n) {\n        int i, j;\n        for (i = 2; i &lt;= n; i++) {\n            lg2[i] = 1 + lg2[i &gt;&gt; 1];\n        }\n        for (i = 0; i &lt;= lg2[n]; i++) {\n            for (j = 0; j &lt; n; j++) {\n                spt[i][j] = 0;\n            }\n        }\n    }\n\n    void update(int st, int dr, int val) {\n        int lg = lg2[dr - st + 1], dr_idx;\n        spt[lg][st] = max(spt[lg][st], val);\n        dr_idx = dr - (1 &lt;&lt; lg) + 1;\n        spt[lg][dr_idx] = max(spt[lg][dr_idx], val);\n    }\n\n    void pullResults() {\n        int i, j, new_j;\n        for (i = lg2[n]; i &gt; 0; i--) {\n            for (j = 0; j + (1 &lt;&lt; i) &lt;= n; j++) {\n                spt[i - 1][j] = max(spt[i - 1][j], spt[i][j]);\n                new_j = j + (1 &lt;&lt; (i - 1));\n                spt[i - 1][new_j] = max(spt[i - 1][new_j], spt[i][j]);\n            }\n        }\n    }\n\n    void writeAnswer() {\n        int i;\n        unsigned long long answer;\n        pullResults();\n        answer = 0;\n        for (i = 0; i &lt; n; i++) {\n            answer ^= 1LL * (i + 1) * spt[0][i];\n        }\n        std::cout &lt;&lt; answer &lt;&lt; \"\\n\";\n    }\n} rmq;\n\nunsigned int nextValue() {\n    unsigned int w;\n    x ^= x &lt;&lt; 11;\n    x ^= x &gt;&gt; 4;\n    x ^= x &lt;&lt; 5;\n    x ^= x &gt;&gt; 14;\n    w = x ^ y ^ z;\n    x = y;\n    y = z;\n    z = w;\n    return z;\n}\n\nvoid processUpdates() {\n    int q, i, st, dr, val, aux;\n    std::cin &gt;&gt; n &gt;&gt; q &gt;&gt; x &gt;&gt; y &gt;&gt; z;\n    rmq.init(n);\n    for (i = 0; i &lt; q; i++) {\n        st = nextValue() % n;\n        dr = nextValue() % n;\n        if (st &gt; dr) {\n            aux = st;\n            st = dr;\n            dr = aux;\n        }\n        val = nextValue() % MAXVAL;\n        rmq.update(st, dr, val);\n    }\n}\n\nint main() {\n    int t;\n    std::cin &gt;&gt; t;\n    while (t--) {\n        processUpdates();\n        rmq.writeAnswer();\n    }\n    return 0;\n}\n</code></pre>","tags":["structuri de date","RMQ","optimizare","sparse table","binary lifting"]},{"location":"dificil/rmq/#rmq-sau-arbori-de-intervale","title":"RMQ sau Arbori de intervale?","text":"<p>Arborii de intervale (AINT) pot face tot ce poate face RMQ, dar haide\u021bi s\u0103 compar\u0103m aceste dou\u0103 structuri de date.</p>","tags":["structuri de date","RMQ","optimizare","sparse table","binary lifting"]},{"location":"dificil/rmq/#comparatie-in-functie-de-timp","title":"Compara\u021bie \u00een func\u021bie de timp","text":"<p>RMQ este precalculat, la \u00eenceput, \u00een \\(\\mathcal{O}(n \\log n)\\), iar AINT \u00een \\(\\mathcal{O}(n)\\). \u00cens\u0103, RMQ are complexitate \\(\\mathcal{O}(1)\\) per query, \u00cen timp ce AINT are \\(\\mathcal{O}(\\log n)\\) per query.</p>","tags":["structuri de date","RMQ","optimizare","sparse table","binary lifting"]},{"location":"dificil/rmq/#comparatie-in-functie-de-memorie","title":"Compara\u021bie \u00een func\u021bie de memorie","text":"<p>RMQ folose\u0219te \\(\\mathcal{O}(n \\log n)\\) memorie, iar AINT folose\u0219te \\(\\mathcal{O}(n)\\) memorie.</p>","tags":["structuri de date","RMQ","optimizare","sparse table","binary lifting"]},{"location":"dificil/rmq/#alte-precizari","title":"Alte preciz\u0103ri","text":"<p>AINT poate rezolva \u0219i alte probleme pe care RMQ nu le poate rezolva. La astfel de probleme, putem folosi un Sparse Table normal, rezult\u00e2nd aceea\u0219i complexitate ca la AINT la query-uri. Acest lucru \u00eenseamn\u0103 c\u0103 AINT este mai folositor \u00een acest caz, chiar dac\u0103 este mai greu de implementat.</p> <p>\u00cen acela\u0219i timp, AINT poate trata \u0219i actualiz\u0103ri \u00eempreun\u0103 cu interog\u0103ri, iar RMQ nu le poate trata. \u00cen aceast\u0103 situa\u021bie, RMQ nu intr\u0103 \u00een calcul atunci c\u00e2nd dorim s\u0103 g\u0103sim cea mai bun\u0103 structur\u0103 de date pentru a rezolva o anumit\u0103 problem\u0103.</p>","tags":["structuri de date","RMQ","optimizare","sparse table","binary lifting"]},{"location":"dificil/rmq/#concluzie","title":"Concluzie","text":"<p>AINT este, de obicei, mai folositor ca RMQ, mai pu\u021bin atunci c\u00e2nd num\u0103rul de query-uri este cu mult mai mare dec\u00e2t num\u0103rul de elemente sau atunci c\u00e2nd dorim s\u0103 nu scriem prea multe linii de cod.</p>","tags":["structuri de date","RMQ","optimizare","sparse table","binary lifting"]},{"location":"dificil/rmq/#probleme-rezolvate","title":"Probleme rezolvate","text":"","tags":["structuri de date","RMQ","optimizare","sparse table","binary lifting"]},{"location":"dificil/rmq/#problema-lot-2023-juniori-excursie","title":"Problema Lot 2023 Juniori excursie","text":"<p>Observ\u0103m c\u0103 indicatoarele trebuie s\u0103 fie de forma RRR...RLLL..L. S\u0103 fixam pozi\u021bia \\(i\\) p\u00e2n\u0103 la care vom avea R-uri. Costul va fi egal cu num\u0103rul de L-uri de la \\(st\\) la \\(i\\) adunat cu num\u0103rul de R-uri de la \\(i + 1\\) la \\(dr\\). Aceste lucruri pot fi calculate u\u0219or folosind sume par\u021biale.</p> <p>Fie $prefL_i = $ c\u00e2te L-uri sunt de la 1 la \\(i\\) \u0219i $suffR_i = $ c\u00e2te R-uri sunt de la \\(i\\) la \\(n\\). Atunci r\u0103spunsul va fi \\(min(prefL_i - prefL_{st-1} + suffR_{i+1} - suffR_{dr+1})\\) astfel \u00eenc\u00e2t \\(st - 1 \\leq i \\leq dr\\). Acest lucru este echivalent cu a afla minimul expresiei \\(prefL_i + suffR_{i+1}\\) cu \\(i\\) in intervalul \\([st - 1, dr]\\). Vom folosi RMQ pentru a afla acest minim.</p> <p>Sursa de 100 de puncte:</p> <pre><code>#include &lt;ctype.h&gt;\n\n#include &lt;fstream&gt;\n\nconst int MAXN = 200'000;\nconst int LOGN = 18;\n\nstd::ifstream fin(\"excursie.in\");\nstd::ofstream fout(\"excursie.out\");\n\nchar v[MAXN + 1];\nint n, prefL[MAXN + 1], suffR[MAXN + 2];\n\nint min(int a, int b) { return a &lt; b ? a : b; }\n\nstruct SparseTable {\n    int spt[LOGN][MAXN + 1], lg2[MAXN + 2];\n\n    void init() {\n        int i, j;\n        for (i = 2; i &lt;= n + 1; i++) {\n            lg2[i] = 1 + lg2[i &gt;&gt; 1];\n        }\n        for (i = 0; i &lt;= n; i++) {\n            spt[0][i] = prefL[i] + suffR[i + 1];\n        }\n        for (i = 1; i &lt;= lg2[n]; i++) {\n            for (j = 0; j + (1 &lt;&lt; i) - 1 &lt;= n; j++) {\n                spt[i][j] = min(spt[i - 1][j], spt[i - 1][j + (1 &lt;&lt; (i - 1))]);\n            }\n        }\n    }\n\n    int query(int st, int dr) {\n        int lg = lg2[dr - st + 1];\n        return min(spt[lg][st], spt[lg][dr - (1 &lt;&lt; lg) + 1]);\n    }\n} rmq;\n\nvoid readString() {\n    int i, ch;\n    fin &gt;&gt; n;\n    while (!isalpha(ch = fin.get()))\n        ;\n    for (i = 1; i &lt;= n; i++) {\n        v[i] = (ch == 'R');\n        ch = fin.get();\n    }\n}\n\nvoid computePartialSums() {\n    int i;\n    for (i = 1; i &lt;= n; i++) {\n        prefL[i] = prefL[i - 1] + (1 - v[i]);\n    }\n    for (i = n; i &gt; 0; i--) {\n        suffR[i] = suffR[i + 1] + v[i];\n    }\n}\n\nvoid answerQueries() {\n    int q, i, st, dr, aux;\n    fin &gt;&gt; q;\n    for (i = 0; i &lt; q; i++) {\n        fin &gt;&gt; st &gt;&gt; dr;\n        if (st &gt; dr) {\n            aux = st;\n            st = dr;\n            dr = aux;\n        }\n        fout &lt;&lt; rmq.query(st - 1, dr) - prefL[st - 1] - suffR[dr + 1] &lt;&lt; \"\\n\";\n    }\n}\n\nint main() {\n    readString();\n    computePartialSums();\n    rmq.init();\n    answerQueries();\n    return 0;\n}\n</code></pre>","tags":["structuri de date","RMQ","optimizare","sparse table","binary lifting"]},{"location":"dificil/rmq/#problema-cf-2009g2","title":"Problema CF 2009G2","text":"","tags":["structuri de date","RMQ","optimizare","sparse table","binary lifting"]},{"location":"dificil/rmq/#versiunea-usoara-g1","title":"Versiunea u\u0219oar\u0103, G1","text":"<p>S\u0103 rezolv\u0103m mai \u00eent\u00e2i versiunea u\u0219oar\u0103. Noi trebuie s\u0103 avem \\(b_i = b_{i+1} - 1 = b_{i+2} - 2 = .. = b_{i+k-1} - (k-1)\\). S\u0103 sc\u0103dem \\(i\\) din aceast\u0103 rela\u021bie: \\(b_i - i = b_{i+1} - (i+1) = b_{i+2} - (i+2) = .. = b_{i+k-1} - (i+k-1)\\). Acest lucru este echivalent cu: \\(a_i = a_{i+1} = a_{i+2} = .. = a_{i+k-1}\\), unde \\(a_i = b_i - i\\).</p> <p>S\u0103 precalculam $rez_i = $ frecven\u021ba elementului majoritar din intervalul \\([i, i + k)\\) (\\(k - rez_l\\) va fi r\u0103spunsul nostru la un query). \\(rez\\) poate fi calculat folosind sliding window. Vom men\u021bine un map care se cheam\u0103 \\(fr\\) cu frecven\u021ba elementelor \u0219i \u00eenca un vector de frecven\u021b\u0103 care se cheam\u0103 \\(frfr\\) care men\u021bine frecven\u021ba fiec\u0103rei valori din \\(fr\\).</p> <p>C\u00e2nd adaug\u0103m o valoare, sc\u0103dem 1 din \\(frfr_{fr_{val}}\\), cre\u0219tem \\(fr_{val}\\) cu 1 \u0219i adun\u0103m 1 la noul \\(frfr_{fr_{val}}\\). Dac\u0103 \\(fr_{val}\\) este mai mare ca rezulatul curent, atunci set\u0103m rezultatul curent la \\(fr_{val}\\).</p> <p>Atunci c\u00e2nd scoatem o valoare, sc\u0103dem 1 din \\(frfr_{fr_{val}}\\). Dac\u0103 \\(fr_{val}\\) era egal cu rezultatul \u0219i \\(frfr_{fr_{val}}\\) a devenit 0, atunci rezultatul scade cu 1, deoarece \\(frfr_{fr_{val} - 1}\\) a crescut cu 1. Restul r\u0103m\u00e2ne la fel ca la ad\u0103ugare.</p> <p>Sursa de accepted la G1:</p> <pre><code>#include &lt;iostream&gt;\n#include &lt;map&gt;\n\nconst int MAXN = 200'000;\n\nint n, k, q, result, a[MAXN], rez[MAXN], frfr[MAXN + 1];\nstd::map&lt;int, int&gt; fr;\n\nvoid fastReadWrite() {\n    std::ios_base::sync_with_stdio(0);\n    std::cin.tie(0);\n}\n\nvoid readArray() {\n    int i;\n    std::cin &gt;&gt; n &gt;&gt; k &gt;&gt; q;\n    for (i = 0; i &lt; n; i++) {\n        std::cin &gt;&gt; a[i];\n        a[i] -= i;\n    }\n}\n\nvoid addValue(int val) {\n    frfr[fr[val]]--;\n    fr[val]++;\n    frfr[fr[val]]++;\n    if (fr[val] &gt; result) {\n        result = fr[val];\n    }\n}\n\nvoid remValue(int val) {\n    frfr[fr[val]]--;\n    if (fr[val] == result &amp;&amp; frfr[fr[val]] == 0) {\n        result--;\n    }\n    fr[val]--;\n    frfr[fr[val]]++;\n}\n\nvoid scanWindows() {\n    int i;\n    result = 0;\n    fr.clear();\n    for (i = 0; i &lt; k; i++) {\n        addValue(a[i]);\n    }\n    rez[0] = result;\n    for (i = k; i &lt; n; i++) {\n        remValue(a[i - k]);\n        addValue(a[i]);\n        rez[i - k + 1] = result;\n    }\n    // stergem restul elementelor pentru ca frfr sa fie setat la 0 la final\n    for (i = n; i &lt; n + k; i++) {\n        remValue(a[i - k]);\n    }\n}\n\nvoid answerQueries() {\n    int i, st, dr;\n    for (i = 0; i &lt; q; i++) {\n        std::cin &gt;&gt; st &gt;&gt; dr;\n        std::cout &lt;&lt; k - rez[st - 1] &lt;&lt; \"\\n\";\n    }\n}\n\nvoid solveTest() {\n    readArray();\n    scanWindows();\n    answerQueries();\n}\n\nint main() {\n    int t;\n    fastReadWrite();\n    std::cin &gt;&gt; t;\n    while (t--) {\n        solveTest();\n    }\n    return 0;\n}\n</code></pre>","tags":["structuri de date","RMQ","optimizare","sparse table","binary lifting"]},{"location":"dificil/rmq/#versiunea-grea","title":"Versiunea grea","text":"<p>Noi trebuie, de fapt, s\u0103 avem o subsecven\u021b\u0103 (contigu\u0103) de exact \\(k\\) elemente. Observ\u0103m c\u0103 \\(f(a_l, a_{l+1}, .., a_r) = k - max(rez_l, rez_{l+1}, .., rez_{r-k+1})\\) (\u00eencerc\u0103m fiecare subsecven\u021b\u0103 de \\(k\\) elemente). A\u0219a c\u0103, r\u0103spunsul nostru este \\(\\sum _{i=l} ^r \\ k - max(rez_l, rez_{l+1}, \\dots, rez_{i-k+1})\\).</p> <p>Vom g\u0103si, pentru fiecare \\(i\\), la c\u00e2te sume contribuie \\(rez_i\\). Cu alte cuvinte, vom afla pentru c\u00e2\u021bi \\(j &gt; i\\) avem \\(max(rez_l, rez_{l+1}, \\dots, rez_j) = rez_i\\). De asemenea, pentru a nu num\u0103ra de mai multe ori anumite sume, vom presupune c\u0103 nu exist\u0103 \\(l \\leq p &lt; i\\) astfel \u00eenc\u00e2t \\(rez_p = rez_i\\). Fie $nxt_{0, i} = $ cel mai mic \\(j &gt; i\\) astfel \u00eenc\u00e2t \\(rez_j &gt;= rez_i\\), lucru pe care \u00eel vom afla cu stiv\u0103. Fie \\(sum_{0, i} = rez_i \\cdot (i - nxt_{0, i})\\).</p> <p>Acum, s\u0103 presupunem c\u0103 avem un arbore, \u00een care \\(nxt_{0, i}\\) reprezint\u0103 p\u0103rintele lui \\(i\\) \u0219i \\(sum_{0, i}\\) reprezint\u0103 costul muchiei de la \\(i\\) la p\u0103rintele lui \\(i\\). Noi vom pleca de la \\(l\\) \u0219i vom tot merge \u00een tat\u0103l nodului, p\u00e2n\u0103 c\u00e2nd indicele tat\u0103lui este mai mare dec\u00e2t \\(r\\). Pentru a afla al c\u00e2telea tat\u0103 este cu u\u0219urinta, vom precalcula $nxt_{i, j} = $ al \\(2^i\\)-lea tat\u0103 al lui \\(j\\) \u0219i $sum_{i, j} = $ suma costurilor muchiilor lan\u021bului de la \\(j\\) la cel de-al \\(2^i\\)-lea tat\u0103 al lui \\(j\\).</p> \\[nxt_{i, j} = nxt_{i-1, nxt_{i-1, j}} \\\\ sum_{i, j} = sum_{i-1, j} + sum_{i-1, nxt_{i-1, j}}\\] <p>Sursa de accepted:</p> <pre><code>#include &lt;iostream&gt;\n#include &lt;map&gt;\n\nconst int MAXN = 200'000;\nconst int LOGN = 18;\nconst int INFINIT = 1'000'000'000;\n\nint n, k, q, result, a[MAXN], rez[MAXN + 1], frfr[MAXN + 1], stiva[MAXN];\nint nxt[LOGN][MAXN + 1];\nlong long sum[LOGN][MAXN + 1];\nstd::map&lt;int, int&gt; fr;\n\nvoid fastReadWrite() {\n    std::ios_base::sync_with_stdio(0);\n    std::cin.tie(0);\n}\n\nvoid readArray() {\n    int i;\n    std::cin &gt;&gt; n &gt;&gt; k &gt;&gt; q;\n    for (i = 0; i &lt; n; i++) {\n        std::cin &gt;&gt; a[i];\n        a[i] -= i;\n    }\n}\n\nvoid addValue(int val) {\n    frfr[fr[val]]--;\n    fr[val]++;\n    frfr[fr[val]]++;\n    if (fr[val] &gt; result) {\n        result = fr[val];\n    }\n}\n\nvoid remValue(int val) {\n    frfr[fr[val]]--;\n    if (fr[val] == result &amp;&amp; frfr[fr[val]] == 0) {\n        result--;\n    }\n    fr[val]--;\n    frfr[fr[val]]++;\n}\n\nvoid scanWindows() {\n    int i;\n    result = 0;\n    fr.clear();\n    for (i = 0; i &lt; k; i++) {\n        addValue(a[i]);\n    }\n    rez[0] = result;\n    for (i = k; i &lt; n; i++) {\n        remValue(a[i - k]);\n        addValue(a[i]);\n        rez[i - k + 1] = result;\n    }\n    // stergem restul elementelor pentru ca frfr sa fie setat la 0 la final\n    for (i = n; i &lt; n + k; i++) {\n        remValue(a[i - k]);\n    }\n}\n\nvoid buildTable() {\n    int sp, i, j;\n    n -= k - 1;\n    stiva[0] = n;\n    sp = 1;\n    nxt[0][n] = n;\n    sum[0][n] = 0;\n    rez[n] = INFINIT;  // infinit\n    for (i = n - 1; i &gt;= 0; i--) {\n        while (rez[i] &gt; rez[stiva[sp - 1]]) {\n            sp--;\n        }\n        nxt[0][i] = stiva[sp - 1];\n        sum[0][i] = 1LL * rez[i] * (stiva[sp - 1] - i);\n        stiva[sp++] = i;\n    }\n\n    for (i = 1; i &lt; LOGN; i++) {\n        for (j = 0; j &lt;= n; j++) {\n            nxt[i][j] = nxt[i - 1][nxt[i - 1][j]];\n            sum[i][j] = sum[i - 1][j] + sum[i - 1][nxt[i - 1][j]];\n        }\n    }\n}\n\nvoid answerQueries() {\n    int i, st, dr, j;\n    long long ans = 0;\n    for (i = 0; i &lt; q; i++) {\n        std::cin &gt;&gt; st &gt;&gt; dr;\n        st--;\n        dr -= k;\n        ans = 1LL * k * (dr - st + 1);\n        for (j = LOGN - 1; j &gt;= 0; j--) {\n            if (nxt[j][st] &lt;= dr) {\n                ans -= sum[j][st];\n                st = nxt[j][st];\n            }\n        }\n        ans -= 1LL * rez[st] * (dr - st + 1);\n        std::cout &lt;&lt; ans &lt;&lt; \"\\n\";\n    }\n}\n\nvoid solveTest() {\n    readArray();\n    scanWindows();\n    buildTable();\n    answerQueries();\n}\n\nint main() {\n    int t;\n    fastReadWrite();\n    std::cin &gt;&gt; t;\n    while (t--) {\n        solveTest();\n    }\n    return 0;\n}\n</code></pre> <p>Observatie</p> <p>Aceast\u0103 solu\u021bie este foarte asem\u0103n\u0103toare cu solu\u021bia la problema str\u0103mo\u0219i, discutat\u0103 \u00een articolul de LCA</p>","tags":["structuri de date","RMQ","optimizare","sparse table","binary lifting"]},{"location":"dificil/rmq/#concluzii","title":"Concluzii","text":"<p>Sparse Table este una dintre structurile de date care r\u0103spunde la \u00eentreb\u0103ri pe un interval \u00eentr-un \u0219ir static. Chiar dac\u0103 arborii de intervale pot face aproape tot ce poate face \u0219i Sparse Table, de obicei cu o complexitate chiar mai bun\u0103, Sparse Table este mai u\u0219or de implementat. De asemenea, am v\u0103zut c\u0103 RMQ poate avea multe avantaje, dar \u0219i dezavantaje fa\u021b\u0103 de AINT.</p>","tags":["structuri de date","RMQ","optimizare","sparse table","binary lifting"]},{"location":"dificil/rmq/#probleme-suplimentare","title":"Probleme suplimentare","text":"<ul> <li>ONI 2021 Baraj Juniori cartita</li> <li>Info1Cup 2021 wonderland</li> <li>CF 1175E</li> <li>CF 191C</li> <li>CF 1328E</li> <li>CF 1702G2</li> <li>CF 832D</li> <li>RMI 2020 Sum Zero</li> <li>EJOI 2021 consecutive1</li> <li>PBinfo minisecvente</li> <li>PBinfo divquery</li> <li>infoarena euclid</li> <li>infoarena plantatie</li> <li>CodeChef Maximum of GCDs</li> <li>Substring Restrictions - CS   Academy</li> <li>Problemele cu Sparse Table de la articolul de pe CP   algorithms</li> <li>Probleme cu RMQ de pe kilonova</li> <li>Probleme cu Binary Lifting de pe kilonova</li> <li>Problemele de RMQ din acest blog</li> <li>Problemele din acest blog</li> </ul>","tags":["structuri de date","RMQ","optimizare","sparse table","binary lifting"]},{"location":"dificil/rmq/#resurse-suplimentare","title":"Resurse suplimentare","text":"<ul> <li>RMQ - SEPI Infobits F1 (pag.   63)</li> <li>Sparse Table - CP   algorithms</li> <li>Recomandat - Sparse Table -   Codeforces</li> <li>Recomandat - Binary Lifting -   Codeforces</li> <li>Binary Lifting - USACO</li> <li>Avansat - RMQ cu \\(\\mathcal{O}(N)\\) timp de construc\u021bie \u0219i \\(\\mathcal{O}(1)\\) timp pe   query</li> </ul>","tags":["structuri de date","RMQ","optimizare","sparse table","binary lifting"]},{"location":"dificil/segment-trees-part2/","title":"Arbori de intervale (c\u0103utare binar\u0103, lazy propagation)","text":"","tags":["structuri de date","arbori de intervale","lazy propagation"]},{"location":"dificil/segment-trees-part2/#introducere","title":"Introducere","text":"<p>A\u0219a cum a\u021bi v\u0103zut \u0219i \u00een articolul anterior pe aceast\u0103 tem\u0103, arborii de intervale se dovedesc a fi o structur\u0103 de date foarte puternic\u0103, care ne ajut\u0103 \u00een foarte multe tipuri de probleme. \u00cen cele ce urmeaz\u0103, vom prezenta un set de opera\u021bii adi\u021bionale pe care le putem face folosind arborii de intervale, precum c\u0103utarea binar\u0103 pe un arbore de intervale, precum \u0219i actualiz\u0103ri pe interval, folosind metoda lazy propagation.</p>","tags":["structuri de date","arbori de intervale","lazy propagation"]},{"location":"dificil/segment-trees-part2/#cautarea-binara-pe-un-arbore-de-intervale","title":"C\u0103utarea binar\u0103 pe un arbore de intervale","text":"<p>S\u0103 presupunem c\u0103 avem de rezolvat urm\u0103toarea problem\u0103:</p> <p>Se da un \u0219ir de \\(n\\) valori \u0219i \\(q\\) queryuri \u00een care fie schimb\u0103m o valoare din \u0219ir, fie trebuie s\u0103 afl\u0103m prima pozi\u021bie care are o valoare mai mare sau egal\u0103 cu un \\(x\\) dat.</p> <p>O solu\u021bie care este foarte simplu de implementat ar fi s\u0103 folosim o c\u0103utare binar\u0103 pe rezultat, iar la un pas al c\u0103ut\u0103rii binare, s\u0103 folosim un arbore de intervale care s\u0103 ne r\u0103spund\u0103 rapid la un query de tipul care este valoarea maxim\u0103 \u00een intervalul \\([1, mid]\\).</p> <p>De\u0219i aceast\u0103 solu\u021bie ruleaz\u0103 \u00een \\(\\mathcal{O}(q \\log^2 n)\\), poate fi prea \u00eenceat\u0103 \u00een anumite situa\u021bii. De aceea, se impune g\u0103sirea unor optimiz\u0103ri care s\u0103 ne permit\u0103 s\u0103 nu mai avem nevoie de o alt\u0103 c\u0103utare binar\u0103.</p> <p>Dac\u0103 ne g\u00e2ndim la un interval de tipul \\([a, b]\\), noi vom putea efectua urm\u0103toarea opera\u021bie f\u0103r\u0103 probleme, p\u00e2n\u0103 c\u00e2nd ajungem la un interval de lungime \\(1\\):</p> <ul> <li>afl\u0103m primul interval inclus \u00een intervalul \\([a, b]\\).</li> <li>dac\u0103 acest interval are un maxim mai mare sau egal ca \\(x\\), atunci c\u0103ut\u0103m \u00een   acest subinterval</li> <li>altfel, vom c\u0103uta \u00een subintervalele de la dreapta.</li> </ul> <p>Astfel, am demonstrat c\u0103 putem folosi o strategie de tip divide et impera pentru a aborda aceast\u0103 problem\u0103, a\u0219a cum se poate vedea \u00een segmentul de cod de mai jos:</p> <pre><code>int query(int node, int start, int end, int query_start, int query_end, int x) {\n    // nu exist\u0103 valoarea\n    if (end &lt; query_start || start &gt; query_end) {\n        return -1;\n    }\n\n    if (start == end) {\n        if (segtree[start] &gt;= x) {\n            return start;\n        }\n\n        // nu am g\u0103sit valoarea\n        return -1;\n    }\n\n    int mid = start + (end - start) / 2;\n    int left_result = query(node &lt;&lt; 1, start, mid, query_start, query_end, x);\n    if (left_result != -1) {\n        return left_result;\n    }\n\n    return query(node &lt;&lt; 1 | 1, mid + 1, end, query_start, query_end, x);\n}\n</code></pre>","tags":["structuri de date","arbori de intervale","lazy propagation"]},{"location":"dificil/segment-trees-part2/#problema-exemplu-hotel-queries-cses","title":"Problem\u0103 exemplu: Hotel Queries - CSES","text":"<p>Pentru a rezolva aceast\u0103 problem\u0103, va trebui s\u0103 folosim aceast\u0103 tehnic\u0103 pentru a afla prima pozi\u021bie din \u0219ir cu o valoare mai mare dec\u00e2t valoarea dat\u0103, iar dac\u0103 o g\u0103sim, vom sc\u0103dea \\(x\\) din valoarea acelui num\u0103r pentru a simula procesul prin care oamenii se cazeaz\u0103 la hotel.</p> <p>Mai jos pute\u021bi vedea codul surs\u0103 pentru problema dat\u0103.</p> <pre><code>#include &lt;iostream&gt;\n\nconstexpr int N = 2e5 + 1;\nint hotels, groups, rooms[N + 1], segtree[4 * N + 1];\n\nvoid build(int node, int start, int end) {\n    if (start == end) {\n        segtree[node] = rooms[start];\n        return;\n    }\n    int mid = start + (end - start) / 2;\n\n    build(node &lt;&lt; 1, start, mid);\n    build(node &lt;&lt; 1 | 1, mid + 1, end);\n\n    segtree[node] = std::max(segtree[node &lt;&lt; 1], segtree[node &lt;&lt; 1 | 1]);\n}\n\nvoid update(int node, int start, int end, int index, int value) {\n    if (start == end) {\n        segtree[node] = value;\n        return;\n    }\n\n    int mid = start + (end - start) / 2;\n    if (index &lt;= mid) {\n        update(node &lt;&lt; 1, start, mid, index, value);\n    } else {\n        update(node &lt;&lt; 1 | 1, mid + 1, end, index, value);\n    }\n\n    segtree[node] = std::max(segtree[node &lt;&lt; 1], segtree[node &lt;&lt; 1 | 1]);\n}\n\nint query(int node, int start, int end, int threshold) {\n    if (start == end) {\n        return start;\n    }\n\n    int mid = start + (end - start) / 2;\n\n    if (segtree[node &lt;&lt; 1] &gt;= threshold) {\n        return query(node &lt;&lt; 1, start, mid, threshold);\n    }\n\n    return query(node &lt;&lt; 1 | 1, mid + 1, end, threshold);\n}\n\nint main() {\n    std::cin &gt;&gt; hotels &gt;&gt; groups;\n\n    for (int i = 1; i &lt;= hotels; ++i) {\n        std::cin &gt;&gt; rooms[i];\n    }\n\n    build(1, 1, hotels);\n    for (int i = 1; i &lt;= groups; ++i) {\n        int required_rooms;\n        std::cin &gt;&gt; required_rooms;\n\n        if (segtree[1] &lt; required_rooms) {\n            std::cout &lt;&lt; 0 &lt;&lt; \" \";\n            continue;\n        }\n\n        int hotel_index = query(1, 1, hotels, required_rooms);\n        std::cout &lt;&lt; hotel_index &lt;&lt; \" \";\n\n        rooms[hotel_index] -= required_rooms;\n        update(1, 1, hotels, hotel_index, rooms[hotel_index]);\n    }\n\n    return 0;\n}\n</code></pre>","tags":["structuri de date","arbori de intervale","lazy propagation"]},{"location":"dificil/segment-trees-part2/#actualizari-pe-interval-lazy-propagation","title":"Actualiz\u0103ri pe interval - Lazy Propagation","text":"<p>Am v\u0103zut p\u00e2n\u0103 acum \u00een probleme faptul c\u0103 putem folosi arborii de intervale \u00een mod eficient pentru a putea efectua actualiz\u0103ri pe unele valori precum \u0219i interog\u0103ri pe intervale. Totu\u0219i, aceste lucruri nu ne ajut\u0103 \u00eenc\u0103 s\u0103 rezolv\u0103m situa\u021biile \u00een care trebuie s\u0103 schimb\u0103m valorile de pe un interval \u0219i s\u0103 prelucr\u0103m \u0219irul conform acestor opera\u021bii.</p> <p>Tehnica folosit\u0103 \u00een aceste situa\u021bii este una specific\u0103 \u0219i se nume\u0219te lazy propagation \u0219i vom putea folosi aceast\u0103 tehnic\u0103 pentru a rezolva problemele ce \u021bin de actualizarea unui interval de valori \u0219i r\u0103spunderea la acelea\u0219i tipuri de queryuri.</p> <p>Cel mai important principiu pe care \u00eel aplic\u0103m atunci c\u00e2nd vom prelucra asemenea actualiz\u0103ri este acela c\u0103 vom vrea s\u0103 le am\u00e2n\u0103m c\u00e2t mai mult posibil (de aici vine \u0219i denumirea de lazy propagation), iar pentru a face asta, \u00een loc s\u0103 actualiz\u0103m fiecare valoare individual\u0103, vom \u021bine eviden\u021ba existen\u021bei acelei actualiz\u0103ri \u00eentr-un vector auxiliar, lazy, care va avea drept rol p\u0103strarea unei cantit\u0103\u021bi minime de informa\u021bie care s\u0103 ne permit\u0103 s\u0103 reconstituim actualiz\u0103rile care s-au f\u0103cut la un moment dat.</p>","tags":["structuri de date","arbori de intervale","lazy propagation"]},{"location":"dificil/segment-trees-part2/#problema-introductiva-range-update-queries-cses","title":"Problem\u0103 introductiv\u0103: Range Update Queries - CSES","text":"<p>Aici va trebui s\u0103 cre\u0219tem valorile dintr-un interval cu o valoare dat\u0103 \u0219i s\u0103 afl\u0103m valoarea de la o anumit\u0103 pozi\u021bie. De\u0219i aceast\u0103 problem\u0103 are \u0219i alte solu\u021bii (precum cea cu arbori indexa\u021bi binari), aici ne vom concentra pe \u00eenv\u0103\u021barea acestei noi tehnici.</p> <p>\u00cen cazul acestei probleme, deoarece avem de f\u0103cut actualiz\u0103ri pe interval \u00een care cre\u0219tem valori, asta ne d\u0103 motiva\u021bia \u0219i pentru ce vom stoca \u00een vectorul lazy, \u0219i anume suma valorilor din queryurile care au atins nodul respectiv, aceasta fiind singura diferen\u021b\u0103 major\u0103 \u00eentre codul unei probleme obi\u0219nuite ce necesit\u0103 arbori de intervale \u0219i problemele cu lazy propagation.</p> <p>Ulterior, c\u00e2nd proces\u0103m o interogare, vom parcurge \u00een jos drumul de la r\u0103d\u0103cin\u0103 la nodul curent \u0219i vom procesa actualiz\u0103rile relevante, \u00eemp\u0103r\u021bind \u00een dou\u0103 con\u021binutul queryurilor, eventual unind con\u021binutul queryului cu alte queryuri anterioare.</p> <p>Observa\u021bie</p> <p>Va fi foarte important atunci c\u00e2nd trecem \u00eentr-un nod s\u0103 proces\u0103m imediat con\u021binutul din lazy pentru a putea asigura p\u0103strarea corect\u0103 a valorilor reale din fiecare nod.</p> <p>Mai jos pute\u021bi vedea codul surs\u0103, unde opera\u021biile specifice metodei lazy propagation sunt explicate \u00een detaliu. Se remarc\u0103 aten\u021bia la detalii atunci c\u00e2nd transfer\u0103m con\u021binutul unui query de la un nod la unul din fii, precum \u0219i faptul c\u0103 realiz\u0103m actualiz\u0103rile imediat ce vizit\u0103m un nod.</p> <pre><code>#include &lt;iostream&gt;\n#include &lt;vector&gt;\n\n// range set value, range query for sum segtree, can be easily modified for\n// other things\nclass SegmentTree {\nprivate:\n    int size_;\n    std::vector&lt;long long&gt; segtree_;\n    std::vector&lt;long long&gt; lazy_;\n\npublic:\n    void init(int size) {\n        size_ = size;\n        segtree_.resize(1 + 4 * size);\n        lazy_.resize(1 + 4 * size);\n    }\n\n    void lazy(int node, int start, int end) {\n        segtree_[node] += lazy_[node] * (end - start + 1);\n\n        // Dac\u0103 nodul curent nu este o frunz\u0103\n        if (start != end) {\n            lazy_[node &lt;&lt; 1] += lazy_[node];\n            lazy_[node &lt;&lt; 1 | 1] += lazy_[node];\n        }\n\n        lazy_[node] = 0;\n    }\n\n    void build(int node, int start, int end, std::vector&lt;int&gt; &amp;data) {\n        if (start == end) {\n            segtree_[node] = data[start];\n            return;\n        }\n\n        int mid = start + (end - start) / 2;\n\n        build(node &lt;&lt; 1, start, mid, data);\n        build(node &lt;&lt; 1 | 1, mid + 1, end, data);\n\n        segtree_[node] = segtree_[node &lt;&lt; 1] + segtree_[node &lt;&lt; 1 | 1];\n    }\n\n    void update(int node, int start, int end, int query_start, int query_end,\n                int value) {\n        // Dac\u0103 avem lazy, actualiz\u0103m\n        if (lazy_[node]) {\n            lazy(node, start, end);\n        }\n\n        if (end &lt; query_start || start &gt; query_end) {\n            return;\n        }\n\n        if (query_start &lt;= start &amp;&amp; end &lt;= query_end) {\n            lazy_[node] = value;\n            lazy(node, start, end);  // actualiz\u0103m\n            return;\n        }\n\n        int mid = start + (end - start) / 2;\n\n        update(node &lt;&lt; 1, start, mid, query_start, query_end, value);\n        update(node &lt;&lt; 1 | 1, mid + 1, end, query_start, query_end, value);\n\n        segtree_[node] = segtree_[node &lt;&lt; 1] + segtree_[node &lt;&lt; 1 | 1];\n    }\n\n    long long query(int node, int start, int end, int query_start,\n                    int query_end) {\n        // Dac\u0103 avem lazy, actualiz\u0103m\n        if (lazy_[node]) {\n            lazy(node, start, end);\n        }\n\n        if (end &lt; query_start || start &gt; query_end) {\n            return 0;\n        }\n\n        if (query_start &lt;= start &amp;&amp; end &lt;= query_end) {\n            return segtree_[node];\n        }\n\n        int mid = start + (end - start) / 2;\n        return query(node &lt;&lt; 1, start, mid, query_start, query_end)\n             + query(node &lt;&lt; 1 | 1, mid + 1, end, query_start, query_end);\n    }\n};\n\nSegmentTree segtree;\n\nint main() {\n    int n, queries;\n    std::cin &gt;&gt; n &gt;&gt; queries;\n\n    segtree.init(n);\n\n    std::vector&lt;int&gt; values(n + 1);\n    for (int i = 1; i &lt;= n; i++) {\n        std::cin &gt;&gt; values[i];\n    }\n\n    segtree.build(1, 1, n, values);\n\n    for (int i = 1; i &lt;= queries; i++) {\n        int t;\n        std::cin &gt;&gt; t;\n\n        if (t == 1) {\n            int start, end, value;\n            std::cin &gt;&gt; start &gt;&gt; end &gt;&gt; value;\n            segtree.update(1, 1, n, start, end, value);\n        } else {\n            int index;\n            std::cin &gt;&gt; index;\n            std::cout &lt;&lt; segtree.query(1, 1, n, index, index) &lt;&lt; '\\n';\n        }\n    }\n\n    return 0;\n}\n</code></pre>","tags":["structuri de date","arbori de intervale","lazy propagation"]},{"location":"dificil/segment-trees-part2/#problema-simple-info1cup-2019","title":"Problema Simple - Info1Cup 2019","text":"<p>Pentru a rezolva aceast\u0103 problem\u0103, vom \u00eencepe prin a precalcula pentru fiecare interval valoarea maxim\u0103 par\u0103, valoarea maxim\u0103 impar\u0103, valoarea minim\u0103 par\u0103 \u0219i valoarea minim\u0103 impar\u0103, deoarece o observa\u021bie important\u0103 este faptul c\u0103 ad\u0103ugarea unei valori pe un interval nu va schimba ordinea relativ\u0103 a acestor valori.</p> <p>Astfel, vom p\u0103stra pentru fiecare nod \u00een lazy un contor care \u021bine cont de suma actualiz\u0103rilor efectuate la acea pozi\u021bie, pentru a stabili dac\u0103 trebuie s\u0103 lu\u0103m valorile originale sau cele inverse (minim par/maxim impar) sau (maxim par/minim impar).</p> <p>Apoi, vom avea grij\u0103 la implementarea solu\u021biei finale s\u0103 includem aceste date \u00een r\u0103spunsul final.</p> <pre><code>#include &lt;iostream&gt;\n#include &lt;vector&gt;\n\nstruct str {\n    long long min_even, max_even;\n    long long min_odd, max_odd;\n};\n\nclass SegmentTree {\nprivate:\n    int size_;\n    std::vector&lt;str&gt; segtree_;\n    std::vector&lt;long long&gt; lazy_;\n\npublic:\n    void init(int sz) {\n        size_ = sz;\n        segtree_.resize(1 + 4 * sz);\n        lazy_.resize(1 + 4 * sz);\n    }\n\n    void lazy(int node, int start, int end) {\n        if (segtree_[node].min_even != -1) {\n            segtree_[node].min_even += lazy_[node];\n            segtree_[node].max_even += lazy_[node];\n        }\n\n        if (segtree_[node].min_odd != -1) {\n            segtree_[node].min_odd += lazy_[node];\n            segtree_[node].max_odd += lazy_[node];\n        }\n\n        if (lazy_[node] % 2 == 1) {\n            std::swap(segtree_[node].min_odd, segtree_[node].min_even);\n            std::swap(segtree_[node].max_odd, segtree_[node].max_even);\n        }\n\n        if (start != end) {\n            lazy_[node &lt;&lt; 1] += lazy_[node];\n            lazy_[node &lt;&lt; 1 | 1] += lazy_[node];\n        }\n\n        lazy_[node] = 0;\n    }\n\n    str cmp(str lhs, str rhs) {\n        str ans = {-1, -1, -1, -1};\n\n        if (lhs.min_even != -1) {\n            ans.min_even = lhs.min_even;\n        }\n\n        if (ans.min_even == -1\n            || (rhs.min_even != -1 &amp;&amp; rhs.min_even &lt; ans.min_even)) {\n            ans.min_even = rhs.min_even;\n        }\n\n        if (lhs.min_odd != -1) {\n            ans.min_odd = lhs.min_odd;\n        }\n\n        if (ans.min_odd == -1\n            || (rhs.min_odd != -1 &amp;&amp; rhs.min_odd &lt; ans.min_odd)) {\n            ans.min_odd = rhs.min_odd;\n        }\n\n        if (lhs.max_even != -1) {\n            ans.max_even = lhs.max_even;\n        }\n\n        if (ans.max_even == -1\n            || (rhs.max_even != -1 &amp;&amp; rhs.max_even &gt; ans.max_even)) {\n            ans.max_even = rhs.max_even;\n        }\n\n        if (lhs.max_odd != -1) {\n            ans.max_odd = lhs.max_odd;\n        }\n\n        if (ans.max_odd == -1\n            || (rhs.max_odd != -1 &amp;&amp; rhs.max_odd &gt; ans.max_odd)) {\n            ans.max_odd = rhs.max_odd;\n        }\n\n        return ans;\n    }\n\n    void build(int node, int start, int end, std::vector&lt;int&gt; &amp;data) {\n        if (start == end) {\n            if (data[start] % 2 == 0) {\n                segtree_[node] = {data[start], data[start], -1, -1};\n            } else {\n                segtree_[node] = {-1, -1, data[start], data[start]};\n            }\n            return;\n        }\n\n        int mid = start + (end - start) / 2;\n\n        build(node &lt;&lt; 1, start, mid, data);\n        build(node &lt;&lt; 1 | 1, mid + 1, end, data);\n        segtree_[node] = cmp(segtree_[node &lt;&lt; 1], segtree_[node &lt;&lt; 1 | 1]);\n    }\n\n    void update(int node, int start, int end, int query_start, int query_end,\n                int val) {\n        if (lazy_[node]) {\n            lazy(node, start, end);\n        }\n\n        if (end &lt; query_start || start &gt; query_end) {\n            return;\n        }\n\n        if (query_start &lt;= start &amp;&amp; end &lt;= query_end) {\n            lazy_[node] = val;\n            lazy(node, start, end);\n            return;\n        }\n\n        int mid = start + (end - start) / 2;\n\n        update(node &lt;&lt; 1, start, mid, query_start, query_end, val);\n        update(node &lt;&lt; 1 | 1, mid + 1, end, query_start, query_end, val);\n\n        segtree_[node] = cmp(segtree_[node &lt;&lt; 1], segtree_[node &lt;&lt; 1 | 1]);\n    }\n\n    str query(int node, int start, int end, int query_start, int query_end) {\n        if (lazy_[node]) {\n            lazy(node, start, end);\n        }\n\n        if (end &lt; query_start || start &gt; query_end) {\n            return {-1, -1, -1, -1};\n        }\n\n        if (query_start &lt;= start &amp;&amp; end &lt;= query_end) {\n            return segtree_[node];\n        }\n\n        int mid = start + (end - start) / 2;\n        return cmp(query(node &lt;&lt; 1, start, mid, query_start, query_end),\n                   query(node &lt;&lt; 1 | 1, mid + 1, end, query_start, query_end));\n    }\n};\n\nSegmentTree segtree;\nint main() {\n    int n;\n    std::cin &gt;&gt; n;\n\n    segtree.init(n);\n\n    std::vector&lt;int&gt; values(n + 1);\n    for (int i = 1; i &lt;= n; i++) {\n        std::cin &gt;&gt; values[i];\n    }\n\n    int queries;\n    std::cin &gt;&gt; queries;\n\n    segtree.build(1, 1, n, values);\n\n    for (int i = 1; i &lt;= queries; i++) {\n        int t;\n        std::cin &gt;&gt; t;\n\n        if (t == 0) {\n            int start, end, value;\n            std::cin &gt;&gt; start &gt;&gt; end &gt;&gt; value;\n            segtree.update(1, 1, n, start, end, value);\n        } else {\n            int start, end;\n            std::cin &gt;&gt; start &gt;&gt; end;\n            str ans = segtree.query(1, 1, n, start, end);\n            std::cout &lt;&lt; ans.min_even &lt;&lt; \" \" &lt;&lt; ans.max_odd &lt;&lt; '\\n';\n        }\n    }\n    return 0;\n}\n</code></pre>","tags":["structuri de date","arbori de intervale","lazy propagation"]},{"location":"dificil/segment-trees-part2/#problema-range-updates-and-sums-cses","title":"Problema Range Updates and Sums CSES","text":"<p>Pentru a rezolva aceast\u0103 problem\u0103, va trebui s\u0103 fim aten\u021bi la diferitele tipuri de opera\u021bii pe care le primim, precum \u0219i cum codific\u0103m schimb\u0103rile (sum\u0103 sau schimbarea unei valori), lucruri ce se pot face doar cu o implementare clar\u0103 a structurii de date folosite.</p> <p>Pentru a nu folosi mai mul\u021bi vectori de tip lazy, am codificat schimb\u0103rile de valori cu numere negative \u0219i ad\u0103ug\u0103rile cu numere pozitive, pentru a \u0219ti tipul de opera\u021bie folosit. Ulterior, queryurile de sum\u0103 devin asem\u0103n\u0103toare celor obi\u0219nuite.</p> <p>Mai jos g\u0103si\u021bi solu\u021bia care ia accepted.</p> <pre><code>#include &lt;iostream&gt;\n#include &lt;vector&gt;\n\nclass SegmentTree {\nprivate:\n    int size_;\n    std::vector&lt;long long&gt; segtree_;\n    std::vector&lt;long long&gt; lazy_;\n\npublic:\n    void init(int size) {\n        size_ = size;\n        segtree_.resize(1 + 4 * size);\n        lazy_.resize(1 + 4 * size);\n    }\n\n    void lazy(int node, int start, int end) {\n        if (lazy_[node] &gt; 0) {\n            segtree_[node] += lazy_[node] * (end - start + 1);\n        } else {\n            segtree_[node] = (-lazy_[node]) * (end - start + 1);\n        }\n\n        if (start != end) {\n            if (lazy_[node] &lt; 0) {\n                lazy_[node &lt;&lt; 1] = lazy_[node];\n                lazy_[node &lt;&lt; 1 | 1] = lazy_[node];\n            } else {\n                if (lazy_[node &lt;&lt; 1] &lt; 0) {\n                    lazy_[node &lt;&lt; 1] -= lazy_[node];\n                } else {\n                    lazy_[node &lt;&lt; 1] += lazy_[node];\n                }\n\n                if (lazy_[node &lt;&lt; 1 | 1] &lt; 0) {\n                    lazy_[node &lt;&lt; 1 | 1] -= lazy_[node];\n                } else {\n                    lazy_[node &lt;&lt; 1 | 1] += lazy_[node];\n                }\n            }\n        }\n\n        lazy_[node] = 0;\n    }\n\n    void build(int node, int start, int end, std::vector&lt;int&gt; &amp;data) {\n        if (start == end) {\n            segtree_[node] = data[start];\n            return;\n        }\n\n        int mid = start + (end - start) / 2;\n\n        build(node &lt;&lt; 1, start, mid, data);\n        build(node &lt;&lt; 1 | 1, mid + 1, end, data);\n\n        segtree_[node] = segtree_[node &lt;&lt; 1] + segtree_[node &lt;&lt; 1 | 1];\n    }\n\n    void update(int node, int start, int end, int query_start, int query_end,\n                int value) {\n        if (lazy_[node]) {\n            lazy(node, start, end);\n        }\n\n        if (end &lt; query_start || start &gt; query_end) {\n            return;\n        }\n\n        if (query_start &lt;= start &amp;&amp; end &lt;= query_end) {\n            lazy_[node] = value;\n            lazy(node, start, end);\n            return;\n        }\n\n        int mid = start + (end - start) / 2;\n\n        update(node &lt;&lt; 1, start, mid, query_start, query_end, value);\n        update(node &lt;&lt; 1 | 1, mid + 1, end, query_start, query_end, value);\n\n        segtree_[node] = segtree_[node &lt;&lt; 1] + segtree_[node &lt;&lt; 1 | 1];\n    }\n\n    long long query(int node, int start, int end, int query_start,\n                    int query_end) {\n        if (lazy_[node]) {\n            lazy(node, start, end);\n        }\n\n        if (end &lt; query_start || start &gt; query_end) {\n            return 0;\n        }\n\n        if (query_start &lt;= start &amp;&amp; end &lt;= query_end) {\n            return segtree_[node];\n        }\n\n        int mid = start + (end - start) / 2;\n\n        return query(node &lt;&lt; 1, start, mid, query_start, query_end)\n             + query(node &lt;&lt; 1 | 1, mid + 1, end, query_start, query_end);\n    }\n};\n\nSegmentTree segtree;\nint main() {\n    int n, queries;\n    std::cin &gt;&gt; n &gt;&gt; queries;\n\n    segtree.init(n);\n\n    std::vector&lt;int&gt; values(n + 1);\n    for (int i = 1; i &lt;= n; i++) {\n        std::cin &gt;&gt; values[i];\n    }\n\n    segtree.build(1, 1, n, values);\n\n    for (int i = 1; i &lt;= queries; i++) {\n        int t;\n        std::cin &gt;&gt; t;\n\n        int start, end, value;\n        std::cin &gt;&gt; start &gt;&gt; end;\n\n        if (t == 1) {\n            std::cin &gt;&gt; value;\n            segtree.update(1, 1, n, start, end, value);\n        } else if (t == 2) {\n            std::cin &gt;&gt; value;\n            segtree.update(1, 1, n, start, end, -value);\n        } else if (t == 3) {\n            std::cout &lt;&lt; segtree.query(1, 1, n, start, end) &lt;&lt; '\\n';\n        }\n    }\n\n    return 0;\n}\n</code></pre>","tags":["structuri de date","arbori de intervale","lazy propagation"]},{"location":"dificil/segment-trees-part2/#concluzii","title":"Concluzii","text":"<p>C\u0103utarea binar\u0103 \u00een arborele de intervale, precum \u0219i lazy propagation sunt tehnici foarte des utilizate \u00een aceste probleme, fiind la baza multor aplica\u021bii, a\u0219a cum a\u021bi putut observa \u00een acest articol. O recomandare pe care o oferim este aceea de a \u0219ti foarte bine cum s\u0103 implementa\u021bi lazy propagation deoarece aceast\u0103 varia\u021bie a arborilor de intervale poate pune dificult\u0103\u021bi dac\u0103 nu este abordat\u0103 cum trebuie.</p> <p>Recomand\u0103m abordarea unui num\u0103r c\u00e2t mai mare de probleme dintre cele prezentate aici, precum \u0219i a problemelor de pe CSES de la sec\u021biunea Range Queries.</p>","tags":["structuri de date","arbori de intervale","lazy propagation"]},{"location":"dificil/segment-trees-part2/#probleme-suplimentare","title":"Probleme suplimentare","text":"<ul> <li>IIOT Predictor Machine</li> <li>CSES Prefix Sum Queries</li> <li>USACO Platinum Counting Haybales</li> <li>Infoarena fibo4</li> <li>Codeforces DZY Loves Fibonacci Numbers</li> <li>ONI 2023 Baraj Seniori sirbun</li> <li>IOI 2014 Wall</li> <li>RoAlgo Contest #12 - Nice Apple Tree</li> <li>ONI 2024 Baraj Seniori balama</li> <li>Biscuiti infoarena</li> <li>Luffpar infoarena</li> <li>USACO Platinum Bessie's Snow Cow</li> <li>JOI 2018 Bubblesort 2</li> <li>Problemele cu lazy propagation de pe kilonova</li> </ul>","tags":["structuri de date","arbori de intervale","lazy propagation"]},{"location":"dificil/segment-trees-part2/#resurse-suplimentare","title":"Resurse suplimentare","text":"<ul> <li>Range Update Range Query - USACO Guide</li> <li>CP Algorithms - Range updates (Lazy Propagation)</li> <li>Historic Sums and Range Add Range Sum</li> </ul>","tags":["structuri de date","arbori de intervale","lazy propagation"]},{"location":"dificil/segment-trees/","title":"Arbori de intervale","text":"<p>\u00cen competi\u021biile de informatic\u0103 \u0219i la olimpiad\u0103 se \u00eent\u00e2lnesc adesea probleme care implic\u0103 operarea pe subsecven\u021bele unui vector. Spre exemplu, cum putem calcula eficient suma, maximul sau minimul pe o subsecven\u021b\u0103 a unui vector, mai ales c\u00e2nd acesta sufer\u0103 modific\u0103ri \u00een timp real?</p> <p>Observa\u021bie</p> <p>Dac\u0103 vectorul este static (nu sufer\u0103 modific\u0103ri), putem utiliza tehnici simple precum vectori de sume par\u021biale sau RMQ (Range Minimum Query). Totu\u0219i, \u00een scenariile unde vectorul se modific\u0103 frecvent, aceste tehnici devin ineficiente. Opera\u021biile de query au o complexitate de \\(\\mathcal{O}(1)\\) at\u00e2t pentru sume par\u021biale, c\u00e2t \u0219i pentru RMQ. \u00cens\u0103, pentru actualiz\u0103ri, trebuie reconstruit tot tabelul de valori, ceea ce duce la o complexitate de \\(\\mathcal{O}(n)\\) pentru sume par\u021biale \u0219i \\(\\mathcal{O}(n \\log n)\\) pentru RMQ.</p> <p>Arborii de intervale (cunoscu\u021bi \u0219i sub denumirea de segment trees sau aint \u00een jargonul rom\u00e2nesc) reprezint\u0103 o solu\u021bie elegant\u0103 \u0219i eficient\u0103 pentru acest tip de probleme, permi\u021b\u00e2nd efectuarea rapid\u0103 de interog\u0103ri \u0219i actualiz\u0103ri \u00een \\(\\mathcal{O}(\\log n)\\) pentru ambele opera\u021bii.</p> <p>\u00cen acest articol, vom explora conceptele de baz\u0103 ale arborilor de intervale, modul de construire \u0219i utilizare a acestora, \u0219i vom analiza c\u00e2teva aplica\u021bii frecvente \u00een problemele de olimpiad\u0103. Vom \u00eencepe prin a defini structura unui arbore de intervale \u0219i vom continua prin a explica opera\u021biile de actualizare, interogare \u0219i implement\u0103rile acestora. \u00cen final, vom discuta \u0219i c\u00e2teva probleme ap\u0103rute \u00een concursurile de programare competitiv\u0103. F\u0103r\u0103 prea mult\u0103 vorb\u0103rie, s\u0103 \u00eencepem!</p>","tags":["structuri de date","arbori","queryuri"]},{"location":"dificil/segment-trees/#problema-clasica","title":"Problema clasic\u0103","text":"<p>Problema</p> <p>Fie un vector \\(A\\) cu \\(N\\) elemente. Asupra lui se vor face \\(M\\) opera\u021bii de tipul:</p> <ul> <li><code>update(pos, val)</code> - actualizeaz\u0103 valoarea de pe pozi\u021bia <code>pos</code> \u00een <code>val</code></li> <li><code>query(x, y)</code> - afla\u021bi suma elementelor din intervalul \\([x, y]\\), $(A_{st}</li> <li>A_{st+1} + ... + A_{dr})$</li> </ul>","tags":["structuri de date","arbori","queryuri"]},{"location":"dificil/segment-trees/#structura-unui-arbore-de-intervale","title":"Structura unui arbore de intervale","text":"<p>Un arbore de intervale este un arbore binar care este folosit pentru a stoca informa\u021bii despre intervalele unui vector. Fiecare nod din arbore reprezint\u0103 un interval \u0219i stocheaz\u0103 o anumit\u0103 valoare (de exemplu, suma, minimul sau maximul) pentru intervalul respectiv.</p>","tags":["structuri de date","arbori","queryuri"]},{"location":"dificil/segment-trees/#cum-se-formeaza-un-arbore-de-intervale","title":"Cum se formeaz\u0103 un arbore de intervale?","text":"<p>S\u0103 consider\u0103m un vector \\(A\\) de dimensiune \\(N\\). Arborele de intervale asociat acestui vector se construie\u0219te astfel:</p> <ul> <li>R\u0103d\u0103cina arborelui va fi nodul 1 \u0219i va avea asociat r\u0103spunsul pentru   intervalul \\([1,n]\\).</li> <li>Un nod \\(k\\) are asociat un interval \\([st,dr]\\), iar acesta are doi fii ce se vor   afla pe pozi\u021biile \\(2 \\cdot k\\) (fiul din st\u00e2nga) \u0219i \\(2 \\cdot k + 1\\) (fiul din   dreapta). Fiul din st\u00e2nga va avea r\u0103spunsul pentru intervalul \\([st, m]\\), iar   fiul din dreapta pentru \\([m+1, dr]\\), unde m este mijlocul intervalului.</li> </ul> <p>Reprezentare \u00een memorie</p> <p>De\u0219i conceptul de arbore de intervale este unul de tip arbore binar, \u00een practic\u0103, structura este stocat\u0103 \u00een memorie sub forma unui vector. Astfel, fiecare nod din arbore corespunde unei pozi\u021bii din acest vector, ceea ce ne permite s\u0103 acces\u0103m eficient nodurile arborelui folosind opera\u021bii de indexare.</p> <p>S\u0103 consider\u0103m vectorul \\(A=[5,8,6,3,2,7,2,6]\\), arborele de intervale asociat vectorului \\(A\\) va ar\u0103ta \u00een felul urm\u0103tor:</p> <p></p>","tags":["structuri de date","arbori","queryuri"]},{"location":"dificil/segment-trees/#care-este-memoria-necesara-stocarii","title":"Care este memoria necesara stocarii ?","text":"<ul> <li>Num\u0103rul de frunze: Arborele de intervale are N frunze, c\u00e2te una pentru fiecare   element din vectorul original. Aceste frunze sunt reprezentate \u00een ultimul   nivel al arborelui.</li> <li>Num\u0103rul de noduri interne: avem \\(N-1\\) noduri interne.</li> <li>\u00cen\u0103l\u021bimea maxim\u0103 a unui arbore binar complet cu \\(N\\) frunze este \\(\\lceil   \\log_2(N) \\rceil\\).</li> </ul> <p>Astfel, \u00een caz general, num\u0103rul total de noduri (frunze + noduri interne) dintr-un arbore binar complet de \u00een\u0103l\u021bime \\(h\\) este:</p> \\[ \\begin{align*} 2^{h+1} - 1 &amp;= 2 \\cdot 2^{\\lceil \\log_2(N) \\rceil} - 1 \\\\[0.2cm] &amp;\\leq 2 \\cdot 2^{\\log_2(N) + 1} - 1 \\\\[0.2cm] &amp;\\leq 4 \\cdot 2^{\\log_2(N)} - 1 \\\\[0.2cm] &amp;= 4 \\cdot N - 1 \\end{align*} \\] <p>Observa\u021bie</p> <p>Dimensiunea \\(4 \\cdot N\\) asigur\u0103 faptul c\u0103 avem suficient spa\u021biu pentru a construi un arbore de intervale complet, indiferent de dimensiunea vectorului original. Aceast\u0103 alocare permite men\u021binerea unui arbore echilibrat \u0219i eficient, permi\u021b\u00e2nd efectuarea de opera\u021bii de actualizare \u0219i interogare \u00eentr-un mod optim.</p>","tags":["structuri de date","arbori","queryuri"]},{"location":"dificil/segment-trees/#operatii-elementare","title":"Opera\u021bii elementare","text":"","tags":["structuri de date","arbori","queryuri"]},{"location":"dificil/segment-trees/#construirea-arborelui","title":"Construirea arborelui","text":"<p>Construirea unui arbore de intervale se realizeaz\u0103 \u00eentr-un mod recursiv bottom-up, pornind de la frunzele arborelui (care corespund elementelor vectorului ini\u021bial) \u0219i merg\u00e2nd spre r\u0103d\u0103cin\u0103. La fiecare nivel al arborelui, valorile nodurilor se determin\u0103 pe baza fiilor s\u0103i.</p> <p>Aceast\u0103 opera\u021bie se efectueaz\u0103 \u00een \\(\\mathcal{O}(n)\\), unde \\(n\\) este num\u0103rul de elemente din vectorul ini\u021bial. De re\u021binut c\u0103 exist\u0103 \u0219i o alt\u0103 variant\u0103 de a construi arborele prin a actualiza fiecare pozi\u021bie cu valoarea din vector, \u00eens\u0103 duce la o complexitate de \\(\\mathcal{O}(n \\log n)\\).</p> <p></p> <p>\u00cen diagramele de mai sus, vedem c\u0103 la fiecare pas, valorile din noduri sunt calculate pe baza sumelor subintervalelor din fiul st\u00e2ng \u0219i fiul drept. Acest proces este realizat \u00een codul de mai jos prin apeluri recursive, unde func\u021bia <code>build</code> este apelat\u0103 pentru fiecare subarbore (st\u00e2ng \u0219i drept), iar valorile din noduri sunt apoi actualizate.</p> <p>De re\u021binut</p> <p>Arborii de intervale func\u021bioneaz\u0103 eficient doar cu opera\u021bii asociative (ex: suma, maximul, minimul, cmmdc). Asociativitatea permite combinarea rezultatelor din subintervale f\u0103r\u0103 a afecta corectitudinea rezultatului final.</p> <p>Mai jos sunt prezentate dou\u0103 modalit\u0103\u021bi de implementare, at\u00e2t recursiv\u0103, c\u00e2t \u0219i iterativ\u0103:</p> Construc\u021bie recursiv\u0103Construc\u021bie iterativ\u0103 <pre><code>void build(int node, int st, int dr) {\n    if (st == dr) {\n        aint[node] = A[st];\n        return;\n    }\n    int mid = (st + dr) / 2;\n\n    build(2 * node, st, mid);          // Construim subarborele st\u00e2ng\n    build(2 * node + 1, mid + 1, dr);  // Construim subarborele drept\n\n    // Actualiz\u0103m rezultatul nodului \u00een func\u021bie de rezultatele fiilor\n    aint[node] = aint[2 * node] + aint[2 * node + 1];\n}\n</code></pre> <pre><code>void build(int arr[]) {\n    // Inser\u0103m nodurile frunzelor \u00een arbore\n    for (int i = 0; i &lt; n; i++) {\n        tree[n + i] = arr[i];\n    }\n\n    // Construim arborele prin calcularea p\u0103rin\u021bilor\n    for (int i = n - 1; i &gt; 0; --i) {\n        tree[i] = tree[i &lt;&lt; 1] + tree[i &lt;&lt; 1 | 1];\n    }\n}\n</code></pre>","tags":["structuri de date","arbori","queryuri"]},{"location":"dificil/segment-trees/#operatia-de-update","title":"Opera\u021bia de update","text":"<p>Pentru a efectua un update, ne vom deplasa \u00een arbore p\u00e2n\u0103 la frunza care reprezint\u0103 elementul modificat.Odat\u0103 ce am ajuns la frunz\u0103, \u00eenlocuim valoarea veche cu cea nou\u0103.Pe m\u0103sur\u0103 ce revenim din recursivitate, actualiz\u0103m fiecare nod din drum, recalcul\u00e2nd valorile pe baza celor doi fii, pentru a ne asigura c\u0103 arborele r\u0103m\u00e2ne corect.</p> <p>Aceast\u0103 opera\u021bie se efectueaz\u0103 \u00een \\(\\mathcal{O}(\\log n)\\), unde \\(n\\) este num\u0103rul de elemente din vectorul ini\u021bial.Complexitatea este determinat\u0103 de \u00een\u0103l\u021bimea arborelui, deoarece actualizarea trebuie propagat\u0103 de la frunz\u0103 p\u00e2n\u0103 la r\u0103d\u0103cin\u0103.</p> <p>Mai jos este prezentat\u0103 o diagram\u0103 care ilustreaz\u0103 cum se modific\u0103 structura arborelui de intervale dup\u0103 ce actualiz\u0103m valoarea elementului de pe pozi\u021bia 5 din 2 \u00een 1.</p> <p></p> <p>\u00cen diagramele de mai sus, putem observa cum se modific\u0103 structura arborelui de intervale dup\u0103 ce modific\u0103m valoarea de pe pozi\u021bia 5 din 2 \u00een 7. Nodurile afectate de aceast\u0103 modificare sunt eviden\u021biate, iar valorile lor sunt actualizate pentru a reflecta noua configura\u021bie.</p> <p>Iat\u0103 un exemplu de implementare a acestei opera\u021bii \u00een C++:</p> <pre><code>void update(int pos, int val, int node, int st, int dr) {\n    if (st == dr) {\n        aint[node] = val; // Daca am ajuns la pozitia pos, schimbam valoarea\n        return;\n    }\n\n    int mid = (st + dr) / 2;\n    if (pos &lt;= mid)  // (1)\n        update(pos, val, node * 2, st, mid);\n    else\n        update(pos, val, node * 2 + 1, mid + 1, dr);\n\n    // La intoarcerea din apelul recursiv, actualizam nodul\n    aint[node] = aint[node * 2] + aint[node * 2 + 1];\n}\n</code></pre> <ol> <li>Dac\u0103 nodul se afl\u0103 \u00een intervalul din st\u00e2nga</li> </ol>","tags":["structuri de date","arbori","queryuri"]},{"location":"dificil/segment-trees/#operatia-de-query","title":"Operatia de query","text":"<p>C\u00e2nd dorim s\u0103 efectu\u0103m o interogare pe un interval \\([x, y]\\), scopul este de a g\u0103si rapid r\u0103spunsul pentru acest subinterval f\u0103r\u0103 a fi nevoie s\u0103 parcurgem to\u021bi termenii din vectorul ini\u021bial. Arborele de intervale face acest lucru prin \u00eemp\u0103r\u021birea intervalului \\([x, y]\\) \u00een subintervale mai mici, pe care le combin\u0103 pentru a g\u0103si r\u0103spunsul final.</p> <p>Aceast\u0103 descompunere se bazeaz\u0103 pe faptul c\u0103, pentru orice interval \\([st, dr]\\) gestionat de un nod din arbore, avem trei cazuri:</p> <ol> <li>Interval complet \u00een afara intervalului de interogare (gri \u00eenchis): Dac\u0103    intervalul \\([st, dr]\\) nu se suprapune cu intervalul \\([x, y]\\), atunci acel    interval nu contribuie la r\u0103spuns \u0219i putem returna direct 0 sau alt\u0103 valoare    de identitate (pentru maxim, minim etc.).</li> <li>Interval complet inclus \u00een intervalul de interogare (portocaliu): Dac\u0103    intervalul \\([st, dr]\\) este complet inclus \u00een intervalul \\([x, y]\\),    return\u0103m valoarea stocat\u0103 \u00een nodul respectiv, deoarece aceasta reprezint\u0103    deja r\u0103spunsul pentru \u00eentregul interval.</li> <li>Interval par\u021bial suprapus (galben): \u00cen acest caz, descompunem intervalul    \u00een dou\u0103 subintervale, corespunz\u0103toare fiilor nodului curent, \u0219i combin\u0103m    rezultatele interog\u0103rilor pentru aceste subintervale.</li> </ol> <p></p> <p>Iat\u0103 un exemplu de implementare a opera\u021biei de query \u00een C++:</p> <pre><code>int query(int x, int y, int node, int st, int dr) {\n    if (dr &lt; x || y &lt; st) {  // Daca intervalul se afla complet in afara\n        return 0;\n    }\n    if (x &lt;= st &amp;&amp; dr &lt;= y) {  // Daca intervalul este complet inclus\n        return aint[node];\n    }\n\n    int mid = (st + dr) / 2;\n    int Q_st = query(x, y, node * 2, st, mid);          // (1)\n    int Q_dr = query(x, y, node * 2 + 1, mid + 1, dr);  //(2)\n\n    return Q_st + Q_dr;\n}\n</code></pre> <ol> <li>R\u0103spunsul pentru intervalul din st\u00e2nga</li> <li>R\u0103spunsul pentru intervalul din dreapta</li> </ol>","tags":["structuri de date","arbori","queryuri"]},{"location":"dificil/segment-trees/#probleme-rezolvate","title":"Probleme rezolvate","text":"<p>Tip</p> <p>\u00cenainte de a trece la problemele rezolvate, te \u00eencurajez s\u0103 \u00eencerci s\u0103 implementezi structura de date \u0219i s\u0103 rezolvi singur c\u00e2teva probleme de baz\u0103. \u00cencearc\u0103 s\u0103 implementezi arborele de intervale pentru a calcula suma \u0219i maximul pe un interval dat. \u00cen modul acesta vei vedea unde ai neclarit\u0103\u021bi. Dup\u0103 ce te-ai convains c\u0103 ai \u00een\u021beles tot ce s-a discutat p\u00e2n\u0103 acum, te invit s\u0103 discut\u0103m c\u00e2teva probleme mai interesante. Un alt mic sfat ar fi s\u0103 \u00eencerci problema \u00eenainte de a urm\u0103ri rezolvarea complet\u0103.</p>","tags":["structuri de date","arbori","queryuri"]},{"location":"dificil/segment-trees/#1-arbint","title":"1. Arbint","text":"<p>Fie un vector $ A $ cu $ N $ elemente naturale. Asupra lui se vor face $ M $ opera\u021bii, codificate astfel \u00een fi\u0219ierul de intrare:</p> <ul> <li><code>0 a b</code> - S\u0103 se determine maximul din intervalul \\([a, b]\\).</li> <li><code>1 a b</code> - Valoarea elementului de pe pozi\u021bia $ a $ va deveni $ b $.</li> </ul> <p>Problema de baz\u0103, identic\u0103 cu cea pe care am rezolvat-o anterior, singura diferen\u021b\u0103 este c\u0103 acum trebuie s\u0103 calcul\u0103m elementul maxim. Solu\u021bia mea o pute\u021bi vedea aici.</p>","tags":["structuri de date","arbori","queryuri"]},{"location":"dificil/segment-trees/#2-maxq-oni-2007","title":"2. Maxq - ONI 2007","text":"<p>Johnie a \u00eenceput s\u0103 se joace cu un vector de numere. El dispune ini\u021bial de un vector $ V $ cu $ N $ numere \u00eentregi \u0219i poate efectua urm\u0103toarele opera\u021bii:</p> <ul> <li>Schimbarea elementului de pe pozi\u021bia $ p $ cu un alt num\u0103r \u00eentreg;</li> <li>Aflarea subsecven\u021bei de sum\u0103 maxim\u0103 din $ V $ inclus\u0103 \u00eentre indicii $ a $   \u0219i $ b $.</li> </ul> <p>Pentru rezolvarea acestei probleme vom adopta aceea\u0219i strategie, vom analiza modul \u00een care putem combina dou\u0103 segmente de lungime \\(L/2\\) \u00eentr-un singur segment de lungime \\(L\\). \u00cen cazul acestei probleme vom avea nevoie de mai multe informa\u021bii pentru fiecare nod:</p> <pre><code>struct Node {\n    int suma;     // Suma subsecventei\n    int prefmax;  // Prefixul de suma maxima\n    int suffmax;  // Sufixul de suma maxima\n    int smax;     // Subsecventa de suma maxima\n};\n</code></pre> <p>S\u0103 analizam pu\u021bin unde se poate afl\u0103 segmentul de sum\u0103 maxim\u0103 dup\u0103 combinarea celor dou\u0103 subsegmente.</p> <ul> <li>Segmentul de sum\u0103 maxim\u0103 se afl\u0103 \u00een intervalul din st\u00e2nga (L.smax)</li> <li>Segmentul de sum\u0103 maxim\u0103 se afl\u0103 \u00een intervalul din dreapta (R.smax)</li> <li>Segmentul de sum\u0103 maxim\u0103 \u00eencepe \u00een intervalul st\u00e2ng \u0219i se termin\u0103 \u00een cel   drept. Aceasta este reprezentat\u0103 prin combina\u021bia dintre L.suffmax \u0219i   R.prefmax.</li> </ul> <p></p> <p>Pentru a calcula prefixul de sum\u0103 maxim\u0103 pentru fiecare nod lu\u0103m maximul dintre prefixul g\u0103sit \u00een st\u00e2nga \u0219i \u00eentregul segment din st\u00e2nga la care se adaug\u0103 prefixul de sum\u0103 maxim\u0103 din dreapta.</p> <p></p> <p>Analog pentru sufixul de sum\u0103 maxim\u0103, doar c\u0103 lu\u0103m maximul dintre sufixul g\u0103sit \u00een dreapta \u0219i \u00eentregul segment care \u00eencepe \u00een dreapta \u0219i se continua \u00een st\u00e2nga.</p> <pre><code>struct Node {\n    int suma;     // Suma subsecventei\n    int prefmax;  // Prefixul de suma maxima\n    int suffmax;  // Sufixul de suma maxima\n    int smax;     // Subsecventa de suma maxima\n};\n\nNode merge(Node L, Node R) {\n    Node T;\n    T.suma = L.suma + R.suma;\n    T.prefmax = max(L.prefmax, L.suma + R.prefmax);\n    T.suffmax = max(R.suffmax, R.suma + L.suffmax);\n    T.smax = max(max(L.smax, R.smax), L.suffmax + R.prefmax);\n}\n</code></pre> <p>\u00centrebare</p> <p>Cu ce valori ini\u021bializ\u0103m frunzele arborelui?</p> <p>Iat\u0103 o posibila implementare a acestei probleme in C++:</p> <pre><code>#include &lt;algorithm&gt;\n#include &lt;fstream&gt;\n#include &lt;iostream&gt;\nusing namespace std;\n\nifstream fin(\"maxq.in\");\nofstream fout(\"maxq.out\");\n\nconst int MAXN = 2e5 + 1;\n\nstruct Node {\n    long long suma;     // Suma subsecventei\n    long long prefmax;  // Prefixul de suma maxima\n    long long sufmax;   // Sufixul de suma maxima\n    long long smax;     // Subsecventa de suma maxima\n} aint[MAXN * 4];\n\nint n;\n\nNode combine(Node L, Node R) {\n    Node T;\n    T.suma = L.suma + R.suma;\n    T.prefmax = max(L.prefmax, L.suma + R.prefmax);\n    T.sufmax = max(R.sufmax, R.suma + L.sufmax);\n    T.smax = max(max(L.smax, R.smax), L.sufmax + R.prefmax);\n    return T;\n}\n\nvoid update(int pos, int val, int node = 1, int st = 1, int dr = n) {\n    if (st == dr) {\n        if (val &gt; 0) {\n            aint[node] = {val, val, val, val};\n        } else {\n            aint[node] = {val, 0, 0, 0};\n        }\n        return;\n    }\n\n    int mid = (st + dr) / 2;\n    if (pos &lt;= mid) {\n        update(pos, val, node * 2, st, mid);\n    } else {\n        update(pos, val, node * 2 + 1, mid + 1, dr);\n    }\n    aint[node] = combine(aint[node * 2], aint[node * 2 + 1]);\n}\n\nNode query(int x, int y, int node = 1, int st = 1, int dr = n) {\n    if (y &lt; st || dr &lt; x) {\n        return {0, 0, 0, 0};\n    }\n    if (x &lt;= st &amp;&amp; dr &lt;= y) {\n        return aint[node];\n    }\n\n    int mid = (st + dr) / 2;\n    Node Q1 = query(x, y, node * 2, st, mid);\n    Node Q2 = query(x, y, node * 2 + 1, mid + 1, dr);\n    return combine(Q1, Q2);\n}\n\nint main() {\n    int q;\n    fin &gt;&gt; n;\n    for (int i = 1; i &lt;= n; i++) {\n        int x;\n        fin &gt;&gt; x;\n        update(i, x);\n    }\n\n    fin &gt;&gt; q;\n    while (q--) {\n        int op, x, y;\n        fin &gt;&gt; op &gt;&gt; x &gt;&gt; y;\n        if (op == 0) {\n            update(x + 1, y);\n        } else {\n            fout &lt;&lt; query(x + 1, y + 1).smax &lt;&lt; '\\n';\n        }\n    }\n\n    return 0;\n}\n</code></pre>","tags":["structuri de date","arbori","queryuri"]},{"location":"dificil/segment-trees/#3-nrinversiuni","title":"3. NrInversiuni","text":"<p>\u00cen aceast\u0103 problem\u0103, trebuie s\u0103 determin\u0103m num\u0103rul de inversiuni dintr-o permutare dat\u0103 a unui vector de lungime $ n $. O inversiune este o pereche ordonat\u0103 \\((i, j)\\) astfel \u00eenc\u00e2t $ 1 \\leq i &lt; j \\leq n $ \u0219i $ v[i] &gt; v[j] $.</p> <p>Solu\u021bia naiv\u0103 ar presupune s\u0103 verific\u0103m pentru fiecare pereche de elemente \\((i, j)\\) dac\u0103 $ v[i] &gt; v[j] $. Acest lucru necesit\u0103 dou\u0103 bucle imbricate, una pentru $ i $ \u0219i alta pentru $ j $, ceea ce duce la o complexitate de $ O(n^2) $.</p> <p>Solu\u021bia optim\u0103. Aceast\u0103 problem\u0103 poate fi rezolvat\u0103 eficient cu ajutorul arborilor de intervale. Observa\u021bia esen\u021bial\u0103 este c\u0103 fiecare element formeaz\u0103 inversiuni cu toate elementele mai mari dec\u00e2t el care apar \u00eenaintea lui \u00een vector. Pentru a implementa solu\u021bia, folosim un arbore de intervale care ne ajut\u0103 s\u0103 men\u021binem num\u0103rul de elemente mai mare dec\u00e2t un anumit element pe m\u0103sur\u0103 ce parcurgem vectorul.</p> <p>Not\u0103: Folosind aceast\u0103 metod\u0103, complexitatea algoritmului se reduce la $ O(n \\log n) $.</p> <p>Iat\u0103 cum se poate implementa solu\u021bia:</p> <ul> <li>Pentru fiecare element \\(x\\), calcul\u0103m c\u00e2te elemente mai mari dec\u00e2t \\(x\\) se afl\u0103   deja \u00een arbore. Altfel spus, c\u00e2te elemente se afl\u0103 \u00een intervalul \\([x+1,n]\\).</li> <li>Actualiz\u0103m arborele, marc\u00e2nd apari\u021bia elementului \\(x\\).</li> </ul>","tags":["structuri de date","arbori","queryuri"]},{"location":"dificil/segment-trees/#probleme-de-antrenament","title":"Probleme de antrenament","text":"<p>Pentru problemele de pe codeforces, este necesar un cont pentru a putea accesa acest curs din sec\u021biunea EDU (ITMO Academy)</p> <ul> <li>Dynamic Range Minimum Queries</li> <li>Number of Minimums on a   Segment</li> <li>Intervalxy</li> <li>Kth   one</li> <li>First element at least   X</li> <li>Sign   Alternation</li> <li>Inversions</li> <li>Xenia and bit operations</li> <li>Irrigation</li> <li>Distinct Value Queries</li> <li>United Cows of Farmer John - USACO   Gold</li> <li>Increasing Subsequence II</li> <li>Salary Queries</li> <li>Kth - ONI 2023</li> <li>Intersec\u021bie   segmente : baleiere</li> </ul>","tags":["structuri de date","arbori","queryuri"]},{"location":"dificil/segment-trees/#probleme-dificile","title":"Probleme dificile","text":"<ul> <li>Dulciuri - OJI 2021</li> <li>Array Counting - IIOT 2021-2022</li> <li>Panama Sum - IIOT 2022-2023</li> <li>Lucky Array</li> </ul>","tags":["structuri de date","arbori","queryuri"]},{"location":"dificil/segment-trees/#bibliografie-resurse-suplimentare","title":"Bibliografie + Resurse suplimentare","text":"<ul> <li>CPPI</li> <li>USACO Guide</li> <li>Codeforces EDU: curs complet   pentru introducerea \u00een arbori de intervale</li> <li>CSAcademy: articol care con\u021bine   anima\u021bii pentru opera\u021biile elementare</li> <li>CPAlgorithms:   articol mai avansat care prezint\u0103 mai multe tehnici</li> <li>Efficient and easy segment trees</li> <li>Arbori de intervale si   baleiere</li> <li>Template arbori de   intervale:   o clas\u0103 flexibil\u0103 care permite modificarea rapid\u0103 a opera\u021biilor.</li> </ul>","tags":["structuri de date","arbori","queryuri"]},{"location":"dificil/small-to-large/","title":"Small to large","text":"","tags":["structuri de date","arbori","STL","dsu"]},{"location":"dificil/small-to-large/#introducere","title":"Introducere","text":"<p>S\u0103 \u00eencepem cu urm\u0103toarea problem\u0103:</p>","tags":["structuri de date","arbori","STL","dsu"]},{"location":"dificil/small-to-large/#cses-distinct-colors","title":"CSES - Distinct Colors","text":"<p>Pentru a rezolva aceast\u0103 problem\u0103, ar fi necesar s\u0103 \u0219tim pentru fiecare nod c\u00e2te valori diferite se afl\u0103 \u00een mul\u021bimea nodurilor din subarborele s\u0103u.</p> <p>Observa\u021bie</p> <p>Pentru un nod, ar fi destul s\u0103 \u021binem \u00eentr-o structur\u0103 de tip <code>set</code> valorile nodurilor din subarborele s\u0103u (pe care \u00eel vom nota cu \\(s\\)), iar r\u0103spunsul pentru el ar fi <code>s[nod].size()</code>.</p> <p>Astfel, am putea s\u0103 facem o parcurgere <code>DFS</code> a arborelui, unde mul\u021bimii fiec\u0103rui nod \u00eei vom ad\u0103uga valoarea sa \u0219i valorile din mul\u021bimile fiilor s\u0103i. Apoi, putem salva rezultatul \u00eentr-un vector separat, pe care \u00eel putem numi <code>rez</code>.</p> <p>S\u0103 ne uit\u0103m la implementarea acestei idei.</p> <pre><code>#include &lt;iostream&gt;\n#include &lt;set&gt;\n#include &lt;vector&gt;\n\nconstexpr int NMAX = 200005;\nint rez[NMAX];\nstd::vector&lt;std::vector &lt;int&gt;&gt; G(NMAX);\n//tinem minte cate un set pentru fiecare nod\nstd::vector&lt;std::set &lt;int&gt;&gt; s(NMAX);\n\nvoid dfs(int nod, int t) {\n    for (auto x : G[nod]) {\n        if (x != t) {\n            dfs(x, nod);\n            //parcurgem setul fiecarui fiu si adaugam elementele in setul nodului\n            for (auto x2 : s[x]){\n                s[nod].insert(x2);\n            }\n        }\n    }\n    //obtinem rezultatul folosind metoda .size()\n    rez[nod] = s[nod].size();\n}\n\nint main() {\n    int n, i, u, v, c;\n    std::cin &gt;&gt; n;\n    for (i = 1; i &lt;= n; i++) {\n        std::cin &gt;&gt; c;\n        //valoarea nodului o putem adauga direct in setul acestuia\n        s[i].insert(c);\n    }\n    for (i = 1; i &lt; n; i++) {\n        std::cin &gt;&gt; u &gt;&gt; v;\n        G[u].push_back(v);\n        G[v].push_back(u);\n    }\n    dfs(1, 0);\n    for (i = 1; i &lt;= n; i++) {\n        std::cout &lt;&lt; rez[i] &lt;&lt; \" \";\n    }\n    return 0;\n}\n</code></pre> <p>Totu\u0219i, complexitatea reuniunii multimii unui nod cu cele ale fiilor sai poate lua pana la \\(\\mathcal{O}(n\\log(n))\\), iar noi avem \\(n\\) noduri, deci ar ie\u0219i timp \\(\\mathcal{O}(n^2\\log(n))\\), ceea ce este foarte lent \u0219i nu se va \u00eencadra \u00een restric\u021biile acestei probleme.</p> <p>\u00cens\u0103, aici intervine urm\u0103toarea informa\u021bie:</p> <p>Observa\u021bie</p> <p>Pe structuri cum ar fi <code>set</code> sau <code>map</code>, opera\u021bia de <code>swap</code> este efectuat\u0103 \u00een timp constant. A\u0219adar, dac\u0103 avem 2 seturi, \\(s_1\\) \u0219i \\(s_2\\), <code>std::swap(s1, s2)</code>, sau alternativ <code>s1.swap(s2)</code>, va lua \\(\\mathcal{O}(1)\\).</p> <p>A\u0219adar, \u00een cazul \u00een care m\u0103rimea setului unui fiu este mai mare dec\u00e2t cea a setului nodului, le putem interschimba \u00eentre ele. De aici vine \u0219i numele tehnicii, deoarece noi ducem elementele de la mic la mare.</p>","tags":["structuri de date","arbori","STL","dsu"]},{"location":"dificil/small-to-large/#demonstratie-complexitate","title":"Demonstra\u021bie complexitate","text":"","tags":["structuri de date","arbori","STL","dsu"]},{"location":"dificil/small-to-large/#demonstratie-scurta","title":"Demonstra\u021bie scurt\u0103","text":"<p>Ne putem baza pe acela\u0219i principiu ca la <code>DSU</code>, anume c\u0103 dac\u0103 la un moment dat avem un element \\(x\\) \u00eentr-un set de m\u0103rime \\(s\\), \u00een cel mai r\u0103u caz, acesta va fi reunit cu un set tot de m\u0103rime \\(s\\). Astfel, urm\u0103torul set \u00een care se va afla elementul va avea cel pu\u021bin \\(2s\\) elemente, sau altfel spus, orice element va fi inserat \u00een maxim \\(\\log(n)\\) seturi pe parcursul algoritmului. A\u0219adar, vom avea complexitate \\(\\mathcal{O}(n\\log^2(n))\\), deoarece \u0219i inser\u0103rile iau \\(\\mathcal{O}(\\log(n))\\).</p>","tags":["structuri de date","arbori","STL","dsu"]},{"location":"dificil/small-to-large/#demonstratie-lunga","title":"Demonstra\u021bie lung\u0103","text":"<p>Acum intervine \u00eentrebarea: cu ce ne ajut\u0103 s\u0103 interschimb\u0103m cele dou\u0103 mul\u021bimi? S\u0103 presupunem c\u0103 avem mul\u021bimi care permit existen\u021ba a mai multor elemente egale (structura multiset din STL). Astfel, dac\u0103 avem o mul\u021bime \\(M\\) de m\u0103rime \\(s\\), aceasta va fi reunit\u0103, \u00een cel mai r\u0103u caz, cu o alt\u0103 mul\u021bime de dimensiune \\(s\\), deci urm\u0103toarea mul\u021bime \u00een care se vor afla elementele din \\(M\\) va avea dimensiunea de cel pu\u021bin \\(2 * s\\). A\u0219adar, orice element va fi inserat \u00een maxim \\(\\log(n)\\) seturi pe parcursul algoritmului, iar complexitatea final\u0103 va fi \\(\\mathcal{O}(n\\log^2(n))\\), deoarece inser\u0103rile iau \u00een total \\(\\mathcal{O}(n\\log(n))\\).</p> <p>Pentru structurile de tip set (care nu con\u021bin mai multe elemente egale), intervine \u00eens\u0103 o problem\u0103. Anume, dac\u0103 reunim o astfel de mul\u021bime de dimensiune \\(s\\) cu alta de aceea\u0219i dimensiune, num\u0103rul de elemente al mul\u021bimii care va rezulta nu va mai fi neap\u0103rat \\(2 * s\\), deoarece pot fi elemente care apar \u00een ambele mul\u021bimi.</p> <p>Totu\u0219i, putem demonstra c\u0103 \u0219i \u00een acest caz complexitatea r\u0103m\u00e2ne aceea\u0219i. Dac\u0103 pentru fiecare nod, pentru mul\u021bimea sa, am \u021bine minte c\u00e2te elemente ar fi avut dac\u0103 era un multiset. Dac\u0103 am face swap \u00eentre cele dou\u0103 mul\u021bimi doar \u00een func\u021bie de aceast\u0103 proprietate, ar fi cel pu\u021bin la fel de rapid ca \u00een cazul de mai sus (e la fel ca \u0219i cum am fi avut dou\u0103 structuri de tip multiset, minus elementele care se repetau). Aceast\u0103 metod\u0103, nu \u021bine \u00eens\u0103 cont de m\u0103rimea real\u0103 a mul\u021bimilor, deci putem avea cazuri unde mul\u021bimea cu dimensiunea mai mare este reunit\u0103 la cea de dimensiune mai mic\u0103. A\u0219adar, pentru dou\u0103 structuri de tip set, putem s\u0103 le interschimb\u0103m dup\u0103 dimensiunea lor real\u0103, f\u0103r\u0103 ca acest lucru s\u0103 afecteze complexitatea final\u0103, care r\u0103m\u00e2ne tot maxim \\(\\mathcal{O}(n\\log^2(n))\\).</p> <p>Cu aceast\u0103 schimbare, codul va ar\u0103ta a\u0219a:</p> <pre><code>#include &lt;iostream&gt;\n#include &lt;set&gt;\n#include &lt;vector&gt;\n\nconstexpr int NMAX = 200005;\nint rez[NMAX];\nstd::vector&lt;std::vector &lt;int&gt;&gt; G(NMAX);\n//tinem minte cate un set pentru fiecare nod\nstd::vector&lt;std::set &lt;int&gt;&gt; s(NMAX);\n\nvoid dfs(int nod, int t) {\n    for (auto x : G[nod]) {\n        if (x != t) {\n            dfs(x, nod);\n            //daca numarul de elemente din setul fiului este mai mare decat cel din setul nodului, le interschimbam\n            if(s[x].size() &gt; s[nod].size()){\n                s[nod].swap(s[x]);\n            }\n            //parcurgem setul fiecarui fiu si adaugam elementele in setul nodului\n            for (auto x2 : s[x]){\n                s[nod].insert(x2);\n            }\n        }\n    }\n    //obtinem rezultatul folosind metoda .size()\n    rez[nod] = s[nod].size();\n}\n\nint main() {\n    int n, i, u, v, c;\n    std::cin &gt;&gt; n;\n    for (i = 1; i &lt;= n; i++) {\n        std::cin &gt;&gt; c;\n        //valoarea nodului o putem adauga direct in setul acestuia\n        s[i].insert(c);\n    }\n    for (i = 1; i &lt; n; i++) {\n        std::cin &gt;&gt; u &gt;&gt; v;\n        G[u].push_back(v);\n        G[v].push_back(u);\n    }\n    dfs(1, 0);\n    for (i = 1; i &lt;= n; i++) {\n        std::cout &lt;&lt; rez[i] &lt;&lt; \" \";\n    }\n    return 0;\n}\n</code></pre> <p>Aceast\u0103 solu\u021bie se \u00eencadreaz\u0103 \u00een limitele problemei \u0219i va lua punctaj maxim.</p>","tags":["structuri de date","arbori","STL","dsu"]},{"location":"dificil/small-to-large/#small-to-large-folosind-__gnu_pbds","title":"Small to large folosind <code>__gnu_pbds</code>","text":"<p>Aceast\u0103 structur\u0103 de date ofer\u0103 acelea\u0219i func\u021bii ca structura <code>set</code> din STL, \u00eens\u0103 mai ofer\u0103 \u00eenc\u0103 2 func\u021bii care ne pot fi de ajutor \u00een anumite probleme:</p> <ol> <li><code>find_by_order(x)</code>, care returneaz\u0103 un iterator c\u0103tre a x-a cheie ca ordine,    \u00een timp \\(\\mathcal{O}(\\log(n))\\).</li> <li><code>order_of_key(x)</code>, care returneaz\u0103 num\u0103rul de elemente strict mai mici ca    x, tot \u00een timp \\(\\mathcal{O}(\\log(n))\\).</li> </ol> <p>Pentru a putea folosi aceast\u0103 structur\u0103, va trebui s\u0103 ad\u0103ug\u0103m la programul nostru urm\u0103toarele linii:</p> <pre><code>#include &lt;ext/pb_ds/assoc_container.hpp&gt;\n#include &lt;ext/pb_ds/tree_policy.hpp&gt;\nusing namespace __gnu_pbds;\nusing ordered_set = tree&lt;int, null_type, std::less_equal&lt;int&gt;, rb_tree_tag, tree_order_statistics_node_update&gt;; \n</code></pre> <p>\u00cen interiorul parantezelor ascu\u021bite de dup\u0103 <code>tree</code>, primul c\u00e2mp reprezint\u0103 tipul de date, \u00een acest caz <code>int</code>, al patrulea reprezint\u0103 tipul de arbore folosit, \u00een acest caz, <code>rb_tree</code>, care garanteaz\u0103 complexitatea logaritmic\u0103 a opera\u021biilor de inserare \u0219i \u0219tergere. Al treilea c\u00e2mp reprezint\u0103 tipul de comparator folosit, unde <code>std::less_equal</code> permite existen\u021ba a mai multor elemente egale (ca un <code>multiset</code>), iar <code>std::less</code> nu (ca un <code>set</code>).</p> <p>Totu\u0219i, de\u0219i structura __gnu_pbds ne ofer\u0103 multe avantaje, urm\u0103toarele lucruri trebuie luate \u00een considerare c\u00e2nd este folosit\u0103:</p> <ol> <li>Chiar dac\u0103 opera\u021biile au complexitate logaritmic\u0103, constanta este foarte    mare.</li> <li>Dac\u0103 vrem s\u0103 interschimb\u0103m 2 astfel de structuri \u00een timp \\(\\mathcal{O}(1)\\), va trebui s\u0103    folosim metoda .swap(), cum apare \u00een codul de mai jos. Dac\u0103 am folosi func\u021bia    <code>std::swap()</code>, aceasta ar avea complexitate liniar\u0103.</li> </ol>","tags":["structuri de date","arbori","STL","dsu"]},{"location":"dificil/small-to-large/#problema-e-penultimul-cox-kilonova","title":"Problem\u0103: E - Penultimul Cox -  Kilonova","text":"<p>Aceast\u0103 problem\u0103 se poate rezolva folosind o structur\u0103 de tip <code>__gnu_pbds</code> care admite mai multe chei egale (folose\u0219te comparatorul <code>std::less_equal</code>). Este u\u0219or s\u0103 ne d\u0103m seama c\u0103 r\u0103spunsul pentru fiecare nod este chiar <code>s[nod].order_of_key(v[nod] + 1)</code>. Acel +1 se datoreaz\u0103 faptului c\u0103 ne trebuie num\u0103rul de elemente mai mici sau egale cu \\(v[nod]\\), iar metoda <code>order_of_key</code> returneaz\u0103 num\u0103rul de elemente strict mai mici.</p> <p>O implementare a ideii de mai sus ar fi urm\u0103toarea:</p> <pre><code>#include &lt;iostream&gt;\n#include &lt;vector&gt;\n\n#include &lt;ext/pb_ds/assoc_container.hpp&gt;\n#include &lt;ext/pb_ds/tree_policy.hpp&gt;\nusing namespace __gnu_pbds;\n\n//avem elemente de tip int, care se repeta\nusing ordered_set = tree&lt;int, null_type, std::less_equal&lt;int&gt;, rb_tree_tag, tree_order_statistics_node_update&gt;; \n\nconstexpr int NMAX = 100005;\nstd::vector&lt;std::vector&lt;int&gt;&gt; G(NMAX);\nordered_set s[NMAX];\nint v[NMAX];\nint rez[NMAX];\n\nvoid dfs(int nod) {\n    for (auto x : G[nod]) {\n        dfs(x);\n        //la fel ca la set, operatia de swap ia tot O(1)\n        if (s[x].size() &gt; s[nod].size()){\n            s[x].swap(s[nod]);\n        }\n        for (auto x2 : s[x]){\n            s[nod].insert(x2);\n        }\n    }\n    //numarul de elemente din set mai mici sau egale cu v[nod]\n    rez[nod] = s[nod].order_of_key(v[nod] + 1);\n}\n\nint main() {\n    int n, i, t;\n    std::ios_base::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n    std::cin &gt;&gt; n;\n    for (i = 2; i &lt;= n; i++) {\n        std::cin &gt;&gt; t;\n        G[t].push_back(i);\n    }\n    for (i = 1; i &lt;= n; i++) {\n        std::cin &gt;&gt; v[i];\n        s[i].insert(v[i]);\n    }\n    dfs(1);\n    for (i = 1; i &lt;= n; i++){\n        std::cout &lt;&lt; rez[i] &lt;&lt; \" \";\n    }\n    return 0;\n}\n</code></pre>","tags":["structuri de date","arbori","STL","dsu"]},{"location":"dificil/small-to-large/#probleme-suplimentare","title":"Probleme suplimentare","text":"<ul> <li>Toska - Kilonova</li> <li>Lomsat Gerlal - Codeforces</li> <li>Arborel - Kilonova</li> <li>Magic Tree - CEOI 2019</li> <li>Alte probleme cu small-to-large de pe   Kilonova</li> </ul>","tags":["structuri de date","arbori","STL","dsu"]},{"location":"dificil/small-to-large/#resurse-suplimentare","title":"Resurse suplimentare","text":"<ul> <li>Small-to-large - Usaco Guide</li> <li>__gnu_pbds -   GeeksForGeeks</li> <li>C++ STL: Policy based data structures -   Codeforces</li> <li>Sack (dsu on tree) - Codeforces</li> <li>[Explanation] dsu on trees (small to large) -   Codeforces</li> </ul>","tags":["structuri de date","arbori","STL","dsu"]},{"location":"dificil/square-root-decomposition/","title":"Descompuneri \u00een buc\u0103\u021bi de radical (Square Root Decomposition)","text":"<p>\u00cen multe probleme de algoritmic\u0103, suntem nevoi\u021bi s\u0103 \u00eemp\u0103r\u021bim datele \u00een grupe mai mici pentru a ajunge s\u0103 ob\u021binem solu\u021bii optime sau cel pu\u021bin suficient de rapide pentru a ob\u021bine un punctaj foarte bun, chiar maxim \u00een anumite situa\u021bii. De cele mai multe ori, vom \u00eemp\u0103r\u021bi datele \u00een buc\u0103\u021bi cu o lungime aproximativ egal\u0103 cu \\(\\sqrt n\\), de unde vine \u0219i numele pentru care aceast\u0103 tehnic\u0103 este cunoscut\u0103 \u00een jargonul interna\u021bional, Square Root Decomposition.</p> <p>\u00cen acest articol, vom prezenta c\u00e2teva dintre cele mai cunoscute tipuri de descompuneri \u0219i grup\u0103ri existente care folosesc aceast\u0103 tehnic\u0103, fie c\u0103 e vorba de gruparea elementelor din vector, gruparea query-urilor sau chiar abord\u0103ri diferite \u00een func\u021bie de dimensiunea datelor, toate aceste tehnici au un numitor comun, \u0219i anume prezen\u021ba valorii \\(\\sqrt n\\) drept un etalon de separare a datelor.</p>","tags":["structuri de date","optimizari","precalculari"]},{"location":"dificil/square-root-decomposition/#impartirea-datelor-in-bucati-de-radical","title":"\u00cemp\u0103r\u021birea datelor \u00een buc\u0103\u021bi de radical","text":"<p>Numit \u00een jargonul rom\u00e2nesc \u0219i sub numele de \u0218menul lui Batog, aceast\u0103 tehnic\u0103 const\u0103 \u00een prelucrarea unui \u0219ir de valori prin \u00eemp\u0103r\u021birea acestuia \u00een buc\u0103\u021bi care acoper\u0103 tot \u0219irul, iar lungimea maxim\u0103 a fiec\u0103rei buc\u0103\u021bi este \u00een jur de \\(\\sqrt n\\). Pentru a afla num\u0103rul de ordine al grupei unde se afl\u0103 o valoare, vom putea folosi formula \\(\\frac{i}{bk}\\), unde \\(i\\) este pozi\u021bia curent\u0103, iar \\(bk\\) este dimensiunea unei grupe (a unui bucket), de regul\u0103 aceasta fiind aproximativ \\(\\sqrt n\\).</p> <p>\u00cen cele mai multe cazuri, query-urile pe care le putem rezolva folosind aceast\u0103 metod\u0103 sunt query-uri relativ simple, precum cele de sum\u0103 sau maxim, query-uri care se pot procesa \u0219i folosind alte structuri de date, precum arborii de intervale sau arborii indexa\u021bi binar. Totu\u0219i, \u00een unele situa\u021bii, se recomand\u0103 abord\u0103ri de tipul square root decomposition, deoarece implement\u0103rile se vor dovedi mai scurte \u0219i mai simplu de abordat, \u00een special \u00een cazul unor limite de timp mai pu\u021bin stricte \u0219i/sau a unor restric\u021bii mai mici.</p> <p>Observa\u021bie</p> <p>Vom presupune \u00een cele ce urmeaz\u0103 c\u0103 indexarea valorilor se face de la 0.</p> <p>De regul\u0103, vom vrea s\u0103 \u021binem memorate informa\u021bii pentru fiecare grup\u0103, iar atunci c\u00e2nd actualiz\u0103m o valoare, opera\u021bia va fi efectuat\u0103 \u00een timp constant, deoarece schimb\u0103m informa\u021biile dintr-o singur\u0103 grup\u0103. \u00cen ceea ce prive\u0219te interog\u0103rile, complexitatea acestora este \\(\\mathcal{O}(\\sqrt n)\\) deoarece dac\u0103 avem un interval de forma \\([L, R]\\), noi vom calcula r\u0103spunsul folosind trei pa\u0219i, ace\u0219tia fiind urm\u0103torii:</p> <ul> <li>Intervalul \\([L, x]\\), unde \\(x\\) este cap\u0103tul dreapta al grup\u0103rii \u00een care se afl\u0103   \\(L\\): se poate calcula r\u0103spunsul brut, prin procesarea fiec\u0103rei valori din   grup\u0103.</li> <li>Intervalul \\([x+1, y]\\), unde \\(y\\) este cap\u0103tul din dreapta al ultimei grupe care   se afl\u0103 \u00een \u00eentregime \u00een intervalul din query. Pentru aceste grupe, se   proceseaz\u0103 r\u0103spunsul total corespunz\u0103tor acestui interval \u0219i se consider\u0103 \u00een   contextul r\u0103spunsului final.</li> <li>Intervalul \\([y+1, R]\\), unde \\(y+1\\) este cap\u0103tul st\u00e2nga al grup\u0103rii \u00een care se   afl\u0103 \\(R\\): se poate calcula r\u0103spunsul brut, prin procesarea fiec\u0103rei valori din   grup\u0103.</li> </ul> <p>Observa\u021bie</p> <p>\u00cen mod particular, dac\u0103 \\(L\\) \u0219i \\(R\\) se afl\u0103 \u00een aceea\u0219i grup\u0103, vom putea afla brut r\u0103spunsul cerut, consider\u00e2nd pe r\u00e2nd fiecare valoare din interval.</p> <p>Exemplu</p> <p>De exemplu, dac\u0103 dimensiunea unei grup\u0103ri este 5, iar intervalul \\([L, R]\\) este \\([7, 21]\\), r\u0103spunsul se va afla \u00een modul urm\u0103tor:</p> <ul> <li>Intervalul \\([7, 9]\\): Fiind o grupare care nu se afl\u0103 \u00een \u00eentregime \u00een   interogarea dat\u0103, vom procesa valorile \u00eentr-o manier\u0103 brut\u0103. </li> <li>Intervalele \\([10, 14]\\) \u0219i \\([15, 19]\\): Deoarece aceste intervale se afl\u0103 \u00een   \u00eentregime \u00een interogarea dat\u0103, le vom procesa folosind precalcularea f\u0103cut\u0103   anterior pentru grup\u0103rile \u00eentregi. </li> <li>Intervalul \\([20, 21]\\): Fiind o grupare care nu se afl\u0103 \u00een \u00eentregime \u00een   interogarea dat\u0103, vom procesa valorile \u00eentr-o manier\u0103 brut\u0103.</li> </ul>","tags":["structuri de date","optimizari","precalculari"]},{"location":"dificil/square-root-decomposition/#cand-folosim-aceste-tehnici","title":"C\u00e2nd folosim aceste tehnici?","text":"<p>De multe ori, pentru a g\u0103si abordarea optim\u0103 pentru asemenea probleme, trebuie s\u0103 avem \u00een vedere faptul c\u0103 dac\u0103 avem restric\u021bii mai mici (de regul\u0103, c\u00e2nd \\(n \\approx 10^5\\)), o abordare de acest tip poate fi foarte eficient\u0103 datorit\u0103 flexibilit\u0103\u021bii pe care o avem, precum \u0219i a faptului c\u0103 putem s\u0103 variem punctul limit\u0103 \u00een func\u021bie de eficien\u021ba celor dou\u0103 abord\u0103ri.</p> <p>Cu alte cuvinte, dac\u0103 avem o abordare care ruleaz\u0103 \u00een \\(\\mathcal{O}(a \\cdot x)\\) \u0219i alta care ruleaz\u0103 \u00een \\(\\mathcal{O}(b \\cdot \\frac{n}{x})\\), unde \\(a\\) \u0219i \\(b\\) sunt constante, punctul de cotitur\u0103 \u00eentre cele dou\u0103 abord\u0103ri este acela \u00een care cele dou\u0103 ecua\u021bii au valori egale, din acest motiv nefiind mereu optim s\u0103 abord\u0103m diferit \u00eencep\u00e2nd de la \\(\\mathcal{O}(\\sqrt n)\\), deoarece uneori aceast\u0103 schimbare trebuie produs\u0103 mai devreme sau mai t\u00e2rziu.</p>","tags":["structuri de date","optimizari","precalculari"]},{"location":"dificil/square-root-decomposition/#problema-dynamic-range-sum-queries-de-pe-cses","title":"Problema Dynamic Range Sum Queries de pe CSES","text":"<p>De\u0219i aceast\u0103 problem\u0103 se poate rezolva \u00eentr-un mod mai eficient folosind arborii de intervale, actualiz\u0103rile \u0219i interog\u0103rile reprezint\u0103 un exemplu foarte bun pentru ilustrarea acestei tehnici. Se va observa faptul c\u0103 pentru fiecare bucat\u0103 din vector se va \u021bine suma acesteia, iar query-urile vor fi procesate conform descrierii de mai sus.</p> <pre><code>#include &lt;iostream&gt;\n#include &lt;vector&gt;\n\nusing namespace std;\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n\n    int n, q;\n    cin &gt;&gt; n &gt;&gt; q;\n\n    vector&lt;int&gt; v(n);\n    for (int i = 0; i &lt; n; i++) {\n        cin &gt;&gt; v[i];\n    }\n\n    int sz = 450;\n\n    vector&lt;long long&gt; bk(n / sz + 1);\n\n    for (int i = 0; i &lt; n; i++) {\n        bk[i / sz] += v[i];\n    }\n\n    for (; q; q--) {\n        int tp;\n        cin &gt;&gt; tp;\n\n        if (tp == 1) {\n            int pos, val;\n            cin &gt;&gt; pos &gt;&gt; val;\n\n            pos--;\n            bk[pos / sz] += (val - v[pos]);\n            v[pos] = val;\n        }\n\n        else {\n            int L, R;\n            cin &gt;&gt; L &gt;&gt; R;\n            L--;\n            R--;\n\n            long long sum = 0;\n            if (L / sz == R / sz) {\n                for (int i = L; i &lt;= R; i++) {\n                    sum += v[i];\n                }\n            } else {\n                int pos = L;\n                while (pos / sz == L / sz) {\n                    sum += v[pos];\n                    pos++;\n                }\n                while (pos / sz != R / sz) {\n                    sum += bk[pos / sz];\n                    pos += sz;\n                }\n                while (pos &lt;= R) {\n                    sum += v[pos];\n                    pos++;\n                }\n            }\n\n            cout &lt;&lt; sum &lt;&lt; '\\n';\n        }\n    }\n\n    return 0;\n}\n</code></pre>","tags":["structuri de date","optimizari","precalculari"]},{"location":"dificil/square-root-decomposition/#problema-consecutive-max-difference-de-pe-cs-academy","title":"Problema Consecutive Max Difference de pe CS Academy","text":"<p>Observa\u021bie</p> <p>Aceast\u0103 problem\u0103, \u00eempreun\u0103 cu varia\u021bii ale ei este explicat\u0103 \u00een detaliu \u0219i \u00een acest blog de pe Codeforces.</p> <p>Pentru a rezolva aceast\u0103 problem\u0103, trebuie s\u0103 ne folosim de faptul c\u0103 \u0219tim o valoare minim\u0103 a acestei diferen\u021be, aceasta fiind raportul dintre diferen\u021ba dintre maxim \u0219i minim, respectiv num\u0103rul de perechi de valori adiacente. Folosind aceast\u0103 regul\u0103, tot ce mai avem de f\u0103cut este s\u0103 grup\u0103m valori \u00een functie de zona unde se afl\u0103 ele \u00een \u0219ir (putem \u00eemp\u0103r\u021bi valorile \u00een \\(n\\) grupe astfel), iar mai apoi vom calcula diferen\u021bele \u00eentre cea mai mare valoare din grupa precedent\u0103 \u0219i cea mai mic\u0103 valoare din grupa urm\u0103toare.</p> <pre><code>long long maxDifference(const vector&lt;int&gt;&amp; v) {\n    int min_val = *min_element(v.begin(), v.end());\n    int max_val = *max_element(v.begin(), v.end());\n    double dif = max_val - min_val;\n    int num_pairs = v.size() - 1;\n\n    int aprox = dif / num_pairs;\n\n    int n = v.size();\n    double bucket_size = ((double)max_val - min_val) / n;\n\n    vector&lt;int&gt; buckets[v.size()];\n    for (int i = 0; i &lt; v.size(); i++) {\n        dif = v[i] - min_val;\n        int bucket = (int)(((double)v[i] - min_val) / bucket_size);\n\n        if (bucket == v.size()) {\n            bucket--;\n        }\n        buckets[bucket].push_back(v[i]);\n    }\n\n    int prev_max = 0;\n    long long ans = 0;\n    for (int i = 0; i &lt; v.size(); i++) {\n        if (!buckets[i].size() == 0) {\n            min_val = *min_element(buckets[i].begin(), buckets[i].end());\n            max_val = *max_element(buckets[i].begin(), buckets[i].end());\n\n            if (i) {\n                ans = max(ans, (long long)min_val - prev_max);\n            }\n            prev_max = max_val;\n        }\n    }\n\n    return ans;\n}\n</code></pre>","tags":["structuri de date","optimizari","precalculari"]},{"location":"dificil/square-root-decomposition/#impartirea-query-urilor-in-bucati-de-radical-algoritmul-lui-mo","title":"\u00cemp\u0103r\u021birea query-urilor \u00een buc\u0103\u021bi de radical - Algoritmul lui Mo","text":"<p>Pentru a calcula query-uri mai complicate, de multe ori ne putem g\u00e2ndi la a grupa query-urile pentru a face actualiz\u0103rile \u0219i interog\u0103rile mai pu\u021bin costisitoare din punct de vedere al timpului. O metod\u0103 foarte popular\u0103 de a face acest lucru const\u0103 \u00een gruparea query-urilor \u00een func\u021bie de grupa \u00een care se afl\u0103 pozi\u021bia de start, iar \u00een caz de egalitate, query-urile se ordoneaz\u0103 cresc\u0103tor \u00een func\u021bie de cap\u0103tul din dreapta.</p> <p>Aceast\u0103 metod\u0103 se nume\u0219te Algoritmul lui Mo \u0219i prin folosirea ei pentru a reordona query-urile, ne asigur\u0103m c\u0103 num\u0103rul de opera\u021bii pe care \u00eel facem \u00een medie la fiecare query este de \\(\\mathcal{O}(\\sqrt n)\\), lucru ce se poate motiva prin \u00eensumarea a dou\u0103 elemente de complexitate:</p> <ul> <li> <p>Dac\u0103 avem dou\u0103 (sau mai multe) query-uri din acela\u0219i bucket, cap\u0103tul din   st\u00e2nga se va mi\u0219ca cu cel mult \\(\\sqrt n\\), iar num\u0103rul total de pa\u0219i pe care \u00eei   facem la dreapta este de \\(n\\). Deoarece num\u0103rul de bucket-uri este \\(\\mathcal{O}(\\sqrt   n)\\), atunci contribu\u021bia la complexitate de la aceste query-uri este \\(\\mathcal{O}(n \\sqrt   n)\\).</p> </li> <li> <p>Dac\u0103 avem dou\u0103 query-uri din bucket-uri diferite, putem avea \u00een cel mai r\u0103u   caz \\(n\\) pa\u0219i, dar deoarece num\u0103rul de bucket-uri este \\(\\mathcal{O}(\\sqrt n)\\), atunci   contribu\u021bia la complexitate de la aceste query-uri este \\(\\mathcal{O}(n \\sqrt n)\\).</p> </li> </ul> <p>\u00cen total, complexitatea se reduce la \\(\\mathcal{O}(n \\sqrt n)\\), presupun\u00e2nd c\u0103 opera\u021biile auxiliare pe care le efectu\u0103m se realizeaz\u0103 \u00een timp constant.</p> <p>Observa\u021bie</p> <p>Pentru a optimiza mai mult aceast\u0103 metod\u0103, putem s\u0103 sort\u0103m invers elementele din aceea\u0219i grup\u0103 dac\u0103 avem de-a face cu grupe cu un num\u0103r par, deoarece putem astfel s\u0103 altern\u0103m direc\u021bia \u00een care ad\u0103ug\u0103m \u0219i scoatem valori la cap\u0103tul din dreapta, constanta reduc\u00e2ndu-se cu un factor de aproximativ 2 \u00een majoritatea cazurilor.</p> <p>Pentru a explica acest algoritm, voi prezenta o problem\u0103 clasic\u0103 ce folose\u0219te aceast\u0103 metod\u0103.</p>","tags":["structuri de date","optimizari","precalculari"]},{"location":"dificil/square-root-decomposition/#problema-fsecv-de-la-lot-juniori-2019","title":"Problema fsecv de la Lot Juniori 2019","text":"<p>Pentru a calcula rapid c\u00e2te valori au aceea\u0219i frecven\u021b\u0103 egal\u0103 cu \\(k\\), trebuie s\u0103 ne asigur\u0103m c\u0103 num\u0103rul de opera\u021bii de ad\u0103ugare \u0219i \u0219tergere nu este foarte mare, lucru ce \u00eel putem realiza folosind algoritmul lui Mo. Tot ce ne r\u0103m\u00e2ne de f\u0103cut este s\u0103 \u021binem doi vectori de frecven\u021b\u0103, unul cu frecven\u021ba fiec\u0103rui element, iar cel de-al doilea, cu frecven\u021ba frecven\u021bei elementelor.</p> <p>Se poate observa c\u0103 query-urile sunt ordonate dup\u0103 raportul dintre cap\u0103tul din st\u00e2nga \u0219i dimensiunea bucket-ului, iar \u00een caz de egalitate, dup\u0103 cap\u0103tul din dreapta. De asemenea, pe m\u0103sur\u0103 ce proces\u0103m query-urile, vom ajusta capetele st\u00e2nga \u0219i dreapta \u00een func\u021bie de opera\u021biile pe care trebuie s\u0103 le facem, ad\u0103ug\u00e2nd sau sco\u021b\u00e2nd valori dup\u0103 caz, a\u0219a cum se poate observa \u00een func\u021bia \u00een care proces\u0103m efectiv query-urile.</p> <p>Mai jos pute\u021bi g\u0103si o implementare detaliat\u0103 a problemei men\u021bionate mai sus, aceasta fiind un exemplu clasic al algoritmului lui Mo.</p> <pre><code>#include &lt;bits/stdc++.h&gt;\n\nusing namespace std;\nusing ll = long long;\n\nconst int MAX_A = 1e5, MAX_N = 1e5;\nint a[MAX_N + 5], freq[2 * MAX_A + 5], cnt[MAX_A + 5], blockSize;\n\nstruct Query {\n    int l, r, k, idx;\n\n    bool operator&lt;(Query other) const {\n        return make_pair(l / blockSize, r)\n             &lt; make_pair(other.l / blockSize, other.r);\n    }\n};\n\nvoid add(int idx) {\n    int val = a[idx] + MAX_A;\n\n    if (freq[val] &gt; 0) {\n        cnt[freq[val]]--;\n    }\n    cnt[++freq[val]]++;\n}\n\nvoid remove(int idx) {\n    int val = a[idx] + MAX_A;\n\n    if (freq[val] &gt; 0) {\n        cnt[freq[val]]--;\n    }\n    cnt[--freq[val]]++;\n}\n\nint getAnswer(int idx) { return cnt[idx]; }\n\nvector&lt;int&gt; MoSAlgorithm(vector&lt;Query&gt; queries) {\n    vector&lt;int&gt; answers(queries.size());\n    sort(queries.begin(), queries.end());\n\n    int curL = 0, curR = -1, i;\n    for (i = 1; i &lt; queries.size(); i++) {\n        Query q = queries[i];\n\n        while (curL &gt; q.l) {\n            add(--curL);\n        }\n\n        while (curR &lt; q.r) {\n            add(++curR);\n        }\n\n        while (curL &lt; q.l) {\n            remove(curL++);\n        }\n\n        while (curR &gt; q.r) {\n            remove(curR--);\n        }\n        answers[q.idx] = getAnswer(q.k);\n    }\n\n    return answers;\n}\n\nint main() {\n    ifstream cin(\"fsecv.in\");\n    ofstream cout(\"fsecv.out\");\n\n    int n, q, i;\n    cin &gt;&gt; n &gt;&gt; q;\n\n    blockSize = (int)sqrt(n);\n    for (i = 1; i &lt;= n; i++) {\n        cin &gt;&gt; a[i];\n    }\n\n    vector&lt;Query&gt; queries(q + 1);\n    for (i = 1; i &lt;= q; i++) {\n        cin &gt;&gt; queries[i].l &gt;&gt; queries[i].r &gt;&gt; queries[i].k;\n        queries[i].idx = i;\n    }\n\n    vector&lt;int&gt; output = MoSAlgorithm(queries);\n    for (i = 1; i &lt; output.size(); i++) {\n        cout &lt;&lt; output[i] &lt;&lt; \"\\n\";\n    }\n    return 0;\n}\n</code></pre>","tags":["structuri de date","optimizari","precalculari"]},{"location":"dificil/square-root-decomposition/#procesarea-datelor-in-functie-de-tipul-query-urilor-sau-a-frecventelor","title":"Procesarea datelor \u00een func\u021bie de tipul query-urilor sau a frecventelor","text":"<p>\u00cen alte tipuri de probleme, suntem nevoi\u021bi s\u0103 rezolv\u0103m dou\u0103 probleme diferite pe care s\u0103 le combin\u0103m pentru a ob\u021bine o solu\u021bie c\u00e2t mai bun\u0103 posibil, practic lu\u00e2nd avantajele fiec\u0103rei metode cu scopul de a ob\u021bine o solu\u021bie final\u0103 optim\u0103 pentru datele de care dispunem. Aici am prezentat dou\u0103 asemenea exemple.</p>","tags":["structuri de date","optimizari","precalculari"]},{"location":"dificil/square-root-decomposition/#problema-jumpsum-de-pe-kilonova","title":"Problema Jumpsum de pe Kilonova","text":"<p>Pentru a rezolva aceast\u0103 problem\u0103, plec\u0103m de la faptul c\u0103 dac\u0103 am vrea s\u0103 rezolv\u0103m un query \u00een mod brut, complexitatea ar fi \\(\\mathcal{O}(\\frac{n}{y})\\), ceea ce pentru valori mici ale lui \\(y\\), ne-ar cauza mari probleme din punct de vedere al vitezei programului.</p> <p>Din acest motiv, o idee care se impune imediat este aceea de a precalcula r\u0103spunsurile pentru c\u00e2t mai multe valori ale lui \\(y\\), pentru a evita aceast\u0103 problem\u0103 pe viitor. Totu\u0219i, nu putem precalcula toate r\u0103spunsurile, deoarece complexitatea ar deveni \\(\\mathcal{O}(n^2)\\). Din acest motiv, recurgem la o solu\u021bie de compromis, care folose\u0219te avantajele ambelor metode, iar din acest motiv, vom precalcula r\u0103spunsurile pentru toate valorile mai mici de \\(\\sqrt n\\), respectiv brut pentru toate valorile mai mari de \\(\\sqrt n\\), astfel complexitatea devenind \\(n \\sqrt n\\).</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nlong long n, q, sp[302][100002], v[302];\n\nint main() {\n    cin &gt;&gt; n;\n\n    for (int i = 1; i &lt;= n; i++) {\n        cin &gt;&gt; v[i];\n    }\n\n    for (int pas = 1; pas &lt;= min(300, n); pas++) {\n        for (int i = 1; i &lt;= n; i++) {\n            sp[pas][i] = v[i];\n            if (i &gt; pas) {\n                sp[pas][i] += sp[pas][i - pas];\n            }\n        }\n    }\n\n    cin &gt;&gt; q;\n    for (; q; q--) {\n        int x, y;\n        cin &gt;&gt; x &gt;&gt; y;\n\n        if (y &lt;= min(300, n)) {\n            cout &lt;&lt; sp[y][x] &lt;&lt; '\\n';\n        } else {\n            long long ans = 0;\n            while (x &gt; 0) {\n                ans += v[x];\n                x -= y;\n            }\n            cout &lt;&lt; ans &lt;&lt; '\\n';\n        }\n    }\n}\n</code></pre>","tags":["structuri de date","optimizari","precalculari"]},{"location":"dificil/square-root-decomposition/#problema-bvarcolaci-de-la-oni-2015","title":"Problema Bvarcolaci de la ONI 2015","text":"<p>Pentru a rezolva aceast\u0103 problem\u0103, este foarte important s\u0103 \u00eemp\u0103r\u021bim valorile \u00een func\u021bie de frecven\u021ba \u00een care apar. Cu alte cuvinte, dac\u0103 un element apare de \\(x\\) ori \u00een \u0219ir, lungimea maxim\u0103 a unei secven\u021be \u00een care poate fi majoritar este de cel mult \\(2 \\cdot x - 1\\), ceea ce ne motiveaz\u0103 s\u0103 avem dou\u0103 abord\u0103ri diferite \u00een func\u021bie de frecven\u021ba elementelor.</p> <p>Dac\u0103 un element apare de cel pu\u021bin \\(\\sqrt n\\) ori, putem afla num\u0103rul de secven\u021be cu frecven\u021b\u0103 majoritar\u0103 \u00een \\(\\mathcal{O}(n)\\) cu ajutorul unor sume par\u021biale, num\u0103r\u00e2nd o diferen\u021b\u0103 \u00eentre valorile care apar \u0219i cele care nu apar (reducem problema la un \u0219ir binar).</p> <p>Altfel, vom putea fixa pozi\u021bia primului \u0219i ultimului element egal cu valoarea curent\u0103, iar cu ajutorul unor cazuri, vom putea ajunge s\u0103 g\u0103sim r\u0103spunsul \u00een \\(\\mathcal{O}(frq^2)\\), unde \\(frq\\) este frecven\u021ba valorii curente.</p> <pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\nifstream f(\"bvarcolaci.in\");\nofstream g(\"bvarcolaci.out\");\n\nint n, v[250002], frq[250002], xx[500002];\nvector&lt;int&gt; pos[250002];\n\nlong long fct(long long a, long long b, long long c) {\n    if (a &gt; b) {\n        swap(a, b);\n    }\n    a = min(a, c);\n    b = min(b, c);\n    if (a + b &lt;= c) {\n        return (a + 1) * (b + 1);\n    }\n    long long sol = (a + 1);\n    sol = sol + 1LL * (c - b + 1) * b;\n    int mx = (b - 1);\n    int mn = max(0LL, c - a - 1);\n    sol = sol + 1LL * mx * (mx + 1) / 2;\n    sol = sol - 1LL * mn * (mn + 1) / 2;\n    return sol;\n}\nint main() {\n    long long sol = 0;\n    f &gt;&gt; n;\n    int rad = (int)sqrt(n);\n    for (int i = 1; i &lt;= n; ++i) {\n        f &gt;&gt; v[i];\n        pos[v[i]].push_back(i);\n    }\n    for (int i = 1; i &lt;= n; ++i) {\n        if (pos[i].size() &lt;= rad) {\n            for (int j = 0; j &lt; pos[i].size(); ++j) {\n                for (int k = j; k &lt; pos[i].size(); ++k) {\n                    int st = pos[i][j];\n                    int dr = pos[i][k];\n                    int len = (dr - st + 1);\n                    int frq = k - j + 1;\n                    if (frq &lt; len / 2 + 1) {\n                        continue;\n                    }\n                    int disp = frq * 2 - len - 1;\n                    int catest;\n                    if (j != 0) {\n                        catest = st - pos[i][j - 1] - 1;\n                    } else {\n                        catest = st - 1;\n                    }\n                    int catedr;\n                    if (k + 1 == pos[i].size()) {\n                        catedr = n - dr;\n                    } else {\n                        catedr = pos[i][k + 1] - dr - 1;\n                    }\n                    sol += fct(catest, catedr, disp);\n                }\n            }\n        } else {\n            memset(xx, 0, sizeof(xx));\n            int st = 249999;\n            int nr = 0;\n            for (int j = 1; j &lt;= n; ++j) {\n                if (v[j] == i) {\n                    frq[j] = frq[j - 1] + 1;\n                } else {\n                    frq[j] = frq[j - 1] - 1;\n                }\n                ++xx[250000 + frq[j - 1]];\n                if (250000 + frq[j - 1] &lt;= st) {\n                    ++nr;\n                }\n                while (frq[j] + 250000 &lt;= st) {\n                    nr -= xx[st], --st;\n                }\n                while (frq[j] + 250000 &gt; st + 1) {\n                    ++st, nr += xx[st];\n                }\n                sol += nr;\n            }\n        }\n    }\n    g &lt;&lt; sol &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["structuri de date","optimizari","precalculari"]},{"location":"dificil/square-root-decomposition/#recalcularea-datelor-dupa-un-numar-fix-de-query-uri","title":"Recalcularea datelor dup\u0103 un num\u0103r fix de query-uri","text":"<p>Mai exist\u0103 \u0219i alte probleme \u00een care r\u0103spunsul final const\u0103 \u00een unirea unor r\u0103spunsuri precalculate, \u00eempreun\u0103 cu un num\u0103r mic de elemente schimbate care trebuie procesate separat. De\u0219i nu avem prezentate probleme de acest fel, acest tip de abordare este foarte popular mai ales atunci c\u00e2nd lucr\u0103m cu unele tipuri de query-uri pe arbore, unde de multe ori este optim s\u0103 recalcul\u0103m r\u0103spunsurile odat\u0103 la \\(\\sqrt n\\) query-uri.</p> <p>Problema de mai jos reprezint\u0103 un exemplu mai simplu care combin\u0103 \u0219i cuno\u0219tin\u021bele c\u0103p\u0103tate anterior la algoritmul lui Mo.</p>","tags":["structuri de date","optimizari","precalculari"]},{"location":"dificil/square-root-decomposition/#problema-rangemode-de-pe-infoarena","title":"Problema Rangemode de pe infoarena","text":"<p>Pentru a rezolva aceast\u0103 problem\u0103, vom pleca de la solu\u021bia obi\u0219nuit\u0103 pe care o avem folosind algoritmul lui Mo, unde sort\u0103m query-urile \u00een ordine cresc\u0103toare a grupei de unde \u00eencep. Dac\u0103 am proceda conform unui Mo obi\u0219nuit, ar trebui s\u0103 \u021binem \u0219i un set \u00een care s\u0103 p\u0103str\u0103m frecven\u021bele maxime deoarece avem nevoie s\u0103 afl\u0103m elementul minim cu frecven\u021ba maxim\u0103. Totu\u0219i, o complexitate de genul \\(\\mathcal{O}(q \\sqrt n \\log n)\\) este prea \u00eenceat\u0103.</p> <p>Ne putem g\u00e2ndi acum la ce se \u00eent\u00e2mpl\u0103 cu adev\u0103rat c\u00e2nd rul\u0103m update-urile \u0219i query-urile \u00eentr-un bucket al algoritmului lui Mo. Noi continu\u0103m s\u0103 progres\u0103m spre cap\u0103tul dreapta al vectorului, ad\u0103ug\u00e2nd valorile \u00een structura noastr\u0103 de date. Singurele ajust\u0103ri pe care trebuie s\u0103 le facem sunt atunci c\u00e2nd trebuie s\u0103 ne mi\u0219c\u0103m \u00een bucata par\u021bial\u0103 de la \u00eenceputul query-urilor, bucat\u0103 care are o lungime de cel mult \\(\\sqrt n\\). Din acest motiv, ce putem face acum este s\u0103 reducem abordarea la doar ni\u0219te ad\u0103ug\u0103ri, cu alte cuvinte vom ad\u0103uga valori una c\u00e2te una, ajust\u00e2nd cel mai bun r\u0103spuns \u00eentr-o manier\u0103 foarte simpl\u0103, deoarece putem acum s\u0103 ne d\u0103m seama dac\u0103 valorile ad\u0103ugate la un moment dat pot fi r\u0103spunsuri mai bune.</p> <p>Pentru a trata cele \\(\\sqrt n\\) r\u0103mase, vom \u021bine o copie a celor mai bune r\u0103spunsuri \u0219i vom ad\u0103uga doar valorile r\u0103mase \u00eentr-o manier\u0103 similar\u0103, p\u0103str\u00e2nd cu aten\u021bie noile r\u0103spunsuri pentru valorile r\u0103mase.</p> <pre><code>#include &lt;algorithm&gt;\n#include &lt;fstream&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\nint n, q, v[100002], ans[100002], frq[100002];\n\nstruct queries {\n    int L, R, pi;\n};\nqueries vq[100002];\n\nbool cmp(queries a, queries b) {\n    if (a.L / 300 != b.L / 300) {\n        return a.L &lt; b.L;\n    }\n    return a.R &lt; b.R;\n}\n\nvoid add(int pos, int &amp;mx) {\n    frq[v[pos]]++;\n    if (mx == 100001 || frq[v[pos]] &gt; frq[mx]\n        || (frq[v[pos]] == frq[mx] &amp;&amp; v[pos] &lt; mx)) {\n        mx = v[pos];\n    }\n}\nint main() {\n    ifstream cin(\"rangemode.in\");\n    ofstream cout(\"rangemode.out\");\n\n    cin &gt;&gt; n &gt;&gt; q;\n    for (int i = 1; i &lt;= n; i++) {\n        cin &gt;&gt; v[i];\n    }\n\n    for (int i = 1; i &lt;= q; i++) {\n        cin &gt;&gt; vq[i].L &gt;&gt; vq[i].R;\n        vq[i].pi = i;\n    }\n\n    sort(vq + 1, vq + q + 1, cmp);\n\n    int pq = 1;\n    for (int buk = 0; buk &lt; 350; buk++) {\n        int bg = min(n + 1, (buk + 1) * 300), mxbigger = 100001;\n        while (pq &lt;= q) {\n            int poz = vq[pq].L / 300;\n            if (poz != buk) {\n                break;\n            }\n            while (bg &lt;= vq[pq].R) {  // adaugam valorile noi\n                add(bg++, mxbigger);\n            }\n            int mx2 = mxbigger;\n            // procesam bucata din stanga\n            for (int Lpos = min(vq[pq].R, (buk + 1) * 300 - 1);\n                 Lpos &gt;= vq[pq].L; Lpos--) {\n                add(Lpos, mx2);\n            }\n            ans[vq[pq].pi] = mx2;\n            for (int Lpos = min(vq[pq].R, (buk + 1) * 300 - 1);\n                 Lpos &gt;= vq[pq].L; Lpos--) {\n                frq[v[Lpos]]--;\n            }\n            pq++;\n        }\n        for (int i = 0; i &lt;= 100000; i++) {\n            frq[i] = 0;\n        }\n    }\n\n    for (int i = 1; i &lt;= q; i++) {\n        cout &lt;&lt; ans[i] &lt;&lt; '\\n';\n    }\n    return 0;\n}\n</code></pre>","tags":["structuri de date","optimizari","precalculari"]},{"location":"dificil/square-root-decomposition/#concluzii","title":"Concluzii","text":"<p>\u00cen ceea ce prive\u0219te \u00eemp\u0103r\u021birea pe buc\u0103\u021bi de radical, fie c\u0103 e vorba de procesarea unor grupe de valori separat sau a unor query-uri sau chiar folosirea unor abord\u0103ri diferite \u00een func\u021bie de tipul de query dat, aceste tehnici se dovedesc a fi foarte utile \u0219i frecvent \u00eent\u00e2lnite \u00een concursurile de informatic\u0103, adaptarea \u00een func\u021bie de situa\u021bie fiind foarte important\u0103, a\u0219a cum se poate observa prin alegerea punctului limit\u0103 care depinde \u00een func\u021bie de problem\u0103.</p> <p>Problemele \u0219i resursele pe care le ve\u021bi g\u0103si \u00een cele ce urmeaz\u0103 acoper\u0103 toate aceste tehnici, solu\u021biile optime fiind de cele mai multe ori abord\u0103ri similare cu cele prezentate aici, iar dup\u0103 cum se poate observa, aceast\u0103 familie de algoritmi \u0219i tehnici a ap\u0103rut foarte mult mai ales \u00een ultimii ani \u00een aplica\u021bii tot mai atipice.</p>","tags":["structuri de date","optimizari","precalculari"]},{"location":"dificil/square-root-decomposition/#probleme-suplimentare","title":"Probleme suplimentare","text":"<ul> <li>infoarena mayonaka</li> <li>InfoOltenia 2020 Toorcmmdc</li> <li>Junior Challenge 2020 Aparate</li> <li>infoarena qxy</li> <li>ONI 2022 subsir</li> <li>infoarena suma6</li> <li>infoarena numerex</li> <li>ONI 2015 ksecv</li> <li>ONI 2018 Mexitate</li> <li>Lot Juniori 2019 dss</li> <li>USACO Platinum Minimizing   Haybales</li> <li>IIOT 2024 XYQueries</li> <li>ONI 2022 Baraj Seniori Piezisa</li> <li>infoarena arbore</li> <li>Codeforces Sum of Progression</li> <li>Codeforces Array Queries</li> <li>Codeforces Sakurako's Test</li> <li>Codeforces Robot Queries</li> <li>Codeforces Space Harbour</li> <li>Codeforces Ann and Books</li> <li>Codeforces XOR and Favorite   Number</li> </ul>","tags":["structuri de date","optimizari","precalculari"]},{"location":"dificil/square-root-decomposition/#lectura-suplimentara","title":"Lectur\u0103 suplimentar\u0103","text":"<ul> <li>cp-algorithms: Sqrt   Decomposition</li> <li>SEPI Infobits F1 - paginile   99-137</li> <li>USACO Guide Sqrt Decomposition</li> <li>Infoarena - The Square Root   Trick</li> <li>Infoarena - Multe \"smenuri\" de programare in C/C++... si nu   numai!</li> <li>Codeforces - Square root decomposition and   applications</li> <li>Codeforces - An alternative sorting order for Mo's   algorithm</li> <li>Codeforces - Mo's Algorithm on   Trees</li> </ul>","tags":["structuri de date","optimizari","precalculari"]},{"location":"dificil/sweep-line/","title":"Baleiere (sweep line)","text":"<p>Daca vreti sa ne ajutati cu acest articol, ne puteti gasi pe github sau pe serverul nostru de discord</p> <p>Mai jos g\u0103si\u021bi resurse pe care le pute\u021bi citi p\u00e2n\u0103 atunci.</p>","tags":["geometrie","sortare","structuri de date"]},{"location":"dificil/sweep-line/#introducere","title":"Introducere","text":"","tags":["geometrie","sortare","structuri de date"]},{"location":"dificil/sweep-line/#problema-exemplu","title":"Problema exemplu","text":"","tags":["geometrie","sortare","structuri de date"]},{"location":"dificil/sweep-line/#concluzii","title":"Concluzii","text":"","tags":["geometrie","sortare","structuri de date"]},{"location":"dificil/sweep-line/#probleme-suplimentare","title":"Probleme suplimentare","text":"","tags":["geometrie","sortare","structuri de date"]},{"location":"dificil/sweep-line/#resurse-suplimentare","title":"Resurse suplimentare","text":"<ul> <li>Sweep Line - USACO Guide</li> <li>Sweep line algorithm - Wikipedia</li> <li>Line sweep algorithms - Leetcode</li> <li>Algoritmi de baleiere - Infoarena</li> <li>Arbori de intervale \u0219i aplica\u0163ii \u00een Geometria Computa\u0163ional\u0103 - Infobits</li> <li>Arbori de intervale, pagina 10 - CPPI Sync</li> <li>Sweep Line and Segment Trees - robert1003</li> </ul>","tags":["geometrie","sortare","structuri de date"]},{"location":"dificil/ternary-search/","title":"C\u0103utare ternar\u0103","text":"","tags":["sortare","cautari","matematica"]},{"location":"dificil/ternary-search/#introducere","title":"Introducere","text":"<p>Un algoritm de c\u0103utare ternar\u0103 este o tehnic\u0103 \u00een informatic\u0103 pentru a g\u0103si minimul sau maximul unei func\u021bii unimodale (care are un singur punct/interval cu valoare maxim\u0103/minim\u0103).</p> <p>Spre deosebire de alte c\u0103ut\u0103ri similare precum c\u0103utarea binar\u0103, c\u0103utarea ternar\u0103 este util\u0103 pentru a afla dac\u0103 valoarea extrem\u0103 nu se g\u0103se\u0219te \u00een prima sau ultima treime a spa\u021biului de c\u0103utare, algoritmul repet\u00e2ndu-se pentru celelalte dou\u0103 treimi ale intervalului c\u0103utat.</p> <p>C\u0103utarea ternar\u0103 este un exemplu de algoritm de tipul divide et impera, al\u0103turi de c\u0103utarea binar\u0103 \u0219i al\u021bi algoritmi similari.</p>","tags":["sortare","cautari","matematica"]},{"location":"dificil/ternary-search/#functia-in-sine","title":"Func\u021bia \u00een sine","text":"<p>Pentru a putea aplica c\u0103utarea ternar\u0103, trebuie ca func\u021bia s\u0103 fie (des)cresc\u0103toare (de regul\u0103, strict) p\u00e2n\u0103 la un punct \\(x\\) unde g\u0103sim cea mai mic\u0103 pozi\u021bie care ne d\u0103 valoarea maxim\u0103/minim\u0103 a func\u021biei, urm\u00e2nd c\u0103 func\u021bia s\u0103 fie mai apoi constant\u0103 p\u00e2n\u0103 la un punct \\(y\\), iar apoi func\u021bia va avea monotonia opus\u0103 fa\u021b\u0103 de cea p\u00e2n\u0103 la punctul \\(x\\).</p> <p>Cu alte cuvinte, func\u021bia cre\u0219te p\u00e2n\u0103 la punctul \\(x\\), apoi e constant\u0103 \u00een intervalul \\([x, y]\\), iar apoi scade de la punctul \\(y\\). Similar, putem spune \u0219i pentru cazul opus al unei func\u021bii unimodale.</p>","tags":["sortare","cautari","matematica"]},{"location":"dificil/ternary-search/#algoritmul-standard","title":"Algoritmul standard","text":"<p>S\u0103 presupunem c\u0103 avem o func\u021bie \\(f\\) care este definit\u0103 pe intervalul \\([a, b]\\). Asem\u0103n\u0103tor c\u0103ut\u0103rii binare, vom \u00eencepe prin a c\u0103uta acel punct extrem pe \u00eentreg intervalul. La fiecare pas, vom lua punctele \\(m_1\\) \u0219i \\(m_2\\), care vor fi situate la \\(\\frac{1}{3}\\) respectiv \\(\\frac{2}{3}\\) de cap\u0103tul din st\u00e2nga al intervalului, iar \u00een func\u021bie de valorile \\(f(m_1)\\) \u0219i \\(f(m_2)\\), avem urm\u0103toarele cazuri, acestea fiind similare \u0219i pentru o func\u021bie mai \u00eent\u00e2i descresc\u0103toare.</p> <ul> <li>Dac\u0103 \\(f(m_1) &lt; f(m_2)\\), maximul nu poate fi \u00een intervalul \\([a, m_1]\\) deoarece   \\(f(m_2)\\) este mai mare dec\u00e2t \\(f(m_1)\\).</li> <li>Dac\u0103 \\(f(m_1) &gt; f(m_2)\\), maximul nu poate fi \u00een intervalul \\([m_2, b]\\) deoarece   \\(f(m_1)\\) este mai mare dec\u00e2t \\(f(m_2)\\).</li> <li>Dac\u0103 \\(f(m_1) = f(m_2)\\), maximul nu poate fi dec\u00e2t \u00een intervalul \\([m_1, m_2]\\)   deoarece \\(f(m_1)\\) \u0219i \\(f(m_2)\\) sunt de p\u0103r\u021bi opuse ale punctului sau punctelor   maxime.</li> </ul> <p>Dup\u0103 ce am redus c\u0103utarea la o lungime suficient de mic\u0103 pentru a preveni erori de precizie, putem trata intervalul r\u0103mas folosind brute force pentru a ajunge la r\u0103spunsul dorit. Alternativ, putem apela algoritmul de un num\u0103r finit de ori, similar cu modul \u00een care am rula c\u0103utarea binar\u0103 pe numere reale.</p> <p>Complexitatea algoritmului este \\(\\mathcal{O}(\\log n)\\) unde \\(n\\) este dimensiunea intervalului de c\u0103utare. Se poate remarca faptul c\u0103 spre deosebire de c\u0103utarea binar\u0103, constanta este una mai mare deoarece \u00een medie reducem intervalul de c\u0103utare cu \\(\\frac{1}{3}\\) la un pas.</p> <pre><code>// f(i) este o func\u021bie oarecare\nlong long ternara(int epsilon) {\n    int st = 0;\n    int dr = 1000000000;\n\n    long long ans = -(1LL &lt;&lt; 60);\n\n    while (st &lt;= dr) {\n        int mid1 = st + (dr - st) / 3;\n        int mid2 = dr - (dr - st) / 3;\n\n        if (dr - st + 1 &lt;= epsilon) {\n            for (int i = st; i &lt;= dr; ++i) {\n                ans = max(ans, f(i));\n            }\n            break;\n        }\n\n        long long xa = f(mid1);\n        long long xb = f(mid2);\n\n        ans = max(ans, max(xa, xb));\n\n        if (xa == xb) {\n            st = mid1;\n            dr = mid2;\n        } else if (xa &lt; xb) {\n            st = mid1;\n        } else {\n            dr = mid2;\n        }\n    }\n    return ans;\n}\n</code></pre>","tags":["sortare","cautari","matematica"]},{"location":"dificil/ternary-search/#golden-section-search","title":"Golden Section Search","text":"<p>Pe l\u00e2ng\u0103 c\u0103utarea ternar\u0103, putem folosi pentru a optimiza procesul de c\u0103utare \u0219i c\u0103utarea Golden Section, care spre deosebire de c\u0103utarea ternar\u0103, \u00eemparte intervalul astfel \u00eenc\u00e2t cele dou\u0103 valori de mijloc s\u0103 fie puse la distanta \\(r = \\frac{3 - \\sqrt{5}}{2}\\), distant\u0103 care este egal\u0103 cu \\(\\frac{1}{\\phi}\\), unde \\(\\phi\\) este num\u0103rul de aur, egal cu aproximativ \\(1.618\\).</p> <pre><code>#include &lt;cmath&gt;\n#include &lt;iostream&gt;\n\nusing namespace std;\n\nconstexpr double gr = 1.618033988749895;\n\nconstexpr double gss(double (*f)(double), double a, double b,\n                     const double eps = 1e-5) {\n    double c = b - (b - a) / gr;\n    double d = a + (b - a) / gr;\n\n    while (abs(b - a) &gt; eps) {\n        // Pentru maxim, se inverseaz\u0103 semnul\n        if (f(c) &lt; f(d)) {\n            b = d;\n        } else {\n            a = c;\n        }\n\n        // Recalculam c si d pentru a evita pierderea preciziei\n        // lucru ce poate duce la raspunsuri gresite sau loop infinit\n        c = b - (b - a) / gr;\n        d = a + (b - a) / gr;\n    }\n\n    return (b + a) / 2;\n}\n\nint main() {\n    auto f = [](double x) { return (x - 1) * (x - 2); };\n\n    const double result = gss(f, 1, 5);\n\n    std::cout &lt;&lt; \"Minim la x = \" &lt;&lt; result &lt;&lt; std::endl;\n    return 0;\n}\n</code></pre>","tags":["sortare","cautari","matematica"]},{"location":"dificil/ternary-search/#problema-exemplu-devu-and-his-brother","title":"Problema exemplu - Devu and his Brother","text":"<p>\u00cen aceast\u0103 problem\u0103 avem doi vectori \\(a\\) \u0219i \\(b\\) \u0219i putem cre\u0219te/sc\u0103dea o valoare dintr-unul din cei doi vectori cu costul 1. Vrem s\u0103 afl\u0103m costul minim pentru ca minimul din vectorul \\(a\\) s\u0103 fie cel pu\u021bin egal cu maximul din vectorul \\(b\\).</p> <p>Se poate observa c\u0103 e clar c\u0103 vrem s\u0103 cre\u0219tem valorile din \\(a\\) \u0219i s\u0103 sc\u0103dem valorile din \\(b\\). De asemenea, se poate observa c\u0103 pe m\u0103sur\u0103 ce vrem s\u0103 aducem r\u0103spunsul la o oarecare \"median\u0103\", costul va fi tot mai mic. Aceste lucruri ne duc spre o abordare bazat\u0103 pe o c\u0103utare ternar\u0103 a r\u0103spunsului.</p> <p>Astfel, vom c\u0103uta ternar r\u0103spunsul \u00een intervalul \\([1, 10^9]\\) r\u0103spunsul aplic\u00e2nd algoritmul descris mai sus, implementarea fiind cea de mai sus.</p>","tags":["sortare","cautari","matematica"]},{"location":"dificil/ternary-search/#probleme-suplimentare","title":"Probleme suplimentare","text":"<ul> <li>CF 439D</li> <li>copii3 infoarena</li> <li>CEOI 2017 - Sure   Bet</li> <li>CF 1355 E</li> <li>CF 1848 D</li> <li>Lot Juniori 2018 cherhanale</li> <li>CCO 18-Gradient Descent</li> </ul>","tags":["sortare","cautari","matematica"]},{"location":"dificil/ternary-search/#bibliografie-si-lectura-suplimentara","title":"Bibliografie \u0219i lectur\u0103 suplimentar\u0103","text":"<ul> <li>Ternary Search - CP   Algorithms</li> <li>Ternary Search on Integers  -   Codeforces</li> <li>Tutorial On Tof (Ternary Search) -   Codeforces</li> <li>Solutia de la copii3 - infoarena</li> <li>Ternary Search - Wikipedia</li> <li>Numerical Methods with Programming - Golden Section   Search</li> <li>Golden Section Search -   Wikipedia</li> </ul>","tags":["sortare","cautari","matematica"]},{"location":"dificil/tree-dp/","title":"Programare dinamic\u0103 pe arbore","text":"","tags":["programare dinamica","arbori"]},{"location":"dificil/tree-dp/#introducere","title":"Introducere","text":"<p>\u00cen ceea ce prive\u0219te studiul program\u0103rii dinamice, un tip de probleme frecvent \u00eent\u00e2lnit reprezint\u0103 dinamica pe arbori. De\u0219i abordarea lor nu este foarte diferit\u0103 fa\u021b\u0103 de alte probleme care implic\u0103 diverse recuren\u021be, exist\u0103 c\u00e2teva sfaturi specifice care v\u0103 pot ajuta, \u00eempreun\u0103 cu propriet\u0103\u021bi specifice acestui tip de probleme.</p> <p>De obicei, atunci c\u00e2nd abord\u0103m aceste probleme, vrem s\u0103 ne g\u00e2ndim la modul \u00een care un nod \u0219i copiii lui interac\u021bioneaz\u0103, de regul\u0103 starea pentru un nod \\(i\\) (vom denumi generic aceast\u0103 stare \\(dp[i]\\), chiar dac\u0103 \u00een multe situa\u021bii vom avea \u0219i alte dimensiuni) are rezultatul definit \u00een func\u021bie de rezultatele fiilor s\u0103i. Modul \u00een care g\u0103sim aceste rela\u021bii, precum \u0219i diverse optimiz\u0103ri vor fi prezentate pe parcursul acestui articol, prin diverse exemple.</p> <p>Aceste probleme apar foarte des la olimpiadele \u0219i concursurile de informatic\u0103 rom\u00e2ne\u0219ti, dinamicile pe arbore fiind un tip de problem\u0103 preferat de propun\u0103tor, dat fiind faptul c\u0103 se reg\u0103se\u0219te aproape \u00een fiecare an m\u0103car la una din etapele competi\u021biei, deci se impune cunoa\u0219terea celor mai importante abord\u0103ri. De asemenea, concursuri precum USACO Gold \u0219i Platinum au un num\u0103r ridicat de asemenea probleme, de multe ori laolalt\u0103 cu diferite structuri de date.</p>","tags":["programare dinamica","arbori"]},{"location":"dificil/tree-dp/#problema-tree-matching-cses","title":"Problema Tree Matching - CSES","text":"<p>Pentru a rezolva aceast\u0103 problem\u0103, ne putem g\u00e2ndi la un caz foarte simplu, \u0219i anume cazul c\u00e2nd avem o r\u0103d\u0103cin\u0103 \u0219i un anumit num\u0103r de fii. \u00cen acest caz, ce putem face este fie s\u0103 nu conect\u0103m nodul curent la un alt nod, fie s\u0103 \u00eel conect\u0103m la unul din acele noduri.</p> <p>Astfel, putem deduce dou\u0103 tipuri de cazuri pe care le putem considera \u00een dinamica noastr\u0103, ceea ce motiveaz\u0103 prezen\u021ba unei dinamici cu dou\u0103 dimensiuni. \u00cen mod formal, vom avea urm\u0103toarele defini\u021bii:</p> <ul> <li>\\(dp[0][i]\\) va reprezenta r\u0103spunsul maxim dac\u0103 nu am folosit nodul \\(i\\) \u00een vreo   muchie.</li> <li>\\(dp[1][i]\\) va reprezenta r\u0103spunsul maxim dac\u0103 am folosit nodul \\(i\\) \u00een vreo   muchie.</li> </ul> <p>Pentru a defini \\(dp[0][i]\\), este simplu s\u0103 ne g\u00e2ndim la faptul c\u0103 vom vrea s\u0103 prelu\u0103m r\u0103spunsurile maxime de la fii, deci putem scrie \\(dp[0][i]\\) ca fiind \\(\\sum \\max(dp[0][x], dp[1][x])\\) pentru to\u021bi fiii \\(x\\) ai nodului \\(i\\).</p> <p>\u00cen mod similar, pentru a defini \\(dp[1][i]\\), vom vrea s\u0103 cupl\u0103m nodul \\(i\\) cu unul din fiii s\u0103i, iar mai apoi s\u0103 prelu\u0103m toate maximele de la celelalte noduri. Astfel, \\(dp[1][i]\\) va fi egal cu \\(\\max (1 + dp[0][x]+ \\sum \\max(dp[0][x_0], dp[1][x_0]))\\), unde \\(x\\) este fiul ales, iar \\(x_0\\) reprezint\u0103 oricare din ceilal\u021bi fii ai nodului \\(i\\).</p> <p>Implementarea acestei solu\u021bii se poate face folosind o parcurgere de tip DFS, complexitatea fiind una liniar\u0103. Chiar dac\u0103 aceast\u0103 problem\u0103 este una introductiv\u0103, are foarte multe aspecte care sunt folosite \u00een dinamicile pe arbore, \u00een special legate de combinarea subproblemelor \u0219i folosirea unei game largi de cazuri pentru a ajunge la solu\u021bia dorit\u0103.</p> <p>Mai jos pute\u021bi g\u0103si codul surs\u0103 la aceast\u0103 problem\u0103.</p> <pre><code>#include &lt;iostream&gt;\n#include &lt;vector&gt;\n\nusing namespace std;\n\nvoid dfs(int parent, int node, vector&lt;vector&lt;int&gt;&gt; &amp;tree,\n         vector&lt;vector&lt;int&gt;&gt; &amp;dp) {\n    int sum_mx = 0;\n    for (auto x : tree[node]) {\n        if (x != parent) {\n            dfs(node, x, tree, dp);\n            sum_mx += max(dp[1][x], dp[0][x]);\n        }\n    }\n\n    dp[0][node] = sum_mx;\n    for (auto x : tree[node]) {\n        if (x != parent) {\n            sum_mx -= max(dp[1][x], dp[0][x]);\n            dp[1][node] = max(dp[1][node], 1 + dp[0][x] + sum_mx);\n            sum_mx += max(dp[1][x], dp[0][x]);\n        }\n    }\n}\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n\n    int n;\n    cin &gt;&gt; n;\n\n    vector&lt;vector&lt;int&gt;&gt; tree(n);\n    for (int i = 0; i &lt; n - 1; i++) {\n        int a, b;\n        cin &gt;&gt; a &gt;&gt; b;\n        a--, b--;\n        tree[a].push_back(b);\n        tree[b].push_back(a);\n    }\n\n    vector&lt;vector&lt;int&gt;&gt; dp(2, vector&lt;int&gt;(n));\n\n    dfs(-1, 0, tree, dp);\n    cout &lt;&lt; max(dp[1][0], dp[0][0]) &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["programare dinamica","arbori"]},{"location":"dificil/tree-dp/#problema-the-fair-nut-and-best-path","title":"Problema The Fair Nut and Best Path","text":"<p>Pentru a calcula cantitatea maxim\u0103 de combustibil pe care o putem avea la finalul unui drum, vom vrea s\u0103 \u021binem minte cantitatea maxim\u0103 pe un lan\u021b care pleac\u0103 dintr-un nod anume spre unul din fiii s\u0103i, iar eventual s\u0103 unim dou\u0103 lan\u021buri pentru a putea considera cazul c\u00e2nd r\u0103d\u0103cina curent\u0103 reprezint\u0103 punctul de intersec\u021bie a dou\u0103 asemenea drumuri.</p> <p>Calcularea cantit\u0103\u021bii maxime pentru un lan\u021b este relativ facil\u0103, deoarece putem p\u0103stra o recuren\u021b\u0103 de tip \\(dp[i]\\) pentru fiecare posibil nod, dar unirea a dou\u0103 lan\u021buri este mai dificil\u0103 deoarece trebuie s\u0103 avem grij\u0103 s\u0103 evit\u0103m situa\u021biile \u00een care suma distan\u021belor este mai mare dec\u00e2t cantitatea pe care o putem colecta din ora\u0219e.</p> <p>Tratarea acestor cazuri se poate face \u00eentr-un loop separat care pleac\u0103 de la lan\u021bul cel mai avantajos pe care l-am calculat, urmat de ad\u0103ugarea celui de-al doilea lan\u021b, de preferat unul c\u00e2t mai bun din punct de vedere al benzinii r\u0103mase.</p> <p>Solu\u021bia are o complexitate liniar\u0103, aceast\u0103 problem\u0103 fiind instructiv\u0103 \u00een contextul trat\u0103rii cazurilor atunci c\u00e2nd vine vorba de unirea a dou\u0103 r\u0103spunsuri pentru a ob\u021bine un r\u0103spuns final c\u00e2t mai bun.</p> <pre><code>#include &lt;iostream&gt;\n#include &lt;vector&gt;\n\nusing namespace std;\nint n;\nlong long amount[300002], maxanswer;\nvector&lt;pair&lt;long long, long long&gt;&gt; v[300002];\nlong long dp[300002];\n\nvoid dfs(int parent, int node) {\n    int who = 0;\n    for (int i = 0; i &lt; v[node].size(); ++i) {\n        int nxt = v[node][i].first;\n        if (nxt == parent) {\n            continue;\n        }\n        int cost = v[node][i].second;\n        dfs(node, nxt);\n        if (dp[nxt] - cost &gt; dp[node]) {\n            dp[node] = dp[nxt] - cost, who = nxt;\n        }\n    }\n    dp[node] += amount[node];\n    maxanswer = max(maxanswer, dp[node]);\n    for (int i = 0; i &lt; v[node].size(); ++i) {\n        int nxt = v[node][i].first;\n        if (nxt == parent || nxt == who) {\n            continue;\n        }\n        int cost = v[node][i].second;\n        if (cost &lt; dp[node] || cost &lt; dp[nxt]) {\n            maxanswer = max(maxanswer, dp[node] - cost + dp[nxt]);\n        }\n    }\n}\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n\n    cin &gt;&gt; n;\n\n    for (int i = 1; i &lt;= n; ++i) {\n        cin &gt;&gt; amount[i], maxanswer = max(maxanswer, amount[i]);\n    }\n\n    for (int i = 1; i &lt; n; ++i) {\n        long long a, b, c;\n        cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;\n        v[a].push_back({b, c});\n        v[b].push_back({a, c});\n    }\n    dfs(0, 1);\n    cout &lt;&lt; maxanswer;\n    return 0;\n}\n</code></pre>","tags":["programare dinamica","arbori"]},{"location":"dificil/tree-dp/#problema-arbore-oni-2016","title":"Problema Arbore ONI 2016","text":"<p>Pentru a rezolva aceast\u0103 problem\u0103, ne vom g\u00e2ndi \u00een mod similar cu prima problem\u0103 la o solu\u021bie care va avea dou\u0103 cazuri pentru fiecare nod, dac\u0103 p\u0103str\u0103m acel nod sau nu \u00een arbore, abordare ce duce la calcularea at\u00e2t a num\u0103rului maxim de componente conexe, c\u00e2t \u0219i a calcul\u0103rii num\u0103rului de moduri de a ajunge la acest num\u0103r.</p> <p>Vom avea dou\u0103 cazuri, dac\u0103 decidem s\u0103 p\u0103str\u0103m nodul curent, vom aduna r\u0103spunsurile maxime de la fiecare fiu, iar \u00een caz contrar, vom avea o abordare similar\u0103, diferen\u021ba fiind aceea c\u0103 vom aduna doar cazurile c\u00e2nd p\u0103str\u0103m nodurile.</p> <p>Pentru mai multe detalii de implementare, pute\u021bi vedea solu\u021bia de mai jos.</p> <pre><code>#include &lt;fstream&gt;\n#include &lt;vector&gt;\n#define mod 1000000007\n\nusing namespace std;\n\nifstream f(\"arbore.in\");\nofstream g(\"arbore.out\");\n\nint n;\nvector&lt;int&gt; v[100002];\nint dp[3][100002];\nlong long ways[3][100002], sol, totalans;\n\nvoid dfs(int dad, int node) {\n    if (v[node].size() == 1 &amp;&amp; v[node][0] == dad) {\n        dp[1][node] = 1;\n        ways[1][node] = 1;\n        ways[2][node] = 1;\n        return;\n    }\n    int max3 = 0;\n    long long ways1 = 0;\n    int max1 = 1;\n    long long ways2 = 1;\n    int max2 = 0;\n    long long ways3 = 1;\n    for (int i = 0; i &lt; v[node].size(); ++i) {\n        int nxt = v[node][i];\n        if (nxt == dad) {\n            continue;\n        }\n        dfs(node, nxt);\n        max3 = max3;\n        if (dp[1][nxt] - 1 == dp[2][nxt]) {\n            max3 += dp[1][nxt] - 1;\n            ways3 = (ways3 * (ways[1][nxt] + ways[2][nxt])) % mod;\n        } else {\n            if (dp[1][nxt] - 1 &gt; dp[2][nxt]) {\n                max3 += dp[1][nxt] - 1;\n                ways3 = (ways3 * (ways[1][nxt])) % mod;\n            } else {\n                max3 += dp[2][nxt];\n                ways3 = (ways3 * ways[2][nxt]) % mod;\n            }\n        }\n        max1 = max1 + dp[2][nxt];\n        ways1 = (ways1 * ways[2][nxt]) % mod;\n        if (dp[1][nxt] == dp[2][nxt]) {\n            max2 += dp[1][nxt];\n            ways2 = (ways2 * (ways[1][nxt] + ways[2][nxt])) % mod;\n        } else {\n            if (dp[1][nxt] &gt; dp[2][nxt]) {\n                max2 += dp[1][nxt];\n                ways2 = (ways2 * (ways[1][nxt])) % mod;\n            } else {\n                max2 += dp[2][nxt];\n                ways2 = (ways2 * ways[2][nxt]) % mod;\n            }\n        }\n    }\n    max3++;\n    dp[1][node] = max(max3, max1);\n    dp[2][node] = max2;\n    ways[2][node] = ways2;\n    if (max3 == max1) {\n        ways[1][node] = (ways1 + ways3) % mod;\n    }\n    if (max3 &gt; max1) {\n        ways[1][node] = ways3;\n    }\n    if (max1 &gt; max3) {\n        ways[1][node] = ways1;\n    }\n    if (node == 1) {\n        if (dp[1][node] == dp[2][node]) {\n            totalans = (ways[1][node] + ways[2][node]) % mod;\n        }\n        if (dp[1][node] &gt; dp[2][node]) {\n            totalans = ways[1][node];\n        }\n        if (dp[2][node] &gt; dp[1][node]) {\n            totalans = ways[2][node];\n        }\n    }\n}\nint main() {\n    f &gt;&gt; n;\n    for (int i = 1; i &lt; n; ++i) {\n        int a, b;\n        f &gt;&gt; a &gt;&gt; b;\n        v[a].push_back(b);\n        v[b].push_back(a);\n    }\n    dfs(0, 1);\n    g &lt;&lt; max(dp[1][1], dp[2][1]) &lt;&lt; \" \" &lt;&lt; totalans &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["programare dinamica","arbori"]},{"location":"dificil/tree-dp/#problema-museum-ceoi-2017","title":"Problema Museum CEOI 2017","text":"<p>Observa\u021bie important\u0103</p> <p>Acest blog va detalia o tehnic\u0103 folosit\u0103 pentru aceast\u0103 problem\u0103 care ne ajut\u0103 s\u0103 optimiz\u0103m complexitatea cu un factor de \\(n\\).</p> <p>Exist\u0103 foarte multe dinamici pe arbore care au o solu\u021bie care dup\u0103 un num\u0103r de observa\u021bii, se reduc la un rucsac sau o idee similar\u0103. De regul\u0103, vom vrea s\u0103 ordon\u0103m nodurile dup\u0103 num\u0103rul de noduri din subarbore pentru a reduce num\u0103rul de opera\u021bii efectuat atunci c\u00e2nd actualiz\u0103m r\u0103spunsurile din dinamica noastr\u0103.</p> <p>Acest lucru se va observa \u0219i \u00een cazul problemei noastre, unde vom avea o dinamic\u0103 de tip \\(dp[0/1][i][j]\\), care reprezint\u0103 cel mai mic cost al unui traseu ce \u00eencepe \u00een nodul \\(i\\), viziteaz\u0103 nodul \\(j\\) \u0219i se \u00eentoarce sau nu la nodul \\(i\\) (1 - se \u00eentoarce, 0 - nu se \u00eentoarce).</p> <p>Pentru a calcula aceast\u0103 dinamic\u0103, vom avea pentru fiecare nod un rucsac care trece prin variantele de a continua un anume drum, \u00een func\u021bie de ordinea pe care o vom prefera. De notat c\u0103 trebuie s\u0103 fim aten\u021bi la implementare, deoarece exist\u0103 destul de multe detalii care trebuie avute \u00een considerare.</p> <pre><code>#include &lt;iostream&gt;\n#include &lt;vector&gt;\n\nusing namespace std;\n\nint n, k, x;\nint dp[2][10002][10002];\nint xtr[10002][10002];\n\nvector&lt;pair&lt;int, int&gt;&gt; v[10002];\n\nvector&lt;int&gt; dp2[2][10002];\nvector&lt;int&gt; xtr2[2][10002];\nvector&lt;bool&gt; viz2[2][10002];\nint sts[10002];\nvoid dfs(int parent, int node, int cost) {\n    sts[node] = 1;\n    for (int i = 0; i &lt; (int)v[node].size(); ++i) {\n        int vecin = v[node][i].first;\n        if (vecin == parent) {\n            continue;\n        }\n        dfs(node, vecin, v[node][i].second);\n        sts[node] += sts[vecin];\n    }\n\n    dp2[0][node].resize(sts[node] + 2, 0);\n    dp2[1][node].resize(sts[node] + 2, 0);\n\n    xtr2[0][node].resize(sts[node] + 2, 0);\n    xtr2[1][node].resize(sts[node] + 2, 0);\n\n    viz2[0][node].resize(sts[node] + 2, 0);\n    viz2[1][node].resize(sts[node] + 2, 0);\n\n    viz2[0][node][1] = 1;\n    sts[node] = 1;\n    for (int i = 0; i &lt; (int)v[node].size(); ++i) {\n        int vecin = v[node][i].first;\n        if (vecin == parent) {\n            continue;\n        }\n        int edcost = v[node][i].second;\n        for (int j = min(k, sts[node]); j &gt;= 1; --j) {\n            for (int sz = 1; sz &lt;= min(sts[vecin], k - j); ++sz) {\n                if (!viz2[1][node][j + sz]\n                    || dp2[0][node][j] + dp[1][vecin][sz] + edcost\n                           &lt; dp2[1][node][j + sz]) {\n                    dp2[1][node][j + sz] =\n                        dp2[0][node][j] + dp[1][vecin][sz] + edcost;\n                    viz2[1][node][j + sz] = 1;\n                    xtr2[1][node][j + sz] = xtr[vecin][sz];\n                } else {\n                    if (dp2[0][node][j] + dp[1][vecin][sz] + edcost\n                        == dp2[1][node][j + sz]) {\n                        xtr2[1][node][j + sz] =\n                            min(xtr2[1][node][j + sz], xtr[vecin][sz]);\n                    }\n                }\n                for (int trb = 0; trb &lt;= 1; ++trb) {\n                    if (!viz2[trb][node][j + sz]\n                        || dp2[trb][node][j] + dp[0][vecin][sz] + 2 * edcost\n                               &lt; dp2[trb][node][j + sz]) {\n                        dp2[trb][node][j + sz] =\n                            dp2[trb][node][j] + dp[0][vecin][sz] + 2 * edcost;\n                        viz2[trb][node][j + sz] = 1;\n                        xtr2[trb][node][j + sz] = xtr2[trb][node][j];\n                    } else if (dp2[trb][node][j] + dp[0][vecin][sz] + 2 * edcost\n                               == dp2[trb][node][j + sz]) {\n                        xtr2[trb][node][j + sz] =\n                            min(xtr2[trb][node][j + sz], xtr2[trb][node][j]);\n                    }\n                }\n            }\n        }\n        sts[node] += sts[vecin];\n    }\n    for (int i = 2; i &lt;= min(k, sts[node]); ++i) {\n        dp[1][node][i] = dp2[1][node][i];\n        xtr[node][i] = xtr2[1][node][i];\n        dp[0][node][i] = dp2[0][node][i];\n    }\n    for (int i = 1; i &lt;= min(k, sts[node]); ++i) {\n        xtr[node][i] += cost;\n    }\n}\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n\n    cin &gt;&gt; n &gt;&gt; k &gt;&gt; x;\n    for (int i = 1; i &lt; n; ++i) {\n        int a, b, c;\n        cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;\n        v[a].push_back({b, c});\n        v[b].push_back({a, c});\n    }\n    dfs(0, x, 0);\n    cout &lt;&lt; dp[1][x][k] &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["programare dinamica","arbori"]},{"location":"dificil/tree-dp/#problema-treegcd-oni-2019","title":"Problema TreeGCD ONI 2019","text":"<p>Pentru a rezolva aceast\u0103 problem\u0103, ne vom folosi de faptul c\u0103 valoarea lui \\(M\\) este foarte mic\u0103, ceea ce ne duce cu g\u00e2ndul la o dinamic\u0103 care s\u0103 implice fiecare valoare posibil\u0103 a CMMDC-ului \u00een parte.</p> <p>Mai \u00eent\u00e2i, vom precalcula pentru fiecare num\u0103r \\(i\\) de la 1 la \\(m\\) toate numerele cu proprietatea c\u0103 cmmdc-ul dintre ele \u0219i \\(i\\) este diferit de 1 \u0219i care nu au niciun factor prim \u00een descompunerea lor mai mult de o dat\u0103.</p> <p>Acest lucru ne va ajuta s\u0103 prevenim num\u0103rarea de mai multe ori a acelorla\u0219i r\u0103spunsuri, lucru specific problemelor ce folosesc principiul includerii \u0219i al excluderii.</p> <p>Apoi, vom rula un DFS din r\u0103d\u0103cin\u0103 \u00een care vom avea o dinamic\u0103 de tipul \\(dp[i][j]\\) ce reprezint\u0103 num\u0103rul de moduri de a avea un arbore cu r\u0103d\u0103cina \u00een nodul \\(i\\), iar \u00een acel nod avem valoarea \\(j\\).</p> <p>Pentru a calcula aceast\u0103 dinamic\u0103, putem avea mai \u00eent\u00e2i ni\u0219te tranzi\u021bii \u00eencete care calculeaz\u0103 pentru fiecare variant\u0103 de a avea o valoare pe un nod, num\u0103rul de moduri de a avea o valoare pe un fiu, dar aceast\u0103 abordare ar avea complexitatea \\(\\mathcal{O}(n \\cdot m^2)\\), ceea ce este prea \u00eencet.</p> <p>O observa\u021bie important\u0103 pe care o facem este aceea c\u0103 ne va interesa s\u0103 \u0219tim r\u0103spunsurile pentru divizorii fiec\u0103rei valori pe care o putem avea \u00een acel nod, iar atunci c\u00e2nd vom \u00eenmul\u021bi r\u0103spunsurile la un anume pas, vom \u021bine cont de num\u0103rul de factori primi \u0219i de suma par\u021bial\u0103 a r\u0103spunsurilor pentru numerele care sunt multiplu ale acelui divizor.</p> <p>Astfel, vom ajunge s\u0103 avem o complexitate echivalent\u0103 cu aplicarea unui PINEX, deci \\(\\mathcal{O}(n \\cdot m \\cdot DMAX)\\), unde \\(DMAX\\) este num\u0103rul maxim de divizori pe care \u00eei are un num\u0103r conform precalcul\u0103rii anterioare, iar acest num\u0103r \\(DMAX\\) este egal cu 31 deoarece orice num\u0103r de la 1 la \\(m\\) are cel mult 5 factori primi distinc\u021bi.</p> <p>Pentru mai multe detalii de implementare, recomand\u0103m consultarea sursei de mai jos.</p> <pre><code>#include &lt;algorithm&gt;\n#include &lt;fstream&gt;\n#include &lt;iostream&gt;\n#include &lt;vector&gt;\n\nusing namespace std;\n\nconst int N = 102;\nconst int M = 10004;\nconst int MOD = 1000000007;\n\nint n, m;\nvector&lt;int&gt; adj[N], divs[M];\nlong long dp[N][M], eradp[N][M], pfcnt[M];\n\nvoid dfs(int node, int parent) {\n    for (auto neighbor : adj[node]) {\n        if (neighbor != parent) {\n            dfs(neighbor, node);\n        }\n    }\n\n    for (int amt = 2; amt &lt;= m; ++amt) {\n        dp[node][amt] = 1;\n        for (auto neighbor : adj[node]) {\n            if (neighbor == parent) {\n                continue;\n            }\n            long long count = 0;\n            for (auto divisor : divs[amt]) {\n                if (divisor == 1) {\n                    continue;\n                }\n                count = (count\n                         + ((pfcnt[divisor] &amp; 1 ? -1 : 1)\n                            * eradp[neighbor][divisor])\n                         + MOD)\n                      % MOD;\n            }\n            dp[node][amt] = (dp[node][amt] * count) % MOD;\n        }\n    }\n\n    for (int i = 1; i &lt;= m; ++i) {\n        for (int j = i; j &lt;= m; j += i) {\n            eradp[node][i] = (eradp[node][i] + dp[node][j]) % MOD;\n        }\n    }\n}\n\nint main() {\n    ifstream cin(\"treegcd.in\");\n    ofstream cout(\"treegcd.out\");\n\n    cin &gt;&gt; n &gt;&gt; m;\n\n    for (int i = 0; i &lt; n - 1; ++i) {\n        int x, y;\n        cin &gt;&gt; x &gt;&gt; y;\n        --x;\n        --y;\n        adj[x].push_back(y);\n        adj[y].push_back(x);\n    }\n\n    for (int i = 2; i &lt; M; ++i) {\n        divs[i].push_back(1);\n        int num = i;\n        for (int j = 2; j * j &lt;= num; ++j) {\n            if (num % j == 0) {\n                int previous_size = divs[i].size();\n                for (int k = 0; k &lt; previous_size; ++k) {\n                    divs[i].push_back(divs[i][k] * j);\n                }\n                pfcnt[i]++;\n            }\n            while (num % j == 0) {\n                num /= j;\n            }\n        }\n        if (num != 1) {\n            int previous_size = divs[i].size();\n            for (int k = 0; k &lt; previous_size; ++k) {\n                divs[i].push_back(divs[i][k] * num);\n            }\n        }\n    }\n\n    dfs(0, 0);\n\n    long long result = 0;\n    for (int i = 1; i &lt;= m; ++i) {\n        result = (result + dp[0][i]) % MOD;\n    }\n\n    cout &lt;&lt; result &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["programare dinamica","arbori"]},{"location":"dificil/tree-dp/#problema-compressed-tree-codeforces","title":"Problema Compressed Tree - Codeforces","text":"<p>Pentru aceast\u0103 problem\u0103, vom avea o dinamic\u0103 pe dou\u0103 dimensiuni care va \u021bine cont de urm\u0103toarele cazuri:</p> <ul> <li>\\(dp[0][node]\\): cea mai mare sum\u0103 a unui subarbore cu r\u0103d\u0103cina \u00een \\(node\\), presupun\u00e2nd c\u0103 vom p\u0103stra leg\u0103tura dintre acest nod \u0219i p\u0103rintele s\u0103u.</li> <li>\\(dp[1][node]\\): cea mai mare sum\u0103 a unui subarbore cu r\u0103d\u0103cina \u00een \\(node\\), f\u0103r\u0103 a p\u0103stra leg\u0103tura dintre \\(node\\) \u0219i p\u0103rintele s\u0103u.</li> </ul> <p>\u00cen func\u021bie de aceste cazuri, vom vrea s\u0103 p\u0103str\u0103m un set de noduri, \u00eempreun\u0103 cu sumele lor care s\u0103 fie c\u00e2t mai mari, ceea ce duce cu g\u00e2ndul la o abordare \u00een care sort\u0103m sumele \u00een ordine descresc\u0103toare, lu\u00e2nd mereu termenii pozitivi, iar dac\u0103 este necesar, s\u0103 complet\u0103m cu un num\u0103r de termeni p\u00e2n\u0103 ajungem la doi, respectiv trei copii lua\u021bi.</p> <p>Ulterior, \u00een func\u021bie de num\u0103rul de fii, se pot deduce u\u0219or c\u00e2teva cazuri care puse laolalt\u0103, ne duc la solu\u021bia cerut\u0103, a\u0219a cum se poate observa \u00een codul de mai jos. \u00cen mod alternativ, pute\u021bi consulta \u0219i solu\u021bia oficial\u0103 propus\u0103 de autorii competi\u021biei.</p> <pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n\nlong long ans, v[500002], dp[2][500002];\nvector&lt;vector&lt;int&gt;&gt; tree;\n\nint n;\n\nvoid dfs(int parent, int node) {\n    vector&lt;long long&gt; sums;\n    for (int i = 0; i &lt; (int)tree[node].size(); i++) {\n        int nxt = tree[node][i];\n        if (nxt == parent) {\n            continue;\n        }\n        dfs(node, nxt);\n        sums.push_back(dp[0][nxt]);\n    }\n\n    sort(sums.begin(), sums.end());\n    reverse(sums.begin(), sums.end());\n\n    // keep the parent\n\n    dp[0][node] = v[node];\n    if (sums.size() &gt;= 2) {\n        long long sm = 0;\n        for (int i = 0; i &lt; (int)sums.size(); i++) {\n            if (sums[i] &lt; 0 &amp;&amp; i &gt;= 2) {\n                break;\n            }\n            sm += sums[i];\n        }\n        dp[0][node] = max(dp[0][node], v[node] + sm);\n    }\n\n    if (sums.size() &gt;= 1) {\n        dp[0][node] = max(dp[0][node], sums[0]);\n    }\n\n    // not keep the parent\n\n    if (sums.size() &gt;= 1) {\n        dp[1][node] = v[node] + sums[0];\n    }\n\n    if (sums.size() &gt; 2) {\n        long long sm = 0;\n        for (int i = 0; i &lt; (int)sums.size(); i++) {\n            if (sums[i] &lt; 0 &amp;&amp; i &gt;= 3) {\n                break;\n            }\n            sm += sums[i];\n        }\n        dp[1][node] = max(dp[1][node], v[node] + sm);\n    }\n\n    if (sums.size() &gt;= 2) {\n        dp[1][node] = max(dp[1][node], sums[0] + sums[1]);\n    }\n}\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n\n    int t;\n    cin &gt;&gt; t;\n\n    for (; t; t--) {\n        cin &gt;&gt; n;\n        ans = 0;\n        for (int i = 1; i &lt;= n; i++) {\n            cin &gt;&gt; v[i];\n            ans = max(ans, v[i]);\n        }\n\n        tree.resize(n + 1);\n        for (int i = 1; i &lt; n; i++) {\n            int a, b;\n            cin &gt;&gt; a &gt;&gt; b;\n            tree[a].push_back(b);\n            tree[b].push_back(a);\n        }\n        dfs(0, 1);\n\n        for (int i = 1; i &lt;= n; i++) {\n            ans = max(ans, dp[1][i]);\n            dp[0][i] = dp[1][i] = 0;\n        }\n        cout &lt;&lt; ans &lt;&lt; '\\n';\n        tree.clear();\n    }\n\n    return 0;\n}\n</code></pre>","tags":["programare dinamica","arbori"]},{"location":"dificil/tree-dp/#concluzii","title":"Concluzii","text":"<p>Dinamicile pe arbore apar foarte des \u00een competi\u021biile de informatic\u0103 rom\u00e2ne\u0219ti \u0219i nu numai, iar experien\u021ba c\u0103p\u0103tat\u0103 cu aceste tipuri de probleme se dovede\u0219te a fi foarte important\u0103 pentru ob\u021binerea unor rezultate foarte bune la olimpiad\u0103, \u00een special la ONI \u0219i baraj \u00een clasele XI-XII.</p> <p>Recomand\u0103m lucratul a c\u00e2t mai multe probleme, at\u00e2t din aceast\u0103 list\u0103 c\u00e2t \u0219i din celelalte articole men\u021bionate anterior, \u00een special cel despre rerooting, care are concepte mai simple, dar care se leag\u0103 de cuno\u0219tin\u021bele prezentate aici.</p>","tags":["programare dinamica","arbori"]},{"location":"dificil/tree-dp/#probleme-suplimentare","title":"Probleme suplimentare","text":"<ul> <li>AtCoder Independent Set</li> <li>OJI 2019 Tairos</li> <li>OJI 2008 Iepuri</li> <li>Nastia Plays with a Tree Codeforces</li> <li>ONI 2015 arbvalmax</li> <li>USACO Gold Barn Painting</li> <li>USACO Gold Delegation</li> <li>RMI 2023 AAtree</li> <li>ONI 2017 Baraj Seniori Cli</li> <li>Moisil 2024 Arborele frumos</li> <li>Permutree Codeforces</li> <li>JOI 2020 Power</li> <li>IZhO 2017 Hard route</li> <li>ONI 2018 tricolor</li> <li>ONI 2021 Baraj Seniori Arbsumpow</li> <li>ONI 2019 Baraj Seniori Anarhie</li> <li>CSES Creating Offices</li> <li>Miss Punyverse Codeforces</li> <li>IOI 2007 Training</li> <li>Probleme cu DP pe arbore de pe Kilonova</li> <li>Probleme cu DP pe arbore de pe Codeforces</li> </ul>","tags":["programare dinamica","arbori"]},{"location":"dificil/tree-dp/#resurse-suplimentare","title":"Resurse suplimentare","text":"<ul> <li>DP on Trees - USACO Guide</li> <li>DP on Trees tutorial - Codeforces</li> </ul>","tags":["programare dinamica","arbori"]},{"location":"dificil/trie/","title":"Trie (arbore de prefixe)","text":"","tags":["arbori","structuri de date","siruri de caractere"]},{"location":"dificil/trie/#ce-este-un-trie","title":"Ce este un Trie","text":"<p>Un trie (sau arbore de prefixe) este un arbore de c\u0103utare \\(k\\)-ar (un arbore cu r\u0103d\u0103cin\u0103 unde fiecare nod are maxim \\(k\\) fii), reprezent\u00e2nd un mod unic de a memora informa\u021biile, numite \u0219i chei.</p> <p>Num\u0103rul de fii al unui nod este \u00een mare parte influen\u021bat de tipul informa\u021biilor memorate, dar de cele mai multe ori, un Trie este folosit pentru re\u021binerea \u0219irurilor de caractere, astfel fiecare nod av\u00e2nd maxim 26 fii.</p> <p>Ini\u021bial arborele con\u021bine doar un singur nod, r\u0103d\u0103cina, urm\u00e2nd ca apoi cuvintele s\u0103 fie introduse \u00een ordinea citirii lor, de la st\u00e2nga la dreapta. Observ\u0103m c\u0103 \u00een\u0103l\u021bimea arborelui este lungimea maxim\u0103 a unui cuv\u00e2nt. Complexitatea de timp este \\(\\mathcal{O}(L)\\), unde \\(L\\) este lungimea maxim\u0103, iar memoria consumat\u0103, \u00een cel mai r\u0103u caz, este \\(\\mathcal{O}({ L \\cdot k})\\).</p> Un exemplu de trie pentru cuvintele am, bad, be \u0219i so","tags":["arbori","structuri de date","siruri de caractere"]},{"location":"dificil/trie/#moduri-de-implementare","title":"Moduri de implementare","text":"<p>Exist\u0103 dou\u0103 modalit\u0103\u021bi standard prin care putem implementa un Trie, folosind pointeri sau vectori. Ambele func\u021bioneaz\u0103 la fel de bine, \u00eens\u0103 opera\u021bia de delete este mai greu de implementat cu vectori.</p>","tags":["arbori","structuri de date","siruri de caractere"]},{"location":"dificil/trie/#prin-pointeri","title":"Prin pointeri","text":"<p>Ne vom folosi de o structur\u0103 unde vom re\u021bine un contor reprezent\u00e2nd de c\u00e2te ori am trecut prin nodul curent, c\u00e2t \u0219i un vector de pointeri, reprezent\u00e2nd fiii nodului curent.</p> <pre><code>struct Trie {\n    int cnt;\n    Trie *fii[26];\n\n    Trie() : cnt{0} {\n        for (int i = 0; i &lt; 26; ++i) {\n            fii[i] = nullptr;\n        }\n    }\n\n    ~Trie() {\n        for (int i = 0; i &lt; 26; ++i) {\n            delete fii[i];\n        }\n    }\n};\n\nTrie *root = new Trie;\n</code></pre> <p>Opera\u021bia de insert poate fi foarte u\u0219or scris\u0103 recursiv.</p> <pre><code>void insert(Trie *node, string a, int poz) {\n    if (poz == a.size()) {\n        node-&gt;cnt++;\n        return;\n    }\n\n    int index = a[poz] - 'a';\n    if (node-&gt;fii[index] == nullptr) {\n        node-&gt;fii[index] = new Trie();\n    }\n\n    insert(node-&gt;fii[index], a, poz + 1);\n}\n</code></pre> <p>\u00cen momentul \u00een care am ajuns la un nod \\(node\\) \u00een arbore, verific\u0103m dac\u0103 exist\u0103 fiul pentru caracterul urm\u0103tor \u0219i dac\u0103 nu exist\u0103, \u00eel ad\u0103ug\u0103m \u00een arbore, apoi apel\u0103m recursiv p\u00e2n\u0103 ajungem la finalul stringului.</p> <p>Pentru a elimina un string din trie ne mai trebuie o informa\u021bie suplimentar\u0103, \u0219i anume s\u0103 \u0219tim c\u00e2\u021bi fii are un nod. A\u0219adar, dac\u0103 am eliminat un sufix al \u0219irului \u0219i nodul curent nu mai are fii nici nu mai este vizitat prin alt \u0219ir inserat, putem da erase complet la pointerul respectiv.</p> <pre><code>bool del(Trie *node, string a, int pos) {\n    int idx = a[pos] - 'a';\n    if (pos == a.size()) {\n        node-&gt;cnt--;\n    } else if (del(node-&gt;fii[idx], a, pos + 1)) {\n        node-&gt;nrf--;\n        node-&gt;fii[idx] = nullptr;\n    }\n\n    if (node-&gt;cnt == 0 &amp;&amp; node-&gt;nrf == 0 &amp;&amp; node != t) {\n        delete node;\n        return 1;\n    }\n\n    return 0;\n}\n</code></pre> <p>Restul opera\u021biilor se implementeaz\u0103 similar, practic baza tuturor opera\u021biilor st\u0103 \u00een modul de a parcurge trie-ul.</p>","tags":["arbori","structuri de date","siruri de caractere"]},{"location":"dificil/trie/#prin-vectori","title":"Prin vectori","text":"<p>\u00cen loc de o structur\u0103 vom folosi un vector cu \\(k\\) coloane. \u00cen fiecare element din vector vom re\u021bine pozi\u021bia fiului respectiv.</p> <pre><code>vector&lt;vector&lt;int&gt;&gt; trie(1, vector&lt;int&gt;(26, -1));\n</code></pre> <p>Astfel <code>trie[node][5]</code> va fi egal cu pozi\u021bia \u00een vectorul trie pentru al cincilea fiu a lui <code>node</code>.</p> <p>Opera\u021bia de inserare este foarte similar\u0103 fa\u021b\u0103 de cea precedent\u0103, singurul lucru care difer\u0103 este modul de implementare. \u00cen acest caz ne este mult mai u\u0219or s\u0103 folosim o func\u021bie care s\u0103 itereze propriu-zis prin \u0219irul de caractere.</p> <pre><code>vector&lt;vector&lt;int&gt;&gt; trie(1, vector&lt;int&gt;(26, -1));\nvector&lt;int&gt; cnt(1);\n\nvoid insert(string a) {\n    int root = 0;\n    for (const char i : a) {\n        int idx = i - 'a';\n        if (trie[root][idx] == -1) {\n            trie[root][idx] = trie.size();\n            trie.emplace_back(26, -1);\n            cnt.push_back(0);\n        }\n        cnt[root]++;\n        root = trie[root][idx];\n    }\n    cnt[root]++;\n}\n</code></pre> <p>Observ\u0103m faptul c\u0103 increment\u0103m \u0219i la final contorul.</p>","tags":["arbori","structuri de date","siruri de caractere"]},{"location":"dificil/trie/#trie-pe-biti","title":"Trie pe bi\u021bi","text":"<p>Unele probleme necesit\u0103 re\u021binerea numerelor \u00eentr-o structur\u0103 de date, cum ar fi un trie, \u00eensa vom \u00eenlocui \u0219irurile de caractere cu reprezentarea binar\u0103 a numerelor.</p>","tags":["arbori","structuri de date","siruri de caractere"]},{"location":"dificil/trie/#problema-xormax-de-pe-kilonova-usoara","title":"Problema xormax de pe Kilonova (u\u0219oar\u0103)","text":"<p>Un exemplu bun este chiar problema xormax, unde ni se d\u0103 un vector cu \\(N\\) elemente \u0219i trebuie s\u0103 afl\u0103m care este suma xor maxim\u0103 a unui interval. Suma xor a unui interval cu capetele \\([L, R]\\) este valoarea \\(v_L \\oplus v_{L+1} \\oplus \\dots \\oplus v_R\\), unde \\(\\oplus\\) este operatorul xor pe bi\u021bi.</p> <p>Pentru a rezolva problema putem parcurge vectorul de la st\u00e2nga la dreapta \u0219i s\u0103 aflam pentru fiecare \\(1 \\leq i \\leq N\\) care este suma xor maxim\u0103 a unui interval care se termin\u0103 \u00een \\(i\\). Dac\u0103 construim vectorul \\(xp\\), unde \\(xp[i] = v_1 \\oplus v_2 \\oplus \\dots \\oplus v_{i-1} \\oplus v_i\\), atunci suma xor pe intervalul \\([L, R]\\) este egal\u0103 cu \\(xp[R] \\oplus xp[L-1]\\). Observ\u0103m c\u0103 pentru un \\(R\\) fixat trebuie s\u0103 g\u0103sim care este \\(L\\)-ul care maximizeaz\u0103 rela\u021bia de mai sus. Pentru a face asta putem s\u0103 introducem primii \\(R-1\\) \\(xp\\)-uri \u00eentr-un trie pe bi\u021bi \u0219i s\u0103 c\u0103ut\u0103m bit cu bit, \u00eencep\u00e2nd cu bitul semnificativ, \\(xp\\)-ul care va maximiza rezultatul.</p> <pre><code>#include &lt;iostream&gt;\n#include &lt;vector&gt;\n\nusing namespace std;\nconst int N = 2e5 + 1;\n\nvector&lt;vector&lt;int&gt;&gt; trie(1, vector&lt;int&gt;(2, -1));\n\nint n, v[N], xp[N];\n\nint find(int nr) {\n    int root = 0;\n    int ans = 0;\n    for (int bit = 31; bit &gt;= 0; bit--) {\n        bool b = (nr &amp; (1 &lt;&lt; bit));\n        if (trie[root][!b] == -1) {\n            if (trie[root][b] == -1) {\n                return ans;\n            } else {\n                root = trie[root][b];\n            }\n        } else {\n            ans += (1 &lt;&lt; bit);\n            root = trie[root][!b];\n        }\n    }\n    return ans;\n}\n\nvoid insert(int nr) {\n    int root = 0;\n    for (int bit = 31; bit &gt;= 0; bit--) {\n        bool b = (nr &amp; (1 &lt;&lt; bit));\n        if (trie[root][b] == -1) {\n            trie[root][b] = trie.size();\n            trie.emplace_back(2, -1);\n        }\n        root = trie[root][b];\n    }\n}\n\nint main() {\n    cin.tie(nullptr)-&gt;sync_with_stdio(nullptr);\n    cin &gt;&gt; n;\n\n    for (int i = 1; i &lt;= n; i++) {\n        cin &gt;&gt; v[i];\n        xp[i] = xp[i - 1] ^ v[i];\n    }\n\n    int ans = 0;\n    insert(0);\n\n    for (int i = 1; i &lt;= n; i++) {\n        int res = find(xp[i]);\n        ans = max(ans, res);\n        insert(xp[i]);\n    }\n\n    cout &lt;&lt; ans;\n}\n</code></pre> <p>O variant\u0103 care se folose\u0219te de implementarea cu pointeri este urm\u0103toarea:</p> <pre><code>#include &lt;iostream&gt;\n#include &lt;vector&gt;\n\nusing namespace std;\n\nstruct Trie {\n    Trie *_next[2];\n    int _pos;\n\n    explicit Trie(const int value) : _pos{value}, _next{nullptr, nullptr} {}\n\n    Trie() : Trie{-1} {}\n\n    ~Trie() {\n        delete _next[0];\n        delete _next[1];\n    }\n} *root;\n\nvoid add(const int val, const int idx) {\n    Trie *node = root;\n\n    for (int i = 29; i &gt;= 0; i--) {\n        bool has = (val &gt;&gt; i) &amp; 1;\n        if (node-&gt;_next[has] == nullptr) {\n            node-&gt;_next[has] = new Trie(idx);\n        }\n        node = node-&gt;_next[has];\n    }\n}\n\nint query(const int val) {\n    Trie *node = root;\n\n    for (int i = 29; i &gt;= 0; i--) {\n        bool has = (val &gt;&gt; i) &amp; 1;\n        if (node-&gt;_next[!has]) {\n            node = node-&gt;_next[!has];\n        } else if (node-&gt;_next[has]) {\n            node = node-&gt;_next[has];\n        } else {\n            break;\n        }\n    }\n    return node-&gt;_pos;\n}\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(nullptr);\n    cout.tie(nullptr);\n\n    root = new Trie(0);\n\n    int n, x, sum = 0, value = 0;\n    cin &gt;&gt; n;\n    vector&lt;int&gt; sums(n + 1);\n\n    add(sum, 0);\n\n    for (int i = 1; i &lt;= n; i++) {\n        cin &gt;&gt; x;\n        sum ^= x;\n        sums[i] = sum;\n\n        value = max(value, x);\n\n        if (i &gt; 1) {\n            int qry = query(sum);\n            value = max(value, sum ^ sums[qry]);\n        }\n\n        add(sum, i);\n    }\n\n    cout &lt;&lt; value;\n\n    delete root;\n\n    return 0;\n}\n</code></pre>","tags":["arbori","structuri de date","siruri de caractere"]},{"location":"dificil/trie/#problema-xor-construction-medie","title":"Problema XOR Construction (medie)","text":"<p>\u00cen aceast\u0103 problem\u0103 ni se dau \\(n-1\\) numere, unde al \\(i\\)-lea are valoarea \\(a_i\\), iar noi trebuie s\u0103 construim alt vector \\(b\\), cu \\(n\\) elemente, astfel \u00eenc\u00e2t s\u0103 existe toate numerele de la 0 la \\(n-1\\) \u00een \\(b\\), iar \\(b_i \\oplus b_{i+1} = a_i\\).</p> <p>\u00cen primul r\u00e2nd, dac\u0103 \\(b_i = 0\\) atunci \\(b_{i+1} = a_i\\), \\(b_{i+1} \\oplus b_{i+2} = a_{i+1}\\) , deci \\(b_{i+2} = a_i \\oplus a_{i+1}\\) \u0219i \\(b_{i+3} = a_i \\oplus a_{i+1} \\oplus a_{i+2}\\). Prin urmare deducem o form\u0103 general\u0103 pentru \\(b_j\\), unde \\(i &lt; j\\) , \u0219i anume \\(b_j = a_i \\oplus a_{i+1} \\oplus a_{i+2} \\oplus \\dots \\oplus a_{j-1}\\). Proprietatea se respect\u0103 \u0219i pentru oricare \\(j &lt; i\\), avem \\(b_j = a_j \\oplus a_{j+1} \\oplus \\dots \\oplus a_{i-1}\\).</p> <p>\u00cen al doilea r\u00e2nd, enun\u021bul problemei asigur\u0103 faptul c\u0103 mereu va exista solu\u021bie. Dar c\u00e2nd nu avem solu\u021bie? P\u0103i \u00een momentul \u00een care se repet\u0103 dou\u0103 elemente \u00een vectorul \\(b\\), ceea ce \u00eenseamn\u0103 faptul c\u0103 trebuie s\u0103 existe o secven\u021b\u0103 cu suma xor egal\u0103 cu 0. Pentru simplitate vom spune c\u0103 pe pozi\u021bia \\(k\\) va fi \\(b_k = 0\\). Dac\u0103 \\(i &lt; j\\) \u0219i \\(b_i = b_j\\) \u0219i \\(j &lt; k\\), atunci \\(a_i \\oplus a_{i+1} \\oplus a_{i+2} \\oplus \\dots \\oplus a_{j-1} = 0\\), analog pentru \\(i &gt; j &gt; k\\). Dac\u0103 \\(i &lt; k &lt; j\\) \u0219i \\(b_i = b_j\\) atunci \\(b_i = a_i \\oplus a_{i+1} \\oplus \\dots \\oplus a_{k-1}\\), \\(b_j = a_k \\oplus a_{k+1} \\dots \\oplus a_{j-1}\\). Prin urmare \\(a_i \\oplus a_{i+1} \\oplus \\dots \\oplus a_{j-1} = 0\\). A\u0219adar, \u0219tim ca mereu \u00een vectorul \\(b\\) elementele vor fi distincte.</p> <p>\u00cen al treilea r\u00e2nd, observ\u0103m c\u0103 vectorul \\(b\\) este generat \u00een func\u021bie de ce valoare are \\(k\\). Deci o prim\u0103 idee ar fi s\u0103 fix\u0103m mai \u00eent\u00e2i unde vom pune 0-ul \u00een vectorul \\(b\\) \u0219i s\u0103-l construim \u00een \\(\\mathcal{O}(n)\\), complexitatea temporal\u0103 fiind \\(\\mathcal{O}(n^2)\\). Dar putem s\u0103 ne folosim de a doua observa\u021bie, \u0219i anume c\u0103 mereu vectorul \\(b\\) va avea elementele distincte. Deci ne este suficient s\u0103 \u0219tim care va fi valoarea maxim\u0103 din \\(b\\) dac\u0103 0-ul se afl\u0103 pe pozi\u021bia \\(k\\). Pentru a face asta putem s\u0103 folosim 2 trie-uri, unul pentru sufix, altul pentru prefix, complexitatea final\u0103 devenind \\(\\mathcal{O}(n \\log n)\\).</p> <pre><code>#include &lt;iostream&gt;\n#include &lt;vector&gt;\n\nusing namespace std;\nconst int N = 2e5 + 1;\n\nint n;\nvector&lt;int&gt; v(N), ans(N);\nvector&lt;int&gt; xr1(N), xr2(N);\n\nvector&lt;vector&lt;int&gt;&gt; trie1(1, vector&lt;int&gt;(2, -1)), trie2(1, vector&lt;int&gt;(2, -1));\n\nvector&lt;int&gt; maxim1(N), maxim2(N);\n\nvoid insert(vector&lt;vector&lt;int&gt;&gt; &amp;trie, int nr) {\n    int root = 0;\n    for (int i = 30; i &gt;= 0; i--) {\n        bool bit = (nr &amp; (1 &lt;&lt; i));\n        if (trie[root][bit] == -1) {\n            trie[root][bit] = trie.size();\n            trie.push_back(vector&lt;int&gt;(2, -1));\n        }\n        root = trie[root][bit];\n    }\n}\n\nint get_max(vector&lt;vector&lt;int&gt;&gt; &amp;trie, int nr) {\n    int ans = 0;\n    int root = 0;\n    for (int i = 30; i &gt;= 0; i--) {\n        bool bit = (nr &amp; (1 &lt;&lt; i));\n        if (trie[root][!bit] != -1) {\n            ans += (1 &lt;&lt; i);\n            root = trie[root][!bit];\n        } else if (trie[root][bit] != -1) {\n            root = trie[root][bit];\n        }\n    }\n    return ans;\n}\n\nint main() {\n    cin &gt;&gt; n;\n    int xr = 0;\n    for (int i = 1; i &lt; n; i++) {\n        cin &gt;&gt; v[i];\n        xr1[i] = xr1[i - 1] ^ v[i];\n    }\n    for (int i = n - 1; i &gt;= 1; i--) {\n        xr2[i] = xr2[i + 1] ^ v[i];\n    }\n\n    maxim1[1] = 0;\n    maxim2[n] = 0;\n    insert(trie1, xr2[1]);\n\n    for (int i = 2; i &lt;= n; i++) {\n        maxim1[i] = get_max(trie1, xr2[i]);\n        insert(trie1, xr2[i]);\n    }\n\n    insert(trie2, xr1[n - 1]);\n    for (int i = n - 2; i &gt;= 0; i--) {\n        maxim2[i] = get_max(trie2, xr1[i]);\n        insert(trie2, xr1[i]);\n    }\n\n    for (int i = 1; i &lt;= n; i++) {\n        if (max(maxim1[i], maxim2[i - 1]) == n - 1) {\n            int xr1 = 0, xr2 = 0;\n            vector&lt;int&gt; fr(2 * n + 1);\n            fr[0] = 1;\n            ans[i] = 0;\n            for (int j = i - 1; j &gt;= 1; j--) {\n                ans[j] = v[j] ^ ans[j + 1];\n                xr1 ^= v[j];\n                fr[ans[j]]++;\n                if (fr[ans[j]] &gt;= 2) {\n                    break;\n                }\n            }\n            for (int j = i; j &lt; n; j++) {\n                ans[j + 1] = v[j] ^ xr2;\n                xr2 ^= v[j];\n                fr[ans[j + 1]]++;\n                if (fr[ans[j + 1]] &gt;= 2) {\n                    break;\n                }\n            }\n            int ok = 1;\n            for (int j = 0; j &lt; n; j++) {\n                if (fr[j] != 1) {\n                    ok = 0;\n                    break;\n                }\n            }\n            if (1) {\n                for (int j = 1; j &lt;= n; j++) {\n                    cout &lt;&lt; ans[j] &lt;&lt; \" \";\n                }\n                return 0;\n            }\n        }\n    }\n}\n</code></pre>","tags":["arbori","structuri de date","siruri de caractere"]},{"location":"dificil/trie/#problema-cuvinte-medie-grea","title":"Problema cuvinte (medie-grea)","text":"<p>Se dau \\(N\\) cuvinte formate doar din primele \\(K\\) litere mici ale alfabetului englez \u0219i un \u0219ir \\(x_i\\), de \\(M\\) numere naturale. Trebuie s\u0103 se formeze \\(M\\) cuvinte astfel \u00eenc\u00e2t oricare cuv\u00e2nt \\((1 \\leq i \\leq M)\\) s\u0103 respecte urm\u0103toarele propriet\u0103\u021bi:</p> <ul> <li>S\u0103 aib\u0103 lungimea \\(x_i\\).</li> <li>S\u0103 fie format doar din primele \\(K\\) litere mici ale alfabetului englez.</li> <li>S\u0103 nu existe \\(j \\leq M,\\, j \\neq i\\), sau un cuv\u00e2nt \\(cuv\\) din cele \\(N\\), astfel   \u00eenc\u00e2t cuv\u00e2ntul \\(j\\) s\u0103 fie prefix pentru cuv\u00e2ntul \\(i\\), sau \\(cuv\\) s\u0103 fie prefix   pentru \\(i\\).</li> <li>S\u0103 nu existe \\(j \\leq M,\\, j \\neq i\\), sau un cuv\u00e2nt \\(cuv\\) din cele \\(N\\), astfel   \u00eenc\u00e2t cuv\u00e2ntul \\(i\\) s\u0103 fie prefix pentru cuv\u00e2ntul \\(j\\), sau \\(i\\) s\u0103 fie prefix   pentru \\(cuv\\).</li> </ul>","tags":["arbori","structuri de date","siruri de caractere"]},{"location":"dificil/trie/#solutie","title":"Solu\u021bie","text":"<p>Prima idee ar fi s\u0103 sortam vectorul \\(x\\). Fie \\(dp_i\\) = \u00een c\u00e2te moduri putem alege primele \\(i\\) cuvinte. Putem considera toate posibilit\u0103\u021bile de a forma \u0219irurile , iar abia apoi s\u0103 vedem cum elimin\u0103m pe cele care nu sunt bune. Cu alte cuvinte, fie \\((s_1, s_2, .. , s_{i-1})\\) primele \\(i-1\\) cuvinte alese astfel \u00eenc\u00e2t s\u0103 respecte condi\u021biile impuse de problem\u0103. Sunt \u00een total \\(dp_{i-1} \\cdot K^{x_i}\\) moduri de a forma un set de \u0219iruri cu primele \\(i\\) cuvinte.</p> <p>Observa\u021bie</p> <p>Nu exist\u0103 dou\u0103 cuvinte, \\(s_x\\) \u0219i \\(s_y\\), astfel \u00eenc\u00e2t ambele s\u0103 fie prefixe pentru \\(s_i\\).</p> <p>Dac\u0103 ambele ar fi prefixe pentru \\(s_i\\), atunci fie \\(s_x\\) este prefix pentru \\(s_y\\), fie invers, ceea ce este fals, pentru c\u0103 noi am generat primele \\(i-1\\) cuvinte optim.</p> <p>Astfel dac\u0103 pentru fiecare cuv\u00e2nt \\(k\\), \\(k &lt; i\\), putem s\u0103 sc\u0103dem din num\u0103rul total de posibilit\u0103\u021bi \u0219irurile unde \\(s_k\\) este prefix pentru \\(s_i\\), nu vom elimina dou\u0103 configura\u021bii la fel.</p> \\[ dp_i = dp_{i-1} \\cdot K^{x_i} - dp_{i-1} \\cdot \\sum_{j = 1}^{i-1} K^{x_i - x_j} \\] <p>Observa\u021bie</p> <p>Nu exist\u0103 dou\u0103 cuvinte, unul provenit din cele \\(N\\) date \u0219i cel\u0103lalt (\\(s_k\\)) din primele \\(i-1\\) astfel \u00eenc\u00e2t ambele s\u0103 fie prefixe pentru \\(s_i\\). Dac\u0103 ambele sunt prefixe pentru \\(s_i\\), atunci fie \\(s_k\\) este prefix pentru un cuv\u00e2nt din cele \\(N\\), fie invers.</p> <p>Deci, putem s\u0103 fixam un cuv\u00e2nt din cele \\(N\\) date ini\u021bial \u0219i s\u0103 elimin\u0103m num\u0103rul de posibilit\u0103\u021bi ca el s\u0103 fie prefix pentru \\(s_i\\). Datorit\u0103 observa\u021biei, nu vom elimina o posibilitate dac\u0103 a fost eliminat\u0103 deja \u00een prima etap\u0103.</p> <p>\u00cen mod natural vom zice c\u0103 din dp-ul nostru vom sc\u0103dea \u00een mod similar \\(dp_{i-1} \\cdot \\sum_{j = 1}^{N} K^{x_i - len(j)}\\), unde \\(len(j)\\) = lungimea cuv\u00e2ntului \\(j\\), cu \\(x_i \\geq len(j)\\). \u00cens\u0103 nu este adev\u0103rat, pentru c\u0103 dac\u0103 avem dou\u0103 cuvinte \\(x\\) \u0219i \\(y\\) , unde \\(x\\) este prefix pentru \\(y\\), atunci suma de mai sus va num\u0103ra 2 configura\u021bii de dou\u0103 ori. Observ\u0103m c\u0103 nou\u0103 ne trebuie practic doar acele cuvinte \\(x\\), pentru care nu exist\u0103 alt cuv\u00e2nt \\(y\\), cu \\(y\\) prefix pentru \\(x\\), iar \\(len(x) \\leq x_i\\).</p> <p>Astfel putem parcurge direct pe Trie-ul cuvintelor. Dac\u0103 suntem la un nod \\(node\\), acesta este cap\u0103tul unui cuv\u00e2nt, iar \\(len(cuv) \\leq x_i\\), atunci putem sc\u0103dea din dp-ul nostru \\(dp_{i-1} \\cdot K^{x_i - len(cuv)}\\) \u0219i s\u0103 oprim parcurgerea. Dac\u0103 suntem la un nod \\(node\\), acesta are lungimea egal\u0103 cu \\(x_i\\), atunci sc\u0103dem din dp \\(dp_{i-1}\\) \u0219i oprim parcurgerea.</p> <p>Cu alte cuvinte, o solu\u021bie \u00een \\(\\mathcal{O}(M^2 + M \\cdot S)\\) este posibil\u0103, unde \\(S = \\sum_{i=1}^{N} len(i)\\). Putem optimiza solu\u021bia, observ\u00e2nd c\u0103 de fiecare dat\u0103 putem face tranzi\u021biile \u00een \\(\\mathcal{O}(1)\\). Solu\u021bia final\u0103 devine \\(\\mathcal{O}(M + S)\\) sau \\(\\mathcal{O}(M \\cdot \\log + S)\\).</p> <pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\nconst int mod = 1e9 + 7, N = 3e5 + 1;\nstruct Mint {\n    int val;\n    Mint(int x = 0) { val = x % mod; }\n    Mint(long long x) { val = x % mod; }\n    Mint operator+(Mint oth) { return val + oth.val; }\n    Mint operator*(Mint oth) { return 1LL * val * oth.val; }\n    Mint operator-(Mint oth) { return val - oth.val + mod; }\n    Mint fp(Mint a, long long n) {\n        Mint p = 1;\n        while (n) {\n            if (n &amp; 1) {\n                p = p * a;\n            }\n            a = a * a;\n            n /= 2;\n        }\n        return p;\n    }\n    Mint operator/(Mint oth) {\n        Mint invers = fp(oth, mod - 2);\n        return 1LL * val * invers.val;\n    }\n    friend ostream&amp; operator&lt;&lt;(ostream&amp; os, const Mint&amp; lol) {\n        os &lt;&lt; lol.val;\n        return os;\n    }\n};\n\nint n, m, k;\nvector&lt;Mint&gt; dp(N);\nvector&lt;int&gt; x(N), depth(N), cnt1(N);\nvector&lt;vector&lt;int&gt;&gt; trie(1, vector&lt;int&gt;(26, -1));\nvector&lt;bool&gt; cnt(1);\nMint spm = 0;\nMint fp(Mint a, int n) {\n    Mint p = 1;\n    while (n) {\n        if (n &amp; 1) {\n            p = a * p;\n        }\n        a = a * a;\n        n /= 2;\n    }\n    return p;\n}\n\nvoid insert(string a) {\n    int root = 0;\n    for (int i = 0; i &lt; a.size(); i++) {\n        if (trie[root][a[i] - 'a'] == -1) {\n            trie[root][a[i] - 'a'] = trie.size();\n            trie.push_back(vector&lt;int&gt;(26, -1));\n            cnt.push_back(0);\n        }\n        root = trie[root][a[i] - 'a'];\n    }\n    cnt[root] = 1;\n}\nvoid dfs(int node, int lenx, int len) {\n    if (lenx == len) {\n        return;\n    }\n    if (cnt[node]) {\n        spm = spm + fp(k, lenx - len);\n        return;\n    }\n    for (int i = 0; i &lt; 26; i++) {\n        if (trie[node][i] != -1) {\n            dfs(trie[node][i], lenx, len + 1);\n        }\n    }\n}\nvoid dfs1(int node, int len) {\n    depth[len]++;\n    if (cnt[node]) {\n        cnt1[len]++;\n        return;\n    }\n    for (int i = 0; i &lt; 26; i++) {\n        if (trie[node][i] != -1) {\n            dfs1(trie[node][i], len + 1);\n        }\n    }\n}\nint main() {\n    cin.tie(0)-&gt;sync_with_stdio(0);\n    cin &gt;&gt; n &gt;&gt; m &gt;&gt; k;\n    for (int i = 1; i &lt;= n; i++) {\n        string a;\n        cin &gt;&gt; a;\n        insert(a);\n    }\n    for (int i = 1; i &lt;= m; i++) {\n        cin &gt;&gt; x[i];\n    }\n    sort(x.begin() + 1, x.begin() + 1 + m);\n    dp[1] = fp(k, x[1]);\n    Mint sm = 0;\n    dfs(0, x[1], 0);\n    dfs1(0, 0);\n    dp[1] = dp[1] - depth[x[1]];\n    dp[1] = dp[1] - spm;\n    for (int i = 2; i &lt;= m; i++) {\n        dp[i] = dp[i - 1] * fp(k, x[i]);\n        sm = sm * fp(k, x[i] - x[i - 1]);\n        sm = sm + fp(k, x[i] - x[i - 1]);\n        dp[i] = dp[i] - dp[i - 1] * sm;\n        spm = spm * fp(k, x[i] - x[i - 1]);\n        for (int j = x[i - 1]; j &lt; x[i]; j++) {\n            spm = spm + fp(k, x[i] - j) * cnt1[j];\n        }\n        dp[i] = dp[i] - dp[i - 1] * depth[x[i]];\n        dp[i] = dp[i] - dp[i - 1] * spm;\n    }\n    cout &lt;&lt; dp[m];\n}\n</code></pre>","tags":["arbori","structuri de date","siruri de caractere"]},{"location":"dificil/trie/#problema-cli-medie-grea","title":"Problema cli (medie-grea)","text":"<p>Se dau \\(N\\) cuvinte care trebuie tastate \u00eentr-un terminal. Un cuv\u00e2nt este considerat tastat dac\u0103 el va ap\u0103rea \u00een terminal cel pu\u021bin odat\u0103 pe parcursul tast\u0103rii. Avem dou\u0103 tipuri de opera\u021bii la dispozi\u021bie: ad\u0103ug\u0103m un caracter la finalul \u0219irul tastat deja, elimin\u0103m un caracter de la finalul \u0219irului (dac\u0103 nu este vid). Pentru fiecare \\(i = \\overline{1, K}\\), noi trebuie s\u0103 aflam care este num\u0103rul minim de opera\u021bii pentru a tasta exact \\(i\\) cuvinte distincte dintre cele date. \u00cen momentul \u00een care \u00eencepem s\u0103 tast\u0103m un cuv\u00e2nt, trebuie mereu s\u0103 \u00eencepem de la un \u0219ir vid \\((\\emptyset)\\), \u0219i s\u0103 termin\u0103m tastarea tot la un \u0219ir vid. Un exemplu de tastare corect\u0103 este: \\(\\emptyset \\rightarrow a \\rightarrow ab \\rightarrow abc \\rightarrow ab \\rightarrow a \\rightarrow \\emptyset\\).</p> <p>Ne vom folosi din nou de metoda program\u0103rii dinamice, dar de data asta vom face dp direct pe trie. Astfel, fie \\(dp[nod][i]\\) = num\u0103rul minim de opera\u021bii pentru a tasta \\(i\\) cuvinte cu prefixul format din lan\u021bul de la r\u0103d\u0103cin\u0103 la \\(nod\\). Acum, pentru un nod fixat din trie-ul nostru, putem presupune c\u0103 \u00een momentul tast\u0103rii vom \u00eencepe mereu cu \u0219irul format de la r\u0103d\u0103cin\u0103 la \\(nod\\), \u00een loc de \\(\\emptyset\\). De exemplu, dac\u0103 cuvintele au prefixul abab, atunci noi vom presupune o succesiune valid\u0103 de opera\u021bii: \\(abab \\rightarrow abab\\textbf{c} \\rightarrow \\dots \\rightarrow abab\\textbf{c} \\rightarrow abab\\). Putem deci face un rucsac pentru fiii nodului, \\(dp1[i][j]\\) = care e num\u0103rul minim de opera\u021bii pentru a tasta \\(j\\) cuvinte din primii \\(i\\) fii. Pentru c\u0103 prefixul necesit\u0103 \\(\\text{len}(prefix)\\) opera\u021bii de ad\u0103ugare \u0219i \u0219tergere, vom \u00eencepe \\(dp\\)-ul nostru cu \\(2 \\cdot \\text{len}(prefix)\\) opera\u021bii deja f\u0103cute. Cu alte cuvinte, pentru a tasta 0 cuvinte vom face \\(dp1[0][0] = 2 \\cdot \\text{len}(prefix)\\). \u00cen momentul \u00een care trecem de la \\(i\\) la \\(i+1\\) avem 2 cazuri: fie nu lu\u0103m fiul respectiv \u00een considerare, fie alegem \\(p\\) \u0219iruri pe care le vom tasta \u00een \\(dp[fiu(i)][p] - 2 \\cdot \\text{len}(prefix)\\) opera\u021bii.</p> <pre><code>for (int i = 1; i &lt;= 26; i++) {\n    for (int k1 = 0; k1 &lt;= min(sz[nod], k); k1++) {\n        dp1[i][k1] = min(dp1[i][k1], dp1[i - 1][k1]);\n\n        const auto nod2 = trie[nod][i - 1];\n        for (int k2 = 1; k2 &lt;= k1 &amp;&amp; nod2 != -1 &amp;&amp; k2 &lt; dp[nod2].size(); k2++) {\n            dp1[i][k1] =\n                min(dp1[i][k1], dp1[i - 1][k1 - k2] + dp[nod2][k2] - 2 * len);\n        }\n    }\n}\n</code></pre> <p>Problema const\u0103 \u00een faptul c\u0103 secven\u021ba de cod de mai sus ruleaz\u0103 pentru fiecare nod din trie, ceea ce ar rezulta \u00eentr-o complexitate de \\(\\mathcal{O}(N \\cdot K^2)\\). Doar c\u0103, \u00een practic\u0103 solu\u021bia are complexitatea de \\(\\mathcal{O}(N \\cdot K)\\). \u00cen momentul \u00een care facem rucsac pe un arbore, este foarte important s\u0103 fim aten\u021bi la memoria \u0219i la timpul consumate. Observ\u0103m faptul c\u0103 cele dou\u0103 bucle merg p\u00e2n\u0103 la \\(\\min(sz[nod], k)\\), lucru ce \u00eembun\u0103t\u0103\u021be\u0219te timpul de execu\u021bie considerabil. Pute\u021bi citi mai multe din solu\u021bia problemei Barricades, iar sursa complet\u0103 o pute\u021bi vizualiza aici.</p>","tags":["arbori","structuri de date","siruri de caractere"]},{"location":"dificil/trie/#probleme-suplimentare","title":"Probleme suplimentare","text":"<ul> <li>intervalxor2 (Trie pe bi\u021bi persistent.   Pute\u021bi face queriurile \u0219i offline)</li> <li>xortree2 (Problem\u0103 ok cu trie pe bi\u021bi)</li> <li>rps (Alt exemplu de dp pe trie)</li> <li>ratina (Lowest Common Ancestor pe   trie)</li> <li>aiacupalindroame</li> <li>Facebook Search</li> <li>Perfect Security</li> <li>Collapsing Strings</li> </ul>","tags":["arbori","structuri de date","siruri de caractere"]},{"location":"dificil/trie/#resurse-suplimentare","title":"Resurse suplimentare","text":"<ul> <li>Trie (USACO Guide)</li> <li>Using a Trie -   Topcoder</li> </ul>","tags":["arbori","structuri de date","siruri de caractere"]},{"location":"dificil/z-function/","title":"Z Function","text":"<p>Daca vreti sa ne ajutati cu acest articol, ne puteti gasi pe github sau pe serverul nostru de discord</p> <p>Mai jos g\u0103si\u021bi resurse pe care le pute\u021bi citi p\u00e2n\u0103 atunci.</p>","tags":["implementare","siruri de caractere","optimizare"]},{"location":"dificil/z-function/#introducere","title":"Introducere","text":"","tags":["implementare","siruri de caractere","optimizare"]},{"location":"dificil/z-function/#problema-exemplu","title":"Problema exemplu","text":"","tags":["implementare","siruri de caractere","optimizare"]},{"location":"dificil/z-function/#concluzii","title":"Concluzii","text":"","tags":["implementare","siruri de caractere","optimizare"]},{"location":"dificil/z-function/#probleme-suplimentare","title":"Probleme suplimentare","text":"","tags":["implementare","siruri de caractere","optimizare"]},{"location":"dificil/z-function/#resurse-suplimentare","title":"Resurse suplimentare","text":"<ul> <li>Z function - CP-algorithms</li> <li>Z Algorithm - Codeforces</li> </ul>","tags":["implementare","siruri de caractere","optimizare"]},{"location":"mediu/","title":"Mediu","text":"<p>In aceasta categorie sunt toate de dificultate medie</p>"},{"location":"mediu/ad-hoc/","title":"Abordarea problemelor ad-hoc","text":"<p>Con\u021binutul articolului</p> <p>O bun\u0103 parte din con\u021binutul acestui articol este preluat din cursul creat de acela\u0219i autor pentru lotul de juniori din 2023, curs care se poate g\u0103si aici</p>","tags":["probleme","meta"]},{"location":"mediu/ad-hoc/#introducere","title":"Introducere","text":"<p>De-a lungul drumului vostru de p\u00e2n\u0103 acum spre ob\u021binerea rezultatelor care v-au adus aici, a\u021bi rezolvat foarte multe probleme de diverse tipuri \u0219i de diverse nivele de dificultate. Pentru o mare parte dintre ele, le putem clasifica dup\u0103 algoritmul sau tehnica folosit\u0103 pentru rezolvarea problemei, ceea ce face exersarea acestor probleme \u0219i \u00eensu\u0219irea cuno\u0219tin\u021belor necesare mai facil\u0103, prin faptul c\u0103 putem g\u0103si similitudini cu alte probleme rezolvate anterior, precum \u0219i datorit\u0103 faptului c\u0103 exist\u0103 numeroase resurse utile pentru \u00eenv\u0103\u021barea algoritmilor, metodelor de programare \u0219i structurilor de date necesare pentru implementarea acelor solu\u021bii.</p> <p>\u00cen schimb, exist\u0103 un anumit tip de probleme pe care nu le putem \u00eencadra sub umbrela unui algoritm sau a unei tehnici de programare, iar aceste probleme par a fi complet diferite una fa\u021b\u0103 de cealalt\u0103. Aceste probleme sunt cele ad-hoc \u0219i a\u0219a cum sugereaz\u0103 \u0219i numele, modul \u00een care g\u0103sim solu\u021biile la aceste probleme depinde \u00een totalitate de circumstan\u021bele care ni se dau de la problem\u0103 la problem\u0103. Cu toate acestea, de\u0219i problemele ad-hoc sunt \u00een teorie complet originale, putem s\u0103 ne folosim de c\u00e2teva principii care ne vor ajuta pentru a facilita g\u0103sirea unor solu\u021bii pentru aceste probleme</p> <p>Scopul pe care acest articol \u00eel are este acela de a prezenta viziunea mea asupra principiilor necesare pentru a g\u0103si idei, abord\u0103ri \u0219i solu\u021bii pentru problemele ad-hoc, precum \u0219i de a prezenta diverse probleme, aplic\u00e2nd aceste principii. De asemenea, un alt scop este acela de a unifica diversele resurse prezentate anterior pe diverse site-uri cu scopul de a extinde baza de informa\u021bii \u00een ceea ce prive\u0219te acest tip de probleme prea pu\u021bin discutat \u0219i analizat \u00eentr-o manier\u0103 mai sistematic\u0103.</p>","tags":["probleme","meta"]},{"location":"mediu/ad-hoc/#o-strategie-de-baza-pentru-abordarea-problemelor-ad-hoc","title":"O strategie de baz\u0103 pentru abordarea problemelor ad-hoc","text":"","tags":["probleme","meta"]},{"location":"mediu/ad-hoc/#tratarea-cazurilor-mici","title":"Tratarea cazurilor mici","text":"<p>Un prim pas spre a rezolva cu succes probleme ad-hoc este acela de a g\u0103si solu\u021bii pentru exemple mici, lucru ce se poate face fie cu ajutorul h\u00e2rtiei \u0219i a analizei manuale a acelor exemple, fie cu ajutorul unui program ce poate genera toate solu\u021biile posibile folosind un algoritm de tip brute force. De exemplu, pute\u021bi folosi un program brute force pentru a genera toate permut\u0103rile unui \u0219ir de \\(n\\) numere, toate submul\u021bimile mul\u021bimii \\({1, 2, ..., n}\\) \u0219i asa mai departe.</p> <pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n\nint main() {\n    int n cin &gt;&gt; n;\n\n    vector&lt;int&gt; v;\n\n    for (int i = 1; i &lt;= n; i++) {\n        v.push_back(i);\n    }\n\n    // generarea permutarilor multimii 1, 2, .., n\n\n    do {\n        // procesam permutarea\n    } while (next_permutation(v.begin(), v.end()));\n\n    // generarea submultimilor multimii 1, 2, .., n\n    // avem 2^n submultimi, fiecare dintre ele putand fi reprezentata folosind\n    // o masca pe biti\n\n    for (int i = 0; i &lt; (1 &lt;&lt; n); i++) {\n        vector&lt;int&gt; subset;\n        for (int j = 0; j &lt; n; j++) {\n            if (i &amp; (1 &lt;&lt; j)) {\n                subset.push_back(j);\n                // procesam acel numar ca parte a submultimii gasite\n            }\n        }\n    }\n    return 0;\n}\n</code></pre>","tags":["probleme","meta"]},{"location":"mediu/ad-hoc/#gasirea-unor-patternuri-sau-a-unor-relatii-intre-diverse-valori-din-input","title":"G\u0103sirea unor patternuri sau a unor rela\u021bii \u00eentre diverse valori din input","text":"<p>De multe ori, dup\u0103 ce gener\u0103m r\u0103spunsuri pentru valori mici folosind o metod\u0103 sau alta, putem s\u0103 observ\u0103m diferite rela\u021bii sau patternuri \u00een func\u021bie de r\u0103spunsurile pe care le ob\u021binem. De asemenea, ne putem folosi de anumite particularit\u0103\u021bi pe care anumite valori din restric\u021bii le au, lucruri ce se \u00eent\u00e2lnesc des \u00een problemele ad-hoc. \\newline</p> <p>Un exemplu concret este problema asort de la barajul de juniori din 2016.</p> <p>Observa\u021bie</p> <p>Solu\u021bia acestei probleme este explicat\u0103 \u00een arhiva noastr\u0103 aici</p>","tags":["probleme","meta"]},{"location":"mediu/ad-hoc/#folositi-va-de-diferite-restrictii-speciale-din-enunt-daca-apar-asemenea-restrictii","title":"Folosi\u021bi-v\u0103 de diferite restric\u021bii speciale din enun\u021b (dac\u0103 apar asemenea restric\u021bii)","text":"<p>De multe ori, pot ap\u0103rea anumite restric\u021bii care sunt foarte particulare raportat la problema \u00een sine. De obicei, o parte important\u0103 a solu\u021biei \u00een acest caz const\u0103 \u00een observarea rolului din spatele acestor restric\u021bii.</p> <p>De\u0219i acesta nu este un sfat util doar pentru problemele ad-hoc, de multe ori analizarea atent\u0103 a acestor p\u0103r\u021bi din problem\u0103 poate u\u0219ura rezolvarea problemei sau cel pu\u021bin a unor subprobleme care duc la solu\u021bia final\u0103 a problemelor.</p>","tags":["probleme","meta"]},{"location":"mediu/ad-hoc/#presupunerea-unor-solutii-rezonabile","title":"Presupunerea unor solu\u021bii rezonabile","text":"<p>Acest pas este unul ce depinde de la problem\u0103 la problem\u0103, dar de obicei e important s\u0103 \u00eencerc\u0103m s\u0103 reducem c\u00e2t se poate aspectele variabile din problem\u0103 (reducem intervalul posibil al solu\u021biei, ignor\u0103m informa\u021bii neimportante, trat\u0103m cazurile evidente etc.).</p>","tags":["probleme","meta"]},{"location":"mediu/ad-hoc/#convinge-te-singur-ca-solutia-gasita-anterior-este-corecta-sau-incorecta","title":"Convinge-te singur c\u0103 solu\u021bia g\u0103sit\u0103 anterior este corect\u0103 (sau incorect\u0103)","text":"<p>Acest ultim pas este de departe cel mai dificil deoarece de multe ori se poate \u00eent\u00e2mpla una din cele dou\u0103 situa\u021bii:</p> <ul> <li>solu\u021bia s\u0103 par\u0103 corect\u0103 dar s\u0103 apar\u0103 gre\u0219eli de idee \u0219i/sau submisii care   obtin 0 sau un scor foarte mic.</li> <li>solu\u021bia s\u0103 fie corect\u0103 dar s\u0103 fie foarte greu de g\u0103sit cel putin o intui\u021bie   dac\u0103 nu o demonstra\u021bie complet\u0103 a acesteia.</li> </ul> <p>Indiferent de caz, este important s\u0103 ne asigur\u0103m c\u0103 solu\u021bia ob\u021binut\u0103 nu ob\u021bine un r\u0103spuns gre\u0219it pe un caz evident, dar \u0219i s\u0103 \u00eencerc\u0103m pe c\u00e2t posibil s\u0103 trimitem solu\u021bia c\u00e2nd algoritmul \u0219i implementarea au sens.</p> <p>Aten\u021bie</p> <p>De\u0219i acesta este un sfat general, este foarte important s\u0103 evita\u021bi s\u0103 trimite\u021bi solu\u021bia imediat ce g\u0103si\u021bi un bug pe care l-a\u021bi rezolvat (cu excep\u021bia cazului c\u00e2nd concursul se apropie de final \u0219i orice secund\u0103 conteaz\u0103) - pe l\u00e2ng\u0103 faptul c\u0103 num\u0103rul de submisii este limitat, este de asemenea important s\u0103 reu\u0219iti s\u0103 rezolva\u021bi problema din mai pu\u021bine submisii, deoarece din experien\u021ba personal\u0103, ajut\u0103 \u00een ceea ce prive\u0219te \u00eencrederea pe care o c\u0103p\u0103ta\u021bi pentru celelalte probleme \u00een timpul concursului.</p>","tags":["probleme","meta"]},{"location":"mediu/ad-hoc/#problema-exemplu-pretty-permutations","title":"Problem\u0103 exemplu - Pretty Permutations","text":"<p>Putem \u00eencepe prin a g\u0103si diverse r\u0103spunsuri pentru valori mici ale lui \\(n\\).</p> <ul> <li>\\(n = 2\\) - [\\(2, 1\\)]</li> <li>\\(n = 3\\) - [\\(3, 1, 2\\)]</li> <li>\\(n = 4\\) - [\\(2, 1, 4, 3\\)]</li> <li>\\(n = 5\\) - [\\(3, 1, 2, 5, 4\\)]</li> </ul> <p>Se poate observa c\u0103 \u00een cazul acestei probleme, este \u00eendeajuns s\u0103 g\u0103sim c\u00e2teva solu\u021bii pentru valori mici ale lui \\(n\\) pentru a observa un pattern pentru valorile pare \u0219i impare ale lui \\(n\\). Astfel, pentru \\(n &gt; 3\\), putem pleca de la solu\u021bia pentru \\(n - 2\\) la care ad\u0103ug\u0103m perechea [\\(n, n-1\\)]. Aceast\u0103 solu\u021bie este una optim\u0103 deoarece fiecare element va fi situat la o distan\u021b\u0103 de 1 de pozi\u021bia lui, cu excep\u021bia lui 3 c\u00e2nd \\(n\\) e impar, care va fi situat la distan\u021ba 2.</p> <p>De\u0219i aceast\u0103 problem\u0103 este una relativ facil\u0103, procesul folosit pentru rezolvarea ei va fi reg\u0103sit \u00een multe alte probleme de acest gen \u00een viitor.</p>","tags":["probleme","meta"]},{"location":"mediu/ad-hoc/#problema-yinyang-oji-2019-clasa-a-x-a","title":"Problema Yinyang (OJI 2019, clasa a X-a)","text":"<p>La o prim\u0103 citire a enun\u021bului, putem observa faptul c\u0103 noi trebuie s\u0103 sort\u0103m matricea folosind un algoritm de interschimbare a dou\u0103 linii sau coloane consecutive. De aici, putem observa faptul c\u0103 putem s\u0103 verific\u0103m rezultatele pe care le-am ob\u021bine folosind un asemenea algoritm.</p> <p>Cei doi algoritmi de sortare care interschimb\u0103 valori adiacente la fiecare pas sunt bubble sort \u0219i insertion sort, deci putem verifica cei doi algoritmi \u0219i vedem care ar oferi rezultate mai optime. Dar oare este necesar?</p>","tags":["probleme","meta"]},{"location":"mediu/ad-hoc/#generalizarea-raspunsului-pe-o-matrice","title":"Generalizarea r\u0103spunsului pe o matrice","text":"<p>\u0218tim deja de la lucrul cu vectori c\u0103 num\u0103rul de inversiuni al unui vector este echivalent cu num\u0103rul de opera\u021bii de interschimbare pe care \u00eel face algoritmul bubble sort, ceea ce ne duce cu g\u00e2ndul la folosirea bubble sort pentru a calcula num\u0103rul minim de interschimb\u0103ri.</p> <p>De asemenea, deoarece atunci c\u00e2nd interschimb\u0103m dou\u0103 linii (sau coloane), valorile nu \u00ee\u0219i schimb\u0103 ordinea pe coloan\u0103 (sau pe linie), putem trata \u00een mod independent sortarea liniilor \u0219i a coloanelor pentru a ob\u021bine r\u0103spunsul.</p> <p>Dup\u0103 g\u0103sirea acestor observa\u021bii, putem s\u0103 sort\u0103m liniile, apoi coloanele folosind bubble sort, iar tot ceea ce avem de f\u0103cut apoi este s\u0103 verific\u0103m condi\u021biile din enun\u021b.</p>","tags":["probleme","meta"]},{"location":"mediu/ad-hoc/#problema-preparing-boxes-abc-134","title":"Problema Preparing Boxes (ABC 134)","text":"<p>Mai \u00eent\u00e2i, trebuie s\u0103 ne g\u00e2ndim la informa\u021biile pe care le putem afla mai u\u0219or cu privire la valorile din vectorul \\(b\\). De exemplu, \\(b[1] \\ \\% \\ 2\\) = \\((a[1] + a[2] + \\dots + a[n]) \\ \\% \\ 2\\). Totu\u0219i, \\(b[n] \\ \\% \\ 2\\) = \\(a[n] \\ \\% \\ 2\\).</p> <p>De asemenea, num\u0103rul total de valori pe care trebuie s\u0103 le verific\u0103m este \\(\\mathcal{O}(n \\log n)\\), o observa\u021bie ce este destul de clar\u0103 pentru oricine a implementat cel pu\u021bin o dat\u0103 ciurul lui Eratostene.</p> <p>Din aceste observa\u021bii, putem deduce faptul c\u0103 este optim s\u0103 fix\u0103m valorile din \\(b\\) de la dreapta la st\u00e2nga, iar parcurgerea lor folosind brute force este \u00eendeajuns de rapid\u0103.</p>","tags":["probleme","meta"]},{"location":"mediu/ad-hoc/#solutia-finala","title":"Solu\u021bia final\u0103","text":"<p>Din cele dou\u0103 observa\u021bii de mai sus, putem deduce un algoritm pentru implementarea solu\u021biei, care trece prin valori \u00een ordine descresc\u0103toare a pozi\u021biei, iar pentru fiecare valoare, putem s\u0103 determin\u0103m dac\u0103 va fi 0 sau 1 \u00een functie de restul \u00eemp\u0103r\u021birii la 2 al sumei valorilor relevante.</p> <p>Solu\u021bie care ia accepted</p>","tags":["probleme","meta"]},{"location":"mediu/ad-hoc/#problema-karte-coci-2018-runda-5","title":"Problema Karte (COCI 2018, runda 5)","text":"<p>Pentru multe probleme de acest gen, o sortare a datelor este foarte util\u0103 deoarece ne ajut\u0103 s\u0103 vedem lucrurile \u00eentr-o perspectiv\u0103 diferit\u0103. \u00cen cazul acestei probleme, e mai simplu s\u0103 presupunem c\u0103 valorile mai mici ne vor duce mai u\u0219or la r\u0103spunsul cerut, a\u0219a c\u0103 vom sorta datele mai \u00eent\u00e2i.</p> <p>Dup\u0103 ce grup\u0103m datele, vom crea o nou\u0103 list\u0103 \u00een care vom pune mai \u00eent\u00e2i cele mai mici \\(n - k\\) valori \u00een ordine descresc\u0103toare, iar mai apoi punem celelalte valori, tot \u00een ordine descresc\u0103toare.</p> <p>\u00cen cele din urm\u0103, tot ce trebuie s\u0103 mai facem este s\u0103 verific\u0103m dac\u0103 num\u0103rul de false ipoteze este exact \\(k\\), conform enun\u021bului.</p> <p>Solu\u021bie care ia punctaj maxim</p>","tags":["probleme","meta"]},{"location":"mediu/ad-hoc/#problema-game-ejoi-2017","title":"Problema Game (EJOI 2017)","text":"<p>\u00cen primul r\u00e2nd, este clar c\u0103 fiecare juc\u0103tor va vrea s\u0103 ia elementul cu valoarea maxim\u0103 la fiecare pas. Acest lucru ne duce la o solu\u021bie relativ u\u0219or de g\u0103sit care implic\u0103 un set (la fiecare pas lu\u0103m valoarea maxim\u0103 \u0219i eventual ad\u0103ug\u0103m valoarea nou\u0103 \u00een set). Complexitatea este \\(\\mathcal{O}(n * k * \\log n)\\), ceea ce ob\u021bine 50 de puncte. Cum putem \u00eembun\u0103t\u0103\u021bi aceast\u0103 solu\u021bie?</p>","tags":["probleme","meta"]},{"location":"mediu/ad-hoc/#observatii-suplimentare","title":"Observa\u021bii suplimentare","text":"<p>Deocamdat\u0103 nu am folosit \u00eenc\u0103 faptul c\u0103 valorile din input nu sunt foarte mari \u0219i putem s\u0103 folosim un vector de frecven\u021b\u0103 pentru a simula procesul. Totu\u0219i, acest lucru nu este \u00eendeajuns pentru a ob\u021bine punctajul maxim, deoarece nu am stabilit \u00eenc\u0103 ce facem cu elementele pe care le ad\u0103ug\u0103m pe parcurs.</p> <p>S\u0103 analiz\u0103m ce se \u00eent\u00e2mpl\u0103 la un pas al jocului. Dup\u0103 ce \u0219tim valoarea maxim\u0103 ini\u021bial\u0103, avem dou\u0103 cazuri \u00een ceea ce prive\u0219te noua valoare ad\u0103ugat\u0103.</p> <ul> <li>Fie e mai mare dec\u00e2t maximul curent, iar atunci juc\u0103torul aflat la mutare va   lua acea valoare.</li> <li>Altfel, acea valoare va fi ad\u0103ugat\u0103 \u00een vectorul de frecven\u021b\u0103, iar calculul va   continua ca de obicei.</li> </ul> <p>Astfel, complexitatea solu\u021biei va deveni \\(\\mathcal{O}(n \\cdot k)\\).</p>","tags":["probleme","meta"]},{"location":"mediu/ad-hoc/#alte-sfaturi-practice","title":"Alte sfaturi practice","text":"<ul> <li>Folosi\u021bi tot felul de idei \u0219i analiza\u021bi de ce sunt incorecte</li> <li>Ave\u021bi grij\u0103 la cazurile limit\u0103 \u0219i cazurile mici.</li> <li>Verifica\u021bi de dou\u0103 ori solu\u021biile la cazurile pe care le rezolva\u021bi manual sau   cu programul brute force</li> <li>Nu v\u0103 g\u00e2ndi\u021bi prea mult la diferite abord\u0103ri foarte sofisticate, deoarece de   multe ori aceste probleme au solu\u021bii mai simple dec\u00e2t par.</li> </ul>","tags":["probleme","meta"]},{"location":"mediu/ad-hoc/#concluzii","title":"Concluzii","text":"<p>\u00cen general, problemele ad-hoc (\u0219i nu numai) trebuie tratate plec\u00e2nd de la informa\u021biile pe care le avem, f\u0103r\u0103 s\u0103 for\u021b\u0103m folosirea anumitor tehnici sau algoritmi dec\u00e2t dac\u0103 avem certitudinea c\u0103 se pot face \u00eentr-un anume mod. Astfel, putem p\u0103stra o viziune deschis\u0103 asupra tehnicilor posibile pe care o problem\u0103 le poate impune, iar sfaturile pe care le-am adresat aici fac \u0219i rezolvarea celor mai atipice probleme posibil\u0103, antrenamentul fiind cu at\u00e2t mai esen\u021bial pentru aceast\u0103 clas\u0103 de probleme.</p>","tags":["probleme","meta"]},{"location":"mediu/ad-hoc/#probleme-suplimentare","title":"Probleme suplimentare","text":"<ul> <li>OJI 2019 traseu</li> <li>infoarena palind</li> <li>COCI 2018 karte</li> <li>ONI 2008 aranjare</li> <li>CF 1815A</li> <li>CF 1797C </li> <li>CF 1815B</li> <li>Baraj juniori 2016 asort</li> <li>IOI 2010 quality</li> <li>COCI 2013 organizator</li> <li>CF 1332B</li> <li>ABC134 D</li> <li>CF 1804B</li> <li>ARC158 A</li> <li>ARC153 B</li> <li>ARC145 B</li> <li>CF 1407C</li> <li>CF 1776F</li> <li>ARC118 C</li> <li>CF 1776G</li> <li>ARC159 C</li> <li>CF 1736D</li> <li>Probleme ad-hoc de pe kilonova</li> </ul>","tags":["probleme","meta"]},{"location":"mediu/ad-hoc/#resurse-suplimentare","title":"Resurse suplimentare","text":"<ul> <li>Problemele ad-hoc - USACO Guide</li> <li>Abordarea problemelor ad-hoc (2021) -   SEPI</li> <li>Abordarea problemelor ad-hoc (2023) -   SEPI</li> <li>Probleme constructive si interactive -   HKOI</li> <li>How to get started with solving Ad-Hoc tasks on codeforces -   Codeforces</li> <li>Tips on Constructive Algorithms -   Codeforces</li> <li>Good ad-hoc problems - Codeforces</li> <li>How to prove your solutions in Competitive Programming -   Codeforces</li> <li>How to come up with solutions? -   Codeforces</li> <li>On \"is this greedy or DP\", forcing and rubber bands -   Codeforces</li> </ul>","tags":["probleme","meta"]},{"location":"mediu/amortised-analysis/","title":"Analiza amortizat\u0103","text":"","tags":["optimizare","coada","stiva"]},{"location":"mediu/amortised-analysis/#ce-este-analiza-amortizata","title":"Ce este analiza amortizat\u0103?","text":"<p>\u00cen algoritmic\u0103, se \u00eent\u00e2mpl\u0103 de foarte multe ori s\u0103 g\u0103sim algoritmi pentru diverse aplica\u021bii care de\u0219i la prima vedere par foarte \u00eence\u021bi, dup\u0103 ce \u00eei analiz\u0103m \u00een detaliu, constat\u0103m faptul c\u0103 \u00een practic\u0103 se comport\u0103 foarte bine \u0219i \u00een multe cazuri, putem chiar demonstra complexitatea rapid\u0103 pe care ace\u0219tia o au.</p> <p>Aceast\u0103 metod\u0103 de a analiza complexitatea unui algoritm pentru care timpul de execu\u021bie nu este evident se nume\u0219te analiz\u0103 amortizat\u0103 \u0219i este foarte util\u0103 \u00een majoritatea algoritmilor mai complec\u0219i.</p> <p>Cum func\u021bioneaz\u0103 analiza amortizat\u0103?</p> <p>\u00cen analiza amortizat\u0103, facem media timpului necesar pentru a executa o secven\u021b\u0103 de opera\u021bii, \u00eemp\u0103r\u021bind acest timp la num\u0103rul opera\u021biilor executate. Prin analiza amortizat\u0103 putem s\u0103 ar\u0103t\u0103m c\u0103 costul mediu al unei opera\u021bii este mic, atunci c\u00e2nd \u00eemp\u0103r\u021bim la num\u0103rul de opera\u021bii, cu toate c\u0103 o singur\u0103 opera\u021bie din secven\u021b\u0103 ar putea fi \"scump\u0103\". Acest cost mediu per opera\u021bie se mai nume\u0219te \u0219i costul amortizat.</p>","tags":["optimizare","coada","stiva"]},{"location":"mediu/amortised-analysis/#exemple","title":"Exemple","text":"","tags":["optimizare","coada","stiva"]},{"location":"mediu/amortised-analysis/#incrementarea-unui-contor-binar","title":"Incrementarea unui contor binar","text":"<p>Dac\u0103 vrem s\u0103 p\u0103str\u0103m un contor binar de lungime \\(n\\), pentru a aduna un 1 la o valoare, se poate \u00eent\u00e2mpla s\u0103 schimb\u0103m valoarea tuturor bi\u021bilor din \u0219irul pe care \u00eel aveam (cel mult \\(n\\)), deci s-ar putea spune c\u0103 complexitatea unei asemenea opera\u021bii este \\(\\mathcal{O}(n)\\).</p> <p>Totu\u0219i, dac\u0103 analiz\u0103m mai \u00een detaliu ce se \u00eent\u00e2mpl\u0103, observ\u0103m c\u0103 de\u0219i bi\u021bii de pe pozi\u021biile mai nesemnificative \u00ee\u0219i schimb\u0103 valoarea des, bi\u021bii mai semnificativi \u00ee\u0219i schimb\u0103 pozi\u021bia mult mai rar. Cu alte cuvinte, un bit de pe pozi\u021bia \\(i\\) \u00ee\u0219i schimb\u0103 valoarea odat\u0103 la \\(2^i\\) increment\u0103ri, iar opera\u021bia de transport apare odat\u0103 la \\(2^{i+1}\\) increment\u0103ri.</p> <p>Astfel, dac\u0103 avem un num\u0103r de increment\u0103ri fix (s\u0103 presupunem c\u0103 acesta este \\(x\\)), num\u0103rul de schimb\u0103ri care se face este \\(\\frac{x}{2^0} + \\frac{x}{2^1} + \\dots + \\frac{x}{2^n}\\), unde \\(n\\) este lungimea maxim\u0103 a acestui num\u0103r. Cu alte cuvinte, aceast\u0103 sum\u0103 este de fapt aproximativ egal\u0103 cu \\(2 \\cdot x\\), iar complexitatea real\u0103 a acestei increment\u0103ri este \\(\\mathcal{O}(1)\\).</p>","tags":["optimizare","coada","stiva"]},{"location":"mediu/amortised-analysis/#ciurul-lui-eratostene","title":"Ciurul lui Eratostene","text":"<p>De\u0219i am vorbit \u00een detaliu de acest algoritm \u0219i \u00een articolul s\u0103u specific, nu am discutat foarte mult complexitatea sa.</p> <pre><code>int prim[100001];\nfor (int i = 2; i &lt;= n; i++) {\n    if (prim[i] == 0) {\n        for (int j = i + i; j &lt;= n; j += i) {\n            prim[j] = 1;\n        }\n    }\n}\n</code></pre> <p>La prima vedere, ne-am putea g\u00e2ndi c\u0103 complexitatea acestui algoritm ar fi \\(\\mathcal{O}(n^2)\\), deoarece avem dou\u0103 foruri \u0219i cel de-al doilea for merge de asemenea de la \\(i\\) la \\(n\\).</p> <p>Totu\u0219i, pasul din cel de-al doilea for este de \\(i\\), deci trebuie s\u0103 analiz\u0103m c\u00e2\u021bi pa\u0219i facem de fapt pentru un \\(n\\) fixat.</p> <ul> <li>\\(\\frac{n}{2} + \\frac{n}{3} + \\frac{n}{5} + \\dots\\), sum\u0103 care converge la \\(\\mathcal{O}(n   \\log \\log n)\\), datorit\u0103 propriet\u0103\u021bilor sumelor armonice. Se poate observa \u0219i   c\u00e2nd programul este rulat c\u0103 viteza lui de execu\u021bie este foarte bun\u0103 \u00een   practic\u0103.</li> </ul>","tags":["optimizare","coada","stiva"]},{"location":"mediu/amortised-analysis/#operatiile-specifice-stivei","title":"Opera\u021biile specifice stivei","text":"<p>A\u0219a cum s-a observat \u00een articolul nostru despre stiv\u0103, la un moment dat, putem scoate un num\u0103r mare de valori, \u00een special dac\u0103 valoarea pe care o ad\u0103ug\u0103m este cea mai mare sau cea mai mic\u0103 de p\u00e2n\u0103 acum.</p> <p>Totu\u0219i, deoarece pentru fiecare valoare putem s\u0103 ad\u0103ug\u0103m \u0219i s\u0103 o scoatem cel mult o singur\u0103 dat\u0103, num\u0103rul total de opera\u021bii va fi \\(2 \\cdot n\\), iar complexitatea algoritmului devine \\(\\mathcal{O}(n)\\).</p>","tags":["optimizare","coada","stiva"]},{"location":"mediu/amortised-analysis/#hash-table","title":"Hash table","text":"<p>\u00cen unele probleme de algoritmic\u0103, suntem for\u021ba\u021bi s\u0103 p\u0103str\u0103m valorile conform unei codific\u0103ri de tip hash, pentru a reduce complexitatea total\u0103. De\u0219i \u00een teorie, se poate \u00eent\u00e2mpla ca toate valorile s\u0103 fie egale \u0219i complexitatea s\u0103 devin\u0103 liniar\u0103, \u00een practic\u0103, valorile vor fi distribuite relativ normal \u0219i complexitatea pentru opera\u021bii precum g\u0103sirea valorilor devine constant\u0103.</p>","tags":["optimizare","coada","stiva"]},{"location":"mediu/amortised-analysis/#paduri-de-multimi-disjuncte","title":"P\u0103duri de mul\u021bimi disjuncte","text":"<p>De\u0219i intr\u0103m mai mult \u00een detalii aici, se poate demonstra cu u\u0219urin\u021b\u0103 faptul c\u0103 complexitatea total\u0103 a opera\u021biilor, dac\u0103 aplic\u0103m optimiz\u0103rile descrise acolo devine \\(\\mathcal{O}(n \\log^{*} n)\\), chiar dac\u0103 opera\u021biile individuale sunt de ordin liniar.</p>","tags":["optimizare","coada","stiva"]},{"location":"mediu/amortised-analysis/#concluzii","title":"Concluzii","text":"<p>Analiza amortizat\u0103 este o metod\u0103 folosit\u0103 pentru foarte multe tipuri de algoritmi pentru a demonstra complexitatea acestora, atunci c\u00e2nd lucrurile nu sunt evidente. De asemenea, aceast\u0103 metod\u0103 se aplic\u0103 \u0219i pentru anumite p\u0103r\u021bi din probleme care de\u0219i \u00een teorie par \u00eencete, complexitatea lor practic\u0103 este una mai rapid\u0103.</p>","tags":["optimizare","coada","stiva"]},{"location":"mediu/amortised-analysis/#probleme-suplimentare","title":"Probleme suplimentare","text":"<ul> <li>Probleme care implica analiza amortizata -   nerdarena</li> </ul>","tags":["optimizare","coada","stiva"]},{"location":"mediu/amortised-analysis/#resurse-suplimentare","title":"Resurse suplimentare","text":"<ul> <li>Un video despre analiza amortizat\u0103, v\u0103 va ajuta s\u0103 \u00een\u021belege\u021bi mai bine   rezolvarea problemei stack_max_min \u0219i de ce are complexitatea   \\(\\mathcal{O}(N)\\)</li> <li>Analiza amortizata -   Algopedia</li> <li>Amortized analysis -   Wikipedia</li> <li>Analiza amortizata - Utilizarea unei   stive</li> <li>Amortized analysis -   CLRS</li> <li>Amortized Complexity and Rollbacks -   Codeforces</li> <li>Amortized analysis - Carnegie Mellon   University</li> </ul>","tags":["optimizare","coada","stiva"]},{"location":"mediu/apcm/","title":"Arbore par\u021bial de cost minim","text":"<p>\u00cen diverse probleme de grafuri, suntem nevoi\u021bi s\u0103 alegem o mul\u021bime de muchii care formeaz\u0103 un graf conex, iar costul s\u0103 fie c\u00e2t mai mic. \u00cen cele mai multe cazuri, va fi \u00eendeajuns s\u0103 cre\u0103m un arbore par\u021bial, iar acesta s\u0103 fie de cost minim, concept ce va fi subiectul acestui articol.</p>","tags":["grafuri","greedy","arbori","sortare"]},{"location":"mediu/apcm/#introducere","title":"Introducere","text":"<p>Defini\u021bie</p> <p>Arborele par\u021bial de cost minim (APCM) un graf par\u021bial conex cu proprietatea c\u0103 suma costurilor muchiilor este minim\u0103 \u0219i graful este un arbore (deci, are \\(n-1\\) muchii).</p> <p>Observa\u021bie</p> <p>Un graf poate avea mai mul\u021bi arbori par\u021biali de cost minim, dar \u00een aproape toate problemele, precum \u0219i \u00een practic\u0103, nu conteaz\u0103 cu ce arbore lucr\u0103m, at\u00e2ta timp c\u00e2t suma costurilor muchiilor este minim\u0103.</p> <p>Exemplu</p> <p>De exemplu, dac\u0103 avem urm\u0103torul graf: \\(n = 5\\), \\(m = 6\\) \u0219i urm\u0103toarele muchii de tip \\((a, b, cost)\\): \\((1, 2, 3)\\), $ (2, 3, 5)$, $ (2, 4, 2)$, $ (3, 4, 8)$, $ (5, 1, 7)$, $ (5, 4, 4)$, arborele par\u021bial de cost minim va avea costul 14, aleg\u00e2ndu-se primele trei muchii \u0219i ultima.</p> <p>Pentru a afla APM-ul, exist\u0103 mai mul\u021bi algoritmi, dar cei mai folosi\u021bi algoritmi sunt algoritmul lui Kruskal \u0219i algoritmul lui Prim. Exist\u0103 \u0219i al\u021bi algoritmi mai pu\u021bin cunoscu\u021bi, precum algoritmul lui Boruvka. Acest articol va acoperi cei trei algoritmi men\u021biona\u021bi.</p> <p>\u00cen probleme, de cele mai multe ori vom putea aplica algoritmul ales f\u0103r\u0103 prea multe modific\u0103ri, dar g\u0103sirea unui graf pe care s\u0103 aplic\u0103m APM se va dovedi a fi o alegere mai dificil\u0103.</p>","tags":["grafuri","greedy","arbori","sortare"]},{"location":"mediu/apcm/#algoritmul-lui-kruskal","title":"Algoritmul lui Kruskal","text":"<p>Defini\u021bie</p> <p>Algoritmul lui Kruskal este un algoritm de tip greedy care va prelucra muchiile \u00een ordine cresc\u0103toare a costurilor acestora, iar pentru fiecare dintre muchii, va verifica dac\u0103 ad\u0103ugarea ei \u00een graful par\u021bial va genera un ciclu sau nu. Pentru verificarea rapid\u0103 a ciclurilor \u00een graf, vom folosi o structur\u0103 de tip Union-Find, iar sortarea se poate face cu u\u0219urin\u021b\u0103 p\u0103str\u00e2nd muchiile \u00eentr-o structur\u0103 potrivit\u0103.</p> <p>Observa\u021bie</p> <p>Dac\u0103 sunt mai multe muchii cu cost egal, nu are importan\u021b\u0103 care este aleas\u0103, rezultatul fiind identic.</p> <p>Un lucru care se poate remarca este faptul c\u0103 acest algoritm este centrat \u00een jurul muchiilor, opera\u021biile f\u0103cute cu acestea fiind esen\u021biale pentru algoritmul nostru (sortarea lor, urmat\u0103 de verificarea individual\u0103). Deoarece sortarea muchiilor este de departe cea mai costisitoare parte a algoritmului, complexitatea final\u0103 a algoritmului va fi \\(\\mathcal{O}(m \\log m)\\).</p> <p>Aici pute\u021bi g\u0103si o implementare \u00een limbajul C++ a algoritmului lui Kruskal.</p> <pre><code>#include &lt;algorithm&gt;\n#include &lt;iostream&gt;\n#include &lt;vector&gt;\n\nusing namespace std;\n\n/* Procesarea muchiilor */\nstruct edges {\n    int a, b, c;\n};\nedges v[200001];\n\nbool cmp(edges a, edges b) { return a.c &lt; b.c; }\n\n/* Clasa pentru paduri de multimi disjuncte */\nclass dsu {\nprivate:\n    int n;\n    vector&lt;int&gt; parent, card;\n\npublic:\n    void init(int sz) {\n        n = sz;\n        parent.resize(n + 1);\n        card.resize(n + 1);\n        for (int i = 1; i &lt;= n; i++) {\n            parent[i] = i;\n            card[i] = 1;\n        }\n    }\n    int Find(int x) {\n        if (parent[x] == x) {\n            return x;\n        }\n        return parent[x] = Find(parent[x]);\n    }\n    void Union(int a, int b) {\n        a = Find(a);\n        b = Find(b);\n        if (a == b) {\n            return;\n        }\n        if (card[b] &gt; card[a]) {\n            swap(a, b);\n        }\n        parent[b] = a;\n        card[a] += card[b];\n    }\n};\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n\n    int n, m;\n    cin &gt;&gt; n &gt;&gt; m;\n\n    for (int i = 0; i &lt; m; i++) {\n        cin &gt;&gt; v[i].a &gt;&gt; v[i].b &gt;&gt; v[i].c;\n    }\n    sort(v, v + m, cmp);\n\n    dsu links;\n    links.init(n);\n\n    long long cost = 0;\n    int mch = 0;\n    for (int i = 0; i &lt; m; i++) {\n        if (links.Find(v[i].a) != links.Find(v[i].b)) {\n            cost += v[i].c;\n            mch++;\n            links.Union(v[i].a, v[i].b);\n        }\n    }\n\n    if (mch == n - 1) {\n        cout &lt;&lt; cost &lt;&lt; '\\n';\n    } else {\n        cout &lt;&lt; \"IMPOSSIBLE\\n\";\n    }\n    return 0;\n}\n</code></pre>","tags":["grafuri","greedy","arbori","sortare"]},{"location":"mediu/apcm/#algoritmul-lui-prim","title":"Algoritmul lui Prim","text":"<p>Defini\u021bie</p> <p>Algoritmul lui Prim este un algoritm de tip greedy care va prelucra nodurile \u00een ordine cresc\u0103toare a costurilor de a fi conectate, plec\u00e2nd de la un nod oarecare, iar pentru fiecare dintre noduri, va verifica dac\u0103 ad\u0103ugarea muchiilor vecine cu acel nod \u00een graful par\u021bial va rezulta \u00een mic\u0219orarea unor costuri sau nu. Pentru verificarea rapid\u0103 a \u00eembun\u0103t\u0103\u021birilor pe care le ob\u021binem \u00een privin\u021ba costurilor, vom folosi o implementare similar\u0103 cu cea de la algoritmul lui Dijkstra.</p> <p>Observa\u021bie</p> <p>Dac\u0103 sunt mai multe noduri cu cost egal, nu are importan\u021b\u0103 care este aleas\u0102, rezultatul fiind identic.</p> <p>Un lucru care se poate remarca este faptul c\u0103 acest algoritm este centrat \u00een jurul nodurilor, opera\u021biile f\u0103cute cu acestea fiind esen\u021biale pentru algoritmul nostru (procesarea lor, urmat\u0103 de verificarea muchiilor adiacente fiec\u0103rui nod). Deoarece algoritmul este similar \u00een stil cu algoritmul lui Dijkstra, complexitatea final\u0103 va fi aceea\u0219i cu cea de la Dijkstra, \\(\\mathcal{O}((n+m) \\log n)\\)</p> <p>Aici pute\u021bi g\u0103si o implementare \u00een limbajul C++ a algoritmului lui Prim.</p> <pre><code>#include &lt;iostream&gt;\n#include &lt;set&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\nint main() {\n    int n, m;\n    cin &gt;&gt; n &gt;&gt; m;\n\n    vector&lt;vector&lt;pair&lt;int, int&gt; &gt; &gt; graph(n + 1);\n    for (int i = 1; i &lt;= m; i++) {\n        int a, b, c;\n        cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;\n        graph[a].push_back({b, c});\n        graph[b].push_back({a, c});\n    }\n\n    /* Implementare similara cu cea de la Dijkstra */\n    vector&lt;int&gt; cost(n + 1, (1 &lt;&lt; 30));\n    cost[1] = 0;\n    set&lt;pair&lt;int, int&gt; &gt; s;\n    s.insert({0, 1});\n\n    long long MST = 0;\n    int added = 0;\n    while (!s.empty()) {\n        pair&lt;int, int&gt; smallest = *s.begin();\n        s.erase(smallest);\n\n        MST += smallest.first;\n        cost[smallest.second] = 0;\n        added++;\n        for (int i = 0; i &lt; (int)graph[smallest.second].size(); i++) {\n            int nxt = graph[smallest.second][i].first;\n            int val = graph[smallest.second][i].second;\n\n            if (val &lt; cost[nxt]) {\n                if (s.find({cost[nxt], nxt}) != s.end()) {\n                    s.erase({cost[nxt], nxt});\n                }\n                cost[nxt] = val;\n                s.insert({cost[nxt], nxt});\n            }\n        }\n    }\n\n    if (added == n) {\n        cout &lt;&lt; MST &lt;&lt; '\\n';\n    } else {\n        cout &lt;&lt; \"IMPOSSIBLE\" &lt;&lt; '\\n';\n    }\n    return 0;\n}\n</code></pre>","tags":["grafuri","greedy","arbori","sortare"]},{"location":"mediu/apcm/#algoritmul-lui-boruvka","title":"Algoritmul lui Boruvka","text":"<p>Defini\u021bie</p> <p>Acest algoritm \u00eencepe cu fiecare nod fiind \u00eentr-o component\u0103 conex\u0103 doar cu el \u00eensu\u0219i. Apoi, va face itera\u021bii prin graf, p\u00e2n\u0103 c\u00e2nd nu este arbore (adic\u0103 c\u00e2t timp mai sunt cel pu\u021bin dou\u0103 componente conexe). El va g\u0103si pentru fiecare component\u0103 conex\u0103 (sau pentru fiecare nod, depinz\u00e2nd de problem\u0103) cea mai bun\u0103 muchie nefolosit\u0103 (de obicei, cea cu costul minim) care o (\u00eel) une\u0219te de alt\u0103 component\u0103 conex\u0103. Dup\u0103 ce aceste muchii sunt g\u0103site, ele sunt folosite. Vom folosi \u0219i la acest algoritm structura Union-Find pentru a afla dac\u0103 muchiile duc la componente conexe diferite \u0219i pentru a uni dou\u0103 componente conexe.</p> <p>Observa\u021bie</p> <p>La fiecare iterare prin graf, num\u0103rul de componente conexe se \u00eenjum\u0103t\u0103\u021be\u0219te. La \u00eenceput sunt \\(n - 1\\) componente conexe, deci se vor face \\(\\mathcal{O}(\\log n)\\) itera\u021bii. Astfel, complexitatea algoritmului este \\(\\mathcal{O}(m \\log n)\\), unde \\(m\\) este num\u0103rul de muchii, iar \\(n\\) este num\u0103rul de noduri.</p> <p>Observa\u021bie</p> <p>Uneori, nu este posibil s\u0103 construim un APM, dar trebuie s\u0103 raport\u0103m c\u0103 nu se poate. Vom face acest lucru printr-o metod\u0103 similar\u0103 cu cea de la Bubble Sort: vom men\u021bine o variabil\u0103 care s\u0103 ne spun\u0103 dac\u0103 am reu\u0219it s\u0103 unim vreo pereche de componente conexe. Dac\u0103 p\u00e2n\u0103 acum nu am ob\u021binut un arbore \u0219i nu mai avem cum s\u0103 folosim vreo muchie, atunci putem s\u0103 declar\u0103m c\u0103 nu se poate ob\u021bine un APM.</p> <p>Aici pute\u021bi g\u0103si o implementare \u00een C++ a algoritmului lui Boruvka:</p> <pre><code>#include &lt;iostream&gt;\n\nconst int MAXN = 200'000;\nconst int MAXM = 400'000;\n\nint n, m, minedge[MAXN], foundEdge;\nlong long rez;\nchar viz[MAXM];\n\nstruct Edge {\n    int u, v, cost;\n} edges[MAXM];\n\nstruct DSU {\n    int sef[MAXN], cate_comp;\n\n    void init(int n) {\n        int i;\n        cate_comp = n;\n        for (i = 0; i &lt; n; i++) {\n            sef[i] = i;\n        }\n    }\n\n    int find(int i) {\n        if (i == sef[i]) {\n            return i;\n        }\n        return sef[i] = find(sef[i]);\n    }\n\n    void join(int i, int j) {\n        if ((i = find(i)) != (j = find(j))) {\n            cate_comp--;\n            sef[j] = i;\n        }\n    }\n} dsu;\n\nvoid fastReadWrite() {\n    std::ios_base::sync_with_stdio(false) : std::cin.tie(nullptr);\n    std::cout.tie(nullptr);\n}\n\nvoid readGraph() {\n    int i;\n    std::cin &gt;&gt; n &gt;&gt; m;\n    for (i = 0; i &lt; m; i++) {\n        std::cin &gt;&gt; edges[i].u &gt;&gt; edges[i].v &gt;&gt; edges[i].cost;\n        edges[i].u--;\n        edges[i].v--;\n    }\n}\n\nvoid resetComps() {\n    int i;\n    for (i = 0; i &lt; n; i++) {\n        minedge[i] = -1;\n    }\n}\n\n// este muchia a mai buna ca muchia b?\nint better(int a, int b) {\n    if (b == -1) {\n        return 1;\n    }\n    return edges[a].cost &lt; edges[b].cost;\n}\n\nvoid processEdges() {\n    int i, u, v;\n    for (i = 0; i &lt; m; i++) {\n        if (viz[i] == 0) {  // daca n-am folosit muchia deja\n            u = dsu.find(edges[i].u);\n            v = dsu.find(edges[i].v);\n            if (u != v) {                     // sa nu fie in aceeasi componenta\n                if (better(i, minedge[u])) {  // cautam cea mai buna muchie\n                                              // pentru fiecare componenta\n                    minedge[u] = i;\n                }\n                if (better(i, minedge[v])) {\n                    minedge[v] = i;\n                }\n            }\n        }\n    }\n}\n\nvoid processComps() {\n    int i, u, v;\n    for (i = 0; i &lt; n; i++) {  // trecem prin fiecare componenta\n        if (minedge[i]\n                != -1  // daca am gasit o muchie pentru componenta in care i e\n                       // parinte daca i nu e parintele unei componente atunci\n                       // nu o sa fie gasita nicio muchie\n            &amp;&amp; viz[minedge[i]] == 0) {  // sa nu o fi folosit pentru componenta\n                                        // cu care ne unim deja\n            dsu.join(edges[minedge[i]].u,\n                     edges[minedge[i]].v);  // unim componentele\n            rez += edges[minedge[i]].cost;  // adunam costul\n            viz[minedge[i]] = 1;            // am folosit muchia\n            foundEdge = 1;\n        }\n    }\n}\n\nvoid findMST() {\n    int i, u, v;\n\n    dsu.init(n);\n    rez = 0;\n    foundEdge = 1;\n    while (dsu.cate_comp &gt; 1\n           &amp;&amp; foundEdge) {  // cat timp nu e arbore si mai putem face ceva\n        foundEdge = 0;\n        resetComps();    // resetam componentele\n        processEdges();  // trecem prin fiecare muchie\n        processComps();  // unim fiecare componenta cu muchia ei cea mai buna\n    }\n    if (dsu.cate_comp &gt; 1) {\n        std::cout &lt;&lt; \"IMPOSSIBLE\\n\";\n    } else {\n        std::cout &lt;&lt; rez &lt;&lt; \"\\n\";\n    }\n}\n\nint main() {\n    fastReadWrite();\n    readGraph();\n    findMST();\n    return 0;\n}\n</code></pre>","tags":["grafuri","greedy","arbori","sortare"]},{"location":"mediu/apcm/#care-este-algoritmul-mai-bun","title":"Care este algoritmul mai bun?","text":"<p>Algoritmul lui Boruvka poate fi folosit \u0219i atunci c\u00e2nd avem prea multe muchii ca s\u0103 le putem procesa pe toate, dar putem afla pentru fiecare nod cea mai bun\u0103 muchie folositoare. Un exemplu de astfel de problem\u0103 este problema CF 888G.</p> <p>C\u00e2nd vorbim despre algoritmii lui Kruskal, respectiv al lui Prim, niciunul dintre ei nu este mai bun mereu dec\u00e2t cel\u0103lalt. Pe de o parte, Kruskal se dovede\u0219te a fi mult mai bun atunci c\u00e2nd este vorba de grafuri rare, cu \\(M \\approx N\\), deoarece constanta de la sortare este mult mai bun\u0103 dec\u00e2t cea de la seturi. Totu\u0219i, dac\u0103 graful este foarte dens, algoritmul lui Prim este superior, iar \u00een cazul unor grafuri complete, de multe ori este mai bine s\u0103 implement\u0103m varianta sa \u00een \\(\\mathcal{O}(n^2)\\), similar\u0103 cu cea prezentat\u0103 la Dijkstra, pentru a rezolva probleme precum cablaj.</p> <p>\u00cen condi\u021bii de concurs, dac\u0103 to\u021bi algoritmii vor intra \u00een limita de timp, Kruskal este mult mai u\u0219or de scris \u0219i mai practic, dar cunoa\u0219terea algoritmului lui Prim este foarte util\u0103, mai ales dat fiind factorul de similaritate cu Dijkstra. De asemenea, algoritmul lui Boruvka este \u0219i el foarte important.</p>","tags":["grafuri","greedy","arbori","sortare"]},{"location":"mediu/apcm/#probleme-suplimentare","title":"Probleme suplimentare","text":"<ul> <li>Road Reparation</li> <li>USACO Gold Fenced   In</li> <li>USACO Gold Moo   Network</li> <li>infoarena cablaj</li> <li>OJI 2017 Ninjago</li> <li>Codeforces Microcycle</li> <li>infoarena desen</li> <li>ONI 2018 Poligon</li> <li>ONI 2019 Oracol</li> <li>Codeforces Opening Portals</li> <li>Codeforces XOR-MST</li> <li>USACO Gold Moo   Network</li> <li>Problemele cu APM de pe kilonova</li> <li>Probleme educa\u021bionale cu APM</li> <li>Minimum spanning tree for each   edge</li> </ul>","tags":["grafuri","greedy","arbori","sortare"]},{"location":"mediu/apcm/#lectura-suplimentara","title":"Lectur\u0103 suplimentar\u0103","text":"<ul> <li>Minimum Spanning Tree - USACO Guide</li> <li>Minimum spanning tree - Prim's   algorithm</li> <li>Minimum spanning tree - Kruskal with Disjoint Set   Union</li> <li>Arbore partial de cost minim - CPPI   Sync</li> <li>Minimum Spanning Tree Problems</li> <li>Boruvka's Algorithm</li> <li>Avansat - Second Best Minimum Spanning   Tree</li> </ul>","tags":["grafuri","greedy","arbori","sortare"]},{"location":"mediu/backtracking/","title":"C\u0103utare complet\u0103. Tehnica Backtracking","text":"","tags":["brute force","implementare","recursivitate","cautare completa"]},{"location":"mediu/backtracking/#introducere","title":"Introducere","text":"<p>Tehnica backtracking este o tehnic\u0103 folosit\u0103 \u00een problemele \u00een care trebuie s\u0103 gener\u0103m toate solu\u021biile posibile \u0219i eventual s\u0103 verific\u0103m pentru fiecare dintre ele dac\u0103 respect\u0103 una sau mai multe condi\u021bii.</p> <p>Aceast\u0103 tehnic\u0103 ne va garanta mereu ob\u021binerea unei solu\u021bii optime, dar din p\u0103cate, rezolv\u0103rile care folosesc aceast\u0103 tehnic\u0103 tind s\u0103 fie foarte lente, aceast\u0103 metod\u0103 fiind o strategie viabil\u0103 doar atunci c\u00e2nd datele de intrare \u0219i restric\u021biile sunt foarte mici (de regul\u0103, \\(n \\leq 10\\) pentru permut\u0103ri, \\(n \\leq 20\\) pentru submul\u021bimi \u0219i doar \u00een cazuri foarte rare \u0219i cu multe optimiz\u0103ri, \\(n\\) poate fi cel mult \\(30-40\\)).</p> <p>\u00cen general, vom folosi recursivitatea pentru a ne genera solu\u021biile, iar pentru a le genera, vom pleca de la o solu\u021bie vid\u0103, c\u0103reia \u00eei vom ad\u0103uga la un anumit pas toate variantele posibile de a continua, evident \u021bin\u00e2nd cont de restric\u021biile problemei. Mai jos vom prezenta ni\u0219te exemple.</p>","tags":["brute force","implementare","recursivitate","cautare completa"]},{"location":"mediu/backtracking/#problema-exemplu-generarea-permutarilor","title":"Problema exemplu - generarea permut\u0103rilor","text":"<p>Pentru a rezolva aceast\u0103 problem\u0103, vom avea o func\u021bie recursiv\u0103 care va avea drept parametru pozi\u021bia la care suntem \u00een permutarea pe care o gener\u0103m, iar mai apoi vom avea dou\u0103 cazuri distincte:</p> <ol> <li>Suntem la finalul permut\u0103rii: \u00een acest caz, vom afi\u0219a permutarea generat\u0103.</li> <li>Nu suntem la finalul permut\u0103rii: \u00een acest caz, vom \u00eencerca s\u0103 ad\u0103ug\u0103m fiecare    valoare de la 1 la \\(n\\) pe urm\u0103toarea pozi\u021bie a permut\u0103rii. Pentru a putea    face asta, va trebui s\u0103 parcurgem \u0219irul de numere ob\u021binut p\u00e2n\u0103 acum pentru a    evita plasarea aceleia\u0219i valori de dou\u0103 ori (o permutare nu are dubluri).</li> </ol> <p>Observa\u021bie</p> <p>Procesul descris la punctul 2 poate fi optimizat prin p\u0103strarea \u00een memorie a unui alt \u0219ir, care s\u0103 ne ofere informa\u021bia despre existen\u021ba unei anumite valori \u00een permutare.</p> <p>Deoarece sunt \\(n!\\) permut\u0103ri, complexitatea solu\u021biei va fi \\(\\mathcal{O}(n! \\cdot n)\\).</p> <pre><code>#include &lt;fstream&gt;\nusing namespace std;\n\nifstream cin(\"permutari.in\");\nofstream cout(\"permutari.out\");\n\nint n, v[11], vis[11];\n\nvoid backtrack(int pos) {\n    if (pos == n + 1) {  // afisam permutarea\n        for (int i = 1; i &lt;= n; i++) {\n            cout &lt;&lt; v[i] &lt;&lt; \" \";\n        }\n        cout &lt;&lt; '\\n';\n    } else {\n        for (int nxt = 1; nxt &lt;= n; nxt++) {\n            if (vis[nxt] == 0) {  // verificam daca nxt a aparut deja\n                vis[nxt] = 1;     // il marcam vizitat\n                v[pos] = nxt;\n                backtrack(pos + 1);  // apelam urmatorul pas\n                vis[nxt] =\n                    0;  // resetam contorul pentru a putea folosi nxt in viitor\n            }\n        }\n    }\n}\n\nint main() {\n    cin &gt;&gt; n;\n    backtrack(1);\n    return 0;\n}\n</code></pre>","tags":["brute force","implementare","recursivitate","cautare completa"]},{"location":"mediu/backtracking/#problema-exemplu-chessboard-and-queens","title":"Problema exemplu - Chessboard and Queens","text":"<p>Pentru a rezolva aceast\u0103 problem\u0103, trebuie s\u0103 facem c\u00e2teva observa\u021bii pentru a reduce num\u0103rul de st\u0103ri pe care trebuie s\u0103-l vizit\u0103m. \u00cen primul r\u00e2nd, deoarece reginele atac\u0103 pe linie \u0219i pe coloan\u0103, fiecare regin\u0103 trebuie s\u0103 fie pe o linie distinct\u0103 \u0219i pe o coloan\u0103 distinct\u0103, iar acum singurul lucru pe care va trebui s\u0103-l verific\u0103m este faptul c\u0103 nicio pereche de regine nu se afl\u0103 pe aceea\u0219i diagonal\u0103, fie ea principal\u0103 sau secundar\u0103.</p> <p>Nu \u00een ultimul r\u00e2nd, trebuie s\u0103 evit\u0103m st\u0103rile care sunt blocate de ziduri \u0219i s\u0103 num\u0103r\u0103m variantele corecte.</p> <p>Observa\u021bie</p> <p>Solu\u021bia de mai jos folose\u0219te func\u021bia <code>next_permutation</code>, care ia ca parametri \u00eenceputul \u0219i sf\u00e2r\u0219itul unei secven\u021be de valori \u0219i genereaz\u0103 urm\u0103toarea permutare \u00een ordine lexicografic\u0103 a \u0219irului curent. De remarcat este faptul c\u0103 se poate folosi \u0219i solu\u021bia de mai sus, \u00eempreun\u0103 cu observa\u021biile specifice acestei probleme.</p> <pre><code>#include &lt;algorithm&gt;\n#include &lt;iostream&gt;\n#include &lt;vector&gt;\n\nusing namespace std;\n\nint main() {\n    vector&lt;vector&lt;char&gt;&gt; grid(8, vector&lt;char&gt;(8));\n    vector&lt;int&gt; perm(8);\n\n    for (int i = 0; i &lt; 8; ++i) {\n        for (int j = 0; j &lt; 8; j++) {\n            cin &gt;&gt; grid[i][j];\n        }\n        perm[i] = i;\n    }\n    int ans = 0;\n    do {\n        bool ok = 1;\n        for (int i = 0; i &lt; 8; i++) {\n            if (grid[i][perm[i]] == '*') {\n                ok = 0;\n            }\n        }\n        for (int i = 0; i &lt; 8; ++i) {\n            for (int j = i + 1; j &lt; 8; ++j) {\n                if (abs(i - j) == abs(perm[i] - perm[j])) {\n                    ok = 0;\n                }\n            }\n        }\n        ans += ok;\n    } while (next_permutation(perm.begin(), perm.begin() + 8));\n\n    cout &lt;&lt; ans &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["brute force","implementare","recursivitate","cautare completa"]},{"location":"mediu/backtracking/#concluzii","title":"Concluzii","text":"<p>Cunoa\u0219terea acestei tehnici, \u00eempreun\u0103 cu problemele specifice reprezint\u0103 un punct important de plecare pentru a putea genera toate solu\u021biile atunci c\u00e2nd situa\u021bia o cere. De asemenea, scrierea unei astfel de solu\u021bii poate fi util\u0103 \u0219i atunci c\u00e2nd vrei s\u0103 rezolvi o problem\u0103 mai dificil\u0103, dar nu ai f\u0103cut \u00eenc\u0103 observa\u021biile care s\u0103 te duc\u0103 la un punctaj mai mare, garant\u00e2ndu-\u021bi ni\u0219te puncte \u0219i o solu\u021bie corect\u0103 care poate servi drept un punct de plecare pentru g\u0103sirea altor observa\u021bii.</p>","tags":["brute force","implementare","recursivitate","cautare completa"]},{"location":"mediu/backtracking/#probleme-suplimentare","title":"Probleme suplimentare","text":"<ul> <li>pbinfo aranjamente</li> <li>pbinfo   produscartezian1</li> <li>pbinfo generarea   submul\u021bimilor</li> <li>pbinfo regine1</li> <li>pbinfo partitiinumar</li> <li>pbinfo paranteze</li> <li>Probleme cu backtracking de pe   pbinfo</li> <li>USACO Bronze Cow   Gymnastics</li> <li>USACO Bronze Why Did The Cow Cross The Road   II</li> <li>OJI 2010 Immortal</li> <li>USACO Bronze Livestock   Lineup</li> <li>USACO Bronze Back and   Forth</li> <li>Codeforces Three logos</li> <li>Probleme cu backtracking de pe kilonova</li> <li>CSES Grid Paths</li> </ul>","tags":["brute force","implementare","recursivitate","cautare completa"]},{"location":"mediu/backtracking/#resurse-suplimentare","title":"Resurse suplimentare","text":"<ul> <li>Metoda   backtracking</li> <li>Backtracking pe vectori \u0219i probleme diverse - CPPI   Sync</li> <li>Backtracking \u00een plan - CPPI   Sync</li> <li>Basic Complete Search - USACO   Guide</li> <li>Complete Search with Recursion - USACO   Guide</li> </ul>","tags":["brute force","implementare","recursivitate","cautare completa"]},{"location":"mediu/basic-geometry/","title":"Concepte fundamentale de geometrie","text":"<p>Daca vreti sa ne ajutati cu acest articol, ne puteti gasi pe github sau pe serverul nostru de discord</p> <p>Mai jos g\u0103si\u021bi resurse pe care le pute\u021bi citi p\u00e2n\u0103 atunci.</p>","tags":["matematica","geometrie","implementare"]},{"location":"mediu/basic-geometry/#introducere","title":"Introducere","text":"","tags":["matematica","geometrie","implementare"]},{"location":"mediu/basic-geometry/#problema-exemplu","title":"Problema exemplu","text":"","tags":["matematica","geometrie","implementare"]},{"location":"mediu/basic-geometry/#concluzii","title":"Concluzii","text":"","tags":["matematica","geometrie","implementare"]},{"location":"mediu/basic-geometry/#probleme-suplimentare","title":"Probleme suplimentare","text":"","tags":["matematica","geometrie","implementare"]},{"location":"mediu/basic-geometry/#resurse-suplimentare","title":"Resurse suplimentare","text":"<ul> <li>Aria unui triunghi, ecua\u021bia dreptei \u00een plan - CPPI   Sync</li> <li>Aria unui poligon simplu - CPPI   Sync</li> <li>Notiuni elementare de geometrie si aplicatii -   Infoarena</li> <li>Rectangle Geometry - USACO Guide</li> </ul>","tags":["matematica","geometrie","implementare"]},{"location":"mediu/bignum/","title":"Numere mari","text":"<p>Fie \\(\\overline{a_{n-1} a_{n-2} \\ldots a_1 a_0}\\) un num\u0103r \u00een baza 10, format din \\(n\\) cifre. Aici, \\(a_i\\) pentru \\(0 \\leq i &lt; n\\) sunt cifrele num\u0103rului, cu fiecare \\(a_i\\) satisf\u0103c\u00e2nd \\(0 \\leq a_i \\leq 9\\), \u0219i \\(a_{n-1} \\neq 0\\). Valoarea num\u0103rului este dat\u0103 de:</p> \\[ \\overline{a_{n-1} a_{n-2} \\cdots a_1 a_0} = \\sum_{k=0}^{n-1} a_k \\cdot 10^k \\] <p>Aceast\u0103 sum\u0103 poate fi descompus\u0103 \u00een:</p> \\[ \\overline{a_{n-1} a_{n-2} \\cdots a_1 a_0} = a_{n-1} \\cdot 10^{n-1} + a_{n-2} \\cdot 10^{n-2} + \\ldots + a_1 \\cdot 10^1 + a_0 \\cdot 10^0 \\] <p>Similar, fie \\((\\overline{a_{n-1} a_{n-2} \\ldots a_1 a_0})_b\\) un num\u0103r \u00een baza \\(b\\), format din \\(n\\) cifre, unde \\(a_i\\) \u00eendepline\u0219te acelea\u0219i condi\u021bii ca mai sus. Valoarea num\u0103rului este dat\u0103 de:</p> \\[ \\overline{a_{n-1} a_{n-2} \\ldots a_1 a_0}_b = \\sum_{k=0}^{n-1} a_k \\cdot b^k \\] <p>Aceast\u0103 sum\u0103 poate fi descompus\u0103 \u00een:</p> \\[ \\overline{a_{n-1} a_{n-2} \\ldots a_1 a_0}_b = a_{n-1} \\cdot b^{n-1} + a_{n-2} \\cdot b^{n-2} + \\ldots + a_1 \\cdot b^1 + a_0 \\cdot b^0 \\] <p>Numerele mari sunt esen\u021biale pentru calcule ce dep\u0103\u0219esc limita de \\(2^{63} - 1\\). Acestea se bazeaz\u0103 pe reprezentarea cifric\u0103 a numerelor. De exemplu, s\u0103 reprezent\u0103m num\u0103rul 82534 folosind defini\u021bia numerelor \u00een baza 10:</p> \\[ \\begin{align*} 82534 &amp;= 80000 + 2000 + 500 + 30 + 4\\\\ &amp;= 8 \\cdot 10000 + 2 \\cdot 1000 + 5 \\cdot 100 + 3 \\cdot 10 + 4 \\cdot 1\\\\ &amp;= 8 \\cdot 10^{4} + 2 \\cdot 10^3 + 5 \\cdot 10^2 + 3 \\cdot 10^1 + 4 \\cdot 10^0 \\\\ \\end{align*} \\]","tags":["vectori","matematica","numere mari","implementare"]},{"location":"mediu/bignum/#reprezentarea-numerelor-in-memorie","title":"Reprezentarea numerelor \u00een memorie","text":"<p>Reprezentarea pe cifre a numerelor ne duce cu g\u00e2ndul la reprezentarea num\u0103rului folosind un vector. Astfel, o abordare comun\u0103 pentru manipularea numerelor mari \u00een algoritmic\u0103 este reprezentarea acestora prin intermediul unui vector de cifre. Consider\u0103m un num\u0103r mare, pe care \u00eel descompunem \u00een cifrele sale componente \u0219i le stoc\u0103m \u00eentr-un vector.</p> <p>Exemplu</p> <p>De exemplu, num\u0103rul 82534 poate fi stocat \u00eentr-un vector \\(v\\) astfel:</p> \\[ \\begin{array}{r|cccccccc} i &amp; 0 &amp; 1 &amp; 2 &amp; 3 &amp; 4\\\\ \\hline v[i] &amp; 4 &amp; 3 &amp; 5 &amp; 2 &amp; 8 \\\\ \\end{array} \\]","tags":["vectori","matematica","numere mari","implementare"]},{"location":"mediu/bignum/#reprezentarea-inversa","title":"Reprezentarea invers\u0103","text":"<p>Fie un num\u0103r natural \\(N\\) cu cifrele $\\overline{a_{n-1} a_{n-2} \\ldots a_1 a_0} $ \u00een baza 10. Reprezentarea invers\u0103 a lui \\(N\\) \u00eentr-un vector \\(v\\) de dimensiune \\(n\\) este definit\u0103 astfel:</p> \\[ v[i] = a_{n-i},\\,\\forall\\ 0 \\leq i &lt; n \\] <p>unde \\(n\\) este num\u0103rul de cifre ale num\u0103rului natural \\(N\\), iar \\(v[0]\\) reprezint\u0103 cifra unit\u0103\u021bilor, \\(v[1]\\) cifra zecilor \u0219.a.m.d.</p> <p>Observa\u021bie</p> <p>Numerotarea cifrelor de la coad\u0103, ca \u00een exemplul anterior, este op\u021bional\u0103, dar este indicat\u0103 pentru simplificare, deoarece este mult mai simplu s\u0103 efectu\u0103m opera\u021biile dac\u0103 p\u0103str\u0103m num\u0103rul \u00een memorie \u00een ordine invers\u0103 fa\u021b\u0103 de cum l-am scrie \u00een mod obi\u0219nuit. Practic, ad\u0103ugarea unor valori la pozi\u021biile mai nesemnificative este o opera\u021bie mult mai des \u00eent\u00e2lnit\u0103 dec\u00e2t ad\u0103ugarea la \u00eenceputul num\u0103rului, iar c\u00e2nd e nevoie, putem cre\u0219te lungimea num\u0103rului plas\u00e2nd noua cifr\u0103 pe pozi\u021bia \\(n\\), \\(v[n]\\) \u021bin\u00e2nd aceast\u0103 valoare.</p>","tags":["vectori","matematica","numere mari","implementare"]},{"location":"mediu/bignum/#citirea-si-afisarea-unui-numar-mare","title":"Citirea \u0219i afi\u0219area unui num\u0103r mare","text":"<p>Pentru citirea unui num\u0103r mare, vom citi lungimea num\u0103rului (num\u0103rul de cifre) \u0219i apoi cifrele sale, \u00eencep\u00e2nd de la cea mai pu\u021bin semnificativ\u0103 cifr\u0103 (cifra unit\u0103\u021bilor). Pentru afi\u0219are, proced\u0103m invers, \u00eencep\u00e2nd de la cea mai semnificativ\u0103 cifr\u0103.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\n// Lungimea maxim\u0103 a num\u0103rului\nconst int NMAX = 1000;\n\n// Vectorul care va stoca cifrele num\u0103rului\nint cifre[NMAX];\n\n// Lungimea num\u0103rului\nint n;\n\nint main() {\n    cin &gt;&gt; n;\n\n    // Citim cifrele de la coad\u0103 spre cap\n    for (int i = n - 1; i &gt;= 0; i--) {\n        cin &gt;&gt; cifre[i];\n    }\n\n    // Afi\u0219\u0103m num\u0103rul\n    for (int i = n - 1; i &gt;= 0; i--) {\n        cout &lt;&lt; cifre[i];\n    }\n\n    return 0;\n}\n</code></pre>","tags":["vectori","matematica","numere mari","implementare"]},{"location":"mediu/bignum/#optimizarea-prin-stocarea-lungimii-v0","title":"Optimizarea prin stocarea lungimii v[0]","text":"<p>O \u00eembun\u0103t\u0103\u021bire semnificativ\u0103 a acestei metode este reprezentat\u0103 de utilizarea primei pozi\u021bii a vectorului, \\(v[0]\\), pentru a stoca lungimea num\u0103rului. Aceasta face mai u\u0219oar\u0103 manipularea lungimii \u0219i permite modific\u0103ri mai u\u0219oare ale num\u0103rului, cum ar fi ad\u0103ugarea sau eliminarea cifrelor.</p>","tags":["vectori","matematica","numere mari","implementare"]},{"location":"mediu/bignum/#reprezentarea-inversa_1","title":"Reprezentarea invers\u0103","text":"<p>Fie un num\u0103r natural \\(N\\) cu cifrele $\\overline{a_{n-1} a_{n-2} \\ldots a_1 a_0} $ \u00een baza 10. Reprezentarea invers\u0103 a lui \\(N\\) \u00eentr-un vector \\(v\\) de dimensiune $n $ este definit\u0103 astfel:</p> \\[ \\begin{gather*} v[0] = n\\\\ v[i + 1] = a_{n-i},\\,\\forall\\ 0 \\leq i &lt; n \\end{gather*} \\] <p>unde \\(v[0]\\) reprezint\u0103 cifra unit\u0103\u021bilor, \\(v[1]\\) cifra zecilor \u0219.a.m.d., \u0219i \\(n\\) este num\u0103rul de cifre ale num\u0103rului natural \\(N\\).</p> <p>Exemplu</p> <p>De exemplu, num\u0103rul 82534 va fi stocat astfel:</p> \\[ \\begin{array}{r|ccccccccc} i &amp; \\boldsymbol{0} &amp; 1 &amp; 2 &amp; 3 &amp; 4 &amp; 5\\\\ \\hline v[i] &amp; \\boldsymbol{5} &amp; 4 &amp; 3 &amp; 5 &amp; 2 &amp; 8 \\\\ \\end{array} \\] <p>Aici, \\(v[0]=5\\) indic\u0103 num\u0103rul de cifre din \\(N\\), iar cifrele sunt stocate \u00een ordine invers\u0103 \u00eencep\u00e2nd de la \\(v[1]\\).</p>","tags":["vectori","matematica","numere mari","implementare"]},{"location":"mediu/bignum/#procesarea-eficienta-a-numerelor-mari-in-c","title":"Procesarea eficient\u0103 a numerelor mari \u00een C++","text":"<p>Un aspect comun este citirea numerelor mari atunci c\u00e2nd acestea sunt prezentate ca un \u0219ir continuu de cifre, f\u0103r\u0103 separatoare precum spa\u021biile. O tehnic\u0103 eficient\u0103 pentru a aborda aceast\u0103 problem\u0103 implic\u0103 utilizarea string-urilor. Aceast\u0103 metod\u0103 are avantajul de a permite citirea numerelor indiferent de lungimea lor, f\u0103r\u0103 a necesita specificarea acesteia \u00een prealabil.</p>","tags":["vectori","matematica","numere mari","implementare"]},{"location":"mediu/bignum/#pasul-1-citirea-numarului-ca-string","title":"Pasul 1: Citirea num\u0103rului ca string","text":"<p>Primul pas este citirea \u00eentregului num\u0103r ca un string. Aceasta este o abordare flexibil\u0103 care nu este constr\u00e2ns\u0103 de lungimea num\u0103rului. De exemplu, pentru a citi un num\u0103r mare:</p> <pre><code>string numarMare;\ncin &gt;&gt; numarMare;\n</code></pre>","tags":["vectori","matematica","numere mari","implementare"]},{"location":"mediu/bignum/#pasul-2-conversia-stringului-in-vector-de-cifre","title":"Pasul 2: Conversia stringului \u00een vector de cifre","text":"<p>Dup\u0103 citirea num\u0103rului, urm\u0103torul pas este conversia fiec\u0103rui caracter al stringului \u00eentr-o cifr\u0103 numeric\u0103 individual\u0103 \u0219i stocarea acesteia \u00eentr-un vector. Aceast\u0103 conversie este realizat\u0103 prin sc\u0103derea valorii ASCII a caracterului <code>'0'</code> din fiecare caracter al stringului. De asemenea, lungimea num\u0103rului este salvat\u0103 \u00een prima pozi\u021bie a vectorului pentru a facilita accesul \u0219i manipularea ulterioar\u0103 a cifrelor.</p> <p>Iat\u0103 cum arat\u0103 implementarea:</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\n// Lungimea maxim\u0103 a num\u0103rului\nconst int NMAX = 1000;\n\n// Vectorul care va stoca cifrele num\u0103rului\nint cifre[NMAX];\n\n// Lungimea num\u0103rului\nint n;\n\nint main() {\n    string numarMare;\n    cin &gt;&gt; numarMare;\n\n    // Stoc\u0103m lungimea numarului \u00een cifre[0].\n    cifre[0] = numarMare.size();\n\n    // Citim num\u0103rul de la coad\u0103 la cap, convertind\n    // fiecare caracter \u00een valoarea sa numeric\u0103.\n    for (int i = 0; i &lt; cifre[0]; ++i) {\n        cifre[cifre[0] - i] = numarMare[i] - '0';\n    }\n\n    // Afi\u0219area num\u0103rului\n    for (int i = cifre[0]; i &gt;= 1; i--) {\n        cout &lt;&lt; cifre[i];\n    }\n    cout &lt;&lt; endl;\n\n    return 0;\n}\n</code></pre> <p>Aceast\u0103 abordare simplific\u0103 semnificativ citirea numerelor mari</p>","tags":["vectori","matematica","numere mari","implementare"]},{"location":"mediu/bignum/#utilizarea-vectorint-din-stl-pentru-stocare","title":"Utilizarea <code>vector&lt;int&gt;</code> din STL pentru stocare","text":"<p>C\u00e2nd am f\u0103cut citirea cu string-uri, am folosit <code>numarMare.size()</code> pentru a afla lungimea string-ului. Putem folosi aceea\u0219i metod\u0103 pentru a afla \u0219i lungimea num\u0103rului fara s\u0103 o stoc\u0103m in \\(v[0]\\), dar pentru a putea realiza asta, trebuie s\u0103 folosim <code>vector&lt;int&gt;</code>, astfel nemaifiind nevoie s\u0103 stoc\u0103m dimensiunea \u00een \\(v[0]\\).</p>","tags":["vectori","matematica","numere mari","implementare"]},{"location":"mediu/bignum/#crearea-vectorului-si-inserareastergerea-cifrelor-la-inceput","title":"Crearea vectorului si inserarea/\u0219tergerea cifrelor la inceput","text":"<pre><code>#include &lt;iostream&gt;\n#include &lt;vector&gt;\n\nusing namespace std;\n\nvoid afisareNumar(const vector&lt;int&gt;&amp; cifre) {\n    // Pornim de la cifre.size() - 1, deoarece vectorul e indexat de la zero.\n    for (int i = cifre.size() - 1; i &gt;= 0; --i) {\n        cout &lt;&lt; cifre[i];\n    }\n    cout &lt;&lt; \"\\n\";\n}\n\nvoid inserareCifra(vector&lt;int&gt;&amp; cifre, int cifra) {\n    // Inserarea unei cifre noi are loc \u00een fa\u021b\u0103, deoarece folosim reprezentarea\n    // invers\u0103.\n    cifre.push_back(cifra);\n}\n\nvoid stergereCifra(vector&lt;int&gt;&amp; cifre) {\n    // Analog, prima cifr\u0103 se \u0219terge din spate.\n    cifre.pop_back();\n}\n\nint main() {\n    // Putem ini\u021bializa astfel vectorul cu un num\u0103r predefinit, 12 \u00een acest\n    // exemplu.\n    vector&lt;int&gt; cifre = {2, 1};\n\n    cout &lt;&lt; \"Numarul de cifre: \" &lt;&lt; cifre.size() &lt;&lt; \"\\n\";\n    afisareNumar(cifre);\n\n    // Inserarea unei cifre noi \u00een fa\u021b\u0103.\n    inserareCifra(cifre, 9);\n\n    cout &lt;&lt; \"Numarul de cifre: \" &lt;&lt; cifre.size() &lt;&lt; \"\\n\";\n    afisareNumar(cifre);\n\n    // \u0218tergem ultima cifr\u0103.\n    stergereCifra(cifre);\n\n    cout &lt;&lt; \"Numarul de cifre: \" &lt;&lt; cifre.size() &lt;&lt; \"\\n\";\n    afisareNumar(cifre);\n}\n</code></pre> <p>Observ\u0103m c\u0103 astfel dimensiunea vectorului poate varia, un lucru care ne poate ajuta extrem de mult atunci c\u00e2nd nu \u0219tim cat de lung va fi num\u0103rul final.</p>","tags":["vectori","matematica","numere mari","implementare"]},{"location":"mediu/bignum/#implementarea-diverselor-operatii-pe-numerele-mari","title":"Implementarea diverselor opera\u021bii pe numerele mari","text":"<p>Pentru implementarea opera\u021biilor pe numere mari, avem de-a face cu c\u00e2teva cazuri ce vor fi prezentate \u00een ordinea frecven\u021bei lor \u00een practic\u0103, urm\u00e2nd ca la final s\u0103 fie puse toate \u00eempreun\u0103 \u00eentr-o implementare complet\u0103 a unei clase de numere mari. Aceast\u0103 metod\u0103 ce se recomand\u0103 \u00een special celor cu mai mult\u0103 experien\u021b\u0103. \u00cen subcapitolele ce urmeaz\u0103, vom presupune c\u0103 ambii termeni ai opera\u021biilor sunt numere mari, cu excep\u021bia \u00eemp\u0103r\u021birii \u0219i a \u00eenmul\u021bii, unde vom trata ca operanzi at\u00e2t numere mari, c\u00e2t \u0219i numere mici (adic\u0103 numere care nu sunt mari).</p>","tags":["vectori","matematica","numere mari","implementare"]},{"location":"mediu/bignum/#adunarea-numerelor-mari","title":"Adunarea numerelor mari","text":"<p>Adunarea a dou\u0103 numere mari se va realiza \u00een mod similar cu modul \u00een care a\u021bi fost obi\u0219nui\u021bi s\u0103 aduna\u021bi numere la \u0219coal\u0103 \u00een clasele mici, cifr\u0103 cu cifr\u0103 \u0219i \u021bin\u00e2nd cont de transportul cifrelor adi\u021bionale.</p> <pre><code>// Adunarea fiec\u0103rei cifre din b la cifra corespunz\u0103toare din a\nfor (int i = 1; i &lt;= b[0]; i++) {\n    a[i] += b[i];\n}\n\n// `a` trebuie s\u0103 aib\u0103 num\u0103rul potrivit de cifre pentru a putea \u00eenc\u0103pea\n// adunarea, a\u0219adar alegem maximul dintre lungimile celor dou\u0103 numere.\na[0] = max(a[0], b[0]);\n\n// Gestionarea transportului\nfor (int i = 1; i &lt;= a[0]; i++) {\n    // Avem un transport!\n    if (a[i] &gt;= 10) {\n        // Dac\u0103 e ultima cifr\u0103, doar cre\u0219tem num\u0103rul de cifre.\n        if (i == a[0]) {\n            a[0]++;\n        }\n\n        // Adaug\u0103 transportul la cifra urm\u0103toare, \u0219i re\u021bine doar ultima cifr\u0103.\n        a[i + 1]++;\n        a[i] -= 10;\n    }\n}\n</code></pre>","tags":["vectori","matematica","numere mari","implementare"]},{"location":"mediu/bignum/#scaderea-numerelor-mari","title":"Sc\u0103derea numerelor mari","text":"<p>Sc\u0103derea a dou\u0103 numere mari se va realiza \u00een mod similar cu modul \u00een care a\u021bi fost obi\u0219nui\u021bi s\u0103 sc\u0103de\u021bi numere la \u0219coal\u0103 \u00een clasele mici, cifr\u0103 cu cifr\u0103 \u0219i \u021bin\u00e2nd cont de \u00eemprumutul cifrelor necesare pentru efectuarea opera\u021biilor.</p> <pre><code>// Sc\u0103derea fiec\u0103rei cifre din b din cifra corespunz\u0103toare din a\nfor (int i = 1; i &lt;= b[0]; i++) {\n    a[i] -= b[i];\n}\n\n// Gestionarea \u00eemprumutului\nfor (int i = a[0]; i &gt;= 1; i--) {\n    // Dac\u0103 cifra este negativ\u0103, \u201ene \u00eemprumut\u0103m\u201d\n    // Ad\u0103ug\u0103m 10 la cifra curent\u0103 \u0219i sc\u0103dem 1 de la cifra urm\u0103toare pentru a\n    // face \u00eemprumutul.\n    if (a[i] &lt; 0) {\n        a[i] += 10;\n        a[i + 1]--;\n    }\n}\n\n// Elimin\u0103 zerourile nesemnificative din fa\u021ba num\u0103rului\nwhile (a[a[0]] == 0) {\n    a[0]--;\n}\n</code></pre>","tags":["vectori","matematica","numere mari","implementare"]},{"location":"mediu/bignum/#compararea-a-doua-numere-mari","title":"Compararea a dou\u0103 numere mari","text":"<p>Pentru a compara dou\u0103 numere mari, avem dou\u0103 cazuri simple de tratat, urm\u00e2nd ca restul implement\u0103rii s\u0103 fie similar cu modul \u00een care am compara dou\u0103 \u0219iruri de caractere.</p> <p>Dac\u0103 cele dou\u0103 numere au un num\u0103r diferit de cifre, putem trage concluzia \u00een mod evident, iar \u00een caz contrar, vom lua cifr\u0103 cu cifr\u0103, de la cea mai semnificativ\u0103 la cea mai pu\u021bin semnificativ\u0103.</p> <pre><code>// -1 dac\u0103 a &lt; b\n// 0 dac\u0103 a == b\n// 1 dac\u0103 a &gt; b\nint comparaCifre(const vector&lt;int&gt;&amp; a, const vector&lt;int&gt;&amp; b) {\n    // a are mai multe cifre\n    if (a[0] &gt; b[0]) {\n        return 1;\n    }\n\n    // b are mai multe cifre\n    if (a[0] &lt; b[0]) {\n        return -1;\n    }\n\n    // Au acela\u0219i num\u0103r de cifre, deci compar\u0103m cifr\u0103 cu cifr\u0103.\n    for (int i = a[0]; i &gt;= 1; i--) {\n        if (a[i] == b[i]) {\n            continue;\n        }\n\n        return (a[i] &gt; b[i]) ? 1 : -1;\n    }\n\n    return 0;\n}\n</code></pre>","tags":["vectori","matematica","numere mari","implementare"]},{"location":"mediu/bignum/#inmultirea-unui-numar-mare-cu-un-numar-mic","title":"\u00cenmul\u021birea unui num\u0103r mare cu un num\u0103r mic","text":"<p>Acest subcaz al \u00eenmul\u021birii poate fi implementat mult mai u\u0219or, implementarea prelu\u00e2nd multe elemente din cele ale adun\u0103rii a dou\u0103 numere mari. Vom presupune c\u0103 vom \u00eenmul\u021bi num\u0103rul mare cu \\(x\\).</p> <pre><code>long long val = 0;\n\nfor (int i = 1; i &lt;= a[0]; i++) {\n    // Includem produsul dintre cifra curent\u0103 \u0219i x\n    val += 1LL * a[i] * x;\n    // Stoc\u0103m ultima cifr\u0103 a acestei sume...\n    a[i] = val % 10;\n    // ...\u0219i o scoatem din sum\u0103.\n    val /= 10;\n}\n\n// Gestionarea transportului r\u0103mas dup\u0103 \u00eenmul\u021bire.\n// Pentru fiecare cifr\u0103 din val, l\u0103rgim num\u0103rul \u0219i stoc\u0103m ultima cifr\u0103 din val\n// ca prima cifr\u0103 din num\u0103r.\nfor (; val; val /= 10) {\n    a[0]++;\n    a[a[0]] = val % 10;\n}\n</code></pre>","tags":["vectori","matematica","numere mari","implementare"]},{"location":"mediu/bignum/#inmultirea-a-doua-numere-mari","title":"\u00cenmul\u021birea a dou\u0103 numere mari","text":"<p>\u00cenmul\u021birea a dou\u0103 numere mari va necesita lucrul cu toate cifrele num\u0103rului, complexitatea algoritmului devenind \\(\\mathcal{O}(n_A \\cdot n_B)\\), unde \\(n_A\\) reprezint\u0103 num\u0103rul de cifre al lui \\(A\\), iar \\(n_B\\), num\u0103rul de cifre al lui \\(B\\). Din nou, implementarea va fi asem\u0103n\u0103toare cu cea \u00eenv\u0103\u021bat\u0103 \u00een clasele mici la \u0219coal\u0103.</p> <pre><code>// Num\u0103rul nostru este cel pu\u021bin la fel de mare ca suma cifrelor lor + 1.\nvector&lt;long long&gt; ans(a[0] + b[0] + 1);\n\n// Facem produsul fiec\u0103rei cifre din a cu fiecare cifr\u0103 din b\nfor (int i = 1; i &lt;= a[0]; i++) {\n    for (int j = 1; j &lt;= b[0]; j++) {\n        ans[i + j - 1] += 1LL * b[j] * a[i];\n    }\n}\n\n// Ajustarea dimensiunii vectorului a pentru a \u021bine cont de posibilele\n// transporturi\na[0] += b[0] - 1;\n\nfor (int i = 1; i &lt;= a[0]; i++) {\n    // Avem un transport\n    if (ans[i] &gt;= 10) {\n        // Dac\u0103 este ultima cifr\u0103...\n        if (i == a[0]) {\n            // ...cre\u0219tem dimensiunea \u0219i o ad\u0103ug\u0103m.\n            a[0]++;\n            ans.push_back(ans[i] / 10);\n        } else {\n            // Adaug\u0103 transportul la cifra urm\u0103toare.\n            ans[i + 1] += ans[i] / 10;\n        }\n\n        // P\u0103streaz\u0103 cifra curent\u0103.\n        ans[i] %= 10;\n    }\n}\n\n// Copierea cifrelor din ans \u00eenapoi \u00een a\nfor (int i = 1; i &lt; (int)ans.size(); i++) {\n    a[i] = ans[i];\n}\n</code></pre>","tags":["vectori","matematica","numere mari","implementare"]},{"location":"mediu/bignum/#impartirea-unui-numar-mare-la-un-numar-mic","title":"\u00cemp\u0103r\u021birea unui num\u0103r mare la un num\u0103r mic","text":"<p>La fel ca la \u00eenmul\u021bire, vom lucra cifr\u0103 cu cifr\u0103 \u0219i vom avea grij\u0103 s\u0103 lu\u0103m transportul cifr\u0103 cu cifr\u0103. Vom presupune c\u0103 vom \u00eemp\u0103r\u021bi num\u0103rul mare la \\(x\\).</p> <pre><code>long long val = 0;\n\nfor (int i = a[0]; i &gt;= 1; i--) {\n    // Actualizeaz\u0103 val pentru a include cifra curent\u0103\n    val = val * baza + a[i];\n\n    // Stocheaz\u0103 c\u00e2tul \u00eemp\u0103r\u021birii lui val la x \u00een pozi\u021bia curent\u0103\n    a[i] = val / x;\n\n    // Stocheaz\u0103 restul \u00eemp\u0103r\u021birii \u00een val\n    val %= x;\n}\n\n// Elimin\u0103, zerourile nesemnificative din fa\u021ba num\u0103rului\nwhile (a[a[0]] == 0) {\n    a[0]--;\n}\n</code></pre>","tags":["vectori","matematica","numere mari","implementare"]},{"location":"mediu/bignum/#afisarea-unui-numar-mare","title":"Afi\u0219area unui num\u0103r mare","text":"<p>Atunci c\u00e2nd lucr\u0103m cu o baz\u0103 mai mare ca 10, afi\u0219area num\u0103rului poate deveni un pic mai complicat\u0103, fiind nevoie de aten\u021bie suplimentar\u0103 pentru a face lucrurile s\u0103 func\u021bioneze. Aici am pus o implementare mai generalizat\u0103, unde \\(b\\) este baza pe care o folosim (implicit e 10, dar poate fi ajustat\u0103).</p> <pre><code>bool ok = false;\n\n// Parcurgem de la cea mai semnificativ\u0103 cifr\u0103 c\u0103tre cea mai pu\u021bin semnificativ\u0103\n// cifr\u0103\nfor (int i = a[0]; i &gt;= 1; i--) {\n    if (ok) {\n        // Valoarea curent\u0103 s\u0103 fie cel pu\u021bin 1\n        long long val = max(1LL, a[i]);\n\n        // Ad\u0103ug\u0103m zerouri la \u00eenceput pentru a p\u0103stra formatul corect.\n        while (val * 10 &lt; b) {\n            cout &lt;&lt; 0;\n            val *= 10;\n        }\n    }\n\n    // Dac\u0103 cifra curent\u0103 nu este zero, am \u00eenceput s\u0103 afi\u0219\u0103m\n    // adic\u0103 am sc\u0103pat de zerourile ini\u021biale.\n    if (a[i]) {\n        ok = true;\n    }\n\n    cout &lt;&lt; a[i];\n}\n</code></pre>","tags":["vectori","matematica","numere mari","implementare"]},{"location":"mediu/bignum/#optimizari-ce-se-pot-face-la-implementare","title":"Optimiz\u0103ri ce se pot face la implementare","text":"<p>Prima \u0219i cea mai evident\u0103 optimizare const\u0103 \u00een lucrul cu o baz\u0103 mai mare ca 10, de regul\u0103 putere a lui 10. Se recomand\u0103 folosirea unei baze \u00eentre \\(10^6\\) \u0219i \\(10^8\\), pentru a evita overflow-urile ce ar putea ap\u0103rea de la stocarea individual\u0103 a fiec\u0103rei pozi\u021bii drept un num\u0103r de 10 sau mai multe cifre.</p> <p>Aceast\u0103 optimizare poate fi util\u0103 mai ales \u00een situa\u021bia \u00een care foarte multe calcule sunt necesare sau limita de timp este str\u00e2ns\u0103. Un astfel de exemplu reprezint\u0103 problemele de programare dinamic\u0103 \u00een care trebuie afi\u0219at num\u0103rul complet de solu\u021bii (totu\u0219i, \u00een prezent, o mare parte din acele probleme cer r\u0103spunsul modulo un num\u0103r prim).</p> <p>De asemenea, a\u0219a cum ve\u021bi observa mai t\u00e2rziu, exist\u0103 diverse metode de a optimiza opera\u021biile de \u00eenmul\u021bire, folosind diver\u0219i algoritmi precum algoritmul lui Karatsuba sau FFT, dar ace\u0219tia nu fac obiectul discu\u021biei noastre din acest articol.</p>","tags":["vectori","matematica","numere mari","implementare"]},{"location":"mediu/bignum/#probleme-suplimentare","title":"Probleme suplimentare","text":"<ul> <li>pbinfo sumaXXL</li> <li>pbinfo produsXL</li> <li>infoarena perm3</li> <li>ONI 2016 cod</li> <li>ONI 2023 Baraj Juniori Fuziune - cerinta 2</li> <li>Lot Juniori 2015 Pastile</li> <li>infoarena coprime</li> <li>OJI 2010 numar</li> <li>Probleme cu numere mari de pe Kilonova</li> </ul>","tags":["vectori","matematica","numere mari","implementare"]},{"location":"mediu/bignum/#resurse-suplimentare","title":"Resurse suplimentare","text":"<ul> <li>Clas\u0103 de numere mari</li> <li>Lucrul cu numere mari - infoarena</li> <li>Numere mari - CPPI Sync</li> </ul>","tags":["vectori","matematica","numere mari","implementare"]},{"location":"mediu/bitmask-dp/","title":"Dinamic\u0103 pe st\u0103ri exponen\u021biale (bitmask DP)","text":"<p>Atunci c\u00e2nd vorbim de tipuri de probleme pentru care apel\u0103m la solu\u021bii bazate pe metoda program\u0103rii dinamice, dinamicile pe m\u0103\u0219ti pe bi\u021bi (bitmask dp) se disting prin faptul c\u0103 reu\u0219esc s\u0103 formalizeze aceste calcule pentru dimensiuni mici ale valorilor, elimin\u00e2nd necesitatea de a calcula toate cele \\(N!\\) permut\u0103ri ale \u0219irului dat, prin st\u0103ri care s\u0103 \u021bin\u0103 doar posibilele rezultate optime.</p> <p>Chiar dac\u0103 aceast\u0103 subtehnic\u0103 este folosit\u0103 doar pentru dimensiuni ale datelor foarte mici (de regul\u0103, valoarea maxim\u0103 a lui \\(N\\) \u00eentr-o problem\u0103 de acest gen este 20), bitmask dp se dovede\u0219te a fi o unealt\u0103 foarte util\u0103 \u00een multe instan\u021be, chiar \u0219i atunci c\u00e2nd trebuie s\u0103 g\u0103sim solu\u021bii \u00eencete pentru a face pa\u0219i spre a optimiza diverse abord\u0103ri.</p> <p>Observa\u021bie</p> <p>\u00cen jargonul algoritmic rom\u00e2nesc, aceast\u0103 tehnic\u0103 este numit\u0103 dinamic\u0103 pe st\u0103ri exponen\u021biale, denot\u00e2nd num\u0103rul exponen\u021bial de st\u0103ri (de regul\u0103, \\(2^N\\) st\u0103ri)</p>","tags":["programare dinamica","operatii pe biti","submultimi"]},{"location":"mediu/bitmask-dp/#introducere-si-aplicare","title":"Introducere \u0219i aplicare","text":"<p>\u00cen primul r\u00e2nd, pentru a putea folosi aceast\u0103 tehnic\u0103, trebuie s\u0103 ne reamintim c\u00e2teva concepte \u00eenv\u0103\u021bate de la opera\u021biile pe bi\u021bi, cele mai importante fiind submul\u021bimile \u0219i m\u0103\u0219tile pe bi\u021bi. Pentru mai multe detalii, pute\u021bi citi aici.</p> <p>Acum c\u0103 acest concept v\u0103 este cunoscut, pentru a formaliza o stare \u00eentr-o problem\u0103 de acest gen, trebuie s\u0103 g\u0103sim o mul\u021bime de valori cu un cardinal suficient de mic, care are proprietatea c\u0103 submul\u021bimile sale pot constitui st\u0103ri \u00eentr-o rela\u021bie de recuren\u021b\u0103 de acest fel.</p> <p>Observa\u021bie</p> <p>Nu este obligatoriu ca starea pe care o folosim s\u0103 fie legat\u0103 strict de \u0219irul de numere dat. De foarte multe ori, vom aplica aceast\u0103 tehnic\u0103 atunci c\u00e2nd avem o particularitate care poate fi transpus\u0103 \u00een submul\u021bimi (un exemplu ar fi atunci c\u00e2nd avem pu\u021bine valori distincte sau un set de litere al alfabetului).</p> <p>\u00cen cele mai multe cazuri, vorbim de dinamici de tipul \\(dp[msk]\\) sau \\(dp[msk][i]\\), unde ambele reprezint\u0103 r\u0103spunsul optim pentru submul\u021bimea reprezentat\u0103 cu masca \\(msk\\) \u0219i eventual \\(i\\) fiind ultima valoare aleas\u0103. Evident, dac\u0103 problema o impune, putem folosi \u0219i alte dimensiuni pentru a reprezenta datele \u00eentr-o manier\u0103 mai clar\u0103 \u0219i f\u0103r\u0103 poten\u021biale erori.</p> <p>Vom continua prin a prezenta probleme clasice care se rezolv\u0103 cu aceast\u0103 tehnic\u0103.</p>","tags":["programare dinamica","operatii pe biti","submultimi"]},{"location":"mediu/bitmask-dp/#problema-teamwork","title":"Problema teamwork","text":"<p>Se poate remarca faptul c\u0103 sunt cel mult 18 participan\u021bi, iar fiecare trebuie s\u0103 fie folosit o dat\u0103. Generarea tuturor permut\u0103rilor ar fi mult prea \u00eenceat\u0103, a\u0219a c\u0103 va trebui s\u0103 p\u0103str\u0103m informa\u021bii legate de varianta optim\u0103 de a folosi toate submul\u021bimile de copii.</p> <p>Definim \\(dp[msk]\\) ca fiind suma maxim\u0103 a scorurilor dac\u0103 am folosit submul\u021bimea cu masca \\(msk\\). Pentru a face tranzi\u021bia de la \\(msk\\) la o alt\u0103 stare, va trebui s\u0103 parcurgem lista de participan\u021bi, verific\u00e2nd cu ajutorul opera\u021biilor pe bi\u021bi dac\u0103 au mai fost lua\u021bi sau nu.</p> <p>Solu\u021bia va avea complexitate \\(\\mathcal{O}(2^n \\cdot n)\\), fiind suficient de bun\u0103 pentru problema dat\u0103.</p> <p>Observa\u021bie</p> <p>De-a lungul solu\u021biilor prezentate, se va observa preferin\u021ba pentru indexarea de la 0 a pozi\u021biilor, motivul fiind unul ce \u021bine de eficien\u021ba de timp \u0219i memorie (dac\u0103 am fi indexat de la 1, am fi avut nevoie de dou\u0103 ori mai multe m\u0103\u0219ti, deoarece m\u0103\u0219tile care con\u021bineau pozi\u021bia 0 deveneau inutile).</p> <pre><code>#include &lt;fstream&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\nint main() {\n    ifstream cin(\"teamwork.in\");\n    ofstream cout(\"teamwork.out\");\n\n    int n;\n    cin &gt;&gt; n;\n\n    vector&lt;vector&lt;int&gt;&gt; a(n, vector&lt;int&gt;(n));\n    vector&lt;int&gt; dp(1 &lt;&lt; n);\n\n    for (int i = 0; i &lt; n; ++i) {\n        for (int j = 0; j &lt; n; ++j) {\n            cin &gt;&gt; a[i][j];\n        }\n    }\n    for (int msk = 0; msk &lt; (1 &lt;&lt; n) - 1; ++msk) {\n        // cati biti are i\n        int nb = __builtin_popcount(msk);\n        for (int j = 0; j &lt; n; ++j) {\n            if (!(msk &amp; (1 &lt;&lt; j))) {\n                dp[msk ^ (1 &lt;&lt; j)] =\n                    max(dp[msk ^ (1 &lt;&lt; j)], dp[msk] + a[nb][j]);\n            }\n        }\n    }\n    cout &lt;&lt; dp[(1 &lt;&lt; n) - 1] &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["programare dinamica","operatii pe biti","submultimi"]},{"location":"mediu/bitmask-dp/#problema-elevator-rides","title":"Problema Elevator Rides","text":"<p>Pentru a rezolva aceast\u0103 problem\u0103, vom recurge la o alt\u0103 dinamic\u0103 similar\u0103 cu cea anterioar\u0103, singura diferen\u021b\u0103 fiind faptul c\u0103 trebuie s\u0103 o g\u00e2ndim \u0219i din perspectiva problemei rucsacului. Este clar c\u0103 vrem s\u0103 avem ceva de tipul \\(dp[msk]\\) care s\u0103 ne \u021bin\u0103 num\u0103rul minim de folosiri ale liftului pentru submul\u021bimea de oameni cu masca \\(msk\\), dar trebuie s\u0103 g\u0103sim o metod\u0103 pentru a departaja mul\u021bimile cu acela\u0219i num\u0103r de excursii cu liftul.</p> <p>O metod\u0103 simpl\u0103 este aceea de a \u021bine o alt\u0103 informa\u021bie \u00een dinamica noastr\u0103, \u0219i anume gradul de umplere al liftului la excursia curent\u0103, astfel vom \u021bine \u00een dinamica noastr\u0103 o pereche, care va avea at\u00e2t num\u0103rul minim de c\u0103l\u0103torii, c\u00e2t \u0219i gradul de umplere al c\u0103l\u0103toriei curente. La fiecare pas, fie vom reu\u0219i s\u0103 ad\u0103ug\u0103m c\u0103l\u0103torul curent \u00een excursia curent\u0103, fie vom \u00eencepe un alt drum cu liftul.</p> <p>Complexitatea va fi la fel ca la problema precedent\u0103, \\(\\mathcal{O}(2^n \\cdot n)\\), fiind suficient de bun\u0103 pentru cerin\u021bele problemei.</p> <pre><code>#include &lt;iostream&gt;\n#include &lt;vector&gt;\n\nusing namespace std;\n\nint main() {\n    int n, w;\n    cin &gt;&gt; n &gt;&gt; w;\n\n    vector&lt;int&gt; v(n);\n    for (int i = 0; i &lt; n; ++i) {\n        cin &gt;&gt; v[i];\n    }\n\n    vector&lt;pair&lt;int, int&gt;&gt; dp(1 &lt;&lt; n);\n    dp[0].first = 1;\n\n    for (int msk = 1; msk &lt; (1 &lt;&lt; n); ++msk) {\n        dp[msk].first = n + 1;\n    }\n\n    for (int msk = 0; msk &lt; (1 &lt;&lt; n); ++msk) {\n        for (int j = 0; j &lt; n; ++j) {\n            if (msk &amp; (1 &lt;&lt; j)) {\n                continue;\n            }\n            if (dp[msk].second + v[j] &lt;= w) {\n                dp[msk + (1 &lt;&lt; j)] = min(\n                    dp[msk + (1 &lt;&lt; j)], {dp[msk].first, dp[msk].second + v[j]});\n            } else {\n                dp[msk + (1 &lt;&lt; j)] =\n                    min(dp[msk + (1 &lt;&lt; j)], {dp[msk].first + 1, v[j]});\n            }\n        }\n    }\n\n    cout &lt;&lt; dp[(1 &lt;&lt; n) - 1].first;\n    return 0;\n}\n</code></pre>","tags":["programare dinamica","operatii pe biti","submultimi"]},{"location":"mediu/bitmask-dp/#problema-hamiltonian-flights","title":"Problema Hamiltonian Flights","text":"<p>Aceast\u0103 problem\u0103 este una din varia\u021biile problemei comis-voiajorului sau cum se nume\u0219te \u00een englez\u0103, Traveling salesman problem.</p> <p>Pentru a afla num\u0103rul de drumuri de la 0 la \\(n-1\\) care trec prin toate nodurile, vom \u021bine o dinamic\u0103 de tip \\(dp[msk][i]\\) \u00een care vom \u021bine num\u0103rul de drumuri care pleac\u0103 de la 0, sunt la nodul \\(i\\) \u0219i au trecut prin submul\u021bimea de noduri \\(msk\\). Se poate observa c\u0103 graful dat poate avea muchii multiple, acesta fiind motivul pentru care \u021binem muchiile \u00eentr-o list\u0103 de vecini \u0219i nu \u00eentr-o matrice de adiacen\u021b\u0103.</p> <p>Deoarece limita de timp este una str\u00e2ns\u0103, sunt necesare c\u00e2teva optimiz\u0103ri prezentate \u00een cod pentru a evita parcurgerea st\u0103rilor inutile.</p> <pre><code>#include &lt;cassert&gt;\n#include &lt;iostream&gt;\n#include &lt;vector&gt;\n\nusing namespace std;\n\nconst int mod = 1000000007;\n\nint main() {\n    int n, m;\n    cin &gt;&gt; n &gt;&gt; m;\n\n    vector&lt;vector&lt;int&gt;&gt; graph(n);\n\n    for (int i = 0; i &lt; m; ++i) {\n        int a, b;\n        cin &gt;&gt; a &gt;&gt; b;\n        --a, --b;\n        graph[a].push_back(b);\n    }\n\n    vector&lt;vector&lt;int&gt;&gt; dp((1 &lt;&lt; n), vector&lt;int&gt;(n));\n    dp[1][0] = 1;\n\n    for (int msk = 0; msk &lt; (1 &lt;&lt; n); msk++) {\n        // daca masca nu contine 1, nu are sens sa continuam\n        if (!(msk &amp; 1)) {\n            continue;\n        }\n        // daca masca contine n, nu e valida (procesam n la final)\n        if (msk &amp; (1 &lt;&lt; (n - 1))) {\n            continue;\n        }\n        for (int node = 0; node &lt; n; node++) {\n            // nodul trebuie sa fi fost procesat deja\n            if (!(msk &amp; (1 &lt;&lt; node))) {\n                continue;\n            }\n            for (int nxt : graph[node]) {\n                // nu vom procesa un nod deja vizitat\n                if (msk &amp; (1 &lt;&lt; nxt)) {\n                    continue;\n                }\n                dp[msk ^ (1 &lt;&lt; nxt)][nxt] += dp[msk][node];\n                if (dp[msk ^ (1 &lt;&lt; nxt)][nxt] &gt;= mod) {\n                    dp[msk ^ (1 &lt;&lt; nxt)][nxt] -= mod;\n                }\n            }\n        }\n    }\n\n    cout &lt;&lt; dp[(1 &lt;&lt; n) - 1][n - 1] &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["programare dinamica","operatii pe biti","submultimi"]},{"location":"mediu/bitmask-dp/#concluzii","title":"Concluzii","text":"<p>Dinamica pe st\u0103ri exponen\u021biale este o tehnic\u0103 foarte util\u0103 c\u00e2nd trebuie s\u0103 formaliz\u0103m rela\u021bii pe un num\u0103r mic de elemente. Aplica\u021biile acesteia pe grafuri sau pe alte tipuri de mul\u021bimi vor fi foarte utile at\u00e2t \u00een concursuri, c\u00e2t \u0219i \u00een alte situa\u021bii practice, iar tehnici precum SOS DP \u0219i Broken Profile DP vor aduce conceptul la un nivel \u0219i mai avansat.</p>","tags":["programare dinamica","operatii pe biti","submultimi"]},{"location":"mediu/bitmask-dp/#probleme-suplimentare","title":"Probleme suplimentare","text":"<ul> <li>infoarena morcovi</li> <li>infoarena poly</li> <li>infoarena coins</li> <li>infoarena zebughil</li> <li>RCPCamp 2023 Anton Would Approve this   problem</li> <li>OJI 2011 Ubuntzei</li> <li>OJI 2020 RecycleBin</li> <li>Lot Juniori 2014 ssce</li> <li>Lot Juniori 2024 nooverlap</li> <li>Lot Juniori 2016 ksiruri</li> <li>Lot Juniori 2024 numbers</li> <li>OJI 2005 scara</li> <li>AtCoder Matching</li> <li>Codeforces Square Subsets</li> <li>Nastya and Scoreboard</li> <li>USACO Gold Uddered but not   Heard</li> <li>Codeforces Team Building</li> <li>Codeforces Minimax Problem</li> <li>COCI 2016 Burza</li> <li>permutare - InfoTeams #2</li> </ul>","tags":["programare dinamica","operatii pe biti","submultimi"]},{"location":"mediu/bitmask-dp/#lectura-suplimentara","title":"Lectur\u0103 suplimentar\u0103","text":"<ul> <li>Bitmask DP - USACO Guide</li> <li>A primer on bitmask DP - Neo Wang</li> <li>Curs lot juniori 2023 - Dinamic\u0103 pe st\u0103ri   exponen\u021biale</li> <li>Dinamic\u0103 pe st\u0103ri exponen\u021biale - CPPI   Sync</li> <li>DP Book, pagina 37</li> <li>(Avansat) Broken Profile DP - USACO   Guide</li> <li>(Avansat) SOS DP - USACO Guide</li> <li>(Avansat) SOS Dynamic Programming -   Codeforces</li> </ul>","tags":["programare dinamica","operatii pe biti","submultimi"]},{"location":"mediu/bitwise-ops/","title":"Opera\u021bii pe bi\u021bi","text":"<p>\u00cen informatic\u0103 \u0219i \u00een programare, bitul reprezint\u0103 unitatea de baz\u0103 pentru stocarea informa\u021biilor \u00een memorie. Orice activitate desf\u0103\u0219urat\u0103 folosind un sistem de calcul (inclusiv articolul pe care \u00eel citi\u021bi acum) are la baz\u0103 o \u00een\u0219iruire de bi\u021bi folosi\u021bi pentru a reda informa\u021bia sub o form\u0103 accesibil\u0103 pentru oameni.</p> <p>Din acest considerent, bi\u021bii au ajuns s\u0103 fie studia\u021bi \u00een mod am\u0103nun\u021bit, iar \u00een cele ce urmeaz\u0103, vom prezenta sistemul binar, opera\u021biile pe bi\u021bi \u0219i diverse propriet\u0103\u021bi, observa\u021bii \u0219i tehnici pe care le putem folosi pentru a rezolva probleme de algoritmic\u0103, dar \u0219i modurile \u00een care putem integra cuno\u0219tin\u021bele drept pa\u0219i intermediari pentru rezolvarea altor probleme de algoritmic\u0103.</p>","tags":["biti","matematica"]},{"location":"mediu/bitwise-ops/#sistemul-binar","title":"Sistemul binar","text":"<p>De-a lungul acestui articol, vom lucra cu numere reprezentate \u00een form\u0103 binar\u0103 (\u00een baza 2), deci formate din cifre de 0 \u0219i de 1. De exemplu, dac\u0103 vrem s\u0103 scriem num\u0103rul 27 \u00een binar, reprezentarea acestuia va fi:</p> \\[27_{(10)} = 00011011_{(2)} = 0 \\cdot 2^7 + 0 \\cdot 2^6 + 0 \\cdot 2^5 + 1 \\cdot 2^4 + 1 \\cdot 2^3 + 0 \\cdot 2^2 + 1 \\cdot 2^1 + 1 \\cdot 2^0\\] <p>De\u0219i de obicei nu lucr\u0103m cu zerourile nesemnificative, \u00een acest caz ele au fost prezentate pentru \u00een\u021belegerea conceptului, precum \u0219i datorit\u0103 faptului c\u0103 a\u0219a cum ar trebui cunoscut deja, tipurile de date din limbajele C/C++ (\u0219i alte limbaje) au un num\u0103r de bi\u021bi clar definit (de exemplu, <code>int</code> este un tip de date pe 32 de bi\u021bi, <code>char</code> este un tip de date pe 8 bi\u021bi \u0219.a.m.d.).</p>","tags":["biti","matematica"]},{"location":"mediu/bitwise-ops/#legatura-dintre-o-baza-oarecare-si-baza-10","title":"Leg\u0103tura dintre o baz\u0103 oarecare \u0219i baza 10","text":"<p>\u00cen cele ce urmeaz\u0103, prezent\u0103m algoritmul de transformare a unui num\u0103r din baza 10 \u00een baza \\(k\\) \u0219i invers. Remarc\u0103m faptul c\u0103 acest algoritm func\u021bioneaz\u0103 indiferent de baza de la care plec\u0103m, at\u00e2ta timp c\u00e2t baza 10 este parte din calculele noastre.</p> <p>Observa\u021bie</p> <p>\u00cen general, dac\u0103 vrem s\u0103 transform\u0103m din baza \\(a\\) \u00een baza \\(b\\), un algoritm foarte u\u0219or de implementat va fi s\u0103 transform\u0103m mai \u00eent\u00e2i din baza \\(a\\) \u00een baza 10, iar mai apoi s\u0103 transform\u0103m din baza 10 \u00een baza \\(b\\).</p>","tags":["biti","matematica"]},{"location":"mediu/bitwise-ops/#transformarea-unui-numar-din-baza-10-in-baza-k","title":"Transformarea unui num\u0103r din baza 10 \u00een baza \\(k\\)","text":"<p>Pentru a transforma un num\u0103r din baza 10 \u00een baza \\(k\\), vom \u00eemp\u0103r\u021bi repetat num\u0103rul la \\(k\\), p\u00e2n\u0103 c\u00e2nd num\u0103rul va deveni 0, iar resturile \u00eemp\u0103r\u021birilor pe care le ob\u021binem vor crea num\u0103rul \u00een baza \\(k\\), \u00een ordine invers\u0103.</p> <p>Exemplu</p> <p>De exemplu, dac\u0103 vrem s\u0103 convertim num\u0103rul 46 \u00een baza 2, vom ob\u021bine urm\u0103toarele c\u00e2turi \u0219i resturi.</p> <ul> <li>\\(n = 46\\), \\(\\frac{46}{2} = 23\\), restul 0.</li> <li>\\(n = 23\\), \\(\\frac{23}{2} = 11\\), restul 1.</li> <li>\\(n = 11\\), \\(\\frac{11}{2} = 5\\), restul 1.</li> <li>\\(n = 5\\), \\(\\frac{5}{2} = 2\\), restul 1.</li> <li>\\(n = 2\\), \\(\\frac{2}{2} = 1\\), restul 0.</li> <li>\\(n = 1\\), \\(\\frac{1}{2} = 0\\), restul 1.</li> </ul> <p>Dac\u0103 lu\u0103m resturile \u00eemp\u0103r\u021birilor la 2 \u00een ordine invers\u0103, ob\u021binem 101110, num\u0103r care se poate verifica c\u0103 ne va returna \\(n = 46\\) daca \u00eel convertim \u00een baza 10.</p> <p>Mai jos pute\u021bi g\u0103si o scurt\u0103 implementare \u00een limbajul C++.</p> <pre><code>int n, k;  // transformam n in baza k\ncin &gt;&gt; n &gt;&gt; k;\nint nrcif = 0, v[32];  // cifrele in baza k\n\n// obtinem cifrele, una cate una\nwhile (n &gt; 0) {\n    int c = n % k;\n    nrcif++;\n    v[nrcif] = c;\n    n /= k;\n}\n\n// pentru a le afisa, le vom afisa invers\nfor (int i = nrcif; i &gt;= 1; i--) {\n    cout &lt;&lt; v[i];\n}\ncout &lt;&lt; '\\n';\n</code></pre>","tags":["biti","matematica"]},{"location":"mediu/bitwise-ops/#transformarea-unui-numar-din-baza-k-in-baza-10","title":"Transformarea unui num\u0103r din baza \\(k\\) \u00een baza 10","text":"<p>Pentru a transforma un num\u0103r din baza \\(k\\) \u00een baza 10, vom lua cifrele num\u0103rului, de la dreapta la st\u00e2nga, \u0219i vom ad\u0103uga la r\u0103spunsul nostru \\(cif \\cdot k^i\\), unde \\(cif\\) este cifra curent\u0103, \\(k\\) este baza de la care plec\u0103m \u0219i \\(i\\) este num\u0103rul pasului la care suntem.</p> <p>Exemplu</p> <p>De exemplu, dac\u0103 vrem s\u0103 convertim num\u0103rul 10110 \u00een baza 10, vom avea urm\u0103toarele cifre:</p> <ul> <li>pozi\u021bia 0: cifra este 0, se adun\u0103 0 la num\u0103rul \u00een baza 10.</li> <li>pozi\u021bia 1: cifra este 1, se adun\u0103 \\(2^1\\) la num\u0103rul \u00een baza 10.</li> <li>pozi\u021bia 2: cifra este 1, se adun\u0103 \\(2^2\\) la num\u0103rul \u00een baza 10.</li> <li>pozi\u021bia 3: cifra este 0, se adun\u0103 0 la num\u0103rul \u00een baza 10.</li> <li>pozi\u021bia 4: cifra este 1, se adun\u0103 \\(2^4\\) la num\u0103rul \u00een baza 10.</li> </ul> <p>Adunate, aceste puteri ne vor da 22, acesta fiind num\u0103rul in baza 10.</p> <p>Mai jos pute\u021bi g\u0103si o scurt\u0103 implementare \u00een limbajul C++.</p> <pre><code>int n, k;  // transformam n in baza 10, vom presupune ca se da numarul n drept\n           // un numar zecimal dar cu cifre mai mici decat k\ncin &gt;&gt; n &gt;&gt; k;\nint nrcif = 0, v[32];  // cifrele in baza k\n\n// obtinem cifrele, una cate una\nwhile (n &gt; 0) {\n    int c = n % 10;\n    nrcif++;\n    v[nrcif] = c;\n    n /= k;\n}\n\n// pentru a le afisa, le vom afisa invers\nint putere = 1;\nint zecimal = 0;  // numarul convertit in baza 10\nfor (int i = 1; i &lt;= nrcif; i++) {\n    zecimal += putere * v[i];  // adunam cifra inmultita cu puterea lui k\n    putere *= k;  // la fiecare pas, crestem exponentul cu 1, inmultind cu k\n}\ncout &lt;&lt; zecimal &lt;&lt; '\\n';\n</code></pre>","tags":["biti","matematica"]},{"location":"mediu/bitwise-ops/#operatii-pe-biti","title":"Opera\u021bii pe bi\u021bi","text":"<p>Pe l\u00e2ng\u0103 opera\u021biile specifice lucrului cu diverse baze de numera\u021bie, putem lucra cu bi\u021bi folosind opera\u021biile consacrate pe bi\u021bi, care ne vor permite s\u0103 folosim eficien\u021ba lucrului cu bi\u021bi la maxim. Pentru a efectua aceste opera\u021bii, va trebui s\u0103 \u0219tim ce operatori putem folosi. O bun\u0103 parte din cuno\u0219tinte se vor lega de sintaxa \u00eenv\u0103\u021bat\u0103 anterior, \u00een special cele referitoare la operatorii logici.</p> <p>\u00cen contextul algoritmic, putem vorbi de urm\u0103torii operatori:</p>","tags":["biti","matematica"]},{"location":"mediu/bitwise-ops/#operatorul-and-si-pe-biti","title":"Operatorul AND (\"\u0219i\" pe bi\u021bi)","text":"<p>Acest operator ia drept parametri dou\u0103 numere \\(a\\) \u0219i \\(b\\) \u0219i calculeaz\u0103 pentru fiecare bit rezultatul opera\u021biei logice AND. Cu alte cuvinte, pentru o pozi\u021bie \\(i\\), dac\u0103 ambii bi\u021bi de pe pozi\u021bia \\(i\\) din \\(a\\) \u0219i \\(b\\) sunt egali cu 1, opera\u021bia AND va returna 1 pentru acea pozi\u021bie. Altfel, va returna 0. Mai jos pute\u021bi g\u0103si un tabel de adev\u0103r a acestei opera\u021bii, notat\u0103 \u00een limbajele C/C++ cu <code>&amp;</code>:</p> &amp; 0 1 0 0 0 1 0 1 <p>Exemplu</p> <p>De exemplu, dac\u0103 aplic\u0103m opera\u021bia pentru 12 \u0219i 23, reprezent\u0103rile lor binare sunt 01100, respectiv 10111 (am pus un zero nesemnificativ \u00een fa\u021ba lui 12 pentru a ne asigura c\u0103 numerele au acela\u0219i num\u0103r de bi\u021bi), rezultatul opera\u021biei AND este 4, deoarece bitul de pe pozi\u021bia 2 este singurul bit egal cu 1 \u00een ambele numere.</p>","tags":["biti","matematica"]},{"location":"mediu/bitwise-ops/#operatorul-or-sau-pe-biti","title":"Operatorul OR (\"sau\" pe bi\u021bi)","text":"<p>Acest operator ia drept parametri dou\u0103 numere \\(a\\) \u0219i \\(b\\) \u0219i calculeaz\u0103 pentru fiecare bit rezultatul opera\u021biei logice OR. Cu alte cuvinte, pentru o pozi\u021bie \\(i\\), dac\u0103 cel pu\u021bin unul din bi\u021bii de pe pozi\u021bia \\(i\\) din \\(a\\) \u0219i \\(b\\) sunt egali cu 1, opera\u021bia OR va returna 1 pentru acea pozi\u021bie. Altfel, va returna 0. Mai jos pute\u021bi g\u0103si un tabel de adev\u0103r a acestei opera\u021bii, notat\u0103 \u00een limbajele C/C++ cu <code>|</code>:</p> <code>|</code> 0 1 0 0 1 1 1 1 <p>Exemplu</p> <p>De exemplu, dac\u0103 aplic\u0103m opera\u021bia pentru 12 \u0219i 19, reprezent\u0103rile lor binare sunt 01100, respectiv 10011 (am pus un zero nesemnificativ \u00een fa\u021ba lui 12 pentru a ne asigura c\u0103 numerele au acela\u0219i num\u0103r de bi\u021bi), rezultatul opera\u021biei OR este 27, deoarece fiecare din cei 5 bi\u021bi apare \u00een m\u0103car unul din numerele date, cu excep\u021bia bitului 2.  </p>","tags":["biti","matematica"]},{"location":"mediu/bitwise-ops/#operatorul-xor-sau-exclusiv-pe-biti","title":"Operatorul XOR (\"sau exclusiv\" pe bi\u021bi)","text":"<p>Acest operator ia drept parametri dou\u0103 numere \\(a\\) \u0219i \\(b\\) \u0219i calculeaz\u0103 pentru fiecare bit rezultatul opera\u021biei logice XOR. Cu alte cuvinte, pentru o pozi\u021bie \\(i\\), dac\u0103 exact unul din bi\u021bii de pe pozi\u021bia \\(i\\) din \\(a\\) \u0219i \\(b\\) sunt egali cu 1, opera\u021bia XOR va returna 1 pentru acea pozi\u021bie. Altfel, va returna 0. Mai jos pute\u021bi g\u0103si un tabel de adev\u0103r a acestei opera\u021bii, notat\u0103 \u00een limbajele C/C++ cu <code>^</code>:</p> ^ 0 1 0 0 1 1 1 0 <p>Exemplu</p> <p>De exemplu, dac\u0103 aplic\u0103m opera\u021bia pentru 12 \u0219i 22, reprezent\u0103rile lor binare sunt 01100, respectiv 10110 (am pus un zero nesemnificativ \u00een fa\u021ba lui 12 pentru a ne asigura c\u0103 numerele au acela\u0219i num\u0103r de bi\u021bi), rezultatul opera\u021biei XOR este 26, deoarece bitul de pe pozi\u021bia 2 este singurul bit egal cu 1 \u00een ambele numere, iar ceilal\u021bi bi\u021bi apar o singur\u0103 dat\u0103, cu excep\u021bia bitului 0, care nu este fixat \u00een niciunul dintre numere.</p>","tags":["biti","matematica"]},{"location":"mediu/bitwise-ops/#shiftarea-pe-biti","title":"Shiftarea pe bi\u021bi","text":"<p>Un alt operator care este folosit \u00een foarte multe contexte este shiftarea pe bi\u021bi, at\u00e2t la st\u00e2nga, c\u00e2t \u0219i la dreapta. Operatorul este folosit atunci c\u00e2nd vrem s\u0103 \u00eenmul\u021bim sau s\u0103 \u00eemp\u0103r\u021bim un num\u0103r cu o putere a lui 2, lucru ce ne poate fi foarte folositor atunci c\u00e2nd vrem s\u0103 afl\u0103m valoarea unui bit anume, s\u0103 ini\u021bializ\u0103m o valoare minim\u0103 sau maxim\u0103, precum \u0219i \u00een multe alte cazuri similare.</p> <p>Shiftarea la st\u00e2nga, notat\u0103 cu <code>&lt;&lt;</code> este folosit\u0103 atunci c\u00e2nd vrem s\u0103 \u00eenmul\u021bim un num\u0103r cu o putere a lui 2. Modul de folosire al acestui operator este <code>a&lt;&lt;b</code>, care are semnifica\u021bia c\u0103 \u00eenmul\u021bim \\(a\\) cu \\(2^b\\).</p> <p>Observa\u021bie</p> <p>\u00cen mod particular, <code>1&lt;&lt;x</code> ne va returna \u00een timp constant \\(2^x\\), iar pentru puterile lui 2 mai mari de 30, se impune folosirea nota\u021biei <code>1LL&lt;&lt;x</code>, pentru a ne asigura c\u0103 lucr\u0103m \u00een spa\u021biul numerelor din tipul de date long long.</p> <p>Shiftarea la dreapta, notat\u0103 cu <code>&gt;&gt;</code> este folosit\u0103 atunci c\u00e2nd vrem s\u0103 \u00eemp\u0103r\u021bim un num\u0103r cu o putere a lui 2. Modul de folosire al acestui operator este <code>a&gt;&gt;b</code>, care are semnifica\u021bia c\u0103 \u00eemp\u0103r\u021bim \\(a\\) cu \\(2^b\\).</p>","tags":["biti","matematica"]},{"location":"mediu/bitwise-ops/#proprietati-aplicatii-si-legaturi-intre-operatii-pe-biti","title":"Propriet\u0103\u021bi, aplica\u021bii \u0219i leg\u0103turi \u00eentre opera\u021bii pe bi\u021bi","text":"<p>Atunci c\u00e2nd vine vorba de opera\u021bii pe bi\u021bi, exist\u0103 diverse leg\u0103turi, propriet\u0103\u021bi \u0219i trucuri pe care le putem folosi pentru a ajunge s\u0103 rezolv\u0103m mai u\u0219or anumite probleme. Aici voi men\u021biona cele mai frecvent \u00eent\u00e2lnite asemenea propriet\u0103\u021bi, preciz\u00e2nd pentru fiecare dintre ele utilitatea ei.</p> <p>Observa\u021bie</p> <p>\u00cenainte de toate, vrem s\u0103 reamintim faptul c\u0103 \\(2^i &gt; \\sum_{x=0}^{i-1} 2^x\\), deci cu alte cuvinte, dac\u0103 vom avea de f\u0103cut o alegere \u00eentre o putere a lui 2 \u0219i unele puteri mai mici ale lui 2, alegerea unei puteri mai mari ne va garanta un r\u0103spuns optim, chiar dac\u0103 am putea alege ulterior o serie de puteri ale lui 2.</p> <p>Observa\u021bie</p> <p>Un alt aspect important, care va fi folosit \u00een majoritatea problemelor ce \u021bin de opera\u021bii pe bi\u021bi este acela c\u0103 putem trata bi\u021bii de pe pozi\u021bii diferite \u00een mod independent, f\u0103r\u0103 a afecta corectitudinea solu\u021biei g\u0103site.</p> <p>Leg\u0103tura dintre suma numerelor, AND \u0219i XOR</p> <p>Pentru oricare dou\u0103 valori \\(a\\) \u0219i \\(b\\) mai mari sau egale cu 0, \\(a + b = 2 \\cdot (a \\&amp; b) + (a \\oplus b)\\).</p> <p>Aceast\u0103 proprietate se poate demonstra u\u0219or folosind independen\u021ba bi\u021bilor \u0219i evalu\u00e2nd expresia pentru toate modurile \u00een care putem asigna valori bi\u021bilor.</p> <p>Mici verific\u0103ri cu impact major</p> <ul> <li> <p>Pentru a verifica dac\u0103 \\(n\\) este o putere a lui 2, este \u00eendeajuns s\u0103   verific\u0103m valoarea expresiei \\(n \\ \\&amp; \\ (n-1)\\). Dac\u0103 aceasta este 0,   \u00eenseamn\u0103 c\u0103 \\(n\\) \u0219i \\(n-1\\) nu au bi\u021bi \u00een comun, iar singurul caz \u00een care   acest lucru se poate \u00eent\u00e2mpla este dac\u0103 \\(n\\) este putere a lui 2   (reprezentarea binar\u0103 a lui \\(n\\) ar fi \\(100 \\dots 0\\), iar cea a lui \\(n-1\\)   ar fi \\(011 \\dots 1\\).)</p> </li> <li> <p>Pentru a verifica dac\u0103 pentru o valoare \\(n\\), bitul de pe pozi\u021bia \\(x\\) este   setat, este \u00eendeajuns s\u0103 afl\u0103m dac\u0103 rezultatul expresiei \\((n \\ \\&amp; \\   (1&lt;&lt;x)) \\neq 0\\). Deoarece \\(2^x\\) este o putere a lui 2, singurul mod \u00een   care expresia ar fi nenul\u0103 este c\u00e2nd bitul de pe pozi\u021bia \\(x\\) este setat \u00een   \\(n\\).</p> </li> <li> <p>Pentru a afla valoarea celui mai nesemnificativ bit, este \u00eendeajuns s\u0103   folosim opera\u021bia \\(x \\ \\&amp; \\ (-x)\\), motivul pentru care aceast\u0103 opera\u021bie   func\u021bioneaz\u0103 este acela c\u0103 \u00een cazul lui \\(-x\\), bi\u021bii vor fi inversa\u021bi, cu   excep\u021bia ultimului bit, care va r\u0103m\u00e2ne la fel, datorit\u0103 modului \u00een care   sunt dispuse \u00een memorie numerele negative (bitul de semn va fi mereu setat   \u00een cazul lor).</p> </li> </ul>","tags":["biti","matematica"]},{"location":"mediu/bitwise-ops/#lucrul-cu-submultimi","title":"Lucrul cu submul\u021bimi","text":"<p>A\u0219a cum ve\u021bi vedea \u00een detaliu dac\u0103 ve\u021bi citi articolul specific combinatoricii, lucrul cu submul\u021bimi va reprezenta o aplica\u021bie important\u0103 a lucrului cu bi\u021bi, cele \\(2^n\\) submul\u021bimi ale unei mul\u021bimi cu dimensiunea \\(n\\) put\u00e2nd fi toate codificate folosind c\u00e2te un num\u0103r \u00een intervalul \\([0, 2^n - 1]\\).</p> <p>Pentru mai multe detalii, pute\u021bi citi aici articolul nostru care prive\u0219te \u00een detaliu submul\u021bimile din perspectiva combinatoricii. Totu\u0219i, aplica\u021biile prezentate acolo se aplic\u0103 \u00een totalitate \u0219i din perspectiva articolului curent.</p> <p>Lectur\u0103 suplimentar\u0103</p> <p>Alternativ, pute\u021bi citi mai multe detalii de pe articolul de pe cp-algorithms despre enumerarea submul\u021bimilor.</p>","tags":["biti","matematica"]},{"location":"mediu/bitwise-ops/#probleme-suplimentare","title":"Probleme suplimentare","text":"<ul> <li>morse ONI 2006</li> <li>intervale RoAlgo Contest #3</li> <li>Bit Showdown RoAlgo Contest #9</li> <li>patratele OJI 2022</li> <li>Matmare RoAlgo PreOJI 2024</li> <li>Searching for Soulmates   USACO</li> <li>Powered Addition</li> <li>Data Structures Fan</li> <li>castel OJI 2018</li> <li>Sheikh (Easy version)</li> <li>Three Days Ago</li> <li>Preparing Olympiad</li> <li>Petr and a Combination   Lock</li> <li>CSES Xor Pyramid</li> <li>Probleme cu opera\u021bii pe bi\u021bi de pe kilonova</li> <li>Probleme cu opera\u021bii pe bi\u021bi de pe   codeforces</li> </ul>","tags":["biti","matematica"]},{"location":"mediu/bitwise-ops/#lectura-suplimentara","title":"Lectur\u0103 suplimentar\u0103","text":"<ul> <li>Articol de pe USACO Guide</li> <li>Bitwise operations for beginners</li> <li>Bitwise operations for beginners, part   2</li> <li>Opera\u021bii pe bi\u021bi - Infoarena</li> <li>Opera\u021bii pe bi\u021bi - CPPI   Sync</li> <li>Opera\u021bii pe bi\u021bi - Dan   Pracsiu</li> <li>Bit Manipulation -   cp-algorithms</li> <li>Curs lot juniori   2015</li> <li>Easy explanation about Bitwise operations   [Tutorial]</li> </ul>","tags":["biti","matematica"]},{"location":"mediu/cf-atcoder/","title":"Abordarea concursurilor de pe Codeforces/AtCoder","text":"","tags":["meta","practice","concursuri","rating"]},{"location":"mediu/cf-atcoder/#introducere","title":"Introducere","text":"<p>O platform\u0103 foarte popular\u0103 folosit\u0103 de elevii \u0219i studen\u021bii din toat\u0103 lumea pentru a se preg\u0103ti mai bine pentru olimpiadele \u0219i concursurile de informatic\u0103, dar \u0219i pentru des\u0103v\u00e2r\u0219irea cuno\u0219tin\u021belor \u00een materie de algoritmi \u0219i structuri de date, precum \u0219i pentru a-\u0219i \u00eembun\u0103t\u0103\u021bi abilit\u0103\u021bile de rezolvare a problemelor este Codeforces. O alt\u0103 platform\u0103 similar\u0103 este AtCoder, cu un format similar al concursurilor, dar ne vom concentra pe Codeforces \u00een explica\u021biile ce urmeaz\u0103.</p> <p>De\u0219i concursurile de pe Codeforces sunt diferite ca format fa\u021b\u0103 de olimpiade (de regul\u0103, 5-7 probleme \u00een 2-3 ore, de regul\u0103 ordonate cresc\u0103tor \u00een func\u021bie de dificultate), problemele de pe acest site sunt foarte apreciate \u0219i recomandate de sute de mii de utilizatori la nivel global, fiind cea mai mare platform\u0103 de acest fel la nivel mondial. Problemele sunt disponibile \u00een englez\u0103 \u0219i rus\u0103.</p> <p>Aceast\u0103 platform\u0103 este una pe care o recomand\u0103m mai ales dup\u0103 ce ave\u021bi oarecare experien\u021b\u0103 cu problemele de pe Pbinfo \u0219i cele mai simple date la concursurile rom\u00e2ne\u0219ti de informatic\u0103, pentru o provocare \u00een plus \u0219i pentru a \u00eenv\u0103\u021ba lucruri noi.</p>","tags":["meta","practice","concursuri","rating"]},{"location":"mediu/cf-atcoder/#formatul-problemelor","title":"Formatul problemelor","text":"<p>Problemele sunt algoritmice, nivelul acestora este unul foarte variat, \u00eencep\u00e2nd de la aplica\u021bii foarte simple, similare cu nivelul problemelor de pe siteuri precum Pbinfo \u0219i termin\u00e2nd cu probleme foarte dificile, uneori nerezolvate \u00een timpul concursurilor. De regul\u0103, problemele A de la rundele de Div. 3 \u0219i Div. 4 sunt cele mai u\u0219oare, unele din cele mai dificile probleme fiind problemele de la rundele de Div. 1, literele E-F sunt cele mai dificile, sau echivalentul lor, problemele G, H sau I de la rundele Div. 1 + Div. 2.</p> <p>De\u0219i sunt peste \\(10 \\ 000\\) de probleme pe Codeforces, o bun\u0103 parte dintre ele se vor dovedi a nu fi foarte relevante pentru contextul fiec\u0103rui cititor al acestei arhive, din cauza dificult\u0103\u021bii prea sc\u0103zute/ridicate a acestora sau din cauza faptului c\u0103 stilul problemelor nu se mai reg\u0103se\u0219te la fel de mult \u00een problemele care se dau \u00een prezent pe Codeforcees.</p> <p>Spre deosebire de problemele cu care sunte\u021bi obi\u0219nui\u021bi de la olimpiade sau de pe Pbinfo, verdictele care pot ap\u0103rea pe Codeforces sunt diferite. Cele mai frecvent \u00eent\u00e2lnite sunt acestea:</p> <ul> <li>Accepted: A\u021bi rezolvat problema corect, echivalent punctajului de 100 de   puncte de la olimpiade. \u00cen timpul concursului pute\u021bi g\u0103si verdictul Pretests   passed, similar \u00een scop cu Accepted.</li> <li>Wrong answer on test x: A\u021bi rezolvat corect problema pentru primele \\(x-1\\)   teste, dar la testul \\(x\\), r\u0103spunsul este gre\u0219it.</li> <li>Time limit exceeded on test \\(x\\): A\u021bi rezolvat corect problema pentru primele   \\(x-1\\) teste, dar la testul \\(x\\), solu\u021bia dep\u0103\u0219e\u0219te timpul de execu\u021bie alocat   pentru problem\u0103 (de regul\u0103, 1-2 secunde).</li> <li>Memory limit exceeded on test \\(x\\): A\u021bi rezolvat corect problema pentru primele   \\(x-1\\) teste, dar la testul \\(x\\), solu\u021bia dep\u0103\u0219e\u0219te memoria alocat\u0103 pentru   problem\u0103 (de regul\u0103, 256 MB).</li> <li>Idleness limit exceeded on test \\(x\\): \u00cen cazul problemelor interactive, a\u021bi   rezolvat corect problema pentru primele \\(x-1\\) teste, dar la testul \\(x\\),   solu\u021bia nu se opre\u0219te din rulat.  </li> </ul> <p>Observa\u021bie</p> <p>\u00cen preajma anului nou, \u00een spirit de s\u0103rb\u0103toare, verdictul Accepted este \u00eenlocuit cu Happy New Year!</p>","tags":["meta","practice","concursuri","rating"]},{"location":"mediu/cf-atcoder/#competitiile-si-sistemul-de-rating","title":"Competi\u021biile \u0219i sistemul de rating","text":"","tags":["meta","practice","concursuri","rating"]},{"location":"mediu/cf-atcoder/#diviziile-si-ratingurile-de-pe-codeforces","title":"Diviziile \u0219i ratingurile de pe Codeforces","text":"<p>\u00cen func\u021bie de nivelul dovedit la concursurile de pe Codeforces, nivel m\u0103surat prin rating, concuren\u021bii pot avea urm\u0103toarele culori \u0219i titluri:</p> Titlu Culoare Rating Divizie Newbie \u25a0 0-1199 4, 3, 2 Pupil \u25a0 1200-1399 4, 3, 2 Specialist \u25a0 1400-1599 3, 2 Expert \u25a0 1600-1899 2 Candidate Master \u25a0 1900-2099 2, 1 Master \u25a0 2100-2299 1 International Master \u25a0 2300-2399 1 Grandmaster \u25a0 2400-2599 1 International Grandmaster \u25a0 2600-2999 1 Legendary Grandmaster \u25a0 \u25a0 3000+ 1 <p>Observa\u021bie</p> <p>Un singur rom\u00e2n a atins rankul de legendary grandmaster, Costin Andrei Oncescu, acesta particip\u00e2nd \u0219i de 3 ori la IOI.</p> <p>Server interna\u021bional pentru cei cu rating 1900+</p> <p>Exist\u0103 un server neoficial de Discord care cuprinde cea mai mare comunitate de utilizatori care sunt \u00een Div. 1, AC, accesul la discu\u021bii fiind disponibil celor cu rating peste 1900, ei fiind creatorii botului TLE, pe care \u00eel avem \u0219i noi.</p> <p>Ini\u021bial, un concurent are rating 0, dar dup\u0103 6 concursuri \u00een care ratingul este unul provizoriu, acesta devine unul conform cu abilit\u0103\u021bile dovedite de concurent, mai multe detalli sunt aici. Sistemul prin care se acord\u0103 rating este unul de tip ELO, \u00een care se m\u0103soar\u0103 performan\u021ba fiec\u0103rui concurent comparat cu performan\u021ba medie care era a\u0219teptat\u0103 de la acesta.</p> <p>\u00cen func\u021bie de ratingul pe care un concurent \u00eel are, acesta poate participa la urm\u0103toarele tipuri de competi\u021bii \u00een mod oficial:</p> <ul> <li>Div. 4: Cele mai u\u0219oare competi\u021bii, participarea oficial\u0103 este limitat\u0103 celor   cu rating sub 1400.</li> <li>Div. 3: Competi\u021bii u\u0219oare, care sunt mai grele dec\u00e2t Div. 4, participarea   oficial\u0103 este limitat\u0103 celor cu rating sub 1600.</li> <li>Div. 2: Competi\u021biile standard ale Codeforces, participarea oficial\u0103 este   limitat\u0103 celor cu rating sub 1900 (atunci c\u00e2nd se \u021bine \u00een paralel o rund\u0103 de   Div. 1) sau 2100 (c\u00e2nd se \u021bine doar runda de Div. 2, \u00een aceast\u0103 categorie   intr\u00e2nd \u0219i rundele Educational).</li> <li>Div. 1: Cele mai dificile competi\u021bii, participarea oficial\u0103 este limitat\u0103   celor cu rating cel pu\u021bin egal cu 1900.</li> <li>Div. 1 + Div. 2: Runde speciale, care combin\u0103 problemele de la Div. 1 \u0219i Div.   2, fiind deschise tuturor concuren\u021bilor.</li> </ul> <p>Pentru a \u021bi se schimba ratingul dup\u0103 o competi\u021bie, va trebui s\u0103 participi oficial, iar dac\u0103 performezi mai bine dec\u00e2t ratingul t\u0103u ar indica, acesta va cre\u0219te. \u00cen caz contrar, acesta va sc\u0103dea. Cu c\u00e2t ratingul este mai mare, cu at\u00e2t trebuie s\u0103 ai rezultate mai bune pentru a le p\u0103stra, iar competi\u021biile mai slabe pot cauza o sc\u0103dere mai accentuat\u0103 a ratingului.</p> <p>Aten\u021bie</p> <p>Nu vei ob\u021bine mereu un rating mai mare dec\u00e2t ai avut la o rund\u0103 anterioar\u0103, dar asta este ceva ce nu trebuie s\u0103 te demoralizeze, deoarece e o parte normal\u0103 din via\u021ba fiec\u0103rui competitor. Ce po\u021bi face \u00een schimb este s\u0103 \u00eenve\u021bi din gre\u0219eli \u0219i la competi\u021biile viitoare, s\u0103 \u00eencerci s\u0103 le evi\u021bi. Mai multe detalii ulterior \u00een articol.</p> <p>Exist\u0103 \u0219i alte competi\u021bii pe Codeforces, precum Kotlin Heroes, runde de ICPC \u0219i multe alte competi\u021bii neoficiale, dar ne vom rezuma la competi\u021biile oficiale.</p>","tags":["meta","practice","concursuri","rating"]},{"location":"mediu/cf-atcoder/#tipurile-competitiilor","title":"Tipurile competi\u021biilor","text":"<p>Competi\u021biile de pe Codeforces sunt de dou\u0103 tipuri, dup\u0103 cum urmeaz\u0103:</p> <ol> <li>Runde \u00een care fiecare problem\u0103 are un punctaj diferit, tot mai mare \u00een    func\u021bie de nivelul de dificultate al problemei (Aici se \u00eencadreaz\u0103 rundele de    Div. 1, Div. 2 \u0219i Div. 1 + Div. 2), iar \u00een func\u021bie de timpul necesar pentru    rezolvarea problemei \u0219i num\u0103rul de submisii gre\u0219ite, punctajul ob\u021binut pentru    fiecare problem\u0103 scade.</li> <li>Runde \u00een care fiecare problem\u0103 are acela\u0219i punctaj, iar \u00een func\u021bie de timpul    necesar pentru rezolvarea problemei \u0219i num\u0103rul de submisii gre\u0219ite,    penalizarea ob\u021binut\u0103 cre\u0219te (Aici se \u00eencadreaz\u0103 rundele educa\u021bionale, rundele    Div. 3 \u0219i rundele Div. 4).</li> </ol> <p>Observa\u021bie</p> <p>Indiferent de tipul rundei, se recomand\u0103 rezolvarea problemelor \u00een ordine, \u00eencep\u00e2nd de la prima problem\u0103. Uneori, dac\u0103 apar dificult\u0103\u021bi la rezolvarea problemei curente, se recomand\u0103 citirea urm\u0103toarei probleme pentru a avea o \u0219ans\u0103 la ob\u021binerea unor puncte \u00een plus.</p> <p>De regul\u0103, competi\u021biile dureaz\u0103 \u00eentre 120 \u0219i 150 minute (2 ore - \\(2.5\\) ore), rareori dur\u00e2nd 180 minute \u00een cazul unor runde mai dificile \u0219i \u00eencep vara \u00een jurul orei 17:35 sau iarna \u00een jurul 16:35, cu mici excep\u021bii.</p> <p>\u00cen cazul rundelor men\u021bionate \u00een prima categorie, solu\u021biile vor fi testate doar pe o parte din testele finale ale problemei (preteste), iar verdictul de Accepted va fi \u00eenlocuit \u00een timpul rundei cu verdictul Pretests passed.</p> <p>\u00cen cadrul rundelor men\u021bionate \u00een cea de-a doua categorie, exist\u0103 o sec\u021biune dup\u0103 concurs de 12 ore, \u00een care orice test care este folosit pentru a da hack la o solu\u021bie care ob\u021binuse Accepted \u00een timpul concursului va fi folosit pentru a evalua toate celelalte solu\u021bii, la finalul acestei etape.</p> <p>Indiferent de rund\u0103, are loc o sec\u021biune \u00een care toate testele preg\u0103tite de autori sunt folosite pentru a evalua solu\u021biile, cele care iau Accepted dup\u0103 aceast\u0103 sec\u021biune sunt cele care vor conta la scorul fiec\u0103rui concurent.</p> <p>Cu c\u00e2teva zile \u00eenainte de \u00eenceputul fiec\u0103rei runde, autorii vor anun\u021ba competi\u021bia, anun\u021b care va ap\u0103rea pe prima pagin\u0103 a Codeforces. La finalul competi\u021biei, autorii vor publica solu\u021biile problemelor folosind un alt blog, care va fi ad\u0103ugat la anun\u021bul concursului.</p>","tags":["meta","practice","concursuri","rating"]},{"location":"mediu/cf-atcoder/#stilul-problemelor-de-pe-codeforces","title":"Stilul problemelor de pe Codeforces","text":"<p>De\u0219i problemele care apar pe Codeforces cuprind no\u021biuni din toat\u0103 programarea competitiv\u0103, inclusiv no\u021biuni care nu apar la olimpiadele de informatic\u0103 sau \u00een general, la concursuri, se pot observa cu prec\u0103dere preferin\u021be care trebuie avute \u00een vedere pentru a maximiza performan\u021bele la concursuri.</p>","tags":["meta","practice","concursuri","rating"]},{"location":"mediu/cf-atcoder/#problemele-ad-hoc","title":"Problemele ad-hoc","text":"<p>Foarte multe probleme, mai ales cele date \u00een prima parte a rundelor, nu necesit\u0103 un algoritm sau vreo metod\u0103 de programare pentru a rezolva problema, fiind \u00eendeajuns doar observa\u021bii de baz\u0103 \u0219i observarea unor rela\u021bii matematice simple, majoritatea acestor probleme fiind fie probleme matematice, fie probleme care se bazeaz\u0103 pe observa\u021bii Greedy foarte simple sau construc\u021bii elementare.</p> <p>De\u0219i aceste teme se reg\u0103sesc \u0219i ulterior \u00een competi\u021bii, ele apar foarte mult mai ales \u00een primele probleme din runde, spre deosebire de olimpiadele din Rom\u00e2nia \u0219i alte \u021b\u0103ri, unde problemele tind s\u0103 fie mai algoritmice \u0219i tehnice.</p>","tags":["meta","practice","concursuri","rating"]},{"location":"mediu/cf-atcoder/#implementari-simple-si-clare","title":"Implement\u0103ri simple \u0219i clare","text":"<p>De\u0219i acest lucru este important indiferent de problema pe care vre\u021bi s\u0103 o rezolva\u021bi, se poate observa faptul c\u0103 multe din solu\u021biile pe care autorii le au \u00een g\u00e2nd pentru probleme, mai ales c\u00e2nd vine vorba de cele care apar la \u00eenceputul competi\u021biilor sunt foarte simple, aceasta poate fi o capcan\u0103 \u00een care mul\u021bi concuren\u021bi cad, \u00eencerc\u00e2nd s\u0103 aib\u0103 solu\u021bii mai complicate dec\u00e2t trebuie, fie c\u0103 e vorba de implement\u0103ri care sunt prea lungi sau abord\u0103ri mai eficiente dec\u00e2t trebuie.</p>","tags":["meta","practice","concursuri","rating"]},{"location":"mediu/cf-atcoder/#tendintele-concursurilor","title":"Tendin\u021bele concursurilor","text":"<p>De-a lungul anilor, au existat diverse mode (meta-uri) \u00een ceea ce prive\u0219te tipurile de probleme care apar \u00een competi\u021bii, ceea ce necesit\u0103 o oarecare perioad\u0103 de adaptare, meta-uri care devin o necesitate pentru a introduce idei, perspective \u0219i \u00een unele cazuri, metode noi de a rezolva problemele.</p> <p>Totu\u0219i, \u00een ciuda acestui fapt, o mare parte din sfaturile de aici vor putea fi aplicate \u0219i peste mul\u021bi ani, chiar dac\u0103 stilul problemelor va fi diferit p\u00e2n\u0103 atunci.</p>","tags":["meta","practice","concursuri","rating"]},{"location":"mediu/cf-atcoder/#cum-ne-putem-antrena-pentru-codeforces","title":"Cum ne putem antrena pentru Codeforces","text":"<p>\u00cen primul r\u00e2nd, cel mai bun antrenament const\u0103 \u00een concursurile care apar pe platform\u0103, de regul\u0103 cam \\(6-10\\) pe lun\u0103. De\u0219i nu toate sunt potrivite pentru to\u021bi concuren\u021bii, exist\u0103 mereu c\u00e2teva runde \u00een fiecare lun\u0103 care merit\u0103 date. De regul\u0103, recomand\u0103m rundele de Div. 3 \u0219i Div. 4 pentru elevii sub 1400 rating, rundele de Div. 2 pot fi date dac\u0103 ai cel pu\u021bin 1400 rating \u0219i evident, rundele de Div. 1 odat\u0103 ce sunte\u021bi eligibili pentru ele.</p> <p>Concursuri virtuale - simul\u0103ri</p> <p>Chiar dac\u0103 nu ave\u021bi cum s\u0103 ajunge\u021bi la runde sau vre\u021bi s\u0103 simula\u021bi runde ce au avut loc \u00een trecut, pute\u021bi face asta folosind feature-ul Virtual Participation ce apare dac\u0103 intra\u021bi aici.</p> <p>Upsolving</p> <p>O alt\u0103 recomandare pe care o avem este ca dup\u0103 fiecare concurs pe care \u00eel da\u021bi, s\u0103 rezolva\u021bi 1-2 probleme care nu a\u021bi reu\u0219it s\u0103 le rezolva\u021bi \u00een timpul concursului, \u00eempreun\u0103 cu tot ce \u021bine de algoritmii sau tehnicile care trebuie \u0219tiute pentru rezolvarea acelor probleme. \u00cen specialitate, aceast\u0103 parte a competi\u021biilor de informatic\u0103 se nume\u0219te upsolving.</p>","tags":["meta","practice","concursuri","rating"]},{"location":"mediu/cf-atcoder/#botul-tle","title":"Botul TLE","text":"<p>Botul TLE este cel mai complet bot de Discord pe care \u00eel pute\u021bi folosi pentru a v\u0103 antrena pentru Codeforces, acesta fiind disponibil gratuit pe serverul nostru, RoAlgo. Acesta v\u0103 d\u0103 posibilitatea s\u0103 v\u0103 urm\u0103ri\u021bi progresul de pe Codeforces pe discord, s\u0103 lucra\u021bi probleme apropiate de nivelul vostru \u0219i s\u0103 v\u0103 recomande concursuri, probleme \u0219i multe alte facilit\u0103\u021bi, precum dueluri sau alte turnee.</p> <p>\u00cen timpul concursului, \u00een limita func\u021bionalit\u0103\u021bii serverelor de pe Codeforces, pute\u021bi vedea \u0219i \u00een timp real care ar fi schimbarea prev\u0103zut\u0103 a ratingului la acel moment, dar nu recomand\u0103m folosirea acestui clasament, deoarece e mult mai bine s\u0103 v\u0103 concentra\u021bi pe problemele pe care le ave\u021bi de rezolvat.</p> <p>Observa\u021bie</p> <p>\u00cen general, e bine ca \u00een timpul concursurilor s\u0103 v\u0103 concentra\u021bi strict pe ce ave\u021bi de f\u0103cut \u0219i nu pe ce rezultate au prietenii, colegii, rivalii vo\u0219tri etc. Concursurile trebuie s\u0103 le privi\u021bi mai \u00eent\u00e2i ca o lupt\u0103 cu voi \u00een\u0219i\u0219i \u0219i nu cu ceilal\u021bi din jurul vostru, pentru c\u0103 oric\u00e2nd ve\u021bi g\u0103si lucruri care trebuie \u00eembun\u0103t\u0103\u021bite.</p> <p>Dintre cele mai populare comenzi ale botului, vom enum\u0103ra urm\u0103toarele:</p> <ul> <li><code>;handle identify [numele_vostru]</code> - aceast\u0103 comand\u0103 v\u0103 permite s\u0103 asocia\u021bi   contul vostru de Codeforces cu baza noastr\u0103 de date, dup\u0103 ce trimite\u021bi o surs\u0103   care d\u0103 eroare de compilare la problema care vi se asigneaz\u0103.</li> <li><code>;gitgud</code> - aceast\u0103 comand\u0103 v\u0103 permite s\u0103 rezolva\u021bi o problem\u0103 cu un rating   egal cu ratingul vostru, dac\u0103 o rezolva\u021bi pute\u021bi scrie <code>;gotgud</code> \u0219i primi\u021bi   puncte \u00een clasamentul lunar pe care \u00eel avem pe server. Singura particularitate   este c\u0103 dac\u0103 nu vre\u021bi s\u0103 rezolva\u021bi o anumit\u0103 problem\u0103, trebuie s\u0103 a\u0219tepta\u021bi   dou\u0103 ore p\u00e2n\u0103 c\u00e2nd ve\u021bi folosi comanda din nou.</li> </ul> <p>!!! note \"Observa\u021bie\"</p> <pre><code>  Dac\u0103 vre\u021bi s\u0103 rezolva\u021bi probleme mai grele sau mai u\u0219oare, pute\u021bi scrie\n  `;gitgud x`, unde $x$ este un multiplu de 100 reprezent\u00e2nd diferen\u021ba fa\u021b\u0103\n  de ratingul vostru curent. De asemenea, pute\u021bi vedea toate variantele de a\n  folosi aceast\u0103 comand\u0103 pe server.\n</code></pre> <ul> <li><code>;gimme</code> - aceast\u0103 comand\u0103 v\u0103 permite s\u0103 rezolva\u021bi o problem\u0103 cu un rating   egal cu ratingul vostru, f\u0103r\u0103 a fi constr\u00e2n\u0219i de condi\u021biile specifice comenzii   gitgud. Din nou, ave\u021bi multe variante \u0219i moduri de a folosi aceast\u0103 comand\u0103.</li> <li><code>;duel</code> - Aceast\u0103 categorie de comenzi permite dueluri \u00eentre doi sau mai mul\u021bi   membri de pe server care au contul asociat cu baza noastr\u0103 de date, sub   diferite condi\u021bii.</li> <li><code>;plot comanda</code> - Aceast\u0103 categorie de comenzi permite vizionarea diverselor   grafice care se ocup\u0103 de prelucrarea datelor statistice din concursuri \u0219i   datele concuren\u021bilor, inclusiv \u00een ceea ce prive\u0219te partea de exersare a   problemelor.</li> <li><code>;help</code> - Aceast\u0103 comand\u0103 arat\u0103 toate modurile de a folosi botul nostru,   \u00eencep\u00e2nd de la cele descrise aici \u0219i termin\u00e2nd cu multe alte comenzi care   arat\u0103 date statistice, sugestii pentru probleme dar \u0219i grafice care arat\u0103   evolu\u021bia ratingului, a performan\u021belor \u0219i multe altele.</li> </ul>","tags":["meta","practice","concursuri","rating"]},{"location":"mediu/cf-atcoder/#ce-trebuie-evitat","title":"Ce trebuie evitat?","text":"<p>\u00cen primul r\u00e2nd, tri\u0219atul la aceste competi\u021bii nu este permis \u00een nicio form\u0103 \u0219i cu niciun scop, acesta v\u0103 poate cauza conturile s\u0103 fie excluse din concursuri sau de pe site, precum \u0219i pierderea reputa\u021biei voastre ca concuren\u021bi \u0219i \u00een func\u021bie de gravitatea situa\u021biei, se poate ajunge la pedepse pe server.</p> <p>Tri\u0219atul const\u0103 fie \u00een discutarea problemelor cu al\u021bi concuren\u021bi \u00een timpul rundei sau copierea de solu\u021bii, \u00een mod voit sau nevoit, inclusiv dac\u0103 discuta\u021bi idei, da\u021bi spoilere sau alte asemenea \u00een timpul concursului.</p> <p>Observa\u021bie</p> <p>Totu\u0219i, dac\u0103 g\u0103si\u021bi o problem\u0103 similar\u0103 cu cea din concurs care s-a dat anterior \u0219i modifica\u021bi solu\u021bia acelei probleme, nu constituie fraud\u0103.</p>","tags":["meta","practice","concursuri","rating"]},{"location":"mediu/cf-atcoder/#greseli-comune-in-timpul-rundelor","title":"Gre\u0219eli comune \u00een timpul rundelor","text":"<p>O eroare frecvent f\u0103cut\u0103 \u00een timpul concursurilor const\u0103 \u00een folosirea unor instruc\u021biuni precum memset pe vectorii statici (reseteaz\u0103 memoria de fiecare dat\u0103, iar \u00een cazul Codeforces, unde problemele sunt de obicei multi-test, poate cauza limit\u0103 de timp dep\u0103\u0219it\u0103 c\u00e2nd num\u0103rul de teste este mare).</p> <p>O alt\u0103 eroare frecvent exploatat\u0103 de hackeri const\u0103 \u00een folosirea unor structuri de date precum unordered_map, din cauza coliziunilor ce pot avea loc ca urmare a faptului c\u0103 toate valorile ar folosi acela\u0219i hash.</p> <p>Este de asemenea foarte important s\u0103 evita\u021bi submisiile date la grab\u0103 sau care au ca scop doar ca s\u0103 testeze evitarea unor anumite verdicte, ideal este s\u0103 trimite\u021bi solu\u021bii care au o \u0219ans\u0103 s\u0103 ia Accepted (pe scurt, nu are niciun sens s\u0103 trimite\u021bi un brut neoptimizat, cel mai probabil lua\u021bi Time Limit Exceeded).</p> <p>\u00cen general, este bine s\u0103 ave\u021bi codul foarte bine organizat pentru a evita erori subtile sau de implementare. De asemenea, testele sunt mult mai puternice, deci posibilele abord\u0103ri care exploateaz\u0103 testele slabe au \u0219anse mult mai mici de succes pe Codeforces.</p>","tags":["meta","practice","concursuri","rating"]},{"location":"mediu/cf-atcoder/#conturi-multiple","title":"Conturi multiple","text":"<p>Folosirea de conturi multiple \u00een timpul concursurilor este strict interzis\u0103, la fel ca \u0219i folosirea activ\u0103 a mai multor conturi \u00een acela\u0219i timp.</p> <p>Totu\u0219i, \u00een unele situa\u021bii, aceast\u0103 practic\u0103 este acceptat\u0103 tacit de comunitate, foarte mul\u021bi utilizatori av\u00e2nd aceste conturi multiple pentru diverse scopuri, printre care \u00eencerc\u0103ri de a c\u00e2\u0219tiga runde sau de a ob\u021bine mai mult\u0103 \u00eencredere \u00een sine, condi\u021bia fiind aceea de a folosi un singur cont \u00een fiecare rund\u0103.</p>","tags":["meta","practice","concursuri","rating"]},{"location":"mediu/cf-atcoder/#concluzii","title":"Concluzii","text":"<p>Codeforces este o platform\u0103 foarte important\u0103 pentru programarea competitiv\u0103, fiind practic cea mai mare comunitate de acest fel la nivel mondial. Zecile de concursuri ce au loc \u00een fiecare an, \u00eempreun\u0103 cu blogurile care sunt scrise des \u0219i care prezint\u0103 diverse tehnici, algoritmi \u0219i structuri de date prezentate \u0219i aici (ve\u021bi g\u0103si de multe ori resurse de pe Codeforces recomandate de noi) fiind esen\u021biale pentru progresul vostru ca algoritmi\u0219ti.</p> <p>Respectarea competi\u021biei este esen\u021bial\u0103 \u0219i v\u0103 va ajuta s\u0103 deveni\u021bi mai buni \u00een acest mod, iar \u00een timp, pute\u021bi folosi aceast\u0103 platform\u0103 pentru a v\u0103 completa abilit\u0103\u021bile de rezolvitori de probleme \u0219i de programatori. Chiar dac\u0103 nu poate suplini sau \u00eenlocui \u00een niciun fel lucratul pentru olimpiad\u0103, Codeforces, AtCoder \u0219i alte platforme de acest fel sunt potrivite pentru concursuri rapide, diferite ca stil care v\u0103 ajut\u0103 s\u0103 v\u0103 adapta\u021bi mai bine la provoc\u0103rile pe care le ave\u021bi.</p> <p>Mult succes la competi\u021biile de aici!</p>","tags":["meta","practice","concursuri","rating"]},{"location":"mediu/constructive/","title":"Abordarea problemelor constructive","text":"","tags":["ad hoc","probleme constructive","optimizare"]},{"location":"mediu/constructive/#introducere","title":"Introducere","text":"<p>Problemele constructive sunt de multe ori un tip de probleme ce pune concuren\u021bii \u00een dificultate deoarece acestea impun un mod diferit de a g\u00e2ndi lucrurile \u0219i abord\u0103rile sunt de asemenea diferite. Foarte multe dintre sfaturi vor fi similare cu cele de la articolul despre problemele ad-hoc, pe care \u00eel ave\u021bi mai sus, dar vom insista asupra unor lucruri adi\u021bionale care s\u0103 fie aplicate \u0219i utilizate \u00een probleme.</p>","tags":["ad hoc","probleme constructive","optimizare"]},{"location":"mediu/constructive/#asemanari-cu-celelalte-probleme-ad-hoc","title":"Asem\u0103n\u0103ri cu celelalte probleme ad-hoc","text":"<p>La fel ca \u0219i la problemele ad-hoc, strategia men\u021bionat\u0103 \u00een acest articol poate fi aplicat\u0103 \u00een mare m\u0103sur\u0103 \u0219i pentru problemele constructive, deoarece \u00een majoritatea situa\u021biilor putem observa faptul c\u0103 dac\u0103 apel\u0103m la ni\u0219te abord\u0103ri de tip brute-force pentru cazurile mici, \u00eenso\u021bite de presupuneri c\u00e2t mai bune, vom putea ajunge s\u0103 amelior\u0103m anumite deficien\u021be pe care de regul\u0103 aceste tipuri de probleme le expun.</p>","tags":["ad hoc","probleme constructive","optimizare"]},{"location":"mediu/constructive/#alte-sfaturi-practice","title":"Alte sfaturi practice","text":"<p>Deoarece aceste tipuri de probleme se reg\u0103sesc mai ales \u00een concursurile de pe Codeforces, viteza \u0219i \u00eencerc\u0103rile valide pot fi foarte utile pentru a ajunge la r\u0103spunsurile optime.</p> <p>Nu \u00een ultimul r\u00e2nd, \u00een special atunci c\u00e2nd rezolva\u021bi probleme mai dificile, demonstrarea solu\u021biilor este foarte important\u0103 \u0219i poate face diferen\u021ba \u00een special \u00een r\u00e2ndul celor mai buni concuren\u021bi.</p>","tags":["ad hoc","probleme constructive","optimizare"]},{"location":"mediu/constructive/#concluzii","title":"Concluzii","text":"<p>Acest articol des\u0103v\u00e2r\u0219e\u0219te studiul tehnicilor care implic\u0103 \u00een mod exclusiv g\u00e2ndirea \u00een afara cutiei, f\u0103c\u00e2nd loc \u0219i altor tehnici prin excelen\u021b\u0103 algoritmice. Chiar dac\u0103 \u00een sec\u021biunile viitoare ve\u021bi mai avea de citit articole despre probleme interactive \u0219i output-only printre altele, cunoa\u0219terea tehnicilor prezentate \u00een articolele anterioare, \u00eempreun\u0103 cu rezolvarea problemelor de aici va fi foarte util\u0103 pentru tot ce \u021bine de \u00eensu\u0219irea unor cuno\u0219tinte organice \u0219i durabile.</p>","tags":["ad hoc","probleme constructive","optimizare"]},{"location":"mediu/constructive/#probleme-suplimentare","title":"Probleme suplimentare","text":"<ul> <li>IIOT 2023 Ping Pong</li> <li>OJI 2017 Roboti</li> <li>Codeforces Unnatural Conditions</li> <li>IIOT 2024 Tetris Tiling</li> <li>RoAlgo Contest #10 Paranteze</li> <li>OJI 2018 Galeti</li> <li>Lot Juniori 2011 domino</li> <li>IIOT 2022 Pepi and his Friends</li> <li>Codeforces Timofey and Rectangles</li> <li>ONI 2017 Tris</li> <li>Probleme constructive de pe kilonova</li> <li>Probleme constructive de pe Codeforces</li> </ul>","tags":["ad hoc","probleme constructive","optimizare"]},{"location":"mediu/constructive/#resurse-suplimentare","title":"Resurse suplimentare","text":"<ul> <li>Tips on Constructive Algorithms -   Codeforces</li> <li>How to prove your solutions in Competitive   Programming</li> <li>The Reason You are Bad at Codeforces \u2014 You are Not Russian   Enough</li> <li>Constructive Algorithms - HKOI</li> </ul>","tags":["ad hoc","probleme constructive","optimizare"]},{"location":"mediu/contest-improvement/","title":"Cum ajungi tot mai bun la concursuri?","text":"","tags":["meta","sfaturi"]},{"location":"mediu/contest-improvement/#introducere","title":"Introducere","text":"<p>Probabil c\u0103 toat\u0103 lumea \u0219i-a pus m\u0103car o dat\u0103 \u00eentrebarea \"cum ajung s\u0103 am rezultate tot mai bune la concursuri sau examene?\"</p> <p>De\u0219i este o \u00eentrebare care pare simpl\u0103, are un r\u0103spuns complicat, iar aici ne vom propune s\u0103 discut\u0103m despre concursuri \u0219i examene la modul general, iar ulterior, pute\u021bi citi acest articol pentru sfaturi adaptate la olimpiadele de informatic\u0103, precum \u0219i acest articol, pentru sfaturi adaptate la examenul de bacalaureat sau pentru admitere.</p> <p>De-a lungul acestui articol, vom discuta sfaturi generale, precum \u0219i gre\u0219eli frecvente pe care le fac concuren\u021bii pe parcursul lor educa\u021bional.</p> <p>De asemenea, vom face o introducere \u0219i asupra diferitelor formate ale concursurilor, \u00eempreun\u0103 cu particularit\u0103\u021bile lor, iar \u00een acest articol, vom discuta despre gestionarea presiunii \u0219i a\u0219tept\u0103rilor ce apar pe m\u0103sur\u0103 ce ave\u021bi mai mult\u0103 experien\u021b\u0103, precum \u0219i alte sfaturi utile.</p>","tags":["meta","sfaturi"]},{"location":"mediu/contest-improvement/#tipurile-de-concursuri","title":"Tipurile de concursuri","text":"<p>\u00cenc\u0103 de la o v\u00e2rst\u0103 fraged\u0103, ajunge\u021bi s\u0103 concura\u021bi cu cei din jur sub diverse forme, iar acum a venit timpul s\u0103 ob\u021bine\u021bi rezultate c\u00e2t mai bune la un anumit concurs sau examen (nu neap\u0103rat de informatic\u0103 sau programare) \u0219i vre\u021bi s\u0103 v\u0103 cre\u0219te\u021bi \u0219ansele la acest obiectiv.</p> <p>O particularitate pe care o au concursurile de informatic\u0103 este c\u0103 \u00een mare m\u0103sur\u0103, ve\u021bi \u0219ti mereu rezultatul pe care \u00eel ob\u021bine\u021bi \u00een timp real, iar corectarea se face \u00een mod automat, ceea ce elimin\u0103 situa\u021biile \u00een care erorile umane de corectare pot decide soarta unei probe sau a unui concurs.</p> <p>Acest fapt este un mare avantaj pentru to\u021bi competitorii deoarece d\u0103 na\u0219tere la urm\u0103toarea strategie care are \u0219anse maxime de succes: \"ob\u021bine un punctaj maxim \u0219i vei c\u00e2\u0219tiga cu siguran\u021b\u0103\".</p> <p>Chiar dac\u0103 aceast\u0103 strategie este una foarte simplist\u0103, ea ne duce totu\u0219i cu g\u00e2ndul la faptul c\u0103 at\u00e2ta timp c\u00e2t vom ob\u021bine un rezultat suficient de bun, vom putea c\u00e2\u0219tiga concursul respectiv.</p> <p>C\u00e2teva dintre tipurile de concursuri sau examene ce implic\u0103 programarea sau algoritmica, \u00een ordinea dificult\u0103\u021bii lor sunt urm\u0103toarele:</p> <ul> <li>testele de la clas\u0103: \u00een func\u021bie de profil, ele sunt cele mai simple tipuri de   probe pe care le da\u021bi \u0219i au un rol de a v\u0103 ajuta s\u0103 identifica\u021bi cele mai de   baz\u0103 deficien\u021be de cunoa\u0219tere pe care le ave\u021bi</li> <li>examenul de bacalaureat: primul examen la nivel na\u021bional, unde ave\u021bi de   rezolvat diverse exerci\u021bii \u0219i probleme de nivel mediu, care v\u0103 departajeaz\u0103 la   nivel na\u021bional comparat cu ceilal\u021bi elevi de v\u00e2rsta voastr\u0103 de la acela\u0219i   profil cu voi.</li> <li>examenul de admitere: acest examen este unul mai greu, care are rolul de a   selecta cei mai merituo\u0219i studen\u021bi care vor studia la universitatea la care   vre\u021bi s\u0103 v\u0103 petrece\u021bi urm\u0103torii ani din via\u021b\u0103. \u00cen Rom\u00e2nia, majoritatea   facult\u0103\u021bilor de profil au examene de tip gril\u0103, cu exerci\u021bii \u0219i probleme, care   combin\u0103 punctajul ob\u021binut la aceast\u0103 prob\u0103 cu notele de la bacalaureat.</li> <li>olimpiada de informatic\u0103: cel mai dificil tip de concurs, care are rolul de a   selecta cei mai buni elevi din jude\u021b/\u021bar\u0103/regiune etc., problemele date sunt   mult mai dificile dec\u00e2t cele de la probele de admitere, iar rezultatele bune   la olimpiad\u0103 aduc \u00een prezent beneficii \u00een contextul probelor de admitere de la   universit\u0103\u021bile din Rom\u00e2nia.</li> </ul> <p>Pe l\u00e2ng\u0103 aceste concursuri, mai exist\u0103 \u0219i probe care v\u0103 departajeaz\u0103 \u00een alte contexte \u00een via\u021b\u0103, dar pe care vom insista mai pu\u021bin:</p> <ul> <li>interviuri tehnice de angajare: \u00een prezent, foarte multe companii folosesc   probleme de algoritmic\u0103 \u00een procesul de recrutare al angaja\u021bilor, iar   rezolvarea rapid\u0103 \u0219i eficient\u0103 a acestor probleme reprezint\u0103 un pas important   spre ob\u021binerea unui job dorit. Nivelul acestor probleme este cuprins \u00eentre   admitere \u0219i olimpiad\u0103, cu mici excep\u021bii.</li> <li>olimpiada pe echipe (IIOT) \u0219i concursul ICPC pe echipe \u00eentre studen\u021bi:   concursuri pe echipe de 3 sau 4 oameni, \u00een care un grup mai mare de elevi   rezolv\u0103 un num\u0103r larg de probleme \u00eentr-un interval scurt de timp, cu scopul de   a ob\u021bine c\u00e2t mai multe puncte, folosindu-se de abilit\u0103\u021bile individuale \u0219i de   lucrul \u00een echip\u0103.</li> <li>hackathons \u0219i marathons: de regul\u0103, aceste concursuri au mai pu\u021bine aspecte   algoritmice \u00een ele, fiind mai mult axate pe dezvoltarea unor aplica\u021bii sau a   unor solu\u021bii software pentru diverse domenii de activitate.</li> </ul> <p>Chiar dac\u0103 aceste concursuri par a fi foarte diferite ca format \u0219i stil, exist\u0103 multe aspecte comune \u00eentre ele care v\u0103 pot ajuta s\u0103 deveni\u021bi tot mai buni, indiferent de obiectivul propus.</p>","tags":["meta","sfaturi"]},{"location":"mediu/contest-improvement/#cum-va-pregatiti-pentru-aceste-concursuri","title":"Cum v\u0103 preg\u0103ti\u021bi pentru aceste concursuri?","text":"<p>Primul \u0219i cel mai important lucru pe care trebuie s\u0103 \u00eel face\u021bi este s\u0103 studia\u021bi nivelul concursului, prin prisma problemelor care s-au dat \u00een anii anteriori. Fie c\u0103 este vorba de un examen de bacalaureat sau de lotul na\u021bional, nivelul de dificultate al problemelor este unul similar de la an la an, iar studierea programei este esen\u021bial\u0103 pentru succesul vostru. De asemenea, obi\u0219nuirea cu formatul concursului este \u0219i ea un factor important pentru a v\u0103 putea ajuta s\u0103 v\u0103 doza\u021bi efortul \u0219i s\u0103 fi\u021bi obi\u0219nui\u021bi cu mediul de concurs.</p> <p>Odat\u0103 ce \u0219ti\u021bi ce ave\u021bi de f\u0103cut, trebuie s\u0103 studia\u021bi materia de care ave\u021bi nevoie pentru aceste probe. \u00centr-o situa\u021bie ideal\u0103, studiul vostru este unul constant \u0219i de lung\u0103 durat\u0103, dar dac\u0103 din diverse motive nu a\u021bi \u00eenv\u0103\u021bat la timp anumite concepte sau capitole, recomand\u0103m urmarea acestui roadmap pentru olimpiad\u0103, iar pentru examenele de bacalaureat \u0219i admitere, recomand\u0103m citirea con\u021binuturilor din capitolele u\u0219or (\u0219i unele din sec\u021biunea mediu) ale acestei arhive.</p> <p>Pe parcurs, pe m\u0103sur\u0103 ce deveni\u021bi tot mai familiari cu aceste con\u021binuturi, este bine s\u0103 lucra\u021bi problemele \u0219i variantele de concurs ce s-au dat \u00een anii anteriori la nivelul pe care \u00eel \u021binti\u021bi. Fie c\u0103 este vorba de subiectele de bacalaureat, diverse modele de examen sau problemele date \u00een anii trecu\u021bi la olimpiad\u0103, rezolvarea lor \u0219i \u00een\u021belegerea abord\u0103rilor din spatele lor este un pas foarte important spre succes.</p>","tags":["meta","sfaturi"]},{"location":"mediu/contest-improvement/#cum-va-identificati-punctele-tari-si-slabe","title":"Cum v\u0103 identifica\u021bi punctele tari \u0219i slabe?","text":"<p>De-a lungul procesului vostru de preg\u0103tire, ve\u021bi observa \u00een mod inevitabil diverse capitole sau algoritmi care v\u0103 pun mai mari dificult\u0103\u021bi dec\u00e2t de obicei, acest lucru fiind normal \u0219i \u00eent\u00e2lnit la fiecare concurent. Dac\u0103 \u00een cadrul mai multor probleme sau variante de examen observa\u021bi c\u0103 acest lucru se \u00eent\u00e2mpl\u0103 mult prea des, este bine s\u0103 v\u0103 recapitula\u021bi din nou acel capitol sau s\u0103 \u00eentreba\u021bi pe cineva care se pricepe mai bine dec\u00e2t voi, pentru a putea avea o misiune mai u\u0219oar\u0103 \u00een acest demers.</p> <p>Comunitatea noastr\u0103 are mii de oameni activi care sunt gata s\u0103 v\u0103 ajute, a\u0219a cum \u0219i tu po\u021bi ajuta la r\u00e2ndul t\u0103u pe al\u021bii care au nevoie \u00een diverse contexte.</p>","tags":["meta","sfaturi"]},{"location":"mediu/contest-improvement/#cat-timp-sa-alocati-lucrului","title":"C\u00e2t timp s\u0103 aloca\u021bi lucrului?","text":"<p>Ideal, ar trebui s\u0103 lucra\u021bi c\u00e2t de mult posibil, \u00een limita puterii \u0219i anduran\u021bei mentale pe care o ave\u021bi, dar pentru a aduce discu\u021bia \u00eenapoi la realitate, este bine s\u0103 lucra\u021bi c\u00e2t de des posibil (ideal \u00een fiecare zi) m\u0103car c\u00e2te o or\u0103, dar dac\u0103 \u0219ti\u021bi c\u0103 \u021binti\u021bi spre un obiectiv mai \u00eenalt sau nu mai ave\u021bi at\u00e2ta timp pentru a \u00eenv\u0103\u021ba \u0219i a parcurge materia, mai multe ore sunt necesare (m\u0103car \\(2-3\\) ore).</p> <p>Lucratul constant este mult mai util dec\u00e2t lucratul \u00een salturi deoarece \u00een acest mod, permite\u021bi creierului vostru s\u0103 asimileze cuno\u0219tin\u021bele mai bine, f\u0103c\u00e2nd loc \u0219i altor con\u021binuturi (eventual de la alte materii).</p>","tags":["meta","sfaturi"]},{"location":"mediu/contest-improvement/#dozarea-efortului-in-contextul-unor-competitii-mai-dificile","title":"Dozarea efortului \u00een contextul unor competi\u021bii mai dificile","text":"<p>Exist\u0103 anumite competi\u021bii mai dificile (olimpiadele, \u00een special fazele superioare) care necesit\u0103 un volum mare de efort \u0219i timp pentru a ajunge s\u0103 ob\u021bine\u021bi rezultate c\u00e2t mai bune, iar de multe ori, pot ap\u0103rea diverse lucruri care v\u0103 pot duce la ceea ce se nume\u0219te efectul de burnout, un efect pe care trebuie s\u0103 \u00eel evita\u021bi cu orice pre\u021b.</p> <p>Dac\u0103 \u00een anumite momente sim\u021bi\u021bi c\u0103 nu mai ave\u021bi acela\u0219i randament ca de obicei, o pauz\u0103 scurt\u0103 (cel mult c\u00e2teva zile) poate fi binevenit\u0103 pentru a putea s\u0103 reveni\u021bi la randamentul obi\u0219nuit. \u00cen acest interval de timp, trebuie s\u0103 ave\u021bi grij\u0103 \u0219i la programul vostru de odihn\u0103, deoarece \u00een multe situa\u021bii, aceste probleme sunt corelate \u0219i este bine s\u0103 preveni\u021bi probleme mai complicate, burnoutul fiind un semnal al corpului vostru c\u0103 este nevoie de o mic\u0103 ajustare sau chiar de o schimbare a ritmului obi\u0219nuit.</p>","tags":["meta","sfaturi"]},{"location":"mediu/contest-improvement/#rezultatele-preliminare-si-gestionarea-lor","title":"Rezultatele preliminare \u0219i gestionarea lor","text":"<p>De-a lungul preg\u0103tirii pentru un concurs, exist\u0103 diverse probe intermediare, fie c\u0103 este vorba de concursurile online (Codeforces, IIOT, AtCoder etc.) sau este vorba de simul\u0103rile organizate de \u0219coal\u0103/inspectorat/profesori etc., aceste rezultate sunt un indicator important asuprea performan\u021bei voastre \u0219i a identific\u0103rii punctelor voastre slabe, ceea ce pe de o parte este un lucru foarte util, dar pe de alt\u0103 parte, nu trebuie s\u0103 stea la baza unei presiuni inutile din partea celor din jur.</p> <p>\u00cen anumite situa\u021bii, un rezultat mai slab poate servi drept un semnal de alarm\u0103 pentru a insista mai bine pe anumite no\u021biuni sau care d\u0103 semnalul c\u0103 o anumit\u0103 abordare nu este potrivit\u0103, dar \u00een lipsa unui indicator mai constant \u00een aceast\u0103 privin\u021b\u0103, nu trebuie s\u0103 lua\u021bi niciodat\u0103 decizii pripite.</p>","tags":["meta","sfaturi"]},{"location":"mediu/contest-improvement/#concluzii","title":"Concluzii","text":"<p>Acest articol a discutat despre c\u00e2teva dintre cele mai importante \u0219i generale sfaturi legate de ob\u021binerea rezultatelor mai bune la concursuri, \u00eencep\u00e2nd cu identificarea tipurilor de concursuri care exist\u0103, precum \u0219i cele mai comune etape din parcursul academic al fiec\u0103rui elev care particip\u0103 la un anumit concurs. \u00cen articolele ulterioare, vom discuta despre gestionarea presiunii, precum \u0219i sfaturi mai specifice pentru diverse tipuri de concursuri, precum bacalaureatul sau olimpiada, precum \u0219i gestionarea presiunii \u0219i a situa\u021biilor mai dificile.</p>","tags":["meta","sfaturi"]},{"location":"mediu/contest-improvement/#articole-suplimentare","title":"Articole suplimentare","text":"<ul> <li>Cum ajungi s\u0103 iei rezultate tot mai bune la olimpiad\u0103?</li> <li>Cum s\u0103 te preg\u0103te\u0219ti pentru bacalaureat \u0219i admitere?</li> <li>Cum gestionezi presiunea concursurilor?</li> <li>Ghid complet pentru concursurile de informatica -   infoarena</li> <li>Psihologia concursurilor de informatica -   Algopedia</li> </ul>","tags":["meta","sfaturi"]},{"location":"mediu/contest-list/","title":"List\u0103 de concursuri relevante","text":"<p>Pe l\u00e2ng\u0103 olimpiada de informatic\u0103, prezentat\u0103 mai devreme \u00een acest articol, exist\u0103 numeroase concursuri \u0219i olimpiade pentru elevii de gimnaziu, liceu \u0219i chiar \u0219i pentru studen\u021bi. Nu \u00een ultimul r\u00e2nd, exist\u0103 numeroase platforme cu concursuri online cu diverse reguli care permit oric\u0103rui entuziast de algoritmic\u0103 s\u0103 se men\u021bin\u0103 \u00een form\u0103 \u0219i de ce nu, s\u0103 devin\u0103 tot mai bun.</p> <p>Aceasta nu este o list\u0103 complet\u0103 a concursurilor, iar de multe ori apar concursuri ce nu sunt neap\u0103rat organizate \u00eentr-un mod regular, a\u0219a c\u0103 recomand\u0103m s\u0103 fi\u021bi pe faz\u0103 pe serverul nostru RoAlgo.</p>","tags":["concursuri","pregatire","olimpiada"]},{"location":"mediu/contest-list/#concursuri-romanesti","title":"Concursuri rom\u00e2ne\u0219ti","text":"<p>\u00cen primul r\u00e2nd, \u021bara noastr\u0103 organizeaz\u0103 o gam\u0103 larg\u0103 de concursuri care au loc \u00een prezent, continu\u00e2nd o tradi\u021bie \u00eendelungat\u0103 a concursurilor de acest fel. Aici voi enumera cele mai importante concursuri, precum \u0219i c\u00e2nd au loc.</p> <p>Multe dintre aceste concursuri, pe l\u00e2ng\u0103 faptul c\u0103 reprezint\u0103 o oportunitate \u00een plus de a te preg\u0103ti pentru olimpiad\u0103, au \u0219i premii generoase \u0219i de asemenea reprezint\u0103 o metod\u0103 de a putea fi admis mai u\u0219or la universit\u0103\u021bile de profil din Rom\u00e2nia.</p> <ul> <li> <p>Olimpiada de Informatic\u0103 pe Echipe (IIOT): Are   loc anual pe parcursul a 4 runde preliminare, o rund\u0103 final\u0103 \u0219i o rund\u0103   interna\u021bional\u0103, rundele preliminare av\u00e2nd loc lunar \u00een perioada   noiembrie-februarie, cu finala na\u021bional\u0103 av\u00e2nd loc \u00een fiecare an la Colegiul   Na\u021bional de Informatic\u0103 Piatra Neam\u021b. \u00cen prezent, este dedicat exclusiv   elevilor de liceu, care pot participa \u00een echipe de 4 membri \u0219i 2 rezerve   din aceea\u0219i \u0219coal\u0103/centru de excelen\u021b\u0103. Problemele din anii anteriori se   g\u0103sesc aici.</p> </li> <li> <p>Concursul na\u021bional \"Urma\u0219ii lui Moisil\": Are   loc \u00een fiecare an, dup\u0103 olimpiada jude\u021bean\u0103 de informatic\u0103, este dedicat   elevilor de liceu \u0219i reune\u0219te cei mai buni elevi din fiecare jude\u021b, av\u00e2nd o   prob\u0103 de dificultate similar\u0103 cu olimpiada na\u021bional\u0103. Problemele din anii   anteriori se g\u0103sesc aici.</p> </li> <li> <p>Concursul   Prosoft@NT este un   concurs de algoritmic\u0103 pentru elevii de liceu care are loc \u00een fiecare an,   concomitent cu runda na\u021bional\u0103 a IIOT, organizat de Colegiul Na\u021bional de   Informatic\u0103 Piatra Neam\u021b.</p> </li> <li> <p>Concursul interjude\u021bean \"Grigore   Moisil\": Are loc \u00een   fiecare an, dup\u0103 olimpiada jude\u021bean\u0103 de informatic\u0103, este dedicat elevilor de   gimnaziu \u0219i liceu \u0219i reune\u0219te elevii de top din Transilvania, Banat, Cri\u0219ana   \u0219i Maramure\u0219, av\u00e2nd o prob\u0103 de dificultate similar\u0103 cu olimpiada na\u021bional\u0103.   Problemele din anii anteriori se g\u0103sesc   aici.</p> </li> <li> <p>Concursul interjude\u021bean \"Info   Oltenia\": Are   loc \u00een fiecare an, de regul\u0103 iarna, este dedicat elevilor de gimnaziu \u0219i liceu   \u0219i reune\u0219te elevii de top din Oltenia, av\u00e2nd o prob\u0103 de dificultate similar\u0103   cu olimpiada jude\u021bean\u0103. Problemele din anii anteriori se g\u0103sesc   aici.</p> </li> <li> <p>Concursul \"Adolescent Grigore Moisil\": Are loc \u00een   fiecare an, pe parcursul a mai multor runde, este dedicat elevilor de gimnaziu   \u0219i liceu \u0219i are reguli similare cu cele ale concursului ICPC (echipe de 3   persoane), dificultatea problemelor fiind ridicat\u0103, nivelul acestora fiind   cuprins \u00eentre ONI \u0219i Lot Seniori. Problemele din anii anteriori se g\u0103sesc   aici.</p> </li> <li> <p>Concursul ICPC \u0219i etapele regionale la care particip\u0103 universit\u0103\u021bile   rom\u00e2ne\u0219ti, RCPC, SEERC \u0219i EUC: Are loc \u00een fiecare an, de   regul\u0103 toamna, este dedicat studen\u021bilor \u0219i dificultatea problemelor este una   ridicat\u0103, scopul final al echipelor este acela de a avansa la finala mondial\u0103,   ce are loc de regul\u0103 anual. Problemele din anii anteriori se g\u0103sesc pe   Codeforces, Infoarena \u0219i alte site-uri specifice ICPC.</p> </li> </ul>","tags":["concursuri","pregatire","olimpiada"]},{"location":"mediu/contest-list/#concursuri-internationale-cu-participare-romaneasca","title":"Concursuri interna\u021bionale cu participare rom\u00e2neasc\u0103","text":"<ul> <li> <p>Olimpiada Interna\u021bional\u0103 de Informatic\u0103 (IOI)   este cel mai important concurs de algoritmic\u0103 pentru elevi la nivel mondial,   reunind cei mai buni 4 elevi din fiecare \u021bar\u0103 participant\u0103. \u00cen 2024, au   participat elevi din peste 90 de \u021b\u0103ri, Rom\u00e2nia ob\u021bin\u00e2nd o medalie de aur,   dou\u0103 de argint \u0219i una de bronz. Nivelul de dificultate al problemelor este   foarte ridicat, fiind menit s\u0103 testeze p\u00e2n\u0103 \u0219i cei mai buni elevi la nivel   mondial.</p> </li> <li> <p>Olimpiada Europei Centrale de Informatic\u0103   (CEOI) este un concurs de algoritmic\u0103 pentru   elevii \u021b\u0103rilor Europei Centrale, reunind 4 dintre cei mai buni elevi din   fiecare \u021bar\u0103 participant\u0103. \u00cen 2024, au participat elevi din 14 \u021b\u0103ri, Rom\u00e2nia   ob\u021bin\u00e2nd trei medalii de argint \u0219i una de bronz. Nivelul de dificultate al   problemelor este ridicat, fiind menit s\u0103 testeze p\u00e2n\u0103 \u0219i cei mai buni elevi \u00een   vederea IOI.</p> </li> <li> <p>Olimpiada Balcanic\u0103 de Informatic\u0103 (BOI) este un   concurs de algoritmic\u0103 pentru elevii \u021b\u0103rilor din Peninsula Balcanic\u0103, reunind   4 dintre cei mai buni elevi din fiecare \u021bar\u0103 participant\u0103. \u00cen 2024,   particip\u0103 elevi din 15 \u021b\u0103ri, iar Rom\u00e2nia a ob\u021binut (aici voi pune ce au   ob\u021binut, concursul nu a avut loc \u00eenc\u0103). Nivelul de dificultate al problemelor   este ridicat, fiind menit s\u0103 testeze p\u00e2n\u0103 \u0219i cei mai buni elevi \u00een vederea   IOI.</p> </li> <li> <p>Olimpiada European\u0103 de Informatic\u0103 pentru Fete (EGOI)   este un concurs de algoritmic\u0103 pentru fete la nivel european \u0219i nu numai,   reunind cele mai bune eleve din fiecare \u021bar\u0103 participant\u0103. Nivelul de   dificultate al problemelor este ridicat, dar sub cel al IOI. \u00cen 2024,   Rom\u00e2nia a ob\u021binut dou\u0103 medalii de argint \u0219i dou\u0103 de bronz.</p> </li> <li> <p>Olimpiada European\u0103 de Informatic\u0103 pentru Juniori   (EJOI) este cel mai important concurs de   algoritmic\u0103 pentru juniori (elevi care au cel mult 15 ani) la nivel   european, reunind cei mai buni 4 juniori din \u021b\u0103rile participante. \u00cen 2024,   Rom\u00e2nia a ob\u021binut dou\u0103 medalii de aur \u0219i dou\u0103 de argint.</p> </li> <li> <p>Olimpiada Balcanic\u0103 de Informatic\u0103 pentru Juniori   (JBOI) este un concurs de algoritmic\u0103 pentru   juniorii \u021b\u0103rilor din Peninsula Balcanic\u0103, reunind 4 dintre cei mai buni   juniori din fiecare \u021bar\u0103 participant\u0103. \u00cen 2024, Rom\u00e2nia a ob\u021binut trei   medalii de aur \u0219i una de argint.</p> </li> <li> <p>Concursul Info(1)Cup este un concurs de   algoritmic\u0103 pentru juniori la nivel mondial, reunind unii cei mai buni juniori   din fiecare \u021bar\u0103 participant\u0103. Acest concurs este organizat \u00een fiecare an de   Centrul Jude\u021bean de Excelen\u021b\u0103 Prahova. \u00cen fiecare an, Rom\u00e2nia are o   participare numeroas\u0103, juniorii ob\u021bin\u00e2nd rezultate dintre cele mai bune.</p> </li> <li> <p>Turneul de Informatic\u0103 de la Shumen (IATI) este un   concurs de algoritmic\u0103 pentru juniori \u0219i seniori la nivel regional, reunind   unii cei mai buni elevi din fiecare \u021bar\u0103 participant\u0103. Acest concurs este   organizat \u00een fiecare an \u00een Shumen, Bulgaria. \u00cen fiecare an, Rom\u00e2nia are o   participare numeroas\u0103, elevii participan\u021bi ob\u021bin\u00e2nd rezultate dintre cele mai   bune.</p> </li> <li> <p>Romanian Masters of Informatics (RMI) este un   concurs de algoritmic\u0103 pentru juniori \u0219i seniori la nivel regional, reunind   unii cei mai buni elevi din fiecare \u021bar\u0103 participant\u0103. Acest concurs este   organizat \u00een fiecare an de Colegiul Na\u021bional de Informatic\u0103 \"Tudor Vianu\",   Bucure\u0219ti. \u00cen fiecare an, Rom\u00e2nia are o participare numeroas\u0103, elevii   participan\u021bi ob\u021bin\u00e2nd rezultate dintre cele mai bune.</p> </li> </ul>","tags":["concursuri","pregatire","olimpiada"]},{"location":"mediu/contest-list/#concursuri-online","title":"Concursuri online","text":"<p>Majoritatea platformelor cu concursuri online propun runde pe stilul ICPC, unde pentru o problem\u0103, trebuie trecute toate testele pentru a primi puncte (cu alte cuvinte, exact cum ar fi olimpiada dac\u0103 singurele punctaje posibile ar fi 0 sau 100 de puncte). Totu\u0219i, exist\u0103 \u0219i olimpiade care ofer\u0103 posibilitatea unor runde mirror dup\u0103 sau chiar \u00een timpul rundelor oficiale.</p> <ul> <li> <p>Codeforces este una din cele mai populare platforme   unde au loc concursuri online de algoritmic\u0103 la nivel mondial. De regul\u0103, au   loc aproximativ dou\u0103 concursuri pe s\u0103pt\u0103m\u00e2n\u0103, nivelul lor variaz\u0103 de la Div. 4   la Div. 1, \u00een ordine cresc\u0103toare a dificult\u0103\u021bii. Un concurs dureaz\u0103 \u00eentre 2   \u0219i 3 ore \u0219i are \u00eentre 5 \u0219i 9 probleme, ordonate cresc\u0103tor dup\u0103   dificultate. Pentru a deveni tot mai bun la aceste concursuri, po\u021bi folosi   facilit\u0103\u021bile pe care le avem \u00een exclusivitate \u00een Rom\u00e2nia pe serverul   RoAlgo, unde po\u021bi folosi botul   TLE pentru a primi cele mai   interesante sugestii de probleme, concursuri, dueluri \u0219i multe alte beneficii.   Problemele de pe acest site tind s\u0103 fie mai ad-hoc \u00een natur\u0103, cu excep\u021bia   celor de la Div. 3 \u0219i Div. 4, care sunt o surs\u0103 foarte bun\u0103 de tehnici   educa\u021bionale.</p> </li> <li> <p>AtCoder este o alt\u0103 platform\u0103 popular\u0103 unde au loc   concursuri online de algoritmic\u0103 la nivel mondial. De regul\u0103, se organizeaz\u0103   un concurs pe s\u0103pt\u0103m\u00e2n\u0103, nivelul lor variaz\u0103 de la ABC la AGC, \u00een ordine   cresc\u0103toare a dificult\u0103\u021bii. Un concurs dureaz\u0103 \u00eentre 2 \u0219i 3 ore \u0219i are   \u00eentre 6 \u0219i 8 probleme, ordonate cresc\u0103tor dup\u0103 dificultate. Problemele de   pe acest site tind s\u0103 fie mai matematice \u00een natur\u0103, cu excep\u021bia celor de la   ABC, care sunt o surs\u0103 foarte bun\u0103 de tehnici educa\u021bionale.</p> </li> <li> <p>Concursurile de pe Kilonova \u0219i \u00een special RoAlgo   Contests sunt foarte utile pentru   exersarea diverselor tehnici, organiz\u00e2ndu-se runde foarte importante precum   concursurile de tip PreOJI, care sunt menite pentru a testa abilit\u0103\u021bile   concuren\u021bilor \u00eenainte de Olimpiada de informatic\u0103.</p> </li> <li> <p>LeetCode este o platform\u0103 popular\u0103 unde au loc   concursuri online de algoritmic\u0103 la nivel mondial, problemele fiind propuse \u00een   special pe modelul celor de la interviurile de angajare. De regul\u0103, se   organizeaz\u0103 un concurs pe s\u0103pt\u0103m\u00e2n\u0103, nivelul lor este unul mai sc\u0103zut,   con\u021bin\u00e2nd 4 probleme ce trebuie rezolvate \u00een cel mult 2 ore, ordonate   cresc\u0103tor dup\u0103 dificultate.</p> </li> <li> <p>USACO este siteul oficial al Olimpiadei de Informatic\u0103 a   Statelor Unite, aceasta organiz\u00e2nd 4 concursuri \u00een fiecare an, \u00een perioada   decembrie-martie. Concursurile sunt \u00eemp\u0103r\u021bite pe divizii, Bronze fiind cea mai   simpl\u0103, apoi Silver, Gold \u0219i Platinum, formatul concursurilor fiind similar   celor de la olimpiad\u0103. Se recomand\u0103 participarea la acest concurs pentru cei   care vor s\u0103 ob\u021bin\u0103 rezultate bune la olimpiad\u0103, \u00een special datorit\u0103   flexibilit\u0103\u021bii pe care o au (fiecare concurs se poate da \u00eentr-un interval de   4 zile).</p> </li> <li> <p>COCI este siteul oficial al Olimpiadei de Informatic\u0103   a Croa\u021biei, aceasta organiz\u00e2nd \\(6-8\\) concursuri \u00een fiecare an, \u00een perioada   noiembrie-aprilie. Concursurile au \\(3-4\\) ore \u0219i se recomand\u0103 participarea la   acest concurs pentru cei care vor s\u0103 ob\u021bin\u0103 rezultate bune la olimpiad\u0103,   problemele fiind de un nivel variat.</p> </li> <li> <p>JOI este siteul oficial al Olimpiadei de   Informatic\u0103 a Japoniei, aceasta organiz\u00e2nd \\(6-8\\) concursuri \u00een fiecare an, \u00een   perioada februarie-mai. Concursurile au 5 ore \u0219i se recomand\u0103 participarea   la acest concurs pentru cei care vor s\u0103 ob\u021bin\u0103 rezultate bune la olimpiad\u0103,   problemele fiind de un nivel ridicat, de multe ori cele mai grele probleme   sunt mai grele dec\u00e2t problemele de la lotul Rom\u00e2niei de informatic\u0103.</p> </li> </ul>","tags":["concursuri","pregatire","olimpiada"]},{"location":"mediu/contest-list/#alte-concursuri","title":"Alte concursuri","text":"<p>Pentru mai multe informa\u021bii \u0219i concursuri, pute\u021bi verifica aceste liste de pe USACO Guide, precum \u0219i celelalte liste de concursuri de mai jos. Nu \u00een ultimul r\u00e2nd, pe serverul RoAlgo v\u0103 \u021binem la curent cu concursurile care apar.</p> <ul> <li>Concursuri</li> <li>Olimpiade</li> <li>Gym Codeforces - cuprinde at\u00e2t olimpiade, c\u00e2t   \u0219i runde de tip ICPC.</li> <li>Clist - list\u0103 cu toate concursurile de algoritmic\u0103   posibile, totu\u0219i multe dintre ele nu sunt relevante.</li> </ul>","tags":["concursuri","pregatire","olimpiada"]},{"location":"mediu/cycles/","title":"Cicluri \u00een grafuri. Grafuri func\u021bionale","text":"","tags":["C++","implementare","grafuri","cicluri"]},{"location":"mediu/cycles/#introducere","title":"Introducere","text":"<p>\u00cen general, c\u00e2nd vine vorba de lucrul cu cicluri \u00een problemele cu grafuri, lucrurile pot fi mai dificile, iar din acest motiv vrem s\u0103 formaliz\u0103m procesul de aflare a unor cicluri \u00een grafuri, fie c\u0103 e vorba de grafuri orientate sau neorientate, iar mai apoi vom discuta \u0219i despre un tip special de grafuri, grafurile func\u021bionale.</p> <p>Vom \u00eencepe prin a relua defini\u021bia discutat\u0103 la articolul anterior despre grafuri.</p> <p>Ciclu</p> <p>O secven\u021b\u0103 de muchii \\((v_1, v_2, ..., v_k, v_1)\\) formeaz\u0103 un ciclu dac\u0103 \\((v_i, v_{i + 1}) \\in E\\) pentru orice \\(1 \\leq i &lt; k\\) \u0219i \\((v_k, v_1) \\in E\\). Un ciclu este simplu dac\u0103 \\(v_i \\neq v_j\\) pentru orice \\(1 \\leq i &lt; j &lt; k\\).</p> <p>Altfel spus, un ciclu reprezint\u0103 o secven\u021b\u0103 de muchii ce nu se repet\u0103, pleac\u0103 de la un nod \\(v_1\\) \u0219i parcurg\u00e2nd \u00een ordine acele muchii, se ajunge tot la nodul \\(v_1\\). Un ciclu simplu este un ciclu \u00een care nu se repet\u0103 noduri.</p> <p>\u00cen cele ce urmeaz\u0103, vom prezenta c\u00e2teva tehnici care pleac\u0103 de la cunoa\u0219terea ciclurilor \u00een grafuri, precum \u0219i modurile \u00een care acestea pot fi implementate. Modul de implementare a acestor algoritmi va fi exclusiv folosind structuri \u0219i metode din STL, scopul acestor aplica\u021bii fiind \u00een special aplica\u021biile care apar la olimpiadele \u0219i concursurile de informatic\u0103.</p>","tags":["C++","implementare","grafuri","cicluri"]},{"location":"mediu/cycles/#cicluri-euleriene","title":"Cicluri euleriene","text":"<p>Ciclu eulerian</p> <p>Un lan\u021b eulerian este un lan\u021b care con\u021bine toate muchiile exact o singur\u0103 dat\u0103 (dar nodurile se pot vizita iar). Un ciclu eulerian este un lan\u021b eulerian care \u00eencepe \u0219i se termin\u0103 \u00een acela\u0219i nod.</p> <p>Gradele nodurilor</p> <p>Mai \u00eent\u00e2i, o condi\u021bie necesar\u0103 \u0219i suficient\u0103 este aceea c\u0103 toate nodurile trebuie s\u0103 poat\u0103 fi vizitate, iar gradele nodurilor s\u0103 fie pare.</p> <p>Acest lucru poate fi ar\u0103tat u\u0219or, presupun\u00e2nd c\u0103 putem avea un ciclu eulerian care s\u0103 con\u021bin\u0103 un nod cu grad impar. Dac\u0103 \u00eencepem ciclul nostru acolo, nu \u00eel vom putea termina acolo, deoarece dup\u0103 ce folosim o muchie s\u0103 p\u0103r\u0103sim nodul, vom avea un num\u0103r par de muchii adiacente nodului curent. Jum\u0103tate dintre ele ar trebui s\u0103 fie folosite pentru a intra acolo, cealalt\u0103 jum\u0103tate pentru a ie\u0219i, deci am fi nevoi\u021bi s\u0103 ie\u0219im de acolo cu ultima muchie, contradic\u021bie. Dac\u0103 nu \u00eencepem acolo, vom fi la un moment dat bloca\u021bi, deci avem iar contradic\u021bie.</p> <p>Lan\u021b eulerian c\u00e2nd avem noduri cu grad impar</p> <p>Totu\u0219i, putem construi un lan\u021b eulerian dac\u0103 avem noduri cu grad impar, at\u00e2ta timp c\u00e2t avem exact dou\u0103 noduri cu grad impar \u0219i \u00eencepem \u0219i termin\u0103m \u00een nodurile cu grad impar.</p> <p>Pentru a afla dac\u0103 graful dat admite un ciclu eulerian, vom putea folosi algoritmul lui Fleury.</p> <p>Algoritmul lui Fleury este unul recursiv, acesta baz\u00e2ndu-se pe faptul c\u0103 pentru un nod oarecare, at\u00e2ta timp c\u00e2t mai avem muchii adiacente cu el care nu au fost folosite, vom apela recursiv func\u021bia pentru nodul adiacent muchiei curente. Dac\u0103 la un moment dat avem o muchie nefolosit\u0103, o marc\u0103m drept vizitat\u0103 \u0219i mergem mai departe. Se remarc\u0103 faptul c\u0103 nodurile sunt ad\u0103ugate la r\u0103spuns \u00een ordinea invers\u0103 \u00een care apel\u0103m func\u021biile.</p> <p>\u00cen general, dac\u0103 identific\u0103m faptul c\u0103 o problem\u0103 necesit\u0103 cicluri euleriene, odat\u0103 ce avem implementarea de baz\u0103 complet\u0103, o mare parte din problem\u0103 este complet\u0103, algoritmul fiind relativ u\u0219or de \u00eenv\u0103\u021bat.</p> <p>Mai jos se poate observa o implementare C++ pentru problema ciclueuler de pe infoarena.</p> <pre><code>#include &lt;fstream&gt;\n#include &lt;vector&gt;\n\nusing namespace std;\n\nvector&lt;vector&lt;pair&lt;int, int&gt;&gt;&gt; graph;\nvector&lt;int&gt; grad, visN, visM, sol;\n\nvoid dfs(int node) {\n    visN[node] = 1;\n    for (auto next : graph[node]) {\n        if (!visN[next.first]) {\n            dfs(next.first);\n        }\n    }\n}\n\nvoid euler(int node) {\n    while (graph[node].size() &gt; 0) {\n        int next = graph[node].back().first;\n        int next_edge = graph[node].back().second;\n        graph[node].pop_back();\n        if (!visM[next_edge]) {\n            visM[next_edge] = 1;\n            euler(next);\n        }\n    }\n    sol.push_back(node);\n}\n\nint main() {\n    ifstream cin(\"ciclueuler.in\");\n    ofstream cout(\"ciclueuler.out\");\n\n    int n, m;\n    cin &gt;&gt; n &gt;&gt; m;\n\n    graph.resize(n + 1);\n    grad.resize(n + 1);\n    visN.resize(n + 1);\n    visM.resize(m + 1);\n\n    for (int i = 1; i &lt;= m; i++) {\n        int a, b;\n        cin &gt;&gt; a &gt;&gt; b;\n        grad[a]++;\n        grad[b]++;\n        graph[a].push_back({b, i});\n        graph[b].push_back({a, i});\n    }\n    dfs(1);\n\n    // daca exista un nod nevizitat sau gradul lui e impar, nu avem ciclu\n    // eulerian\n    int ok = 1;\n    for (int i = 1; i &lt;= n; i++) {\n        if (visN[i] == 0 || grad[i] % 2 == 1) {\n            ok = 0;\n        }\n    }\n    if (ok == 0) {\n        cout &lt;&lt; -1 &lt;&lt; '\\n';\n    } else {\n        euler(1);\n        sol.pop_back();\n        for (auto node : sol) {\n            cout &lt;&lt; node &lt;&lt; \" \";\n        }\n    }\n    return 0;\n}\n</code></pre> <p>Observa\u021bie</p> <p>Algoritmul lui Fleury se poate implementa \u0219i iterativ, folosind un principiu similar cu cel descris mai sus, implementarea put\u00e2nd fi f\u0103cut\u0103 cu o stiv\u0103 sau un deque.</p> <pre><code>deque&lt;int&gt; dq;\ndq.push_back(1);\nwhile (!dq.empty()) {\n    x = dq.back();\n    while (!v[x].empty() &amp;&amp; vizitat[v[x].back().first]) {\n        v[x].pop_back();\n    }\n    if (v[x].empty()) {\n        dq.pop_back();\n        ans.push_back(x);\n    } else {\n        vizitat[v[x].back().first] = true;\n        dq.push_back(v[x].back().second);\n        v[x].pop_back();\n    }\n}\n</code></pre>","tags":["C++","implementare","grafuri","cicluri"]},{"location":"mediu/cycles/#problema-exemplu-domino","title":"Problem\u0103 exemplu - Domino","text":"<p>Aceast\u0103 problem\u0103 se reduce la aflarea unui lan\u021b eulerian \u00een graful descris \u00een enun\u021b.</p> <p>Graful din enun\u021b are doar 10 noduri \u0219i vom folosi propriet\u0103\u021bile descrise mai devreme \u00een articol, unde am men\u021bionat faptul c\u0103 este obligatoriu s\u0103 \u00eencepem dintr-un nod cu grad impar pentru a avea lan\u021b eulerian. Dac\u0103 toate nodurile au grad par, nu conteaz\u0103 de unde \u00eencepem.</p> <p>Dac\u0103 avem mai mult de 2 noduri cu grad impar, atunci nu avem solu\u021bie. \u00cen mod similar, \u0219i dac\u0103 nu putem parcurge toate muchiile.</p> <p>Observa\u021bie</p> <p>Se poate observa faptul c\u0103 algoritmul dat este foarte similar cu cel descris pentru ciclul eulerian.</p> <pre><code>#include &lt;algorithm&gt;\n#include &lt;fstream&gt;\n#include &lt;vector&gt;\n\nusing namespace std;\n\nvector&lt;vector&lt;pair&lt;int, int&gt;&gt;&gt; graph;\nvector&lt;int&gt; grad, visM;\n\nvector&lt;pair&lt;int, int&gt;&gt; sol;\nvoid euler(int node) {\n    while (graph[node].size() &gt; 0) {\n        int next = graph[node].back().first;\n        int next_edge = graph[node].back().second;\n        int sgn = 0;\n        if (next_edge &lt; 0) {\n            next_edge *= -1;\n            sgn = 1;\n        }\n        graph[node].pop_back();\n        if (!visM[next_edge]) {\n            visM[next_edge] = 1;\n            euler(next);\n            sol.push_back({next_edge, sgn});\n        }\n    }\n}\n\nint main() {\n    ifstream cin(\"domino.in\");\n    ofstream cout(\"domino.out\");\n\n    int n;\n    cin &gt;&gt; n;\n\n    graph.resize(10);\n    grad.resize(10);\n    visM.resize(n + 1);\n\n    for (int i = 1; i &lt;= n; i++) {\n        int a, b;\n        cin &gt;&gt; a &gt;&gt; b;\n        grad[a]++;\n        grad[b]++;\n        graph[a].push_back({b, i});\n        graph[b].push_back({a, -i});\n    }\n\n    int impar = 0;\n    int ok = -1;\n    for (int i = 0; i &lt;= 9; i++) {\n        if (grad[i] &gt; 0) {\n            if (grad[i] % 2 == 1) {\n                ok = i;\n                impar++;\n            } else {\n                if (ok == -1) {\n                    ok = i;\n                }\n            }\n        }\n    }\n    if (impar != 0 &amp;&amp; impar != 2) {\n        cout &lt;&lt; 0 &lt;&lt; '\\n';\n    } else {\n        euler(ok);\n        if ((int)sol.size() != n) {\n            cout &lt;&lt; 0 &lt;&lt; '\\n';\n        } else {\n            cout &lt;&lt; 1 &lt;&lt; '\\n';\n            reverse(sol.begin(), sol.end());\n            for (auto x : sol) {\n                cout &lt;&lt; x.first &lt;&lt; \" \" &lt;&lt; x.second &lt;&lt; '\\n';\n            }\n        }\n    }\n    return 0;\n}\n</code></pre>","tags":["C++","implementare","grafuri","cicluri"]},{"location":"mediu/cycles/#cicluri-hamiltoniene","title":"Cicluri hamiltoniene","text":"<p>Ciclu hamiltonian</p> <p>Un lan\u021b hamiltonian este un lan\u021b care con\u021bine toate nodurile exact o singur\u0103 dat\u0103. \u00cen mod similar, un ciclu hamiltonian este un ciclu care con\u021bine toate nodurile exact o singur\u0103 dat\u0103.</p> <p>\u00cen general, pentru a afla un ciclu hamiltonian, putem folosi metode de tip brute-force, precum backtracking.</p> <p>Aici pute\u021bi g\u0103si implementarea \u00een C++ pentru problema Hamilton de pe pbinfo.</p> <p>Se poate observa c\u0103 pentru a optimiza implementarea, am folosit o masc\u0103 pe bi\u021bi pentru a \u021bine nodurile deja vizitate, dar algoritmul va r\u0103m\u00e2ne unul exponen\u021bial din punct de vedere al timpului \u0219i memoriei utilizate.</p> <pre><code>#include &lt;fstream&gt;\n#include &lt;vector&gt;\n\nusing namespace std;\n\nint n;\nvector&lt;vector&lt;int&gt;&gt; graph;\nvector&lt;int&gt; sol, cd;\n\nint ord[11];\n\nvoid bkt(int node, int msk) {\n    ord[++ord[0]] = node;\n    if (!sol.empty()) {\n        return;\n    }\n    for (auto x : graph[node]) {\n        if (msk == (1 &lt;&lt; n) - 1 &amp;&amp; x == 1) {\n            for (int i = 1; i &lt;= ord[0]; i++) {\n                sol.push_back(ord[i]);\n            }\n            sol.push_back(1);\n            return;\n        }\n        if (msk &amp; (1 &lt;&lt; (x - 1))) {\n            continue;\n        }\n        bkt(x, msk ^ (1 &lt;&lt; (x - 1)));\n    }\n    --ord[0];\n}\nint main() {\n    ifstream cin(\"hamilton.in\");\n    ofstream cout(\"hamilton.out\");\n\n    cin &gt;&gt; n;\n    graph.resize(n + 1);\n\n    int a, b;\n    while (cin &gt;&gt; a &gt;&gt; b) {\n        graph[a].push_back(b);\n        graph[b].push_back(a);\n    }\n\n    bkt(1, 1);\n\n    if (sol.empty()) {\n        cout &lt;&lt; 0 &lt;&lt; '\\n';\n    } else {\n        cout &lt;&lt; 1 &lt;&lt; '\\n';\n        for (auto x : sol) {\n            cout &lt;&lt; x &lt;&lt; \" \";\n        }\n    }\n    return 0;\n}\n</code></pre> <p>Ulterior, \u00een alte probleme precum cele \u00een care avem nevoie de dinamici pe m\u0103\u0219ti, vom discuta aplica\u021bii avansate ale acestor cicluri, a\u0219a cum sunt prezentate \u00een acest articol.</p>","tags":["C++","implementare","grafuri","cicluri"]},{"location":"mediu/cycles/#grafuri-functionale","title":"Grafuri func\u021bionale","text":"<p>Grafuri func\u021bionale</p> <p>Un graf func\u021bional este un graf orientat cu \\(n\\) noduri \u0219i \\(n\\) muchii, cu proprietatea c\u0103 fiecare nod are o singur\u0103 muchie care pleac\u0103 din el.</p> <p>Cu alte cuvinte, aceste grafuri sunt o reuniune de cicluri, \u00eempreun\u0103 cu ni\u0219te lan\u021buri ata\u0219ate de ele.</p> <p>Aceste grafuri, datorit\u0103 formei lor speciale, au multe propriet\u0103\u021bi interesante \u0219i fac prelucrarea lor mai u\u0219oar\u0103. De multe ori, vom vrea s\u0103 filtr\u0103m nodurile care nu fac parte din cicluri, iar mai apoi, s\u0103 lucr\u0103m cu fiecare ciclu \u00een mod independent. Vom folosi c\u00e2teva exemple pentru a prezenta acest concept \u00een diverse probleme de la competi\u021bii de informatic\u0103.</p> <p>Ciclurile permutarilor</p> <p>P\u00e2n\u0103 c\u00e2nd v\u0103 uita\u021bi peste problemele de mai jos, recomand\u0103m citirea acestei sec\u021biuni a articolului despre permut\u0103ri, unde se vorbe\u0219te de ciclurile unei permut\u0103ri \u0219i aplica\u021biile care implic\u0103 grafuri func\u021bionale</p>","tags":["C++","implementare","grafuri","cicluri"]},{"location":"mediu/cycles/#problema-exemplu-mouse-hunt-codeforces","title":"Problem\u0103 exemplu - Mouse Hunt - Codeforces","text":"<p>Pentru a rezolva aceast\u0103 problem\u0103, vrem s\u0103 filtr\u0103m nodurile care nu apar\u021bin ciclurilor, iar algoritmul pe care \u00eel vom prezenta mai jos va fi unul standard, care va fi aplicat \u00een multe asemenea probleme.</p> <p>Practic, vom vrea s\u0103 plec\u0103m de la fiecare nod nevizitat \u0219i s\u0103 parcurgem graful p\u00e2n\u0103 c\u00e2nd d\u0103m de un nod deja vizitat. Apoi, vom vrea s\u0103 reconstruim ciclul care pleac\u0103 de la nodul vizitat, dac\u0103 acest pas este prima oar\u0103 c\u00e2nd am vizitat nodul \u00een cauz\u0103.</p> <pre><code>#include &lt;iostream&gt;\n#include &lt;vector&gt;\n\nusing namespace std;\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n\n    int n;\n    cin &gt;&gt; n;\n\n    vector&lt;int&gt; costs(n + 1), graph(n + 1);\n    for (int i = 1; i &lt;= n; i++) {\n        cin &gt;&gt; costs[i];\n    }\n    for (int i = 1; i &lt;= n; i++) {\n        cin &gt;&gt; graph[i];\n    }\n\n    int ans = 0;\n\n    vector&lt;int&gt; visited(n + 1), processed(n + 1);\n    for (int i = 1; i &lt;= n; i++) {\n        if (!visited[i]) {\n            int node = i;\n            // parcurgem graful\n            while (!visited[node]) {\n                visited[node] = 1;\n                node = graph[node];\n            }\n\n            if (!processed[node]) {\n                int mini = 1000000000;\n                // aflam ciclul\n                while (!processed[node]) {\n                    mini = min(mini, costs[node]);\n                    processed[node] = i;\n                    node = graph[node];\n                }\n                if (processed[node] == i) {\n                    ans += mini;\n                }\n            }\n        }\n    }\n\n    cout &lt;&lt; ans &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["C++","implementare","grafuri","cicluri"]},{"location":"mediu/cycles/#problema-suplimentara-milk-exchange-usaco-bronze","title":"Problem\u0103 suplimentar\u0103 - Milk Exchange - USACO Bronze","text":"<p>Pentru a rezolva aceast\u0103 problem\u0103, va trebui s\u0103 reducem \u0219irul dat la un graf func\u021bional, graf pentru care \u0219tim c\u0103 unele noduri vor fi noduri de unde doar se va da lapte, iar alte noduri sunt noduri care doar vor primi lapte. Nodurile din prima categorie vor da treptat laptele celor din cea de-a doua categorie.</p> <p>Astfel, vom afla ciclurile \u00eencep\u00e2nd din fiecare nod care va da lapte, iar pe parcurs, vom \u00eensuma cantit\u0103\u021bile de lapte \u0219i vom verifica dac\u0103 avem nevoie de mai mult de \\(m\\) secunde pentru a finaliza procesul.</p> <p>Cu alte cuvinte, vom rezolva problema independent pentru fiecare ciclu din graf.</p> <pre><code>#include &lt;iostream&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\nint n, v[200002], cnt[200002], vis[200002], nxt[200002];\nlong long m;\nstring s;\n\nlong long sum = 0;\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n\n    cin &gt;&gt; n &gt;&gt; m;\n    cin &gt;&gt; s;\n    s = ' ' + s;  // 1-index string\n\n    for (int i = 1; i &lt;= n; i++) {\n        cin &gt;&gt; v[i];\n        sum += v[i];\n    }\n\n    for (int i = 1; i &lt;= n; i++) {\n        if (s[i] == 'L') {\n            if (i == 1) {\n                cnt[n]++, nxt[i] = n;\n            } else {\n                cnt[i - 1]++, nxt[i] = i - 1;\n            }\n        } else {\n            if (i == n) {\n                cnt[1]++, nxt[i] = 1;\n            } else {\n                cnt[i + 1]++, nxt[i] = i + 1;\n            }\n        }\n    }\n\n    for (int i = 1; i &lt;= n; i++) {\n        if (vis[i] == 0 &amp;&amp; cnt[i] == 0) {\n            vector&lt;int&gt; cycle;\n            int pos = i;\n            while (vis[pos] == 0) {\n                vis[pos] = 1;\n                cycle.push_back(pos);\n                pos = nxt[pos];\n            }\n            long long noncyclesum = 0;\n            for (int j = 0; j &lt; (int)cycle.size() &amp;&amp; cycle[j] != pos; j++) {\n                noncyclesum += v[cycle[j]];\n            }\n            sum -= min(m, noncyclesum);\n        }\n    }\n\n    cout &lt;&lt; sum &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["C++","implementare","grafuri","cicluri"]},{"location":"mediu/cycles/#problema-cyclic-operations-codeforces","title":"Problema Cyclic Operations - Codeforces","text":"<p>Pentru a rezolva aceast\u0103 problem\u0103, putem observa mai \u00eent\u00e2i faptul c\u0103 cazul \\(k = 1\\) este u\u0219or de tratat, deoarece graful din \u0219ir trebuie s\u0103 aib\u0103 doar bucle. \u00cen caz contrar, trebuie s\u0103 verific\u0103m dac\u0103 toate ciclurile din componentele conexe create de graful dat au lungime \\(k\\).</p> <p>Acest lucru poate fi u\u0219or demonstrat folosind periodicitatea opera\u021biei date \u00een enun\u021b. Pentru mai multe detalii, recomand\u0103m citirea solu\u021biei oficiale.</p> <pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n\nint n, k;\nvector&lt;vector&lt;int&gt; &gt; graph;\nvector&lt;int&gt; visited;\nvector&lt;int&gt; prv;\n\nbool ok;\n\nvector&lt;int&gt; vals;\nvoid dfs(int nod) {\n    if (ok == 0) {\n        return;\n    }\n\n    vals.push_back(nod);\n    prv[nod] = vals.size();\n\n    for (int i = 0; i &lt; graph[nod].size(); i++) {\n        int poz = graph[nod][i];\n        if (prv[poz] != 0) {\n            if ((vals.size() + 1 - prv[poz]) != k) {\n                ok = 0;\n                break;\n            }\n        } else {\n            if (!visited[nod]) {\n                dfs(poz);\n            }\n        }\n    }\n    visited[nod] = 1;\n    prv[nod] = 0;\n    vals.pop_back();\n}\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n\n    int t;\n    cin &gt;&gt; t;\n\n    for (; t; t--) {\n        cin &gt;&gt; n &gt;&gt; k;\n        vector&lt;int&gt; v(n + 1);\n\n        graph.resize(n + 1);\n        visited.resize(n + 1);\n        prv.resize(n + 1);\n        vals.clear();\n\n        for (int i = 1; i &lt;= n; i++) {\n            cin &gt;&gt; v[i], visited[i] = 0;\n            graph[i].push_back(v[i]);\n        }\n\n        ok = 1;\n\n        if (k == 1) {\n            for (int i = 1; i &lt;= n; i++) {\n                if (v[i] != i) {\n                    ok = 0;\n                }\n            }\n        } else {\n            for (int i = 1; i &lt;= n; i++) {\n                if (!visited[i]) {\n                    dfs(i);\n                }\n            }\n\n            cout &lt;&lt; (ok == 1 ? \"YES\" : \"NO\") &lt;&lt; '\\n';\n\n            graph.clear();\n            visited.clear();\n            prv.clear();\n        }\n        return 0;\n    }\n</code></pre>","tags":["C++","implementare","grafuri","cicluri"]},{"location":"mediu/cycles/#concluzii","title":"Concluzii","text":"<p>Lucrul cu cicluri este important \u00een ceea ce prive\u0219te teoria grafurilor, iar observarea diverselor propriet\u0103\u021bi pe care ciclurile le au poate fi important\u0103 \u00een contextul a multor probleme de teoria grafurilor, dar \u0219i ulterior, atunci c\u00e2nd ve\u021bi \u00eenv\u0103\u021ba unii algoritmi mai dificili, precum aceia pentru componentele tare conexe sau componentele biconexe.</p>","tags":["C++","implementare","grafuri","cicluri"]},{"location":"mediu/cycles/#probleme-suplimentare","title":"Probleme suplimentare","text":"<ul> <li>CSES Mail Delivery</li> <li>pbinfo drum hamiltonian</li> <li>Codeforces Badge</li> <li>CSES Teleporters Path</li> <li>OJI 2014 cartite</li> <li>USACO Bronze Swapity   Swap</li> <li>USACO Silver Bovine   Shuffle</li> <li>CSES Planets Cycles</li> <li>Codeforces Lucky Permutation</li> <li>infoarena domino</li> <li>infoarena johnie</li> <li>USACO Silver Redistributing   Gifts</li> <li>Codeforces Yet Another Sorting   Problem</li> <li>Codeforces Jewel of Data Structure   Problems</li> <li>Codeforces Shifting String</li> <li>USACO Silver Visits</li> <li>USACO Silver Swapity Swapity   Swap</li> <li>Codeforces Square Root of   Permutation</li> <li>Codeforces Inversion Counting</li> <li>CEOI 2005 depot - se intr\u0103 \u00een cont \u0219i se d\u0103   upsolving pentru a accesa problema</li> <li>Lot Seniori 2014 Evacuare</li> <li>Lot Seniori 2016 politic</li> <li>infoarena zaharel</li> <li>ONI 2024 sim</li> <li>Lot Seniori 2011 amici</li> <li>IOI 2011 Tropical Garden</li> </ul>","tags":["C++","implementare","grafuri","cicluri"]},{"location":"mediu/cycles/#resurse-suplimentare","title":"Resurse suplimentare","text":"<ul> <li>Eulerian path -   cp-algorithms</li> <li>Euler paths and circuits - Discrete Mathematics: An Open   Introduction</li> <li>Cicluri euleriene - wikipedia</li> <li>Cicluri hamiltoniene -   wikipedia</li> <li>Problema gasirii drumului hamiltonian -   wikipedia</li> <li>Cicluri ale permutarilor -   Algopedia</li> <li>Grafuri func\u021bionale - USACO   Guide</li> </ul>","tags":["C++","implementare","grafuri","cicluri"]},{"location":"mediu/data-normalization/","title":"Normalizarea datelor","text":"<p>\u00cen unele probleme, suntem nevoi\u021bi s\u0103 prelucr\u0103m datele de intrare, astfel \u00eenc\u00e2t s\u0103 putem efectua opera\u021bii de actualizare \u0219i interogare ale datelor mult mai u\u0219or. O metod\u0103 foarte popular\u0103 care are drept scop compresia datelor de intrare este normalizarea datelor. Cu alte cuvinte, scopul principal al acestei metode este acela de a transforma un \u0219ir cu valori arbitrare \u00eentr-un \u0219ir cu valori mai mici.</p> <p>De regul\u0103, transform\u0103m valorile \u00eentr-un \u0219ir cu valori \u00eentre 1 \u0219i \\(n\\), \u00een care fiecare valoare va fi modificat\u0103 \u00een func\u021bie de pozi\u021bia acesteia \u00een \u0219irul sortat. De\u0219i \u00een multe cazuri, vom putea folosi \u0219i alte structuri de date, normalizarea devine \u00een multe cazuri o metod\u0103 care ne ajut\u0103 s\u0103 \u00eembun\u0103t\u0103\u021bim constanta de timp pentru multe solu\u021bii.</p>","tags":["normalizare","implementare"]},{"location":"mediu/data-normalization/#mod-de-implementare","title":"Mod de implementare","text":"<p>Cum am zis \u0219i anterior, vrem s\u0103 putem prelucra un \u0219ir dat, astfel \u00eenc\u00e2t s\u0103 afl\u0103m cu u\u0219urin\u021b\u0103 pozi\u021bia lui din \u0219irul sortat, reduc\u00e2nd astfel intervalul de valori la unul de lungime \\(n\\).</p> <p>De exemplu, dac\u0103 \u0219irul nostru este \\(v = \\{4, 9, 41, 22, 14, 7, 44 \\}\\), dup\u0103 normalizare, vrem s\u0103 ob\u021binem \\(v = \\{1, 3, 6, 5, 4, 2, 7 \\}\\).</p> <p>Observa\u021bie</p> <p>Dac\u0103 avem mai multe valori egale, nu are importan\u021b\u0103 dac\u0103 le vom atribui aceea\u0219i valoare sau valori diferite, a\u0219a cum ve\u021bi putea vedea \u00een implementarea de mai jos.</p> <p>Pentru a face asta, exist\u0103 dou\u0103 abord\u0103ri principale. Prima const\u0103 \u00een a \u021bine un \u0219ir separat cu valorile, pe care le vom sorta, iar mai apoi la fiecare opera\u021bie, dac\u0103 vrem s\u0103 afl\u0103m pozi\u021bia \u00een \u0219irul sortat pentru o valoare dat\u0103, vom folosi o c\u0103utare binar\u0103. Cea de-a doua abordare este similar\u0103, singura diferen\u021b\u0103 fiind c\u0103 \u021binem valorile \u00eentr-o structur\u0103 de tip <code>std::set</code> \u0219i dup\u0103 ce iter\u0103m prin set, facem coresponden\u021bele cu valorile \u00een timp logaritmic pentru fiecare valoare \u00eent\u00e2lnit\u0103. Mai jos pute\u021bi g\u0103si o implementare ce folose\u0219te prima metod\u0103.</p> <p>Codul de mai jos sorteaz\u0103 \u0219irul \u0219i afl\u0103 pentru fiecare valoare din \u0219irul ini\u021bial pozi\u021bia pe care s-ar afla \u00een \u0219irul normalizat.</p> <p>Observa\u021bie</p> <p>Exist\u0103 structuri de date care fac acest lucru \u0219i f\u0103r\u0103 a fi nevoie de prelucr\u0103ri adi\u021bionale, precum Policy based data structures, dar \u00een multe situa\u021bii, acestea se dovedesc a fi foarte \u00eencete \u0219i foarte costisitoare din punct de vedere al memoriei, normalizarea fiind o op\u021biune superioar\u0103 \u00een toate situa\u021biile. Totu\u0219i, dac\u0103 limita de timp nu este str\u00e2ns\u0103, acestea pot fi o op\u021biune viabil\u0103.</p> <pre><code>#include &lt;algorithm&gt;\n#include &lt;iostream&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\nint main() {\n    int n;\n    cin &gt;&gt; n;\n\n    vector&lt;int&gt; v(n + 1), sorted(n + 1);\n    for (int i = 1; i &lt;= n; i++) {\n        cin &gt;&gt; v[i];\n        sorted[i] = v[i];\n    }\n\n    sort(sorted.begin() + 1, sorted.begin() + n + 1);\n\n    int maxi = 0;\n    for (int i = 1; i &lt;= n; i++) {\n        int L = 1;\n        int R = n;\n        int ans = 0;\n        while (L &lt;= R) {\n            int mid = (L + R) / 2;\n            if (sorted[mid] &lt; v[i]) {\n                ans = mid;\n                L = mid + 1;\n            } else {\n                R = mid - 1;\n            }\n        }\n        cout &lt;&lt; ans &lt;&lt; '\\n';\n    }\n    return 0;\n}\n</code></pre>","tags":["normalizare","implementare"]},{"location":"mediu/data-normalization/#normalizare-mai-simpla-cand-valorile-sunt-distincte","title":"Normalizare mai simpl\u0103 c\u00e2nd valorile sunt distincte","text":"<p>\u00cen unele probleme \u00een care toate valorile sunt distincte, ne putem g\u00e2ndi \u0219i la o variant\u0103 de a implementa conversia din datele clasice \u00een cele normalizate \u00een timp liniar (dup\u0103 sortare).</p> <p>Ne putem g\u00e2ndi pur \u0219i simplu la o traversare a \u0219irului \u00een timp liniar, presupun\u00e2nd c\u0103 p\u0103str\u0103m valorile originale folosind perechi.</p> <pre><code>int cnt = 0;  // numarul de valori distincte\nfor (int i = 1; i &lt;= n; i++) {\n    if (sorted[i].first &gt; sorted[i - 1].first) {\n        cnt++;\n    }\n    v[sorted[i].second] = cnt;\n}\n</code></pre>","tags":["normalizare","implementare"]},{"location":"mediu/data-normalization/#problema-restaurant-customers-de-pe-cses","title":"Problema Restaurant Customers de pe cses","text":"<p>Pentru a rezolva aceast\u0103 problem\u0103, trebuie s\u0103 g\u0103sim o metod\u0103 care ne ajut\u0103 s\u0103 proces\u0103m intervalele \u00een a\u0219a fel \u00eenc\u00e2t s\u0103 nu trebuiasc\u0103 s\u0103 avem nevoie de foarte mult\u0103 memorie pentru valorile din intervale.</p> <p>O prim\u0103 solu\u021bie brut\u0103 const\u0103 \u00een verificarea fiec\u0103rui punct posibil de la 1 la \\(10^9\\), iar pentru fiecare punct, verific\u0103m dac\u0103 este inclus \u00een fiecare dintre cele \\(n\\) intervale date. Complexitatea ar fi \\(\\mathcal{O}(n \\cdot maxval)\\), ceea ce este mult prea \u00eencet pentru o solu\u021bie optim\u0103.</p> <p>Observa\u021bie</p> <p>Singurele puncte \u00een care se schimb\u0103 num\u0103rul de intervale acoperite de un punct sunt acelea unde \u00eencepe \u0219i se termin\u0103 un interval, deci num\u0103rul de puncte relevante scade la \\(2 \\cdot n\\).</p> <p>Solu\u021bia men\u021bionat\u0103 mai sus ar fi optimizat\u0103 la \\(\\mathcal{O}(n^2)\\), ceea ce nu este \u00eendeajuns pentru rezolvarea problemei date.</p> <p>O alt\u0103 abordare const\u0103 \u00een folosirea unei abord\u0103ri pe stilul \u0218menului lui Mars, iar pentru fiecare interval, putem ad\u0103uga 1 \u00een zona \\([st, dr]\\), iar complexitatea ar deveni \\(\\mathcal{O}(maxval)\\).</p> <p>Folosind observa\u021bia de mai sus, putem reduce num\u0103rul de puncte la \\(2 \\cdot n\\), iar dup\u0103 ce sort\u0103m punctele relevante, solu\u021bia explicat\u0103 mai sus poate fi optimizat\u0103 la \\(\\mathcal{O}(n \\log n)\\), unele din abord\u0103rile care merg pot fi fie folosirea \u0219menului lui Mars pe vectorul cu punctele normalizate, fie sortarea punctelor relevante \u0219i considerarea lor drept evenimente, mai apoi parcurg\u00e2ndu-le \u00een ordine cresc\u0103toare.</p> <p>O abordare care consider\u0103 punctele drept evenimente se poate citi mai jos. Deoarece toate punctele sunt distincte, nu este necesar s\u0103 consider\u0103m \u00eentr-o manier\u0103 particular\u0103 intr\u0103rile \u0219i ie\u0219irile.</p> <pre><code>#include &lt;algorithm&gt;\n#include &lt;iostream&gt;\n\nusing namespace std;\n\nint n;\n\npair&lt;int, int&gt; p[400002];\n\nint main() {\n    cin &gt;&gt; n;\n    for (int i = 1; i &lt;= n; ++i) {\n        int a, b;\n        cin &gt;&gt; a &gt;&gt; b;\n        // 1 - intrare in restaurant, -1 - iesire din restaurant\n        // transformam fiecare moment intr-o pereche\n        p[i * 2 - 1] = {a, 1};\n        p[i * 2] = {b, -1};\n    }\n\n    sort(p + 1, p + n * 2 + 1);\n\n    int counter = 0, max_counter = 0;\n    for (int i = 1; i &lt;= n * 2; ++i) {\n        counter += p[i].second;\n        if (counter &gt; max_counter) {\n            max_counter = counter;\n        }\n    }\n\n    cout &lt;&lt; max_counter &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["normalizare","implementare"]},{"location":"mediu/data-normalization/#concluzii","title":"Concluzii","text":"<p>De\u0219i normalizarea nu este altceva dec\u00e2t o tehnic\u0103 auxiliar\u0103, aceasta se va dovedi a fi una foarte important\u0103 \u00een cazul multor probleme algoritmice, acest pas fiind un pas intermediar foarte important atunci c\u00e2nd avem nevoie s\u0103 prelucr\u0103m datele folosind structuri de date, evit\u00e2nd astfel folosirea unor variante dinamice, care ocup\u0103 mult mai mult\u0103 memorie \u0219i consum\u0103 mult mai mult timp.</p>","tags":["normalizare","implementare"]},{"location":"mediu/data-normalization/#probleme-suplimentare","title":"Probleme suplimentare","text":"<ul> <li>map pbinfo</li> <li>Probleme cu normalizare de pe   pbinfo</li> <li>1D Country AtCoder</li> <li>Rectangular Pasture USACO   Silver</li> <li>Years Codeforces</li> <li>nextseq infoarena</li> <li>Static Range Queries Codeforces</li> </ul>","tags":["normalizare","implementare"]},{"location":"mediu/data-normalization/#lectura-suplimentara","title":"Lectur\u0103 suplimentar\u0103","text":"<ul> <li>Coordinate Compression - USACO   Guide</li> <li>Normalize an array</li> </ul>","tags":["normalizare","implementare"]},{"location":"mediu/debugging/","title":"Cum repari o solu\u021bie gre\u0219it\u0103?","text":"","tags":["meta","sfaturi","debugging"]},{"location":"mediu/debugging/#introducere","title":"Introducere","text":"<p>Atunci c\u00e2nd scrie\u021bi programe pentru a rezolva diverse probleme de algoritmic\u0103, ve\u021bi avea de-a face \u00een mod inevitabil cu bug-uri (erori/gre\u0219eli) care v\u0103 fac solu\u021bia s\u0103 fie gre\u0219it\u0103. \u00cen acest articol, vom prezenta cele mai importante lucruri pe care s\u0103 le ave\u021bi \u00een vedere atunci c\u00e2nd scrie\u021bi solu\u021bii, precum \u0219i metode pe care s\u0103 le folosi\u021bi c\u00e2nd solu\u021biile sunt gre\u0219ite.</p>","tags":["meta","sfaturi","debugging"]},{"location":"mediu/debugging/#cele-mai-frecvente-erori-de-implementare","title":"Cele mai frecvente erori de implementare","text":"<p>\u00cen cele mai multe cazuri, erorile apar din cauza unor gre\u0219eli ce pot fi evitate. Dintre cele mai frecvente motive pentru care apar bug-urile, vom enumera urm\u0103toarele:</p>","tags":["meta","sfaturi","debugging"]},{"location":"mediu/debugging/#variabile-neinitializate","title":"Variabile neini\u021bializate","text":"<p>Uneori, po\u021bi avea nevoie de variabile locale, fie c\u0103 e vorba \u00eentr-o func\u021bie sau chiar \u00een func\u021bia main. Ini\u021bializare acestor variabile este obligatorie, iar nerespectarea acestei reguli poate duce la erori ce de multe ori nu sunt depistate de mediul vostru de lucru. De exemplu, \\(s\\) ar trebui s\u0103 fie egal cu 385 la final, dar deoarece aceast\u0103 variabil\u0103 nu este ini\u021bializat\u0103, r\u0103spunsul va fi diferit.</p> <p>Observa\u021bie</p> <p>\u00cen func\u021bie de set\u0103rile mediului vostru, outputul poate fi 385. Totu\u0219i, acesta este un undefined behavior, a\u0219a cum vom vorbi \u0219i mai t\u00e2rziu \u00een acest articol.</p> <pre><code>int n = 10;\nint s;\nfor (int i = 1; i &lt;= n; i++) {\n    s += i * i;\n}\n\ncout &lt;&lt; s &lt;&lt; '\\n';\n</code></pre>","tags":["meta","sfaturi","debugging"]},{"location":"mediu/debugging/#overflow-uri","title":"Overflow-uri","text":"<p>Defini\u021bie</p> <p>Situa\u021bia \u00een care o variabil\u0103 care poate avea o valoare mai mare dec\u00e2t limitele tipului de date care \u00eei este asignat se nume\u0219te overflow.</p> <p>Un astfel de exemplu este atunci c\u00e2nd o valoare poate fi egal\u0103 cu \\(n^2\\) iar \\(n \\leq 10^5\\). Deoarece opera\u021biile efectuate cu dou\u0103 variabile cu acela\u0219i tip de date ne returneaz\u0103 o variabil\u0103 cu acela\u0219i tip de date, produsele sau ridic\u0103rile la putere sunt vulnerabile la overflow-uri, precum \u0219i sumele ce implic\u0103 mul\u021bi termeni mai mari.</p> <pre><code>int n = 100000;\ncout &lt;&lt; n * (n + 1) / 2 &lt;&lt; '\\n';        // overflow\ncout &lt;&lt; 1LL * n * (n + 1) / 2 &lt;&lt; '\\n';  // ok\n</code></pre>","tags":["meta","sfaturi","debugging"]},{"location":"mediu/debugging/#conditii-scrise-prost","title":"Condi\u021bii scrise prost","text":"<p>\u00cen cazul unor structuri alternative, folosirea proast\u0103 a unor operatori logici \u0219i de egalitate poate duce la schimbarea total\u0103 a rezultatelor.</p> <p>De exemplu, aici plasarea egalit\u0103\u021bii din if-uri trebuie s\u0103 fie corect\u0103, altfel instruc\u021biunile devin total diferite. \u00cen mod similar, putem avea aceea\u0219i eroare c\u00e2nd folosim operatori precum <code>&amp;&amp;</code>, <code>||</code>, dac\u0103 folosim <code>&amp;</code>, <code>|</code> etc.</p> <pre><code>if (x == 3) {  // se verifica daca x = 3\n    // cod\n}\nif (x = 3) {  // x devine 3, dupa se verifica daca este nenul\n}\n</code></pre>","tags":["meta","sfaturi","debugging"]},{"location":"mediu/debugging/#erori-off-by-one","title":"Erori off by one","text":"<p>\u00cen multe calcule, se poate \u00eent\u00e2mpla s\u0103 ave\u021bi valori gre\u0219ite sau semne puse prost (de exemplu, \\(&gt;=\\) \u00een loc de \\(&gt;\\)) iar aceste lucruri s\u0103 cauzeze programul s\u0103 se ruleze \u00eentr-un mod complet diferit.</p> <p>O alt\u0103 eroare care intr\u0103 \u00een aceea\u0219i categorie const\u0103 \u00een folosirea gre\u0219it\u0103 a variabilelor atunci c\u00e2nd se apeleaz\u0103 la structuri repetitive imbricate. Un exemplu foarte des \u00eent\u00e2lnit de bug care apare aici este folosirea variabilelor \\(i\\) \u0219i \\(j\\) la foruri, increment\u0103rile fiind scrise eronat, un exemplu de cod eronat este dat mai jos.</p> <p>Acest cod va rula la infinit, practic fiind un caz de loop care va rula f\u0103r\u0103 oprire.</p> <pre><code>for (int i = 1; i &lt;= n; i++) {\n    for (int j = 1; j &lt;= n; i++) {}\n}\n</code></pre> <p>O alt\u0103 eroare off by one reprezint\u0103 \u00eemp\u0103r\u021birea la zero, opera\u021bie neacceptat\u0103 \u00een matematic\u0103 \u0219i \u00een informatic\u0103.</p>","tags":["meta","sfaturi","debugging"]},{"location":"mediu/debugging/#iesirea-din-tablouri","title":"Ie\u0219irea din tablouri","text":"<p>De obicei, dac\u0103 avem o pozi\u021bie care este accesat\u0103 dar nu exist\u0103 \u00een \u0219ir, atunci programul se va opri din rulat \u0219i ve\u021bi avea un verdict de tipul runtime error (programul iese cu un verdict diferit de 0). Dintre cele mai frecvente situa\u021bii \u00een care apar erori, putem men\u021biona acces\u0103rile pozi\u021biilor negative sau pozi\u021biilor prea mari. Mai jos g\u0103si\u021bi exemple \u00een care avem de-a face cu asemenea erori.</p> <pre><code>for (int i = n; i &gt;= 1; i++) {  // i creste si vom iesi din vector\n    cout &lt;&lt; v[i] &lt;&lt; \" \";\n}\n</code></pre> <pre><code>#include &lt;iostream&gt;\n#include &lt;vector&gt;\n\nusing namespace std;\n\nint main() {\n    vector&lt;int&gt; arr = {1, 2, 3, 4, 5};\n    int maxIndex = 100;\n\n    for (int i = 0; i &lt; maxIndex; ++i) {\n        arr[i] = arr[i] * 2;\n        cout &lt;&lt; arr[i] &lt;&lt; '\\n';\n    }\n\n    return 0;\n}\n</code></pre>","tags":["meta","sfaturi","debugging"]},{"location":"mediu/debugging/#undefined-behavior","title":"Undefined behavior","text":"<p>Undefined behavior</p> <p>Atunci c\u00e2nd acces\u0103m memorie care nu exist\u0103, dar programul nu se opre\u0219te din rulat, avem de-a face cu o situa\u021bie ce se nume\u0219te undefined behavior.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int arr[8] = {1, 2, 3, 4, 5};\n\n    cout &lt;&lt; arr[5] &lt;&lt; '\\n';\n    cout &lt;&lt; arr[-1] &lt;&lt; '\\n';  // undefined behavior, vom avea erori la rulare\n\n    return 0;\n}\n</code></pre>","tags":["meta","sfaturi","debugging"]},{"location":"mediu/debugging/#cum-eviti-erorile-de-implementare","title":"Cum evi\u021bi erorile de implementare?","text":"<p>\u00cen general, pentru a evita aceste erori de implementare, se recomand\u0103 urmarea unui stil de cod prietenos cu cititorul \u0219i cel mai important, un stil citibil. Acest lucru este important at\u00e2t pentru rezolvarea problemei curente, dar \u0219i pentru cazurile c\u00e2nd ve\u021bi avea nevoie s\u0103 citi\u021bi codul ulterior.</p> <p>Nu \u00een ultimul r\u00e2nd, aceste coduri pot fi citite de al\u021bi utilizatori, iar codurile scrise frumos sunt mult mai u\u0219or de urm\u0103rit, astfel pute\u021bi ajuta \u0219i al\u021bi oameni s\u0103 \u00een\u021beleag\u0103 anumite tehnici mai bine.</p> <p>Alte lucruri importante pe care le pute\u021bi face sunt verificarea cu aten\u021bie a restric\u021biilor din enun\u021b, care v\u0103 pot induce \u00een eroare uneori c\u00e2nd vine vorba de anumite detalii de implementare.</p>","tags":["meta","sfaturi","debugging"]},{"location":"mediu/debugging/#cele-mai-frecvent-intalnite-erori-la-idee","title":"Cele mai frecvent \u00eent\u00e2lnite erori la idee","text":"<p>\u00cen mod evident, dac\u0103 ideea de la care pleac\u0103 solu\u021bia voastr\u0103 este complet gre\u0219it\u0103, trebuie s\u0103 v\u0103 g\u00e2ndi\u021bi iar \u0219i s\u0103 analiza\u021bi cu mai mult\u0103 aten\u021bie ce ave\u021bi de f\u0103cut \u0219i cum pute\u021bi rezolva problema dat\u0103. Totu\u0219i, punctajul de 100 poate fi mai aproape de voi dec\u00e2t a\u021bi crede, chiar \u0219i dup\u0103 un verdict de 0.</p> <p>C\u00e2teva dintre cele mai dese erori care se fac \u0219i pot fi reparate repede sunt urm\u0103toarele:</p> <ul> <li>Cazurile particulare (corner cases): \u00cen multe probleme, cazuri precum \\(N = 1\\),   valori cu propriet\u0103\u021bi specifice sau anumite tipuri de inputuri pot pune   probleme dac\u0103 acele cazuri nu sunt tratate cum trebuie.</li> <li>Enun\u021b citit gre\u0219it: Da, de foarte multe ori se poate \u00eent\u00e2mpla s\u0103 citi\u021bi   enun\u021bul gre\u0219it \u0219i s\u0103 rezolva\u021bi o problem\u0103 complet diferit\u0103.</li> <li>Extinderea unor idei poate fi calea spre succes: Dac\u0103 ave\u021bi o idee   promi\u021b\u0103toare dar sunte\u021bi bloca\u021bi la un pas al rezolv\u0103rii, particularizarea   ideii pentru anumite tipuri de date poate fi foarte util\u0103.</li> <li>Algoritm/metod\u0103 neoptim\u0103: \u00cen acest caz, optimiz\u0103rile sunt necesare sau \u00een   unele cazuri, chiar schimbarea complet\u0103 a algoritmului folosit pentru   rezolvarea problemei.</li> <li>Resetarea gre\u0219it\u0103 a datelor: \u00cen special \u00een cazul problemelor cu multitest   (rezolvarea mai multor seturi de date \u00eentr-o rulare a programului), resetarea   gre\u0219it\u0103 a datelor poate duce la erori \u00een ceea ce prive\u0219te calcularea   r\u0103spunsului</li> </ul>","tags":["meta","sfaturi","debugging"]},{"location":"mediu/debugging/#moduri-de-a-rula-algoritmul","title":"Moduri de a rula algoritmul","text":"<p>Atunci c\u00e2nd vi se \u00eent\u00e2mpl\u0103 s\u0103 ave\u021bi un algoritm ce returneaz\u0103 r\u0103spunsuri gre\u0219ite, vre\u021bi s\u0103 v\u0103 pute\u021bi da seama ce p\u0103r\u021bi din algoritm fac lucrurile gre\u0219it. \u00cen general, deoarece datele cu care lucra\u021bi pot fi foarte mari, vrem s\u0103 ne concentr\u0103m pe evaluarea unor teste mici, care s\u0103 poat\u0103 fi citibile cu u\u0219urin\u021b\u0103 \u0219i eventual comparate fie cu rezultatele ob\u021binute pe h\u00e2rtie, fie cu rezultatele ob\u021binute de un algoritm brute-force.</p>","tags":["meta","sfaturi","debugging"]},{"location":"mediu/debugging/#folosirea-liniilor-de-afisare-a-datelor","title":"Folosirea liniilor de afi\u0219are a datelor","text":"<p>Cea mai simpl\u0103 \u0219i una dintre cele mai eficiente tehnici de reparare a unui cod este folosirea unor r\u00e2nduri \u00een care afi\u0219\u0103m date \u00een consol\u0103, pentru a evalua evolu\u021bia unor variabile. De obicei, vrem s\u0103 facem asta cu r\u0103spunsurile afi\u0219ate sau cu unele rezultate intermediare ce duc la r\u0103spunsul c\u0103utat. Acest lucru se poate face \u00een multe moduri, dar cel mai simplu mod este acela de a folosi instruc\u021biuni de tip cout.</p> <p>Exemplul de mai jos este pur didactic, neav\u00e2nd vreo \u00eensemn\u0103tate \u00een mod particular.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint x = 10;\n\nint main() {\n    cout &lt;&lt; \"x = \" &lt;&lt; x &lt;&lt; '\\n';  // 10\n    x = 5000;\n    cout &lt;&lt; \"x = \" &lt;&lt; x &lt;&lt; '\\n';  // 5000\n}\n</code></pre>","tags":["meta","sfaturi","debugging"]},{"location":"mediu/debugging/#folosirea-debuggerului","title":"Folosirea debuggerului","text":"<p>Multe editoare de cod (printre care \u0219i Code::Blocks) ofer\u0103 acces la un debugger, acesta fiind un instrument care poate fi folosit pentru a urm\u0103ri evolu\u021bia unor variabile de-a lungul codului f\u0103r\u0103 a fi nevoie de afi\u0219area lor \u00een diverse pozi\u021bii din cod. Acest instrument poate avea multe avantaje, dar \u00een cazul unui mediu de concurs \u00eencet (de exemplu, calculatoarele de la \u0219coli), poate fi anevoios \u0219i greu de utilizat.</p>","tags":["meta","sfaturi","debugging"]},{"location":"mediu/debugging/#stress-testing","title":"Stress testing","text":"<p>O metod\u0103 foarte important\u0103 \u0219i util\u0103 \u00een special atunci c\u00e2nd bug-urile sunt greu de g\u0103sit const\u0103 \u00een crearea unui program (sau mai multe) care s\u0103 poat\u0103 genera teste de evaluare care s\u0103 foloseasc\u0103 la evaluarea sursei scrise de tine. Aceste teste, odat\u0103 create, pot fi rulate pentru a depista erori. \u00cen general, vrei s\u0103 ai un program corect, dar \u00eencet \u0219i un program rapid, dar gre\u0219it, care va fi corectat (sau demonstrat c\u0103 este eronat indiferent de situa\u021bie). Unele metode implic\u0103 \u0219i folosirea unui program separat pentru generarea datelor de intrare.</p> <p>\u00cen ceea ce prive\u0219te generatorul de teste, vrem s\u0103 putem genera foarte multe teste mici (valori ale lui \\(n\\) suficient de mici care s\u0103 poat\u0103 permite unei solu\u021bii brute s\u0103 se mi\u0219te repede), cu scopul de a detecta un test de evaluare pentru care cele dou\u0103 programe s\u0103 dea un r\u0103spuns diferit.</p>","tags":["meta","sfaturi","debugging"]},{"location":"mediu/debugging/#stress-testing-cu-un-singur-program","title":"Stress testing cu un singur program","text":"<p>Una dintre cele mai u\u0219oare metode (\u0219i cea mai practic\u0103 \u00een condi\u021biile unor concursuri fizice) este aceea cu un singur program. Modul de func\u021bionare const\u0103 \u00een ad\u0103ugarea programelor men\u021bionate anterior drept func\u021bii \u00eentr-un program, iar mai apoi, folosim un generator suficient de puternic \u0219i teste bine create pentru a detecta eventualele bug-uri.</p> <p>Un exemplu de cod poate fi g\u0103sit mai jos.</p> <pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n\nmt19937_64 rnd;  // 64-bit\nlong long val(bool positive) {\n    long long ans = rnd();\n    if (positive) {\n        return abs(ans);\n    } else {\n        return ans;\n    }\n}\n\n/*\n    Aici adaugam variabilele pe care le vom folosi, trebuie sa fim atenti pentru\n   ca uneori avem nevoie de copii pentru valorile noastre\n\n*/\n\n// Aici generam datele de intrare, de regula se recomanda un input mic pentru\n// rezultate optime\nvoid gentest() {}\n\n// Aici adaugam o solutie corecta, foarte inceata, care va fi folosita pentru a\n// evalua solutia eficienta\nint bruteforce() {}\n\n// Aici adaugam solutia eficienta, care desi este rapida, este incorecta si vrem\n// s-o reparam\nint efficient() {}\n\n//  Daca raspunsurile sunt diferite, vom afisa inputul aici\nvoid printinput() {}\n\nint main() {\n    // alegem seedul aleator pentru a avea rezultate diferite mereu\n    int seed = std::random_device{}();\n    rnd.seed(seed);\n\n    int t = 0;\n    while (t &lt;= 10000) {\n        gentest();\n        int brute = bruteforce();\n        int eff = efficient();\n        if (brute != eff) {\n            cout &lt;&lt; \"Brute: \" &lt;&lt; brute &lt;&lt; '\\n';\n            cout &lt;&lt; \"Efficient: \" &lt;&lt; eff &lt;&lt; '\\n';\n            printinput();\n            return 0;\n        }\n    }\n    return 0;\n}\n</code></pre>","tags":["meta","sfaturi","debugging"]},{"location":"mediu/debugging/#stress-testing-cu-3-programe","title":"Stress testing cu 3 programe","text":"<p>Procesul va fi similar, diferen\u021ba fiind aceea c\u0103 pentru a avea programe mai mici ca dimensiune, se vor folosi comenzi de terminal pentru rularea programelor \u00een mod concomitent, p\u00e2n\u0103 c\u00e2nd se vor ob\u021bine r\u0103spunsuri diferit \u00eentre programe.</p>","tags":["meta","sfaturi","debugging"]},{"location":"mediu/debugging/#concluzii","title":"Concluzii","text":"<p>Debugging-ul este una dintre cele mai importante tehnici pentru orice programator, iar indiferent de metoda folosit\u0103, repararea solu\u021biilor gre\u0219ite este un pas esen\u021bial pentru a progresa indiferent c\u0103 e vorba de a fi un competior mai bun sau a putea opera mai eficient \u00een ceea ce prive\u0219te proiecte mai complexe.</p>","tags":["meta","sfaturi","debugging"]},{"location":"mediu/debugging/#resurse-suplimentare","title":"Resurse suplimentare","text":"<ul> <li>O abordare eficient\u0103 a problemelor de informatic\u0103 -   Nerdvana</li> <li>Compilation and Debugging Tutorial -   Codeforces</li> <li>How to Debug - USACO   Guide</li> <li>Basic Debugging - USACO   Guide</li> <li>How to test your solution? -   Errichto</li> </ul>","tags":["meta","sfaturi","debugging"]},{"location":"mediu/deque/","title":"Deque","text":"<p>Probabil c\u0103 p\u00e2n\u0103 acum, v-ati obi\u0219nuit cu folosirea stivelor \u0219i a cozilor \u00een diverse probleme de algoritmic\u0103, iar de\u0219i aceste structuri de date sunt foarte puternice, fiecare dintre ele are lipsuri care fac implementarea anumitor p\u0103r\u021bi mult mai dificil\u0103.</p> <p>Acum, se pune \u00eentrebarea fireasc\u0103 dac\u0103 putem s\u0103 unim propriet\u0103\u021bile cozilor \u0219i ale stivelor f\u0103r\u0103 s\u0103 avem de f\u0103cut sacrificii majore, iar r\u0103spunsul este din fericire un DA clar. \u00cen cele ce urmeaz\u0103, vom discuta despre deque, o structur\u0103 de date care \u00eembin\u0103 propriet\u0103\u021bile stivelor \u0219i ale cozilor, ad\u0103ug\u00e2nd \u0219i facilit\u0103\u021bi \u00een plus.</p>","tags":["vectori","structuri de date"]},{"location":"mediu/deque/#introducere-si-sintaxa","title":"Introducere \u0219i sintax\u0103","text":"<p>Defini\u021bie</p> <p>Un deque (double-ended queue) este o structur\u0103 de date liniar\u0103, similar\u0103 cu stiva \u0219i coada, cu proprietatea c\u0103 suport\u0103 opera\u021biile specifice stivelor \u0219i cozilor \u00een timp constant. A\u0219a cum \u00eei zice \u0219i numele, practic este o coad\u0103 dubl\u0103, din care putem extrage valori din ambele capete, dar \u0219i ad\u0103uga \u00een ambele capete.</p> <p>Observa\u021bie</p> <p>Complexitatea men\u021bionat\u0103 mai sus este cel pu\u021bin pentru implementarea din STL (std::deque) una amortizat\u0103, cu alte cuvinte, \\(n\\) opera\u021bii f\u0103cute pe un deque vor fi \\(\\mathcal{O}(n)\\), dar asta nu garanteaz\u0103 faptul c\u0103 fiecare opera\u021bie va lua \\(\\mathcal{O}(1)\\). Din acest motiv, vom spune c\u0103 complexitatea unui deque este \\(\\mathcal{O}(1)\\) amortizat.</p>","tags":["vectori","structuri de date"]},{"location":"mediu/deque/#sintaxa","title":"Sintax\u0103","text":"<p>La fel ca \u0219i \u00een cazul cozilor \u0219i stivelor, deque-ul poate fi implementat de m\u00e2n\u0103, folosind un tablou de lungime fix\u0103, ad\u0103ug\u00e2nd \u0219i sco\u021b\u00e2nd valori \u00eentr-un mod ciclic.</p> <pre><code>const int QMAX = 100001;\nint coada[100001];\n\nint pop() {\n    ultim = (ultim - 1 + QMAX) % QMAX;\n    return coada[ultim];\n}\nvoid pushFront(int e) {\n    prim = (prim - 1 + QMAX) % QMAX;\n    coada[prim] = e;\n}\nvoid pushBack(int e) {\n    ultim = (ultim + 1 - QMAX) % QMAX;\n    coada[ultim] = e;\n}\n</code></pre> <p>Totu\u0219i, \u00een cele mai multe probleme, ne vom folosi de versiunea specific\u0103 limbajului C++, \u0219i anume std::deque. Acesta va avea func\u021biile specifice cozilor \u0219i stivelor, f\u0103r\u0103 a fi nevoie s\u0103 le implement\u0103m noi.</p> <p>Lista operatorilor \u0219i func\u021biilor pe care le pute\u021bi folosi \u00een deque este urm\u0103toarea:</p> <ol> <li>push_back(value): Adaug\u0103 value la sf\u00e2r\u0219itul deque-ului.</li> <li>push_front(value): Adaug\u0103 value la \u00eenceputul deque-ului.</li> <li>pop_back(): Scoate valoarea de la sf\u00e2r\u0219itul deque-ului.</li> <li>pop_front(): Scoate valoarea de la \u00eenceputul deque-ului.</li> <li>front(): Spune care este valoarea de la \u00eenceputul deque-ului.</li> <li>back(): Spune care este valoarea de la cap\u0103tul deque-ului.</li> <li>empty(): Spune dac\u0103 deque-ul este goal\u0103.</li> <li>size(): Returneaz\u0103 dimensiunea deque-ului.</li> </ol> <p>Mai jos pute\u021bi g\u0103si exemple de aplicare a func\u021biilor \u00een deque.</p> <pre><code>deque&lt;int&gt; d;\nd.push_back(1);             // 1\nd.push_back(3);             // 1 3\nd.push_front(2);            // 2 1 3\nd.push_back(4);             // 2 1 3 4\nd.push_front(5);            // 5 2 1 3 4\nd.pop_back();               // 5 2 1 3\nd.pop_back();               // 5 2 1\nd.pop_front();              // 2 1\ncout &lt;&lt; d.front() &lt;&lt; '\\n';  // 2\ncout &lt;&lt; d.back() &lt;&lt; '\\n';   // 1\ncout &lt;&lt; d.size() &lt;&lt; '\\n';   // 2\nif (!d.empty()) {\n    cout &lt;&lt; \"Are valori\";\n}\n</code></pre>","tags":["vectori","structuri de date"]},{"location":"mediu/deque/#motivatie","title":"Motiva\u021bie","text":"<p>Motivul principal pentru care folosim deque-urile este acela de a putea performa opera\u021bii pe secven\u021be de lungime fix\u0103, fiind una din tehnicile des folosite \u00een cazul problemelor ce folosesc tehnica sliding window (sau \u00een rom\u00e2n\u0103, fereastra glisant\u0103), subiect discutat \u00een acest articol. Acesta va fi \u0219i scopul principal al acestui articol, acela de a prezenta cele mai des \u00eent\u00e2lnite aplica\u021bii ale deque-ului.</p> <p>De cele mai multe ori, atunci c\u00e2nd vom lucra cu deque-ul, vom vrea s\u0103 proces\u0103m secven\u021be de o lungime fix\u0103, av\u00e2nd opera\u021bii bine stabilite \u0219i de cele mai multe ori, prelu\u00e2nd aspecte de implementare v\u0103zute mai devreme c\u00e2nd a\u021bi studiat principiile de func\u021bionare ale stivei.</p>","tags":["vectori","structuri de date"]},{"location":"mediu/deque/#problema-deque","title":"Problema deque","text":"<p>\u00cen aceast\u0103 problem\u0103, se cere aflarea valorii minime pentru toate subsecven\u021bele de lungime \\(k\\). O solu\u021bie ce merit\u0103 men\u021bionat\u0103, dar care nu este optim\u0103, este folosirea unei structuri de tip set care reu\u0219e\u0219te s\u0103 ob\u021bin\u0103 rezultatul dorit \u00een \\(\\mathcal{O}(n \\log n)\\).</p> <p>Pentru solu\u021bia optim\u0103, vom proceda \u00een mod similar cum am proceda dac\u0103 am vrea s\u0103 afl\u0103m cea mai apropiat\u0103 valoare mai mic\u0103 de la st\u00e2nga, singura modificare fiind faptul c\u0103 dac\u0103 valoarea minim\u0103 este prea departe de pozi\u021bia curent\u0103, o scoatem.</p> <pre><code>#include &lt;deque&gt;\n#include &lt;fstream&gt;\n\nusing namespace std;\n\nint n, k, v[5000002];\n\nifstream fin(\"deque.in\");\nofstream fout(\"deque.out\");\n\nint main() {\n    fin &gt;&gt; n &gt;&gt; k;\n    for (int i = 1; i &lt;= n; ++i) {\n        fin &gt;&gt; v[i];\n    }\n    deque&lt;int&gt; d;\n\n    long long ans = 0;\n    for (int i = 1; i &lt;= n; ++i) {\n        if (!d.empty() &amp;&amp; i - d.front() == k) {\n            d.pop_front();\n        }\n        while (!d.empty() &amp;&amp; v[i] &lt;= v[d.back()]) {\n            d.pop_back();\n        }\n        d.push_back(i);\n        if (i &gt;= k) {\n            ans += v[d.front()];\n        }\n    }\n\n    fout &lt;&lt; ans &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["vectori","structuri de date"]},{"location":"mediu/deque/#problema-maximum-subarray-sum-ii","title":"Problema Maximum Subarray Sum II","text":"<p>Pentru a rezolva aceast\u0103 problem\u0103, ne folosim de faptul c\u0103 suma unei subsecven\u021be \u00eentre pozi\u021biile \\(L\\) \u0219i \\(R\\) este \\(sp[R] - sp[L-1]\\), unde \\(sp[i]\\) este suma par\u021bial\u0103 a valorilor p\u00e2n\u0103 la pozi\u021bia \\(i\\). Astfel, dat fiind c\u0103 trebuie s\u0103 afl\u0103m suma maxim\u0103 a unei subsecven\u021be \u00eentre lungimile \\(a\\) \u0219i \\(b\\), la pasul \\(i\\), vom insera \\(sp[i-a]\\), folosind deque-ul drept o stiv\u0103 care \u021bine sumele minime. La fel ca la problema precedent\u0103, dac\u0103 pozi\u021bia \\(i - b - 1\\) \u00eenc\u0103 este \u00een deque, o vom scoate.</p> <p>Observa\u021bie</p> <p>Vrem s\u0103 sc\u0103dem din suma curent\u0103 o sum\u0103 c\u00e2t mai mic\u0103 pentru a avea o sum\u0103 maxim\u0103, deoarece \\(sp[i]\\) este elementul fix, invariant.</p> <pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n\nlong long v[200002], sp[200002];\nint main() {\n    int n, a, b;\n    cin &gt;&gt; n &gt;&gt; a &gt;&gt; b;\n\n    for (int i = 1; i &lt;= n; i++) {\n        cin &gt;&gt; v[i];\n        sp[i] = sp[i - 1] + v[i];\n    }\n\n    deque&lt;int&gt; d;\n    long long ans = -(1LL &lt;&lt; 60);\n\n    for (int i = a; i &lt;= n; i++) {\n        while (!d.empty() &amp;&amp; sp[i - a] &lt;= sp[d.back()]) {\n            d.pop_back();\n        }\n        while (!d.empty() &amp;&amp; i - d.front() &gt; b) {\n            d.pop_front();\n        }\n        d.push_back(i - a);\n        if (sp[i] - sp[d.front()] &gt;= ans) {\n            ans = sp[i] - sp[d.front()];\n        }\n    }\n\n    cout &lt;&lt; ans;\n</code></pre>","tags":["vectori","structuri de date"]},{"location":"mediu/deque/#problema-cetate","title":"Problema cetate","text":"<p>Pentru rezolvarea cerin\u021bei 2 a acestei probleme, putem fixa dou\u0103 linii \u0219i s\u0103 aplic\u0103m o tehnic\u0103 similar\u0103 folosind deque, afl\u00e2nd suma maxim\u0103 folosindu-ne de sumele par\u021biale de pe coloane, mai jos fiind codul de la cerin\u021ba a doua, \u00eentreaga submisie put\u00e2nd fi accesat\u0103 aici</p> <pre><code>maxSum = LLONG_MIN;\nfor (linTop = 1; linTop &lt;= n; linTop++) {\n    linBot = linTop;\n    while (linBot &lt;= n &amp;&amp; (linBot - linTop + 1) &lt;= k) {\n        /* precalculam suma pe coloane */\n        cols[0] = 0;\n        for (col = 1; col &lt;= m; col++) {\n            cols[col] = cols[col - 1];\n            cols[col] += sp[linBot][col] - sp[linBot][col - 1]\n                       - sp[linTop - 1][col] + sp[linTop - 1][col - 1];\n        }\n\n        /* sliding window */\n        d.clear();\n        d.push_back(0);\n        for (col = 1; col &lt;= m; col++) {\n            /* daca a ramas ceva in urma */\n            if (d.front() == (col - k - 1)) {\n                d.pop_front();\n            }\n\n            sum = cols[col] - cols[d.front()];\n\n            bool isGreater = sum &gt; maxSum;\n            bool lexicSort =\n                sum == maxSum &amp;&amp; (linTop &lt;= maxLin || d.front() + 1 &lt;= maxCol);\n            if (isGreater || lexicSort) {\n                maxSum = sum;\n\n                maxLin = linTop, maxCol = d.front() + 1;\n                maxLin1 = linBot, maxCol1 = col;\n            }\n\n            /* ideea de la next greater element */\n            while (!d.empty() &amp;&amp; cols[col] &lt; cols[d.back()]) {\n                d.pop_back();\n            }\n            d.push_back(col);\n        }\n        linBot++;\n    }\n}\n\ncout &lt;&lt; maxSum &lt;&lt; \"\\n\";\ncout &lt;&lt; maxLin &lt;&lt; \" \" &lt;&lt; maxCol &lt;&lt; \" \" &lt;&lt; maxLin1 &lt;&lt; \" \" &lt;&lt; maxCol1 &lt;&lt; \"\\n\";\n</code></pre>","tags":["vectori","structuri de date"]},{"location":"mediu/deque/#problema-secv-oni-2016-baraj-juniori","title":"Problema secv - ONI 2016 Baraj Juniori","text":"<p>Pentru a rezolva prima cerin\u021b\u0103, este \u00eendeajuns s\u0103 scoatem din \u0219ir de la st\u00e2nga la dreapta toate secven\u021bele de lungime \\(K\\) cu sum\u0103 mai mare dec\u00e2t \\(S\\).</p> <p>Pentru cea de-a doua cerin\u021b\u0103, afl\u0103m pentru fiecare secven\u021b\u0103 de lungime \\(K+1\\) diferen\u021ba dintre suma ei \u0219i \\(S\\), iar dac\u0103 valoarea curent\u0103 este mai mic\u0103 dec\u00e2t diferen\u021ba minim\u0103 pentru o secven\u021b\u0103 din cele (cel mult) \\(K+1\\) care o acoper\u0103, atunci ea poate fi scoas\u0103.</p> <pre><code>#include &lt;deque&gt;\n#include &lt;fstream&gt;\n#include &lt;iostream&gt;\n#include &lt;vector&gt;\n\nusing namespace std;\n\nint main() {\n    ifstream cin(\"secv.in\");\n    ofstream cout(\"secv.out\");\n\n    int c;\n    cin &gt;&gt; c;\n\n    int n, k, s;\n    cin &gt;&gt; n &gt;&gt; k &gt;&gt; s;\n\n    if (c == 1) {\n        vector&lt;long long&gt; st;\n        st.push_back(0);\n        int sz = 0;\n        int cnt = 0;\n        for (int i = 1; i &lt;= n; i++) {\n            int val;\n            cin &gt;&gt; val;\n\n            st.push_back(st.back() + val);\n            sz++;\n            if (sz &gt; k) {\n                if (st[sz] - st[sz - k] &gt; s) {\n                    for (int j = 1; j &lt;= k; j++) {\n                        st.pop_back();\n                    }\n                    sz -= k;\n                    cnt++;\n                }\n            }\n        }\n\n        cout &lt;&lt; cnt &lt;&lt; '\\n';\n    } else {\n        vector&lt;int&gt; vals(n + 1);\n        vector&lt;int&gt; sp(n + 1);\n        vector&lt;int&gt; threshold(n + 1);\n        for (int i = 1; i &lt;= n; i++) {\n            cin &gt;&gt; vals[i];\n            sp[i] = sp[i - 1] + vals[i];\n        }\n\n        for (int i = k + 1; i &lt;= n; i++) {\n            threshold[i - k] = sp[i] - sp[i - (k + 1)] - s;\n        }\n\n        int ans = 0;\n\n        deque&lt;int&gt; s;\n        for (int i = 1; i &lt;= n; i++) {\n            if (i &lt;= n - k) {\n                while (!s.empty() &amp;&amp; threshold[i] &gt; threshold[s.back()]) {\n                    s.pop_back();\n                }\n                s.push_back(i);\n            }\n            if (!s.empty() &amp;&amp; s.front() == i - (k + 1)) {\n                s.pop_front();\n            }\n\n            if (vals[i] &lt; threshold[s.front()]) {\n                ans++;\n            }\n        }\n\n        cout &lt;&lt; ans &lt;&lt; '\\n';\n    }\n    return 0;\n}\n</code></pre>","tags":["vectori","structuri de date"]},{"location":"mediu/deque/#concluzie","title":"Concluzie","text":"<p>Deque este o structur\u0103 de date foarte util\u0103 pentru foarte multe probleme ce folosesc sliding window, precum \u0219i \u00een ceea ce prive\u0219te multe optimiz\u0103ri care pleac\u0103 de la aplica\u021bii care \u00een mod normal s-ar rezolva cu o stiv\u0103 sau o coad\u0103.</p>","tags":["vectori","structuri de date"]},{"location":"mediu/deque/#probleme-suplimentare","title":"Probleme suplimentare","text":"<ul> <li>infoarena vila2</li> <li>infoarena knumere</li> <li>RoAlgo PreOJI 2024 pofta</li> <li>JBOI 2022 Wall</li> <li>Lot Juniori 2016 pofta</li> <li>IIOT Discount Optimization</li> <li>Problemele cu deque de pe kilonova</li> <li>Problemele cu deque de pe   infoarena</li> </ul>","tags":["vectori","structuri de date"]},{"location":"mediu/deque/#lectura-suplimentara","title":"Lectur\u0103 suplimentar\u0103","text":"<ul> <li>Deque CPPI Sync</li> <li>Deque si aplicatii - Infoarena</li> <li>Deque   Algopedia</li> <li>Minima/maxima over all fixed-size arrays   (multi-dimensional)</li> <li>Minimum stack / Minimum   queue</li> </ul>","tags":["vectori","structuri de date"]},{"location":"mediu/divide-et-impera/","title":"Tehnica divide et impera","text":"","tags":["functii","recursivitate","olimpiada"]},{"location":"mediu/divide-et-impera/#introducere","title":"Introducere","text":"<p>Divide et Impera (nume inspirat din doctrina romana, poate fi tradus ca dezbin\u0103 \u0219i st\u0103p\u00e2ne\u0219te) este o metod\u0103 de programare bazat\u0103 pe un principiu simplu, acela al \u00eemp\u0103r\u021birii unei probleme date \u00een dou\u0103 sau mai multe subprobleme de acela\u0219i tip, care sunt independente \u0219i prin combinarea rezultatelor ob\u021binute, ob\u021binem rezultatul problemei \u00eentregi.</p> <p>Subproblemele trebuie s\u0103 fie de acela\u0219i tip cu problema ini\u021bial\u0103, ele urm\u00e2nd a fi rezolvate prin aceea\u0219i tehnic\u0103. De regul\u0103, vom \u00eemp\u0103r\u021bi problema \u00een subprobleme de dimensiuni aproximativ egale. \u00cen urma \u00eemp\u0103r\u021birilor succesive \u00een subprobleme, se ajunge \u00een situa\u021bia c\u0103 problema curent\u0103 nu mai poate fi \u00eemp\u0103r\u021bit\u0103 \u00een subprobleme. O asemenea problem\u0103 se nume\u0219te caz de baz\u0103 (sau problem\u0103 elementar\u0103) \u0219i se rezolv\u0103 \u00eentr-un mod trivial, f\u0103r\u0103 a mai fi nevoie de alte \u00eemp\u0103r\u021biri).</p> <p>Divide et Impera admite de regul\u0103 o implementare recursiv\u0103 \u2013 rezolvarea problemei const\u0103 \u00een rezolvarea unor subprobleme de acela\u0219i tip. Un algoritm pseudocod care descrie metoda este:</p> <pre><code>func\u021bie (X) \n   dac\u0103 X este caz de baz\u0103 atunci \n      rezolv\u0103m cazul de baz\u0103\n      \u00eentoarcem r\u0103spunsul\n   altfel \n      aflam valoarea (sau valorile) de mijloc\n      \u00eemp\u0103r\u021bim problema X \u00een 2^n subprobleme, unde n este num\u0103rul de valori de mijloc\n      unim rezultatele ob\u021binute \u00een cele 2^n func\u021bii\n      \u00eentoarcem r\u0103spunsul ob\u021binut\n</code></pre> <p>Aceast\u0103 tehnic\u0103 este frecvent \u00eent\u00e2lnit\u0103 \u00een foarte multe tipuri de probleme, ea st\u00e2nd la baza multor algoritmi de sortare prin comparare (quicksort, mergesort) dar are aplica\u021bii \u0219i \u00een domeniul matematicii, fiind folosit \u00een algoritmi mai avansa\u021bi precum \u00eenmul\u021birea matricilor sau aflarea celor mai apropiate puncte \u00een plan. Totu\u0219i, acest articol se va concentra pe aplica\u021biile mai simple ale divide et impera.</p>","tags":["functii","recursivitate","olimpiada"]},{"location":"mediu/divide-et-impera/#problema-exemplu-ordonat","title":"Problema exemplu - Ordonat","text":"<p>Pentru a rezolva aceast\u0103 problem\u0103, trebuie s\u0103 identific\u0103m subproblemele \u0219i diversele cazuri care pot ap\u0103rea atunci c\u00e2nd rezolv\u0103m problema.</p> <p>\u00cen primul r\u00e2nd, pentru ca un \u0219ir s\u0103 fie ordonat, trebuie ca ambele jum\u0103t\u0103\u021bi ale \u0219irului s\u0103 fie ordonate, iar elementele din mijloc trebuie s\u0103 aib\u0103 acela\u0219i rezultat la comparare.</p> <p>De exemplu, un \u0219ir strict cresc\u0103tor este format din dou\u0103 \u0219iruri strict cresc\u0103toare, cu proprietatea c\u0103 \\(v[mij] &lt; v[mij+1]\\). Putem defini \u00een mod similar \u0219i un \u0219ir strict descresc\u0103tor.</p> <p>\u00cen cazul acestei probleme, cazul de baz\u0103 constituie \u00een \u0219irul cu lungime 1, care este at\u00e2t strict cresc\u0103tor, c\u00e2t \u0219i strict descresc\u0103tor. Pute\u021bi vedea codul surs\u0103 mai jos.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint n, v[1001];\n\nint divide(int L, int R) {\n    if (L == R) {\n        return 3;  // atat strict crescator cat si strict descrescator\n    }\n    int mid = (L + R) / 2;\n    int ansL = divide(L, mid);\n    int ansR = divide(mid + 1, R);\n    if ((ansL % 2 == 1) &amp;&amp; (ansR % 2 == 1) &amp;&amp; v[mid] &lt; v[mid + 1]) {\n        return 1;  // strict crescator\n    }\n    if ((ansL &gt;= 2) &amp;&amp; (ansR &gt;= 2) &amp;&amp; v[mid] &gt; v[mid + 1]) {\n        return 2;  // strict descrescator\n    }\n    return 0;  // neordonat\n}\nint main() {\n    cin &gt;&gt; n;\n    for (int i = 1; i &lt;= n; i++) {\n        cin &gt;&gt; v[i];\n    }\n\n    int ans = divide(1, n);\n    if (ans == 1) {\n        cout &lt;&lt; \"strict crescator\" &lt;&lt; '\\n';\n    }\n    if (ans == 2) {\n        cout &lt;&lt; \"strict descrescator\" &lt;&lt; '\\n';\n    }\n    if (ans == 0) {\n        cout &lt;&lt; \"neordonat\" &lt;&lt; '\\n';\n    }\n    return 0;\n}\n</code></pre>","tags":["functii","recursivitate","olimpiada"]},{"location":"mediu/divide-et-impera/#problema-turnurilor-din-hanoi-tower-of-hanoi-cses","title":"Problema turnurilor din Hanoi - Tower of Hanoi - CSES","text":"<p>Observa\u021bie</p> <p>Aceast\u0103 problem\u0103 este una foarte celebr\u0103, fiind studiat\u0103 de foarte mul\u021bi ani - Tower of Hanoi</p> <p>Problema const\u0103 \u00een mutarea unui \u0219ir de 3 (\u00een varianta generalizat\u0103, \\(n\\)) discuri de dimensiuni descresc\u0103toare din tija \\(A\\) \u00een tija \\(B\\), folosindu-te de o tij\u0103 ajut\u0103toare, \\(C\\). La un pas, putem muta un disc dintr-o tij\u0103 \u00een alta, cu condi\u021bia ca tija unde plas\u0103m discul s\u0103 aib\u0103 fie un disc mai mare \u00een v\u00e2rf, fie s\u0103 nu aib\u0103 niciun disc plasat.</p> <p>Num\u0103rul minim de mut\u0103ri pentru a muta \\(n\\) discuri din tija \\(A\\) \u00een tija \\(B\\) este \\(2^n - 1\\), iar algoritmul de mutare al discurilor se bazeaz\u0103 pe faptul c\u0103 vom vrea s\u0103 mut\u0103m la un pas un disc maxim \u00een tija \\(B\\), fapt ce presupune mutarea turnului cu \u00een\u0103l\u021bime \\(h - 1\\) \u00een discul \\(C\\). Acest lucru se poate simula folosind un algoritm de tipul divide et impera. Mai jos g\u0103si\u021bi un algoritm ce rezolv\u0103 aceast\u0103 problem\u0103.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nvoid hanoi(int cnt, int L, int M, int R) {  // mutam din L in R, folosind M\n    if (cnt == 0) {\n        return;\n    }\n    hanoi(cnt - 1, L, R, M);\n    cout &lt;&lt; L &lt;&lt; \" \" &lt;&lt; M &lt;&lt; '\\n';\n    hanoi(cnt - 1, R, M, L);\n}\nint main() {\n    int n;\n    cin &gt;&gt; n;\n\n    cout &lt;&lt; (1 &lt;&lt; n) - 1 &lt;&lt; '\\n';\n    hanoi(n, 1, 3, 2);\n    return 0;\n}\n</code></pre>","tags":["functii","recursivitate","olimpiada"]},{"location":"mediu/divide-et-impera/#problema-compresie-oji-2012-clasa-a-x-a","title":"Problema compresie - OJI 2012, clasa a X-a","text":"<p>Pentru a rezolva aceast\u0103 problem\u0103, va trebui s\u0103 analiz\u0103m \u0219irul dat de la intrare. Mai \u00eent\u00e2i afl\u0103m dimensiunea matricii, iar mai apoi, vom simula \u00eemp\u0103r\u021birile folosind divide et impera. Trebuie avut \u00een vedere cazurile c\u00e2nd \u00eemp\u0103r\u021bim doar \u00een dou\u0103 cadrane \u00een loc de patru, precum \u0219i cazurile de baz\u0103 c\u00e2nd umplem o zon\u0103 a matricii cu un anumit caracter.</p> <p>Mai jos pute\u021bi g\u0103si o solu\u021bie care rezolv\u0103 problema.</p> <pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\nifstream f(\"compresie.in\");\nofstream g(\"compresie.out\");\nint Stars, poz, len, nr, nl, n;\nchar c[1000002];\nchar mat[1002][1002];\nvoid Start() {\n    f &gt;&gt; c;\n    len = strlen(c);\n    for (int i = 0; i &lt; len; ++i) {\n        if (c[i] == '*') {\n            ++Stars;\n        } else if (c[i] &gt;= '0' &amp;&amp; c[i] &lt;= '9') {\n            nr = nr * 10 + c[i] - '0';\n        } else if (nr) {\n            nl += nr, nr = 0;\n        } else {\n            ++nl;\n        }\n    }\n    g &lt;&lt; Stars &lt;&lt; '\\n';\n}\nvoid rec(int stl, int stc, int sfl, int sfc) {\n    if (sfl == stl &amp;&amp; stc == sfc) {\n        mat[stl][stc] = c[poz], ++poz;\n        return;\n    }\n    if (c[poz] == '*') {\n        ++poz;\n        if (sfl == stl) {\n            rec(stl, stc, sfl, (stc + sfc) / 2);\n            rec(stl, (stc + sfc) / 2 + 1, sfl, sfc);\n        } else if (stc == sfc) {\n            rec(stl, stc, (stl + sfl) / 2, sfc);\n            rec((stl + sfl) / 2 + 1, stc, sfl, sfc);\n        } else {\n            rec(stl, stc, (stl + sfl) / 2, (stc + sfc) / 2);\n            rec(stl, (stc + sfc) / 2 + 1, (stl + sfl) / 2, sfc);\n            rec((stl + sfl) / 2 + 1, stc, sfl, (stc + sfc) / 2);\n            rec((stl + sfl) / 2 + 1, (stc + sfc) / 2 + 1, sfl, sfc);\n        }\n    } else if (c[poz] &gt;= '0' &amp;&amp; c[poz] &lt;= '9') {\n        int nr = 0;\n        while (c[poz] &gt;= '0' &amp;&amp; c[poz] &lt;= '9') {\n            nr = nr * 10 + c[poz] - '0', ++poz;\n        }\n        for (int i = stl; i &lt;= sfl; ++i) {\n            for (int j = stc; j &lt;= sfc; ++j) {\n                mat[i][j] = c[poz];\n            }\n        }\n        ++poz;\n    }\n}\nint main() {\n    Start();\n    n = sqrt(nl);\n    rec(1, 1, n, n);\n    for (int i = 1; i &lt;= n; g &lt;&lt; '\\n', ++i) {\n        for (int j = 1; j &lt;= n; ++j) {\n            g &lt;&lt; mat[i][j];\n        }\n    }\n    return 0;\n}\n</code></pre>","tags":["functii","recursivitate","olimpiada"]},{"location":"mediu/divide-et-impera/#problema-interesting-array","title":"Problema Interesting Array","text":"<p>Pentru a rezolva aceast\u0103 problem\u0103, trebuie s\u0103 plec\u0103m de la \u0219irul ini\u021bial \u0219i ne baz\u0103m pe faptul c\u0103 vom avea cel mult \\(\\sqrt n\\) frecven\u021be distincte, fapt ce motiveaz\u0103 o parcurgere de tip divide et impera, unde excludem mereu valorile cu frecven\u021b\u0103 minim\u0103. De\u0219i \u00een teorie acest algoritm poate avea o complexitate de tip \\(\\mathcal{O}(n \\sqrt n)\\), \u00een practic\u0103 algoritmul va fi foarte rapid \u0219i relativ simplu de implementat.</p> <pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n\nint v[100001];\nlong long ans;\n\nvoid query(int a, int b) {\n    map&lt;int, long long&gt; m;\n    long long maxx = 0, minn = 1e9;\n    for (int i = a; i &lt;= b; i++) {\n        m[v[i]]++;\n    }\n    for (auto it : m) {\n        maxx = max(maxx, it.second);\n        minn = min(minn, it.second);\n    }\n    ans = max(ans, maxx * minn);\n    for (int i = a; i &lt;= b; i++) {\n        int j = i - 1;\n        while (j + 1 &lt;= b &amp;&amp; m[v[j + 1]] != minn) {\n            j++;\n        }\n        if (j &gt;= i) {\n            query(i, j);\n            i = j;\n        }\n    }\n}\n\nint main() {\n    int n;\n    cin &gt;&gt; n;\n    for (int i = 1; i &lt;= n; i++) {\n        cin &gt;&gt; v[i];\n    }\n    query(1, n);\n    cout &lt;&lt; ans;\n    return 0;\n}\n</code></pre>","tags":["functii","recursivitate","olimpiada"]},{"location":"mediu/divide-et-impera/#concluzii","title":"Concluzii","text":"<p>Tehnica divide et impera este o tehnic\u0103 foarte important\u0103 pentru \u00een\u021belegerea principiului din spatele unor algoritmi de sortare mai dificili, care chiar dac\u0103 nu trebuie implementa\u021bi \u00een timpul unui concurs de algoritmic\u0103 datorit\u0103 existen\u021bei func\u021biei std::sort, problemele care folosesc propriet\u0103\u021bile acestor algoritmi apar \u00een anumite situa\u021bii. De asemenea, unele probleme se dovedesc a fi exerci\u021bii de implementare foarte utile, care s-au mai reg\u0103sit \u00een problemele date la olimpiad\u0103 la clasa a X-a.</p>","tags":["functii","recursivitate","olimpiada"]},{"location":"mediu/divide-et-impera/#probleme-suplimentare","title":"Probleme suplimentare","text":"<ul> <li>c\u00e2t mai multe probleme din acest capitol pentru Divide et   Impera</li> <li>OJI 2024 aprogressive</li> <li>ONI 2013 romb</li> <li>Codeforces a-good String</li> <li>infoarena bitcost</li> <li>Codeforces Creative Snap</li> <li>OJI 2017 caps</li> <li>ONI 2010 xp</li> <li>Codeforces Dr. Evil   Underscores</li> <li>ONI 2004 invsort</li> <li>Codeforces The Number of   Subpermutations</li> <li>ONI 2018 proiectoare</li> <li>RCPC 2023 blabla</li> <li>probleme cu Divide et Impera de pe   Codeforces</li> <li>probleme cu Divide et Impera de pe Kilonova</li> </ul>","tags":["functii","recursivitate","olimpiada"]},{"location":"mediu/divide-et-impera/#resurse-suplimentare","title":"Resurse suplimentare","text":"<ul> <li>Divide et Impera -   pbinfo</li> <li>Divide et Impera - cppi   sync</li> </ul>","tags":["functii","recursivitate","olimpiada"]},{"location":"mediu/dsu/","title":"P\u0103duri de mul\u021bimi disjuncte (DSU)","text":"<p>Con\u021binutul articolului</p> <p>O bun\u0103 parte din con\u021binutul acestui articol este preluat din cursul creat de acela\u0219i autor pentru lotul de juniori din 2023, curs care se poate g\u0103si aici</p> <p>Structurile de date sunt de multe ori foarte utile \u00een multe contexte \u00een programare, acestea dovedindu-se a fi \u00een special foarte puternice \u0219i esen\u021biale \u00een lucrul problemelor date la diverse olimpiade \u0219i concursuri de informatic\u0103. Acest articol va prezenta o structur\u0103 de date care nu e la prima vedere foarte complicat\u0103 fa\u021b\u0103 de alte structuri de date mai consacrate, dar care se dovede\u0219te a fi foarte puternic\u0103 \u00een rezolvarea multor probleme de toate felurile.</p> <p>A\u0219a cum sugereaz\u0103 \u0219i titlul, vom prezenta \u00een acest articol p\u0103durile de mul\u021bimi disjuncte, sau union-find, denumire dat\u0103 dup\u0103 cele dou\u0103 opera\u021bii principale pe care aceast\u0103 structur\u0103 de date le ofer\u0103. Union-Find poate fi folosit cu mare u\u0219urin\u021b\u0103 pentru probleme de tipul acelora \u00een care ni se cere s\u0103 afl\u0103m pe parcurs ce valori sunt legate \u00eentre ele printr-o rela\u021bie, presupun\u00e2nd c\u0103 rela\u021biile dintre valori se adaug\u0103 treptat. Pe parcurs se vor remarca diverse optimiz\u0103ri, precum \u0219i diferitele clase de probleme \u00een care se poate folosi o asemenea structur\u0103 de date.</p> <p>Pentru u\u0219urarea explica\u021biilor, vom presupune c\u0103 avem o situa\u021bie ipotetic\u0103 \u00een care avem \\(n\\) prieteni \u0219i ni se dau opera\u021bii \u00een care fie dou\u0103 persoane devin prietene, fie trebuie s\u0103 decidem dac\u0103 dou\u0103 persoane apar\u021bin aceluia\u0219i grup de prieteni.</p>","tags":["vectori","arbori","multimi"]},{"location":"mediu/dsu/#definirea-operatiilor-si-functionalitatii-structurii-de-date","title":"Definirea opera\u021biilor \u0219i func\u021bionalit\u0103\u021bii structurii de date","text":"","tags":["vectori","arbori","multimi"]},{"location":"mediu/dsu/#fundamente","title":"Fundamente","text":"<p>Pentru a reprezenta datele, vom \u021bine \u00eentr-un vector dimensiunea fiec\u0103rei mul\u021bimi, iar \u00eentr-un alt vector vom \u021bine pentru fiecare pozi\u021bie, nodul reprezentativ corespunz\u0103tor grupului de prieteni din care face parte, la \u00eenceput fiecare nod fiind reprezentantul lui \u00eensu\u0219i.</p> <pre><code>vector&lt;int&gt; rad(n + 1), card(n + 1);\n\nfor (int i = 1; i &lt;= n; ++i) {\n    rad[i] = i;\n    card[i] = 1;\n}\n</code></pre>","tags":["vectori","arbori","multimi"]},{"location":"mediu/dsu/#operatia-de-unire-union","title":"Opera\u021bia de unire (Union)","text":"<p>La acest pas, ni se dau dou\u0103 persoane \u0219i trebuie s\u0103 stabilim rela\u021bia de prietenie dintre ei. De\u0219i aceast\u0103 opera\u021bie se face \u00een timp constant, conteaz\u0103 foarte mult modul \u00een care facem rela\u021bia de atribuire, aceasta put\u00e2nd schimba radical complexitatea algoritmului. Astfel, voi introduce prima optimizare, si anume optimizarea de unire dup\u0103 cardinalul mul\u021bimii, astfel \u00eenc\u00e2t vom uni mereu mul\u021bimea cu cardinal mai mic la mul\u021bimea cu cardinal mai mare.</p> <p>Motivul pentru care aceast\u0103 optimizare duce la o complexitate mai mic\u0103 va fi dat de num\u0103rul mai mic de opera\u021bii pe care func\u021bia Find le va face la fiecare pas. De asemenea, aceast\u0103 optimizare de a uni mul\u021bimile mai mici la cele mai mari se reg\u0103se\u0219te \u00een mod frecvent \u0219i \u00een alte contexte \u00een diverse structuri de date \u0219i nu numai.</p> <pre><code>void Union(int a, int b) {\n    if (card[a] &lt; card[b]) {  // (1)\n        swap(a, b);\n    }\n    rad[b] = a;          // (2)\n    card[a] += card[b];  // (3)\n}\n</code></pre> <ol> <li>Vom vrea sa ata\u0219\u0103m nodul \\(b\\) la nodul \\(a\\).</li> <li>R\u0103d\u0103cina lui \\(b\\) devine \\(a\\).</li> <li>Cre\u0219tem cardinalul lui \\(a\\) cu cardinalul lui \\(b\\).</li> </ol>","tags":["vectori","arbori","multimi"]},{"location":"mediu/dsu/#operatia-de-cautare-find","title":"Opera\u021bia de c\u0103utare (Find)","text":"<p>La aceast\u0103 opera\u021bie, vrem s\u0103 g\u0103sim pentru un nod, pozi\u021bia nodului reprezentativ \u00een structura noastr\u0103 de date. \u00cen mod normal, aceast\u0103 opera\u021bie poate face cel mult \\(\\mathcal{O}(n)\\) pa\u0219i, \u00een cazul \u00een care arborele rezultat ar fi un lan\u021b. Totu\u0219i, putem s\u0103 ne folosim de parcurgerile pe care le facem pentru a re\u021bine rezultatele pentru toate nodurile de pe parcursul acelui drum, astfel \u00eenc\u00e2t la o parcurgere ulterioar\u0103, num\u0103rul de pa\u0219i s\u0103 se reduc\u0103 spre un num\u0103r constant, structura arborelui ajung\u00e2nd similar\u0103 cu cea a unui arbore stea.</p> <pre><code>int Find(int x) {\n    if (rad[x] == x) {  // (1)\n        return x;\n    }\n    rad[x] = Find(rad[x]);  // (2)\n    return rad[x];\n}\n</code></pre> <ol> <li>Dac\u0103 nodul nostru este r\u0103d\u0103cin\u0103, \u00eenseamn\u0103 c\u0103 l-am g\u0103sit \u0219i-l return\u0103m \u00een    consecin\u021b\u0103.</li> <li>R\u0103d\u0103cina nodului nostru va deveni r\u0103d\u0103cina r\u0103d\u0103cinii curente.</li> </ol>","tags":["vectori","arbori","multimi"]},{"location":"mediu/dsu/#prime-concluzii","title":"Prime concluzii","text":"<p>Opera\u021bia union are complexitatea \\(\\mathcal{O}(1)\\), iar opera\u021bia de find are complexitatea \\(\\mathcal{O}(n)\\). Totu\u0219i, datorit\u0103 optimiz\u0103rilor men\u021bionate mai sus (compresia drumurilor \u0219i unirea dup\u0103 dimensiunea mul\u021bimilor), num\u0103rul total de opera\u021bii f\u0103cute este \\(\\mathcal{O}(n \\log^* n)\\), unde \\(\\log^* x\\) reprezint\u0103 inversul func\u021biei Ackermann, valoare care se poate aproxima ca fiind o constant\u0103. De asemenea, nefolosirea optimiz\u0103rii de compresie a drumurilor ar duce la complexitatea \\(\\mathcal{O}(n \\log n)\\), rezultat foarte important \u00een contextul altor optimiz\u0103ri, cum ar fi tehnica small-to-large sau \u00een general \u00een demonstrarea diverselor rezultate ce \u021bin de sume armonice.</p>","tags":["vectori","arbori","multimi"]},{"location":"mediu/dsu/#problema-disjoint","title":"Problema disjoint","text":"<p>Pentru fiecare opera\u021bie citit\u0103 de la intrare, vom implementa func\u021biile necesare pentru a ob\u021bine rezultatul problemei. Unirea a dou\u0103 mul\u021bimi implic\u0103 mai \u00eent\u00e2i folosirea func\u021biei Find pentru a g\u0103si r\u0103d\u0103cinile, iar mai apoi folosim func\u021bia Union pentru a face unirea propriu-zis\u0103. Folosirea ambelor optimiz\u0103ri pentru \u00eembun\u0103t\u0103\u021birea complexit\u0103\u021bii duce la solu\u021bia optim\u0103, ce ruleaz\u0103 \u00eentr-un timp aproximativ liniar raportat la num\u0103rul de valori citite.</p> <p>Solu\u021bia de 100 de puncte este urm\u0103toarea:</p> <pre><code>#include &lt;fstream&gt;\n#include &lt;vector&gt;\n\nusing namespace std;\n\nconstexpr int NMAX = 100002;\n\nint n, m;\n\nvector&lt;int&gt; rad(NMAX), card(NMAX);\n\nint Find(int x) {\n    if (rad[x] == x) {\n        return x;\n    }\n    rad[x] = Find(rad[x]);\n    return rad[x];\n}\n\nvoid Union(int a, int b) {\n    if (card[a] &lt; card[b]) {\n        swap(a, b);\n    }\n    rad[b] = a;\n    card[a] += card[b];\n}\n\nint main() {\n    ifstream fin(\"disjoint.in\");\n    ofstream fout(\"disjoint.out\");\n\n    fin &gt;&gt; n &gt;&gt; m;\n\n    for (int i = 1; i &lt;= n; ++i) {\n        rad[i] = i;\n        card[i] = 1;\n    }\n\n    for (int i = 1; i &lt;= m; ++i) {\n        int cod, x, y;\n        fin &gt;&gt; cod &gt;&gt; x &gt;&gt; y;\n\n        if (cod == 1 &amp;&amp; Find(x) != Find(y)) {\n            Union(Find(x), Find(y));\n        } else {\n            fout &lt;&lt; (Find(x) == Find(y)) ? \"DA\\n\" : \"NU\\n\";\n        }\n    }\n\n    fin.close();\n    fout.close();\n    return 0;\n}\n</code></pre>","tags":["vectori","arbori","multimi"]},{"location":"mediu/dsu/#oare-putem-implementa-mai-eficient","title":"Oare putem implementa mai eficient?","text":"<p>Ini\u021bial, noi am implementat aceast\u0103 structur\u0103 folosind doi vectori, anume cel \u00een care \u021binem cardinalul fiec\u0103rei mul\u021bimi, precum \u0219i cel \u00een care \u021binem r\u0103d\u0103cina fiec\u0103rei mul\u021bimi. Totu\u0219i, se poate observa faptul c\u0103 noi folosim o gr\u0103mad\u0103 de informa\u021bie inutil\u0103 din cauza faptului c\u0103 pentru fiecare num\u0103r, practic ne intereseaz\u0103 doar dac\u0103 e o r\u0103d\u0103cin\u0103 a unei mul\u021bimi de valori sau nu. Astfel, vom recurge la a reprezenta pozi\u021biile corespunz\u0103toare r\u0103d\u0103cinilor cu numere negative, reprezent\u00e2nd \\(-x\\), unde \\(x\\) e cardinalul mul\u021bimii reprezentat de acea valoare, respectiv reprezentarea nodurilor adiacente cu numere pozitive, reprezent\u00e2nd r\u0103d\u0103cina mul\u021bimii din care acea valoare face parte.</p> <p>Solu\u021bia de 100 de puncte cu optimizarea de memorie este urm\u0103toarea:</p> <pre><code>#include &lt;fstream&gt;\n#include &lt;vector&gt;\n\nusing namespace std;\n\nconstexpr int NMAX = 100002;\n\nint n, q;\n\nvector&lt;int&gt; sz(NMAX);\n\nint Find(int nod) {\n    if (sz[nod] &lt; 0) {\n        return nod;\n    }\n    sz[nod] = Find(sz[nod]);\n    return sz[nod];\n}\n\nvoid Union(int a, int b) {\n    if (a == b) {\n        return;\n    }\n\n    if (sz[a] &gt; sz[b]) {\n        swap(a, b);\n    }\n\n    sz[a] += sz[b];\n    sz[b] = a;\n}\n\nint main() {\n    ifstream fin(\"disjoint.in\");\n    ofstream fout(\"disjoint.out\");\n\n    fin &gt;&gt; n &gt;&gt; q;\n\n    for (int i = 1; i &lt;= n; ++i) {\n        sz[i] = -1;\n    }\n\n    for (int i = 1; i &lt;= q; ++i) {\n        int cod, x, y;\n        fin &gt;&gt; cod &gt;&gt; x &gt;&gt; y;\n\n        if (cod == 1 &amp;&amp; Find(x) != Find(y)) {\n            Union(Find(x), Find(y));\n        } else {\n            fout &lt;&lt; (Find(x) == Find(y)) ? \"DA\\n\" : \"NU\\n\";\n        }\n    }\n\n    fin.close();\n    fout.close();\n    return 0;\n}\n</code></pre>","tags":["vectori","arbori","multimi"]},{"location":"mediu/dsu/#problema-bile","title":"Problema bile","text":"<p>Cerin\u021b\u0103</p> <p>Pe o tabla patratica impartita in \\(N^2\\) patratele (\\(N\\) linii si \\(N\\) coloane), se afla asezate \\(N^2\\) bile (cate una in fiecare patratica a tablei). Lui Gigel ii plac bilele foarte mult, astfel ca el ia, pe rand, cate o bila de pe tabla, pana cand nu mai ramane pe tabla nici o bila. Gigel este, de asemenea, un baiat foarte curios. El a constatat ca bilele pot fi impartite in componente conexe, astfel:</p> <ul> <li> <p>fiecare bila face parte din exact o componenta conexa</p> </li> <li> <p>daca 2 bile sunt invecinate pe orizontala sau verticala, atunci ele fac   parte din aceeasi componenta conexa (adica daca una se afla imediat   deasupra, dedesubtul, la dreapta sau la stanga celeilalte)</p> </li> </ul> <p>Dimensiunea unei componente conexe este egala cu numarul de bile care fac parte din componenta conex\u0103 respectiv\u0103. Dupa fiecare bila luata, Gigel vrea sa stie care este valoarea maxima dintre dimensiunile componentelor conexe din care fac parte bilele ramase.</p> <p>Mai \u00eent\u00e2i, trebuie observat faptul c\u0103 problema determin\u0103rii conectivit\u0103\u021bii dinamice este una foarte dificil de rezolvat (vezi acest articol de pe Wikipedia), deci nu are sens s\u0103 ne chinuim cu asemenea implement\u0103ri care nu fac obiectul cursului nostru sau \u00een general a programelor olimpiadelor de informatic\u0103.</p> <p>Asta ne duce cu g\u00e2ndul s\u0103 \u00eencerc\u0103m s\u0103 privim problema dintr-o perspectiv\u0103 diferit\u0103, \u00een special \u0219i datorit\u0103 faptului c\u0103 nu suntem for\u021ba\u021bi s\u0103 r\u0103spundem la actualiz\u0103ri online. Din acest motiv, vom introduce o abordare care se folose\u0219te la multe solu\u021bii ce se bazeaz\u0103 pe folosirea p\u0103durilor de mul\u021bimi disjuncte.</p> <p>Practic, \u00een loc s\u0103 privim problema de la \u00eenceput la final, vom rezolva problema invers\u0103, \u00een care putem ad\u0103uga bile, ceea ce ne ajut\u0103 s\u0103 reducem problema la o aplica\u021bie standard a p\u0103durilor de mul\u021bimi disjuncte, r\u0103spunsurile ajung\u00e2nd \u00een cele din urm\u0103 s\u0103 fie afi\u0219ate \u00een ordinea invers\u0103 \u00een care le-am aflat.</p> <p>Solu\u021bia de 100 de puncte este urm\u0103toarea:</p> <pre><code>#include &lt;algorithm&gt;\n#include &lt;fstream&gt;\n#include &lt;utility&gt;\n\nusing namespace std;\n\ntemplate &lt;typename T, size_t N&gt;\nusing Array = T[N];\n\nint n, maxim;\n\nArray&lt;int, 251 * 251&gt; rad, card, rasp;\nArray&lt;pair&lt;int, int&gt;, 251 * 251&gt; elim;\nArray&lt;Array&lt;int, 251&gt;, 251&gt; nr;\nArray&lt;Array&lt;bool, 251&gt;, 251&gt; viz;\n\nint dx[] = {-1, 0, 1, 0};\nint dy[] = {0, 1, 0, -1};\n\nint Find(int x) {\n    if (rad[x] == x) {\n        return x;\n    }\n\n    return rad[x] = Find(rad[x]);\n}\n\nvoid Union(int a, int b) {\n    if (card[a] &lt; card[b]) {\n        swap(a, b);\n    }\n\n    rad[b] = a;\n    card[a] += card[b];\n\n    maxim = max(maxim, card[a]);\n}\n\nint main() {\n    ifstream fin(\"bile.in\");\n\n    fin &gt;&gt; n;\n\n    for (int i = 1; i &lt;= n; ++i) {\n        for (int j = 1; j &lt;= n; j++) {\n            int idx = (i - 1) * n + j;\n            nr[i][j] = idx;\n            card[idx] = 1;\n            rad[idx] = idx;\n        }\n    }\n\n    for (int i = 1; i &lt;= n * n; ++i) {\n        fin &gt;&gt; elim[i].first &gt;&gt; elim[i].second;\n    }\n\n    fin.close();\n\n    for (int i = n * n; i &gt;= 1; i--) {\n        rasp[i] = maxim;\n        int x = elim[i].first;\n        int y = elim[i].second;\n\n        for (int j = 0; j &lt; 4; j++) {\n            int newX = x + dx[j];\n            int newY = y + dy[j];\n\n            if (newX &gt;= 1 &amp;&amp; newX &lt;= n &amp;&amp; newY &gt;= 1 &amp;&amp; newY &lt;= n\n                &amp;&amp; viz[newX][newY]) {\n                int b1 = nr[x][y];\n                int b2 = nr[newX][newY];\n                if (nr[newX][newY] != 0 &amp;&amp; Find(b1) != Find(b2)) {\n                    Union(Find(b1), Find(b2));\n                }\n            }\n        }\n\n        maxim = max(maxim, 1);\n        viz[x][y] = true;\n    }\n\n    ofstream fout(\"bile.out\");\n\n    for (int i = 1; i &lt;= n * n; ++i) {\n        fout &lt;&lt; rasp[i] &lt;&lt; '\\n';\n    }\n\n    fout.close();\n\n    return 0;\n}\n</code></pre>","tags":["vectori","arbori","multimi"]},{"location":"mediu/dsu/#problema-secvmax","title":"Problema Secvmax","text":"<p>Cerin\u021b\u0103</p> <p>Fiona are o secventa de \\(N\\) numere naturale. Ea se \u00eentreab\u0103 din c\u00e2nd \u00een c\u00e2nd pentru un anumit num\u0103r \\(Q\\) care este cea mai lung\u0103 subsecven\u021b\u0103 care are toate numerele mai mici sau egale cu \\(Q\\). Ajuta\u021bi-o pe Fiona s\u0103 \u00ee\u0219i r\u0103spund\u0103 la toate \u00eentreb\u0103rile.</p> <p>Aici putem folosi din nou prelucrarea numerelor \u00een ordine cresc\u0103toare a numerelor din vector, iar atunci c\u00e2nd ad\u0103ug\u0103m valorile \u00een considerare, vom verifica fiecare vecin s\u0103 vedem dac\u0103 putem uni valorile din cele dou\u0103 mul\u021bimi, iar la fiecare pas r\u0103spunsul e cardinalul maxim al unei mul\u021bimi, care e cresc\u0103tor pe m\u0103sur\u0103 ce cre\u0219tem valorile ad\u0103ugate.  </p> <pre><code>#include &lt;algorithm&gt;\n#include &lt;fstream&gt;\n#include &lt;vector&gt;\n\nusing namespace std;\n\nifstream f(\"secvmax.in\");\nofstream g(\"secvmax.out\");\n\nstruct Pair {\n    int value;\n    int index;\n\n    constexpr bool operator&lt;(const Pair &amp;other) const {\n        if (value == other.value) {\n            return index &lt; other.index;\n        }\n        return value &lt; other.value;\n    }\n};\n\nvector&lt;Pair&gt; queries, elements;\nvector&lt;int&gt; result, parent, sequence, length;\nint maxLength = 0;\n\nint Find(int node) {\n    int root;\n    for (root = parent[node]; root != parent[root]; root = parent[root])\n        ;\n    int x = node;\n    while (x != root) {\n        swap(root, parent[x]);\n    }\n    return root;\n}\n\nvoid Union(int a, int b) {\n    if (length[a] &lt; length[b]) {\n        length[b] += length[a];\n        parent[a] = b;\n        length[a] = 0;\n    } else {\n        length[a] += length[b];\n        parent[b] = a;\n        length[b] = 0;\n    }\n\n    maxLength = max(maxLength, length[a] + length[b]);\n}\n\nint main() {\n    int n, q;\n    f &gt;&gt; n &gt;&gt; q;\n\n    elements.resize(n + 1);\n    parent.resize(n + 1);\n    sequence.resize(n + 1);\n    length.resize(n + 1);\n\n    queries.resize(q + 1);\n    result.resize(q + 1);\n\n    for (int i = 1; i &lt;= n; ++i) {\n        int value;\n        f &gt;&gt; value;\n        elements[i] = {value, i};\n        sequence[i] = value;\n        parent[i] = i;\n    }\n\n    sort(elements.begin() + 1, elements.end());\n\n    for (int i = 1; i &lt;= q; ++i) {\n        int value;\n        f &gt;&gt; value;\n        queries[i] = {value, i};\n    }\n\n    sort(queries.begin() + 1, queries.end());\n\n    int pos = 1;\n\n    for (int i = 1; i &lt;= q; ++i) {\n        while (pos &lt;= n &amp;&amp; elements[pos].value &lt;= queries[i].value) {\n            int idx = elements[pos++].index;\n            length[idx] = 1;\n            maxLength = max(maxLength, 1);\n\n            if (idx &gt; 0 &amp;&amp; sequence[idx - 1] &lt;= sequence[idx]) {\n                Union(Find(idx - 1), Find(idx));\n            }\n\n            if (idx &lt; n - 1 &amp;&amp; sequence[idx + 1] &lt; sequence[idx]) {\n                Union(Find(idx + 1), Find(idx));\n            }\n        }\n        result[queries[i].index] = maxLength;\n    }\n\n    for (int i = 1; i &lt;= q; ++i) {\n        g &lt;&lt; result[i] &lt;&lt; '\\n';\n    }\n\n    return 0;\n}\n</code></pre>","tags":["vectori","arbori","multimi"]},{"location":"mediu/dsu/#problema-joingraf","title":"Problema joingraf","text":"<p>Cerin\u021b\u0103</p> <p>A fost ziua lui Traian de cur\u00e2nd, iar el a primit \u00een dar un graf cu \\(N\\) noduri. La \u00eenceput, fiecare nod era \u00eentr-o component\u0103 conex\u0103, singur. Dar apoi, c\u00e2inele lui Traian a venit \u0219i i-a spus \\(Q\\) \u00eentreb\u0103ri de forma urm\u0103toare:</p> <ul> <li>\\(1 \\ x \\ y\\): Adaug\u0103 la graful t\u0103u muchiile \\((x, x + 1), (x + 1, x + 2),   \\dots , (y - 1, y)\\)</li> <li>\\(2 \\ x \\ y\\): Spune dac\u0103 nodurile \\(x\\) \u0219i \\(y\\) sunt \u00een aceea\u0219i component\u0103   conex\u0103.</li> </ul> <p>Pentru a rezolva aceast\u0103 problem\u0103 exist\u0103 mai multe abord\u0103ri, plec\u00e2nd de la diverse moduri de a g\u00e2ndi problema, dar \u00een contextul p\u0103durilor de mul\u021bimi disjuncte, ne vom concentra pe solu\u021bia cu DSU.</p> <p>Mai \u00eent\u00e2i, trebuie s\u0103 observ\u0103m c\u0103 componentele conexe sunt ca ni\u0219te intervale. De exemplu, s\u0103 lu\u0103m \\(n = 7\\). Atunci, la \u00eenceput intervalele vor fi: \\([1, 1], [2, 2], [3, 3], [4, 4], [5, 5], [6, 6], [7, 7]\\). Dac\u0103 unim muchiile de la 3 la 6, intervalele vor deveni: \\([1, 1], [2, 2], [3, 6], [7, 7]\\).</p> <p>Atunci, putem folosi o structur\u0103 de tip DSU. Vom re\u021bine \\(par_i\\) ca \"p\u0103rintele\" nodului \\(i\\), sau mai u\u0219or de \u00een\u021beles, cap\u0103tul st\u00e2nga al intervalului \u00een care este nodul \\(i\\). Este nevoie s\u0103 re\u021binem doar cap\u0103tul dreapta, deoarece cap\u0103tul dreapta al secven\u021bei curente este predecesorul cap\u0103tului st\u00e2nga al secven\u021bei urm\u0103toare. Vom re\u021bine \u0219i \\(nxt_i\\) cap\u0103tul st\u00e2nga al secven\u021bei de dup\u0103 secven\u021ba \u00een care este \\(i\\).</p> <p>Iar atunci c\u00e2nd avem update cu \\(x, y\\), mergem la fiecare secven\u021b\u0103 p\u00e2n\u0103 la \\(y\\) (adic\u0103 c\u00e2nd avans\u0103m de la \\(p\\) la urm\u0103toarea, facem \\(p = nxt_p\\)) \u0219i o reunim cu secven\u021ba \u00een care este \\(x\\).</p> <p>Iar la query, verific\u0103m dac\u0103 intervalul \u00een care este \\(x\\) este egal cu cel \u00een care este \\(y\\). Complexitate: \\(\\mathcal{O}(N + Q \\ log \\ N)\\) timp, \\(\\mathcal{O}(n)\\) memorie.</p> <pre><code>#include &lt;iostream&gt;\n#include &lt;vector&gt;\n\nusing namespace std;\n\nconstexpr int N = 1e6 + 2;\nint n, q;\n\nvector&lt;int&gt; tt(N), jump(N);\n\nint root(int nd) {\n    while (tt[nd] != nd) {\n        return tt[nd] = root(tt[nd]);\n    }\n    return nd;\n}\nvoid unite(int a, int b) {\n    a = root(a);\n    b = root(b);\n\n    if (a == b) {\n        return;\n    }\n\n    tt[b] = tt[a];\n}\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(nullptr);\n\n    cin &gt;&gt; n &gt;&gt; q;\n\n    for (int i = 1; i &lt;= n; i++) {\n        tt[i] = jump[i] = i;\n    }\n\n    while (q--) {\n        int t, x, y;\n        cin &gt;&gt; t &gt;&gt; x &gt;&gt; y;\n\n        if (t != 1) {\n            cout &lt;&lt; (root(x) == root(y) ? \"Da\\n\" : \"Nu\\n\");\n            continue;\n        }\n\n        int p = x;\n        while (p &lt;= y) {\n            unite(x, p);\n            p = jump[p] + 1;\n        }\n        jump[x] = jump[y];\n    }\n    return 0;\n}\n</code></pre>","tags":["vectori","arbori","multimi"]},{"location":"mediu/dsu/#concluzii","title":"Concluzii","text":"<p>Acest articol este menit s\u0103 introduc\u0103 audien\u021ba \u00een folosirea p\u0103durilor de mul\u021bimi disjuncte, pun\u00e2nd accentul pe func\u021bionalit\u0103\u021bile de baz\u0103, f\u0103r\u0103 a men\u021biona alte aplica\u021bii importante, cum ar fi algoritmul lui Kruskal sau algoritmii folosi\u021bi pentru dynamic connectivity. De asemenea, p\u0103durile de mul\u021bimi disjuncte pot fi folosite pentru a scurta foarte mult implement\u0103rile aplica\u021biilor simple la grafuri.</p>","tags":["vectori","arbori","multimi"]},{"location":"mediu/dsu/#probleme-suplimentare","title":"Probleme suplimentare","text":"<ul> <li>Chemical table - EJOI 2018</li> <li>MexC ONI 2008</li> <li>Microcycles - Codeforces</li> <li>Galleries - AGM 2020</li> <li>JBOI 2023 Frequencies</li> <li>IIOT 2023-24 Binary Chess</li> <li>Probleme cu DSU de pe kilonova</li> <li>COCI 13-ladice</li> <li>USACO MooTube</li> <li>USACO Wormhole   Sort</li> <li>DSU Step 1 - Codeforces   EDU</li> <li>DSU Step 2 - Codeforces   EDU</li> </ul>","tags":["vectori","arbori","multimi"]},{"location":"mediu/dsu/#bibliografie-si-lectura-suplimentara","title":"Bibliografie \u0219i lectur\u0103 suplimentar\u0103","text":"<ul> <li>P\u0103duri de mul\u021bimi disjuncte - CS   Academy</li> <li>Algoritmul Union-Find -   Algopedia</li> <li>Link ce trebuie accesat pentru inscrierea la cursul despre DSU facut de ITMO   Academy</li> <li>Articol USACO Guide - DSU</li> <li>Curs despre DSU - Codeforces (este necesar un cont pentru a putea accesa   acest curs, plus accesarea linkului de mai   sus)</li> <li>Sack (dsu on tree) - Avansat</li> <li>Smenul de manevrare a query-urilor offline cu   DSU</li> </ul>","tags":["vectori","arbori","multimi"]},{"location":"mediu/euler-totient/","title":"Indicatorul lui Euler","text":"","tags":["matematica","divizori","precalculari"]},{"location":"mediu/euler-totient/#introducere","title":"Introducere","text":"<p>Defini\u021bie</p> <p>Indicatorul lui Euler este un rezultat matematic care este folosit pentru a num\u0103ra c\u00e2te valori prime cu \\(n\\) sunt \u00een intervalul \\([1, n]\\). Acesta este notat cu \\(\\varphi (n)\\).</p> <p>Exemplu</p> <p>De exemplu, \\(\\varphi (12) = 4\\), deoarece 1, 5, 7 \u0219i 11 sunt prime cu 12.</p> <p>Aceast\u0103 func\u021bie se va dovedi util\u0103 \u00een multe probleme de algoritmic\u0103, fie c\u0103 e vorba de aflarea unor r\u0103spunsuri referitoare la divizorii comuni ai unor numere sau ca pas intermediar \u00een algoritmi \u0219i metode mai complicate, precum Func\u021bia M\u00f6bius sau pentru cei mai avansa\u021bi, teorema chinezeasc\u0103 a resturilor.</p>","tags":["matematica","divizori","precalculari"]},{"location":"mediu/euler-totient/#calcularea-functiei-si-proprietatile-acesteia","title":"Calcularea func\u021biei \u0219i propriet\u0103\u021bile acesteia","text":"<p>Pentru a calcula \\(\\varphi (n)\\), putem fie s\u0103 verific\u0103m pentru fiecare num\u0103r de la 1 la \\(n\\) dac\u0103 \\((i, n) = 1\\), unde cu \\((a, b)\\) am notat cel mai mare divizor comun al numerelor \\(a\\) \u0219i \\(b\\), fie s\u0103 g\u0103sim o formul\u0103 care se bazeaz\u0103 pe o observa\u021bie mai avansat\u0103.</p> <p>Cu alte cuvinte, dac\u0103 \u0219tim factorii primi care apar \u00een reprezentarea lui \\(n\\), \u00eei not\u0103m \\(p_1\\), \\(p_2\\), \\(\\dots\\), \\(p_k\\), formula va deveni urm\u0103toarea:</p> \\[ n \\cdot \\prod_{1}^{k} \\frac{p_i - 1}{p_i} \\] <p>De exemplu, pentru \\(n = 30\\), \\(\\varphi (n) = \\frac{2 - 1}{2} \\cdot \\frac{3 - 1}{3} \\cdot \\frac{5 - 1}{5} = 8\\)</p> <p>Aceast\u0103 formul\u0103 poate fi calculat\u0103 \u00een \\(\\mathcal{O}(\\sqrt n)\\) folosind un algoritm similar cu cel pentru aflarea divizorilor primi ai unui num\u0103r, codul de mai jos rezolv\u00e2nd problema Phi de pe pbinfo.</p> <p>Observa\u021bie</p> <p>Trebuie avut grij\u0103 s\u0103 \u00eemp\u0103r\u021bim mai \u00eent\u00e2i r\u0103spunsul la \\(i\\) \u0219i apoi s\u0103 \u00eenmul\u021bim cu \\((i-1)\\), pentru a evita un overflow care nu este necesar, dat fiind c\u0103 \\(\\varphi \\ (n) \\leq n\\).</p> <pre><code>int Phi(int n) {\n    int ans = n;\n    for (int i = 2; i * i &lt;= n; i++) {\n        if (n % i == 0) {\n            ans = ans / i;\n            ans = ans * (i - 1);\n            while (n % i == 0) {\n                n /= i;\n            }\n        }\n    }\n    if (n &gt; 1) {\n        ans = ans / n;\n        ans = ans * (n - 1);\n    }\n    return ans;\n}\n</code></pre>","tags":["matematica","divizori","precalculari"]},{"location":"mediu/euler-totient/#calcularea-functiei-pentru-toate-valorile-de-la-1-la-n","title":"Calcularea func\u021biei pentru toate valorile de la 1 la \\(n\\)","text":"<p>Pentru a calcula \\(\\varphi (i)\\) pentru toate valorile de la 1 la \\(n\\), tot ce trebuie s\u0103 facem este s\u0103 folosim o precalculare similar\u0103 cu cea descris\u0103 la ciurul lui Eratostene.</p> <p>Mai \u00eent\u00e2i, vom ini\u021bializa r\u0103spunsul pentru fiecare pozi\u021bie ca fiind \\(i\\), iar pentru fiecare num\u0103r prim \u00een intervalul \\([2, n]\\) (numerele prime se pot afla u\u0219or, verific\u00e2nd dac\u0103 valoarea calculat\u0103 este \u00eenc\u0103 egal\u0103 cu \\(i\\)), vom trece prin to\u021bi multiplii \u0219i vom \u00eemp\u0103r\u021bi la \\(i\\) \u0219i \u00eenmul\u021bi cu \\(i-1\\).</p> <p>Codul de mai jos rezolv\u0103 problema eratostene3 de pe pbinfo, \u00een care trebuie s\u0103 afl\u0103m pentru fiecare valoare de la intrare c\u00e2te numere sunt prime cu ea.</p> <pre><code>#include &lt;fstream&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\nconst int n = 1000000;\nint main() {\n    ifstream cin(\"eratostene3.in\");\n    ofstream cout(\"eratostene3.out\");\n\n    vector&lt;int&gt; totient(n + 1);\n    for (int i = 1; i &lt;= n; i++) {\n        totient[i] = i;\n    }\n\n    for (int i = 2; i &lt;= n; i++) {\n        // daca numarul inca este prim, trecem prin multipli\n        if (totient[i] == i) {\n            for (int j = i; j &lt;= n; j += i) {\n                totient[j] /= i;\n                totient[j] *= (i - 1);\n            }\n        }\n    }\n\n    int q;\n    cin &gt;&gt; q;\n\n    while (q--) {\n        int n;\n        cin &gt;&gt; n;\n\n        cout &lt;&lt; totient[n] &lt;&lt; \" \";\n    }\n    return 0;\n}\n</code></pre>","tags":["matematica","divizori","precalculari"]},{"location":"mediu/euler-totient/#aflarea-valorilor-functiei-folosind-proprietatea-sumei-divizorilor","title":"Aflarea valorilor func\u021biei folosind proprietatea sumei divizorilor","text":"<p>Gauss a descoperit o proprietate care va fi foarte util\u0103 \u00een contextul calculelor noastre viitoare \u0219i \u00een special la func\u021bia Mobius.</p> \\[ \\sum_{d|n} \\varphi(d) = n \\] <p>Aceast\u0103 sum\u0103 este calculat\u0103 pentru to\u021bi divizorii lui \\(n\\).</p> <p>De exemplu, divizorii lui 10 sunt 1, 2, 5 \u0219i 10. Suma valorilor lui \\(\\varphi (i)\\) este 1 + 1 + 4 + 4 = 10.</p> <p>Folosind aceast\u0103 proprietate putem calcula toate valorilor indicatorului lui Euler \u00een \\(\\mathcal{O}(n \\log n)\\) ca la ciurul lui Eratostene, dar implementarea este una mai simpl\u0103.</p> <pre><code>void phi_1_to_n(int n) {\n    vector&lt;int&gt; phi(n + 1);\n    phi[0] = 0;\n    phi[1] = 1;\n    for (int i = 2; i &lt;= n; i++) {\n        phi[i] = i - 1;\n    }\n    for (int i = 2; i &lt;= n; i++) {\n        for (int j = 2 * i; j &lt;= n; j += i) {\n            phi[j] -= phi[i];\n        }\n    }\n}\n</code></pre>","tags":["matematica","divizori","precalculari"]},{"location":"mediu/euler-totient/#concluzii","title":"Concluzii","text":"<p>Indicatorul lui Euler este o func\u021bie care se dovede\u0219te a fi foarte important\u0103 \u00een foarte multe probleme de algoritmic\u0103, dar \u0219i mai t\u00e2rziu, odat\u0103 ce func\u021bia M\u00f6bius \u0219i teorema chinezeasc\u0103 a resturilor apar \u00een problemele mai avansate date la concursurile de programare competitiv\u0103. Aplica\u021biile acesteia \u00een algebr\u0103 \u0219i \u00een teoria numerelor pot reprezenta un bun loc de plecare pentru cei pasiona\u021bi \u0219i nu numai.</p>","tags":["matematica","divizori","precalculari"]},{"location":"mediu/euler-totient/#probleme-suplimentare","title":"Probleme suplimentare","text":"<ul> <li>fractii infoarena</li> <li>LCMSUM Spoj</li> <li>Permeuler pbinfo</li> <li>Common Divisors Codeforces</li> <li>problemele de pe CPPI   Sync</li> <li>problemele de pe   pbinfo</li> <li>Problemele din aceast\u0103 list\u0103 de pe Vjudge</li> </ul>","tags":["matematica","divizori","precalculari"]},{"location":"mediu/euler-totient/#lectura-suplimentara","title":"Lectur\u0103 suplimentar\u0103","text":"<ul> <li>phi function -   cp-algorithms</li> <li>Indicatorul lui Euler -   pbinfo</li> <li>Euler's phi function, its properties, and how to compute it -   Codeforces</li> <li>Euler's totient function -   wikipedia</li> <li>Func\u021bia M\u00f6bius</li> </ul>","tags":["matematica","divizori","precalculari"]},{"location":"mediu/expression-evaluation/","title":"Evaluarea unei expresii","text":"","tags":["stiva","expresii","implementare","recursivitate"]},{"location":"mediu/expression-evaluation/#introducere","title":"Introducere","text":"<p>\u00cen unele probleme de algoritmic\u0103, sunte\u021bi nevoi\u021bi s\u0103 evalua\u021bi valorile unor expresii aritmetice sau \u00een general, valorile unor expresii conform unor sisteme matematice sau logice bine definite. Aceste probleme sunt colocvial numite probleme la care avem nevoie de no\u021biunile specifice evalu\u0103rii unor expresii aritmetice (parsing \u00een englez\u0103).</p> <p>Observa\u021bie</p> <p>A nu se confunda denumirea de parsing cu cea de la parsarea datelor de intrare, chiar dac\u0103 ambele se ocup\u0103 de procesarea unor \u0219iruri de caractere, parsarea datelor este o metod\u0103 folosit\u0103 pentru \u00eembun\u0103t\u0103\u021birea vitezei de citire a datelor, mai multe detalii pute\u021bi g\u0103si aici.</p> <p>Toate aceste probleme con\u021bin urm\u0103toarele particularit\u0103\u021bi:</p> <ul> <li>Se define\u0219te un sistem de calcul sau un set de opera\u021bii folosind o aritmetic\u0103   sau o gramatic\u0103 nu foarte complicat\u0103.</li> <li>La fel ca la opera\u021biile aritmetice cu care sunte\u021bi obi\u0219nui\u021bi, exist\u0103 o ordine   a efectu\u0103rii opera\u021biilor \u0219i eventual ni\u0219te operatori care fixeaz\u0103 priorit\u0103\u021bile   (parantezele).</li> <li>Implementarea precis\u0103 \u0219i clar\u0103 este un element esen\u021bial \u0219i \u00een multe cazuri,   suficient pentru ob\u021binerea punctajului maxim.</li> <li>Uneori, aceast\u0103 parte devine intermediar\u0103 \u00een contextul unei cerin\u021be mai   particulare a problemei.</li> </ul> <p>Aceast\u0103 tehnic\u0103 se \u00eent\u00e2lne\u0219te \u00een contextul olimpiadei de informatic\u0103 mai ales la nivelul clasei a zecea, fiind un subiect destul de frecvent \u00eent\u00e2lnit \u00eempreun\u0103 cu celelalte aplica\u021bii ale structurilor de date liniare (stiva, coada, algoritmul lui Lee).</p> <p>Pe parcurs, vom explica o implementare simpl\u0103 \u0219i clar\u0103 pentru aceste tipuri de probleme, \u00eempreun\u0103 cu exemple explicate.</p>","tags":["stiva","expresii","implementare","recursivitate"]},{"location":"mediu/expression-evaluation/#problema-exemplu-evaluare-infoarena","title":"Problema exemplu - evaluare infoarena","text":"<p>Pentru a rezolva aceast\u0103 problem\u0103, trebuie s\u0103 aplic\u0103m unul din algoritmii consacra\u021bi \u0219i s\u0103 \u00eel adapt\u0103m pentru opera\u021biile aritmetice date. Cele dou\u0103 metode principale de implementare a expresiilor aritmetice reprezint\u0103 forma polonez\u0103 \u0219i recursivitatea indirect\u0103. Chiar dac\u0103 ambele au avantajele \u0219i dezavantajele lor, articolul va insista mai ales pe recursivitatea indirect\u0103, deoarece este mai u\u0219or de folosit \u0219i mai popular\u0103 \u00een contextul olimpiadei de informatic\u0103.</p>","tags":["stiva","expresii","implementare","recursivitate"]},{"location":"mediu/expression-evaluation/#forma-poloneza","title":"Forma polonez\u0103","text":"<p>Mai \u00eent\u00e2i, consider\u0103m doar o problem\u0103 simplificat\u0103: presupunem c\u0103 to\u021bi operatorii sunt binari, \u0219i to\u021bi sunt asociativi la st\u00e2nga. Parantezele sunt permise.</p> <p>Vom configura dou\u0103 stive: una pentru numere \u0219i una pentru operatori \u0219i paranteze. Ini\u021bial, ambele stive sunt goale. Pentru a doua stiv\u0103, vom men\u021bine condi\u021bia ca toate opera\u021biile s\u0103 fie ordonate \u00een ordinea strict descresc\u0103toare a priorit\u0103\u021bii. Dac\u0103 exist\u0103 paranteze pe stiv\u0103, atunci fiecare bloc de operatori (corespunz\u0103tor unei perechi de paranteze) este ordonat, dar \u00eentreaga stiv\u0103 nu trebuie neap\u0103rat s\u0103 fie ordonat\u0103.</p> <p>Vom itera prin caracterele expresiei de la st\u00e2nga la dreapta. Dac\u0103 caracterul curent este o cifr\u0103, atunci plas\u0103m valoarea acestui num\u0103r pe stiv\u0103. Dac\u0103 caracterul curent este o parantez\u0103 de deschidere, atunci o plas\u0103m pe stiv\u0103. Dac\u0103 caracterul curent este o parantez\u0103 de \u00eenchidere, atunci execut\u0103m to\u021bi operatorii de pe stiv\u0103 p\u00e2n\u0103 ajungem la paranteza de deschidere (cu alte cuvinte, execut\u0103m toate opera\u021biile din interiorul parantezelor). \u00cen final, dac\u0103 caracterul curent este un operator, atunci, c\u00e2t timp v\u00e2rful stivei con\u021bine un operator cu aceea\u0219i prioritate sau cu o prioritate mai mare, execut\u0103m aceast\u0103 opera\u021bie \u0219i plas\u0103m noua opera\u021bie pe stiv\u0103.</p> <p>Dup\u0103 ce am procesat \u00eentreaga expresie, este posibil ca unii operatori s\u0103 mai fie pe stiv\u0103, a\u0219a c\u0103 \u00eei execut\u0103m.</p> <p>O asemenea surs\u0103 se g\u0103se\u0219te aici.</p>","tags":["stiva","expresii","implementare","recursivitate"]},{"location":"mediu/expression-evaluation/#recursivitatea-indirecta","title":"Recursivitatea indirect\u0103","text":"<p>\u00cen ceea ce prive\u0219te recursivitatea indirect\u0103, algoritmul func\u021bioneaz\u0103 \u00een felul urm\u0103tor:</p> <p>Se \u00eemparte expresia \u00een blocuri separate de operatorii cu prioritate cea mai mic\u0103, iar apoi pentru acele blocuri, se separ\u0103 succesiv \u00een blocuri separate de operatori cu prioritate tot mai mare, p\u00e2n\u0103 c\u00e2nd fie reducem termenii la valori simple, fie ajungem la paranteze, care fac procesul s\u0103 se \u00eentoarc\u0103 la func\u021biile ini\u021biale.</p> <p>Deoarece nu este necesar s\u0103 p\u0103str\u0103m \u00een memorie toate aceste blocuri, putem pur \u0219i simplu s\u0103 parcurgem \u0219irul de caractere \u00een timp liniar, deoarece aceste func\u021bii se vor apela una pe cealalt\u0103, de aici vine \u0219i numele de recursivitate indirect\u0103.</p> <p>Pentru implementare, se poate observa faptul c\u0103 func\u021biile evaluare \u0219i termen sunt foarte similare \u00eentre ele, iar func\u021bia factor fie calculeaz\u0103 o valoare simpl\u0103, fie \u00eentoarce procesul la \u00eenceput. Mai jos se poate observa implementarea \u00een C++ pentru problema de pe infoarena.</p> <pre><code>#include &lt;fstream&gt;\nusing namespace std;\n\nifstream cin(\"evaluare.in\");\nofstream cout(\"evaluare.out\");\n\nint factor(), termen();\nstring EVAL;\nint poz = 0;\n\nint evaluare() {\n    int R = termen();\n    while (EVAL[poz] == '-' || EVAL[poz] == '+') {\n        if (EVAL[poz] == '-') {\n            poz++;\n            R -= termen();\n        } else {\n            if (EVAL[poz] == '+') {\n                poz++;\n                R += termen();\n            }\n        }\n    }\n    return R;\n}\nint termen() {\n    int F = factor();\n    while (EVAL[poz] == '*' || EVAL[poz] == '/') {\n        if (EVAL[poz] == '*') {\n            poz++;\n            F *= factor();\n        } else {\n            if (EVAL[poz] == '/') {\n                poz++;\n                F /= factor();\n            }\n        }\n    }\n    return F;\n}\nint factor() {\n    long long r = 0;\n    if (EVAL[poz] == '(') {\n        poz++;\n        r = evaluare();\n        poz++;\n    } else {\n        while (EVAL[poz] &gt;= '0' &amp;&amp; EVAL[poz] &lt;= '9') {\n            r = r * 10 + (EVAL[poz] - '0');\n            poz++;\n        }\n    }\n    return r;\n}\nint main() {\n    cin &gt;&gt; EVAL;\n    EVAL += '$';\n    cout &lt;&lt; evaluare() &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["stiva","expresii","implementare","recursivitate"]},{"location":"mediu/expression-evaluation/#problema-oni-2018-multimi","title":"Problema ONI 2018 multimi","text":"<p>Pentru rezolvarea acestei probleme, vom folosi o implementare similar\u0103 cu cea de mai sus, \u021bin\u00e2nd cont de priorit\u0103\u021bile descrise \u00een enun\u021b. Pentru optimizarea implement\u0103rii, vom folosi structurile de date din STL.</p> <p>Observa\u021bie</p> <p>Se poate observa faptul c\u0103 chiar \u0219i dup\u0103 ce adapt\u0103m implementarea la opera\u021biile din problem\u0103, structura de baz\u0103 a codului r\u0103m\u00e2ne aceea\u0219i.</p> <pre><code>#include &lt;fstream&gt;\n#include &lt;vector&gt;\n\nusing namespace std;\n\nifstream f(\"multimi.in\");\nofstream g(\"multimi.out\");\n\nint n, pos;\nvector&lt;int&gt; v[25];\nint lit[30];\nstring s;\nstring s2;\nchar L;\nint a, b, p;\nvector&lt;int&gt; intersect(vector&lt;int&gt; a, vector&lt;int&gt; b) {\n    vector&lt;int&gt; sol;\n    int i = 0, j = 0;\n    for (; i &lt; a.size() &amp;&amp; j &lt; b.size();) {\n        if (a[i] == b[j]) {\n            sol.push_back(a[i]);\n            ++i;\n            ++j;\n        } else {\n            if (a[i] &lt; b[j]) {\n                ++i;\n            } else {\n                ++j;\n            }\n        }\n    }\n    return sol;\n}\nvector&lt;int&gt; reunion(vector&lt;int&gt; a, vector&lt;int&gt; b) {\n    vector&lt;int&gt; sol;\n    int i = 0, j = 0;\n    for (; i &lt; a.size() &amp;&amp; j &lt; b.size();) {\n        if (a[i] == b[j]) {\n            sol.push_back(a[i]);\n            ++i;\n            ++j;\n        } else {\n            if (a[i] &lt; b[j]) {\n                sol.push_back(a[i]);\n                ++i;\n            } else {\n                sol.push_back(b[j]);\n                ++j;\n            }\n        }\n    }\n    while (i &lt; a.size()) {\n        sol.push_back(a[i]);\n        ++i;\n    }\n    while (j &lt; b.size()) {\n        sol.push_back(b[j]);\n        ++j;\n    }\n    return sol;\n}\nvector&lt;int&gt; termen();\nvector&lt;int&gt; factor();\nvector&lt;int&gt; eval() {\n    vector&lt;int&gt; sol;\n    sol = factor();\n    while (s2[pos] == '+') {\n        ++pos;\n        sol = reunion(sol, factor());\n    }\n    return sol;\n}\nvector&lt;int&gt; factor() {\n    vector&lt;int&gt; sol;\n    sol = termen();\n    while (s2[pos] == '*') {\n        ++pos;\n        sol = intersect(sol, termen());\n    }\n    return sol;\n}\nvector&lt;int&gt; termen() {\n    vector&lt;int&gt; sol;\n    if (s2[pos] == '(') {\n        ++pos;\n        sol = eval();\n        ++pos;\n    } else {\n        int posi = lit[s2[pos] - 'A'];\n        for (int j = 0; j &lt; v[posi].size(); ++j) {\n            sol.push_back(v[posi][j]);\n        }\n        ++pos;\n    }\n    return sol;\n}\nint main() {\n    f &gt;&gt; n;\n    for (int i = 1; i &lt;= n; ++i) {\n        f &gt;&gt; s;\n        a = b = p = 0;\n        L = s[0];\n        lit[L - 'A'] = i;\n        pos = 2;\n        while (s[pos] != '-') {\n            a = a * 10 + s[pos] - '0';\n            ++pos;\n        }\n        ++pos;\n        while (s[pos] != '/') {\n            b = b * 10 + s[pos] - '0';\n            ++pos;\n        }\n        ++pos;\n        while (s[pos] &gt;= '0' &amp;&amp; s[pos] &lt;= '9') {\n            p = p * 10 + s[pos] - '0';\n            ++pos;\n        }\n        for (int j = a; j &lt;= b; j += p) {\n            v[i].push_back(j);\n        }\n    }\n    pos = 0;\n    f &gt;&gt; s2;\n    vector&lt;int&gt; R = eval();\n    g &lt;&lt; R.size() &lt;&lt; '\\n';\n    for (int i = 0; i &lt; R.size(); ++i) {\n        g &lt;&lt; R[i] &lt;&lt; \" \";\n    }\n    return 0;\n}\n</code></pre>","tags":["stiva","expresii","implementare","recursivitate"]},{"location":"mediu/expression-evaluation/#concluzii","title":"Concluzii","text":"<p>Evaluarea de expresii aritmetice este un tip de cerin\u021b\u0103 ce apare \u00een diverse forme \u00een algoritmic\u0103, at\u00e2t \u00een concursurile de informatic\u0103 rom\u00e2ne\u0219ti \u0219i interna\u021bionale, dar \u0219i \u00een diverse aplica\u021bii practice, forma polonez\u0103 ap\u0103r\u00e2nd \u00een multe alte contexte.</p> <p>De asemenea, recursivitatea indirect\u0103 reprezint\u0103 o metod\u0103 elegant\u0103 de rezolvare a multor probleme de algoritmic\u0103, nu doar pentru aceast\u0103 tehnic\u0103. Cunoa\u0219terea temeinic\u0103 a acestei tehnici garanteaz\u0103 ob\u021binerea unui punctaj mare la concursurile de informatic\u0103 \u00een clasa a 10-a \u00een cazul \u00een care se d\u0103 o asemenea problem\u0103, fie la OJI, fie la ONI.</p>","tags":["stiva","expresii","implementare","recursivitate"]},{"location":"mediu/expression-evaluation/#probleme-suplimentare","title":"Probleme suplimentare","text":"<ul> <li>evaluare infoarena</li> <li>emm infoarena</li> <li>bool infoarena</li> <li>OJI 2007 dir</li> <li>ONI 2006 Logic</li> <li>OJI 2018 eq4</li> <li>ONI 2018 Baraj Juniori gcl</li> <li>OJI 2020 arh</li> <li>ONI 2014 Baraj Juniori opmult</li> <li>Urmasii lui Moisil 2023 Indiciu</li> <li>Probleme cu evaluarea de expresii de pe   Kilonova</li> <li>Probleme cu evaluarea de expresii de pe   Infoarena</li> <li>Probleme cu evaluarea de expresii de pe   Codeforces</li> <li>List\u0103 de probleme cu evaluare de   expresii</li> </ul>","tags":["stiva","expresii","implementare","recursivitate"]},{"location":"mediu/expression-evaluation/#resurse-suplimentare","title":"Resurse suplimentare","text":"<ul> <li>Expression parsing -   cp-algorithms</li> <li>Recursivitatea indirecta - CPPI   Sync</li> <li>Polish notation - wikipedia</li> </ul>","tags":["stiva","expresii","implementare","recursivitate"]},{"location":"mediu/handling-pressure/","title":"Cum gestionezi presiunea concursurilor?","text":"","tags":["meta","sfaturi"]},{"location":"mediu/handling-pressure/#introducere","title":"Introducere","text":"<p>De multe ori, fie c\u0103 este vorba de un examen na\u021bional sau de o olimpiad\u0103, apar persoane \u00een jurul t\u0103u care vor s\u0103 ob\u021bii un rezultat c\u00e2t mai bun, dar \u00een acela\u0219i timp, exist\u0103 \u0219i persoane \u00een jurul t\u0103u care \u00ee\u021bi sunt inevitabil competitori sau chiar rivali \u00een scopul t\u0103u de a ajunge la succes. Chiar dac\u0103 poate acele persoane sunt prietenii sau chiar colegii t\u0103i, cu care poate chiar e\u0219ti prieten, apare \u00een mod inevitabil o presiune mai direct\u0103 sau indirect\u0103, generat\u0103 de diver\u0219i factori, iar gestionarea acestor situa\u021bii, precum \u0219i gestionarea rezultatelor mai pu\u021bin fericite reprezint\u0103 un aspect foarte important pentru maturizarea ca concurent.</p> <p>\u00cen acest articol vom discuta c\u00e2teva dintre cele mai importante lucruri pe care le po\u021bi face pentru a fi imun la ace\u0219ti factori, astfel \u00eenc\u00e2t s\u0103 devii cea mai bun\u0103 versiune a ta, indiferent de rezultatele pe care le ob\u021bii la anumite concursuri, evit\u00e2nd astfel anumite consecin\u021be mai pu\u021bin faste ale unor rezultate mai slabe sau a unor medii mai pu\u021bin ideale pentru performan\u021b\u0103</p>","tags":["meta","sfaturi"]},{"location":"mediu/handling-pressure/#sanatatea-este-mai-importanta-decat-orice","title":"S\u0103n\u0103tatea este mai important\u0103 dec\u00e2t orice","text":"<p>Indiferent de ce rezultate \u00ee\u021bi propui s\u0103 ob\u021bii, s\u0103n\u0103tatea \u0219i integritatea fizic\u0103 \u0219i mental\u0103 trebuie s\u0103 fie pe primul loc, deoarece olimpiada nu reprezint\u0103 dec\u00e2t o etap\u0103 a vie\u021bii tale, iar insu\u0219i faptul c\u0103 ai ajuns acolo este mai important dec\u00e2t orice altceva pe termen lung. Exist\u0103 foarte mul\u021bi oameni \u0219i foarte multe companii care pre\u021buiesc rezultatele de acest gen, chiar dac\u0103 este vorba doar de o participare sau o medalie de bronz la olimpiad\u0103. \u00cen mod similar, absolvirea unei facult\u0103\u021bi bune este mult mai important\u0103 dec\u00e2t nota ob\u021binut\u0103 la bacalaureat sau admitere, iar de multe ori, o mare majoritate a rezultatelor se ob\u021bine cu o cantitate mult mai mic\u0103 de efort dec\u00e2t cel necesar pentru \u00eentregul rezultat.</p>","tags":["meta","sfaturi"]},{"location":"mediu/handling-pressure/#viata-si-competitiile-sunt-un-maraton-nu-un-sprint","title":"Via\u021ba \u0219i competi\u021biile sunt un maraton, nu un sprint","text":"<p>A\u0219a cum mult\u0103 lume spune, via\u021ba \u0219i obiectivele sale nu trebuie s\u0103 fie niciodat\u0103 un sprint, iar marile rezultate \u0219i succese vin drept o concluzie a unui efort sus\u021binut \u0219i a atingerii multor obiective mai mici, care sunt mai u\u0219or de realizat. Chiar dac\u0103 la un moment dat, apar anumite obstacole, este important s\u0103 \u021bii minte obiectivul principal, precum \u0219i diversele victorii de etap\u0103 pe care le ob\u021bii.</p> <p>\u00cen contextul concursurilor \u0219i preg\u0103tirii pentru olimpiade, fie c\u0103 rezolvi o problem\u0103 mai grea sau ai \u00een\u021beles \u00een sf\u00e2r\u0219it un algoritm sau o idee, trebuie s\u0103 te bucuri de aceste realiz\u0103ri \u0219i s\u0103 le folose\u0219ti pentru a putea continua pe acela\u0219i trend continuu.</p> <p>Chiar dac\u0103 exist\u0103 perioade \u00een care rezultatele voastre la concursuri nu sunt cele a\u0219teptate, at\u00e2ta timp c\u00e2t lucra\u021bi \u0219i depune\u021bi efortul necesar, rezultatele mai bune vor veni inevitabil \u0219i trebuie s\u0103 ave\u021bi r\u0103bdare, deoarece marile succese vin drept consecin\u021b\u0103 a unui efort pe termen lung.</p>","tags":["meta","sfaturi"]},{"location":"mediu/handling-pressure/#exerseaza-doar-cand-simti-ca-vrei-sa-faci-asta","title":"Exerseaz\u0103 doar c\u00e2nd sim\u021bi c\u0103 vrei s\u0103 faci asta","text":"<p>Chiar dac\u0103 este bine s\u0103 lucrezi c\u00e2t mai des, chiar \u0219i \u00een fiecare zi, exist\u0103 anumite zile sau perioade de timp \u00een care nu ai dorin\u021ba asta sub nicio form\u0103, iar \u00een aceast\u0103 situa\u021bie, este bine s\u0103 faci o pauz\u0103 \u0219i s\u0103 la\u0219i corpul s\u0103 se relaxeze, pentru a evita probleme mai mari pe termen lung.</p> <p>\u00cen acest timp, po\u021bi explora mai mult \u0219i alte hobby-uri pe care le-ai l\u0103sat deoparte, astfel p\u0103str\u00e2nd o viziune deschis\u0103 \u0219i larg\u0103 asupra lumii \u0219i a lucrurilor din jurul t\u0103u.</p> <p>Dac\u0103 ai o competi\u021bie \u00eentr-una din aceste perioade, este esen\u021bial s\u0103 fii c\u00e2t mai deta\u0219at, pentru a evita declan\u0219area unor reac\u021bii de acest fel \u00een timpul \u00eentrecerii, iar \u00een multe situa\u021bii, aceast\u0103 stare de relaxare poate fi chiar un avantaj \u00een timpul probei de concurs.</p>","tags":["meta","sfaturi"]},{"location":"mediu/handling-pressure/#chiar-daca-ai-rezultate-mai-putin-ideale-nu-renunta-si-nu-le-exagera-importanta","title":"Chiar dac\u0103 ai rezultate mai pu\u021bin ideale, nu renun\u021ba \u0219i nu le exagera importan\u021ba","text":"<p>De multe ori, tindem s\u0103 credem c\u0103 valoarea \u0219i stima noastr\u0103 de sine depind doar de cele mai recente rezultate, iar acest lucru ne poate afecta indiferent c\u0103 este vorba de rezultate foarte bune sau de rezultate mai pu\u021bin bune.</p> <p>Un \u0219ir de rezultate sub a\u0219tept\u0103ri poate cauza probleme mult mai mari dec\u00e2t a\u021bi crede, deoarece dac\u0103 importan\u021ba lor este exagerat\u0103, acest lucru poate duce la pierderea \u00eencrederii \u00een sine, lucru ce v\u0103 poate afecta negativ \u00een multe moduri pe termen lung.</p> <p>De aceea, trebuie s\u0103 privi\u021bi fiecare \u00eentrecere ca fiind un eveniment complet diferit, din care s\u0103 \u00eenv\u0103\u021ba\u021bi lucruri noi \u0219i s\u0103 v\u0103 dezvolta\u021bi pe diverse planuri (nu neap\u0103rat academice sau educa\u021bionale).</p>","tags":["meta","sfaturi"]},{"location":"mediu/handling-pressure/#nu-ezita-sa-ceri-ajutorul","title":"Nu ezita s\u0103 ceri ajutorul","text":"<p>Probabil c\u0103 nu e\u0219ti singurul care a avut nevoie vreodat\u0103 de un anume tip de ajutor, iar de aceea suntem aici s\u0103 te ajut\u0103m. Fie c\u0103 ne po\u021bi g\u0103si pe serverul nostru sau \u00een alt\u0103 parte, po\u021bi \u0219i te \u00eencuraj\u0103m s\u0103 vorbe\u0219ti deschis cu noi, \u00eentr-un spa\u021biu sigur \u00een care te putem ajuta s\u0103 treci peste orice fel de dubiu sau dificultate, fie c\u0103 este vorba de \u00een\u021belegerea unor anumite concepte sau de probleme de ordin psihologic care te \u021bin deoparte de ceea ce consideri c\u0103 este nivelul t\u0103u optim.</p> <p>Dac\u0103 consideri c\u0103 problemele tale sunt mai serioase, recomand\u0103m s\u0103 iei leg\u0103tura \u0219i cu speciali\u0219ti \u00een domeniul medical, care te pot \u00eendruma folosind sfaturi adaptate la personalitatea \u0219i problemele pe care le \u00eent\u00e2mpini. Foarte mul\u021bi atle\u021bi profesioni\u0219ti au psihologi angaja\u021bi s\u0103-i ajute s\u0103 treac\u0103 peste anumite dificult\u0103\u021bi, iar acest lucru se poate aplica \u0219i \u00een cazul t\u0103u, deoarece po\u021bi oric\u00e2nd s\u0103 vorbe\u0219ti deschis cu cei din jurul t\u0103u (familie, apropia\u021bi, profesori etc.), care te pot \u00een\u021belege \u0219i sus\u021bine mai bine ca oricine altcineva (chiar \u0219i dec\u00e2t noi).</p>","tags":["meta","sfaturi"]},{"location":"mediu/handling-pressure/#evita-interactiunile-nesanatoase-cu-cei-din-jur","title":"Evit\u0103 interac\u021biunile nes\u0103n\u0103toase cu cei din jur","text":"<p>De multe ori, exist\u0103 oameni care din nevoia de a se deschide celorlal\u021bi, nu o fac mereu \u00eentr-un mod pozitiv \u0219i util pentru toat\u0103 lumea, iar anumite obiceiuri pe care le au pot avea urm\u0103ri negative dac\u0103 sunt preluate.</p> <p>Un exemplu pe care \u00eel pot aduce aici este moda \u00een r\u00e2ndul foarte multor elevi de top de a-\u0219i subestima adev\u0103rata valoare, vorbind doar de experien\u021bele lor negative, minimiz\u00e2ndu-\u0219i succesele, ceea ce \u00een mod repetat, poate duce la sc\u0103derea \u00eencrederii lor \u00een sine, iar \u00een mod indirect, \u0219i pentru ceilal\u021bi, mai ales \u00een cazul \u00een care ace\u0219ti oameni au ob\u021binut rezultate tangibile \u0219i obiective care \u00eei plaseaz\u0103 \u00een ni\u0219te e\u0219aloane \u00eenalte ale performan\u021bei.</p> <p>De aceea, chiar dac\u0103 suntem \u00eentr-o comunitate \u0219i \u00eenv\u0103\u021b\u0103m \u0219i ne distr\u0103m \u00eempreun\u0103, la finalul zilei, trebuie s\u0103 delimit\u0103m interac\u021biunile online de cele reale \u0219i s\u0103 prelu\u0103m doar obiceiurile s\u0103n\u0103toase pe care le au cei din jurul nostru.</p>","tags":["meta","sfaturi"]},{"location":"mediu/handling-pressure/#concluzii","title":"Concluzii","text":"<p>S\u0103n\u0103tatea mintal\u0103 este un aspect tot mai studiat de c\u0103tre oamenii de \u0219tiin\u021b\u0103 la nivel mondial, iar oamenii \u00eencep s\u0103 \u00een\u021beleag\u0103 tot mai mult acest lucru, ceea ce a dus \u0219i la deschiderea acestui subiect \u00een contextul olimpiadelor \u0219i concursurilor, indiferent de materie. Acest articol are drept scop prezentarea c\u00e2torva dintre cele mai comune situa\u021bii \u00eent\u00e2lnite la concuren\u021bi, \u00eempreun\u0103 cu alternative mai s\u0103n\u0103toase \u0219i mai pozitive care s\u0103 v\u0103 ajute s\u0103 evita\u021bi spirale negative \u0219i distructive care pot duce la urm\u0103ri dintre cele mai grave.</p>","tags":["meta","sfaturi"]},{"location":"mediu/handling-pressure/#resurse-suplimentare","title":"Resurse suplimentare","text":"<ul> <li>10 Ways to Protect your Mental Health in STEM and Academical Competitions - Youtube</li> </ul>","tags":["meta","sfaturi"]},{"location":"mediu/hashing/","title":"Hashing","text":"<p>\u00cen informatic\u0103 \u0219i \u00een algoritmic\u0103, de multe ori avem de-a face cu stocarea unei cantit\u0103\u021bi semnificative de informa\u021bie f\u0103r\u0103 s\u0103 putem s\u0103 o stoc\u0103m \u00een intregime, sau \u00een alte cazuri va trebui s\u0103 alter\u0103m informa\u021bia sau s-o organiz\u0103m diferit pentru a putea ajunge la r\u0103spunsurile c\u0103utate c\u00e2t mai rapid \u0219i eficient. \u00cen acest articol voi prezenta c\u00e2teva tipuri de probleme pentru care putem folosi tehnici care vor fi categorizate drept tehnici specifice hashingului, aici voi enumera string hashing, hash tables \u0219i alte tehnici similare, precum xor hashing sau unele fundamente din spatele structurilor de tipul hash map. Pentru a putea parcurge acest capitol, e bine s\u0103 v\u0103 familiariza\u021bi cu lucrul cu \u0219iruri de caractere \u0219i cu aritmetica modular\u0103.</p>","tags":["hashing","siruri de caractere","matematica"]},{"location":"mediu/hashing/#string-hashing","title":"String hashing","text":"<p>Se d\u0103 urm\u0103toarea problem\u0103 ce trebuie rezolvat\u0103: D\u00e2ndu-se dou\u0103 \u0219iruri de caractere, s\u0103 se afle de c\u00e2te ori apare cel de-al doilea \u0219ir \u00een primul. Aceast\u0103 problem\u0103 are diverse solu\u021bii, \u00eencep\u00e2nd de la solu\u021biile de tip brute-force care verific\u0103 naiv toate apari\u021biile unui \u0219ir \u00een cel\u0103lalt, \u0219i termin\u00e2nd cu solu\u021biile care folosesc algoritmi de potrivire a \u0219irurilor, precum KMP sau Z-function, care vor fi aborda\u021bi in alte capitole.</p> <p>\u00cen acest capitol voi prezenta o alt\u0103 abordare foarte util\u0103 pentru acest tip de probleme, \u0219i anume string hashingul. Pe scurt, vom vrea s\u0103 codific\u0103m fiecare \u0219ir de caractere cu un num\u0103r natural care s\u0103 poat\u0103 fi stocat relativ u\u0219or, \u0219i care s\u0103 ne garanteze o probabilitate c\u00e2t mai mare de succes. De ce probabilitate? Dat fiind c\u0103 avem un num\u0103r finit de numere pe care le vom putea folosi \u0219i un num\u0103r mult mai mare de \u0219iruri de caractere care se pot crea, va exista o \u0219ans\u0103 foarte mic\u0103 de a ob\u021bine un rezultat diferit de cel adev\u0103rat (cu alte cuvinte, s\u0103 consider\u0103m dou\u0103 \u0219iruri de caractere diferite ca fiind identice). Dar a\u0219a cum ve\u021bi vedea mai t\u00e2rziu, vom putea mic\u0219ora \u0219ansa de a avea o asemenea coliziune.</p>","tags":["hashing","siruri de caractere","matematica"]},{"location":"mediu/hashing/#cum-aplicam-un-hash-pe-un-sir-de-caractere","title":"Cum aplic\u0103m un hash pe un \u0219ir de caractere","text":"<p>\u00cen cazul majorit\u0103\u021bii problemelor, vom avea de-a face cu \u0219iruri de caractere ce con\u021bin litere mici sau mari ale alfabetului englez (\u00een total, 26 de litere) \u0219i care au o lungime de un ordin cel mult \\(10^6\\). Din nou, dac\u0103 apar \u0219i alte caractere, va trebui s\u0103 ajust\u0103m parametrii dupa o regul\u0103 bine precizat\u0103.</p> <p>S\u0103 presupunem pentru un moment c\u0103 putem stoca numere arbitrar de mari \u00een timp constant, put\u00e2nd s\u0103 efectu\u0103m opera\u021bii pe ele. Dat fiind c\u0103 sunt 26 de litere, ne putem g\u00e2ndi la folosirea bazei 26 pentru a stoca un num\u0103r corespunz\u0103tor unui \u0219ir de caractere, fiecare pozi\u021bie av\u00e2nd o valoare egal\u0103 cu \\(26^{n - i - 1} \\cdot ind_i\\), unde \\(n\\) este lungimea \u0219irului de caractere, \\(i\\) este pozi\u021bia caracterului curent iar \\(ind_i\\) este pozi\u021bia din alfabet (cu indexare de la 0) a caracterului de pe pozi\u021bia \\(i\\). De exemplu, dac\u0103 \\(s_i = d\\), \\(ind_i = 3\\) (d este cea de-a patra liter\u0103 din alfabet).</p> <p>De exemplu, dac\u0103 \u0219irul de caractere este algo, num\u0103rul pe care l-am stoca ar fi egal cu</p> \\[ 26^3 \\cdot 0 + 26^2 \\cdot 11 + 26^1 \\cdot 6 + 26^0 \\cdot 14 = 7606 \\] <p>Din p\u0103cate, nu avem parte de numere infinit de mari, a\u0219a c\u0103 trebuie s\u0103 ne limit\u0103m op\u021biunile. Astfel, va trebui s\u0103 facem ajust\u0103ri \u00een ceea ce prive\u0219te baza folosit\u0103, dar \u0219i ca o noutate, vom stoca numerele modulo \\(m\\), care va fi de regul\u0103 un num\u0103r prim mare, valori potrivite sunt de regul\u0103 \\(10^9 + 7\\), \\(998 \\ 244 \\ 353\\) sau \\(10^9 + 9\\). \u00cen mod similar, vom vrea s\u0103 folosim o baz\u0103 \\(b\\) care va fi \u0219i ea un num\u0103r prim, mai mare dec\u00e2t num\u0103rul de caractere distincte pe care \u00eel putem avea (dat fiind c\u0103 avem 26 de litere, alegeri bune pentru baz\u0103 ar fi 29 sau 31).</p> <p>Observa\u021bie</p> <p>Numerele prime sunt recomandate pentru crearea hashurilor deoarece neav\u00e2nd divizori comuni cu alte numere, riscul de a ajunge la valori egale cu 0 este mult mai sc\u0103zut, ceea ce reduce semnificativ riscul unor coliziuni.</p> <p>Un alt aspect important ce trebuie prezentat const\u0103 \u00een prezentarea modului \u00een care calcul\u0103m hashul unei subsecven\u021be a unui \u0219ir de caractere de la pozi\u021bia \\(L\\) la pozi\u021bia \\(R\\), lungimea acestuia fiind \\(R - L + 1\\). Dac\u0103 \u0219tim hashul pentru intervalul \\([1, R]\\) \u0219i hashul pentru intervalul \\([1, L-1]\\), s\u0103 le not\u0103m \\(x_R\\) \u0219i \\(x_L\\), hashul subsecven\u021bei \\([L, R]\\) va fi \\(y - x \\cdot base^{R - L + 1}\\).</p> <p>Observa\u021bie</p> <p>Deoarece \u00een majoritatea cazurilor avem de p\u0103strat valoarea modulo \\(X\\), va trebui s\u0103 fim aten\u021bi \u00een ceea ce prive\u0219te calculul hashului \u0219i evitarea valorilor negative ale opera\u021biei modulo. Acum, tot ce ne mai r\u0103m\u00e2ne de f\u0103cut e s\u0103 explic\u0103m cum s\u0103 calcul\u0103m aceste hashuri \u0219i s\u0103 putem ajusta parametrii \u00een func\u021bie de problemele care trebuie rezolvate.</p>","tags":["hashing","siruri de caractere","matematica"]},{"location":"mediu/hashing/#implementarea-si-folosirea-hashurilor","title":"Implementarea \u0219i folosirea hashurilor","text":"<p>Pentru a putea folosi hashurile, va trebui s\u0103 precalcul\u0103m mai \u00eent\u00e2i puterile bazei, p\u00e2n\u0103 la \\(n\\), unde \\(n\\) e lungimea \u0219irului de caractere. De asemenea, va trebui sa precalcul\u0103m hashurile pentru toate prefixele \u0219irului \\(s\\) folosind formula de mai sus, practic la fiecare pas vom \u00eenmul\u021bi r\u0103spunsul anterior cu baza \u0219i adun\u0103m valoarea literei noastre, \u021bin\u00e2nd cont de valoarea modulo-ului. Mai jos pute\u021bi g\u0103si chiar solu\u021bia problemei strmatch de pe infoarena, unde ni se cere s\u0103 afl\u0103m de c\u00e2te ori apare primul \u0219ir \u00een cel de-al doilea.</p> <pre><code>#include &lt;fstream&gt;\n#include &lt;string&gt;\n#include &lt;vector&gt;\n\nusing namespace std;\n\nconstexpr int base = 127;\nconstexpr int mod = 1000000007;\nconstexpr int N = 2000000;\n\nint n, m;\nlong long textHash[N + 1], power[N + 1];\n\nint main() {\n    ifstream fin(\"strmatch.in\");\n    ofstream fout(\"strmatch.out\");\n\n    string pattern, text;\n    fin &gt;&gt; pattern &gt;&gt; text;\n\n    int textLen = text.size();\n    int patternLen = pattern.size();\n\n    power[0] = 1;\n    for (int i = 1; i &lt;= N; i++) {\n        power[i] = (power[i - 1] * base) % mod;\n    }\n\n    long long patternHash = 0;\n    for (int i = 0; i &lt; patternLen; i++) {\n        patternHash *= base;\n        patternHash += pattern[i] - '0';\n        patternHash %= mod;\n    }\n\n    for (int i = 0; i &lt; textLen; i++) {\n        textHash[i + 1] = textHash[i];\n\n        textHash[i + 1] *= base;\n        textHash[i + 1] += text[i] - '0';\n        textHash[i + 1] %= mod;\n    }\n\n    int matchCount = 0;\n\n    vector&lt;int&gt; matchPositions;\n    for (int i = patternLen; i &lt;= textLen; i++) {\n        const auto endHash = textHash[i];\n        const auto startHash = textHash[i - patternLen];\n        const auto newStartHash = (startHash * power[patternLen]) % mod;\n\n        const auto currHash = (endHash - newStartHash + mod) % mod;\n\n        if (currHash == patternHash) {\n            matchCount++;\n            if (matchCount &lt;= 1000) {\n                matchPositions.push_back(i - patternLen);\n            }\n        }\n    }\n\n    fout &lt;&lt; matchCount &lt;&lt; '\\n';\n\n    for (const auto pos : matchPositions) {\n        fout &lt;&lt; pos &lt;&lt; \" \";\n    }\n    return 0;\n}\n</code></pre>","tags":["hashing","siruri de caractere","matematica"]},{"location":"mediu/hashing/#double-si-multiple-hashing","title":"Double \u0219i multiple hashing","text":"<p>\u00cen unele probleme, precum String Matching de pe CSES, folosirea unui singur hash nu garanteaz\u0103 r\u0103spunsul corect, datorit\u0103 calit\u0103\u021bii testelor. Astfel, se impune folosirea mai multor hashuri concomitent. Cu alte cuvinte, vom proceda la fel ca la un singur hash, doar c\u0103 pentru a testa egalitatea a dou\u0103 \u0219iruri de caractere de aceea\u0219i lungime, va trebui s\u0103 ne asigur\u0103m c\u0103 \u0219irurile returneaz\u0103 acela\u0219i hash pentru toate perechile de tipul \\((baz\u0103, modulo)\\) alese, perechi care trebuie s\u0103 respecte propriet\u0103\u021bile descrise mai sus.</p> <p>Un exemplu de implementare pe aceast\u0103 idee se poate g\u0103si aici, dou\u0103 hashuri fiind suficiente aici.</p> <p>\u00cen practic\u0103, cu c\u00e2t ad\u0103ug\u0103m mai multe hashuri, cu at\u00e2t probabilitatea ca noi s\u0103 nu mai avem coliziuni scade exponen\u021bial, de cele mai multe ori dou\u0103 hashuri fiind suficiente, dac\u0103 sunt alese \u00een mod potrivit.</p>","tags":["hashing","siruri de caractere","matematica"]},{"location":"mediu/hashing/#hash-tables-si-unordered-map","title":"Hash tables \u0219i unordered map","text":"<p>\u00cen anumite situa\u021bii, suntem nevoi\u021bi s\u0103 grup\u0103m valorile \u00een func\u021bie de anumite criterii, ajung\u00e2nd astfel s\u0103 avem nevoie de o structur\u0103 de date care s\u0103 poat\u0103 grupa elementele cu aceea\u0219i valoare pentru a putea procesa opera\u021bii de inserare, \u0219tergere \u0219i modificare \u00een timp rezonabil. Aici intervin tabelele hash, unde vom p\u0103stra valorile grupate \u00een func\u021bie de un criteriu ales de noi anterior (de exemplu, putem s\u0103 le grup\u0103m \u00een func\u021bie de restul \u00eemp\u0103r\u021birii la un num\u0103r prim mare, dar spre deosebire de string hashing, nu foarte mare deoarece va trebui s\u0103 p\u0103str\u0103m aceste liste separat).</p> <p>Totu\u0219i, \u00een prezent o metod\u0103 mult mai popular\u0103 \u0219i mai simplu de folosit pentru a stoca informa\u021bii legate de valori, p\u0103str\u00e2nd \u0219i eficien\u021ba proces\u0103rii acestora const\u0103 \u00een folosirea structurii de date unordered map, care func\u021bioneaz\u0103 \u00eentr-o manier\u0103 similar\u0103 cu a tabelelor hash. Practic, fiecare valoare inserat\u0103 \u00eentr-un unordered map este stocat\u0103 \u00eentr-o tabel\u0103 hash \u00een func\u021bie de valoarea unui hash intern calculat de structura de date \u00een sine. Aceast\u0103 structur\u0103 de date ne garanteaz\u0103 o complexitate foarte bun\u0103 pe un caz obi\u0219nuit, opera\u021biile fiind \u00een medie \\(\\mathcal{O}(1)\\), dar trebuie avut grij\u0103 la cazul cel mai prost, unde complexitatea unei opera\u021bii poate atinge \u0219i \\(\\mathcal{O}(n)\\), mai jos g\u0103si\u021bi un exemplu de implementare.</p> <pre><code>#include &lt;fstream&gt;\n#include &lt;iostream&gt;\n#include &lt;unordered_map&gt;\n\nusing namespace std;\n\nconstexpr enum Action { INSERT = 1, DELETE = 2, QUERY = 3 };\n\nint main() {\n    ifstream fin(\"hashuri.in\");\n    ofstream fout(\"hashuri.out\");\n\n    unordered_map&lt;int, bool&gt; fr;\n    int n;\n    fin &gt;&gt; n;\n\n    while (n--) {\n        int p, x;\n        fin &gt;&gt; p &gt;&gt; x;\n\n        switch (p) {\n        case Action::INSERT:\n            fr[x] = true;\n            break;\n        case Action::DELETE:\n            fr.erase(x);\n            break;\n        case Action::QUERY:\n            fout &lt;&lt; (fr.count(x) &gt; 0) &lt;&lt; \"\\n\";\n            break;\n        default:\n            break;\n        }\n    }\n\n    return 0;\n}\n</code></pre> <p>Observa\u021bie</p> <p>De\u0219i <code>unordered_map</code> este o structur\u0103 de date destul de eficient\u0103 \u0219i foarte util\u0103 \u00een concursuri, se recomand\u0103 evitarea ei la rundele de Codeforces, unde datorit\u0103 perioadei de open hacking de 12 ore de la rundele Div. 3, Div. 4 \u0219i educationale, solu\u021biile care folosesc <code>unordered_map</code> sunt vulnerabile hackurilor ce se folosesc de tehnicile descrise \u00een acest blog. O alternativ\u0103 const\u0103 \u00een folosirea unui hash custom, sau \u0219i mai simplu, folosirea map-ului chiar dac\u0103 pierdem un factor de \\(\\mathcal{O}(\\log n)\\). Totu\u0219i, la olimpiade nu se genereaz\u0103 de regul\u0103 teste anti-unordered map.</p>","tags":["hashing","siruri de caractere","matematica"]},{"location":"mediu/hashing/#xor-hashing","title":"Xor Hashing","text":"<p>O alt\u0103 tehnic\u0103 ce merit\u0103 men\u021bionat\u0103, dat fiind faptul c\u0103 a ap\u0103rut relativ recent, este cea a xor hashurilor. Pe scurt, modul cum func\u021bioneaz\u0103 este c\u0103 pentru fiecare valoare care apare \u00een \u0219ir (de regul\u0103, o permutare de la 1 la \\(n\\) sau \u00een general un interval de valori mici), vom vrea s\u0103 o \u00eenlocuim cu o valoare aleas\u0103 aleator \u00eentr-un \u00eenterval foarte mare (de regul\u0103, numerele \u00eentregi pe 32 de bi\u021bi).</p> <p>Aceast\u0103 tehnic\u0103 ne ajut\u0103 s\u0103 putem afla cu u\u0219urin\u021b\u0103 dac\u0103 un set de numere \u00eentr-un anumit interval apare \u00eentr-o subsecven\u021b\u0103 sau \u00eentr-un \u0219ir de numere (de regul\u0103, problemele se reduc la a afla dac\u0103 valorile dintr-un interval de numere formeaz\u0103 o permutare a mul\u021bimii \\(\\{1, 2, \\dots, n\\}\\).</p>","tags":["hashing","siruri de caractere","matematica"]},{"location":"mediu/hashing/#exemplu-mixperm-lot-juniori-2017","title":"Exemplu: mixperm lot juniori 2017","text":"<p>Pentru aceast\u0103 problem\u0103, se poate observa c\u0103 este un exemplu clasic al folosirii tehnicii xor hashing (solu\u021bia oficial\u0103 folose\u0219te o combina\u021bie de propriet\u0103\u021bi matematice) deoarece putem genera un num\u0103r aleator pentru fiecare valoare de la 1 la \\(n\\) iar mai apoi c\u00e2nd verific\u0103m fiecare secven\u021b\u0103 brut, folosim valorile xor-urilor par\u021biale pentru a determina cu o probabilitate de aproximativ \\(100 \\%\\) dac\u0103 ob\u021binem o permutare a mul\u021bimii \\(\\{1, 2, \\dots, n\\}\\). O surs\u0103 demonstrativ\u0103 se poate g\u0103si mai jos, submisia put\u00e2nd fi accesat\u0103 aici sau mai jos.</p> <pre><code>#include &lt;chrono&gt;\n#include &lt;fstream&gt;\n#include &lt;iostream&gt;\n#include &lt;random&gt;\n\nusing namespace std;\n\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\nconst int randgen(int left = 1, int right = 1000000000) {\n    return uniform_int_distribution&lt;int&gt;(left, right)(rng);\n}\n\nconstexpr int N = 10000;\n\nint hsh[N + 5], a[N + 5], b[N + 5];\n\nint prefa[N + 5], prefb[N + 5];\nint suffa[N + 5], suffb[N + 5];\n\nint main() {\n    ifstream fin(\"mixperm.in\");\n    ofstream fout(\"mixperm.out\");\n\n    int n;\n    fin &gt;&gt; n;\n\n    int xr = 0;\n\n    for (int i = 1; i &lt;= n; i++) {\n        hsh[i] = randgen();\n        xr ^= hsh[i];\n    }\n\n    for (int i = 1; i &lt;= n; i++) {\n        fin &gt;&gt; a[i];\n    }\n\n    for (int i = 1; i &lt;= n; i++) {\n        fin &gt;&gt; b[i];\n    }\n\n    for (int i = 1; i &lt;= n; i++) {\n        prefa[i] = prefa[i - 1] ^ hsh[a[i]];\n        prefb[i] = prefb[i - 1] ^ hsh[b[i]];\n\n        const int j = n - i + 1;\n        suffa[j] = suffa[j + 1] ^ hsh[a[j]];\n        suffb[j] = suffb[j + 1] ^ hsh[b[j]];\n    }\n\n    int ans = 0;\n    for (int i = 1; i &lt;= n; i++) {\n        for (int j = i; j &lt;= n; j++) {\n            const int secva = prefa[j] ^ prefa[i - 1];\n            const int secvb = prefb[j] ^ prefb[i - 1];\n\n            const int suffa_xor = suffa[j + 1];\n            const int suffb_xor = suffb[j + 1];\n\n            if ((prefa[i - 1] ^ secvb ^ suffa_xor) == xr\n                || (prefb[i - 1] ^ secva ^ suffb_xor) == xr) {\n                ans++;\n            }\n        }\n    }\n\n    fout &lt;&lt; ans &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["hashing","siruri de caractere","matematica"]},{"location":"mediu/hashing/#probleme-suplimentare","title":"Probleme suplimentare","text":"","tags":["hashing","siruri de caractere","matematica"]},{"location":"mediu/hashing/#probleme-de-la-olimpiade","title":"Probleme de la olimpiade","text":"<ul> <li>subsecvente OJI 2013</li> <li>Carry Bit IIOT 2023-24</li> <li>sp Lot juniori 2021</li> <li>gimigpt Lot Juniori 2024</li> <li>mixperm Lot juniori 2017</li> <li>Palindrome String</li> <li>sap RoAlgo Contest 6 - XOR Hashing</li> <li>toska Stelele Informaticii - XOR Hashing</li> <li>Bovine Genomics   USACO</li> <li>RMI 2017 Hangman   2</li> <li>Probleme cu hashing de pe kilonova</li> <li>Probleme cu hashing de pe   infoarena</li> </ul>","tags":["hashing","siruri de caractere","matematica"]},{"location":"mediu/hashing/#probleme-de-pe-alte-siteuri","title":"Probleme de pe alte siteuri","text":"<ul> <li>Finding Periods</li> <li>Sum of Four Values</li> <li>Fullmetal Alchemist II</li> <li>Mysterious Crime</li> <li>The Number of Subpermutations</li> <li>Alte probleme cu hashing de pe   Codeforces</li> </ul>","tags":["hashing","siruri de caractere","matematica"]},{"location":"mediu/hashing/#bibliografie-si-lectura-suplimentara","title":"Bibliografie \u0219i lectur\u0103 suplimentar\u0103","text":"<p>Am ordonat resursele suplimentare \u00een ordinea dificult\u0103\u021bii \u00een\u021belegerii \u0219i \u00eentr-o ordine logic\u0103 pentru a u\u0219ura ob\u021binerea de cuno\u0219tinte despre tehnicile, abord\u0103rile \u0219i problemele discutate \u00een acest curs.</p> <ul> <li>Cartea SEPI F1 - Capitolul 12 (pagina 171) - C\u0103ut\u0103ri \u00een \u0219iruri de caractere.   Algoritmul Rabin-Karp - Articol   Recomandat</li> <li>Articol USACO Guide - String   Hashing</li> <li>Articol USACO Guide - Hash maps</li> <li>XOR Hashing TUTORIAL</li> <li>On the mathematics behind rolling hashes and anti-hash   tests</li> <li>Articolul de pe cppi.sync</li> <li>Hash tables</li> <li>Hash tables - prezentare   detaliata</li> </ul>","tags":["hashing","siruri de caractere","matematica"]},{"location":"mediu/important-formulas/","title":"Important formulas","text":"<p>Daca vreti sa ne ajutati cu acest articol, ne puteti gasi pe github sau pe serverul nostru de discord</p> <p>Mai jos g\u0103si\u021bi resurse pe care le pute\u021bi citi p\u00e2n\u0103 atunci.</p>","tags":["matematica","implementare","recursivitate"]},{"location":"mediu/important-formulas/#introducere","title":"Introducere","text":"","tags":["matematica","implementare","recursivitate"]},{"location":"mediu/important-formulas/#problema-exemplu","title":"Problema exemplu","text":"","tags":["matematica","implementare","recursivitate"]},{"location":"mediu/important-formulas/#concluzii","title":"Concluzii","text":"","tags":["matematica","implementare","recursivitate"]},{"location":"mediu/important-formulas/#probleme-suplimentare","title":"Probleme suplimentare","text":"","tags":["matematica","implementare","recursivitate"]},{"location":"mediu/important-formulas/#resurse-suplimentare","title":"Resurse suplimentare","text":"","tags":["matematica","implementare","recursivitate"]},{"location":"mediu/intro-combinatorics/","title":"Introducere \u00een combinatoric\u0103","text":"<p>Combinatorica este una din ramurile principale ale matematicii, precum \u0219i una din cele patru ramuri din care se dau problemele de la olimpiada interna\u021bional\u0103 de matematic\u0103 (IMO) celelalte fiind algebra, teoria numerelor \u0219i geometria. \u00cen algoritmic\u0103 \u0219i \u00een programarea competitiv\u0103, combinatorica se reg\u0103se\u0219te \u00een probleme de nivel mediu \u0219i ridicat, aplica\u021biile diverselor formule matematice, precum \u0219i tehnicile de rezolvare ale problemelor de combinatoric\u0103 fiind un pas important spre des\u0103v\u00e2r\u0219irea abilit\u0103\u021bilor de rezolvare a problemelor algoritmice, deoarece spre deosebire de alte capitole, combinatorica este mai greu de antrenat, iar experien\u021ba c\u0103p\u0103tat\u0103 prin rezolvarea problemelor se va dovedi a fi una crucial\u0103.</p> <p>\u00cen acest capitol vom prezenta cele mai importante formule specifice combinatoricii, o serie de identit\u0103\u021bi \u0219i rela\u021bii care sunt folosite \u00een foarte multe probleme de algoritmic\u0103, precum \u0219i diverse tehnici care au scopul s\u0103 v\u0103 ajute pentru a putea \u00een\u021belege formulele necesare, precum \u0219i s\u0103 v\u0103 ajute pentru a putea rezolva problemele de acest fel \u00eentr-un mod c\u00e2t mai u\u0219or \u0219i intuitiv. \u00cen cadrul olimpiadelor \u0219i concursurilor de informatic\u0103 din Rom\u00e2nia, combinatorica se reg\u0103se\u0219te drept parte esen\u021bial\u0103 \u00een dou\u0103 competi\u021bii - lotul de juniori \u0219i olimpiada clasei a zecea. Ulterior, poate s\u0103 se reg\u0103seasc\u0103 \u0219i ca subprobleme la probele ulterioare de seniori, \u00eentr-o m\u0103sur\u0103 mai mic\u0103.</p> <p>Pentru a putea parcurge acest capitol, recomand\u0103m citirea \u00een prealabil a articolelor despre aritmetica modular\u0103, divizibilitate \u0219i \u00een general s\u0103 ave\u021bi o \u00een\u021belegere a conceptelor matematice din capitolele anterioare. Va fi foarte important\u0103 \u0219i \u00een\u021belegerea conceptului de invers modular, deoarece de\u0219i \u00een cele mai multe probleme vom avea de-a face cu modulo numere prime, uneori va trebui s\u0103 \u0219tim s\u0103 implement\u0103m \u0219i algoritmul de aflare al inversul modular.</p>","tags":["matematica","combinatorica","teoria numerelor","permutari","aranjamente","combinari"]},{"location":"mediu/intro-combinatorics/#notiuni-teoretice-fundamentale","title":"No\u021biuni teoretice fundamentale","text":"<p>Pe l\u00e2ng\u0103 capitolele men\u021bionate anterior, vrem s\u0103 \u00eencepem prin a explica anumite fundamente, care ne vor ajuta mult pe parcurs.</p>","tags":["matematica","combinatorica","teoria numerelor","permutari","aranjamente","combinari"]},{"location":"mediu/intro-combinatorics/#regula-sumei-si-a-produsului","title":"Regula sumei \u0219i a produsului","text":"<p>Presupunem pentru urm\u0103toarele dou\u0103 reguli c\u0103 avem dou\u0103 mul\u021bimi \\(A\\) \u0219i \\(B\\) disjuncte (adic\u0103 \\(A\\cap B =\\emptyset\\)), av\u00e2nd cardinalul \\(|A| = n\\) \u0219i \\(|B| = m\\).</p> <p>Regula sumei</p> <p>Num\u0103rul de moduri de a alege o valoare din \\(A\\) sau \\(B\\) este \\(n+m\\).</p> <p>Regula produsului</p> <p>Num\u0103rul de moduri de a alege o pereche de valori, una din \\(A\\) \u0219i una din \\(B\\) este \\(n\\cdot m\\).</p> <p>Exemplu</p> <p>C\u00e2te numere de forma \\(\\overline{aba}\\) cu \\(a \\neq 0\\) i \\(a \\neq b\\) exist\u0103?</p> <p>Valorile posibile pentru \\(a\\) sunt \\({1, 2, 3, \\dots, 9}\\), iar valorile posibile ale lui \\(b\\) sunt \\({0, 1, 2, 3, \\dots, 9}\\).</p> <p>Avem 9 variante de a alege o valoare pentru \\(a\\), iar pentru \\(b\\) avem tot 9 variante (10, din care excludem cea egala cu \\(a\\)), astfel num\u0103rul total de variante este \\(9 \\cdot 9 = 81\\).</p> <p>Aceste rela\u021bii vor fi foarte importante mai ales c\u00e2nd avem de-a face cu formule independente care contribuie la r\u0103spunsul final.</p>","tags":["matematica","combinatorica","teoria numerelor","permutari","aranjamente","combinari"]},{"location":"mediu/intro-combinatorics/#permutari","title":"Permut\u0103ri","text":"<p>Permutare</p> <p>O permutare a unei mul\u021bimi reprezint\u0103 o aranjare a elementelor dintr-o mul\u021bime \\(M\\) finit\u0103 \u00eentr-o ordine diferit\u0103. Dac\u0103 cardinalul mul\u021bimii \\(|M| = n\\), num\u0103rul de permut\u0103ri ale unei mul\u021bimi de \\(n\\) valori este \\(n!\\).</p> <p>De exemplu, pentru \\(n = 3\\), cele 6 permut\u0103ri ale mul\u021bimii \\(\\{1, 2, 3\\}\\) sunt urm\u0103toarele: \\(\\{1, 2, 3\\}\\), \\(\\{1, 3, 2\\}\\), \\(\\{2, 1, 3\\}\\), \\(\\{2, 3, 1\\}\\), \\(\\{3, 1, 2\\}\\), \\(\\{3, 2, 1\\}\\)</p> <p>\u00cen probleme, exist\u0103 diverse cazuri particulare ale permut\u0103rilor care devin foarte utile \u00een rezolvarea unor probleme de combinatoric\u0103.</p> <p>Deranjamente</p> <p>Un deranjament este o permutare f\u0103r\u0103 puncte fixe, adic\u0103 \\(\\forall i\\), \\(p_i\\neq i\\).</p> <p>Num\u0103rul de deranjamente cu \\(n\\) elemente este egal cu \\(D_n = (n-1)\\cdot (D_{n-1} + D_{n-2})\\), unde \\(D_0 = 1\\) \u0219i \\(D_1 = 0\\). Acest concept a fost util printre altele la rezolvarea problemei Poseidon, dat\u0103 la OJI 2024, clasa a X-a.</p> <p>Permut\u0103ri cu repeti\u021bii</p> <p>Definim o permutare cu repeti\u021bii ca fiind o secven\u021b\u0103 de \\(n\\) numere, care are proprietatea c\u0103 fiecare valoare este \u00een intervalul \\([1, n]\\) \u0219i valorile se pot repeta. Num\u0103rul de permut\u0103ri cu repeti\u021bie cu aceste propriet\u0103\u021bi care au \\(n\\) elemente este</p> \\[ \\frac{n!}{F_1!\\cdot F_2!\\cdot\\dots\\cdot F_n!} = n!\\prod_{k = 1}^{n}\\frac{1}{F_k!} \\] <p>unde \\(F_i\\) reprezint\u0103 frecven\u021ba la care apare \\(i\\) \u00een permutare. Acest concept se reg\u0103se\u0219te \u00eentr-un num\u0103r de probleme date \u00een special la loturile de juniori.</p> <p>Mai jos pute\u021bi g\u0103si o secven\u021b\u0103 de cod pe care o putem folosi pentru a genera toate permut\u0103rile unui \u0219ir. Func\u021bia <code>std::next_permutation</code> nu va genera permut\u0103ri cu repeti\u021bie dac\u0103 acestea apar de mai multe ori.</p> <pre><code>vector&lt;int&gt; v(10);\n\nint i = 1;\n\nfor (auto&amp; x : v) {\n    x = i++;\n}\n\ndo {\n    afiseaza(v);\n} while (next_permutation(v.begin(), v.end()));\n</code></pre>","tags":["matematica","combinatorica","teoria numerelor","permutari","aranjamente","combinari"]},{"location":"mediu/intro-combinatorics/#submultimi","title":"Submul\u021bimi","text":"<p>O submul\u021bime a unui num\u0103r const\u0103 \u00een alegerea unui num\u0103r de elemente dintr-o mul\u021bime \\(M\\). Num\u0103rul de submul\u021bimi ale lui \\(M\\) este egal cu \\(2^{|M|}\\), deoarece pentru fiecare element al mul\u021bimii, putem alege dac\u0103 s\u0103 \u00eel includem \u00een submul\u021bimea pe care vrem s\u0103 o cre\u0103m sau nu.</p> <p>Dac\u0103 mul\u021bimea \\(M\\) este egal\u0103 cu \\(\\{0, 1, 1\\}\\), cele 8 submul\u021bimi ale ei sunt urm\u0103toarele: \\(\\emptyset\\), \\(\\{0\\}\\), \\(\\{0, 1\\}\\), \\(\\{0, 1, 2\\}\\), \\(\\{0, 2\\}\\), \\(\\{1\\}\\), \\(\\{1, 2\\}\\), \\(\\{2\\}\\).</p> <p>Pentru a putea itera prin toate submul\u021bimile unei mul\u021bimi date, ne putem folosi de faptul c\u0103 fiind \\(2^n\\) asemenea submul\u021bimi, putem identifica fiecare submul\u021bime folosind una din reprezent\u0103rile binare ale numerelor de la 0 la \\(2^n - 1\\), tehnic\u0103 numit\u0103 colocvial bitmasks sau m\u0103\u0219ti pe bi\u021bi. Pentru a vedea dac\u0103 trebuie s\u0103 folosim unul din numere sau nu, trebuie doar verificat pentru o submul\u021bime dat\u0103 dac\u0103 bitul corespunz\u0103tor acelei pozi\u021bii este setat sau nu \u00een masca pe care o verific\u0103m. Pentru mai multe detalii, pute\u021bi vedea codul de mai jos.</p> <pre><code>const int totalSubsets = 1 &lt;&lt; n;  // 2^n\n\nfor (int mask = 0; mask &lt; totalSubsets; ++mask) {\n    vector&lt;int&gt; subset;\n\n    for (int idx = 0; idx &lt; n; ++idx) {\n        if (mask &amp; (1 &lt;&lt; idx)) {  // (1)\n            subset.push_back(idx);\n        }\n    }\n\n    process(subset);\n}\n</code></pre> <ol> <li>Dac\u0103 bitul din masc\u0103 la pozi\u021bia \\(idx\\) este setat, \u00eenseamn\u0103 c\u0103 elementul de la    indice este prezent \u0219i deci ad\u0103ug\u0103m indicele \u00een submul\u021bime.</li> </ol>","tags":["matematica","combinatorica","teoria numerelor","permutari","aranjamente","combinari"]},{"location":"mediu/intro-combinatorics/#aranjamente","title":"Aranjamente","text":"<p>Un aranjament de \\(n\\) elemente luate c\u00e2te \\(k\\) reprezint\u0103 o submul\u021bime ordonat\u0103 a lui \\(A\\) de \\(k\\) elemente. De exemplu, aranjamente de 4 luate c\u00e2te 3 ale mul\u021bimii \\(\\{1, 2, 3, 4\\}\\) sunt urm\u0103toarele: \\(\\{1, 2, 3\\}\\), \\(\\{1, 2, 4\\}\\), \\(\\{1, 3, 4\\}\\), \\(\\{2, 1, 3\\}\\), \\(\\{2, 1, 4\\}\\), \\(\\{2, 3, 4\\}\\), \\(\\{3, 1, 2\\}\\), \\(\\{3, 1, 4\\}\\), \\(\\{3, 2, 4\\}\\), \\(\\{4, 1, 2\\}\\), \\(\\{4, 1, 3\\}\\), \\(\\{4, 2, 3\\}\\)</p> <p>Similar permut\u0103rilor, aranjamentele pot fi considerate func\u021bii injective definite pe mul\u021bimea \\(\\{1, 2, 3,\\dots, k\\}\\) cu valori \u00een \\(\\{1, 2, 3,\\dots, n\\}\\)</p> <p>Num\u0103rul aranjamentelor de \\(n\\) luate c\u00e2te \\(k (k\\leq n)\\) se noteaz\u0103 cu \\(A_n^k\\) \u0219i este egal cu \\(\\frac{n!}{(n-k)!}\\)</p> <p>O alt\u0103 formul\u0103 care poate fi util\u0103 \u00een special \u00een cazul precalcul\u0103rilor este \\(A_n^k = (n - k + 1)\\cdot A_n^{k-1}\\)</p>","tags":["matematica","combinatorica","teoria numerelor","permutari","aranjamente","combinari"]},{"location":"mediu/intro-combinatorics/#combinari","title":"Combin\u0103ri","text":"<p>O combinare de \\(n\\) elemente luate c\u00e2te \\(k\\) reprezint\u0103 o submul\u021bime neordonat\u0103 a lui \\(A\\) de \\(k\\) elemente. De exemplu, combin\u0103rile de 4 luate c\u00e2te 3 ale mul\u021bimii \\(\\{1, 2, 3, 4\\}\\) sunt urm\u0103toarele: \\(\\{1, 2, 3\\}\\), \\(\\{1, 2, 4\\}\\), \\(\\{1, 3, 4\\}\\), \\(\\{2, 3, 4\\}\\)</p> <p>Se poate observa c\u0103 spre deosebire de aranjamente, dac\u0103 dou\u0103 mul\u021bimi au acelea\u0219i elemente dar \u00eentr-o ordine diferit\u0103, se num\u0103r\u0103 o singur\u0103 dat\u0103.</p> <p>Formula pentru combin\u0103ri de \\(n\\) luate c\u00e2te \\(k\\), care se noteaz\u0103 cu \\(C_n^k\\) (alternativ, ve\u021bi mai putea g\u0103si nota\u021bii precum \\({}_{n}C_{k}\\), \\(C(n, k)\\) sau \\(\\binom{n}{k}\\) este $$ C_n^k = \\frac{n!}{k!\\cdot (n-k)!} $$ unde \\(C_0^0 = C_n^n = 1\\).</p> <p>Exist\u0103 numeroase moduri \u0219i propriet\u0103\u021bi de a lega valoarea lui \\(C_n^k\\) de alte valori combinatoriale, cele mai importante fiind urm\u0103toarele:</p> <ul> <li>\\(C_{n}^{k} =C_{n-1}^{k} +C_{n-1}^{k-1}\\), deoarece:</li> </ul> \\[ \\begin{align*} C_n^k &amp;= \\frac{n!}{k! (n-k)!}\\\\ &amp;= \\frac{n(n - 1)!}{k! (n-k)!}\\\\ &amp;= \\frac{k(n - 1)!}{k! (n - k)!} + \\frac{(n-k)(n - 1)!}{k! (n - k)!}\\\\ &amp;= \\frac{(n - 1)!}{(k - 1)! (n - k)!} + \\frac{(n - 1)!}{k! (n - k - 1)!}\\\\ &amp;= C_{n-1}^{k-1} +C_{n-1}^{k} \\end{align*} \\] <ul> <li> <p>Dac\u0103 simplific\u0103m frac\u021biile din formula de mai sus, putem scrie \\(C_n^k\\) ca   fiind</p> \\[   \\begin{align*}   C_n^k &amp;= \\prod_{i=1}^{k}\\frac{n-i+1}{i}\\\\   &amp;=   \\frac{n \\cdot (n - 1) \\cdots (n-(k - 1) + 1) \\cdots (n-k+1)}{1\\cdot 2\\cdot 3\\cdots\\cdot k}   \\end{align*} \\] </li> <li> <p>\\(C_{n}^{k} = C_{n}^{n-k}\\), fapt ce se poate observa din aplicarea formulei   specifice.</p> </li> <li>\\(\\sum_{i=0}^{n} C_n^i = 2^n\\)</li> </ul> <p>De multe ori, pentru a calcula combin\u0103rile, vom folosi triunghiul lui Pascal drept precalculare, fapt ce \u00eel putem realiza cu ajutorul formulei de mai sus care leag\u0103 \\(C_{n}^{k}\\) de \\(C_{n-1}^{k}\\) \u0219i \\(C_{n-1}^{k-1}\\).</p> <pre><code>const int N = 1000;\n\nint C[N + 1][N + 1];\n\nC[0][0] = 1;\n\nfor (int n = 1; n &lt;= N; n++) {\n    C[n][0] = 1;\n\n    for (int k = 1; k &lt;= n; k++) {\n        if (n == k) {\n            C[n][k] = 1;\n        } else {\n            C[n][k] = C[n - 1][k] + C[n - 1][k - 1];\n        }\n    }\n}\n</code></pre> <p>Exist\u0103 o metod\u0103 mai eficient\u0103 de a calcula \\(C_n^k\\) \u00een timp \\(\\mathcal{O}(k)\\) \u0219i spa\u021biu \\(\\mathcal{O}(1)\\):</p> <pre><code>const long long C(int n, int k) {\n    long long res = 1;\n\n    // C(n, k) = C(n, n-k)\n    if (k &gt; n - k) {\n        k = n - k;\n    }\n\n    for (int i = 0; i &lt; k; ++i) {\n        res *= (n - i);\n        res /= (i + 1);\n    }\n\n    return res;\n}\n</code></pre> <p>\u00cen alte situa\u021bii, va trebui s\u0103 precalcul\u0103m factorialele \u0219i inversele modulare pentru a putea calcula combin\u0103rile, a\u0219a cum vom ar\u0103ta mai jos. Dac\u0103 nu sunte\u021bi familiari cu ridicarea la putere \u00een timp logaritmic, v\u0103 rug\u0103m s\u0103 citi\u021bi articolul pe aceast\u0103 tem\u0103.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nconst int MOD = 998244353;\nconst int N = 100000;\n\nlong long fact[N + 1], inv[N + 1];\n\nlong long modpow(long long base, long long exponent) {\n    long long result = 1;\n    while (exponent) {\n        if (exponent &amp; 1) {\n            result = (result * base) % MOD;\n        }\n        base = (base * base) % MOD;\n        exponent &gt;&gt;= 1;\n    }\n    return result;\n}\n\nlong long C(int n, int k) {\n    if (k &gt; n || k &lt; 0) {\n        return 0;\n    }\n\n    // C(n, k) = n! * (k!)^-1 * (n - k)!^-1\n    long long result = fact[n];\n    result *= inv[k];\n    result %= MOD;\n    result *= inv[n - k];\n    result %= MOD;\n    return result;\n}\n\nvoid precalc() {\n    fact[0] = 1;\n    inv[0] = 1;\n\n    for (int i = 1; i &lt;= N; i++) {\n        fact[i] = (fact[i - 1] * i) % MOD;\n    }\n\n    inv[N] = modpow(fact[N], MOD - 2);  // (1)\n    for (int i = N - 1; i &gt;= 0; --i) {\n        inv[i] = (inv[i + 1] * (i + 1)) % MOD;\n    }\n}\n\nint main() {\n    precalc();\n\n    int n, k;\n    cin &gt;&gt; n &gt;&gt; k;\n    cout &lt;&lt; C(n, k);\n    return 0;\n}\n</code></pre> <ol> <li>Calcul\u0103m inversul modular \\(x^{-1} \\mod p\\) (\\(p\\) este <code>MOD</code> \u00een cod). \u00cen cazul     \u00een care \\(p\\) este prim, conform micii teoreme a lui Fermat, \\(x^{-1} = x^{p -     2}\\).</li> </ol>","tags":["matematica","combinatorica","teoria numerelor","permutari","aranjamente","combinari"]},{"location":"mediu/intro-combinatorics/#partitii","title":"Parti\u021bii","text":"<p>Numim parti\u021bie a unui num\u0103r \\(n\\) o secven\u021b\u0103 de numere naturale nenule \\(P\\) cu proprietatea c\u0103 \\(\\sum_{i = 1}^k P_i = n\\), unde \\(k\\) este num\u0103rul de numere din parti\u021bie. Parti\u021biile unui num\u0103r pot fi ordonate sau neordonate, \u00een func\u021bie de proprietatea pe care dorim s\u0103 o aplic\u0103m \u00eentr-o problem\u0103.</p> <p>Pentru a afla num\u0103rul de parti\u021bii ordonate ale unui num\u0103r \\(n\\), putem s\u0103 ne g\u00e2ndim la num\u0103rul de moduri de a \u00eemp\u0103r\u021bi \\(n\\) stele folosind diferite bare (anticip\u0103m \u00eentr-o oarecare m\u0103sur\u0103 discu\u021bia pe care o vom avea la Stars and Bars), iar dat fiind c\u0103 avem \\(n-1\\) pozi\u021bii unde putem face o \u00eemp\u0103r\u021bire, iar pentru fiecare pozi\u021bie avem posibilitatea de a pune o limit\u0103 sau nu, cu alte cuvinte avem \\(2^{n-1}\\) parti\u021bii ordonate ale unui num\u0103r \\(n\\).</p> <p>\u00cen privin\u021ba parti\u021biilor neordonate, deoarece trebuie s\u0103 p\u0103str\u0103m proprietatea c\u0103 numerele din parti\u021bie sunt cresc\u0103toare, trebuie s\u0103 avem grij\u0103 la calculul num\u0103rului de parti\u021bii de acest tip, iar o prim\u0103 solu\u021bie la aceast\u0103 problem\u0103 const\u0103 \u00een folosirea unei recuren\u021be de tipul \\(p(i, j)\\) = num\u0103rul de parti\u021bii neordonate ale lui \\(i\\), unde lungimea acesteia este \\(j\\). Pentru a putea calcula aceast\u0103 recuren\u021b\u0103, avem o formul\u0103 relativ simpl\u0103.</p> <ul> <li>\\(p(i, j) = p(i-1, j-1) + p(i-j, j)\\), dac\u0103 \\(i\\geq 1\\) \u0219i \\(j\\geq 1\\) (cu alte   cuvinte, fie ad\u0103ug\u0103m un 1 la \u00eenceputul parti\u021biei, fie increment\u0103m toate   elementele din parti\u021bie).</li> <li>\\(p(i, 0) = 0\\), pentru \\(i\\geq 1\\)</li> <li>\\(p(0, 0) = 1\\).</li> </ul> <p>Complexitatea acestei recuren\u021be este \\(n^2\\), optimizarea ei fiind imposibil\u0103 folosind aceast\u0103 abordare. Din fericire, exist\u0103 o metod\u0103 \u0219i mai rapid\u0103, care folose\u0219te numere pentagonale, abordare ce ne duce la o solu\u021bie \u00een \\(\\mathcal{O}(n\\sqrt n)\\), pentru mai multe detalii pute\u021bi accesa acest articol sau rezolva problema cresc\u0103tor2.</p>","tags":["matematica","combinatorica","teoria numerelor","permutari","aranjamente","combinari"]},{"location":"mediu/intro-combinatorics/#trucuri-pentru-rezolvarea-problemelor-de-combinatorica","title":"Trucuri pentru rezolvarea problemelor de combinatoric\u0103","text":"","tags":["matematica","combinatorica","teoria numerelor","permutari","aranjamente","combinari"]},{"location":"mediu/intro-combinatorics/#stars-and-bars","title":"Stars and Bars","text":"<p>Tehnica stars and bars este o tehnic\u0103 folosit\u0103 pentru a determina diverse sume combinatoriale care se reduc la aflarea num\u0103rului de solu\u021bii ale ecua\u021biei \\(x_1 + x_2 + ... + x_k = n\\), unde \\(x_i\\) este fie num\u0103r natural pozitiv, fie num\u0103r \u00eentreg non-negativ, reg\u0103sindu-se dou\u0103 cazuri.</p> <p>Num\u0103rul de moduri de a \u00eemp\u0103r\u021bi \\(n\\) obiecte \u00een \\(k\\) grupe, fiecare grup\u0103 av\u00e2nd cel pu\u021bin un element este egal cu \\(C_{n-1}^{k-1}\\), deoarece avem \\(n-1\\) locuri unde putem pune barierele \u0219i trebuie s\u0103 punem \\(k-1\\) bariere pentru a ob\u021bine \\(k\\) grupe.</p> <p>Num\u0103rul de moduri de a \u00eemp\u0103r\u021bi \\(n\\) obiecte \u00een \\(k\\) grupe, dac\u0103 fiecare grup\u0103 poate fi \u0219i goal\u0103 cu \\(C_{n+k-1}^{k-1}\\), deoarece avem \\(n+k-1\\) locuri unde putem pune barierele \u0219i trebuie s\u0103 punem \\(k-1\\) bariere pentru a ob\u021bine \\(k\\) grupe.</p> <p>Aceast\u0103 tehnic\u0103 se g\u0103se\u0219te \u00een diferite aplica\u021bii, de obicei atunci c\u00e2nd vrem s\u0103 grup\u0103m diferite valori sau diferite \u0219iruri, \u00een problemele de num\u0103rare.</p>","tags":["matematica","combinatorica","teoria numerelor","permutari","aranjamente","combinari"]},{"location":"mediu/intro-combinatorics/#hockey-stick-identity","title":"Hockey Stick Identity","text":"<p>Pentru dou\u0103 numere \\(n\\) \u0219i \\(r\\), \\(\\sum_{i=r}^{n} C_i^r = C_{n+1}^{r+1}\\). Pentru a demonstra aceast\u0103 rela\u021bie, se pot folosi argumente inductive, algebrice sau metode ce se folosesc de func\u021bii generatoare. Pentru mai multe detalii, pute\u021bi citi acest blog.</p>","tags":["matematica","combinatorica","teoria numerelor","permutari","aranjamente","combinari"]},{"location":"mediu/intro-combinatorics/#numerele-catalan","title":"Numerele Catalan","text":"<p>\u00cen combinatoric\u0103, numerele Catalan sunt o serie de numere care apar \u00een diverse probleme, devenind foarte cunoscute \u0219i folosite \u00een aplica\u021bii ce se g\u0103sesc de multe ori la olimpiadele de informatic\u0103 pentru juniori.</p> <p>\u0218irul numerelor Catalan este \\(1, 1, 2, 5, 14, 42, \\dots\\) \u0219i formula pentru aflarea celui de-al \\(i\\)-lea num\u0103r Catalan este:</p> \\[ C_n = \\frac{1}{n+1}\\cdot C_{2n}^{n} =\\frac{(2n)!}{(n+1)! n!} = \\prod_{k = 2}^{n} \\frac{n + k}{k} \\] <p>Computa\u021bional vorbind, se folose\u0219te deseori forma recursiv\u0103, cu \\(C_0 = 1\\) \u0219i $$ C_n = \\sum_{i = 1}^n C_{i - 1}C_{n - i} = \\frac{2(2n - 1)}{n + 1} C_{n - 1} $$</p> <p>Printre altele, numerele Catalan apar \u00een aplica\u021bii precum:</p> <ul> <li>Num\u0103rul de arbori binari cu \\(n\\) noduri.</li> <li>Num\u0103rul de parantez\u0103ri corecte de lungime \\(2n\\).</li> <li>Num\u0103rul de drumuri de la \\((0, 0)\\) la \\((n, n)\\) care merg \u00een sus \u0219i la dreapta   f\u0103r\u0103 s\u0103 treac\u0103 de partea cealalt\u0103 a diagonalei principale.</li> <li>\u0218i multe altele, pe care le pute\u021bi g\u0103si   aici</li> </ul> <p>A\u0219a se calculeaz\u0103 num\u0103rul Catalan:</p> Calcul cu C(n, k)Calcul cu DPCalcul direct <pre><code>const unsigned long long C(int n, int k) {\n    unsigned long long res = 1;\n\n    // C(n, k) = C(n, n-k)\n    if (k &gt; n - k) {\n        k = n - k;\n    }\n\n    for (int i = 0; i &lt; k; ++i) {\n        res *= (n - i);\n        res /= (i + 1);\n    }\n\n    return res;\n}\n\nconst unsigned long long catalan(unsigned int n) {\n    return C(2 * n, n) / (n + 1);\n}\n</code></pre> <pre><code>const unsigned long long catalan(unsigned int n) {\n    unsigned long long C[n + 1];\n\n    C[0] = C[1] = 1;\n\n    for (int i = 2; i &lt;= n; i++) {\n        C[i] = 0;\n        for (int j = 0; j &lt; i; j++) {\n            C[i] += C[j] * C[i - j - 1];\n        }\n    }\n\n    return C[n];\n}\n</code></pre> <pre><code>const unsigned long long catalan(unsigned int n) {\n    unsigned long long res = 1;\n\n    for (int i = 1; i &lt;= n; ++i) {\n        res *= 2 * (2 * i - 1);\n        res /= (i + 1);\n    }\n\n    return res;\n}\n</code></pre>","tags":["matematica","combinatorica","teoria numerelor","permutari","aranjamente","combinari"]},{"location":"mediu/intro-combinatorics/#numerele-stirling","title":"Numerele Stirling","text":"<p>La fel ca \u0219i numerele Catalan, numerele Stirling \u0219i Bell apar \u00een anumite aplica\u021bii ale problemelor de combinatoric\u0103. Numerele Stirling de prim\u0103 spe\u021b\u0103 sunt folositoare \u00een special c\u00e2nd vine vorba de num\u0103rarea ciclurilor \u00een permut\u0103ri, iar numerele Stirling de cea de-a doua spe\u021b\u0103, precum \u0219i numerele Bell se reg\u0103sesc \u00een probleme legate de num\u0103rarea unor parti\u021bii.</p> <p>Numerele lui Stirling de spe\u021ba I num\u0103r\u0103 c\u00e2te permut\u0103ri de ordin \\(n\\) cu \\(k\\) cicluri exist\u0103, \u0219i se noteaz\u0103 cu \\(s(n, k)\\). De exemplu, permutarea \\(1, 4, 2, 3, 6, 5\\) are 2 cicluri (1, \\(2, 4, 3\\) \u0219i \\(5, 6\\)). Cazurile particulare sunt \\(s(0, 0) = 1, s(n, 0) = 0\\) \u0219i \\(s(0, k) = 0\\), iar formula recurent\u0103 este \\(s(n, k) = s(n-1, k-1) + (n-1)\\cdot s(n-1, k)\\), recuren\u021b\u0103 ce se poate explica recurg\u00e2nd la cazurile pe care le \u00eent\u00e2mpin\u0103m atunci c\u00e2nd ad\u0103ug\u0103m o nou\u0103 valoare la permutare, deoarece fie putem forma un ciclu nou, fie \u00eel introducem \u00eentr-un ciclu deja existent.</p> <p>Numerele lui Stirling de spe\u021ba II reprezint\u0103 num\u0103rul de parti\u021bii ale unei mul\u021bimi cu \\(n\\) elemente \u00een \\(k\\) submul\u021bimi, \u0219i se noteaz\u0103 cu \\(S(n, k)\\). Cazurile particulare sunt \\(S(0, 0) = 1, S(n, 0) = 0\\) \u0219i \\(S(0, k) = 0\\), iar formula recurent\u0103 este \\(S(n, k) = s(n-1, k-1) + k\\cdot s(n-1, k)\\), recuren\u021b\u0103 ce se poate explica recurg\u00e2nd la cazurile pe care le \u00eent\u00e2mpin\u0103m atunci c\u00e2nd ad\u0103ug\u0103m o nou\u0103 valoare la parti\u021biile existente, deoarece fie putem forma o nou\u0103 parti\u021bie, fie o introducem \u00eentr-o parti\u021bie deja existent\u0103.</p> Stirling de spe\u021ba IStirling de spe\u021ba II <pre><code>const int MAX = 100;\n\nunsigned long long S[MAX + 1][MAX + 1];\n\nvoid stirling(const int N) {\n    S[0][0] = 0;\n\n    for (int i = 1; i &lt;= N; ++i) {\n        for (int j = 1; j &lt;= i; ++j) {\n            S[i][j] = S[i - 1][j - 1] + (i - 1) * S[i - 1][j];\n        }\n    }\n}\n</code></pre> <pre><code>const int MAX = 100;\n\nunsigned long long S[MAX + 1][MAX + 1];\n\nvoid stirling(const int N) {\n    S[0][0] = 0;\n\n    for (int i = 1; i &lt;= N; ++i) {\n        for (int j = 1; j &lt;= i; ++j) {\n            S[i][j] = S[i - 1][j - 1] + j * S[i - 1][j];\n        }\n    }\n}\n</code></pre> <p>Numerele Bell se refer\u0103 la num\u0103rul de modalit\u0103\u021bi prin care putem parti\u021biona o mul\u021bime cu \\(n\\) elemente, \u0219i se noteaz\u0103 cu \\(B_n\\), fiind o generalizare a numerelor Stirling de spe\u021ba II, num\u0103r\u00e2nd toate parti\u021biile posibile pentru o mul\u021bime. \\(B_n\\) poate fi calculat u\u0219or plec\u00e2nd de la numerele Stirling de spe\u021ba a doua, \\(B_n = S(n, 0) + S(n, 1) +\\dots + S(n, n)\\) sau folosind direct numerele Bell anterioare, \\(B_n =\\sum_{i=0}^{n-1} C_{n-1}^i\\cdot B_i\\).</p>","tags":["matematica","combinatorica","teoria numerelor","permutari","aranjamente","combinari"]},{"location":"mediu/intro-combinatorics/#cum-putem-rezolva-probleme-de-combinatorica","title":"Cum putem rezolva probleme de combinatoric\u0103?","text":"<p>De obicei, c\u00e2nd vine vorba de rezolvarea problemelor de combinatoric\u0103, este foarte important mai \u00eent\u00e2i de toate s\u0103 v\u0103 asigura\u021bi c\u0103 \u0219ti\u021bi formulele \u0219i conceptele esen\u021biale, dar \u0219i s\u0103 le \u00een\u021belege\u021bi foarte clar deoarece \u00een cazul acestor probleme, memorarea formulelor f\u0103r\u0103 a le \u00een\u021belege cum trebuie va cauza mai multe probleme dec\u00e2t necunoa\u0219terea lor.</p> <p>Presupun\u00e2nd c\u0103 ave\u021bi un bagaj de cuno\u0219tin\u021be suficient pentru nivelul de dificultate al problemei pe care \u00eel aborda\u021bi, mai \u00eent\u00e2i de toate vre\u021bi s\u0103 \u0219ti\u021bi foarte clar ce date trebuie num\u0103rate \u0219i s\u0103 g\u0103si\u021bi observa\u021bii, care chiar dac\u0103 la \u00eenceput nu par a fi semnificative, pot fi utile pentru ob\u021binerea r\u0103spunsului final.</p> <p>O alt\u0103 tehnic\u0103 foarte important\u0103 const\u0103 \u00een a g\u0103si subprobleme independente ale problemei date, care pot fi folosite pentru a simplifica procesul de g\u0103sire a r\u0103spunsului final, de multe ori acest lucru fiind esen\u021bial \u00een rezolvarea problemelor mai dificile.</p> <p>Nu \u00een ultimul r\u00e2nd, experien\u021ba \u0219i identificarea diferitelor tipuri de formule ce apar de la problem\u0103 la problem\u0103 poate fi foarte folositor, iar de\u0219i acest lucru nu este neap\u0103rat specific strict combinatoricii, se poate observa faptul c\u0103 \u00een cazul acestei tehnici, generarea tuturor solu\u021biilor folosind metode precum backtracking sau brute force se poate dovedi de ajutor pentru identificarea unor posibile rela\u021bii de recuren\u021b\u0103 sau a unor formule care s\u0103 ne duc\u0103 la r\u0103spuns.</p> <p>Trebuie s\u0103 ave\u021bi grij\u0103 \u0219i la faptul c\u0103 \u00een unele cazuri, probleme ce pot p\u0103rea a fi de combinatoric\u0103 s\u0103 nu fie de fapt dinamici care se pot aborda mult mai u\u0219or folosind modul de g\u00e2ndire specific program\u0103rii dinamice, iar chiar dac\u0103 \u00een unele cazuri exist\u0103 similarit\u0103\u021bi \u00eentre cele dou\u0103, acest lucru nu este adev\u0103rat mereu.</p>","tags":["matematica","combinatorica","teoria numerelor","permutari","aranjamente","combinari"]},{"location":"mediu/intro-combinatorics/#concluzii","title":"Concluzii","text":"<p>Combinatorica apare drept subiect de baz\u0103 \u00een multe probleme, iar cunoa\u0219terea temeinic\u0103 a tehnicilor de rezolvare a acestor probleme este esen\u021bial\u0103. Din cauza dificult\u0103\u021bii cu care aceast\u0103 tehnic\u0103 este \u00eenv\u0103\u021bat\u0103, se recomand\u0103 rezolvarea unui num\u0103r c\u00e2t mai mare de probleme, pentru a fi expus la diverse tehnici, formule \u0219i rezultate importante at\u00e2t \u00een matematic\u0103, c\u00e2t \u0219i \u00een informatic\u0103.  </p>","tags":["matematica","combinatorica","teoria numerelor","permutari","aranjamente","combinari"]},{"location":"mediu/intro-combinatorics/#probleme-suplimentare","title":"Probleme suplimentare","text":"","tags":["matematica","combinatorica","teoria numerelor","permutari","aranjamente","combinari"]},{"location":"mediu/intro-combinatorics/#probleme-de-la-olimpiade","title":"Probleme de la olimpiade","text":"<ul> <li>Combination</li> <li>pascal infoarena</li> <li>Stirling infoarena</li> <li>IIOT Dream</li> <li>Polyglot Kilonova</li> <li>Problemele de combinatoric\u0103 de pe Kilonova, \u00een special cele de la loturile de   juniori</li> <li>RoAlgo Contest 4 - Ursul</li> <li>RoAlgo Contest 2 - munte</li> <li>RCPC 2023 KsumT</li> <li>ONI 2014 Spion</li> <li>ONI 2015 Nmult</li> <li>ONI 2015 Baraj Provocare</li> <li>ONI 2013 Xnumere</li> <li>IIOT 2024 Mermaid</li> <li>USACO Gold Help   Yourself</li> <li>Problemele de pe cppi.sync</li> </ul>","tags":["matematica","combinatorica","teoria numerelor","permutari","aranjamente","combinari"]},{"location":"mediu/intro-combinatorics/#alte-probleme","title":"Alte probleme","text":"<ul> <li>CSES Bracket Sequences I</li> <li>CSES Bracket Sequences II</li> <li>CSES Distributing Apples</li> <li>Codeforces Arena</li> <li>Codeforces Close Tuples (hard version)</li> <li>Codeforces Almost Identity   Permutations</li> <li>Codeforces Card Game</li> <li>Codeforces Med and Mex</li> <li>Codeforces Different Subsets For All   Tuples</li> <li>Probleme de combinatoric\u0103 de pe   Codeforces</li> </ul>","tags":["matematica","combinatorica","teoria numerelor","permutari","aranjamente","combinari"]},{"location":"mediu/intro-combinatorics/#bibliografie-si-lectura-suplimentara","title":"Bibliografie \u0219i lectur\u0103 suplimentar\u0103","text":"<ul> <li>Concurs educa\u021bional f\u0103cut de   MathDash</li> <li>Curs de combinatoric\u0103 f\u0103cut de Bogdan   Iordache</li> <li>Curs de combinatoric\u0103 avansat f\u0103cut de Alex   Luchianov</li> <li>Combinatorics - USACO Guide (articol +   probleme)</li> <li>Elemente de combinatoric\u0103</li> <li>Binomial Coefficients -   Eolymp</li> <li>Ghid despre permutari -   nor-blog</li> <li>Elemente de combinatoric\u0103, curs predat la lotul de juniori din   2018</li> <li>Derangement - wikipedia</li> <li>A tutorial of reflection principle in combinatorics</li> <li>Problem Solving Guide to Modular Combinatorics and Exponentiation -   Codeforces</li> <li>Binomial coefficient -   wikipedia</li> <li>Triunghiul lui Pascal -   wikipedia</li> <li>Stars and Bars</li> <li>Num\u0103rul de parti\u021bii ale unui num\u0103r   natural</li> <li>Numere Catalan</li> <li>Catalan Numbers and Catalan   Convolution</li> <li>Catalan Numbers and Generating Uniform Balanced Bracket   Sequences</li> <li>Numerele Stirling \u0219i numerele   Bell</li> <li>Numerele Stirling de ambele   spe\u021be</li> <li>Partition of a set</li> <li>Op\u021bional, restul articolelor de la sec\u021biunea   combinatorics</li> </ul>","tags":["matematica","combinatorica","teoria numerelor","permutari","aranjamente","combinari"]},{"location":"mediu/knapsack/","title":"Problema rucsacului","text":"","tags":["optimizare","programare dinamica"]},{"location":"mediu/knapsack/#introducere","title":"Introducere","text":"<p>Se d\u0103 urm\u0103toarea problem\u0103 pe care trebuie s\u0103 o rezolv\u0103m: Ai un set de obiecte pentru care \u0219tim greutatea \u0219i valoarea lor \u0219i vrei s\u0103 alegi unele obiecte din el, pe care s\u0103 le pui \u00eentr-un rucsac \u0219i s\u0103 \u00eencerci s\u0103 le vinzi turi\u0219tilor care viziteaz\u0103 ora\u0219ul \u00een care locuie\u0219ti. Ideal, ai vrea s\u0103 po\u021bi aduce toate obiectele, dar din p\u0103cate, rucsacul are o capacitate limitat\u0103, a\u0219a c\u0103 va trebui s\u0103 alegi ce obiecte vei p\u0103stra \u0219i ce obiecte nu.</p> <p>Aceast\u0103 problem\u0103 se nume\u0219te problema rucsacului \u0219i este una dintre cele mai studiate probleme de optimizare din informatic\u0103, av\u00e2nd multiple solu\u021bii \u00een func\u021bie de condi\u021biile impuse, restric\u021biile cu privire la num\u0103rul de obiecte alese \u0219i multe alte varia\u021bii, pe care le vom discuta \u00een cele ce urmeaz\u0103.</p>","tags":["optimizare","programare dinamica"]},{"location":"mediu/knapsack/#modul-de-abordare","title":"Modul de abordare","text":"<p>\u00cen cazul majorit\u0103\u021bii problemelor de tipul celei men\u021bionate anterior, vom folosi o abordare ce folose\u0219te metoda program\u0103rii dinamice, a\u0219a c\u0103 recomand\u0103m citirea articolului \u00een care facem introducerea acestei metode pentru a putea \u00een\u021belege mai bine con\u021binuturile explicate aici.</p> <p>O excep\u021bie notabil\u0103 const\u0103 \u00een problema rucsacului frac\u021bionar, \u00een care avem voie s\u0103 rupem obiectele \u00een beneficiul nostru, fiind evident \u00een cazul acestei variante faptul c\u0103 abordarea optim\u0103 const\u0103 \u00een sortarea obiectelor \u00een ordine descresc\u0103toare a raportului \\(\\frac{valoare}{greutate}\\) \u0219i alegerea obiectelor cu cel mai bun raport, p\u00e2n\u0103 c\u00e2nd umplem rucsacul.</p>","tags":["optimizare","programare dinamica"]},{"location":"mediu/knapsack/#variatii-ale-problemei-rucsacului","title":"Varia\u021bii ale problemei rucsacului","text":"<p>\u00cen cele ce urmeaz\u0103, vom prezenta diverse varia\u021bii \u00een care apare problema rucsacului, \u00eempreun\u0103 cu strategiile de abordare \u0219i implement\u0103ri care pot fi folosite \u0219i \u00een alte probleme de acest fel.</p>","tags":["optimizare","programare dinamica"]},{"location":"mediu/knapsack/#rucsacul-clasic-0-1-knapsack","title":"Rucsacul clasic (0-1 Knapsack)","text":"<p>Pentru aceast\u0103 problem\u0103, vom presupune c\u0103 avem voie s\u0103 alegem fiecare dintre cele \\(N\\) obiecte cel mult o dat\u0103, obiecte pentru care \u0219tim valoarea \u0219i greutatea lor, \\(V_i\\) \u0219i \\(W_i\\) \u0219i \u0219tim greutatea maxim\u0103 admis\u0103 a rucsacului, \\(G\\).</p> <p>O prim\u0103 solu\u021bie care pare u\u0219or de g\u0103sit este cea pe care am descris-o mai sus, pe modelul rucsacului frac\u021bionar, \u00eens\u0103 aceasta nu merge, deoarece putem g\u0103si foarte u\u0219or un contra-exemplu. Un asemenea test ar fi \\(N = 3\\), \\(G = 4\\), \\(V_1 = 9\\), \\(W_1 = 3\\), \\(V_2 = 5\\), \\(W_2 = 2\\), \\(V_3 = 5\\), \\(W_3 = 2\\). Un algoritm greedy ar lua primul obiect deoarece raportul dintre valoare \u0219i greutate este maxim, dar solu\u021bia optim\u0103 const\u0103 \u00een luarea ultimelor dou\u0103 obiecte, care chiar dac\u0103 au rapoarte mai mici, adunate ne vor duce la un r\u0103spuns mai bun.</p> <p>\u00cen acest caz, va trebui s\u0103 g\u00e2ndim altfel problema. Deoarece o solu\u021bie de tip greedy va avea mereu un contra-exemplu pe cazul general, vom putea folosi o dinamic\u0103, \u00een care vom \u021bine cont de greutatea folosit\u0103 \u0219i de num\u0103rul de obiecte procesat.</p> <p>Astfel, vom defini \\(dp[i][j]\\) ca fiind valoarea maxim\u0103 a unor obiecte alese din primele \\(i\\) cu suma greut\u0103\u021bilor egal\u0103 cu \\(j\\). R\u0103spunsul final va fi valoarea maxim\u0103 a unei valori de tipul \\(dp[i][j]\\).</p>","tags":["optimizare","programare dinamica"]},{"location":"mediu/knapsack/#cum-calculam-dpij","title":"Cum calcul\u0103m \\(dp[i][j]\\)?","text":"<p>Pentru a calcula \\(dp[i][j]\\), trebuie s\u0103 ne g\u00e2ndim la cazurile de la care plec\u0103m pentru a ajunge la aceast\u0103 stare (vom presupune c\u0103 \\(W_i \\leq j\\)). Cu alte cuvinte, ce facem cu obiectul \\(i\\). Pe de o parte, \u00eel lu\u0103m \u0219i va trebui s\u0103 consider\u0103m cazul specific acestui lucru, iar pe de alt\u0103 parte, nu \u00eel lu\u0103m \u0219i va trebui s\u0103 ne raport\u0103m la starea anterioar\u0103 cu aceea\u0219i sum\u0103 a greut\u0103\u021bii. Rela\u021bia de recuren\u021b\u0103 va dovedi acest lucru, accentu\u00e2nd caracterul binar al problemei rucsacului (de aici vine \u0219i denumirea de \\(0-1\\) knapsack folosit\u0103 \u00een specialitate).</p> \\[dp[i][j] = max(dp[i-1][j], dp[i-1][j-W_i] + V_i)\\] <p>Dup\u0103 cum pute\u021bi vedea, fiecare stare depinde de exact dou\u0103 st\u0103ri anterioare, \u00een func\u021bie de decizia pe care o lu\u0103m cu privire la cel de-al i-lea obiect. Mai jos pute\u021bi g\u0103si solu\u021bia la problema Knapsack I de pe AtCoder.</p> <pre><code>#include &lt;iostream&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\nint main() {\n    int n, w;\n    cin &gt;&gt; n &gt;&gt; w;\n\n    vector&lt;vector&lt;long long&gt; &gt; dp(n + 1, vector&lt;long long&gt;(w + 1, 0));\n\n    for (int i = 1; i &lt;= n; i++) {\n        int wi, vi;\n        cin &gt;&gt; wi &gt;&gt; vi;\n        for (int j = 0; j &lt;= w; j++) {\n            dp[i][j] = dp[i - 1][j];\n            if (wi &lt;= j &amp;&amp; dp[i - 1][j - wi] + vi &gt; dp[i][j]) {\n                dp[i][j] = dp[i - 1][j - wi] + vi;\n            }\n        }\n    }\n\n    long long ans = 0;\n    for (int i = 1; i &lt;= n; i++) {\n        for (int j = 0; j &lt;= w; j++) {\n            ans = max(ans, dp[i][j]);\n        }\n    }\n    cout &lt;&lt; ans &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["optimizare","programare dinamica"]},{"location":"mediu/knapsack/#putem-imbunatati-solutia","title":"Putem \u00eembun\u0103t\u0103\u021bi solu\u021bia?","text":"<p>Se poate observa c\u0103 fiecare pozi\u021bie din dinamica noastr\u0103 depinde doar de rezultatele liniei anterioare, deci putem s\u0103 reducem memoria necesar\u0103 la \\(2 \\cdot w\\), cum se poate vedea mai jos.</p> <pre><code>#include &lt;iostream&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\nint main() {\n    int n, w;\n    cin &gt;&gt; n &gt;&gt; w;\n\n    vector&lt;vector&lt;long long&gt; &gt; dp(2, vector&lt;long long&gt;(w + 1, 0));\n\n    bool x = 1;\n    for (int i = 1; i &lt;= n; i++) {\n        int wi, vi;\n        cin &gt;&gt; wi &gt;&gt; vi;\n        for (int j = 0; j &lt;= w; j++) {\n            dp[x][j] = dp[x ^ 1][j];\n            if (wi &lt;= j &amp;&amp; dp[x ^ 1][j - wi] + vi &gt; dp[x][j]) {\n                dp[x][j] = dp[x ^ 1][j - wi] + vi;\n            }\n        }\n        x ^= 1;\n    }\n\n    long long ans = 0;\n    for (int i = 0; i &lt;= 1; i++) {\n        for (int j = 0; j &lt;= w; j++) {\n            ans = max(ans, dp[i][j]);\n        }\n    }\n    cout &lt;&lt; ans &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre> <p>Ba chiar putem face o alt\u0103 \u00eembun\u0103t\u0103\u021bire din punct de vedere al memoriei, baz\u00e2ndu-ne pe faptul c\u0103 putem calcula st\u0103rile pas cu pas, de la dreapta la st\u00e2nga, f\u0103r\u0103 a avea nevoie s\u0103 \u021binem o a doua linie. Totu\u0219i, trebuie avut grij\u0103 la implementare, deoarece dac\u0103 forul e f\u0103cut de la st\u00e2nga la dreapta, risc\u0103m s\u0103 repet\u0103m obiecte, lucru care nu ne este permis \u00een aceast\u0103 versiune.</p> <pre><code>#include &lt;iostream&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\nint main() {\n    int n, w;\n    cin &gt;&gt; n &gt;&gt; w;\n\n    vector&lt;long long&gt; dp(w + 1, 0);\n\n    bool x = 1;\n    for (int i = 1; i &lt;= n; i++) {\n        int wi, vi;\n        cin &gt;&gt; wi &gt;&gt; vi;\n        for (int j = w; j &gt;= wi; j--) {\n            dp[j] = max(dp[j], dp[j - wi] + vi);\n        }\n    }\n\n    long long ans = 0;\n    for (int j = 0; j &lt;= w; j++) {\n        ans = max(ans, dp[j]);\n    }\n    cout &lt;&lt; ans &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre> <p>Dup\u0103 cum se poate observa, aceast\u0103 implementare a fost adus\u0103 de la \\(\\mathcal{O}(n \\cdot w)\\) memorie la \\(\\mathcal{O}(w)\\) memorie, codul devenind de asemenea mai scurt.</p>","tags":["optimizare","programare dinamica"]},{"location":"mediu/knapsack/#rucsacul-in-care-putem-repeta-obiecte-de-un-numar-nelimitat-de-ori","title":"Rucsacul \u00een care putem repeta obiecte de un num\u0103r nelimitat de ori","text":"<p>Aceast\u0103 varia\u021bie este una \u00een care putem folosi un obiect de mai multe ori. Pentru a putea implementa aceast\u0103 varia\u021bie, trebuie doar s\u0103 modific\u0103m ultimul cod pentru a avea o parcurgere clasic\u0103 de la st\u00e2nga la dreapta. Din nou, vom presupune forma datelor de intrare ca fiind aceea\u0219i.</p> <pre><code>#include &lt;iostream&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\nint main() {\n    int n, w;\n    cin &gt;&gt; n &gt;&gt; w;\n\n    vector&lt;long long&gt; dp(w + 1, 0);\n\n    bool x = 1;\n    for (int i = 1; i &lt;= n; i++) {\n        int wi, vi;\n        cin &gt;&gt; wi &gt;&gt; vi;\n        for (int j = wi; j &lt;= w; j++) {\n            dp[j] = max(dp[j], dp[j - wi] + vi);\n        }\n    }\n\n    long long ans = 0;\n    for (int j = 0; j &lt;= w; j++) {\n        ans = max(ans, dp[j]);\n    }\n    cout &lt;&lt; ans &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["optimizare","programare dinamica"]},{"location":"mediu/knapsack/#rucsacul-in-care-putem-repeta-obiecte-de-un-numar-limitat-de-ori","title":"Rucsacul \u00een care putem repeta obiecte de un num\u0103r limitat de ori","text":"<p>Aceast\u0103 varia\u021bie este una ceva mai dificil\u0103, deoarece nu mai putem folosi implementarea de mai sus f\u0103r\u0103 a folosi obiecte de prea multe ori, a\u0219a c\u0103 va trebui s\u0103 recurgem la o metod\u0103 de a reduce problema la un rucsac de tipul \\(0-1\\), ca cel prezentat mai sus.</p>","tags":["optimizare","programare dinamica"]},{"location":"mediu/knapsack/#trucul-log_2","title":"Trucul \"\\(\\log_2\\)\"","text":"<p>A\u0219a cum \u00eei zice \u0219i numele, vom vrea s\u0103 descompunem frecven\u021bele obiectelor \u00een sume de puteri ale lui 2, astfel \u00eenc\u00e2t s\u0103 putem acoperi oricare num\u0103r de la 1 la frecven\u021ba num\u0103rului, cu c\u00e2t mai pu\u021bine obiecte. Motivul pentru care folosim puterile lui 2 \u0219i nu numere consecutive este acela c\u0103 \u00een cazul \u00een care frecven\u021bele cresc foarte rapid, vom avea nevoie de foarte pu\u021bine numere (de exemplu, \\(1 + 2 + 4 + 8 = 1 + 2 + 3 + 4 + 5\\)).</p> <p>Vom explica modul de aplicare al acestui truc folosind un exemplu, ca mai apoi s\u0103 ar\u0103t\u0103m o implementare de acest fel.</p> <p>Exemplu</p> <p>Dac\u0103 avem un element cu frecven\u021ba 20 \u0219i greutatea individual\u0103 \\(W\\), mai \u00eent\u00e2i vom sc\u0103dea puteri ale lui 2 tot mai mari, iar mai apoi restul r\u0103mas va fi folosit \u0219i el.</p> <ul> <li>\\(20 - 1 = 19\\), putem folosi 1, deci \u00eenmul\u021bim puterea cu 2. Vom crea un   obiect cu greutate \\(1 \\cdot W\\).</li> <li>\\(19 - 2 = 17\\), putem folosi 2, deci \u00eenmul\u021bim puterea cu 2. Vom crea un   obiect cu greutate \\(2 \\cdot W\\).</li> <li>\\(17 - 4 = 13\\), putem folosi 4, deci \u00eenmul\u021bim puterea cu 2. Vom crea un   obiect cu greutate \\(4 \\cdot W\\).</li> <li>\\(13 - 8 = 5\\), putem folosi 8, deci \u00eenmul\u021bim puterea cu 2. Vom crea un   obiect cu greutate \\(8 \\cdot W\\).</li> <li>\\(5 - 16 = -11\\), nu putem folosi 16, a\u0219a c\u0103 folosim num\u0103rul r\u0103mas, 5.   Vom crea un obiect cu greutate \\(5 \\cdot W\\).</li> </ul> <p>Cu alte cuvinte, am \u00eemp\u0103r\u021bit un obiect cu frecven\u021ba 20 \u00een 5 obiecte echivalente, cu frecven\u021bele \\(1, 2, 4, 8\\) \u0219i 5.</p> <p>Un exemplu de problem\u0103 \u00een care se poate aplica acest truc este strehaia de la RoAlgo Contest 2. Pute\u021bi g\u0103si implementarea mai jos.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint ruk[1000001], frq[102];\n\nint main() {\n    int n;\n    cin &gt;&gt; n;\n\n    ruk[0] = 1;\n\n    for (int i = 1; i &lt;= n; i++) {\n        int x;\n        cin &gt;&gt; x;\n\n        for (int p = 1; p &lt;= x; p++) {\n            int q;\n            cin &gt;&gt; q;\n            frq[q]++;\n        }\n    }\n\n    int sm = 0;\n    for (int i = 1; i &lt;= 100; i++) {\n        int val = 1;\n        while (frq[i]) {\n            frq[i] -= val;\n            int total = i * val;\n            for (int poz = sm; poz &gt;= 0; poz--) {\n                if (ruk[poz]) {\n                    ruk[poz + total] = 1;\n                }\n            }\n            sm += total;\n            val *= 2;\n            if (val &gt; frq[i]) {\n                val = frq[i];\n            }\n        }\n    }\n\n    int cnt = 0;\n    for (int i = 0; i &lt;= 1000000; i++) {\n        cnt += ruk[i];\n    }\n    cout &lt;&lt; cnt &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["optimizare","programare dinamica"]},{"location":"mediu/knapsack/#rucsacul-in-care-ne-intereseaza-doar-daca-avem-o-anumita-suma-sau-nu","title":"Rucsacul \u00een care ne intereseaz\u0103 doar dac\u0103 avem o anumit\u0103 sum\u0103 sau nu","text":"<p>\u00cen multe probleme, nu ne intereseaz\u0103 suma maxim\u0103 sau minim\u0103 pe care o putem ob\u021bine, ci pur \u0219i simplu dac\u0103 putem crea o anumit\u0103 sum\u0103 folosind obiectele alese sau nu, acesta fiind un alt exemplu \u00een care putem aplica o dinamic\u0103 de tipul celor prezentate anterior. Deoarece nu mai avem nevoie s\u0103 \u021binem \u0219i o valoare maxim\u0103, avem o mai mare flexibilitate \u00een privin\u021ba implement\u0103rilor. Printre altele, aici putem folosi bitset pentru optimizarea actualiz\u0103rii st\u0103rilor, a\u0219a cum am procedat \u00een aceast\u0103 solu\u021bie pentru problema Money Sums.</p> <pre><code>#include &lt;bitset&gt;\n#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int n;\n    cin &gt;&gt; n;\n\n    bitset&lt;100001&gt; dp;\n\n    dp[0] = 1;\n    for (int i = 1; i &lt;= n; i++) {\n        int x;\n        cin &gt;&gt; x;\n\n        dp |= (dp &lt;&lt; x);  // aplicam operatiile pe biti pentru a creste\n                          // eficienta bitsetului\n    }\n\n    int cnt = 0;\n    for (int i = 1; i &lt;= 100000; i++) {\n        cnt += dp[i];\n    }\n    cout &lt;&lt; cnt &lt;&lt; '\\n';\n    for (int i = 1; i &lt;= 100000; i++) {\n        if (dp[i]) {\n            cout &lt;&lt; i &lt;&lt; \" \";\n        }\n    }\n\n    return 0;\n}\n</code></pre>","tags":["optimizare","programare dinamica"]},{"location":"mediu/knapsack/#adaugarea-si-scoaterea-de-valori-din-rucsac","title":"Ad\u0103ugarea \u0219i scoaterea de valori din rucsac","text":"<p>Dac\u0103 vrem s\u0103 avem un rucsac care s\u0103 poat\u0103 suporta \u0219i actualiz\u0103ri, vom putea folosi o varia\u021bie destul de simpl\u0103 care ne permite s\u0103 ajungem la r\u0103spunsuri mai u\u0219or. Vom presupune c\u0103 vom stoca c\u00e2te moduri sunt s\u0103 ajungem la o anumit\u0103 sum\u0103, modulo \\(P\\), unde \\(P\\) este un num\u0103r prim foarte mare. Acest modulo ne va da flexibilitatea necesar\u0103 pentru a evita coliziunile \u0219i situa\u021biile de tip false negative, c\u00e2nd ajungem s\u0103 spunem c\u0103 nu avem un r\u0103spuns c\u00e2nd de fapt \u00eel avem.</p> <p>Vom presupune c\u0103 suma maxim\u0103 este \\(N\\) \u0219i valoarea ad\u0103ugat\u0103/scoas\u0103 este \\(W\\).</p> <pre><code>for (int i = N; i &gt;= W; i--) {\n    dp[i] += dp[i - W];\n    if (dp[i] &gt;= P) {\n        dp[i] -= P;\n    }\n}\n</code></pre> <p>Pentru a scoate, vom face acela\u0219i lucru dar invers.</p> <pre><code>for (int i = W; i &lt;= N; i++) {\n    dp[i] -= dp[i - W];\n    if (dp[i] &lt; 0) {\n        dp[i] += P;\n    }\n}\n</code></pre>","tags":["optimizare","programare dinamica"]},{"location":"mediu/knapsack/#probleme-suplimentare","title":"Probleme suplimentare","text":"<ul> <li>AtCoder Knapsack I</li> <li>AtCoder Knapsack II</li> <li>CSES Money Sums</li> <li>CSES Coin Combinations I</li> <li>CSES Coin Combinations II</li> <li>ONI 2015 Procente</li> <li>CSES Minimizing Coins</li> <li>RoAlgo Contest 2 strehaia</li> <li>Infoarena Triunghi</li> <li>IIOT 2021 Castle</li> <li>ONI 2015 Procente</li> <li>RCPC 2023 Dragons</li> <li>ONI 2017 Baraj Seniori Cli</li> <li>USACO Gold Fruit   Feast</li> <li>Subset Sum Queries</li> <li>Probleme cu rucsac de pe Kilonova</li> <li>Probleme cu rucsac de pe   Infoarena</li> </ul>","tags":["optimizare","programare dinamica"]},{"location":"mediu/knapsack/#lectura-suplimentara","title":"Lectur\u0103 suplimentar\u0103","text":"<ul> <li>Problema rucsacului - Infoarena</li> <li>Problema rucsacului - CPPI   Sync</li> <li>Knapsack DP - USACO Guide</li> </ul>","tags":["optimizare","programare dinamica"]},{"location":"mediu/lcs/","title":"Sub\u0219ir comun maximal","text":"<p>Problema sub\u0219irului comun maximal este o alt\u0103 problem\u0103 foarte important\u0103 care are aplica\u021bii \u00een domenii diverse precum genetic\u0103, bioinformatic\u0103 \u0219i procesarea limbajelor naturale, iar algoritmul pe care \u00eel vom prezenta va putea fi folosit cu mici modific\u0103ri \u00een foarte multe dinamici bazate pe matrici. Distan\u021be precum Distan\u021ba Levenshtein vor fi prezentate \u0219i ele aici, datorit\u0103 similarit\u0103\u021bii cu problema sub\u0219irului comun maximal.</p>","tags":["programare dinamica","siruri de caractere"]},{"location":"mediu/lcs/#subsirul-comun-maximal","title":"Sub\u0219irul comun maximal","text":"<p>Defini\u021bie</p> <p>Definim sub\u0219irul comun maximal a dou\u0103 \u0219iruri de caractere \\(a\\) \u0219i \\(b\\) ca fiind un sub\u0219ir \\(s\\) care are proprietatea c\u0103 pentru fiecare dintre \u0219irurile de caractere \\(a\\) \u0219i \\(b\\), \\(s\\) este un sub\u0219ir al acelui \u0219ir de caractere. De exemplu, sub\u0219irul comun maximal al \u0219irurilor <code>bcdaacd</code> si <code>acdbac</code> este <code>cdac</code>.</p> <p>Observa\u021bie</p> <p>Pot exista mai multe sub\u0219iruri comune maximale, de obicei ne intereseaz\u0103 lungimea sub\u0219irului comun maximal. Dac\u0103 vrem s\u0103 reconstituim sub\u0219irul comun maximal, a\u0219a cum proced\u0103m \u0219i la alte tipuri de dinamici, ne putem \u021bine o alt\u0103 stare \u00een care p\u0103str\u0103m originea r\u0103spunsului optim.</p> <p>Pentru a calcula sub\u0219irul comun maximal, vom avea o dinamic\u0103 pe dou\u0103 dimensiuni, folosind o abordare care va construi r\u0103spunsul din aproape \u00een aproape, pozi\u021bie cu pozi\u021bie.</p> <p>Astfel, vom avea \\(dp[i][j]\\) drept lungimea maxim\u0103 a unui sub\u0219ir comun care poate fi format din primele \\(i\\) caractere ale lui \\(a\\) \u0219i primele \\(j\\) caractere ale \u0219irului \\(b\\).</p> <p>Pentru a calcula aceast\u0103 recuren\u021b\u0103, avem dou\u0103 cazuri principale:</p> <ul> <li>Fie ad\u0103ug\u0103m un caracter din unul din cele dou\u0103 \u0219iruri, prelu\u00e2nd r\u0103spunsurile   din \\((i-1, j)\\) \u0219i \\((i, j-1)\\)</li> <li>Fie ad\u0103ug\u0103m c\u00e2te un caracter din ambele \u0219iruri, prelu\u00e2nd r\u0103spunsul din \\((i-1,   j-1)\\) \u0219i ad\u0103ug\u00e2nd 1 dac\u0103 caracterele sunt egale.</li> </ul> <p>Cu alte cuvinte,</p> \\[dp[i][j] = max(dp[i-1][j], dp[i][j-1], dp[i-1][j-1] + x)\\] <p>unde \\(x = 1\\) dac\u0103 \\(a_i = b_j\\) \u0219i \\(x = 0\\) \u00een caz contrar.</p> <p>Aceast\u0103 abordare va avea complexitatea \\(\\mathcal{O}(|a| \\cdot |b|)\\), unde \\(|a|\\) \u0219i \\(|b|\\) sunt lungimile celor dou\u0103 \u0219iruri de caractere. Aici pute\u021bi g\u0103si o implementare, care rezolv\u0103 problema similara de pe atcoder</p> <pre><code>#include &lt;cstring&gt;\n#include &lt;iostream&gt;\nusing namespace std;\n\nint n, m, dp[3025][3025], fw[3025][3025];\n\nchar c[3025], c2[3025];\n\nvoid solve(int n, int m) {\n    if (n == 0 || m == 0) {\n        return;\n    }\n    if (fw[n][m] == 1) {\n        solve(n - 1, m);\n    }\n    if (fw[n][m] == 2) {\n        solve(n, m - 1);\n    }\n    if (fw[n][m] == 3) {\n        solve(n - 1, m - 1);\n        cout &lt;&lt; c[n - 1];\n    }\n}\nint main() {\n    cin &gt;&gt; c;\n    cin &gt;&gt; c2;\n    n = strlen(c);\n    m = strlen(c2);\n\n    for (int i = 1; i &lt;= n; i++) {\n        for (int j = 1; j &lt;= m; j++) {\n            dp[i][j] = max(\n                dp[i - 1][j],\n                max(dp[i][j - 1], dp[i - 1][j - 1] + (c[i - 1] == c2[j - 1])));\n            if (dp[i - 1][j] == dp[i][j]) {\n                fw[i][j] = 1;\n            } else {\n                if (dp[i][j - 1] == dp[i][j]) {\n                    fw[i][j] = 2;\n                } else {\n                    fw[i][j] = 3;\n                }\n            }\n        }\n    }\n\n    solve(n, m);\n    return 0;\n}\n</code></pre>","tags":["programare dinamica","siruri de caractere"]},{"location":"mediu/lcs/#distanta-levenshtein","title":"Distan\u021ba Levenshtein","text":"<p>\u00cen mod similar cu sub\u0219irul comun maximal, putem defini \u0219i distan\u021ba Levenshtein ca fiind distan\u021ba de editare \u00eentre dou\u0103 \u0219iruri, dac\u0103 putem ad\u0103uga, \u0219terge sau modifica caractere. Recuren\u021ba va fi foarte similar\u0103 cu cea de la problema precedent\u0103, singura diferen\u021b\u0103 este aceea c\u0103 opera\u021biile se schimb\u0103 din perspectiva valorii ad\u0103ugate. Aici este solu\u021bia la problema Edit Distance de pe CSES</p> <pre><code>#include &lt;iostream&gt;\n#include &lt;string&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\nconst int mod = 1000000007;\n\nint main() {\n    string a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    int n = a.size();\n    int m = b.size();\n\n    vector&lt;vector&lt;int&gt; &gt; dp(n + 1, vector&lt;int&gt;(m + 1, (1 &lt;&lt; 20)));\n    dp[0][0] = 0;\n\n    for (int i = 0; i &lt;= n; i++) {\n        for (int j = 0; j &lt;= m; j++) {\n            if (i != 0) {\n                dp[i][j] = min(dp[i][j], dp[i - 1][j] + 1);\n            }\n            if (j != 0) {\n                dp[i][j] = min(dp[i][j], dp[i][j - 1] + 1);\n            }\n            if (i != 0 &amp;&amp; j != 0) {\n                dp[i][j] =\n                    min(dp[i][j], dp[i - 1][j - 1] + (a[i - 1] != b[j - 1]));\n            }\n        }\n    }\n\n    cout &lt;&lt; dp[n][m] &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["programare dinamica","siruri de caractere"]},{"location":"mediu/lcs/#optional-algoritmul-hunt-szymanski","title":"Op\u021bional - Algoritmul Hunt-Szymanski","text":"<p>Un algoritm interesant care merit\u0103 \u0219tiut pentru aflarea lungimii celui mai lung sub\u0219ir comun este algoritmul Hunt-Szymanski, un algoritm care se bazeaz\u0103 pe ideea c\u0103 dac\u0103 dou\u0103 \u0219iruri de caractere nu au un sub\u0219ir comun lung, foarte multe dintre compara\u021biile necesare sunt irelevante.</p> <p>Principiul din spatele algoritmului este acela c\u0103 ne intereseaz\u0103 doar perechile de pozi\u021bii \\((i, j)\\) cu proprietatea c\u0103 \\(a[i]\\) \u0219i \\(b[j]\\) sunt egale, iar pentru a folosi acest lucru \u00een avantajul nostru, vom precalcula pentru unul din \u0219irurile de caractere pozi\u021biile \u00een care apare fiecare liter\u0103, iar mai apoi, pentru fiecare pozi\u021bie \\(i\\) din \u0219irul \\(a\\), vom itera pozi\u021biile \u00een care apare litera curent\u0103 \u00een ordine descresc\u0103toare, scopul nostru fiind acela de a \u021bine un vector dp cu proprietatea c\u0103 \\(dp[i]\\) este cea mai mic\u0103 pozi\u021bie din \u0219irul \\(b\\) astfel \u00eenc\u00e2t am putut ajunge s\u0103 avem un sub\u0219ir comun maximal de lungime \\(i\\).</p> <p>Complexitatea algoritmului va fi \\(\\mathcal{O}((n + m) \\log n)\\), unde \\(m\\) este num\u0103rul de perechi de caractere egale. De\u0219i cel mai prost caz este \\(\\mathcal{O}(n^2 \\log n)\\), \u00een practic\u0103, algoritmul va fi mult mai eficient. Aici pute\u021bi g\u0103si o implementare a acestui algoritm, inspirata din acest cod.</p> <p>Practic, se poate spune c\u0103 acest algoritm este similar cu algoritmul pentru aflarea celui mai lung sub\u0219ir cresc\u0103tor pe perechi de pozi\u021bii.</p> <pre><code>int lcs(const std::string &amp;A, const std::string &amp;B) {\n    std::vector&lt;std::vector&lt;int&gt;&gt; adj(256);\n    int n = A.size(), m = B.size();\n\n    for (int i = 0; i &lt; m; ++i) {\n        adj[B[i]].push_back(i);\n    }\n\n    std::vector&lt;int&gt; ar;\n    ar.push_back(-1);\n\n    for (int i = 0; i &lt; n; ++i) {\n        for (int j = adj[A[i]].size() - 1; j &gt;= 0; --j) {\n            int x = adj[A[i]][j];\n            if (x &gt; ar.back()) {\n                ar.push_back(x);\n            } else {\n                *std::lower_bound(ar.begin(), ar.end(), x) = x;\n            }\n        }\n    }\n    return ar.size() - 1;\n}\n</code></pre>","tags":["programare dinamica","siruri de caractere"]},{"location":"mediu/lcs/#probleme-suplimentare","title":"Probleme suplimentare","text":"<ul> <li>cmlsc infoarena</li> <li>EJOI 2020 Exam</li> <li>Palindromic Doubles</li> </ul>","tags":["programare dinamica","siruri de caractere"]},{"location":"mediu/lcs/#lectura-suplimentara","title":"Lectur\u0103 suplimentar\u0103","text":"<ul> <li>Probleme clasice de programare dinamica - CPPI   Sync</li> <li>Programare dinamica -   Algopedia</li> <li>Longest Common Subsequence - USACO   Guide</li> <li>Hunt-Szymanski Algorithm Explained (LCS but optimized for special cases) -   Codeforces</li> <li>Paper despre   Hunt-Szymanski</li> </ul>","tags":["programare dinamica","siruri de caractere"]},{"location":"mediu/lee/","title":"Algoritmul lui Lee. Flood Fill","text":"","tags":["structuri de date","Coad\u0103","Lee","Fill","Stiva","BFS","DFS"]},{"location":"mediu/lee/#introducere","title":"Introducere","text":"<p>S\u0103 presupunem c\u0103 avem de-a face cu un labirint cu diverse tipuri de obstacole \u0219i spa\u021bii libere, iar obiectivul nostru este acela de a afla dac\u0103 putem ajunge de la punctul \\(A\\) la punctul \\(B\\), unde punctele \\(A\\) \u0219i \\(B\\) sunt date \u00een input. \u00cen alte varia\u021bii ale acestui tip de probleme, ni se poate cere \u0219i aflarea distan\u021bei minime \u00eentre dou\u0103 sau mai multe puncte.</p> <p>Resurs\u0103 foarte util\u0103</p> <p>Recomand\u0103m softul f\u0103cut de cei de la Colegiul Na\u021bional \"Emil Racovi\u021b\u0103\" Ia\u0219i, at\u00e2t pentru valoarea istoric\u0103, c\u00e2t \u0219i pentru claritatea explica\u021biilor grafice, soft educa\u021bional pe care \u00eel g\u0103si\u021bi aici.</p> <p>Pe parcurs, ve\u021bi observa c\u0103 indiferent de modul \u00een care ve\u021bi rezolva aceste clase de probleme, multe dintre principiile pe care le folosi\u021bi vor r\u0103m\u00e2ne acelea\u0219i, \u00een special atunci c\u00e2nd vine vorba de implementarea acestor tipuri de parcurgeri.</p> <p>Cele dou\u0103 moduri principale de a rezolva aceast\u0103 categorie de probleme sunt fie folosind algoritmi de tip flood fill recursiv (numit \u0219i fill \u00een jargonul rom\u00e2nesc), fie folosind algoritmi iterativi de parcurgere ai labirintului (numit algoritmul lui Lee \u00een literatura de specialitate rom\u00e2neasc\u0103).</p> <p>\u00cen cele ce urmeaz\u0103, voi prezenta at\u00e2t flood fill-ul recursiv, c\u00e2t \u0219i algoritmul lui Lee.</p>","tags":["structuri de date","Coad\u0103","Lee","Fill","Stiva","BFS","DFS"]},{"location":"mediu/lee/#fundamente","title":"Fundamente","text":"<p>P\u00e2n\u0103 s\u0103 ajungem s\u0103 discut\u0103m implementarea algoritmilor \u00een sine, vom prezenta c\u00e2\u021biva pa\u0219i importan\u021bi pe care trebuie s\u0103-i facem p\u00e2n\u0103 ajungem s\u0103 implement\u0103m complet ace\u0219ti doi algoritmi, precum \u0219i cuno\u0219tin\u021bele necesare.</p>","tags":["structuri de date","Coad\u0103","Lee","Fill","Stiva","BFS","DFS"]},{"location":"mediu/lee/#cunostinte-necesare","title":"Cuno\u0219tin\u021be necesare","text":"<p>\u00cen ceea ce prive\u0219te metodele iterative, folosite la algoritmul lui Lee, cunoa\u0219terea cozii este obligatorie, detalii despre modul de implementare, precum \u0219i varia\u021biile acestei structuri de date pot fi g\u0103site aici.</p> <p>\u00cen ceea ce prive\u0219te metodele recursive, folosite la flood fill, cunoa\u0219terea stivei \u0219i a recursivit\u0103\u021bii este obligatorie, detalii despre modul de folosire al stivei pot fi g\u0103site aici, iar informa\u021bii despre implementarea func\u021biilor recursive se g\u0103sesc aici.</p> <p>O alt\u0103 no\u021biune care se recomand\u0103 a fi cunoscut\u0103 \u00een prealabil este tipul de date pair sau o alternativ\u0103 a acestuia (tuple sau dac\u0103 prefera\u021bi implement\u0103rile \u00een stilul C, tipul de date struct, care permite \u0219i alte modific\u0103ri dup\u0103 caz).</p>","tags":["structuri de date","Coad\u0103","Lee","Fill","Stiva","BFS","DFS"]},{"location":"mediu/lee/#vectorii-de-directie","title":"Vectorii de direc\u021bie","text":"<p>\u00cen majoritatea problemelor de acest tip, personajele noastre se vor deplasa folosind mut\u0103ri succesive pe una dintre cele 4 sau 8 direc\u021bii care ne sunt permise de problem\u0103 (de regul\u0103, direc\u021biile cardinale - nord, est, sud, vest \u0219i eventual direc\u021biile diagonale - nord-est, sud-est, sud-vest, nord-vest).</p> <p>Pentru a stoca \u00een memorie aceste dimensiuni cu u\u0219urin\u021b\u0103, vom \u021bine \u00een memorie toate direc\u021biile posibile, iar pentru a face scrierea lor u\u0219oar\u0103, se recomand\u0103 scrierea lor \u00een sensul acelor de ceasornic. Acestea se pot scrie toate la \u00eenceput, noi put\u00e2nd folosi fie arrays din C, fie vectori.</p> <p>Mai jos g\u0103si\u021bi modul de declarare a acestor vectori de direc\u021bie atunci c\u00e2nd putem merge doar \u00een direc\u021bia celor 4 vecini cardinali.</p> <pre><code>int ox[] = {-1, 0, 1, 0};\nint oy[] = {0, 1, 0, -1};\n</code></pre> <pre><code>vector&lt;int&gt; ox = {-1, 0, 1, 0};\nvector&lt;int&gt; oy = {0, 1, 0, -1};\n</code></pre> <p>Pentru a extinde acum la 8 vecini, vom insera direc\u021biile intermediare \u00een ordinea acelor de ceasornic, mai jos g\u0103si\u021bi modul de declarare a acestor vectori de direc\u021bie pentru toate direc\u021biile, \u00eencep\u00e2nd de la N \u0219i termin\u00e2nd cu NV, \u00een sens orar.</p> <pre><code>int ox[] = {-1, -1, 0, 1, 1, 1, 0, -1};\nint oy[] = {0, 1, 1, 1, 0, -1, -1, -1};\n</code></pre> <pre><code>vector&lt;int&gt; ox = {-1, -1, 0, 1, 1, 1, 0, -1};\nvector&lt;int&gt; oy = {0, 1, 1, 1, 0, -1, -1, -1};\n</code></pre> <p>O alternativ\u0103 folosit\u0103 \u00een multe coduri const\u0103 \u00een enumerarea vecinilor \u00een ordine cresc\u0103toare a schimb\u0103rii care se produce pe linie, mai \u00eent\u00e2i prioritiz\u00e2nd vecinii nordici, apoi cei centrali \u0219i apoi cei sudici.</p> <pre><code>int ox[] = {-1, -1, -1, 0, 0, 1, 1, 1};\nint oy[] = {-1, 0, 1, -1, 1, -1, 0, 1};\n</code></pre> <pre><code>vector&lt;int&gt; ox = {-1, -1, -1, 0, 0, 1, 1, 1};\nvector&lt;int&gt; oy = {-1, 0, 1, -1, 1, -1, 0, 1};\n</code></pre> <p>Indiferent de modul \u00een care \u00eei declara\u021bi, dac\u0103 sunte\u021bi la un punct \\((x, y)\\) \u0219i vre\u021bi s\u0103 verifica\u021bi to\u021bi vecinii, tot ce trebuie s\u0103 face\u021bi este s\u0103 parcurge\u021bi vectorii de direc\u021bie \u0219i s\u0103 identifica\u021bi valorile vecinilor.</p> <pre><code>for (int i = 0; i &lt; neighbors; i++) {\n    int nxt_x = x + ox[i];\n    int nxt_y = y + oy[i];\n    // aici urmeaza verificarile ulterioare\n}\n</code></pre>","tags":["structuri de date","Coad\u0103","Lee","Fill","Stiva","BFS","DFS"]},{"location":"mediu/lee/#evitarea-accesarii-unor-patrate-din-afara-matricii","title":"Evitarea acces\u0103rii unor p\u0103trate din afara matricii","text":"<p>Pentru a ne asigura c\u0103 de-a lungul parcurgerilor, noi nu vom ie\u0219i din matrice, avem dou\u0103 variante la fel de bune \u0219i populare.</p> <p>O prim\u0103 variant\u0103 const\u0103 \u00een a ad\u0103uga ziduri imaginare pe marginile matricii, procedeu cunoscut \u0219i sub denumirea de bordare. Vom presupune c\u0103 matricea se nume\u0219te mat, iar tabloul are \\(n\\) linii \u0219i \\(m\\) coloane.</p> <pre><code>for (int i = 0; i &lt;= m + 1; i++) {\n    mat[0][i] = mat[n + 1][i] = -1;  // bordarea liniilor 0 si n+1\n}\nfor (int i = 0; i &lt;= n + 1; i++) {\n    mat[i][0] = mat[i][m + 1] = -1;  // bordarea coloanelor 0 si m+1\n}\n</code></pre> <p>O a doua variant\u0103 const\u0103 \u00een verificarea atent\u0103 a fiec\u0103rei st\u0103ri atunci c\u00e2nd trecem prin ea, astfel \u00eenc\u00e2t s\u0103 ne asigur\u0103m c\u0103 nu ie\u0219im din matrice, lucru ce se \u00eent\u00e2mpl\u0103 c\u00e2nd trecem prin p\u0103trate noi \u00een matrice.</p> <pre><code>for (int i = 0; i &lt; neighbors; i++) {\n    int nxt_x = x + ox[i];\n    int nxt_y = y + oy[i];\n    if (nxt_x &gt;= 1 &amp;&amp; nxt_x &lt;= n &amp;&amp; nxt_y &gt;= 1 &amp;&amp; nxt_y &lt;= m) {\n        // aici vin verificarile ulterioare\n    }\n}\n</code></pre> <p>Pe de o parte, un avantaj al bord\u0103rii este acela c\u0103 nu avem nevoie de o verificare relativ complicat\u0103 pentru p\u0103tratele din matrice. Pe de alt\u0103 parte, verificarea f\u0103r\u0103 bordare nu are nevoie de memorie suplimentar\u0103. Se poate observa faptul c\u0103 ambele metode au avantajele lor, nefiind una din ele superioar\u0103 celeilalte.</p>","tags":["structuri de date","Coad\u0103","Lee","Fill","Stiva","BFS","DFS"]},{"location":"mediu/lee/#problema-introductiva-counting-rooms","title":"Problem\u0103 introductiv\u0103 - Counting Rooms","text":"<p>Pentru a exemplifica aceste no\u021biuni \u0219i a prezenta algoritmii, precum \u0219i diferen\u021bele dintre ei, vom pleca de la o problem\u0103 simpl\u0103, \u0219i anume aflarea num\u0103rului de camere dintr-o \u00eenc\u0103pere.</p>","tags":["structuri de date","Coad\u0103","Lee","Fill","Stiva","BFS","DFS"]},{"location":"mediu/lee/#algoritmul-fill-flood-fill-recursiv","title":"Algoritmul fill (flood fill recursiv)","text":"<p>Pentru a implementa algoritmul flood fill, va trebui s\u0103 plec\u0103m pe r\u00e2nd din fiecare punct nevizitat, iar la un pas al acestui algoritm, vom verifica to\u021bi vecinii folosind vectorul de direc\u021bie creat anterior, iar atunci c\u00e2nd d\u0103m de un asemenea punct, vom apela func\u021bia fill pentru a continua vizitarea punctelor. Trebuie avut grij\u0103 s\u0103 marc\u0103m punctele drept vizitate, pentru a evita ciclarea la infinit.</p> <p>Observa\u021bie</p> <p>Se poate observa c\u0103 acest algoritm este un caz particular al parcurgerii DFS de pe grafuri, ambele fiind recursive \u0219i oper\u00e2nd \u00een acela\u0219i mod.</p> <p>Mai jos, pute\u021bi g\u0103si o implementare recursiv\u0103, \u00een stilul algoritmului flood fill, care rezolv\u0103 problema Counting Rooms, prezentat\u0103 mai sus.</p> <pre><code>#include &lt;fstream&gt;\n#include &lt;iostream&gt;\n#include &lt;queue&gt;\n#include &lt;vector&gt;\n\nusing namespace std;\n\nvector&lt;int&gt; ox = {-1, 0, 1, 0};\nvector&lt;int&gt; oy = {0, 1, 0, -1};\n\nvoid fill(int n, int m, int X, int Y, vector&lt;vector&lt;char&gt; &gt; &amp;grid,\n          vector&lt;vector&lt;int&gt; &gt; &amp;visited) {\n    visited[X][Y] = 1;\n    for (int i = 0; i &lt; 4; i++) {\n        int nxt_x = X + ox[i];\n        int nxt_y = Y + oy[i];\n\n        if (nxt_x &gt;= 1 &amp;&amp; nxt_x &lt;= n &amp;&amp; nxt_y &gt;= 1 &amp;&amp; nxt_y &lt;= m\n            &amp;&amp; visited[nxt_x][nxt_y] == 0 &amp;&amp; grid[nxt_x][nxt_y] == '.') {\n            fill(n, m, nxt_x, nxt_y, grid, visited);\n        }\n    }\n}\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n\n    int n, m;\n    cin &gt;&gt; n &gt;&gt; m;\n\n    vector&lt;vector&lt;char&gt; &gt; grid(n + 1, vector&lt;char&gt;(m + 1));\n    vector&lt;vector&lt;int&gt; &gt; visited(n + 1, vector&lt;int&gt;(m + 1));\n\n    for (int i = 1; i &lt;= n; i++) {\n        for (int j = 1; j &lt;= m; j++) {\n            cin &gt;&gt; grid[i][j];\n        }\n    }\n\n    int ans = 0;\n\n    for (int i = 1; i &lt;= n; i++) {\n        for (int j = 1; j &lt;= m; j++) {\n            if (grid[i][j] == '.' &amp;&amp; visited[i][j] == 0) {\n                fill(n, m, i, j, grid, visited);\n                ans++;\n            }\n        }\n    }\n\n    cout &lt;&lt; ans &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["structuri de date","Coad\u0103","Lee","Fill","Stiva","BFS","DFS"]},{"location":"mediu/lee/#algoritmul-lui-lee-flood-fill-iterativ","title":"Algoritmul lui Lee (flood fill iterativ)","text":"<p>Pentru a implementa algoritmul lui Lee, va trebui s\u0103 plec\u0103m pe r\u00e2nd din fiecare punct nevizitat, iar la un pas al acestui algoritm, vom verifica to\u021bi vecinii folosind vectorul de direc\u021bie creat anterior, iar atunci c\u00e2nd d\u0103m de un asemenea punct, vom ad\u0103uga vecinul \u00een coad\u0103, la fiecare pas prelucr\u00e2nd primul punct care \u00eenc\u0103 se afl\u0103 \u00een coad\u0103. Trebuie avut grij\u0103 s\u0103 marc\u0103m punctele drept vizitate, pentru a evita ciclarea la infinit.</p> <p>Observa\u021bie</p> <p>Se poate observa c\u0103 acest algoritm este un caz particular al parcurgerii BFS de pe grafuri, ambele fiind iterative \u0219i oper\u00e2nd \u00een acela\u0219i mod, folosind o coad\u0103.</p> <p>Mai jos, pute\u021bi g\u0103si o implementare bazat\u0103 pe o coad\u0103, \u00een stilul algoritmului lui Lee, care rezolv\u0103 problema Counting Rooms, prezentat\u0103 mai sus.</p> <p>Observa\u021bie important\u0103</p> <p>De\u0219i \u00een majoritatea cazurilor putem folosi fie metoda fill, fie metoda iterativ\u0103, atunci c\u00e2nd avem nevoie s\u0103 afl\u0103m distan\u021ba dintre dou\u0103 sau mai multe puncte, singura metod\u0103 optim\u0103 este cea iterativ\u0103, bazat\u0103 pe coad\u0103, deoarece \u00een cazul fill, depindem de modul \u00een care ajungem s\u0103 apel\u0103m vecinii recursiv, ceea ce reprezint\u0103 o strategie care va duce la solu\u021bii ineficiente din punct de vedere al timpului \u0219i memoriei. Acest argument va fi reluat \u0219i atunci c\u00e2nd prezent\u0103m DFS \u0219i BFS la grafuri.</p> <pre><code>#include &lt;fstream&gt;\n#include &lt;iostream&gt;\n#include &lt;queue&gt;\n#include &lt;vector&gt;\n\nusing namespace std;\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n\n    int n, m;\n    cin &gt;&gt; n &gt;&gt; m;\n\n    vector&lt;vector&lt;char&gt; &gt; grid(n + 1, vector&lt;char&gt;(m + 1));\n    vector&lt;vector&lt;int&gt; &gt; visited(n + 1, vector&lt;int&gt;(m + 1));\n\n    for (int i = 1; i &lt;= n; i++) {\n        for (int j = 1; j &lt;= m; j++) {\n            cin &gt;&gt; grid[i][j];\n        }\n    }\n\n    int ans = 0;\n    vector&lt;int&gt; ox = {-1, 0, 1, 0};\n    vector&lt;int&gt; oy = {0, 1, 0, -1};\n\n    for (int i = 1; i &lt;= n; i++) {\n        for (int j = 1; j &lt;= m; j++) {\n            if (grid[i][j] == '.' &amp;&amp; visited[i][j] == 0) {\n                queue&lt;pair&lt;int, int&gt; &gt; q;\n\n                q.push({i, j});\n                visited[i][j] = 1;\n                ans++;\n\n                while (!q.empty()) {\n                    pair&lt;int, int&gt; node = q.front();\n                    q.pop();\n\n                    for (int i = 0; i &lt; 4; i++) {\n                        int nxt_x = node.first + ox[i];\n                        int nxt_y = node.second + oy[i];\n\n                        if (nxt_x &gt;= 1 &amp;&amp; nxt_x &lt;= n &amp;&amp; nxt_y &gt;= 1 &amp;&amp; nxt_y &lt;= m\n                            &amp;&amp; visited[nxt_x][nxt_y] == 0\n                            &amp;&amp; grid[nxt_x][nxt_y] == '.') {\n                            visited[nxt_x][nxt_y] = 1;\n                            q.push({nxt_x, nxt_y});\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    cout &lt;&lt; ans &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["structuri de date","Coad\u0103","Lee","Fill","Stiva","BFS","DFS"]},{"location":"mediu/lee/#problema-alee-oji-2007","title":"Problema Alee OJI 2007","text":"<p>Probabil una din cele mai cunoscute probleme rom\u00e2ne\u0219ti care folose\u0219te algoritmul lui Lee pentru rezolvarea acesteia, aceast\u0103 problem\u0103 necesit\u0103 implementarea algoritmului prezentat anterior pentru aflarea distan\u021bei de la origine la punctul ini\u021bial la cel final.</p> <pre><code>#include &lt;bits/stdc++.h&gt;\n\nusing namespace std;\n\nint ox[4] = {0, 1, 0, -1};\nint oy[4] = {-1, 0, 1, 0};\n\nbool isValid(int x, int y, int n, int m, vector&lt;vector&lt;int&gt; &gt; &amp;mat) {\n    return x &gt; 0 &amp;&amp; y &gt; 0 &amp;&amp; x &lt;= n &amp;&amp; y &lt;= n &amp;&amp; mat[x][y] == 0;\n}\n\nint main() {\n    ifstream cin(\"alee.in\");\n    ofstream cout(\"alee.out\");\n\n    int x, y, n, m, final_x, final_y;\n    cin &gt;&gt; n &gt;&gt; m;\n\n    vector&lt;vector&lt;int&gt; &gt; mat(n + 1, vector&lt;int&gt;(n + 1));\n    for (short i = 0; i &lt; m; i++) {\n        cin &gt;&gt; x &gt;&gt; y;\n        mat[x][y] = -1;\n    }\n\n    cin &gt;&gt; final_x &gt;&gt; final_y;\n    mat[final_x][final_y] = 1;\n\n    queue&lt;pair&lt;int, int&gt; &gt; q;\n\n    q.push({final_x, final_y});\n    cin &gt;&gt; final_x &gt;&gt; final_y;\n\n    while (!q.empty()) {\n        pair&lt;int, int&gt; temp = q.front();\n        q.pop();\n\n        for (int i = 0; i &lt; 4; i++) {\n            int new_x = temp.first + ox[i];\n            int new_y = temp.second + oy[i];\n            if (isValid(new_x, new_y, n, m, mat)) {\n                mat[new_x][new_y] = mat[temp.first][temp.second] + 1;\n                q.push({new_x, new_y});\n            }\n        }\n    }\n\n    cout &lt;&lt; mat[final_x][final_y] &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["structuri de date","Coad\u0103","Lee","Fill","Stiva","BFS","DFS"]},{"location":"mediu/lee/#problema-labirint-oji-2021","title":"Problema Labirint OJI 2021","text":"<p>Pentru a rezolva aceast\u0103 problem\u0103, putem \u00eencepe o parcurgere din punctele \\((1, 1)\\) \u0219i \\((n, m)\\), iar pentru a verifica dac\u0103 apar \u00eembun\u0103t\u0103\u021biri, trebuie doar s\u0103 verific\u0103m cu aten\u021bie perechile de distan\u021be noi ce apar, acesta fiind motivul pentru care avem nevoie de dou\u0103 parcurgeri, \u00een loc de una.</p> <pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n\nint n, m, q;\n\nbool ok[1000002];\nint mx[1000002];\n\nchar mat[1002][1002];\nint dist[2][1002][1002];\n\nbool viz[1002][1002];\n\nint ox[] = {-1, 0, 1, 0};\nint oy[] = {0, 1, 0, -1};\n\nbool check(int x, int y) {\n    return ((x &gt;= 1) &amp;&amp; (x &lt;= n) &amp;&amp; (y &gt;= 1) &amp;&amp; (y &lt;= m) &amp;&amp; (viz[x][y] == 0));\n}\nvoid lee(int drum, int x, int y) {\n    memset(viz, 0, sizeof(viz));\n    deque&lt;pair&lt;int, int&gt; &gt; d;\n    d.push_back({x, y});\n    viz[x][y] = 1;\n    for (int i = 1; i &lt;= n; ++i) {\n        for (int j = 1; j &lt;= m; ++j) {\n            dist[drum][i][j] = -1;\n        }\n    }\n    dist[drum][x][y] = 1;\n    while (!d.empty()) {\n        pair&lt;int, int&gt; nod = d[0];\n        d.pop_front();\n        for (int i = 0; i &lt;= 3; ++i) {\n            int nxt_x = ox[i] + nod.first;\n            int nxt_y = oy[i] + nod.second;\n            if (check(nxt_x, nxt_y) &amp;&amp; dist[drum][nxt_x][nxt_y] == -1) {\n                dist[drum][nxt_x][nxt_y] =\n                    dist[drum][nod.first][nod.second] + 1;\n                if (mat[nxt_x][nxt_y] == '0') {\n                    viz[nxt_x][nxt_y] = 1;\n                    d.push_back({nxt_x, nxt_y});\n                }\n            }\n        }\n    }\n}\n\nchar ans[1002][1002];\n\nint main() {\n    ifstream cin(\"labirint.in\");\n    ofstream cout(\"labirint.out\");\n\n    cin &gt;&gt; n &gt;&gt; m;\n    for (int i = 1; i &lt;= n; ++i) {\n        cin &gt;&gt; (mat[i] + 1);\n    }\n\n    lee(0, 1, 1);\n    lee(1, n, m);\n\n    for (int i = 1; i &lt;= n; ++i) {\n        for (int j = 1; j &lt;= m; ++j) {\n            if (mat[i][j] == '1' &amp;&amp; dist[0][i][j] != -1\n                &amp;&amp; dist[1][i][j] != -1) {\n                if (dist[0][i][j] + dist[1][i][j] - 1 &lt; dist[1][1][1]) {\n                    ans[i][j] = '1';\n                } else {\n                    ans[i][j] = '0';\n                }\n            } else {\n                ans[i][j] = '0';\n            }\n        }\n    }\n\n    for (int i = 1; i &lt;= n; ++i) {\n        cout &lt;&lt; (ans[i] + 1) &lt;&lt; '\\n';\n    }\n    return 0;\n}\n</code></pre>","tags":["structuri de date","Coad\u0103","Lee","Fill","Stiva","BFS","DFS"]},{"location":"mediu/lee/#lee-cu-mai-multe-origini","title":"Lee cu mai multe origini","text":"<p>\u00cen anumite situa\u021bii, suntem nevoi\u021bi s\u0103 simul\u0103m o varia\u021bie a algoritmului lui Lee \u00een care avem de-a face cu mai multe puncte de start. \u00cen acest caz, deoarece de cele mai multe ori este prea \u00eencet s\u0103 rul\u0103m algoritmul pentru fiecare punct de start, putem pur \u0219i simplu s\u0103 ad\u0103ug\u0103m \u00een coad\u0103 toate originile \u0219i s\u0103 rul\u0103m acela\u0219i algoritm, singura diferen\u021b\u0103 fiind atunci c\u00e2nd vrem s\u0103 afl\u0103m originea fiec\u0103rui drum, deoarece trebuie s\u0103 fim aten\u021bi s\u0103 evit\u0103m situa\u021biile \u00een care nu putem construi drumul cum trebuie.</p>","tags":["structuri de date","Coad\u0103","Lee","Fill","Stiva","BFS","DFS"]},{"location":"mediu/lee/#problema-monsters-de-pe-cses","title":"Problema Monsters de pe CSES","text":"<p>\u00cen aceast\u0103 problem\u0103, trebuie s\u0103 g\u0103sim un drum pentru personajul nostru astfel \u00eenc\u00e2t s\u0103 poat\u0103 ajunge la una din marginile matricii f\u0103r\u0103 s\u0103 se intersecteze cu vreun monstru.</p> <p>Abordarea general\u0103 pentru aceste tipuri de probleme const\u0103 \u00een a afla mai \u00eent\u00e2i pentru mon\u0219tri, respectiv pentru personajul nostru distan\u021bele de la punctele lor de origine la celelalte p\u0103trate din matrice, iar \u00een cazul personajului, singurele p\u0103trate accesibile sunt cele la care va ajunge \u00eenaintea oric\u0103rui monstru, deoarece se \u0219tie c\u0103 mon\u0219trii pot colabora pentru a opri rivalul lor. A\u0219a cum se va observa \u00een implementarea de mai jos, to\u021bi mon\u0219trii sunt ad\u0103uga\u021bi \u00een coad\u0103 la \u00eenceputul travers\u0103rii.</p> <p>Un alt element important \u00een aceast\u0103 problem\u0103 const\u0103 \u00een reconstruirea solu\u021biei, procedeul fiind similar cu cel prezentat la problema anterioar\u0103.</p> <p>Mai jos g\u0103si\u021bi implementarea autorului pentru aceast\u0103 problem\u0103.</p> <pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n\nint ox[] = {0, 1, 0, -1};\nint oy[] = {1, 0, -1, 0};\n\nint main() {\n    int n, m;\n    cin &gt;&gt; n &gt;&gt; m;\n\n    char grid[n + 1][m + 1];\n    for (int i = 1; i &lt;= n; i++) {\n        cin &gt;&gt; (grid[i] + 1);\n    }\n\n    vector&lt;vector&lt;int&gt; &gt; distM(n + 1, vector&lt;int&gt;(m + 1, (1 &lt;&lt; 20))),\n        distA(n + 1, vector&lt;int&gt;(m + 1, (1 &lt;&lt; 20)));\n\n    queue&lt;pair&lt;int, int&gt; &gt; qM, qA;\n    for (int i = 1; i &lt;= n; i++) {\n        for (int j = 1; j &lt;= m; j++) {\n            if (grid[i][j] == 'A') {\n                distA[i][j] = 0;\n                qA.push({i, j});\n            }\n            if (grid[i][j] == 'M') {\n                distM[i][j] = 0;\n                qM.push({i, j});\n            }\n        }\n    }\n\n    while (!qM.empty()) {\n        pair&lt;int, int&gt; node = qM.front();\n        qM.pop();\n\n        for (int i = 0; i &lt; 4; i++) {\n            int nxtX = node.first + ox[i];\n            int nxtY = node.second + oy[i];\n            if (nxtX &gt;= 1 &amp;&amp; nxtX &lt;= n &amp;&amp; nxtY &gt;= 1 &amp;&amp; nxtY &lt;= m\n                &amp;&amp; grid[nxtX][nxtY] != '#') {\n                if (distM[nxtX][nxtY] &gt; distM[node.first][node.second] + 1) {\n                    distM[nxtX][nxtY] = distM[node.first][node.second] + 1;\n                    qM.push({nxtX, nxtY});\n                }\n            }\n        }\n    }\n\n    while (!qA.empty()) {\n        pair&lt;int, int&gt; node = qA.front();\n        qA.pop();\n\n        for (int i = 0; i &lt; 4; i++) {\n            int nxtX = node.first + ox[i];\n            int nxtY = node.second + oy[i];\n            if (nxtX &gt;= 1 &amp;&amp; nxtX &lt;= n &amp;&amp; nxtY &gt;= 1 &amp;&amp; nxtY &lt;= m\n                &amp;&amp; grid[nxtX][nxtY] != '#') {\n                if (distA[nxtX][nxtY] &gt; distA[node.first][node.second] + 1\n                    &amp;&amp; distA[node.first][node.second] + 1 &lt; distM[nxtX][nxtY]) {\n                    distA[nxtX][nxtY] = distA[node.first][node.second] + 1;\n                    qA.push({nxtX, nxtY});\n                }\n            }\n        }\n    }\n\n    for (int i = 1; i &lt;= n; i++) {\n        for (int j = 1; j &lt;= m; j++) {\n            if (distA[i][j] != (1 &lt;&lt; 20)\n                &amp;&amp; (i == 1 || i == n || j == 1 || j == m)) {\n                int x = i;\n                int y = j;\n                string s;\n                while (distA[x][y] != 0) {\n                    if (distA[x - 1][y] == distA[x][y] - 1) {\n                        s += 'D';\n                        x--;\n                        continue;\n                    }\n                    if (distA[x][y - 1] == distA[x][y] - 1) {\n                        s += 'R';\n                        y--;\n                        continue;\n                    }\n                    if (distA[x + 1][y] == distA[x][y] - 1) {\n                        s += 'U';\n                        x++;\n                        continue;\n                    }\n                    if (distA[x][y + 1] == distA[x][y] - 1) {\n                        s += 'L';\n                        y++;\n                        continue;\n                    }\n                }\n                cout &lt;&lt; \"YES\\n\";\n                cout &lt;&lt; s.size() &lt;&lt; '\\n';\n                reverse(s.begin(), s.end());\n                cout &lt;&lt; s &lt;&lt; '\\n';\n                return 0;\n            }\n        }\n    }\n\n    cout &lt;&lt; \"NO\\n\";\n    return 0;\n}\n</code></pre>","tags":["structuri de date","Coad\u0103","Lee","Fill","Stiva","BFS","DFS"]},{"location":"mediu/lee/#algoritmul-0-1-bfs","title":"Algoritmul 0-1 BFS","text":"<p>De\u0219i acest algoritm este folosit \u00een principal pentru problemele de drumuri minime pe grafuri, exist\u0103 exemple care implic\u0103 \u0219i probleme pe matrici, a\u0219a cum se precizeaz\u0103 \u00een articolul nostru despre drumuri minime.</p>","tags":["structuri de date","Coad\u0103","Lee","Fill","Stiva","BFS","DFS"]},{"location":"mediu/lee/#lee-cu-structuri-de-date","title":"Lee cu structuri de date","text":"<p>\u00cen unele cazuri, putem avea de-a face cu probleme \u00een care vizitarea unui p\u0103trat adiacent din matrice poate avea costuri diferite de 0 \u0219i 1, \u00een acest caz se impune folosirea unor structuri de date pentru a calcula aceste costuri minime, implementarea devenind foarte similar\u0103 cu cea pe care o ve\u021bi vedea atunci c\u00e2nd ve\u021bi \u00eenv\u0103\u021ba algoritmul lui Dijkstra, acesta fiind varianta sa pe matrice.</p> <p>La fel ca \u0219i la Dijkstra, cele mai populare structuri de date sunt setul \u0219i coada de priorit\u0103\u021bi, mai jos g\u0103sind implement\u0103ri folosind ambele structuri de date ce rezolv\u0103 problema lee2 de pe pbinfo.</p>","tags":["structuri de date","Coad\u0103","Lee","Fill","Stiva","BFS","DFS"]},{"location":"mediu/lee/#implementare-cu-set","title":"Implementare cu set","text":"<pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n\nint ox[] = {-1, 0, 1, 0};\nint oy[] = {0, 1, 0, -1};\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n\n    int x, y, z, n, t;\n    cin &gt;&gt; n &gt;&gt; x &gt;&gt; y &gt;&gt; z &gt;&gt; t;\n\n    vector&lt;vector&lt;int&gt; &gt; val(n + 1, vector&lt;int&gt;(n + 2, 0)),\n        dp(n + 1, vector&lt;int&gt;(n + 1, (1 &lt;&lt; 25)));\n\n    for (int i = 1; i &lt;= n; ++i) {\n        cin &gt;&gt; val[1][i];\n    }\n\n    for (int i = 2; i &lt;= n; ++i) {\n        for (int j = 1; j &lt;= n; ++j) {\n            val[i][j] = 1\n                      + (val[i - 1][j - 1] * x + val[i - 1][j] * y\n                         + val[i - 1][j + 1] * z)\n                            % t;\n        }\n    }\n\n    dp[1][1] = val[1][1];\n\n    set&lt;pair&lt;int, pair&lt;int, int&gt; &gt; &gt; s;\n    s.insert({\n        dp[1][1], {1, 1}\n    });\n\n    while (!s.empty()) {\n        pair&lt;int, pair&lt;int, int&gt; &gt; x = *s.begin();\n        s.erase(x);\n\n        pair&lt;int, int&gt; nod = x.second;\n\n        for (int i = 0; i &lt;= 3; ++i) {\n            int new_x = ox[i] + nod.first;\n            int new_y = oy[i] + nod.second;\n            if (new_x == 0 || new_y == 0 || new_x == n + 1 || new_y == n + 1) {\n                continue;\n            }\n            if (dp[nod.first][nod.second] + val[new_x][new_y]\n                &lt; dp[new_x][new_y]) {\n                dp[new_x][new_y] =\n                    dp[nod.first][nod.second] + val[new_x][new_y];\n                s.insert({\n                    dp[new_x][new_y], {new_x, new_y}\n                });\n            }\n        }\n    }\n\n    cout &lt;&lt; dp[n][n] &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["structuri de date","Coad\u0103","Lee","Fill","Stiva","BFS","DFS"]},{"location":"mediu/lee/#implementare-cu-priority-queue","title":"Implementare cu priority queue","text":"<p>Observa\u021bie</p> <p>Nodurile se introduc \u00een priority queue cu minus \u00een fa\u021b\u0103 deoarece vrem s\u0103 \u021binem elementele \u00een ordine cresc\u0103toare, iar implementarea standard a priority queue le \u021bine \u00een ordine descresc\u0103toare.</p> <pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n\nint ox[] = {-1, 0, 1, 0};\nint oy[] = {0, 1, 0, -1};\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n\n    int x, y, z, n, t;\n    cin &gt;&gt; n &gt;&gt; x &gt;&gt; y &gt;&gt; z &gt;&gt; t;\n\n    vector&lt;vector&lt;int&gt; &gt; val(n + 1, vector&lt;int&gt;(n + 2, 0)),\n        dp(n + 1, vector&lt;int&gt;(n + 1, (1 &lt;&lt; 25)));\n\n    for (int i = 1; i &lt;= n; ++i) {\n        cin &gt;&gt; val[1][i];\n    }\n\n    for (int i = 2; i &lt;= n; ++i) {\n        for (int j = 1; j &lt;= n; ++j) {\n            val[i][j] = 1\n                      + (val[i - 1][j - 1] * x + val[i - 1][j] * y\n                         + val[i - 1][j + 1] * z)\n                            % t;\n        }\n    }\n\n    dp[1][1] = val[1][1];\n\n    priority_queue&lt;pair&lt;int, pair&lt;int, int&gt; &gt; &gt; pq;\n    pq.push({\n        -dp[1][1], {1, 1}\n    });\n\n    while (!pq.empty()) {\n        pair&lt;int, pair&lt;int, int&gt; &gt; x = pq.top();\n        pq.pop();\n\n        pair&lt;int, int&gt; nod = x.second;\n\n        for (int i = 0; i &lt;= 3; ++i) {\n            int new_x = ox[i] + nod.first;\n            int new_y = oy[i] + nod.second;\n            if (new_x == 0 || new_y == 0 || new_x == n + 1 || new_y == n + 1) {\n                continue;\n            }\n            if (dp[nod.first][nod.second] + val[new_x][new_y]\n                &lt; dp[new_x][new_y]) {\n                dp[new_x][new_y] =\n                    dp[nod.first][nod.second] + val[new_x][new_y];\n                pq.push({\n                    -dp[new_x][new_y], {new_x, new_y}\n                });\n            }\n        }\n    }\n\n    cout &lt;&lt; dp[n][n] &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["structuri de date","Coad\u0103","Lee","Fill","Stiva","BFS","DFS"]},{"location":"mediu/lee/#concluzii","title":"Concluzii","text":"<p>Algoritmii de tip flood fill sunt unii din cei mai \u00eent\u00e2lni\u021bi algoritmi din aceast\u0103 sec\u021biune a structurilor de date liniare, ei reg\u0103sindu-se \u00een foarte multe tipuri de probleme, fiind una din cele mai populare tipuri de probleme de la olimpiadele de informatic\u0103 din Rom\u00e2nia \u0219i nu numai, ace\u0219tia fiind reg\u0103si\u021bi \u0219i \u00een USACO Silver \u0219i alte competi\u021bii similare.</p> <p>\u00cen multe situa\u021bii, datorit\u0103 popularit\u0103\u021bii acestei metode, problemele noi ce folosesc aceast\u0103 tehnic\u0103 combin\u0103 \u0219i al\u021bi algoritmi, precum c\u0103utarea binar\u0103, programarea dinamic\u0103 sau chiar combinatorica \u00een anumite exemple mai dificile.</p> <p>Pe l\u00e2ng\u0103 aplica\u021biile din problemele de algoritmic\u0103, ace\u0219tia se reg\u0103sesc \u0219i \u00een multe situa\u021bii practice, \u00een care trebuie estimat impactul unor poten\u021biale dezastre naturale sau chiar \u0219i \u00een editarea imaginilor \u0219i a altor forme grafice.</p>","tags":["structuri de date","Coad\u0103","Lee","Fill","Stiva","BFS","DFS"]},{"location":"mediu/lee/#probleme-suplimentare","title":"Probleme suplimentare","text":"<ul> <li>OJI 2004 rj</li> <li>OJI 2007 alee</li> <li>infoarena muzeu</li> <li>infoarena barbar</li> <li>RoAlgo Contest #1 - Expansion</li> <li>USACO Silver Icy   Perimeter</li> <li>USACO Silver Cross Country   Skiing</li> <li>OJI 2021 labirint</li> <li>OJI 2009 insule</li> <li>infoarena delfin</li> <li>infoarena vila</li> <li>infoarena marceland</li> <li>Codeforces Fox and Two Dots</li> <li>USACO Silver Where's   Bessie</li> <li>Codeforces Solve the Maze</li> <li>OJI 2018 castel</li> <li>ONI 2014 traseu</li> <li>Codeforces Igor in the Museum</li> <li>ONI 2012 gheizere</li> <li>Codeforces Olya and Energy   Drinks</li> <li>USACO Silver Comfortable   Cows</li> <li>USACO Silver Snow   Boots</li> <li>Lot Juniori 2021 Fete si baieti</li> <li>OJI 2016 miting</li> <li>Probleme cu coada si lee de pe   pbinfo</li> <li>Problemele cu flood fill de pe kilonova</li> </ul>","tags":["structuri de date","Coad\u0103","Lee","Fill","Stiva","BFS","DFS"]},{"location":"mediu/lee/#lectura-suplimentara","title":"Lectur\u0103 suplimentar\u0103","text":"<ul> <li>Flood fill - USACO Guide</li> <li>BFS Fill - Algoritmul lui Lee -   Algopedia</li> <li>Algoritmul lui Lee - infogenius</li> <li>Algoritmul lui Lee - infoarena</li> <li>Algoritmul lui Lee -   pbinfo</li> <li>Cozi (include si alte probleme) - CPPI   Sync</li> <li>Probleme diverse - CPPI   Sync</li> <li>Flood fill - wikipedia</li> <li>Algoritmi de umplere - generalitati -   Pbinfo</li> <li>Algoritmi de umplere - fill recursiv -   Pbinfo</li> <li>Algoritmi de umplere - fill cu coada -   Pbinfo</li> <li>An Efficient (and quite common) Way to Navigate Grid Problems -   Codeforces</li> <li>0-1 BFS - Codeforces</li> </ul>","tags":["structuri de date","Coad\u0103","Lee","Fill","Stiva","BFS","DFS"]},{"location":"mediu/lis/","title":"Sub\u0219ir cresc\u0103tor maximal","text":"<p>\u00cen cele ce urmeaz\u0103, vom prezenta problema afl\u0103rii celui mai lung sub\u0219ir cresc\u0103tor dintr-un \u0219ir, prezent\u00e2nd o serie de algoritmi care rezolv\u0103 aceast\u0103 problem\u0103, \u00eencep\u00e2nd de la cei mai \u00eence\u021bi \u0219i termin\u00e2nd cu variantele optime, precum \u0219i diversele modific\u0103ri pe care le putem face.</p>","tags":["programare dinamica","structuri de date","optimizari","subsiruri"]},{"location":"mediu/lis/#introducere","title":"Introducere","text":"<p>Se consider\u0103 un sub\u0219ir cresc\u0103tor al vectorului \\(v\\) un sub\u0219ir \\(p_1, p_2, \\dots, p_k\\) cu propriet\u0103\u021bile c\u0103 \\(1 \\leq p_1 &lt; p_2 &lt; \\dots &lt; p_k \\leq n\\), iar \\(v[p_1] &lt; v[p_2] &lt; \\dots &lt; v[p_k]\\).</p> <p>Un sub\u0219ir cresc\u0103tor maximal al unui \u0219ir este un sub\u0219ir cresc\u0103tor al lui \\(v\\) cu proprietatea c\u0103 lungimea acestuia este maxim\u0103.</p> <p>De exemplu, dac\u0103 \\(v = \\{7, 3, 5, 3, 6, 2, 9, 8 \\}\\), unul dintre sub\u0219irurile cresc\u0103toare de lungime maxim\u0103 al acestui \u0219ir este \\(\\{ 3, 5, 6, 9 \\}\\), lungimea acestuia fiind 4.</p>","tags":["programare dinamica","structuri de date","optimizari","subsiruri"]},{"location":"mediu/lis/#cum-aflam-subsirul-crescator-maximal","title":"Cum afl\u0103m sub\u0219irul cresc\u0103tor maximal?","text":"<p>O prim\u0103 solu\u021bie const\u0103 \u00een folosirea unei metode de tip Backtracking pentru a testa toate sub\u0219irurile, dar aceasta este mult prea \u00eenceat\u0103, nu are sens s\u0103 o discut\u0103m aici. Totu\u0219i, exist\u0103 c\u00e2teva solu\u021bii care sunt bazate pe algoritmi de tip Greedy \u0219i bazate pe metoda program\u0103rii dinamice care ne duc la r\u0103spuns, \u00een diverse complexit\u0103\u021bi de timp. \u00cen cele ce urmeaz\u0103, le vom prezenta, una c\u00e2te una.</p>","tags":["programare dinamica","structuri de date","optimizari","subsiruri"]},{"location":"mediu/lis/#dinamica-in-on2","title":"Dinamica \u00een O(n^2)","text":"<p>O solu\u021bie foarte cunoscut\u0103 a acestei probleme const\u0103 \u00een folosirea unei dinamici, \u00een care \\(dp[i]\\) va \u021bine lungimea sub\u0219irului cresc\u0103tor maximal care con\u021bine pozi\u021bia \\(i\\). Tranzi\u021biile vor fi foarte simple, fiecare pozi\u021bie este comparat\u0103 cu fiecare, complexitatea solu\u021biei ajung\u00e2nd la $\\mathcal{O}(n^2).</p> \\[ dp[i] = \\max_{\\substack{j &lt; i\\\\v[j] &lt; v[i]}} \\left(dp[j] + 1\\right) \\] <p>Evident, dac\u0103 nu exist\u0103 o pozi\u021bie \\(j &lt; i\\) care respect\u0103 condi\u021bia de mai sus, \\(dp[i] = 1\\).</p> <p>Implementarea acestei solu\u021bii nu este foarte complicat\u0103, mai jos g\u0103si\u021bi solu\u021bia propus\u0103 de noi pentru problema SCLM de pe pbinfo.</p> <pre><code>#include &lt;fstream&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\nint main() {\n    ifstream cin(\"sclm.in\");\n    ofstream cout(\"sclm.out\");\n\n    int n;\n    cin &gt;&gt; n;\n\n    vector&lt;int&gt; v(n + 1), dp(n + 1), fw(n + 1);\n    for (int i = 1; i &lt;= n; i++) {\n        cin &gt;&gt; v[i];\n    }\n\n    int maxi = 0;\n    int pos = 0;\n    for (int i = 1; i &lt;= n; i++) {\n        for (int j = 1; j &lt; i; j++) {\n            if (v[j] &lt; v[i] &amp;&amp; dp[j] &gt; dp[i]) {\n                dp[i] = dp[j];\n                fw[i] = j;\n            }\n        }\n        dp[i]++;\n        if (dp[i] &gt; maxi) {\n            maxi = dp[i];\n            pos = i;\n        }\n    }\n\n    // vom reconstitui raspunsul din aproape in aproape\n    cout &lt;&lt; maxi &lt;&lt; '\\n';\n    vector&lt;int&gt; ans;\n    while (pos) {\n        ans.push_back(pos);\n        pos = fw[pos];\n    }\n    for (int i = maxi - 1; i &gt;= 0; i--) {\n        cout &lt;&lt; ans[i] &lt;&lt; \" \";\n    }\n    return 0;\n}\n</code></pre>","tags":["programare dinamica","structuri de date","optimizari","subsiruri"]},{"location":"mediu/lis/#solutie-in-mathcalon-log-n-cu-cautare-binara","title":"Solu\u021bie \u00een \\(\\mathcal{O}(n \\log n)\\) cu c\u0103utare binar\u0103","text":"<p>Pentru a rezolva aceast\u0103 problem\u0103 \u00een timp optim, trebuie s\u0103 observ\u0103m c\u0103 foarte mul\u021bi candida\u021bi pe care \u00eei \u021binem la solu\u021bia anterioar\u0103 nu \u00ee\u0219i au rostul, fiind \u00eendeajuns s\u0103 \u0219tim doar candidatul cu cea mai mic\u0103 valoare pentru fiecare valoare distinct\u0103 pe care o poate lua \\(dp[i]\\).</p> <p>Deoarece pe m\u0103sur\u0103 ce cre\u0219tem valorile lui \\(dp[i]\\), candida\u021bii pe care \u00eei p\u0103str\u0103m au valori tot mai mari, putem \u00eembun\u0103t\u0103\u021bi aceast\u0103 solu\u021bie p\u0103str\u00e2nd doar candida\u021bii \u0219i c\u0103ut\u00e2nd binar valoarea minim\u0103 din \u0219irul candida\u021bilor care dep\u0103\u0219e\u0219te valoarea curent\u0103. Mai jos g\u0103si\u021bi solu\u021bia problemei Increasing Subsequence de pe CSES.</p> <pre><code>#include &lt;iostream&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\nint main() {\n    int n;\n    cin &gt;&gt; n;\n\n    vector&lt;int&gt; v(n + 1), dp(n + 1);\n    for (int i = 1; i &lt;= n; i++) {\n        cin &gt;&gt; v[i];\n    }\n\n    vector&lt;int&gt; candidates;\n    int maxi = 0;\n    for (int i = 1; i &lt;= n; i++) {\n        if (i == 1 || v[i] &gt; v[candidates.back()]) {\n            candidates.push_back(i);\n            dp[i] = candidates.size();\n        } else {\n            int L = 0;\n            int R = (int)candidates.size() - 1;\n            int ans = -1;\n            while (L &lt;= R) {\n                int mid = (L + R) / 2;\n                if (v[candidates[mid]] &gt;= v[i]) {\n                    ans = mid;\n                    R = mid - 1;\n                } else {\n                    L = mid + 1;\n                }\n            }\n            // ans ne da si pozitia in cazul in care avem nevoie de\n            // reconstruirea solutiei\n            dp[i] = ans + 1;\n            candidates[ans] = i;\n        }\n        maxi = max(maxi, dp[i]);\n    }\n\n    cout &lt;&lt; maxi &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["programare dinamica","structuri de date","optimizari","subsiruri"]},{"location":"mediu/lis/#solutie-in-mathcalon-log-n-cu-structuri-de-date","title":"Solu\u021bie \u00een \\(\\mathcal{O}(n \\log n)\\) cu structuri de date","text":"<p>Pentru solu\u021biile \u00een \\(\\mathcal{O}(n \\log n)\\) care folosesc structuri de date, mai \u00eent\u00e2i vom vrea s\u0103 avem o copie a vectorului ini\u021bial, pe care s\u0103 o sort\u0103m. Recomand\u0103m mai \u00eent\u00e2i familiarizarea cu arborii de intervale sau arborii indexa\u021bi binar pentru a continua, precum \u0219i normalizarea dac\u0103 nu a\u021bi mai folosit aceast\u0103 tehnic\u0103 anterior.</p> <p>Acest lucru ne garanteaz\u0103 normalizarea vectorului, lucru pe care \u00eel vom folosi pentru a putea avea queryuri de tip maxim pe un interval pe parcursul implement\u0103rii voastre.</p> <p>Dup\u0103 ce am f\u0103cut acest pas, tot ce trebuie s\u0103 facem este s\u0103 c\u0103ut\u0103m binar pentru fiecare valoare din \u0219ir, \u00een ordinea \u00een care apar, care ar fi pozi\u021bia \u00een vectorul sortat, facem query-urile de maxim pe interval \u0219i actualiz\u0103m pozi\u021bia g\u0103sit\u0103 anterior \u00een timpul c\u0103ut\u0103rii binare. Mai jos g\u0103si\u021bi cele dou\u0103 variante folosind cele dou\u0103 structuri de date, solu\u021biile fiind pentru aceea\u0219i problem\u0103 de pe CSES.</p>","tags":["programare dinamica","structuri de date","optimizari","subsiruri"]},{"location":"mediu/lis/#solutie-cu-arbori-de-intervale","title":"Solu\u021bie cu arbori de intervale","text":"<pre><code>#include &lt;algorithm&gt;\n#include &lt;iostream&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\nvoid add(int node, int L, int R, int poz, int val, vector&lt;int&gt; &amp;segtree) {\n    if (L == R) {\n        segtree[node] = max(segtree[node], val);\n        return;\n    }\n\n    int mid = (L + R) / 2;\n    if (poz &lt;= mid) {\n        add(node * 2, L, mid, poz, val, segtree);\n    } else {\n        add(node * 2 + 1, mid + 1, R, poz, val, segtree);\n    }\n    segtree[node] = max(segtree[node * 2], segtree[node * 2 + 1]);\n}\n\nint query(int node, int L, int R, int qL, int qR, vector&lt;int&gt; &amp;segtree) {\n    if (qL &lt;= L &amp;&amp; R &lt;= qR) {\n        return segtree[node];\n    }\n\n    if (qR &lt; L || qL &gt; R) {\n        return 0;\n    }\n\n    int mid = (L + R) / 2;\n    return max(query(node * 2, L, mid, qL, qR, segtree),\n               query(node * 2 + 1, mid + 1, R, qL, qR, segtree));\n}\n\nint main() {\n    int n;\n    cin &gt;&gt; n;\n\n    vector&lt;int&gt; v(n + 1), sorted(n + 1), segtree(4 * n + 1);\n    for (int i = 1; i &lt;= n; i++) {\n        cin &gt;&gt; v[i];\n        sorted[i] = v[i];\n    }\n    sort(sorted.begin() + 1, sorted.begin() + n + 1);\n\n    int maxi = 0;\n    for (int i = 1; i &lt;= n; i++) {\n        int L = 1;\n        int R = n;\n        int ans = 0;\n        while (L &lt;= R) {\n            int mid = (L + R) / 2;\n            if (sorted[mid] &lt; v[i]) {\n                ans = mid;\n                L = mid + 1;\n            } else {\n                R = mid - 1;\n            }\n        }\n\n        int query_ans = query(1, 1, n, 1, ans, segtree) + 1;\n        maxi = max(maxi, query_ans);\n        add(1, 1, n, ans + 1, query_ans, segtree);\n    }\n\n    cout &lt;&lt; maxi &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["programare dinamica","structuri de date","optimizari","subsiruri"]},{"location":"mediu/lis/#solutie-cu-arbori-indexati-binar","title":"Solu\u021bie cu arbori indexa\u021bi binar","text":"<pre><code>#include &lt;algorithm&gt;\n#include &lt;iostream&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\nvoid add(int node, int n, int val, vector&lt;int&gt; &amp;fen) {\n    for (; node &lt;= n; node += (node &amp; (-node))) {\n        fen[node] = max(fen[node], val);\n    }\n}\n\nint compute(int node, vector&lt;int&gt; &amp;fen) {\n    int ans = 0;\n    for (; node; node -= (node &amp; (-node))) {\n        ans = max(ans, fen[node]);\n    }\n    return ans;\n}\n\nint main() {\n    int n;\n    cin &gt;&gt; n;\n\n    vector&lt;int&gt; v(n + 1), sorted(n + 1), fen(n + 1);\n    for (int i = 1; i &lt;= n; i++) {\n        cin &gt;&gt; v[i];\n        sorted[i] = v[i];\n    }\n    sort(sorted.begin() + 1, sorted.begin() + n + 1);\n\n    int maxi = 0;\n    for (int i = 1; i &lt;= n; i++) {\n        int L = 1;\n        int R = n;\n        int ans = 0;\n        while (L &lt;= R) {\n            int mid = (L + R) / 2;\n            if (sorted[mid] &lt; v[i]) {\n                ans = mid;\n                L = mid + 1;\n            } else {\n                R = mid - 1;\n            }\n        }\n\n        int query_ans = compute(ans, fen) + 1;\n        maxi = max(maxi, query_ans);\n        add(ans + 1, n, query_ans, fen);\n    }\n\n    cout &lt;&lt; maxi &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["programare dinamica","structuri de date","optimizari","subsiruri"]},{"location":"mediu/lis/#concluzii-si-alte-moduri-in-care-putem-folosi-aceasta-abordare","title":"Concluzii \u0219i alte moduri \u00een care putem folosi aceast\u0103 abordare","text":"<p>Probleme similare cu cea descris\u0103 mai sus sunt unele precum num\u0103rul de sub\u0219iruri cresc\u0103toare maximale, lungimea unui sub\u0219ir cresc\u0103tor maximal \u00een care putem avea elemente egale sau pentru doritorii unei provoc\u0103ri mai avansate, num\u0103rul minim de sub\u0219iruri descresc\u0103toare necesare pentru a acoperi o secven\u021b\u0103 dat\u0103.</p> <p>De\u0219i toate aceste solu\u021bii au utilitatea lor, pe parcurs, ve\u021bi observa c\u0103 solu\u021biile ce implic\u0103 structuri de date au o mai mare plaj\u0103 \u00een ceea ce prive\u0219te modific\u0103rile care pot fi f\u0103cute \u0219i timpul de implementare al acestora.</p>","tags":["programare dinamica","structuri de date","optimizari","subsiruri"]},{"location":"mediu/lis/#probleme-suplimentare","title":"Probleme suplimentare","text":"<ul> <li>CopyCopyCopyCopyCopy   Codeforces</li> <li>scmax infoarena</li> <li>subsiruri infoarena</li> <li>LIS On Permutations -   Codeforces</li> <li>IIOT 2018 UpDown</li> <li>Codeforces Tourist</li> <li>interclasare infoarena</li> <li>USACO Gold Cowjog</li> <li>Pokemoni - Lot 2024 Juniori</li> </ul>","tags":["programare dinamica","structuri de date","optimizari","subsiruri"]},{"location":"mediu/lis/#lectura-suplimentara","title":"Lectur\u0103 suplimentar\u0103","text":"<ul> <li>Articolul de pe   wikipedia</li> <li>Articolul de pe   pbinfo</li> <li>Articolul de pe   cp-algorithms</li> <li>Articolul de pe USACO Guide</li> </ul>","tags":["programare dinamica","structuri de date","optimizari","subsiruri"]},{"location":"mediu/mitm/","title":"Meet in the Middle","text":"","tags":["optimizari","precalculare","brute force"]},{"location":"mediu/mitm/#introducere","title":"Introducere","text":"<p>Meet in the middle este o tehnic\u0103 de programare care este folosit\u0103 atunci c\u00e2nd avem de-a face cu probleme pentru care solu\u021bia optim\u0103 este aceea de a \u00eemp\u0103r\u021bi spa\u021biul de c\u0103utare \u00een dou\u0103, pentru a putea aplica for\u021ba brut\u0103 independent pentru cele dou\u0103 jum\u0103t\u0103\u021bi rezultate.</p> <p>Numele \u0219i principiile acestei tehnici sunt \u00eenrudite cu atacul criptografic cu acela\u0219i nume.</p> <p>\u00cen algoritmic\u0103, acea tehnic\u0103 este folosit\u0103 atunci c\u00e2nd vrem s\u0103 rezolv\u0103m probleme folosind brute-force, dar restric\u021biile nu sunt suficient de mici pentru un brute-force clasic, utilizarea cea mai des \u00eent\u00e2lnit\u0103 pentru meet in the middle este atunci c\u00e2nd trebuie s\u0103 lucr\u0103m cu submul\u021bimi.</p> <p>!!! \"Observa\u021bie\"</p> <pre><code>Deoarece spa\u021biul de c\u0103utare se \u00eemparte \u00een dou\u0103, complexitatea exponen\u021bial\u0103\nva cre\u0219te mult mai greu, meet in the middle devenind util pentru probleme la\ncare dimensiunea datelor de intrare este cel mult $40-45$.\n</code></pre> <p>Cu alte cuvinte, vom rula un algoritm brute-force pentru fiecare jum\u0103tate, iar apoi vom uni rezultatele ob\u021binute \u00een timp liniar, raportat la num\u0103rul de solu\u021bii generate.</p> <p>Astfel, complexitatea algoritmului va deveni acum \\(\\mathcal{O}(2^{\\frac{n}{2}})\\).</p>","tags":["optimizari","precalculare","brute force"]},{"location":"mediu/mitm/#problema-meet-in-the-middle","title":"Problema Meet in the Middle","text":"<p>Pentru a afla c\u00e2te submul\u021bimi au suma \\(k\\), vom precalcula pentru prima jum\u0103tate din \u0219ir sumele tuturor submul\u021bimilor, stoc\u00e2nd sumele \u00eentr-un vector sau map, iar apoi pentru fiecare sum\u0103 din cea de-a doua jum\u0103tate, vom afla c\u00e2te sume sunt egale cu complementul ei \\(k - sum\\).</p> <pre><code>#include &lt;algorithm&gt;\n#include &lt;iostream&gt;\n#include &lt;vector&gt;\n\nusing namespace std;\n\nint bs(int sum, vector&lt;int&gt; &amp;sums) {\n    int L = 0;\n    int R = sums.size() - 1;\n    int ans = 0;\n    while (L &lt;= R) {\n        int mid = (L + R) / 2;\n        if (sums[mid] &lt;= sum) {\n            ans = mid + 1;\n            L = mid + 1;\n        } else {\n            R = mid - 1;\n        }\n    }\n    return ans;\n}\n\nint main() {\n    int n, k;\n    cin &gt;&gt; n &gt;&gt; k;\n\n    vector&lt;int&gt; v(n);\n    for (int i = 0; i &lt; n; i++) {\n        cin &gt;&gt; v[i];\n    }\n\n    long long ans = 0;\n    vector&lt;int&gt; sums;\n\n    int firsthalf = n / 2 + n % 2;\n    int secondhalf = n - firsthalf;\n    for (int i = 0; i &lt; (1 &lt;&lt; firsthalf); i++) {\n        long long sum = 0;\n        for (int j = 0; j &lt; firsthalf; j++) {\n            if (i &amp; (1 &lt;&lt; j)) {\n                sum += v[j];\n            }\n        }\n\n        if (sum &lt;= k) {\n            sums.push_back(sum);\n        }\n    }\n\n    sort(sums.begin(), sums.end());\n\n    for (int i = 0; i &lt; (1 &lt;&lt; secondhalf); i++) {\n        long long sum = 0;\n        for (int j = firsthalf; j &lt; n; j++) {\n            if (i &amp; (1 &lt;&lt; (j - firsthalf))) {\n                sum += v[j];\n            }\n        }\n\n        if (sum &lt;= k) {\n            ans += bs(k - sum, sums) - bs(k - sum - 1, sums);\n        }\n    }\n\n    cout &lt;&lt; ans &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["optimizari","precalculare","brute force"]},{"location":"mediu/mitm/#problema-sum-of-four-values","title":"Problema Sum of Four Values","text":"<p>Un alt tip de probleme care se poate rezolva cu meet in the middle este acela \u00een care trebuie s\u0103 g\u0103sim o submul\u021bime de dimensiunea \\(x\\) cu o anumit\u0103 proprietate, iar abordarea pentru aceste probleme const\u0103 \u00een a crea submul\u021bimi de dimensiunea \\(\\frac{x}{2}\\) iar mai apoi, le vom uni \u00eentr-un mod similar cu cel de la prima problem\u0103, a\u0219a cum facem \u0219i aici.</p> <pre><code>#include &lt;iostream&gt;\n#include &lt;map&gt;\n#include &lt;vector&gt;\n\nusing namespace std;\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n\n    int n, x;\n    cin &gt;&gt; n &gt;&gt; x;\n\n    vector&lt;int&gt; v(n + 1);\n    for (int i = 1; i &lt;= n; ++i) {\n        cin &gt;&gt; v[i];\n    }\n\n    map&lt;int, int&gt; mp;\n    for (int i = 2; i &lt;= n; ++i) {\n        for (int j = i + 1; j &lt;= n; ++j) {\n            mp[v[i] + v[j]]++;\n        }\n    }\n\n    for (int i = 2; i &lt;= n; ++i) {\n        for (int j = i + 1; j &lt;= n; ++j) {\n            if (mp[v[i] + v[j]] &gt;= 2) {\n                mp[v[i] + v[j]]--;\n            } else {\n                mp.erase(v[i] + v[j]);\n            }\n        }\n        for (int j = i - 1; j &gt;= 1; --j) {\n            if (mp.find(x - v[i] - v[j]) != mp.end()) {\n                int rem = x - v[i] - v[j];\n                cout &lt;&lt; j &lt;&lt; \" \" &lt;&lt; i &lt;&lt; \" \";\n                for (int q = i + 1; q &lt;= n; ++q) {\n                    for (int p = q + 1; p &lt;= n; ++p) {\n                        if (v[p] + v[q] == rem) {\n                            cout &lt;&lt; q &lt;&lt; \" \" &lt;&lt; p &lt;&lt; '\\n';\n                            return 0;\n                        }\n                    }\n                }\n            }\n        }\n    }\n    cout &lt;&lt; \"IMPOSSIBLE\";\n    return 0;\n}\n</code></pre>","tags":["optimizari","precalculare","brute force"]},{"location":"mediu/mitm/#concluzii","title":"Concluzii","text":"<p>Tehnica meet in the middle este o tehnic\u0103 util\u0103 pentru a \u00eembun\u0103t\u0103\u021bi timpul de execu\u021bie pentru foarte multe solu\u021bii ce se bazeaz\u0103 pe metode de tip brute-force. Fie c\u0103 e vorba de probleme cu restric\u021bii mici sau la care avem nevoie de submul\u021bimi mici, meet in the middle este o tehnic\u0103 foarte util\u0103 pentru diferite tipuri de aplica\u021bii.</p>","tags":["optimizari","precalculare","brute force"]},{"location":"mediu/mitm/#probleme-suplimentare","title":"Probleme suplimentare","text":"<ul> <li>Piese Lot Juniori 2017</li> <li>Infoarena loto</li> <li>23 - IIOT 2019-20</li> <li>OJI 2018 eq4</li> <li>Infoarena aiacubiti</li> <li>Infoarena colectie</li> <li>CEOI 2019 cubeword</li> <li>USACO Silver Field   Day</li> <li>Cupa SEPI 2023 circles</li> <li>Probleme cu meet in the middle de pe   Codeforces</li> <li>Probleme cu meet in the middle de pe Kilonova</li> </ul>","tags":["optimizari","precalculare","brute force"]},{"location":"mediu/mitm/#lectura-suplimentara","title":"Lectur\u0103 suplimentar\u0103","text":"<ul> <li>Meet in the middle - Errichto</li> <li>Meet in the middle - USACO   Guide</li> <li>Infobits F1 - SEPI (pagina   89)</li> <li>Meet in the middle -   infoarena</li> </ul>","tags":["optimizari","precalculare","brute force"]},{"location":"mediu/modular-inverse/","title":"Invers modular","text":"","tags":["matematica","combinatorica"]},{"location":"mediu/modular-inverse/#problema","title":"Problema","text":"<p>\u00cen cadrul multor probleme de informatic\u0103 se cere calcularea unei valori \u0219i afi\u0219area acesteia modulo unei constante precizate \u00een enun\u021b. Se poate observa faptul c\u0103 opera\u021biile de adunare, sc\u0103dere \u0219i \u00eenmul\u021bire se pot efectua f\u0103r\u0103 probleme cu respect la un anumit modul, \u00eens\u0103 opera\u021bia de \u00eemp\u0103r\u021bire trebuie tratat\u0103 diferit. Mai exact, dac\u0103 \\(A\\), \\(B\\) si \\(M\\) sunt numere \u00eentregi, \\(M \\ne 0\\), \\(B \\ne 0\\), egalitatea \\(\\frac{A}{B} \\mod{M} = \\frac{A \\mod{M}}{B \\mod{M}} \\mod{M}\\) nu este \u00eentotdeauna adev\u0103rat\u0103.</p> <p>Se recomand\u0103 citirea informa\u021biilor din articolul despre matematic\u0103 de baz\u0103 \u00eenainte de a citi no\u021biunile de aici.</p>","tags":["matematica","combinatorica"]},{"location":"mediu/modular-inverse/#ce-este-inversul-modular","title":"Ce este inversul modular?","text":"<p>\u00cen matematic\u0103, inversul unui num\u0103r real \\(x\\) este acel num\u0103r \\(x^{-1}\\) care satisface \\(x \\cdot x^{-1} = 1\\). \u00cemp\u0103r\u021birea unui num\u0103r la \\(x\\) este echivalent\u0103 cu \u00eenmul\u021birea acestuia cu \\(x^{-1} = \\frac{1}{x}\\). Tot a\u0219a, \u0219i \u00een aritmetica modular\u0103 definim inversul modular al unui num\u0103r \\(x\\) (cu respect la modulul \\(M\\)) acel num\u0103r notat \\(x^{-1}\\) care satisface rela\u021bia \\(x \\cdot x^{-1} \\equiv{1} \\pmod{M}\\). Se poate demonstra faptul c\u0103 un num\u0103r \u00eentreg are un invers modular modulo \\(M\\) dac\u0103 \u0219i numai dac\u0103 el \u0219i \\(M\\) sunt prime \u00eentre ele.</p> <p>Atunci, pentru a efectua opera\u021bia de \u00eemp\u0103r\u021bire cu respect la modul dintre \\(A\\) \u0219i \\(B\\) trebuie s\u0103 \u00eel \u00eenmul\u021bim pe \\(A\\) cu inversul modular al lui \\(B\\), deoarece \\((\\frac{A}{B}) \\mod{M} = (A \\cdot B^{-1}) \\mod{M}\\).</p>","tags":["matematica","combinatorica"]},{"location":"mediu/modular-inverse/#cum-calculam-inversul-modular-al-unui-numar","title":"Cum calcul\u0103m inversul modular al unui num\u0103r?","text":"","tags":["matematica","combinatorica"]},{"location":"mediu/modular-inverse/#calcularea-folosind-mica-teorema-a-lui-fermat","title":"Calcularea folosind mica teorem\u0103 a lui Fermat","text":"<p>Mica teorem\u0103 a lui Fermat</p> <p>Dac\u0103 \\(p\\) este un num\u0103r prim \u0219i \\(a\\) este un num\u0103r \u00eentreg prim cu \\(p\\), atunci \\(a^{p-1} \\equiv 1 \\pmod{p}\\).</p> <p>Congruen\u021ba se mai poate scrie ca:</p> \\[ a \\cdot a^{p - 2} \\equiv 1 \\pmod{p} \\] <p>Se poate observa u\u0219or c\u0103 de fapt inversul modular al lui \\(a\\) este \\(a^{p - 2}\\), care poate fi calculat rapid folosind exponen\u021bierea logaritmic\u0103.</p>","tags":["matematica","combinatorica"]},{"location":"mediu/modular-inverse/#algoritmul-extins-al-lui-euclid","title":"Algoritmul extins al lui Euclid","text":"<p>Lu\u0103m \u00een considerare urm\u0103toarea identitate:</p> <p>Identitatea lui B\u00e9zout</p> <p>Fie numerele \u00eentregi \\(A\\), \\(B\\) \u0219i \\(d = cmmdc(A, B)\\). Atunci, exist\u0103 cel pu\u021bin o pereche de numere \u00eentregi \\(x\\) \u0219i \\(y\\) astfel \u00eencat \\(Ax + By = d\\).</p> <p>Daca \\(A\\) \u0219i \\(M\\) sunt prime \u00eentre ele, atunci exist\u0103 \\(x_1\\) \u0219i \\(y_1\\) astfel \u00eenc\u00e2t \\(Ax_1 + My_1 = 1\\). De aici reiese faptul c\u0103 \\(Ax_1 \\equiv 1 \\pmod{M}\\), adic\u0103 \\(x_1\\) este inversul modular al lui \\(A\\).</p> <p>Fie \\(c\\) c\u00e2tul \u00eemp\u0103r\u021birii lui \\(A\\) la \\(M\\) \u0219i \\(r\\) restul. Algoritmul lui Euclid ne spune c\u0103 \\(cmmdc(A, M) = cmmdc(M, r) \\implies cmmdc(M, r) = 1\\). Astfel, exist\u0103 \\(x_2\\) \u0219i \\(y_2\\) care satisfac \\(Mx_2 + ry_2 = 1\\).</p> <p>Dar</p> \\[ \\begin{align*} r = A - M \\cdot c &amp;\\implies Mx_2 + (A - M \\cdot c)y_2 = 1\\\\ &amp;\\iff Mx_2 + Ay_2 - M \\cdot c \\cdot y_2 = 1\\\\ &amp;\\iff Ay_2 + M(x_2 - c \\cdot y_2) = 1 \\end{align*} \\] <p>Se observa c\u0103 \\(x_1 = y_2\\) \u0219i \\(y_1 = x_2 - c \\cdot y_2\\), iar \\(c = \\lfloor \\frac{A}{M} \\rfloor\\). Astfel, putem folosi recursiv algoritmul lui Euclid, ad\u0103ug\u00e2ndu-i parametrii \\(x_1\\) \u0219i \\(y_1\\):</p> <pre><code>void euclidExtins(const int a, const int b, int&amp; x1, int&amp; y1);\n</code></pre> <p>\u00cen cazul \u00een care parametrul \\(b\\) din func\u021bie este egal cu 0, atunci \\(a\\) va fi egal cu 1 \u0219i astfel vom seta \\(x_1 = 1\\), iar \\(y_1\\) poate lua orice valoare, de exemplu tot 1.</p> <p>Aten\u021bie</p> <p>Valoarea lui \\(x_1\\) poate fi \u0219i negativ\u0103. Dac\u0103 este necesar\u0103 o valoare pozitiv\u0103 atunci facem opera\u021bia \\(x_1 = x_1 + M\\).</p> <p>Mai jos se poate observa o implementare \u00een C++ a algoritmului lui Euclid, respectiv a func\u021biei de calculare a inversului modular al lui \\(A\\) pentru modulul \\(M\\):</p> <pre><code>void euclidExtins(const int a, const int b, int&amp; x1, int&amp; y1) {\n    if (b == 0) {\n        x1 = 1;\n        y1 = 1;\n        return;\n    }\n\n    int x2, y2;\n\n    euclidExtins(b, a % b, x2, y2);\n\n    x1 = y2;\n    y1 = (x2 - a / b * y2) % M;\n}\n\nint inversModular(const int A) {\n    int x1, y1;\n\n    euclidExtins(A, M, x1, y1);\n\n    /* daca vrem x1 pozitiv\n    if(x1 &lt; 0)\n        x1 += M;\n    */\n\n    return x1;\n}\n</code></pre>","tags":["matematica","combinatorica"]},{"location":"mediu/modular-inverse/#probleme-cu-invers-modular","title":"Probleme cu invers modular","text":"<ul> <li>Invers Modular</li> <li>Lot 2021 Juniori Prosum</li> <li>Codeforces Beautiful Numbers</li> <li>Toate aplicatiile prezentate la combinatorica</li> <li>Codeforces Sum of the kth   powers</li> </ul>","tags":["matematica","combinatorica"]},{"location":"mediu/modular-inverse/#lectura-suplimentara","title":"Lectur\u0103 suplimentar\u0103","text":"<ul> <li>Algoritmul lui Euclid extins. Invers modular -   Pbinfo</li> <li>Modular arithmetic - USACO Guide</li> <li>Modular multiplicative   inverse</li> <li>Calculate modulo inverses   efficiently</li> <li>Modular arithmetic for Beginners -   Codeforces</li> <li>Func\u021bie scurt\u0103 de a calcula inversul modular -   Codeforces</li> <li>Modular Inverse / Inverse Remainder / Modular Division \u2013 A Quick Guide -   Codeforeces</li> </ul>","tags":["matematica","combinatorica"]},{"location":"mediu/number-bases/","title":"Baze de numera\u021bie","text":"<p>Daca vreti sa ne ajutati cu acest articol, ne puteti gasi pe github sau pe serverul nostru de discord</p> <p>Mai jos g\u0103si\u021bi resurse pe care le pute\u021bi citi p\u00e2n\u0103 atunci.</p>","tags":["implementare","biti","optimizare"]},{"location":"mediu/number-bases/#introducere","title":"Introducere","text":"","tags":["implementare","biti","optimizare"]},{"location":"mediu/number-bases/#problema-exemplu","title":"Problema exemplu","text":"","tags":["implementare","biti","optimizare"]},{"location":"mediu/number-bases/#concluzii","title":"Concluzii","text":"","tags":["implementare","biti","optimizare"]},{"location":"mediu/number-bases/#probleme-suplimentare","title":"Probleme suplimentare","text":"","tags":["implementare","biti","optimizare"]},{"location":"mediu/number-bases/#resurse-suplimentare","title":"Resurse suplimentare","text":"<ul> <li>Baze de numeratie CPPI   Sync</li> <li>Baze de numeratie   Algopedia</li> </ul>","tags":["implementare","biti","optimizare"]},{"location":"mediu/pinex/","title":"Principiul includerii \u0219i excluderii (pinex)","text":"<p>\u00cen unele probleme de algoritmic\u0103, suntem nevoi\u021bi s\u0103 calcul\u0103m num\u0103rul de r\u0103spunsuri care se potrivesc cu o anumit\u0103 regul\u0103, dar num\u0103rarea direct\u0103 a fiec\u0103rei reguli \u00een mod individual nu aduce cu u\u0219urin\u021b\u0103 r\u0103spunsul corect. \u00cen cazul acestor probleme, vom apela la un principiu matematic folosit \u00een foarte mul\u021bi algoritmi elementari studia\u021bi p\u00e2n\u0103 acum, formaliz\u00e2nd discu\u021bia \u0219i aduc\u00e2nd mai multe asemenea probleme \u00een discu\u021bie.</p> <p>Defini\u021bie</p> <p>Principiul includerii \u0219i al excluderii (de asemenea denumit pinex) este un principiu matematic care este folosit atunci c\u00e2nd vrem s\u0103 afl\u0103m reuniunea a dou\u0103 sau mai multe mul\u021bimi, generaliz\u00e2ndu-se modul de calculare a r\u0103spunsurilor pentru aceast\u0103 clas\u0103 de probleme.</p> <p>Cu alte cuvinte, dac\u0103 avem dou\u0103 sau mai multe condi\u021bii care se intersecteaz\u0103, vrem s\u0103 evit\u0103m num\u0103rarea de mai multe ori a unor elemente. Vom pleca de la exemple simple pentru a putea generaliza mai u\u0219or.</p>","tags":["matematica","combinatorica","multimi"]},{"location":"mediu/pinex/#aplicarea-pinex-pentru-doua-multimi","title":"Aplicarea PINEX pentru dou\u0103 mul\u021bimi","text":"<p>Dac\u0103 avem dou\u0103 mul\u021bimi \\(A\\) \u0219i \\(B\\), pentru a afla num\u0103rul de valori care se reg\u0103sesc \u00een cel pu\u021bin una dintre mul\u021bimi putem s\u0103 sc\u0103dem din suma cardinalelor lui \\(A\\) \u0219i \\(B\\), cardinalul intersec\u021biei celor dou\u0103 mul\u021bimi. Mai formal, vom avea urm\u0103toarea formul\u0103:</p> \\[ |A \\cup B| = |A| + |B| - |A \\cap B| \\] <p>Se poate observa c\u0103 versiuni rudimentare ale acestei tehnici au fost folosite \u0219i \u00een cazul calcul\u0103rii unor r\u0103spunsuri pe baza sumelor par\u021biale (suma valorilor de la pozi\u021bia \\(L\\) la \\(R\\) este suma primelor \\(R\\) valori din care sc\u0103dem suma primelor \\(L-1\\) valori) sau \u00een cazul unor alte probleme celebre.</p>","tags":["matematica","combinatorica","multimi"]},{"location":"mediu/pinex/#problema-moobuzz-usaco-silver","title":"Problema MooBuzz - USACO Silver","text":"<p>Aceast\u0103 problem\u0103 este o adaptare a celebrei probleme FizzBuzz, cer\u00e2ndu-se aflarea celui de-al \\(n\\)-lea num\u0103r scris pe tabl\u0103. Pentru a face acest lucru, vom putea c\u0103uta binar r\u0103spunsul, \u0219tiind c\u0103 la fiecare pas, putem afla c\u00e2te numere au fost scrise pe tabl\u0103 care sunt mai mici sau egale cu \\(k\\).</p> <p>Pentru aflarea acestui r\u0103spuns, vom avea dou\u0103 mul\u021bimi:</p> <ul> <li>\\(A = \\{x | x \\ \\% \\ 3 = 0, x \\leq k \\}\\)</li> <li>\\(B = \\{x | x \\ \\% \\ 5 = 0, x \\leq k \\}\\)</li> </ul> <p>Este evident c\u0103 vom sc\u0103dea din \\(|A| + |B|\\) valoarea \\(|A \\cap B|\\), care reprezint\u0103 mul\u021bimea numerelor care se \u00eempart la 15, solu\u021bia devenind una \u00een timp constant, singurul factor de timp prezent fiind cel corespunz\u0103tor c\u0103ut\u0103rii binare. Mai jos pute\u021bi g\u0103si implementarea \u00een limbajul C++.</p> <pre><code>#include &lt;fstream&gt;\nusing namespace std;\n\nint main() {\n    ifstream cin(\"moobuzz.in\");\n    ofstream cout(\"moobuzz.out\");\n\n    int n;\n    cin &gt;&gt; n;\n\n    long long L = 1;\n    long long R = 2000000000;\n    long long ans = 0;\n\n    while (L &lt;= R) {\n        long long mid = (L + R) / 2;\n        long long cnt = mid / 3 + mid / 5 - mid / 15;\n        if (mid - cnt &gt;= n) {\n            ans = mid;\n            R = mid - 1;\n        } else {\n            L = mid + 1;\n        }\n    }\n\n    cout &lt;&lt; ans &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["matematica","combinatorica","multimi"]},{"location":"mediu/pinex/#aplicarea-pinex-pentru-trei-sau-mai-multe-multimi","title":"Aplicarea PINEX pentru trei sau mai multe mul\u021bimi","text":"<p>Pentru a aplica aceea\u0219i formul\u0103 pentru trei sau mai multe mul\u021bimi, vom prezenta o proprietate important\u0103 care ne va ajuta de-a lungul formulelor viitoare.</p> <p>Observa\u021bie</p> <p>Pentru a calcula r\u0103spunsul unei probleme la care va trebui s\u0103 aplic\u0103m acest principiu, vom aduna mereu la r\u0103spuns num\u0103rul elementelor care se afl\u0103 \u00eentr-un num\u0103r impar de mul\u021bimi \u0219i vom sc\u0103dea din r\u0103spuns cele care apar \u00eentr-un num\u0103r par de mul\u021bimi.</p> <p></p> <p>De exemplu, c\u00e2nd avem trei mul\u021bimi, formula de mai devreme devine</p> \\[ |A \\cup B \\cup C| = |A| + |B| + |C| - |A \\cap B| - |A \\cap C| - |B \\cap C| + |A \\cap B \\cap C| \\] <p>\u00cen mod general, dac\u0103 avem \\(k\\) mul\u021bimi, r\u0103spunsul va deveni urm\u0103torul, unde \\(A_i\\) reprezint\u0103 cea de-a \\(i\\)-a mul\u021bime:</p> \\[ \\left| \\bigcup_{i=1}^n A_i \\right| = \\sum_{i=1}^n|A_i| - \\sum_{1\\leq i&lt;j\\leq n} |A_i \\cap A_j| + \\sum _{1\\leq i&lt;j&lt;k\\leq n}|A_i \\cap A_j \\cap A_k| - \\cdots + (-1)^{n-1} | A_1 \\cap \\cdots \\cap A_n | \\] <p>Pe scurt, formula va deveni urm\u0103toarea:</p> \\[ \\bigg|\\bigcup_{i=1}^nA_i \\bigg|= \\sum_{0 \\neq J \\in \\{1, 2,...,n\\} } (-1)^{|J|-1} \\bigg| \\bigcap_{j \\in J} A_j \\bigg| \\] <p>Acest lucru ne garanteaz\u0103 c\u0103 pentru un element care apare \u00een mai multe mul\u021bimi, de\u0219i este adunat individual de mai multe ori, se scad p\u0103r\u021bile care apar \u00een plus \u00een calculul final.</p> <p>Observa\u021bie</p> <p>Dac\u0103 avem de-a face cu o problem\u0103 la care trebuie s\u0103 recurgem la aflarea complementului r\u0103spunsului folosind PINEX, termenii care se adun\u0103 \u0219i cei care se scad se inverseaz\u0103.</p>","tags":["matematica","combinatorica","multimi"]},{"location":"mediu/pinex/#problema-prime-multiples","title":"Problema Prime Multiples","text":"<p>Pentru a afla c\u00e2te valori se \u00eempart la m\u0103car unul din cele \\(n\\) numere prime date, vom afla pentru fiecare submul\u021bime de numere c\u00e2te numere se \u00eempart la produsul numerelor din submul\u021bime, adun\u00e2nd sau sc\u0103z\u00e2nd din r\u0103spuns dup\u0103 caz. Pentru a face asta u\u0219or, vom reprezenta fiecare submul\u021bime folosind o masc\u0103 pe bi\u021bi, tehnic\u0103 explicat\u0103 \u00een acest articol. Singurul lucru la care trebuie avut grij\u0103 este ob\u021binerea produselor submul\u021bimilor, pentru a evita overflow-urile.</p> <pre><code>#include &lt;iostream&gt;\n#include &lt;vector&gt;\n\nusing namespace std;\n\nint main() {\n    long long n, k;\n    cin &gt;&gt; n &gt;&gt; k;\n\n    vector&lt;long long&gt; v(k);\n    for (int i = 0; i &lt; k; ++i) {\n        cin &gt;&gt; v[i];\n    }\n\n    long long sum = 0;\n    for (int msk = 1; msk &lt; (1 &lt;&lt; k); ++msk) {\n        long long prod = 1;\n        int cnt = 0;\n        for (int i = 0; i &lt; k; ++i) {\n            if (msk &amp; (1 &lt;&lt; i)) {\n                if (n / prod &lt; v[i]) {  // evitam overflowul\n                    prod = n + 1;\n                } else {\n                    prod = prod * v[i];\n                }\n                ++cnt;\n            }\n        }\n        if (cnt % 2 == 1) {\n            sum += n / prod;\n        } else {\n            sum -= n / prod;\n        }\n    }\n\n    cout &lt;&lt; sum;\n    return 0;\n}\n</code></pre>","tags":["matematica","combinatorica","multimi"]},{"location":"mediu/pinex/#aplicarea-pinex-in-probleme-mai-complexe","title":"Aplicarea PINEX \u00een probleme mai complexe","text":"<p>Pe l\u00e2ng\u0103 aplicarea func\u021biei M\u00f6bius \u00een problemele dificile ce folosesc PINEX, se mai reg\u0103se\u0219te o form\u0103 de aplicare a acestui principiu, atunci c\u00e2nd trebuie s\u0103 num\u0103r\u0103m c\u00e2te perechi sau mul\u021bimi de valori au o anumit\u0103 valoare a unei func\u021bii. De foarte multe ori, func\u021biile ce apar \u00een aceste probleme sunt multiplicative, deci scopul va fi acela de a exclude mul\u021bimile care au drept r\u0103spuns o valoare multiplu de num\u0103rul pe care \u00eel c\u0103ut\u0103m.</p>","tags":["matematica","combinatorica","multimi"]},{"location":"mediu/pinex/#problema-counting-coprime-pairs","title":"Problema Counting Coprime Pairs","text":"<p>Pentru a afla num\u0103rul de perechi de numere prime \u00eentre ele, vom afla pentru fiecare valoare posibil\u0103 a celui mai mare divizor comun c\u00e2te asemenea perechi exist\u0103. Pentru a face acest lucru, vom itera \u00een ordine descresc\u0103toare \u0219i vom afla mai \u00eent\u00e2i num\u0103rul de numere multiple cu \\(i\\) din \u0219irul dat, iar mai apoi vom sc\u0103dea din num\u0103rul de perechi posibile care se pot genera, num\u0103rul de perechi deja aflate la pa\u0219ii anteriori, c\u00e2nd am verificat valori mai mari ale celui mai mare divizor comun. Mai jos se poate vedea o asemenea implementare.</p> <pre><code>#include &lt;iostream&gt;\n#include &lt;vector&gt;\n\nusing namespace std;\n\nint main() {\n    vector&lt;long long&gt; fr(1000001), cnt(1000001);\n\n    int n;\n    cin &gt;&gt; n;\n\n    for (int i = 1; i &lt;= n; ++i) {\n        int val;\n        cin &gt;&gt; val;\n        fr[val]++;\n    }\n\n    long long ans = 1LL * n * (n - 1) / 2;\n    for (int i = 1000000; i &gt;= 2; --i) {\n        long long val = 0;\n        // aflam cate valori sunt multipli de i\n        for (int j = i; j &lt;= 1000000; j += i) {\n            val += fr[j];\n        }\n        cnt[i] = val * (val - 1) / 2;\n        // scadem perechile deja calculate\n        for (int j = i + i; j &lt;= 1000000; j += i) {\n            cnt[i] -= cnt[j];\n        }\n        ans -= cnt[i];\n    }\n\n    cout &lt;&lt; ans;\n    return 0;\n}\n</code></pre>","tags":["matematica","combinatorica","multimi"]},{"location":"mediu/pinex/#problema-rezolvata-lot-2024-juniori-pmo","title":"Problem\u0103 rezolvat\u0103 - Lot 2024 Juniori pmo","text":"<p>Mai \u00eent\u00e2i, vom fixa num\u0103rul de factori din produs. Fie acesta \\(i\\). Putem observa c\u0103 \\(i\\) este mai mic sau egal cu suma exponen\u021bilor din descompunerea \u00een factori primi a lui \\(x\\) (s\u0103 not\u0103m aceast\u0103 sum\u0103 cu \\(S\\)). Noi nu putem s\u0103 ne asigur\u0103m ca fiecare num\u0103r va fi mai mare ca 1 dec\u00e2t dac\u0103 ne asigur\u0103m c\u0103 fiecare num\u0103r are toate numerele prime din descompunerea lui \\(x\\) \u00een descompunerea lui.</p> <p>Noi vrem ca exact 0 din cele \\(i\\) elemente s\u0103 fie egale cu 1. Pentru a calcula acest num\u0103r, putem aplica PINEX \u00een func\u021bie de c\u00e2te elemente am fixat s\u0103 fie egale cu 1.</p> <p>Fie \\(f(n, i)\\) num\u0103rul de moduri de a \u00eemp\u0103r\u021bi num\u0103rul \\(n\\) \u00een produs de \\(i\\) elemente, care pot fi \u0219i egale cu 1.</p> <p>R\u0103spunsul va fi \\(\\sum _{i=1} ^S \\sum _{j=0} ^i \\ (-1)^j \\cdot C _i ^j \\cdot f(x, i-j)\\), deoarece putem alege cele \\(j\\) elemente care vor fi egale cu 1 \u00een \\(C _i ^j\\) moduri.</p> <p>Observa\u021bie</p> <p>S\u0103 calculam \\(f(n, i)\\). Fie \\(k\\) num\u0103rul de factori primi ai lui \\(n\\) \u0219i fie \\(exp_k\\) exponentul al celui de-al \\(k\\)-lea factor prim \u00een \\(n\\). Pentru a afla num\u0103rul, putem s\u0103 ne leg\u0103m de fiecare factor prim. Noi trebuie sa vedem c\u00e2\u021bi vectori (tablouri unidimensionale) de lungime \\(i\\) cu elemente posibil nule au suma elementelor egal\u0103 cu \\(exp_K\\). Aceast\u0103 formul\u0103 este studiat\u0103 \u00een articolul de Stars and Bars. A\u0219a c\u0103, num\u0103rul c\u0103utat va fi \\(\\prod _{j=1} ^k C _{exp_k+i-1} ^{i-1}\\).</p> <p>Observa\u021bie</p> <p>Descompunerea \u00een factori primi o vom face folosind numerele prime, pe care le vom precalcula folosind ciurul lui Eratostene.</p> <p>Observa\u021bie</p> <p>Unele calcule pot fi foarte mari, mai mari dec\u00e2t poate stoca tipul long long. De aceea, vom folosi __int128.</p> <p>Sursa de 100 de puncte:</p> <pre><code>#include &lt;algorithm&gt;\n#include &lt;fstream&gt;\n#include &lt;string&gt;\n\nstd::ifstream fin(\"pmo.in\");\nstd::ofstream fout(\"pmo.out\");\n\nstd::istream &amp;operator&gt;&gt;(std::istream &amp;in, __int128 &amp;n) {\n    int i;\n    std::string s;\n    in &gt;&gt; s;\n    n = 0;\n    for (i = 0; i &lt; (int)s.size(); i++) {\n        n = n * 10 + s[i] - '0';\n    }\n    return in;\n}\n\nstd::ostream &amp;operator&lt;&lt;(std::ostream &amp;out, __int128 n) {\n    std::string s = \"\";\n    do {\n        s.push_back('0' + n % 10);\n        n /= 10;\n    } while (n &gt; 0);\n    std::reverse(s.begin(), s.end());\n    out &lt;&lt; s;\n    return out;\n}\n\nconst int MAXP = 32'000;\nconst int MAXEXPS = 64;\n\nchar ciur[MAXP];\nint prime[MAXP], exps[MAXEXPS], sumexp, nfact;\nlong long comb[MAXEXPS][MAXEXPS];\n__int128 ways[MAXEXPS];  // ways[i] = nrmod de a scrie x ca prod de i nr\n\nvoid precomputeSieve() {\n    int i, j;\n    for (i = 2; i * i &lt; MAXP; i++) {\n        if (ciur[i] == 0) {\n            for (j = i * i; j &lt; MAXP; j += i) {\n                ciur[j] = 1;\n            }\n        }\n    }\n}\n\nvoid precomputePrimes() {\n    int i, p;\n    p = 0;\n    for (i = 2; i &lt; MAXP; i++) {\n        if (ciur[i] == 0) {\n            prime[p++] = i;\n        }\n    }\n}\n\nvoid precomputeComb() {\n    int i, j;\n    comb[0][0] = 1;\n    for (i = 1; i &lt; MAXEXPS; i++) {\n        comb[i][0] = 1;\n        for (j = 1; j &lt;= i; j++) {\n            comb[i][j] = comb[i - 1][j] + comb[i - 1][j - 1];\n        }\n    }\n}\n\nvoid precompute() {\n    precomputeSieve();\n    precomputePrimes();\n    precomputeComb();\n}\n\nvoid decomposeInPrimes(int val) {\n    int i;\n    nfact = i = sumexp = 0;\n    while (prime[i] * prime[i] &lt;= val) {\n        if (val % prime[i] == 0) {\n            exps[nfact] = 0;\n            do {\n                exps[nfact]++;\n                val /= prime[i];\n            } while (val % prime[i] == 0);\n            sumexp += exps[nfact++];\n        }\n        i++;\n    }\n    if (val &gt; 1) {\n        exps[nfact++] = 1;\n        sumexp++;\n    }\n}\n\nlong long starsAndBars(int n, int k) { return comb[n + k - 1][k - 1]; }\n\nvoid computeWays() {\n    int i, j;\n    for (i = 0; i &lt;= sumexp; i++) {\n        ways[i] = 1;\n        for (j = 0; j &lt; nfact; j++) {\n            ways[i] *= starsAndBars(exps[j], i);\n        }\n    }\n}\n\nvoid calcAnswer() {\n    int i, j;\n    __int128 answer, prod;\n    answer = 0;\n    for (i = 1; i &lt;= sumexp; i++) {\n        for (j = 0; j &lt; i; j++) {\n            prod = comb[i][j] * ways[i - j];\n            if (j % 2 == 0) {\n                answer += prod;\n            } else {\n                answer -= prod;\n            }\n        }\n    }\n    fout &lt;&lt; answer &lt;&lt; \"\\n\";\n}\n\nvoid answerQueries() {\n    int t, x;\n    fin &gt;&gt; t;\n    while (t--) {\n        fin &gt;&gt; x;\n        decomposeInPrimes(x);\n        computeWays();\n        calcAnswer();\n    }\n}\n\nint main() {\n    precompute();\n    answerQueries();\n    return 0;\n}\n</code></pre>","tags":["matematica","combinatorica","multimi"]},{"location":"mediu/pinex/#concluzii","title":"Concluzii","text":"<p>Principiul includerii \u0219i excluderii este un principiu ce se dovede\u0219te a fi util \u00een foarte multe probleme de num\u0103rare, cunoa\u0219terea acestuia dovedindu-se a fi esen\u021bial\u0103 \u00een multe probleme, \u00eencep\u00e2nd de la concursurile de juniori (lot, concursuri interna\u021bionale) \u0219i termin\u00e2nd cu diverse competi\u021bii online \u00een care teoria numerelor \u00ee\u0219i face apari\u021bia. Mai t\u00e2rziu, func\u021bii sau constante ce se bazeaz\u0103 pe PINEX vor demonstra o dat\u0103 \u00een plus utilitatea acestui principiu. Problemele de mai jos pot avea \u0219i alte abord\u0103ri, \u00een afar\u0103 de cea cu PINEX, toate fiind foarte utile \u0219i folositoare \u00een competi\u021biile de informatic\u0103.</p>","tags":["matematica","combinatorica","multimi"]},{"location":"mediu/pinex/#probleme-suplimentare","title":"Probleme suplimentare","text":"<ul> <li>infoarena frac</li> <li>infoarena reuniune</li> <li>infoarena pairs</li> <li>Codeforces Orac and LCM</li> <li>OJI 2024 Poseidon</li> <li>Codeforces Count GCD</li> <li>USACO Gold   Cowpability</li> <li>Codeforces Small GCD</li> <li>Lot Juniori 2015 cardinal</li> <li>Lot Juniori 2019 divizori</li> <li>Lot Juniori 2023 countall</li> <li>ONI 2023 Comun</li> <li>RoAlgo Contest #1 Echipe</li> <li>infoarena cowfood</li> <li>ONI 2023 Baraj Seniori Secvxor</li> <li>ONI 2019 TreeGCD</li> <li>ONI 2013 Xnumere</li> <li>kilonova polyglot</li> <li>Atcoder DP Contest Grid 2</li> <li>Probleme cu PINEX de pe Kilonova</li> </ul>","tags":["matematica","combinatorica","multimi"]},{"location":"mediu/pinex/#lectura-suplimentara","title":"Lectur\u0103 suplimentar\u0103","text":"<ul> <li>Pinex - Infoarena</li> <li>Inclusion-Exclusion Principle -   Codeforces</li> <li>The Inclusion-Exclusion Principle -   CP-algorithms</li> <li>Inclusion-Exclusion Principle - USACO   Guide</li> <li>PIE - University of   Victoria</li> <li>Principiul includerii \u0219i excluderii - Viitori   Olimpici</li> <li>Inclusion\u2013exclusion principle -   Wikipedia</li> <li>Principle of Inclusion and Exclusion (PIE) -   Brilliant</li> </ul>","tags":["matematica","combinatorica","multimi"]},{"location":"mediu/pow-log/","title":"Aritmetic\u0103 modular\u0103. Ridicare la putere \u00een timp logaritmic","text":"","tags":["algebra","optimizari","modulo"]},{"location":"mediu/pow-log/#introducere","title":"Introducere","text":"<p>De multe ori, suntem nevoi\u021bi s\u0103 calcul\u0103m diverse valori modulo \\(x\\) sau s\u0103 calcul\u0103m puteri foarte mari \u00eentr-o manier\u0103 care s\u0103 ne permit\u0103 s\u0103 ob\u021binem r\u0103spunsurile c\u00e2t mai rapid.</p> <p>Pentru a calcula aceste puteri, vom vrea s\u0103 optimiz\u0103m metoda clasic\u0103 de a \u00eenmul\u021bi rezultatul cu baza de fiecare dat\u0103 p\u00e2n\u0103 c\u00e2nd ajungem la r\u0103spunsul optim, a\u0219a c\u0103 se impune folosirea unor observa\u021bii matematice care ne ajut\u0103 s\u0103 calcul\u0103m expresii de acest gen mult mai rapid.</p>","tags":["algebra","optimizari","modulo"]},{"location":"mediu/pow-log/#fundamente-ale-calcului-modular","title":"Fundamente ale calcului modular","text":"<p>\u00cenainte s\u0103 prezent\u0103m subiectul articolului, trebuie s\u0103 prezent\u0103m ni\u0219te fundamente care ne vor ajuta s\u0103 \u00een\u021belegem mai bine conceptul de aici. Vom presupune c\u0103 \\(a\\) \u0219i \\(b\\) sunt numere naturale, cuprinse \u00eentre 0 \u0219i \\(mod - 1\\).</p>","tags":["algebra","optimizari","modulo"]},{"location":"mediu/pow-log/#adunarea-modulara","title":"Adunarea modular\u0103","text":"<p>Observa\u021bie</p> <p>\\((a + b)\\ \\% \\ mod = (a \\ \\% \\ mod + b \\ \\% \\ mod) \\ \\% \\ mod\\). Practic, dac\u0103 adun\u0103m dou\u0103 numere \u0219i facem modulo, e acela\u0219i lucru cu a face modulo separat, iar mai apoi, s\u0103 facem modulo la final.</p> <p>De multe ori, c\u00e2nd adun\u0103m dou\u0103 numere care sunt deja mai mici dec\u00e2t \\(mod\\), este de preferat s\u0103 evit\u0103m opera\u021bia \\(\\%\\) de la final, pentru a optimiza calculul aritmetic, deoarece operatorul \\(\\%\\) este foarte \u00eencet. Mai jos pute\u021bi g\u0103si un exemplu.</p> <pre><code>int sum = a + b;\nif (sum &gt;= mod) {  // mult mai rapid decat %\n    sum -= mod;\n}\n</code></pre>","tags":["algebra","optimizari","modulo"]},{"location":"mediu/pow-log/#scaderea-modulara","title":"Sc\u0103derea modular\u0103","text":"<p>Observa\u021bie</p> <p>\\((a - b)\\ \\% \\ mod = (a\\ \\% \\ mod - b \\ \\% \\ mod + mod) \\ \\% \\ mod\\). Practic, dac\u0103 sc\u0103dem dou\u0103 numere \u0219i facem modulo, e acela\u0219i lucru cu a face modulo separat, iar mai apoi, s\u0103 facem modulo la final.</p> <p>Spre deosebire de adunare, trebuie s\u0103 ad\u0103ug\u0103m un \\(mod\\) \u00een cazul \u00een care rezultatul devine negativ, deoarece spre deosebire de propriet\u0103\u021bile matematice, operatorul \\(\\%\\) poate returna valori negative \u00een limbajul C++. Ad\u0103ugarea acestui mod ne va ajuta s\u0103 avem rezultate non-negative. Implementarea va fi una asem\u0103n\u0103toare cu cea de la adunare.</p> <pre><code>int sum = a - b;\nif (sum &lt; 0) {  // mult mai rapid decat %\n    sum += mod;\n}\n</code></pre>","tags":["algebra","optimizari","modulo"]},{"location":"mediu/pow-log/#inmultirea-modulara","title":"\u00cenmul\u021birea modular\u0103","text":"<p>Observa\u021bie</p> <p>\\((a \\cdot b)\\ \\% \\ mod = ((a \\ \\% \\ mod) \\cdot (b \\ \\% \\ mod)) \\ \\% \\ mod\\). Practic, dac\u0103 \u00eenmul\u021bim dou\u0103 numere \u0219i facem modulo, e acela\u0219i lucru cu a face modulo separat, iar mai apoi, s\u0103 facem modulo la final.</p> <p>De\u0219i nu putem optimiza calculul modulului, trebuie s\u0103 fim aten\u021bi la posibilitatea ca rezultatul s\u0103 nu devin\u0103 mai mare dec\u00e2t valoarea maxim\u0103 a tipurilor de date folosite \u00een probleme (de regul\u0103, tipul int). Folosirea valorii <code>1LL</code> (scrierea lui 1 folosind tipul de date <code>long long</code>) rezolv\u0103 aceast\u0103 problem\u0103.</p> <pre><code>long long sum = (1LL * a * b) % mod;\n</code></pre>","tags":["algebra","optimizari","modulo"]},{"location":"mediu/pow-log/#impartirea-inversul-modular","title":"\u00cemp\u0103r\u021birea (inversul) modular","text":"<p>\u00cemp\u0103r\u021birea este cea mai grea opera\u021bie de manevrat \u00een cazul opera\u021biilor modulare, recomand\u0103m citirea articolului despre invers modular pentru mai multe detalii.</p>","tags":["algebra","optimizari","modulo"]},{"location":"mediu/pow-log/#ridicarea-la-putere-in-timp-logaritmic","title":"Ridicarea la putere \u00een timp logaritmic","text":"<p>Pentru a calcula expresia \\(a^n\\), o prim\u0103 variant\u0103 este aceea de a lucra folosind brute-force, complexitatea fiind \\(\\mathcal{O}(n)\\).</p> <pre><code>long long prod = 1;\nfor (int i = 1; i &lt;= n; i++) {\n    prod = (prod * a);\n}\n</code></pre> <p>Totu\u0219i, nu am folosit \u00eenc\u0103 o proprietate esen\u021bial\u0103 pentru a optimiza calculul de mai sus.</p> <p>Observa\u021bie</p> <p>\\(a^b = \\left(a^{\\frac{n}{2}}\\right)^2\\) cu alte cuvinte, dac\u0103 \\(n\\) este par, putem s\u0103 afl\u0103m \\(a^\\frac{n}{2}\\) \u0219i apoi s\u0103-l ridic\u0103m la p\u0103trat.</p> <p>Aceast\u0103 proprietate ne va ajuta s\u0103 deducem urm\u0103torul mod de a calcula \\(a^n\\) recursiv.</p> <p>\\(a^b\\) este egal cu una din urm\u0103toarele dou\u0103 expresii:</p> <ul> <li>\\(a^{n-1} \\cdot a\\), dac\u0103 \\(n\\) este impar.</li> <li>\\(({a^\\frac{n}{2}}) \\cdot ({a^\\frac{n}{2}})\\), dac\u0103 \\(n\\) este par.</li> </ul> <p>Pentru \\(n = 0\\), r\u0103spunsul este evident 1.</p> <p>Astfel, prin \u00eemp\u0103r\u021birile treptate la 2 ale exponentului, reducem complexitatea la \\(\\mathcal{O}(\\log n)\\), unde \\(n\\) este exponentul.</p> <p>Acest algoritm se poate implementa at\u00e2t recursiv, c\u00e2t \u0219i iterativ, acestea fiind func\u021biile folosite pentru problema Exponentiation de pe CSES</p> RecursivIterativ <pre><code>long long pw(long long a, long long n) {\n    if (n == 0) {\n        return 1;\n    }\n    if (n % 2 == 1) {\n        return (a * pw(a, n-1)) % mod;\n    }\n    // n par\n    long long x = pw(a, n/2);\n    return (x*x) % mod;\n}\n</code></pre> <pre><code>long long pw(long long a, long long n) {\n    long long ans = 1;\n    while (n &gt; 0) {\n        if (n % 2 == 1) { // alternativ, n&amp;1\n            ans = (ans * a) % mod;\n        }\n        a = (a * a) % mod;\n        n = n / 2; // alternativ, n &gt;&gt;= 1\n    }\n    return ans;\n}\n</code></pre>","tags":["algebra","optimizari","modulo"]},{"location":"mediu/pow-log/#concluzii","title":"Concluzii","text":"<p>Aritmetica modular\u0103 este esen\u021bial\u0103 pentru \u00een\u021belegerea calculelor de acest fel, care apar la foarte multe tipuri de probleme, precum cele la programarea dinamic\u0103, combinatoric\u0103 sau matematic\u0103 mai avansat\u0103. Ridicarea la putere \u00een timp logaritmic este o rutin\u0103 folosit\u0103 \u0219i ulterior, \u00een ceea ce prive\u0219te algebra liniar\u0103 \u0219i opera\u021bii combinatoriale.</p>","tags":["algebra","optimizari","modulo"]},{"location":"mediu/pow-log/#probleme-suplimentare","title":"Probleme suplimentare","text":"<ul> <li>CSES Exponentiation II</li> <li>Tema infogym</li> <li>modulo infoarena</li> <li>puteri2 pbinfo</li> <li>Santa's bot Codeforces</li> </ul>","tags":["algebra","optimizari","modulo"]},{"location":"mediu/pow-log/#lectura-suplimentara","title":"Lectur\u0103 suplimentar\u0103","text":"<ul> <li>Modular Arithmetic for Beginners   Codeforces</li> <li>Modular arithmetic USACO Guide</li> <li>Modular arithmetic   Wikipedia</li> <li>Ridicarea la putere in timp logaritmic - Sebastian   Popa</li> </ul>","tags":["algebra","optimizari","modulo"]},{"location":"mediu/queue/","title":"Coada","text":"","tags":["structuri de date","coada","STL"]},{"location":"mediu/queue/#introducere-si-definitie","title":"Introducere \u0219i defini\u021bie","text":"<p>Cu to\u021bii suntem obi\u0219nui\u021bi cu no\u021biunea de coad\u0103. Aproape \u00een fiecare zi, suntem nevoi\u021bi s\u0103 st\u0103m la coad\u0103, fie c\u0103 e vorba de cozi la magazin, la o cas\u0103 de bilete sau la un ghi\u0219eu. \u00cen fiecare dintre aceste situa\u021bii, ne a\u0219ez\u0103m \u00een spatele cozii, a\u0219tept\u0103m ca r\u00e2nd pe r\u00e2nd, cei din fa\u021ba noastr\u0103 s\u0103 ias\u0103 din coad\u0103, iar atunci c\u00e2nd ajungem primii in coad\u0103, s\u0103 fim servi\u021bi.</p> <p>\u00cen schimb, atunci c\u00e2nd vine vorba de informatic\u0103 \u0219i mai ales algoritmic\u0103, principiile cozilor sunt foarte utile \u00een ceea ce prive\u0219te reprezentarea datelor, f\u0103c\u00e2ndu-ne via\u021ba mult mai u\u0219oar\u0103 \u0219i deschiz\u00e2nd poarta spre foarte multe tipuri de aplica\u021bii.</p> <p>Coada este structura de date care pune la dispozi\u021bie informa\u021biile primite \u00een ordinea \u00een care au fost introduse.</p> <p>Ea func\u021bioneaz\u0103 pe principiul \u201cprimul venit, primul servit\u201d (First In, First Out/FIFO).</p>","tags":["structuri de date","coada","STL"]},{"location":"mediu/queue/#operatii-cu-coada","title":"Opera\u021bii cu coada","text":"<p>Cu o coad\u0103 se pot face urm\u0103toarele opera\u021bii \u00een timp constant:</p> <ul> <li>ad\u0103ugarea unui nou element \u00een spatele cozii. Opera\u021bia se nume\u0219te push;</li> <li>eliminarea elementului din v\u00e2rful cozii. Opera\u021bia se nume\u0219te pop;</li> <li>accesarea valorii din v\u00e2rful cozii. Opera\u021bia se nume\u0219te front;</li> </ul> <p>Ca o consecin\u021b\u0103 a acestor opera\u021bii principale, putem face \u0219i urm\u0103toarele lucruri:</p> <ul> <li>ini\u021bializarea cozii \u2013 crearea unei cozi vide;</li> <li>verificarea faptului c\u0103 o coad\u0103 este sau nu vid\u0103;</li> </ul>","tags":["structuri de date","coada","STL"]},{"location":"mediu/queue/#modul-de-folosire-si-implementare-al-cozii","title":"Modul de folosire \u0219i implementare al cozii","text":"<p>Pentru a folosi o coad\u0103, avem nevoie de o metod\u0103 de a o implementa. Dou\u0103 dintre cele mai des \u00eent\u00e2lnite variante de a implementa o coad\u0103 sunt varianta static\u0103, folosind tablouri (eventual circulare) sau folosind containerul queue din STL.</p> <p>\u00cen cele ce urmeaz\u0103, vom prezenta aceste implement\u0103ri folosind problema coada de pe pbinfo, aceasta fiind o problem\u0103 de baz\u0103 care ne ajut\u0103 s\u0103 putem explica diferen\u021bele \u00eentre diverse metode de a implementa aceast\u0103 structur\u0103 de date.</p>","tags":["structuri de date","coada","STL"]},{"location":"mediu/queue/#coada-cu-tablouri","title":"Coada cu tablouri","text":"<p>O prim\u0103 metod\u0103 de a implementa o coad\u0103, f\u0103r\u0103 folosirea vreunei instruc\u021biuni avansate este cea care folose\u0219te tablouri, \u021bin\u00e2nd pozi\u021biile \u00een care se afl\u0103 primul \u0219i ultimul element din coad\u0103.</p> <p>Aici se poate observa faptul c\u0103 folosim un tablou de dimensiune fix\u0103, iar atunci c\u00e2nd ad\u0103ug\u0103m \u0219i scoatem valori din coad\u0103, ajust\u0103m valorile lui \\(L\\) \u0219i \\(R\\).</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int n, q[1000001], L = 0, R = 0;\n    cin &gt;&gt; n;\n\n    while (n--) {\n        char c[6];\n        cin &gt;&gt; c;\n\n        // afisam prima valoare a cozii\n        if (c[0] == 'f') {\n            cout &lt;&lt; q[L] &lt;&lt; '\\n';\n        } else {\n            // adaugam o noua valoare si crestem R\n            if (c[1] == 'u') {\n                int val;\n                cin &gt;&gt; val;\n                q[R++] = val;\n            }\n            // scoatem o valoare si crestem L\n            else {\n                L++;\n            }\n        }\n    }\n    return 0;\n}\n</code></pre>","tags":["structuri de date","coada","STL"]},{"location":"mediu/queue/#coada-circulara","title":"Coada circular\u0103","text":"<p>O \u00eembun\u0103t\u0103\u021bire pe care o putem face la aceast\u0103 implementare const\u0103 \u00een a refolosi memoria dac\u0103 \u0219tim dimensiunea maxim\u0103 pe care o poate avea coada la un moment dat. Astfel, \u00een loc s\u0103 stoc\u0103m cantitatea maxim\u0103 de valori care intr\u0103 in coad\u0103, stoc\u0103m doar dimensiunea maxim\u0103 a datelor, iar pentru a ajusta valorile lui \\(L\\) \u0219i \\(R\\), le vom ajusta circular, astfel limit\u00e2nd memoria folosit\u0103.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int n, q[1001], L = 0, R = 0, maxi = 1001;\n    cin &gt;&gt; n;\n\n    while (n--) {\n        char c[6];\n        cin &gt;&gt; c;\n\n        // afisam prima valoare a cozii\n        if (c[0] == 'f') {\n            cout &lt;&lt; q[L] &lt;&lt; '\\n';\n        } else {\n            // adaugam o noua valoare si crestem R\n            if (c[1] == 'u') {\n                int val;\n                cin &gt;&gt; val;\n                q[R] = val;\n                R++;\n                if (R &gt;= maxi) {\n                    R -= maxi;\n                }\n            }\n            // scoatem o valoare si crestem L\n            else {\n                L++;\n                if (L &gt;= maxi) {\n                    L -= maxi;\n                }\n            }\n        }\n    }\n    return 0;\n}\n</code></pre>","tags":["structuri de date","coada","STL"]},{"location":"mediu/queue/#coada-implementata-cu-stdqueue","title":"Coada implementat\u0103 cu std::queue","text":"<p>Primele dou\u0103 implement\u0103ri, de\u0219i utile \u0219i corecte, au un mare dezavantaj, practic la fel ca la orice structur\u0103 de date static\u0103, trebuie s\u0103 estim\u0103m c\u00e2te valori vom avea. Astfel, se impune introducerea unei implement\u0103ri dinamice, care s\u0103 elimine acest dezavantaj, iar o metod\u0103 de a implementa coada folosind STL const\u0103 \u00een folosirea containerului std::queue, acesta fiind specializat pentru opera\u021biile descrise mai sus, p\u0103str\u00e2nd toate avantajele cozii, ad\u0103ug\u00e2ndu-se faptul c\u0103 memoria de care avem nevoie este doar cea pe care o folosim la un moment dat, f\u0103r\u0103 spa\u021biu suplimentar folosit.</p> <p>Pentru implementarea std::queue, vom avea nevoie de biblioteca queue, precum \u0219i cunoa\u0219terea func\u021biilor specifice, push, pop \u0219i front.</p> <pre><code>#include &lt;iostream&gt;\n#include &lt;queue&gt;\n\nusing namespace std;\n\nint main() {\n    int n;\n    cin &gt;&gt; n;\n\n    queue&lt;int&gt; q;\n\n    while (n--) {\n        char c[6];\n        cin &gt;&gt; c;\n\n        // afisam prima valoare a cozii\n        if (c[0] == 'f') {\n            cout &lt;&lt; q.front() &lt;&lt; '\\n';\n        } else {\n            // adaugam o noua valoare si crestem R\n            if (c[1] == 'u') {\n                int val;\n                cin &gt;&gt; val;\n                q.push(val);\n            }\n            // scoatem o valoare si crestem L\n            else {\n                q.pop();\n            }\n        }\n    }\n    return 0;\n}\n</code></pre>","tags":["structuri de date","coada","STL"]},{"location":"mediu/queue/#aplicatii-ale-cozii","title":"Aplica\u021bii ale cozii","text":"<p>Coada se reg\u0103se\u0219te ca o aplica\u021bie pentru tot ce \u00eenseamn\u0103 p\u0103strarea datelor \u00eentr-o ordine cronologic\u0103, fie c\u0103 e vorba de evenimente, st\u0103ri, pozi\u021bii sau alte informa\u021bii similare. Datorit\u0103 versatilit\u0103\u021bii sale, putem s\u0103 o folosim \u00een combina\u021bie cu stiva, problemele ce constau \u00een implementarea cozii cu stive \u0219i invers sunt foarte cunoscute \u0219i deschid u\u0219a c\u0103tre idei foarte importante, a\u0219a cum se poate observa \u0219i \u00een problemele de pe Leetcode men\u021bionate mai jos.</p> <p>Dintre cei mai importan\u021bi algoritmi ce au la baz\u0103 o coad\u0103, vom men\u021biona parcurgerea \u00een l\u0103\u021bime (BFS), \u00eempreun\u0103 cu varianta ei pe matrice, algoritmul lui Lee \u0219i in general, Flood Fill. Pentru mai multe detalii, pute\u021bi explora acest articol.</p> <p>Nu \u00een ultimul r\u00e2nd, coada este o structur\u0103 de date ce apare \u00een diverse probleme de simulare a unui proces sau \u00een anumite tipuri de probleme ce folosesc tehnici de tipul Sliding Window, deque-ul fiind o structur\u0103 de date specializat\u0103 pe asemenea algoritmi, a\u0219a cum este prezentat\u0103 \u0219i aici.</p>","tags":["structuri de date","coada","STL"]},{"location":"mediu/queue/#probleme-cu-coada","title":"Probleme cu coad\u0103","text":"<ul> <li>Coada1 pbinfo</li> <li>Implement Queue using Stacks -   Leetcode</li> <li>Implement Stack using Queues -   Leetcode</li> </ul>","tags":["structuri de date","coada","STL"]},{"location":"mediu/queue/#lectura-suplimentara","title":"Lectur\u0103 suplimentar\u0103","text":"<ul> <li>Tipul coada -   algopedia</li> <li>Coada - pbinfo</li> <li>Queue - wikipedia</li> </ul>","tags":["structuri de date","coada","STL"]},{"location":"mediu/rerooting/","title":"Tehnica celor dou\u0103 DFS-uri (rerooting)","text":"<p>\u00cen ceea ce prive\u0219te rezolvarea problemelor cu arbori, in anumite situatii se poate observa faptul c\u0103 avem nevoie de o calculare ini\u021bial\u0103 a r\u0103spunsului presupun\u00e2nd r\u0103d\u0103cina \u00eentr-un nod oarecare (de regul\u0103, nodul 1), urmat\u0103 de folosirea acestor r\u0103spunsuri pentru generalizarea rezultatelor pentru toate r\u0103d\u0103cinile posibile. Vom numi tehnica pe care o folosim pentru aceste probleme rerooting, sau a\u0219a cum este cunoscut\u0103 \u00een jargonul rom\u00e2nesc, tehnica celor dou\u0103 DFS-uri.</p> <p>\u00cen cele ce urmeaz\u0103, vom prezenta c\u00e2teva exemple de probleme care se pot rezolva folosind aceast\u0103 tehnic\u0103, \u00eempreun\u0103 cu abord\u0103rile posibile. Se va putea observa faptul c\u0103 \u00een cele mai multe situa\u021bii, implementarea va fi una foarte similar\u0103, singurele modific\u0103ri fiind f\u0103cute la modul \u00een care vom defini dinamicile \u0219i alte date pe care le folosim.</p>","tags":["grafuri","arbori","programare dinamica"]},{"location":"mediu/rerooting/#problema-tree-distances-de-pe-cses","title":"Problema Tree Distances de pe CSES","text":"<p>Observa\u021bie</p> <p>Aceast\u0103 problem\u0103 are o solu\u021bie video explicat\u0103 chiar de autor, pe care o pute\u021bi accesa aici</p> <p>Pentru a rezolva problema, vom putea folosi o abordare de tip rerooting, dup\u0103 cum urmeaz\u0103:</p> <p>Mai \u00eent\u00e2i, vom precalcula folosind un DFS dintr-un nod oarecare distan\u021ba fa\u021b\u0103 de cea mai \u00eendep\u0103rtat\u0103 frunz\u0103 pentru fiecare nod, acest lucru se poate face foarte u\u0219or dac\u0103 \u021binem \u00eentr-un vector distan\u021bele maxime, \\(maxdist[i]\\) fiind distan\u021ba maxim\u0103 de la nodul \\(i\\) la o frunz\u0103 din subarborele nodului \\(i\\).</p> <p>Calculul acestei valori se poate face destul de simplu, deoarece pentru fiecare nod \\(i\\), vom \u0219ti deja valoarea lui \\(maxdist\\) pentru to\u021bi fiii acestuia, tot ce ne r\u0103m\u00e2ne de f\u0103cut este s\u0103 adun\u0103m 1 la aceste valori. Evident, pentru o frunz\u0103, \\(maxdist[i] = 0\\).</p> <p>Observa\u021bie</p> <p>Se poate observa faptul c\u0103 \u00een codul de mai jos am ales drept r\u0103d\u0103cin\u0103 nodul 1, aceasta fiind o conven\u021bie utilizat\u0103 \u00een cele mai multe probleme cu arbori, chiar \u0219i atunci c\u00e2nd nu ni se precizeaz\u0103 \u00een mod specific r\u0103d\u0103cina arborelui.</p> <p>Dup\u0103 ce am aflat valorile din vectorul \\(maxdist\\), acum va trebui s\u0103 folosim aceste r\u0103spunsuri pentru a afla pentru fiecare nod distan\u021ba fa\u021b\u0103 de cel mai \u00eendep\u0103rtat nod care nu se afl\u0103 \u00een subarborele nodului curent (la primul DFS am aflat aceast\u0103 distan\u021b\u0103 fa\u021b\u0103 de nodurile care se aflau \u00een subarborele nodului curent).</p> <p>Pentru a face asta, vom avea nevoie s\u0103 \u021binem ca un parametru suplimentar \u00een cea de-a doua parcurgere DFS distan\u021ba maxim\u0103 de la nodul curent la un nod care nu se afl\u0103 \u00een subarborele s\u0103u, ini\u021bial aceast\u0103 distan\u021b\u0103 fiind 0 pentru nodul 1. Vom nota aceast\u0103 distan\u021b\u0103 \\(distUp\\).</p> <p>Calcularea acestor distan\u021be pentru celelalte noduri se va face din aproape \u00een aproape, \u021bin\u00e2nd cont de urm\u0103toarele observa\u021bii:</p> <ul> <li>Pentru un nod, doar cele mai \u00eendep\u0103rta\u021bi doi subarbori sunt relevan\u021bi,   deoarece \u00een cazul celorlal\u021bi subarbori, putem oric\u00e2nd s\u0103 folosim ca etalon   unul din primii doi subarbori.</li> <li>Pe m\u0103sur\u0103 ce ne apropiem de frunze, distan\u021ba pe care o avem deja anterior   calculat\u0103 va cre\u0219te, singurul mod \u00een care poate cre\u0219te mai mult este dac\u0103   pentru un fiu \\(x\\), avem un alt fiu \\(y\\) cu proprietatea c\u0103 \\(maxdist[y] + 1 &gt;   distUp\\), motivul fiind acela c\u0103 atunci c\u00e2nd am cobor\u00ee spre frunze, frunza din   subarborele lui \\(y\\) ar fi mai \u00eendep\u0103rtat\u0103.</li> <li>Dac\u0103 vrem s\u0103 ajungem la fiul care ne-a dat \\(maxdist[nod]\\), va trebui s\u0103   folosim a doua distan\u021b\u0103 pentru a calcula noua valoare a lui \\(distUp\\), pentru a   evita situa\u021bia \u00een care num\u0103r\u0103m acelea\u0219i muchii de mai multe ori.</li> </ul> <p>Aceste observa\u021bii sunt puse laolalt\u0103 \u00een codul de mai jos, se poate observa faptul c\u0103 de\u0219i conceptul pare unul mai complicat, tot ce trebuie s\u0103 facem este s\u0103 observ\u0103m cu aten\u021bie ce se \u00eent\u00e2mpl\u0103 atunci c\u00e2nd ajungem de la un nod la altul.</p> <pre><code>#include &lt;iostream&gt;\n#include &lt;vector&gt;\n\nusing namespace std;\n\nint n;\nvector&lt;vector&lt;int&gt; &gt; tree;\nvector&lt;int&gt; maxdist, ans;\n\nvoid dfs(int parent, int node) {\n    for (int i = 0; i &lt; (int)tree[node].size(); i++) {\n        int nxt = tree[node][i];\n        if (nxt == parent) {\n            continue;\n        }\n        dfs(node, nxt);\n        maxdist[node] = max(maxdist[node], maxdist[nxt] + 1);\n    }\n}\n\nvoid dfs2(int parent, int node, int distUp) {\n    ans[node] = max(maxdist[node], distUp);\n    int max1 = 0, max2 = 0;\n    // cele mai mari doua distante fata de subarborii nodului curent\n    for (int i = 0; i &lt; (int)tree[node].size(); i++) {\n        int nxt = tree[node][i];\n        if (nxt == parent) {\n            continue;\n        }\n        // verificam daca distanta e mai mare decat a uneia din primele doua\n        if (maxdist[nxt] + 1 &gt; max1) {\n            max2 = max1;\n            max1 = maxdist[nxt] + 1;\n        } else {\n            if (maxdist[nxt] + 1 &gt; max2) {\n                max2 = maxdist[nxt] + 1;\n            }\n        }\n    }\n\n    for (int i = 0; i &lt; (int)tree[node].size(); i++) {\n        int nxt = tree[node][i];\n        if (nxt == parent) {\n            continue;\n        }\n        // daca nodul curent este cel care ne-a dat distanta maxima\n        if (maxdist[nxt] + 1 == max1) {\n            dfs2(node, nxt, max(distUp, max2) + 1);\n        } else {\n            dfs2(node, nxt, max(distUp, max1) + 1);\n        }\n    }\n}\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n\n    cin &gt;&gt; n;\n    tree.resize(n + 1);\n    maxdist.resize(n + 1);\n    ans.resize(n + 1);\n\n    for (int i = 1; i &lt; n; i++) {\n        int a, b;\n        cin &gt;&gt; a &gt;&gt; b;\n        tree[a].push_back(b);\n        tree[b].push_back(a);\n    }\n\n    dfs(0, 1);\n    dfs2(0, 1, 0);\n\n    for (int i = 1; i &lt;= n; i++) {\n        cout &lt;&lt; ans[i] &lt;&lt; \" \";\n    }\n    return 0;\n}\n</code></pre>","tags":["grafuri","arbori","programare dinamica"]},{"location":"mediu/rerooting/#problema-subtree-de-pe-atcoder","title":"Problema Subtree de pe AtCoder","text":"<p>S\u0103 consider\u0103m o problem\u0103 mai simpl\u0103:</p> <p>Presupun\u00e2nd c\u0103 nodul 1 este colorat negru, \u00een c\u00e2te moduri putem colora arborele?</p> <p>Mai \u00eent\u00e2i, fix\u0103m r\u0103d\u0103cina arborelui \u00een nodul 1. Fie \\(dp[i]\\) num\u0103rul de moduri \u00een care putem colora subarborele nodului \\(i\\) astfel \u00eenc\u00e2t fie nodul \\(i\\) este colorat negru, fie niciun nod nu este colorat negru. Observa\u021bi c\u0103, dac\u0103 \\(i\\) este o frunz\u0103, atunci \\(dp[i]=2\\) (alegem s\u0103 color\u0103m nodul \\(i\\) negru sau nu).</p> <p>Pentru fiecare copil \\(c\\) al lui \\(i\\), exist\u0103 \\(dp[c]\\) moduri de a colora subarborele s\u0103u dac\u0103 \\(i\\) este colorat negru. Acest lucru \u00eenseamn\u0103 c\u0103 avem recuren\u021ba</p> \\[ dp[i]=1+\\prod_{c \\in \\text{Copiii lui } i} dp[c] \\] <p>unde produsul corespunde color\u0103rii nodului \\(i\\) \u00een negru, iar 1 corespunde color\u0103rii nodului \\(i\\) \u00een alb.</p> <p>R\u0103spunsul la problema mai simpl\u0103 este astfel \\(dp[1]-1\\). Calculul tuturor valorilor \\(dp[i]\\) se poate face \u00een \\(\\mathcal{O}(N)\\).</p>","tags":["grafuri","arbori","programare dinamica"]},{"location":"mediu/rerooting/#rezolvarea-pentru-toate-radacinile","title":"Rezolvarea pentru toate r\u0103d\u0103cinile","text":"<p>Mai \u00eent\u00e2i, fix\u0103m r\u0103d\u0103cina arborele arbitrar \u0219i facem un DFS pentru a calcula toate valorile \\(dp[i]\\).</p> <p>Fie \\(dp2[i]\\) num\u0103rul de moduri \u00een care putem colora arborele dac\u0103 elimin\u0103m subarborele nodului \\(i\\) astfel \u00eenc\u00e2t fie p\u0103rintele lui \\(i\\) este negru, fie niciun nod nu este colorat negru. Observa\u021bi c\u0103 \\(dp2[1]=1\\).</p> <p>Num\u0103rul de moduri \u00een care putem colora arborele dac\u0103 \u0219tim c\u0103 nodul \\(i\\) este negru este pur \u0219i simplu \\((dp[i]-1)\\cdot dp2[i]\\). Cum putem \u00eens\u0103 calcula eficient \\(dp2[i]\\)?</p> <p>Recuren\u021ba de baz\u0103 pentru a calcula \\(dp2[i]\\) este</p> \\[ dp2[i] = 1+dp2[\\text{P\u0103rintele lui } i] \\cdot \\prod_{s \\in \\text{Fra\u021bii lui } i} dp[s] \\] <p>unde produsul corespunde color\u0103rii p\u0103rintelui lui \\(i\\) \u00een negru, iar 1 corespunde color\u0103rii p\u0103rintelui lui \\(i\\) \u00een alb.</p> <p>Totu\u0219i, deoarece \\(M\\) nu este garantat a fi prim, nu putem pur \u0219i simplu s\u0103 g\u0103sim produsul copiilor unui nod \u0219i s\u0103 \u00eemp\u0103r\u021bim acel produs la \\(dp[i]\\) pentru fiecare copil (deoarece nu putem g\u0103si inversul modular u\u0219or).</p> <p>Cu toate acestea, observa\u021bi c\u0103 dac\u0103 nodul \\(i\\) este al \\(k\\)-lea copil al p\u0103rintelui s\u0103u, putem folosi produse prefix \u0219i sufix pentru a calcula</p> \\[ \\prod_{s \\in \\text{Fra\u021bii lui } i}dp[s] \\] <p>f\u0103r\u0103 a folosi \u00eemp\u0103r\u021birea. (Adic\u0103 g\u0103sim produsul lui \\(dp[s]\\) pentru fra\u021bii de la primul la al \\((k - 1)\\)-lea copil al p\u0103rintelui lui \\(i\\), produsul lui \\(dp[s]\\) pentru fra\u021bii de la al \\((k + 1)\\)-lea la ultimul copil al p\u0103rintelui lui \\(i\\), \u0219i apoi le \u00eenmul\u021bim \u00eentre ele.)</p> <p>Calculul tuturor valorilor \\(dp2[i]\\) necesit\u0103 \\(\\mathcal{O}(N)\\) folosind un DFS, astfel \u00eenc\u00e2t complexitatea total\u0103 a acestui algoritm este \\(\\mathcal{O}(N)\\).</p> <pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n\nint n, mod;\nstruct Node {\n    vector&lt;int&gt; adj;\n    vector&lt;int&gt; l, r;\n    int down, up;\n} nodes[100001];\n\nvoid dfs1(int nod, int tt) {\n    nodes[nod].down = 1;\n    for (auto &amp;c : nodes[nod].adj) {\n        if (c != tt) {\n            dfs1(c, nod);\n            nodes[nod].down =\n                (1LL * nodes[nod].down * (nodes[c].down + 1)) % mod;\n        }\n    }\n\n    // scoatem parintele\n    vector&lt;int&gt;::iterator it =\n        find(nodes[nod].adj.begin(), nodes[nod].adj.end(), tt);\n    if (it != nodes[nod].adj.end()) {\n        nodes[nod].adj.erase(it);\n    }\n}\n\nvoid dfs2(int nod, int tt) {\n    int sz = nodes[nod].adj.size();\n    if (sz == 0) {\n        return;\n    }\n    nodes[nod].l.assign(sz, 0);\n    nodes[nod].r.assign(sz, 0);\n\n    nodes[nod].l[0] = nodes[nod].up;\n    for (int i = 1; i &lt; sz; i++) {\n        nodes[nod].l[i] = (1LL * nodes[nod].l[i - 1]\n                           * (nodes[nodes[nod].adj[i - 1]].down + 1))\n                        % mod;\n    }\n\n    nodes[nod].r[sz - 1] = 1;\n    for (int i = sz - 2; i &gt;= 0; i--) {\n        nodes[nod].r[i] = (1LL * nodes[nod].r[i + 1]\n                           * (nodes[nodes[nod].adj[i + 1]].down + 1))\n                        % mod;\n    }\n\n    for (int i = 0; i &lt; sz; i++) {\n        int next = nodes[nod].adj[i];\n        nodes[next].up = ((1LL * nodes[nod].l[i] * nodes[nod].r[i]) + 1) % mod;\n        dfs2(next, nod);\n    }\n}\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n\n    cin &gt;&gt; n &gt;&gt; mod;\n    for (int i = 1; i &lt; n; i++) {\n        int x, y;\n        cin &gt;&gt; x &gt;&gt; y;\n        x--;\n        y--;\n        nodes[x].adj.push_back(y);\n        nodes[y].adj.push_back(x);\n    }\n    dfs1(0, 0);\n    nodes[0].up = 1;\n    dfs2(0, 0);\n    for (int i = 0; i &lt; n; i++) {\n        cout &lt;&lt; (1LL * nodes[i].down * nodes[i].up) % mod &lt;&lt; '\\n';\n    }\n    return 0;\n}\n</code></pre>","tags":["grafuri","arbori","programare dinamica"]},{"location":"mediu/rerooting/#concluzii","title":"Concluzii","text":"<p>Tehnica rerooting este o tehnic\u0103 folositoare \u00een anumite tipuri de probleme cu arbori, de multe ori o precalculare relativ simpl\u0103 poate reprezenta un pas important spre rezolvarea unor probleme foarte complicate de acest fel. De\u0219i nu este o tehnic\u0103 la fel de des \u00eent\u00e2lnit\u0103 precum alte varia\u021bii ale dinamicii pe arbore, apare suficient de des \u00eenc\u00e2t s\u0103 se justifice discu\u021bia ei separat\u0103.</p>","tags":["grafuri","arbori","programare dinamica"]},{"location":"mediu/rerooting/#probleme-suplimentare","title":"Probleme suplimentare","text":"<ul> <li>infoarena razboiul lumilor</li> <li>Codeforces Jovial Jaunt</li> <li>ONI 2003 asmin</li> <li>Codeforces Tree with Maximum   Cost</li> <li>infoarena treesearch</li> <li>USACO Gold Directory   Traversal</li> <li>Codeforces Two Paths</li> <li>ONI 2015 arbvalmax</li> <li>AtCoder Expensive Expense</li> <li>BOI 2017 City Attractions</li> <li>Codeforces Road Improvement</li> <li>APIO 2010 Patrol</li> </ul>","tags":["grafuri","arbori","programare dinamica"]},{"location":"mediu/rerooting/#lectura-suplimentara","title":"Lectur\u0103 suplimentar\u0103","text":"<ul> <li>Rerooting DP - USACO Guide</li> <li>The Ultimate Reroot Template -   Codeforces</li> <li>Rerooting Technique - YouKn0wWho   Academy</li> <li>Online Query Based Rerooting   Technique</li> <li>Rerooting DP - Codeforces/Youtube</li> </ul>","tags":["grafuri","arbori","programare dinamica"]},{"location":"mediu/shortest-path/","title":"Algoritmi pentru drumuri minime","text":"<p>Aflarea drumului minim \u00eentre dou\u0103 sau mai multe loca\u021bii este una dintre cele mai importante probleme pe care oamenii au fost nevoi\u021bi s\u0103 le rezolve de-a lungul istoriei, \u00eencep\u00e2nd din timpurile preistorice \u00een care comunicarea era limitat\u0103 \u0219i p\u00e2n\u0103 \u00een zilele noastre, c\u00e2nd avem foarte multe facilit\u0103\u021bi la dispozi\u021bie. \u00cen func\u021bie de criteriul ales, ne putem g\u00e2ndi la distan\u021ba minim\u0103, timpul minim de parcurgere al unui traseu sau alte criterii, precum dificultatea de parcurgere a drumului ales etc.</p> <p>Exemplu</p> <p>De exemplu, s\u0103 presupunem c\u0103 vrei s\u0103 parcurgi drumul Piatra Neam\u021b - Bra\u0219ov. Acest traseu poate fi parcurs \u00een dou\u0103 moduri principale, fiecare cu avantajele \u0219i dezavantajele lui.</p> <ul> <li>Piatra Neam\u021b - Miercurea Ciuc - Bra\u0219ov: 238km, timp de parcurgere: 4h,   traseu dificil</li> <li>Piatra Neam\u021b - Bac\u0103u - Bra\u0219ov: 239km, timp de parcurgere: 4h20m, traseu   ceva mai u\u0219or</li> </ul> <p>Chiar dac\u0103 cele dou\u0103 drumuri au o distan\u021b\u0103 identic\u0103, diferen\u021ba este dat\u0103 de timpul de parcurgere \u0219i de dificultatea traseului \u00een sine. De\u0219i primul traseu necesit\u0103 mai pu\u021bin timp pentru parcurgerea lui, cel de-al doilea traseu este semnificativ mai u\u0219or din punct de vedere al dificult\u0103\u021bii din punct de vedere rutier (dup\u0103 p\u0103rerea autorului), fapt ce \u00eei d\u0103 un cost mai mic, fiind preferat primului, \u00een ciuda timpului \u0219i distan\u021bei mai mari.</p> <p>\u00cen cele ce urmeaz\u0103, vom discuta despre algoritmii ce ne ajut\u0103 s\u0103 afl\u0103m drumuri minime, model\u00e2nd aceste probleme folosind grafurile orientate \u0219i neorientate, prezent\u00e2nd avantajele \u0219i dezavantajele fiec\u0103rui algoritm.</p>","tags":["grafuri","drumuri minime","dijsktra"]},{"location":"mediu/shortest-path/#introducere","title":"Introducere","text":"<p>De regul\u0103, atunci c\u00e2nd vorbim de drumuri minime, vorbim de muchii care au asociate costuri. Pentru a \u00een\u021belege mai u\u0219or no\u021biunea de cost pentru o muchie, ne vom raporta la exemplul folosit anterior.</p> <p>Defini\u021bie</p> <p>Un drum minim \u00eentre dou\u0103 noduri \\(a\\) \u0219i \\(b\\) este un lan\u021b simplu cu capetele \u00een \\(a\\) \u0219i \\(b\\) cu proprietatea c\u0103 costul total al muchiilor de pe lan\u021b este minim.</p> <p>Observa\u021bie</p> <p>Dac\u0103 nu se specific\u0103 un asemenea cost, presupunem c\u0103 costul fiec\u0103rei muchii este egal cu 1.</p> <p>Pentru a p\u0103stra \u00een memorie costul unei muchii, vom \u021bine o variabil\u0103 \u00een plus, astfel vom fi nevoi\u021bi s\u0103 lucr\u0103m cu structuri sau cu tipuri precum pair, dup\u0103 preferin\u021be.</p> <p>Fie c\u0103 e vorba de aflarea drumului minim \u00eentre dou\u0103 noduri, toate nodurile sau dac\u0103 vrem pur \u0219i simplu s\u0103 verific\u0103m anumite propriet\u0103\u021bi, algoritmii pe care \u00eei vom prezenta se vor dovedi a fi solu\u021bii utile, fiecare dintre ei av\u00e2nd avantajele \u0219i dezavantajele lor.  </p>","tags":["grafuri","drumuri minime","dijsktra"]},{"location":"mediu/shortest-path/#algoritmul-lui-dijkstra","title":"Algoritmul lui Dijkstra","text":"<p>De departe cel mai cunoscut algoritm pentru aflarea drumului minim \u00eentre dou\u0103 noduri, algoritmul lui Dijsktra este folosit atunci c\u00e2nd avem de-a face cu costuri pozitive, condi\u021bia minim\u0103 necesar\u0103 este aceea s\u0103 nu avem cicluri negative.</p> <p>Observa\u021bie</p> <p>Algoritmul este numit dup\u0103 un informatician olandez, iar o pronun\u021bie corect\u0103 a numelui lui este \"daikstra\" (pentru fanii fotbalului, g\u00e2ndi\u021bi-v\u0103 la Virgil Van Dijk), nu \"di\u0219tra\", \"jikstra\" sau alte variante total gre\u0219ite, care sunt folosite foarte des.</p> <p>Defini\u021bie</p> <p>Un ciclu negativ este un ciclu cu proprietatea c\u0103 suma costurilor muchiilor de pe ciclu este negativ\u0103.</p> <p>Modul de func\u021bionare al algoritmului este unul foarte simplu:</p> <ul> <li>Pentru fiecare nod, vom \u021bine un cost total p\u00e2n\u0103 la el, la \u00eenceput acesta va fi   ini\u021bializat pentru toate nodurile cu valori mari, cu excep\u021bia nodului (sau   nodurilor) start, care vor avea costul ini\u021bial 0.</li> <li>C\u00e2t timp nu am vizitat toate nodurile, alegem nodul cu costul total dintre   cele nealese. Dac\u0103 exist\u0103 mai multe asemenea noduri, oricare poate fi ales.</li> <li>Pentru nodul ales, vom vizita toate nodurile nevizitate, vecine cu el \u0219i   verific\u0103m pentru fiecare dintre ele dac\u0103 costul total pentru acel nod devine   mai mic.</li> </ul>","tags":["grafuri","drumuri minime","dijsktra"]},{"location":"mediu/shortest-path/#implementare-suboptima","title":"Implementare suboptim\u0103","text":"<p>Acest algoritm, \u00een forma sa neoptimizat\u0103 are complexitatea \\(\\mathcal{O}(n^2)\\) \u0219i are drept unic scop obi\u0219nuirea cu conceptul algoritmului, singura situa\u021bie \u00een care poate fi folosit drept o solu\u021bie real\u0103 este atunci c\u00e2nd avem un graf complet, \u00een care num\u0103rul de muchii se apropie de \\(n^2\\), mai jos put\u00e2nd fi citit\u0103 o implementare care aplic\u0103 pa\u0219ii de mai sus pe un graf neorientat.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\nint main() {\n    int n, m;\n    cin &gt;&gt; n &gt;&gt; m;\n\n    int adj[n + 1]\n           [n + 1];   // pentru acest exemplu, vom folosi matricea de adiacenta\n    int cost[n + 1];  // costul minim de la nodul start la x;\n    int viz[n + 1];   // daca nodul a fost procesat deja\n    for (int i = 1; i &lt;= n; i++) {\n        cost[i] = 1000000000;\n        viz[i] = 0;\n        for (int j = 1; j &lt;= n; j++) {\n            adj[i][j] = 1000000000;\n        }\n    }\n\n    for (int i = 1; i &lt;= m; i++) {\n        int a, b, c;\n        cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;\n        adj[a][b] = adj[b][a] = c;\n    }\n\n    int s;\n    cin &gt;&gt; s;\n    cost[s] = 0;\n    for (int i = 1; i &lt;= n; i++) {\n        int mini = 1000000000;\n        int nod = 0;\n        // aflam nodul cu cost minim dintre cele nevizitate\n        for (int j = 1; j &lt;= n; j++) {\n            if (viz[j] == 0 &amp;&amp; cost[j] &lt; mini) {\n                mini = cost[j];\n                nod = j;\n            }\n        }\n\n        // aflam noile distante\n        viz[nod] = 1;\n        for (int j = 1; j &lt;= n; j++) {\n            if (viz[j] == 0 &amp;&amp; cost[nod] + adj[nod][j] &lt; cost[j]) {\n                cost[j] = cost[nod] + adj[nod][j];\n            }\n        }\n    }\n\n    // afisam costurile finale\n    for (int i = 1; i &lt;= n; i++) {\n        cout &lt;&lt; cost[i] &lt;&lt; \" \";\n    }\n    return 0;\n</code></pre>","tags":["grafuri","drumuri minime","dijsktra"]},{"location":"mediu/shortest-path/#implementare-optima","title":"Implementare optim\u0103","text":"<p>Pentru a putea implementa algoritmul \u00een complexitatea sa optim\u0103, \\(\\mathcal{O}((n+m) \\log n)\\), va trebui s\u0103 facem c\u00e2teva observa\u021bii critice.</p> <p>\u00cen primul r\u00e2nd, nu are niciun sens s\u0103 tot verific\u0103m dac\u0103 nodurile deja vizitate sunt cele cu cost minim.</p> <p>\u00cen al doilea r\u00e2nd, fiind vorba de regul\u0103 de grafuri cu un num\u0103r de muchii apropiat de num\u0103rul de noduri, putem \u021bine vecinii folosind liste.</p> <p>Nu \u00een ultimul r\u00e2nd, cea mai important\u0103 optimizare const\u0103 \u00een g\u0103sirea nodului cu cost minim la fiecare pas, acest lucru se poate realiza folosind o structur\u0103 de date arborescent\u0103, de tip set sau heap (priority queue). Complexitatea acestui pas este redus la \\(\\mathcal{O}(\\log n)\\), ceea ce ne d\u0103 \u00eembun\u0103t\u0103\u021birea de care avem nevoie.</p> <p>Dup\u0103 aplicarea acestor optimiz\u0103ri, ideile fiind acelea\u0219i, cu excep\u021bia folosirii unei cozi de priorit\u0103\u021bi sau a unui set, mai jos fiind prezente ambele variante.</p> <pre><code>#include &lt;iostream&gt;\n#include &lt;queue&gt;\n#include &lt;vector&gt;\n\nusing namespace std;\n\nint main() {\n    int n, m;\n    cin &gt;&gt; n &gt;&gt; m;\n\n    vector&lt;vector&lt;pair&lt;int, int&gt; &gt; &gt; graph(n + 1);\n    for (int i = 1; i &lt;= m; i++) {\n        int a, b, c;\n        cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;\n        graph[a].push_back({b, c});\n        graph[b].push_back({a, c});\n    }\n\n    vector&lt;long long&gt; cost(n + 1, (1LL &lt;&lt; 60));\n    vector&lt;int&gt; vis(n + 1);\n    cost[1] = 0;\n    // priority queue tine perechile in ordine descrescatoare, de aceea se\n    // impune folosirea semnului - pentru a ne folosi de aceasta proprietate\n    // fara a folosi alti comparatori\n    priority_queue&lt;pair&lt;long long, int&gt; &gt; s;\n    s.push({0, 1});\n\n    while (!s.empty()) {\n        pair&lt;long long, int&gt; smallest = s.top();\n        s.pop();\n\n        // daca am trecut deja prin acel nod, nu mai are sens sa parcurgem iar\n        // vecinii lui\n        if (vis[smallest.second] == 1) {\n            continue;\n        }\n        vis[smallest.second] = 1;\n\n        for (int i = 0; i &lt; (int)graph[smallest.second].size(); i++) {\n            int nxt = graph[smallest.second][i].first;\n            int val = graph[smallest.second][i].second;\n\n            if (-smallest.first + val &lt; cost[nxt]) {\n                cost[nxt] = -smallest.first + val;\n                s.push({-cost[nxt], nxt});\n            }\n        }\n    }\n\n    for (int i = 1; i &lt;= n; i++) {\n        cout &lt;&lt; cost[i] &lt;&lt; \" \";\n    }\n    return 0;\n}\n</code></pre> <pre><code>#include &lt;iostream&gt;\n#include &lt;set&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\nint main() {\n    int n, m;\n    cin &gt;&gt; n &gt;&gt; m;\n\n    vector&lt;vector&lt;pair&lt;int, int&gt; &gt; &gt; graph(n + 1);\n    for (int i = 1; i &lt;= m; i++) {\n        int a, b, c;\n        cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;\n        graph[a].push_back({b, c});\n        graph[b].push_back({a, c});\n    }\n\n    vector&lt;long long&gt; cost(n + 1, (1LL &lt;&lt; 60));\n    cost[1] = 0;\n    set&lt;pair&lt;long long, int&gt; &gt; s;\n    s.insert({0, 1});\n\n    while (!s.empty()) {\n        pair&lt;long long, int&gt; smallest = *s.begin();\n        s.erase(smallest);\n\n        for (int i = 0; i &lt; (int)graph[smallest.second].size(); i++) {\n            int nxt = graph[smallest.second][i].first;\n            int val = graph[smallest.second][i].second;\n\n            if (smallest.first + val &lt; cost[nxt]) {\n                if (s.find({cost[nxt], nxt}) != s.end()) {\n                    s.erase({cost[nxt], nxt});\n                }\n                cost[nxt] = smallest.first + val;\n                s.insert({cost[nxt], nxt});\n            }\n        }\n    }\n\n    for (int i = 1; i &lt;= n; i++) {\n        cout &lt;&lt; cost[i] &lt;&lt; \" \";\n    }\n    return 0;\n</code></pre> <p>Folosind aceste implement\u0103ri, putem afla drumurile minime \u00eentre dou\u0103 noduri foarte rapid, \u00een cazul majorit\u0103\u021bii problemelor de acest fel. Totu\u0219i, a\u0219a cum ve\u021bi vedea \u00een cazul celorlal\u021bi doi algoritmi, Dijkstra nu acoper\u0103 toate variantele de grafuri cu costuri.</p>","tags":["grafuri","drumuri minime","dijsktra"]},{"location":"mediu/shortest-path/#algoritmul-bellman-ford","title":"Algoritmul Bellman-Ford","text":"<p>Algoritmul Bellman-Ford este un algoritm de aflare a drumului minim \u00eentre dou\u0103 noduri folosit mai ales pentru detectarea ciclurilor negative.</p> <p>\u00cen mod similar cu algoritmul lui Dijkstra, vom \u021bine pentru fiecare nod costul total p\u00e2n\u0103 la el, dar ca o noutate, vom \u021bine \u0219i num\u0103rul de modific\u0103ri ale costului minim. Dac\u0103 num\u0103rul de modific\u0103ri ale costului minim este cel pu\u021bin \\(n\\), atunci putem spune c\u0103 avem un ciclu de cost negativ, deoarece asta \u00eenseamn\u0103 c\u0103 sigur am modificat costul minim de dou\u0103 ori din acela\u0219i vecin.</p> <p>De\u0219i \u00een practic\u0103 algoritmul se comport\u0103 rezonabil, complexitatea pe cazul cel mai prost este \\(\\mathcal{O}(n \\cdot m)\\). Implementarea, una foarte similar\u0103 cu cea a parcurgerii BFS, se poate g\u0103si mai jos.</p> <pre><code>#include &lt;iostream&gt;\n#include &lt;queue&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\nint main() {\n    ifstream cin(\"bellmanford.in\");\n    ofstream cout(\"bellmanford.out\");\n\n    int n, m;\n    cin &gt;&gt; n &gt;&gt; m;\n\n    vector&lt;vector&lt;pair&lt;int, int&gt; &gt; &gt; graph(n + 1);\n    for (int i = 1; i &lt;= m; i++) {\n        int a, b, c;\n        cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;\n\n        graph[a].push_back({b, c});\n    }\n\n    vector&lt;long long&gt; costs(n + 1, (1LL &lt;&lt; 60));\n    vector&lt;int&gt; cnt(n + 1);\n\n    costs[1] = 0;\n    queue&lt;int&gt; q;\n    q.push(1);\n    while (!q.empty()) {\n        int node = q.front();\n        q.pop();\n\n        for (int i = 0; i &lt; (int)graph[node].size(); i++) {\n            int nxt = graph[node][i].first;\n            int c = graph[node][i].second;\n            if (costs[node] + c &lt; costs[nxt]) {\n                costs[nxt] = costs[node] + c;\n                q.push(nxt);\n\n                cnt[nxt]++;\n                if (cnt[nxt] &gt; n) {\n                    cout &lt;&lt; \"Ciclu negativ!\" &lt;&lt; '\\n';\n                    return 0;\n                }\n            }\n        }\n    }\n\n    for (int i = 2; i &lt;= n; i++) {\n        cout &lt;&lt; costs[i] &lt;&lt; \" \";\n    }\n    return 0;\n}\n</code></pre> <p>Observa\u021bie</p> <p>Exist\u0103 o varia\u021bie a acestui algoritm, foarte des folosit\u0103 \u00een cazul unor probleme de drum minim, numit\u0103 SPFA (Shortest Path Faster Algorithm). Acest algoritm este folosit cu succes \u00een multe probleme de informatic\u0103, ca o alternativ\u0103 la algoritmul lui Dijkstra. Totu\u0219i, \u00een cazul cel mai prost complexitatea este similar\u0103 cu cea de la Bellman-Ford, \\(\\mathcal{O}(n \\cdot m)\\).</p>","tags":["grafuri","drumuri minime","dijsktra"]},{"location":"mediu/shortest-path/#algoritmul-floyd-warshall-roy-floyd","title":"Algoritmul Floyd-Warshall (Roy-Floyd)","text":"<p>Algoritmul Floyd-Warshall (Roy-Floyd) este un algoritm de aflare a drumului minim \u00eentre toate perechile de noduri, f\u0103r\u0103 a fi nevoie de a calcula individual distan\u021bele dintre oricare dou\u0103 noduri.</p> <p>Modul \u00een care func\u021bioneaz\u0103 acest algoritm este acela c\u0103 pentru fiecare pereche de noduri, vom \u021bine \u00een memorie distan\u021ba dintre acea pereche de noduri, iar la fiecare pas, vom fixa un nod pe care \u00eel vom folosi drept un nod intermediar, cu scopul de a mic\u0219ora distan\u021bele dintre noduri \u00een acest fel.</p> <p>Cu alte cuvinte, vom fixa o valoare \\(k\\) corespunz\u0103toare nodului din mijloc, iar pentru fiecare pereche \\((i, j)\\), vom verifica dac\u0103 \\(dist(i, k) + dist(k, j) &lt; dist(i, j)\\), astfel relax\u00e2nd drumul dintre cele dou\u0103 noduri.</p> <p>Complexitatea total\u0103 a algoritmului va fi \\(\\mathcal{O}(n^3)\\), fiind unul dintre algoritmii folosi\u021bi pentru a evalua performan\u021ba calculatoarelor, datorit\u0103 simplit\u0103\u021bii sale. Mai jos g\u0103si\u021bi implementarea \u00een limbajul C++.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\nint n, a[102][102];  // costul minim de la i la j\nint main() {\n    cin &gt;&gt; n;\n    for (int i = 1; i &lt;= n; ++i) {\n        for (int j = 1; j &lt;= n; ++j) {\n            cin &gt;&gt; a[i][j];\n        }\n    }\n    for (int k = 1; k &lt;= n; k++) {\n        for (int i = 1; i &lt;= n; i++) {\n            for (int j = 1; j &lt;= n; j++) {\n                if (a[i][k] &amp;&amp; a[k][j]\n                    &amp;&amp; (a[i][j] &gt; a[i][k] + a[k][j] || !a[i][j]) &amp;&amp; i != j) {\n                    a[i][j] = a[i][k] + a[k][j];\n                }\n            }\n        }\n    }\n    for (int i = 1; i &lt;= n; ++i) {\n        for (int j = 1; j &lt;= n; ++j) {\n            cout &lt;&lt; a[i][j] &lt;&lt; \" \";\n        }\n        cout &lt;&lt; '\\n';\n    }\n    return 0;\n}\n</code></pre> <p>Observa\u021bie</p> <p>Ordinea \u00een care avem cele trei for-uri este esen\u021bial\u0103, fiind obligatoriu s\u0103 \u00eencepem cu nodul pe care \u00eel vom folosi drept cel intermediar \\((k, i, j)\\), celelalte variante fiind gre\u0219ite deoarece rat\u0103m diverse drumuri \u00een acest mod.</p>","tags":["grafuri","drumuri minime","dijsktra"]},{"location":"mediu/shortest-path/#algoritmul-0-1-bfs-si-variatiile-sale","title":"Algoritmul 0-1 BFS \u0219i varia\u021biile sale","text":"<p>\u00cen unele probleme de drum minim, costurile muchiilor sunt valori mici, dar nu doar egale cu 1. Deoarece avem pu\u021bine costuri, ne putem g\u00e2ndi la optimiz\u0103ri care s\u0103 se foloseasc\u0103 de acest lucru pentru a ajunge s\u0103 avem algoritmi mai rapizi, f\u0103r\u0103 a fi nevoie de Dijkstra sau vreun alt algoritm mai general.</p>","tags":["grafuri","drumuri minime","dijsktra"]},{"location":"mediu/shortest-path/#0-1-bfs","title":"0-1 BFS","text":"<p>Un prim exemplu const\u0103 \u00een grafurile (sau construc\u021biile care pot fi reprezentate ca \u0219i grafuri) \u00een care costurile muchiilor sunt doar 0 sau 1. Deoarece avem costuri care nu sunt uniforme, nu vom putea folosi BFS la fel cum am proceda \u00eentr-o problem\u0103 obi\u0219nuit\u0103, dar putem \u00een schimb s\u0103 profit\u0103m de faptul c\u0103 sunt doar dou\u0103 costuri distincte.</p> <p>\u00cen loc s\u0103 avem o singur\u0103 coad\u0103 \u00een care ad\u0103ug\u0103m valori de fiecare dat\u0103 c\u00e2nd drumul devine unul mai optim dec\u00e2t drumul minim, vom avea dou\u0103 cozi (sau un deque) \u00een care vom alterna cozile \u00een care ad\u0103ug\u0103m nodurile, dup\u0103 cum urmeaz\u0103:</p> <ul> <li>Dac\u0103 costul muchiei este 0, vom ad\u0103uga \u00een coada curent\u0103 (sau \u00een v\u00e2rful   deque-ului, dac\u0103 folosim un deque)</li> <li>Dac\u0103 costul muchiei este 1, vom ad\u0103uga \u00een coada urm\u0103toare (sau la coada   deque-ului, dac\u0103 folosim aceast\u0103 structur\u0103 de date)</li> </ul> <p>Observa\u021bie</p> <p>Folosind aceast\u0103 metod\u0103, vom ajunge s\u0103 ad\u0103ug\u0103m fiecare nod \u00een structura noastr\u0103 de date de cel mult 2 ori, complexitatea devenind liniar\u0103, spre deosebire de o abordare standard folosind BFS, \u00een care complexitatea pe cel mai r\u0103u caz poate fi polinomial\u0103 (de cele mai multe ori, p\u0103tratic\u0103 raportat la num\u0103rul de noduri)</p> <p>De asemenea, prin aceast\u0103 strategie vom p\u0103stra o proprietate fundamental\u0103 a parcurgerii BFS c\u00e2nd vine vorba de drumuri minime, \u0219i anume faptul c\u0103 nodurile vor fi procesate \u00een ordine cresc\u0103toare a costurilor fa\u021b\u0103 de origine. Aceast\u0103 proprietate este una esen\u021bial\u0103 \u0219i va fi p\u0103strat\u0103 indiferent de num\u0103rul de cozi pe care \u00eel vom folosi, prin alternarea cozilor pe care le parcurgem la un moment dat, acestea fiind traversate secven\u021bial.</p> <p>Un exemplu de problem\u0103 \u00een care avem aceast\u0103 abordare este problema padure, \u00een care vom implementa acest algoritm pe o matrice. Mai jos pute\u021bi g\u0103si o implementare ce ia 100 pe problema dat\u0103.</p> <pre><code>#include &lt;deque&gt;\n#include &lt;fstream&gt;\n#include &lt;vector&gt;\n\nusing namespace std;\n\nint main() {\n    vector&lt;pair&lt;int, int&gt;&gt; dir = {\n        {-1, 0 },\n        {0,  1 },\n        {1,  0 },\n        {0,  -1}\n    };\n\n    ifstream cin(\"padure.in\");\n    ofstream cout(\"padure.out\");\n\n    int n, m, xa, ya, xb, yb;\n    cin &gt;&gt; n &gt;&gt; m &gt;&gt; xa &gt;&gt; ya &gt;&gt; xb &gt;&gt; yb;\n    --xa, --ya, --xb, --yb;\n\n    vector&lt;vector&lt;int&gt;&gt; mat(n, vector&lt;int&gt;(m)), dist(n, vector&lt;int&gt;(m));\n\n    for (int i = 0; i &lt; n; i++) {\n        for (int j = 0; j &lt; m; j++) {\n            cin &gt;&gt; mat[i][j];\n        }\n    }\n\n    deque&lt;pair&lt;int, int&gt;&gt; Q;\n    dist[xa][ya] = 1;\n    Q.push_front({xa, ya});\n\n    while (!Q.empty()) {\n        pair&lt;int, int&gt; nd = Q.front();\n        Q.pop_front();\n\n        int x = nd.first;\n        int y = nd.second;\n\n        for (int i = 0; i &lt; 4; i++) {\n            auto nx = x + dir[0].first, ny = y + dir[0].second;\n\n            if (nx &gt;= 0 &amp;&amp; ny &gt;= 0 &amp;&amp; nx &lt; n &amp;&amp; ny &lt; m) {\n                if (mat[nx][ny] != mat[x][y]\n                    &amp;&amp; (dist[x][y] + 1 &lt; dist[nx][ny] || !dist[nx][ny])) {\n                    dist[nx][ny] = dist[x][y] + 1;\n                    Q.push_back({nx, ny});\n                } else if (mat[nx][ny] == mat[x][y]\n                           &amp;&amp; (dist[x][y] &lt; dist[nx][ny] || !dist[nx][ny])) {\n                    dist[nx][ny] = dist[x][y];\n                    Q.push_front({nx, ny});\n                }\n            }\n        }\n    }\n\n    cout &lt;&lt; dist[xb][yb] - 1 &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["grafuri","drumuri minime","dijsktra"]},{"location":"mediu/shortest-path/#1-k-bfs-algoritmul-lui-dial","title":"1-K BFS (Algoritmul lui Dial)","text":"<p>Aceast\u0103 abordare poate fi extins\u0103 \u0219i dac\u0103 avem \\(k\\) costuri distincte, folosind o strategie similar\u0103. Deoarece nu vom mai putea folosi un deque, vom recurge la a folosi \\(k\\) cozi, urm\u00e2nd ca mai apoi s\u0103 simul\u0103m algoritmul nostru de drum minim exact ca la 0-1 BFS.</p> <p>Vom \u00eencepe prin a ad\u0103uga punctul ini\u021bial \u00een coada 0, iar pe parcurs, dac\u0103 lu\u0103m punctul din coada \\(x\\) \u0219i costul muchiei este \\(y\\), atunci noul nod va fi ad\u0103ugat \u00een coada \\((x+y) \\ \\% \\ k\\), urm\u00e2nd a fi procesat \u00eempreun\u0103 cu celelalte puncte. Acest lucru se poate generaliza \u0219i dac\u0103 avem \\(k\\) costuri oarecare, put\u00e2nd astfel ad\u0103uga costurile \u00een cozi \u00een func\u021bie de ultimul cost ad\u0103ugat, exact cum proced\u0103m la problema Biom de la ONI 2023.</p> <p>La fel ca \u0219i la algoritmul precedent, vom parcurge cozile alternativ, p\u0103str\u00e2nd ordinea costurilor intact\u0103, pentru a permite algoritmului nostru s\u0103 r\u0103m\u00e2n\u0103 liniar raportat la num\u0103rul de noduri.</p> <p>Pentru a \u00een\u021belege mai bine modul de folosire a acestei variante generalizate, voi explica solu\u021bia problemei John and Tractor, dat\u0103 la finala FIICode 2023.</p> <p>Aici vom avea trei costuri distincte, unul dintre ele put\u00e2nd fi ajustat de opera\u021bia descris\u0103 \u00een enun\u021b. Ne vom concentra pe partea \u00een care vom rula algoritmul lui Dial, folosind 4 cozi (costurile sunt \\(1, 2, 3\\)).</p> <pre><code>#include &lt;iostream&gt;\n#include &lt;queue&gt;\n#include &lt;vector&gt;\n\nusing namespace std;\n\nstruct info {\n    int L, C, x;\n};\n\nvector&lt;int&gt; ox = {0, 1, 0, -1};\nvector&lt;int&gt; oy = {1, 0, -1, 0};\n\nint main() {\n    // limita de timp stransa, fast io e necesar\n\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n\n    int n, m, k;\n    cin &gt;&gt; n &gt;&gt; m &gt;&gt; k;\n\n    int xa, ya, xb, yb;\n    cin &gt;&gt; xa &gt;&gt; ya &gt;&gt; xb &gt;&gt; yb;\n\n    vector&lt;vector&lt;int&gt;&gt; grid(n + 1);\n\n    for (int i = 1; i &lt;= n; i++) {\n        grid[i].resize(m + 1);\n        string s;\n        cin &gt;&gt; s;\n\n        for (int j = 0; j &lt; m; j++) {\n            if (s[j] == 's') {\n                grid[i][j + 1] = 1;\n            }\n            if (s[j] == 'p') {\n                grid[i][j + 1] = 2;\n            }\n            if (s[j] == 'a') {\n                grid[i][j + 1] = 3;\n            }\n        }\n    }\n\n    vector&lt;vector&lt;vector&lt;int&gt;&gt;&gt; dp(\n        n + 1, vector&lt;vector&lt;int&gt;&gt;(m + 1, vector&lt;int&gt;(k + 1, (1 &lt;&lt; 25))));\n\n    queue&lt;info&gt; q[4];\n\n    q[grid[xa][ya]].push({xa, ya, 0});\n    dp[xa][ya][0] = grid[xa][ya];\n\n    if (grid[xa][ya] == 2) {\n        q[grid[xa][ya] - 1].push({xa, ya, 1});\n        dp[xa][ya][1] = grid[xa][ya] - 1;\n    }\n\n    int timp = 0;\n    int lastempty = 0;\n\n    while (lastempty &lt;= 10) {\n        lastempty++;\n        // timp%4 = timp&amp;3, pentru puteri ale lui 2\n        while (!q[(timp &amp; 3)].empty()) {\n            lastempty = 0;\n            info nod = q[(timp &amp; 3)].front();\n            q[(timp &amp; 3)].pop();\n\n            for (int dir = 0; dir &lt;= 3; dir++) {\n                int nxtL = nod.L + ox[dir];\n                int nxtC = nod.C + oy[dir];\n                if (nxtL &gt;= 1 &amp;&amp; nxtL &lt;= n &amp;&amp; nxtC &gt;= 1 &amp;&amp; nxtC &lt;= m) {\n                    int nwt = grid[nxtL][nxtC] + dp[nod.L][nod.C][nod.x];\n                    if (nwt &lt; dp[nxtL][nxtC][nod.x]) {\n                        dp[nxtL][nxtC][nod.x] = nwt;\n                        q[(nwt &amp; 3)].push({nxtL, nxtC, nod.x});\n                    }\n\n                    if (grid[nxtL][nxtC] == 2 &amp;&amp; nod.x &lt; k) {\n                        nwt--;\n                        if (nwt &lt; dp[nxtL][nxtC][nod.x + 1]) {\n                            dp[nxtL][nxtC][nod.x + 1] = nwt;\n                            q[(nwt &amp; 3)].push({nxtL, nxtC, nod.x + 1});\n                        }\n                    }\n                }\n            }\n        }\n        timp++;\n    }\n\n    int ans = 1e9;\n    for (int j = 0; j &lt;= k; j++) {\n        ans = min(ans, dp[xb][yb][j]);\n    }\n    cout &lt;&lt; ans &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["grafuri","drumuri minime","dijsktra"]},{"location":"mediu/shortest-path/#care-este-algoritmul-mai-bun","title":"Care este algoritmul mai bun?","text":"<p>Fiecare algoritm are avantajele \u0219i dezavantajele lui, cunoa\u0219terea tuturor fiind necesar\u0103. Dijkstra este op\u021biunea optim\u0103 \u00een cele mai multe cazuri, dar Floyd-Warshall \u0219i Bellman-Ford au ambele beneficiile lui. 0-1 BFS / 1-K BFS au \u0219i ele avantajele lor, \u00een special c\u00e2nd vine vorba de grafuri cu costuri mici, nefiind nici acest algoritm unul de neglijat.</p>","tags":["grafuri","drumuri minime","dijsktra"]},{"location":"mediu/shortest-path/#probleme-suplimentare","title":"Probleme suplimentare","text":"<ul> <li>Simple Shortest Path</li> <li>Shortest Routes I</li> <li>Shortest Routes II</li> <li>catun infoarena</li> <li>High Score</li> <li>Flight Discount</li> <li>OJI 2004 Lanterna</li> <li>FIICode John and Tractor</li> <li>OJI 2017 Rover</li> <li>Baltic Olympiad 2011 Switch</li> <li>Lot 2018 Juniori Road</li> <li>USACO Gold Fine   Dining</li> <li>ONI 2023 Biom</li> <li>Cycle Finding</li> <li>Investigation</li> <li>Probleme cu drumul minim de pe Kilonova</li> <li>Probleme cu Dijkstra de pe   Infoarena</li> <li>Probleme cu Bellman-Ford de pe   Infoarena</li> <li>rfinv infoarena</li> <li>Probleme cu Floyd-Warshall de pe   Infoarena</li> </ul>","tags":["grafuri","drumuri minime","dijsktra"]},{"location":"mediu/shortest-path/#lectura-suplimentara","title":"Lectur\u0103 suplimentar\u0103","text":"<ul> <li>Shortest Paths with Non-Negative Edge Weights - USACO   Guide</li> <li>Shortest Paths with Negative Edge Weights - USACO   Guide</li> <li>Dijkstra - CP-algorithms</li> <li>Aflarea drumului minim -   CPPI</li> <li>1-K BFS - Codeforces</li> <li>0-1 BFS - CP-algorithms</li> <li>Roy Floyd - CPPI</li> <li>Dijkstra - CPPI</li> <li>Rethink the Dijkstra algorithm -- Let's go   deeper</li> <li>Bellman-Ford - CPPI</li> </ul>","tags":["grafuri","drumuri minime","dijsktra"]},{"location":"mediu/sliding-window/","title":"Sliding window","text":"<p>A\u0219a cum am men\u021bionat \u00een articolul despre lucrul cu secven\u021be, acestea se reg\u0103sesc \u00een foarte multe tipuri de probleme, iar de\u0219i acolo am discutat \u00een special despre problemele de baz\u0103, aici vom prezenta o tehnic\u0103 care va fi util\u0103 pentru problemele \u00een care trebuie s\u0103 iter\u0103m prin ferestre de lungime fix\u0103.</p> <p>Defini\u021bie</p> <p>Fereastra glisant\u0103 (\u00een englez\u0103 sliding window) reprezint\u0103 o metod\u0103 de rezolvare a problemelor care implic\u0103 folosirea informa\u021biei acumulate pentru a face tranzi\u021biile \u00eentre subsecven\u021be de lungime \\(k\\) cu u\u0219urin\u021b\u0103, f\u0103r\u0103 a fi nevoie de recalcularea r\u0103spunsului pentru toate secven\u021bele de lungime \\(k\\).</p> <p>Observa\u021bie</p> <p>Pe parcursul acestui articol, ve\u021bi observa diferite structuri de date folosite pentru aplicarea conceptelor de aici. Toate acestea vor avea un element comun, folosirea unor precalcul\u0103ri pentru a facilita ob\u021binerea r\u0103spunsurilor.</p> <p>Vom continua prin a prezenta c\u00e2teva probleme de acest fel, precum \u0219i prin a face leg\u0103tura cu tehnici mai generale care folosesc principiile de aici, care se vor aplica \u0219i \u00een cazul unor secven\u021be de lungime variabil\u0103.</p>","tags":["secvente","precalculare"]},{"location":"mediu/sliding-window/#teava-roalgo-summer-flasg","title":"\u021aeava - RoAlgo Summer FLASG","text":"<p>O solu\u021bie brut\u0103 a acestei probleme const\u0103 \u00een a calcula pe r\u00e2nd toate sumele corespunz\u0103toare intervalelor de lungime egal\u0103 cu lungimea intervalului dat, dar aceast\u0103 solu\u021bie va rula \u00een \\(\\mathcal{O}(n^2)\\).</p> <p>Pentru a optimiza solu\u021bia brut\u0103, vom \u00eencepe prin a calcula \u00een mod brut suma pentru intervalul \\([st, dr]\\), iar mai apoi ne vom folosi de faptul c\u0103 num\u0103rul de valori diferite dintre intervalele \\([st, dr]\\) \u0219i \\([st+1, dr+1]\\) este exact 2 (cu alte cuvinte, valoarea de pe pozi\u021bia \\(st\\) nu va mai fi considerat\u0103, dar valoarea de pe pozi\u021bia \\(dr+1\\) va fi considerat\u0103).</p> <p>\u00cen acest mod, solu\u021bia va fi optimizat\u0103, ating\u00e2ndu-se complexitatea dorit\u0103, \u0219i anume \\(\\mathcal{O}(n)\\). Mai jos pute\u021bi g\u0103si implementarea folosind aceast\u0103 metod\u0103.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int n;\n    cin &gt;&gt; n;\n\n    vector&lt;int&gt; v(n + 1);\n    for (int i = 1; i &lt;= n; i++) {\n        cin &gt;&gt; v[i];\n    }\n\n    int st, dr;\n    cin &gt;&gt; st &gt;&gt; dr;\n\n    // aflam suma initiala\n    long long sm = 0;\n    for (int i = st; i &lt;= dr; i++) {\n        sm += v[i];\n    }\n\n    // ajustam suma initiala folosind cele doua valori care ies/intra\n    long long ans = 0;\n    while (dr &lt;= n) {\n        ans += sm;\n        sm -= v[st];\n        sm += v[dr + 1];\n        st++, dr++;\n    }\n\n    cout &lt;&lt; ans &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["secvente","precalculare"]},{"location":"mediu/sliding-window/#inaccurate-subsequence-search-codeforces","title":"Inaccurate Subsequence Search - Codeforces","text":"<p>Pentru a rezolva aceast\u0103 problem\u0103, ne vom folosi de faptul c\u0103 trebuie s\u0103 calcul\u0103m num\u0103rul maxim de elemente care se potrivesc pentru toate subsecven\u021bele de lungime \\(m\\).</p> <p>\u00cen cazul acestei probleme, vom putea folosi o structur\u0103 de date de tip map pentru a stoca frecven\u021bele numerelor din cele dou\u0103 \u0219iruri, implementarea folosind acest principiu pentru a \u021bine cu u\u0219urin\u021b\u0103 r\u0103spunsul c\u0103utat, complexitatea devenind \\(\\mathcal{O}(n \\log n)\\).</p> <pre><code>#include &lt;iostream&gt;\n#include &lt;map&gt;\n#include &lt;vector&gt;\n\nusing namespace std;\n\nint main() {\n    // linii pentru citirea rapida, necesare pentru codeforces\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n\n    int t;\n    cin &gt;&gt; t;\n\n    while (t--) {\n        int n, m, k;\n        cin &gt;&gt; n &gt;&gt; m &gt;&gt; k;\n        map&lt;int, int&gt; mpa, mpb;\n\n        vector&lt;long long&gt; v(n + 1), v2(m + 1);\n        for (int i = 1; i &lt;= n; i++) {\n            cin &gt;&gt; v[i];\n        }\n        for (int i = 1; i &lt;= m; i++) {\n            cin &gt;&gt; v2[i];\n            mpa[v2[i]]++;\n        }\n        int cnt = 0, total = 0;\n        for (int i = 1; i &lt;= n; i++) {\n            cnt -= min(mpa[v[i]], mpb[v[i]]);\n            mpb[v[i]]++;\n            cnt += min(mpa[v[i]], mpb[v[i]]);\n            if (i &gt; m) {\n                cnt -= min(mpa[v[i - m]], mpb[v[i - m]]);\n                mpb[v[i - m]]--;\n                cnt += min(mpa[v[i - m]], mpb[v[i - m]]);\n            }\n            if (i &gt;= m &amp;&amp; cnt &gt;= k) {\n                total++;\n            }\n        }\n        cout &lt;&lt; total &lt;&lt; '\\n';\n    }\n    return 0;\n}\n</code></pre>","tags":["secvente","precalculare"]},{"location":"mediu/sliding-window/#sliding-window-median","title":"Sliding Window Median","text":"<p>La fel ca la celelalte dou\u0103 probleme, vom vrea s\u0103 proces\u0103m fiecare element care intr\u0103, \u00eempreun\u0103 cu fiecare element care iese f\u0103r\u0103 a schimba prea mult datele problemei.</p> <p>Solu\u021bia descris\u0103 mai jos se bazeaz\u0103 pe faptul c\u0103 \u021binem \u00een dou\u0103 seturi valorile mai mici dec\u00e2t mediana \u0219i cele mai mari dec\u00e2t mediana, iar atunci c\u00e2nd ajust\u0103m fereastra noastr\u0103, vom echilibra dimensiunile seturilor \u00een mod convenabil pentru a putea accesa \u00een continuare mediana cu u\u0219urin\u021b\u0103, folosind func\u021biile specifice std::set.</p> <pre><code>#include &lt;iostream&gt;\n#include &lt;set&gt;\n#include &lt;vector&gt;\n\nusing namespace std;\n\nint main() {\n    int n, k;\n    cin &gt;&gt; n &gt;&gt; k;\n\n    vector&lt;int&gt; v(n + 1);\n    multiset&lt;int&gt; smaller, larger;\n    for (int i = 1; i &lt;= n; i++) {\n        cin &gt;&gt; v[i];\n    }\n\n    for (int i = 1; i &lt;= n; i++) {\n        smaller.insert(v[i]);\n        if (i &gt; k) {\n            if (smaller.find(v[i - k]) != smaller.end()) {\n                smaller.erase(smaller.lower_bound(v[i - k]));\n            } else {\n                larger.erase(larger.lower_bound(v[i - k]));\n            }\n        }\n        if (i &gt;= k) {\n            for (int i = 1; i &lt;= 2; i++) {\n                if (!larger.empty()) {\n                    int x = *larger.begin();\n                    larger.erase(larger.lower_bound(x));\n                    smaller.insert(x);\n                }\n            }\n            while (smaller.size() - 1 &gt;= larger.size() + 1) {\n                int x = *smaller.rbegin();\n                smaller.erase(smaller.lower_bound(x));\n                larger.insert(x);\n            }\n            cout &lt;&lt; *smaller.rbegin() &lt;&lt; \" \";\n        }\n    }\n    return 0;\n}\n</code></pre>","tags":["secvente","precalculare"]},{"location":"mediu/sliding-window/#alte-aplicatii-si-concluzii","title":"Alte aplica\u021bii \u0219i concluzii","text":"<p>Metode de tipul sliding window se pot folosi \u0219i \u00een cazul altor tehnici, precum tehnica celor doi pointeri, multe dintre aplica\u021biile \u00eent\u00e2lnite la deque \u0219i alte structuri de date mai complicate dec\u00e2t scopul acestui articol, care este unul de leg\u0103tur\u0103 dintre aplica\u021biile \u00eent\u00e2lnite la problemele cu secven\u021be \u0219i cele mai avansate, din capitolele urm\u0103toare.</p>","tags":["secvente","precalculare"]},{"location":"mediu/sliding-window/#probleme-suplimentare","title":"Probleme suplimentare","text":"<ul> <li>OJI 2024 Santinele</li> <li>Strip Codeforces</li> <li>Sliding Window Cost</li> <li>Max Subarray Sum II</li> <li>slidingwindow infoarena</li> <li>Fence Codeforces</li> </ul>","tags":["secvente","precalculare"]},{"location":"mediu/sliding-window/#lectura-suplimentara","title":"Lectur\u0103 suplimentar\u0103","text":"<ul> <li>Sliding Window - USACO   Guide</li> </ul>","tags":["secvente","precalculare"]},{"location":"mediu/stack/","title":"Stiva","text":"<p>\u00cen multe probleme \u00een care lucr\u0103m cu secven\u021be de valori, suntem nevoi\u021bi s\u0103 proces\u0103m valorile pe r\u00e2nd, asemenea unui teanc de obiecte. Pentru a formaliza acest proces, vom avea nevoie de o structur\u0103 de date potrivit\u0103. \u00cen informatic\u0103, numim aceast\u0103 structur\u0103 de date stiv\u0103.</p>","tags":["stiva","structuri de date"]},{"location":"mediu/stack/#notiuni-introductive","title":"No\u021biuni introductive","text":"<p>Ce este o stiv\u0103?</p> <p>Stiva (\u00een englez\u0103, stack) este o structur\u0103 de date liniar\u0103 abstract\u0103, pentru care sunt definite opera\u021biile de ad\u0103ugare a unui element \u0219i eliminare a unui element \u0219i aceste opera\u021bii se realizeaz\u0103 la un singur cap\u0103t al structurii, numit v\u00e2rful stivei. \u00cen timpul opera\u021biilor cu stiva avem acces numai la elementul din v\u00e2rful stivei.</p> <p>Opera\u021biile pe care o stiv\u0103 le poate efectua \u00een timp constant sunt:</p> <ol> <li>push(x): Adaug\u0103 valoarea \\(x\\) pe v\u00e2rful stivei.</li> <li>top(): Spune care este valoarea de pe v\u00e2rful stivei.</li> <li>pop(): Scoate elementul din v\u00e2rful stivei.</li> <li>empty(): Spune dac\u0103 stiva este goal\u0103.</li> </ol> <p>Observa\u021bie</p> <p>Valorile vor fi procesate conform principiului LIFO, adic\u0103 last in, first out.</p>","tags":["stiva","structuri de date"]},{"location":"mediu/stack/#probleme-de-baza","title":"Probleme de baz\u0103","text":"","tags":["stiva","structuri de date"]},{"location":"mediu/stack/#problema-stack","title":"Problema stack","text":"<p>Aceast\u0103 problem\u0103 ne cere s\u0103 implement\u0103m exact opera\u021biile descrise mai sus.</p> <p>Pentru a implementa aceste opera\u021bii, avem dou\u0103 variante posibile:</p>","tags":["stiva","structuri de date"]},{"location":"mediu/stack/#implementarea-folosind-un-vector-obisnuit","title":"Implementarea folosind un vector obi\u0219nuit","text":"<p>Pentru a implementa aceste opera\u021bii f\u0103r\u0103 a folosi vreo structur\u0103 de date dinamic\u0103, putem face asta \u021bin\u00e2nd un contor cu num\u0103rul de valori care se afl\u0103 la acel moment \u00een stiv\u0103, astfel opera\u021biile de \u0219tergere \u0219i de verificare a dimensiunii stivei se fac raport\u00e2ndu-ne la variabila \\(pos\\), iar ad\u0103ugarea valorii se face pur \u0219i simplu cresc\u00e2nd valoarea lui \\(pos\\).</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint stk[100001];\n\nint main() {\n    int t;\n    cin &gt;&gt; t;\n\n    int pos = 0;\n    while (t--) {\n        int tip;\n        cin &gt;&gt; tip;\n        if (tip == 1) {\n            cin &gt;&gt; stk[pos++];\n        } else {\n            if (tip == 2) {\n                pos--;\n            } else {\n                if (tip == 3) {\n                    cout &lt;&lt; stk[pos - 1] &lt;&lt; '\\n';\n                } else {\n                    if (pos == 0) {\n                        cout &lt;&lt; \"YES\" &lt;&lt; '\\n';\n                    } else {\n                        cout &lt;&lt; \"NO\" &lt;&lt; '\\n';\n                    }\n                }\n            }\n        }\n    }\n    return 0;\n}\n</code></pre>","tags":["stiva","structuri de date"]},{"location":"mediu/stack/#implementarea-folosind-stdstack","title":"Implementarea folosind std::stack","text":"<p>Stiva poate fi implementat\u0103 \u0219i cu func\u021biile din STL. Pentru mai multe detalii, vede\u021bi implementarea \u0219i func\u021biile descrise aici.</p> <p>Se poate observa faptul c\u0103 avem nevoie de biblioteca <code>&lt;stack&gt;</code> pentru aceste func\u021bii.</p> <pre><code>#include &lt;iostream&gt;\n#include &lt;stack&gt;\n\nusing namespace std;\n\nint main() {\n    int t;\n    cin &gt;&gt; t;\n    stack&lt;int&gt; st;\n\n    while (t--) {\n        int tip;\n        cin &gt;&gt; tip;\n        if (tip == 1) {\n            int val;\n            cin &gt;&gt; val;\n            st.push(val);\n        } else {\n            if (tip == 2) {\n                st.pop();\n            } else {\n                if (tip == 3) {\n                    cout &lt;&lt; st.top() &lt;&lt; '\\n';\n                } else {\n                    if (st.empty()) {\n                        cout &lt;&lt; \"YES\" &lt;&lt; '\\n';\n                    } else {\n                        cout &lt;&lt; \"NO\" &lt;&lt; '\\n';\n                    }\n                }\n            }\n        }\n    }\n\n    return 0;\n}\n</code></pre>","tags":["stiva","structuri de date"]},{"location":"mediu/stack/#problema-stack_max_min","title":"Problema stack_max_min","text":"<p>Problema ne d\u0103 un \u0219ir de numere \u0219i 4 \u00eentreb\u0103ri pentru c\u00e2te o pozi\u021bie:</p> <ol> <li>Cel mai apropiat indice la st\u00e2nga, unde elementul este mai mare dec\u00e2t pozi\u021bia    din \u00eentrebare.</li> <li>Cel mai apropiat indice la st\u00e2nga, unde elementul este mai mic dec\u00e2t pozi\u021bia    din \u00eentrebare.</li> <li>Cel mai apropiat indice la dreapta, unde elementul este mai mare dec\u00e2t    pozi\u021bia din \u00eentrebare.</li> <li>Cel mai apropiat indice la dreapta, unde elementul este mai mic dec\u00e2t pozi\u021bia    din \u00eentrebare.</li> </ol> <p>Vom precalcula, pentru fiecare element, r\u0103spunsul la fiecare tip de \u00eentrebare. Aici vom descrie algoritmul doar pentru primul tip, deoarece celelalte se rezolv\u0103 analog.</p> <p>Vom parcurge vectorul de la st\u00e2nga la dreapta, iar pe o stiv\u0103 vom re\u021bine indicii cu elemente mai mici sau egale cu elementul curent. Cu alte cuvinte, pentru fiecare element, scoatem de pe stiv\u0103 toate elementele mai mici sau egale cu el. Dac\u0103 stiva este goal\u0103, atunci r\u0103spunsul este \\(-1\\), altfel este indicele elementului de pe v\u00e2rful stivei. Apoi, \u00eel ad\u0103ug\u0103m pe el \u00eensu\u0219i \u00een stiv\u0103.</p> <p>Observa\u021bie important\u0103</p> <p>Pe stiv\u0103 vom re\u021bine indici, nu valori. Acest lucru va fi valabil pentru o mare parte din problemele de stiv\u0103 pe care le rezolva\u021bi.</p> <p>Exemplu</p> <p>Vom face o simulare a acestui algoritm, folosindu-ne de exemplul din problem\u0103, \\(v = [1 \\ 2 \\ 3 \\ 6 \\ 4 \\ 5 \\ 3 \\ 2 \\ 1 \\ 10]\\). Ca \u00een problem\u0103, vectorul va fi indexat de la 0.</p> <ul> <li>Suntem la indicele 0, \\(stiva = []\\). R\u0103spunsul va fi -1.</li> <li>Suntem la indicele 1, \\(stiva = [0]\\), dar \u00eel scoatem, iar apoi \\(stiva =   []\\). R\u0103spunsul va fi \\(-1\\).</li> <li>Suntem la indicele 2, \\(stiva = [1]\\), dar \u00eel scoatem, iar apoi \\(stiva =   []\\). R\u0103spunsul va fi \\(-1\\).</li> <li>Suntem la indicele 3, \\(stiva = [2]\\), dar \u00eel scoatem, iar apoi \\(stiva =   []\\). R\u0103spunsul va fi \\(-1\\).</li> <li>Suntem la indicele 4, \\(stiva = [3]\\). R\u0103spunsul va fi 3.</li> <li>Suntem la indicele 5, \\(stiva = [3 \\ 4]\\), dar \u00eel scoatem pe 4.   R\u0103spunsul va fi 3.</li> <li>Suntem la indicele 6, \\(stiva = [3 \\ 5]\\). R\u0103spunsul va fi 5.</li> <li>Suntem la indicele 7, \\(stiva = [3 \\ 5 \\ 6]\\). R\u0103spunsul va fi 6.</li> <li>Suntem la indicele 8, \\(stiva = [3 \\ 5 \\ 6 \\ 7]\\). R\u0103spunsul va fi 7.</li> <li>Suntem la indicele 9, \\(stiva = [3 \\ 5 \\ 6 \\ 7 \\ 8]\\), dar le scoatem pe   toate, iar apoi \\(stiva = []\\). R\u0103spunsul va fi \\(-1\\).</li> </ul> <p>Aceast\u0103 rezolvare are complexitatea \\(\\mathcal{O}(N)\\), pentru c\u0103 fiecare element va fi pus pe stiv\u0103 \u0219i scos, deci se vor face cel mult dou\u0103 opera\u021bii pentru fiecare.</p> <p>Analiza amortizat\u0103</p> <p>Pentru a \u00een\u021belege de ce complexitatea este liniar\u0103, pute\u021bi citi aici mai multe detalii.</p> <p>Detalii de implementare: vom re\u021bine o matrice \\(raspuns[tip - 1][i]\\) care va reprezenta r\u0103spunsul la o \u00eentrebare de tipul \\(tip \\ i\\). De asemenea, vom folosi o santinel\u0103, care va fi o valoare care va fi mereu mai mic\u0103 (sau mai mare, \u00een func\u021bie de caz) dec\u00e2t orice valoare din vector. Pentru mai multe detalii, vezi implementarea de mai jos.</p> <pre><code>#include &lt;iostream&gt;\n\nusing namespace std;\n\n#define MAXN 200000\n#define MAXTIP 4\n#define INFINIT 2000000000\n\nint v[MAXN + 2], raspuns[MAXTIP][MAXN + 1], stiva[MAXN + 1];\n\nint main() {\n    ios_base::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n\n    int n, sp;\n    cin &gt;&gt; n;\n    for (int i = 1; i &lt;= n; i++) {\n        cin &gt;&gt; v[i];\n    }\n\n    // santinela\n    v[0] = INFINIT;\n    stiva[0] = 0;\n    sp = 1;\n\n    // intrebari de tip 1\n    for (int i = 1; i &lt;= n; i++) {\n        // scoatem elementele mai mici sau egale\n        while (v[stiva[sp - 1]] &lt;= v[i]) {\n            sp--;\n        }\n        raspuns[0][i] = stiva[sp - 1];  // primul element mai mare\n        stiva[sp++] = i;                // adaugam i in stiva\n    }\n\n    // santinela\n    v[0] = 0;\n    stiva[0] = 0;\n    sp = 1;\n\n    // intrebari de tip 2\n    for (int i = 1; i &lt;= n; i++) {\n        // scoatem elementele mai mari sau egale\n        while (v[stiva[sp - 1]] &gt;= v[i]) {\n            sp--;\n        }\n        raspuns[1][i] = stiva[sp - 1];  // primul element mai mic\n        stiva[sp++] = i;\n    }\n\n    // santinela\n    v[n + 1] = INFINIT;\n    stiva[0] = n + 1;\n    sp = 1;\n\n    // intrebari de tip 3\n    for (int i = n; i &gt;= 1; i--) {\n        // scoatem elementele mai mici sau egale\n        while (v[stiva[sp - 1]] &lt;= v[i]) {\n            sp--;\n        }\n        raspuns[2][i] = stiva[sp - 1];  // primul element mai mare\n        stiva[sp++] = i;\n    }\n\n    // santinela\n    v[n + 1] = 0;\n    stiva[0] = n + 1;\n    sp = 1;\n\n    // intrebari de tip 4\n    for (int i = n; i &gt;= 1; i--) {\n        // scoatem elementele mai mari sau egale\n        while (v[stiva[sp - 1]] &gt;= v[i]) {\n            sp--;\n        }\n        raspuns[3][i] = stiva[sp - 1];\n        stiva[sp++] = i;\n    }\n\n    int q;\n    cin &gt;&gt; q;\n    while (q--) {\n        int tip, poz;\n        cin &gt;&gt; tip &gt;&gt; poz;\n        cout &lt;&lt; raspuns[tip - 1][poz + 1] - 1 &lt;&lt; \"\\n\";\n    }\n\n    return 0;\n}\n</code></pre>","tags":["stiva","structuri de date"]},{"location":"mediu/stack/#probleme-rezolvate","title":"Probleme rezolvate","text":"","tags":["stiva","structuri de date"]},{"location":"mediu/stack/#problema-skyline","title":"Problema skyline","text":"<p>Pentru a rezolva aceast\u0103 problem\u0103, va trebui s\u0103 afl\u0103m pentru fiecare valoare care este cea mai apropiat\u0103 pozi\u021bie de la st\u00e2nga \u0219i de la dreapta cu o \u00een\u0103l\u021bime mai mic\u0103 dec\u00e2t cea curent\u0103.</p> <p>Dup\u0103 ce afl\u0103m aceste valori, tot ce trebuie s\u0103 facem este s\u0103 folosim sume par\u021biale pentru a calcula aria cerut\u0103 pentru fiecare pozi\u021bie.</p> <pre><code>#include &lt;fstream&gt;\n\nusing namespace std;\n\nifstream fin(\"skyline.in\");\nofstream fout(\"skyline.out\");\n\nconst int nmax = 40000;\nint length[5 + nmax], height[5 + nmax], l[5 + nmax], stk[5 + nmax];\n// l[i] = cel mai mare j &lt; i pentru care height[j] &lt; height[i]\n\nint main() {\n    int n;\n    fin &gt;&gt; n;\n    int ptr = 0;\n    for (int i = 1; i &lt;= n; i++) {\n        fin &gt;&gt; height[i] &gt;&gt; length[i];\n        length[i] += length[i - 1];  // fac sume partiale pe length[]\n        while (ptr &gt; 0 &amp;&amp; height[stk[ptr - 1]] &gt;= height[i]) {\n            ptr--;\n        }\n        if (ptr == 0) {\n            l[i] = 0;\n        } else {\n            l[i] = stk[ptr - 1];\n        }\n        stk[ptr++] = i;\n    }\n    ptr = 0;\n    long long ans = 0;\n    for (int i = n; i &gt;= 1; i--) {\n        while (ptr &gt; 0 &amp;&amp; height[stk[ptr - 1]] &gt;= height[i]) {\n            ptr--;\n        }\n        int r;  // r = cel mai mic j &gt; i pentru care height[j] &lt; height[i]\n        if (ptr == 0) {\n            r = n + 1;\n        } else {\n            r = stk[ptr - 1];\n        }\n        stk[ptr++] = i;\n        ans = max(ans, 1ll * height[i] * (length[r - 1] - length[l[i]]));\n    }\n    fout &lt;&lt; ans &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["stiva","structuri de date"]},{"location":"mediu/stack/#problema-unific-oji-2013-vii","title":"Problema unific - OJI 2013 VII","text":"<p>Mai \u00eent\u00e2i, vom defini urmatoarele dou\u0103 functii:</p> <ol> <li>\\(canJoin(x, y) = 1\\) dac\u0103 putem unifica \\(x\\) si \\(y\\), 0 altfel</li> <li>\\(join(x, y) =\\) rezultatul unific\u0103rii dintre \\(x\\) si \\(y\\)</li> </ol> <p>Sa simplific\u0103m enun\u021bul astfel: G\u0103sim primul \\(i (1 &lt; i \\leq n)\\) pentru care \\(canJoin(a_{i - 1}, a_i) = 1\\) (dac\u0103 nu exist\u0103 atunci termin\u0103m procedeul). Set\u0103m \\(a_{i - 1}\\) la \\(join(a_{i - 1}, a_i)\\) si scoatem \\(a_i\\) din \u0219ir. Acum, dac\u0103 \\(i &gt; 2\\) \u0219i \\(canJoin(a_{i - 2}, a_{i - 1}) = 0\\) continu\u0103m c\u0103utarea de la \\(i + 1\\). Altfel, set\u0103m \\(a_{i - 1}\\) la \\(join(a_{i - 3}, a_{i - 1})\\) \u0219i continu\u0103m tot a\u0219a.</p> <p>Observ\u0103m c\u0103 noi trebuie s\u0103 scoatem elemente din \u0219ir, iar acest lucru nu este u\u0219or \u00eentr-un vector. A\u0219a c\u0103, atunci c\u00e2nd ajungem la \\(i\\), vom men\u021bine \u00eentr-o stiv\u0103 grupurile care s-au format p\u00e2n\u0103 la \\(i\\). Apoi, c\u00e2t timp stiva nu este goal\u0103, vom \u00eencerca s\u0103 unificam v\u00e2rful stivei cu \\(a_i\\). Dac\u0103 \\(canJoin(top(), a_i) = 1\\) atunci set\u0103m \\(a_i\\) la \\(join(top(), a_i)\\) \u0219i scoatem v\u00e2rful. Altfel, adaug\u0103m \\(a_i\\) in stiva \u0219i continu\u0103m cu \\(i + 1\\).</p> <p>Sursa de 100 de puncte:</p> <pre><code>#include &lt;fstream&gt;\n\nconst int MAXN = 100'000;\nconst int MAXCF = 10;\nconst int FARA_CIFRE = -1;\n\nstd::ifstream fin(\"unific.in\");\nstd::ofstream fout(\"unific.out\");\nint n, sp, fr[MAXCF], fra[MAXCF], frb[MAXCF];\nlong long v[MAXN], stiva[MAXN];\n\nvoid readArray() {\n    int i;\n    fin &gt;&gt; n;\n    for (i = 0; i &lt; n; i++) {\n        fin &gt;&gt; v[i];\n    }\n}\n\nvoid getMostFrequent() {\n    int i, max;\n    long long val;\n    for (i = 0; i &lt; n; i++) {\n        val = v[i];  // vrem sa pastram valoarea\n        while (val &gt; 0) {\n            fr[val % 10]++;\n            val /= 10;\n        }\n    }\n    max = 0;\n    for (i = 1; i &lt; MAXCF; i++) {\n        if (fr[i] &gt; fr[max]) {\n            max = i;\n        }\n    }\n    fout &lt;&lt; max &lt;&lt; \"\\n\";\n}\n\nvoid getDigitFrequencies(long long val, int fr[MAXCF]) {\n    do {  // tratam si cazul val = 0\n        fr[val % 10]++;\n        val /= 10;\n    } while (val &gt; 0);\n}\n\nint canJoin(long long a, long long b) {\n    int i;\n    for (i = 0; i &lt; MAXCF; i++) {\n        fra[i] = frb[i] = 0;\n    }\n    getDigitFrequencies(a, fra);\n    getDigitFrequencies(b, frb);\n    i = 0;  // cautam prima cifra care apare la ambii\n    while (i &lt; MAXCF &amp;&amp; (fra[i] == 0 || frb[i] == 0)) {\n        i++;\n    }\n    return i &lt; MAXCF;  // daca am gasit vreuna\n}\n\nlong long removeCommonDigits(long long val, int other_fr[]) {\n    long long p, rez;\n    int cf, has_digits;\n    p = 1;\n    while (p * 10 &lt;= val) {\n        p *= 10;\n    }\n    rez = has_digits = 0;\n    while (p &gt; 0) {\n        cf = val / p % 10;\n        if (other_fr[cf] == 0) {  // daca nu e comuna\n            rez = rez * 10 + cf;  // adaugam cifra\n            has_digits = 1;\n        }\n        p /= 10;\n    }\n    return has_digits ? rez : FARA_CIFRE;\n}\n\n// consideram ca am aplicat inainte canJoin(a, b)\n// asta inseamna ca fra si frb sunt calculate deja\nlong long join(long long a, long long b) {\n    long long p, rez;\n    a = removeCommonDigits(a, frb);  // numarul nou al lui a\n    b = removeCommonDigits(b, fra);  // numarul nou al lui b\n    if (a != FARA_CIFRE\n        || b != FARA_CIFRE) {   // ambele dispar daca ambele n-au cifre\n        if (a == FARA_CIFRE) {  // nu mai conteaza ca nu are cifre\n            a = 0;\n        }\n        p = 1;\n        while (p &lt;= b) {\n            p *= 10;\n        }\n        if (b == 0) {\n            p = 10;  // si cifra asta trebuie luata in considerare\n        }\n        if (b == FARA_CIFRE) {  // setam la 0 ca sa nu ne afecteze rezultatul\n            b = 0;\n        }\n        a = a * p + b;  // lipim numerele\n    }\n    return a;\n}\n\nvoid unifyArray() {\n    int i;\n    for (i = 0; i &lt; n; i++) {\n        while (sp &gt; 0 &amp;&amp; v[i] &gt;= 0 &amp;&amp; canJoin(stiva[sp - 1], v[i])) {\n            v[i] = join(stiva[sp - 1], v[i]);\n            sp--;  // scoatem varful din stiva\n        }\n        if (v[i] != FARA_CIFRE) {  // daca mai are cifre\n            stiva[sp++] = v[i];    // adaugam elementul in stiva\n        }\n    }\n    fout &lt;&lt; sp &lt;&lt; \"\\n\";  // cate sunt\n    for (i = 0; i &lt; sp; i++) {\n        fout &lt;&lt; stiva[i] &lt;&lt; \" \";\n    }\n    fout &lt;&lt; \"\\n\";\n}\n\nint main() {\n    readArray();\n    getMostFrequent();\n    unifyArray();\n    return 0;\n}\n</code></pre>","tags":["stiva","structuri de date"]},{"location":"mediu/stack/#problema-swap-oni-2013-baraj-juniori","title":"Problema swap - ONI 2013 Baraj Juniori","text":"<p>Notam cu \\(S\\) \u0219irul de paranteze. Pentru punctul a), \u00een timp ce parcurgem \u0219irul de paranteze, vom men\u021bine o stiv\u0103 care va con\u021bine indicii parantezelor deschise c\u0103rora nu le-am g\u0103sit \u00eenc\u0103 o pereche. De fiecare dat\u0103 c\u00e2nd d\u0103m peste o parantez\u0103 deschisa, \u00eei adaug\u0103m indicele \u00een stiv\u0103, iar atunci c\u00e2nd d\u0103m peste o parantez\u0103 \u00eenchis\u0103, \\(top()\\) va fi perechea ei. Adun\u0103m la r\u0103spuns \\(i - top()\\), scoatem v\u00e2rful din stiv\u0103 \u0219i continu\u0103m cu \\(i + 1\\). Punctele b) \u0219i c) pot fi rezolvate \u00eempreun\u0103. Deducem urm\u0103toarele trei cazuri:</p> <ol> <li>\\(S_i = S_{i + 1}\\), unde \\(i\\) \u0219i \\(i + 1\\) sunt parantezele interschimbate.    Atunci, r\u0103spunsul va r\u0103m\u00e2ne exact la fel, deci nu este o opera\u021bie swap valid\u0103</li> <li>\\(S_i = )\\) \u0219i \\(S_{i + 1} = (\\). \u00cen acest caz, exist\u0103 un \\(a (a &lt; i)\\) \u0219i un $b (i</li> <li>1 &lt; b)$ astfel \u00eenc\u00e2t \\(S_a = (\\), \\(S_b = )\\), \u0219i \\((a, i)\\), respectiv \\((i + 1,    b)\\) formau perechi. Costurile lor \u00eensumate vor fi $i - a + b - i - 1 = b - a</li> <li>1$. C\u00e2nd interschimb\u0103m \\(S_i\\) cu \\(S_{i + 1}\\) ob\u021binem perechile \\((a, b)\\) \u0219i    \\((i, i + 1)\\), ale c\u0103ror costuri \u00eensumate dau \\(b - a + 1\\). Deci r\u0103spunsul a    crescut cu 2, ceea ce \u00eenseamn\u0103 c\u0103 nu este o opera\u021bie swap valid\u0103.</li> <li>\\(S_i = (\\) \u0219i \\(S_{i + 1} = )\\). Dac\u0103 nu exist\u0103 nici un \\(a (a &lt; i)\\) astfel \u00eenc\u00e2t    \\(S_a = (\\) \u0219i perechea lui \\(a\\) (pe care o not\u0103m cu \\(b\\)) s\u0103 fie mai mare ca $i</li> <li>1$, atunci opera\u021bia nu ar fi valid\u0103, deoarece nu am avea pereche pentru    \\(S_i\\) dac\u0103 \\(S_i = )\\). Mai \u00eentai, avem perechile \\((a, b)\\) \u0219i \\((i, i + 1)\\).    Dup\u0103 cum am v\u0103zut la cazul 2, r\u0103spunsul ar fi mai mic cu 2 dac\u0103 perechile    ar fi \\((a, i)\\) \u0219i \\((i + 1, b)\\). Deci opera\u021bia swap este valid\u0103.</li> </ol> <p>Observ\u0103m c\u0103 singurul caz \u00een care opera\u021bia swap este valid\u0103 este atunci c\u00e2nd \\(S_i = (, S_{i + 1} = )\\) \u0219i exist\u0103 un \\(a &lt; i\\), \\(S_a = (\\), a c\u0103rui pereche \\(b\\) este mai mare ca \\(i + 1\\). Acest lucru se poate simplifica astfel: C\u0103ut\u0103m un \\(i\\) care respect\u0103 urm\u0103toarele condi\u021bii:</p> <ol> <li>\\(S_i = )\\)</li> <li>\u00cenainte s\u0103 scoatem perechea lui \\(i\\), stiva trebuie s\u0103 aiba cel pu\u021bin 2    elemente</li> <li>V\u00e2rful stivei trebuie s\u0103 aib\u0103 valoarea \\(i - 1\\).</li> </ol> <p>Deci noi, trebuie s\u0103 num\u0103r\u0103m c\u00e2\u021bi \\(i\\) respect\u0103 cele trei condi\u021bii. Dac\u0103 g\u0103sim vreunul, r\u0103spunsul este \\(rez - 2\\), unde \\(rez\\) este r\u0103spunsul de la punctul a). Altfel, r\u0103spunsul este \\(-1\\).</p> <p>Sursa de 100 de puncte:</p> <pre><code>#include &lt;fstream&gt;\n\nconst int MAXN = 90'000;\nconst char DESCHISA = '(';\nconst char INCHISA = ')';\n\nstd::ifstream fin(\"swap.in\");\nstd::ofstream fout(\"swap.out\");\nint stiva[MAXN], sp;\n\nvoid calcAnswer() {\n    int i, n, ch, cate;\n    long long rez;\n    fin &gt;&gt; n;\n    rez = cate = 0;\n    while ((ch = fin.get()) != '(')\n        ;  // asta va fi mereu primul caracter\n    for (i = 0; i &lt; n; i++) {\n        if (ch == DESCHISA) {\n            stiva[sp++] = i;           // il adaugam in stiva\n        } else {                       // INCHISA\n            rez += i - stiva[sp - 1];  // distanta pana la pereche\n            if (sp &gt;= 2\n                &amp;&amp; stiva[sp - 1] == i - 1) {  // conditia sa fie valida operatia\n                cate++;\n            }\n            sp--;  // scoatem perechea din stiva\n        }\n        ch = fin.get();\n    }\n    fout &lt;&lt; rez &lt;&lt; \"\\n\" &lt;&lt; (cate &gt; 0 ? rez - 2 : -1) &lt;&lt; \"\\n\" &lt;&lt; cate &lt;&lt; \"\\n\";\n}\n\nint main() {\n    calcAnswer();\n    return 0;\n}\n</code></pre>","tags":["stiva","structuri de date"]},{"location":"mediu/stack/#problema-ehab-and-prefix-mexs-codeforces-round-649","title":"Problema Ehab and Prefix MEXs - Codeforces Round 649","text":"<p>S\u0103 presupunem c\u0103 suntem la un indice \\(i\\) \u0219i am reu\u0219it s\u0103 construim tot prefixul \\([1, i - 1]\\). Dac\u0103 \\(a_{i - 1} = a_i\\), atunci \\(b_i\\) poate fi orice valoare mai mare ca \\(a_i\\). Vom \u021bine elementele care au \\(a_{i - 1} = a_i\\) \u00eentr-o stiv\u0103, deoarece ele pot lua orice valoare mai mare ca \\(a_i\\). C\u00e2nd \\(a_{i - 1} &lt; a_i\\), vom putea folosi elementele din stiv\u0103 pentru a acoperi intervalul \\([a_{i - 1}, a_i)\\). Dac\u0103 \u00een stiv\u0103 sunt mai pu\u021bin de \\(a_i - a_{i - 1} - 1\\) elemente, atunci nu putem forma prefixul \\([1, i]\\) \u0219i atunci r\u0103spunsul va fi \\(-1\\). Altfel, set\u0103m \\(b_i\\) la \\(a_{i - 1}\\). Apoi lu\u0103m primele \\(a_i - a_{i - 1} - 1\\) elemente, le set\u0103m la \\(a_{i - 1} + 1, a_{i - 1} + 2, .., a_i - 1\\) \u0219i apoi le scoatem din stiv\u0103. Restul elementelor, care au r\u0103mas \u00een stiv\u0103 dup\u0103 ce am trecut prin tot \u0219irul, pot fi setate la \\(n + 1\\) sau la orice valoare mai mare ca \\(n\\).</p> <p>Codul de Accepted:</p> <pre><code>#include &lt;iostream&gt;\n\nconst int MAXN = 100'000;\nconst int CANNOT = -1;\n\nint n, a[MAXN + 1], answer[MAXN + 1], stiva[MAXN];\n\nvoid readArray() {\n    int i;\n    std::cin &gt;&gt; n;\n    for (i = 1; i &lt;= n; i++) {\n        std::cin &gt;&gt; a[i];\n    }\n}\n\nvoid buildAnswer() {\n    int i, sp, pot, j;\n    sp = 0;\n    pot = i = 1;\n    while (i &lt;= n &amp;&amp; pot) {\n        if (a[i] == a[i - 1]) {\n            stiva[sp++] = i;                    // il adaugam in stiva\n        } else if (a[i] - a[i - 1] &gt; sp + 1) {  // nu avem destule elemente\n            pot = 0;\n        } else {\n            answer[i] = a[i - 1];\n            for (j = a[i - 1] + 1; j &lt; a[i]; j++) {\n                // folosim elementul si il scoatem\n                answer[stiva[--sp]] = j;\n            }\n        }\n        i++;\n    }\n    while (sp &gt; 0) {\n        // setam restul elementelor la ceva care nu conteaza\n        answer[stiva[--sp]] = n + 1;\n    }\n    if (pot == 0) {\n        answer[0] = CANNOT;\n    }\n}\n\nvoid writeAnswer() {\n    int i;\n    if (answer[0] == CANNOT) {\n        std::cout &lt;&lt; CANNOT &lt;&lt; \"\\n\";\n    } else {\n        for (i = 1; i &lt;= n; i++) {\n            std::cout &lt;&lt; answer[i] &lt;&lt; \" \";\n        }\n        std::cout &lt;&lt; \"\\n\";\n    }\n}\n\nint main() {\n    readArray();\n    buildAnswer();\n    writeAnswer();\n    return 0;\n}\n</code></pre>","tags":["stiva","structuri de date"]},{"location":"mediu/stack/#concluzii","title":"Concluzii","text":"<p>Dup\u0103 cum se poate observa, odat\u0103 ce deprinde\u021bi tehnicile folosite la problemele prezentate mai sus, solu\u021biile devin mult mai u\u0219or de conceput, exist\u00e2nd foarte multe similarit\u0103\u021bi \u00eentre problemele care implic\u0103 folosirea stivei.</p>","tags":["stiva","structuri de date"]},{"location":"mediu/stack/#probleme-suplimentare","title":"Probleme suplimentare","text":"<ul> <li>Advertisement - CSES (O versiune mai   u\u0219oar\u0103 a problemei skyline)</li> <li>Maximum Building I - CSES (O versiune   putin mai grea a problemei skyline)</li> <li>inunda\u021bie - ONI 2022 VI (Cerin\u021bele 2 \u0219i 3   pot fi rezolvate folosind o stiv\u0103, necesit\u0103 \u0219i c\u0103utare binar\u0103).</li> <li>fuziune - ONI 2023 Baraj Juniori (Problem\u0103   asem\u0103n\u0103toare cu unific, dar necesit\u0103 lucru cu numere mari \u0219i numere prime)</li> <li>\u0219iruri - ONI 2022 VI (Problem\u0103   asem\u0103n\u0103toare cu unific)</li> <li>tower - Shumen 2016 Juniori (Nu v\u0103   speria\u021bi c\u0103 este de la Shumen, problema este doar o aplica\u021bie la   stack_max_min)</li> <li>maxp - ONI 2013 VIII (O alt\u0103 aplica\u021bie la   problema stack_max_min)</li> <li>changemin - ONI 2022 X (O aplica\u021bie   similar\u0103 cu stack_max_min)</li> <li>reactii - ONI 2009 X (Problem\u0103   asem\u0103n\u0103toare cu unific)</li> <li>cladiri - Lot 2007 seniori</li> <li>dag - ONI 2019 Baraj Seniori (Problem\u0103   care se folose\u0219te de tehnica de la stack_max_min)</li> <li>leftmax - OJI 2020 X (Problem\u0103 care se   folose\u0219te de tehinca de la stack_max_min)</li> <li>Alte probleme cu stiva de pe kilonova</li> </ul>","tags":["stiva","structuri de date"]},{"location":"mediu/stack/#bibliografie-si-lectura-suplimentara","title":"Bibliografie \u0219i lectur\u0103 suplimentar\u0103","text":"<ul> <li>std::stack - cppreference</li> <li>Articolul de pe USACO Guide despre   stiv\u0103</li> <li>Stiva - CPPI Sync</li> <li>Un video despre stiv\u0103, pentru a v\u0103 ajuta s\u0103 \u00een\u021belege\u021bi mai bine acest   concept.</li> <li>Un video despre analiza amortizat\u0103, v\u0103 va ajuta s\u0103 \u00een\u021belege\u021bi mai bine   rezolvarea problemei stack_max_min \u0219i de ce are complexitatea   \\(\\mathcal{O}(N)\\)</li> <li>Stiva - pbinfo</li> <li>Algopedia -   Stive</li> <li>Algopedia - Analiza amortizat\u0103, mai multe detalii despre problema   stack_max_min</li> </ul>","tags":["stiva","structuri de date"]},{"location":"mediu/stl-sorting-searching/","title":"Aplica\u021bii ale STL \u00een problemele de c\u0103utare \u0219i sortare","text":"","tags":["meta","greedy","structuri de date"]},{"location":"mediu/stl-sorting-searching/#introducere","title":"Introducere","text":"<p>De multe ori, avem de-a face cu probleme unde g\u0103sim o solu\u021bie care folose\u0219te o metod\u0103 de tip brute-force care func\u021bioneaz\u0103 destul de \u00eencet dar nu o putem optimiza folosind structurile de date obi\u0219nuite. Pentru aceste tipuri de probleme, de multe ori putem apela la structurile de date din STL, fie c\u0103 este vorba de a afla rapid frecven\u021ba unei valori mai mari, fie c\u0103 vrem s\u0103 \u0219tergem o anumit\u0103 valoare rapid sau s\u0103 avem alte tipuri de precalcul\u0103ri.</p> <p>\u00cen acest articol, vom prezenta c\u00e2teva exemple de probleme care nu sunt dificile \u0219i prezint\u0103 aplica\u021bii ale acestor structuri de date, aplica\u021bii de o dificultate u\u0219oar\u0103 sau medie, utile pentru oricine vrea s\u0103 se obi\u0219nuiasc\u0103 cu func\u021biile acestor biblioteci ce compun STL.</p>","tags":["meta","greedy","structuri de date"]},{"location":"mediu/stl-sorting-searching/#problema-subarray-sums-ii-cses","title":"Problema Subarray Sums II - CSES","text":"<p>Pentru a rezolva aceast\u0103 problem\u0103, putem pleca de la una din solu\u021biile care are complexitatea \\(\\mathcal{O}(n^2)\\). Aceast\u0103 solu\u021bie calculeaz\u0103 sumele par\u021biale ale \u0219irului \u0219i fixeaz\u0103 capetele din st\u00e2nga \u0219i dreapta, folosindu-se de sumele par\u021biale calculate anterior pentru a num\u0103ra secven\u021bele cu suma \\(s\\).</p> <p>O \u00eembun\u0103t\u0103\u021bire pe care o putem face const\u0103 \u00een faptul c\u0103 dac\u0103 fix\u0103m una din sumele din expresia anterioar\u0103 (s\u0103 zicem c\u0103 fix\u0103m \\(sum[r]\\)), trebuie s\u0103 afl\u0103m c\u00e2te pozi\u021bii \\(l\\) exist\u0103 astfel \u00eenc\u00e2t \\(sum[r] - sum[l] = s\\).</p> <p>Acest lucru se poate face stoc\u00e2nd cu ajutorul unui map frecven\u021ba fiec\u0103rei sume (ini\u021bializ\u0103m la \u00eenceput suma 0 cu frecven\u021ba 1, corespunz\u0103toare unui \u0219ir gol), iar pentru fiecare \\(i\\), vom actualiza datele din map \u0219i vom aduna la r\u0103spuns frecven\u021ba sumei c\u0103utate. Astfel, complexitatea algoritmului va deveni \\(\\mathcal{O}(n \\log n)\\).</p> <pre><code>#include &lt;iostream&gt;\n#include &lt;map&gt;\nusing namespace std;\n\nint main() {\n    map&lt;long long, int&gt; mp;\n    long long n, s;\n    cin &gt;&gt; n &gt;&gt; s;\n    mp[0] = 1;\n    long long ans = 0, sum = 0;\n    for (int i = 0; i &lt; n; i++) {\n        int nr;\n        cin &gt;&gt; nr;\n\n        sum += nr;\n        ans += mp[sum - s];\n        mp[sum]++;\n    }\n    cout &lt;&lt; ans;\n    return 0;\n}\n</code></pre>","tags":["meta","greedy","structuri de date"]},{"location":"mediu/stl-sorting-searching/#problema-eugene-and-an-array-codeforces","title":"Problema Eugene and an array - Codeforces","text":"<p>Solu\u021bie video</p> <p>Aceast\u0103 problem\u0103 are solu\u021bia video descris\u0103 aici</p> <p>Pentru a rezolva aceast\u0103 problem\u0103, trebuie s\u0103 g\u0103sim o proprietate a sumelor par\u021biale care s\u0103 ne ajute s\u0103 prevenim num\u0103rarea unor subsecven\u021be care au subsecven\u021be cu suma 0.</p> <p>O idee pe care am putea-o folosi este aceea de a afla pentru pozi\u021bia curent\u0103, cel mai mare cap\u0103t st\u00e2ng astfel \u00eenc\u00e2t suma elementelor dintre acele dou\u0103 pozi\u021bii s\u0103 fie egal\u0103 cu 0. Urm\u0103torul pas ar fi s\u0103 observ\u0103m faptul c\u0103 cap\u0103tul maxim din st\u00e2nga pentru care exist\u0103 o pozi\u021bie \\(j &gt; i\\) astfel \u00eenc\u00e2t suma de la pozi\u021bia \\(i+1\\) la \\(j\\) s\u0103 fie 0 este limita superioar\u0103 de la care putem ad\u0103uga subsecven\u021bele la r\u0103spuns.</p> <p>De aici, ne mai r\u0103m\u00e2ne un singur pas, \u0219i anume folosirea unei structuri de tip std::map pentru a \u021bine eviden\u021ba celor mai recente pozi\u021bii unde se g\u0103se\u0219te o anumit\u0103 sum\u0103 par\u021bial\u0103.</p> <pre><code>#include &lt;iostream&gt;\n#include &lt;map&gt;\nusing namespace std;\n\nint n, a[200002];\nmap&lt;long long, int&gt; mp;\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n\n    mp[0] = -1;\n    cin &gt;&gt; n;\n    long long sm = 0;\n    long long ans = 0;\n    int mx = 0;\n    for (int i = 1; i &lt;= n; ++i) {\n        cin &gt;&gt; a[i];\n        sm += a[i];\n        if (mp.find(sm) != mp.end()) {\n            if (sm == 0 &amp;&amp; mp[0] == -1) {\n                mx = max(mx, 1);\n            } else {\n                mx = max(mx, mp[sm] + 1);\n            }\n        }\n        mp[sm] = i;\n        ans = ans + i - mx;\n    }\n    cout &lt;&lt; ans;\n    return 0;\n}\n</code></pre>","tags":["meta","greedy","structuri de date"]},{"location":"mediu/stl-sorting-searching/#problema-ramen-oji-2018","title":"Problema ramen - OJI 2018","text":"<p>Pentru a rezolva aceast\u0103 problem\u0103, plec\u0103m de la urm\u0103toarea presupunere, care se poate demonstra foarte u\u0219or: Dac\u0103 o por\u021bie de m\u00e2ncare ajunge la persoana aflat\u0103 la pozi\u021bia \\(x\\), iar aceast\u0103 persoan\u0103 are o comand\u0103 deja, respectiva persoan\u0103 va lua por\u021bia, chiar dac\u0103 nu este por\u021bia pe care a comandat-o.</p> <p>Pe baza acestui fapt, putem s\u0103 sort\u0103m comenzile \u00een ordine cresc\u0103toare a pozi\u021biei persoanei care face acea comand\u0103 \u0219i la fiecare pas, persoana respectiv\u0103 va ob\u021bine prima comand\u0103 care trece \u00een dreptul ei, dup\u0103 ce a f\u0103cut comanda, indiferent de timpul necesar pentru preg\u0103tirea ei.</p> <p>Pentru a putea simula acest proces, vom folosi o structur\u0103 de tip set, care ne permite inserarea \u0219i \u0219tergerea valorilor \u00een timp logaritmic. Mai jos g\u0103si\u021bi o solu\u021bie care ob\u021bine punctajul maxim.</p> <pre><code>#include &lt;algorithm&gt;\n#include &lt;iostream&gt;\n#include &lt;set&gt;\nusing namespace std;\nifstream in(\"ramen.in\");\nofstream out(\"ramen.out\");\nint n, d;\nset&lt;int&gt; s;\nint ans[100002];\nstruct aa {\n    int care, timp, pi;\n};\naa v[100002];\nbool cmp(aa a, aa b) {\n    if (a.care == b.care) {\n        return a.timp &lt; b.timp;\n    }\n    return a.care &lt; b.care;\n}\nint main() {\n    in &gt;&gt; n &gt;&gt; d;\n    for (int i = 1; i &lt;= n; ++i) {\n        in &gt;&gt; v[i].timp &gt;&gt; v[i].care;\n        v[i].pi = i;\n        s.insert(v[i].timp + d);\n    }\n    sort(v + 1, v + n + 1, cmp);\n    for (int i = 1; i &lt;= n; ++i) {\n        auto it = s.lower_bound(v[i].timp - v[i].care);\n        ans[v[i].pi] = *it + v[i].care;\n        s.erase(it);\n    }\n    for (int i = 1; i &lt;= n; ++i) {\n        out &lt;&lt; ans[i] &lt;&lt; '\\n';\n    }\n    return 0;\n}\n</code></pre>","tags":["meta","greedy","structuri de date"]},{"location":"mediu/stl-sorting-searching/#concluzii","title":"Concluzii","text":"<p>Aceste tipuri de probleme se dovedesc a fi foarte u\u0219or de abordat odat\u0103 ce avem la dispozi\u021bie facilit\u0103\u021bile potrivite, deoarece simplific\u0103rile g\u0103site sunt acum mult mai u\u0219or de implementat. Totu\u0219i, trebuie avut \u00een vedere c\u0103 aceste structuri de date nu sunt mereu cea mai optim\u0103 variant\u0103 \u0219i este bine s\u0103 ne g\u00e2ndim la abord\u0103ri care s\u0103 se muleze \u0219i pe restric\u021biile problemelor \u00een sine.</p>","tags":["meta","greedy","structuri de date"]},{"location":"mediu/stl-sorting-searching/#probleme-suplimentare","title":"Probleme suplimentare","text":"<ul> <li>CPPI 2024 Highlight</li> <li>CSES Apartments</li> <li>OJI 2023 parcare</li> <li>USACO Silver Convention II</li> <li>Codeforces Voting (easy)</li> <li>Codeforces Good Subarrays</li> <li>Codeforces William and Robot</li> <li>OJI 2024 parking</li> <li>USACO Gold Snow Boots</li> </ul>","tags":["meta","greedy","structuri de date"]},{"location":"mediu/stl-sorting-searching/#resurse-suplimentare","title":"Resurse suplimentare","text":"<ul> <li>More Operations on Sorted Sets - USACO Guide</li> <li>Sets with custom comparators - USACO Guide</li> </ul>","tags":["meta","greedy","structuri de date"]},{"location":"mediu/toposort/","title":"Sortare topologic\u0103","text":"","tags":["grafuri","grafuri orientate","parcurgere","sortare","recursivitate"]},{"location":"mediu/toposort/#teorie","title":"Teorie","text":"<p>Definitie</p> <p>\u00centr-un graf orientat \u0219i aciclic, definim sortarea topologic\u0103 ca fiind o ordine a nodurilor (nu neap\u0103rat unic\u0103), astfel \u00eenc\u00e2t, dac\u0103 not\u0103m cu \\(P\\) lista pozi\u021biilor nodurilor, iar \\(A\\) \u0219i \\(B\\) sunt dou\u0103 noduri, cu muchie de la \\(A\\) la \\(B\\), $$P_A &lt; P_B $$</p>","tags":["grafuri","grafuri orientate","parcurgere","sortare","recursivitate"]},{"location":"mediu/toposort/#spre-exemplu","title":"Spre exemplu","text":"<pre><code>graph LR\nA((1)) --&gt; B((2))\nB --&gt; C((3))\nA --&gt; D((4))\nA --&gt; E((5))\nE --&gt; C\n</code></pre> <p>\u00cen acest graf, o sortare topologic\u0103 valid\u0103 ar fi: <code>1, 2, 5, 3, 4</code> , deoarece 1 se afl\u0103 \u00eenaintea lui 2, 5 \u00eenaintea lui 3, etc. Un alt exemplu ar fi <code>1, 4, 5, 2, 3</code> . O ordine incorect\u0103 ar fi \u00eens\u0103 <code>1, 4, 2, 3, 5</code> , deoarece 5 se afl\u0103 dup\u0103 3, de\u0219i exist\u0103 muchie de la 5 la 3.</p>","tags":["grafuri","grafuri orientate","parcurgere","sortare","recursivitate"]},{"location":"mediu/toposort/#un-alt-exemplu","title":"Un alt exemplu","text":"<pre><code>graph LR\nA((1)) --&gt; B((2))\nB --&gt; D((3))\nC((4)) --&gt; A\nD --&gt; C\n</code></pre> <p>Acest graf con\u021bine un ciclu (de fapt chiar este unul), mai exact \\(1, 2, 3, 4\\) . Astfel, putem alege 2 noduri, \\(A\\) \u0219i \\(B\\), astfel \u00eenc\u00e2t ele apar\u021bin aceluia\u0219i ciclu (se poate ajunge de la \\(A\\) la \\(B\\) \u0219i viceversa). Dar asta implic\u0103 faptul c\u0103 \u00een sortarea topologic\u0103, \\(A\\) se afl\u0103 \u00een fa\u021ba lui \\(B\\), dar \u0219i c\u0103 \\(B\\) se afl\u0103 \u00eenaintea lui \\(A\\), ceea ce duce la o contradic\u021bie. A\u0219adar, \u00eentr-un graf ce con\u021bine un ciclu, nu exist\u0103 nicio sortare topologic\u0103.</p>","tags":["grafuri","grafuri orientate","parcurgere","sortare","recursivitate"]},{"location":"mediu/toposort/#algoritmul","title":"Algoritmul","text":"<p>\u00cent\u00e2i, vom presupune c\u0103 graful este aciclic.</p> <p>Numim vecin al unui nod \\(U\\), un nod \\(V\\), astfel \u00eenc\u00e2t exist\u0103 muchie de la \\(U\\) la \\(V\\). \u00cens\u0103, \u0219tim c\u0103 pentru orice dou\u0103 noduri \\(U\\) \u0219i \\(V\\), pentru care exist\u0103 muchie de la \\(U\\) la \\(V\\), \\(U\\) se afl\u0103 \u00eenaintea lui \\(V\\) \u00een ordinea topologic\u0103.</p> <p>A\u0219adar, \u00een sortarea topologic\u0103, orice nod se afl\u0103 \u00eenaintea vecinilor s\u0103i.</p> <p>\u00cen acela\u0219i timp, \u00eentr-o parcurgere <code>DFS</code>, vom intra \u00een vecinii unui nod dup\u0103 ce intr\u0103m \u00een acesta. Putem defini timpul de ie\u0219ire al unui nod ca fiind momentul la care ne \u00eentoarcem din recursivitate \u00eenapoi la el (pentru simplitate, timpii pot fi numerota\u021bi de la 1 la \\(n\\), unde \\(n\\) este num\u0103rul de noduri). Astfel, timpul de ie\u0219ire al unui nod va fi tot timpul mai mare dec\u00e2t cel al vecinilor s\u0103i, deci pentru a afla ordinea topologic\u0103, trebuie doar s\u0103 sort\u0103m nodurile descresc\u0103tor dup\u0103 timpii de ie\u0219ire.</p> <p>Pentru a face acest lucru mai simplu, putem doar s\u0103 ad\u0103ug\u0103m nodurile \u00eentr-o list\u0103 goal\u0103, pe care o vom inversa la sf\u00e2r\u0219it. S\u0103 ne uit\u0103m la urm\u0103toarea secven\u021b\u0103 de cod:</p> <pre><code>#include &lt;algorithm&gt;\n#include &lt;iostream&gt;\n#include &lt;vector&gt;\n\n// Valoare maxima arbitrara pentru numarul maxim de noduri\nconst int NMAX = 10002;\n\n// Listele de adiacenta\nstd::vector&lt;std::vector&lt;int&gt;&gt; lista_adj(NMAX);\n\n// Lista nodurilor sortate dupa timpii de iesire\nstd::vector&lt;int&gt; ord;\n\n// Daca un nod a mai fost vizitat pana acum sau nu\nstd::vector&lt;bool&gt; viz(NMAX);\n\nvoid dfs(int nod) {\n\n    viz[nod] = 1;\n    // Parcurgem lista vecinilor\n    for (auto vecin : lista_adj[nod]) {\n        // Ne intereseaza doar cei care nu au mai fost vizitati\n        if (!viz[vecin]) {\n            dfs(vecin);\n        }\n    }\n\n    // La intoarcerea din recursivitate adaugam nodul in lista\n    ord.push_back(nod);\n}\n\nint main() {\n    int n, m, u, v;\n\n    // Citire\n    std::cin &gt;&gt; n &gt;&gt; m;\n\n    while (m--) {\n        std::cin &gt;&gt; u &gt;&gt; v;\n        lista_adj[u].push_back(v);\n    }\n\n    // Incepem parcurgerea dfs\n    dfs(1);\n\n    // Inversam lista nodurilor sortate dupa timpii de iesire\n    std::reverse(ord.begin(), ord.end());\n\n    // Afisare\n    for (auto nod : ord) {\n        std::cout &lt;&lt; nod &lt;&lt; \" \";\n    }\n    return 0;\n}\n</code></pre> <p>Acest cod este \u00eens\u0103 gre\u0219it \u0219i nu va da rezultatul corect pentru anumite cazuri. S\u0103 lu\u0103m urm\u0103torul exemplu:</p> <pre><code>graph LR\nA((1)) --&gt; B((2))\nC((3)) --&gt; A\nC --&gt; B\n</code></pre> <p>\u00cencep\u00e2nd dintr-un nod arbitrar (\u00een acest caz, 1), noi vom vizita doar nodurile \u00een care putem ajunge din el. \u00cens\u0103, \u00een exemplul dat, asta \u00eenseamn\u0103 c\u0103 vom ignora nodul 3, care \u00een sortare s-ar afla \u00eenaintea lui 1.</p> <p>Pentru a rezolva asta, putem parcurge lista tuturor nodurilor \u0219i s\u0103 verific\u0103m pentru fiecare dac\u0103 este vizitat sau nu. Pentru orice nod nevizitat, \u0219tim c\u0103 nu se poate ajunge la el din niciun nod vizitat, deci este corect s\u0103 spunem c\u0103 orice nod nevizitat se poate afla \u00eenaintea nodurilor deja vizitate.</p> <p>A\u0219adar, pentru orice nod nevizitat, putem \u00eencepe o parcurgere <code>DFS</code> din el \u0219i putem ad\u0103uga \u00een continuare nodurile \u00een lista final\u0103, \u00een func\u021bie de timpul lor de ie\u0219ire.</p> <pre><code>#include &lt;algorithm&gt;\n#include &lt;iostream&gt;\n#include &lt;vector&gt;\n\n// Valoare maxima arbitrara pentru numarul maxim de noduri\nconst int NMAX = 10002;\n\n// Listele de adiacenta\nstd::vector&lt;std::vector&lt;int&gt;&gt; lista_adj(NMAX);\n\n// Lista nodurilor sortate dupa timpii de iesire\nstd::vector&lt;int&gt; ord;\n\n// Daca un nod a mai fost vizitat pana acum sau nu\nstd::vector&lt;bool&gt; viz(NMAX);\n\nvoid dfs(int nod) {\n\n    viz[nod] = 1;\n    // Parcurgem lista vecinilor\n    for (auto vecin : lista_adj[nod]) {\n        // Ne intereseaza doar cei care nu au mai fost vizitati\n        if (!viz[vecin]) {\n            dfs(vecin);\n        }\n    }\n\n    // La intoarcerea din recursivitate adaugam nodul in lista\n    ord.push_back(nod);\n}\n\nint main() {\n    int n, m, u, v;\n\n    // Citire\n    std::cin &gt;&gt; n &gt;&gt; m;\n\n    while (m--) {\n        std::cin &gt;&gt; u &gt;&gt; v;\n        lista_adj[u].push_back(v);\n    }\n\n    // Iteram prin lista nodurilor\n    for (int i = 1; i &lt;= n; i++) {\n        // Daca este nevizitat, incepem parcurgerea DFS din el\n        if (!viz[i]) {\n            dfs(i);\n        }\n    }\n\n    // Inversam lista nodurilor sortate dupa timpii de iesire\n    std::reverse(ord.begin(), ord.end());\n\n    // Afisare\n    for (auto nod : ord) {\n        std::cout &lt;&lt; nod &lt;&lt; \" \";\n    }\n    return 0;\n}\n</code></pre> <p>Acest cod este corect \u0219i va returna o sortare topologic\u0103 valid\u0103 (nu neap\u0103rat unic\u0103).</p>","tags":["grafuri","grafuri orientate","parcurgere","sortare","recursivitate"]},{"location":"mediu/toposort/#complexitatea-algoritmului","title":"Complexitatea algoritmului","text":"<p>Datorit\u0103 faptului c\u0103 folosim o singur\u0103 parcurgere <code>DFS</code>, algoritmul va avea complexitate liniar\u0103 \\(\\mathcal{O}(n + m)\\), unde \\(n\\) este num\u0103rul de noduri, iar \\(m\\) num\u0103rul de muchii. Memoria va fi tot \\(\\mathcal{O}(n + m)\\).</p>","tags":["grafuri","grafuri orientate","parcurgere","sortare","recursivitate"]},{"location":"mediu/toposort/#exemplu-de-problema-cses-course-schedule","title":"Exemplu de Problema: CSES - Course Schedule","text":"","tags":["grafuri","grafuri orientate","parcurgere","sortare","recursivitate"]},{"location":"mediu/toposort/#cerinta","title":"Cerin\u021b\u0103","text":"<p>Se dau \\(n\\) cursuri, numerotate de la 1 la \\(n\\) \u0219i \\(m\\) condi\u021bii ce trebuie \u00eendeplinite, de forma a doi indici, \\(i\\) \u0219i \\(j\\), cu proprietatea ca acel curs cu num\u0103rul \\(i\\) trebuie terminat \u00eenaintea cursului cu num\u0103rul \\(j\\).</p> \\[1 \\leqslant i &lt; j \\leqslant n\\] <p>Se cere s\u0103 se afi\u0219eze o ordine \u00een care s\u0103 fie f\u0103cute aceste cursuri, astfel \u00eenc\u00e2t toate condi\u021biile s\u0103 fie \u00eendeplinite. Dac\u0103 nu exist\u0103 nicio solu\u021bie, se va afi\u0219a \"IMPOSSIBLE\".</p>","tags":["grafuri","grafuri orientate","parcurgere","sortare","recursivitate"]},{"location":"mediu/toposort/#solutie","title":"Solu\u021bie","text":"<p>Nu este greu s\u0103 ne d\u0103m seama c\u0103 acele 'condi\u021bii' pot fi reprezentate ca ni\u0219te muchii orientate \u00eentr-un graf, iar ordinea valid\u0103 a realiz\u0103rii task-urilor va fi cea din sortarea topologic\u0103 a grafului rezultat. \u00cen cazul \u00een care graful con\u021bine cicluri, algoritmul tot va returna o anumit\u0103 ordine a nodurilor. Astfel, putem parcurge din nou fiecare condi\u021bie \u0219i s\u0103 verific\u0103m dac\u0103 fiecare condi\u021bie e \u00eendeplinit\u0103, iar dac\u0103 nu e, \u00eenseamn\u0103 c\u0103 nu avem solu\u021bie. Putem verifica acest lucru u\u0219or \u021bin\u00e2nd minte \u00eentr-un vector pozi\u021biile nodurilor din sortarea topologic\u0103 \u0219i s\u0103 le compar\u0103m, cum este eviden\u021biat \u0219i \u00een acest cod:</p> <pre><code>#include &lt;algorithm&gt;\n#include &lt;iostream&gt;\n#include &lt;vector&gt;\n\n// Algoritmul descris mai sus, doar ca am schimbat un pic denumirile\nstd::vector&lt;std::vector&lt;int&gt;&gt; G(100005);\n\n// Vector cu toate muchiile\nstd::vector&lt;std::pair&lt;int, int&gt;&gt; edges;\n\nstd::vector&lt;int&gt; ord;\n\nstd::vector&lt;bool&gt; viz(100005);\n\n// Pozitia fiecarui nod in ordinea topologica\nstd::vector&lt;int&gt; poz(100005);\n\nvoid dfs(int nod) {\n    viz[nod] = 1;\n    for (auto x : G[nod]) {\n        if (!viz[x]) {\n            dfs(x);\n        }\n    }\n    ord.push_back(nod);\n}\n\nint main() {\n    int n, m, u, v;\n\n    std::cin &gt;&gt; n &gt;&gt; m;\n    while (m--) {\n        std::cin &gt;&gt; u &gt;&gt; v;\n        G[u].push_back(v);\n        // Adaugam muchia in lista de muchii\n        edges.push_back({u, v});\n    }\n\n    for (int i = 1; i &lt;= n; i++) {\n        if (!viz[i]) {\n            dfs(i);\n        }\n    }\n\n    std::reverse(ord.begin(), ord.end());\n\n    for (int i = 0; i &lt; ord.size(); i++) {\n        poz[ord[i]] = i + 1;\n    }\n\n    // Parcurgem din nou toate muchiile si verificam\n    for (auto e : edges) {\n        if (poz[e.first] &gt; poz[e.second]) {\n            // Am gasit o muchie pentru care nu este respectata ordinea topologica\n            std::cout &lt;&lt; \"IMPOSSIBLE\";\n            return 0;\n        }\n    }\n\n    // Daca ordinea respecta toate conditiile, o afisam\n    for (auto x : ord) {\n        std::cout &lt;&lt; x &lt;&lt; \" \";\n    }\n    return 0;\n}\n</code></pre>","tags":["grafuri","grafuri orientate","parcurgere","sortare","recursivitate"]},{"location":"mediu/toposort/#probleme-suplimentare","title":"Probleme suplimentare","text":"<ul> <li>Infoarena - Sortare Topologica</li> <li>CSES Course Schedule</li> <li>Infoarena Path</li> <li>RoAlgo Contest #4 Leximin</li> <li>Codeforces Fox and Names</li> <li>Infoarena easygraph</li> <li>IATI Shumen 2024 xy</li> <li>RoAlgo Contest #2 somnoros</li> <li>Infoarena alpin</li> <li>Codeforces Gym Permutation   Counting</li> </ul>","tags":["grafuri","grafuri orientate","parcurgere","sortare","recursivitate"]},{"location":"mediu/toposort/#resurse-suplimentare","title":"Resurse suplimentare","text":"<ul> <li>Topological Sorting -   cp-algorithms</li> <li>Topological Sorting - USACO Guide</li> </ul>","tags":["grafuri","grafuri orientate","parcurgere","sortare","recursivitate"]},{"location":"mediu/tree-1/","title":"Introducere \u00een arbori. Diametrul unui arbore","text":"","tags":["arbori","grafuri","diametru"]},{"location":"mediu/tree-1/#introducere","title":"Introducere","text":"<p>Arborii sunt un tip particular de grafuri, ace\u0219tia fiind denumirea folosit\u0103 pentru a defini grafurile neorientate conexe \u0219i aciclice. Se poate remarca faptul c\u0103 reprezentarea grafic\u0103 a acestora seam\u0103n\u0103 foarte mult cu configura\u021bia unui arbore din p\u0103dure, diferen\u021ba major\u0103 fiind faptul c\u0103 r\u0103d\u0103cina arborelui este plasat\u0103 de obicei \u00een partea de sus a desenului, \u00een contrast cu pozi\u021bia real\u0103 a unei r\u0103d\u0103cini. Nu suntem totu\u0219i la ora de biologie, a\u0219a c\u0103 vom continua cu definirea arborilor.</p> <p>Dintre propriet\u0103\u021bile pe care le au arborii, vom enumera cele mai importante dintre ele, acestea fiind utilizate \u00een mod alternativ \u00een enun\u021buri pentru a defini acela\u0219i lucru.</p> <ul> <li>Graf neorientat conex \u0219i aciclic.</li> <li>Graf neorientat conex cu \\(n\\) noduri \u0219i \\(n-1\\) muchii.</li> <li>Graf neorientat conex cu proprietatea c\u0103 \u00eentre oricare dou\u0103 noduri exist\u0103 un   drum unic. Aceast\u0103 proprietate ne permite folosirea DFS pentru aflarea   drumurilor minime \u00een arbore, o particularitate ce nu se \u00eent\u00e2lne\u0219te la alte   tipuri de grafuri, unde BFS sau al\u021bi algoritmi mai specializa\u021bi de drumuri   minime sunt necesare.</li> </ul> <p>Aceste propriet\u0103\u021bi speciale pe care arborii le au fa\u021b\u0103 de grafurile obi\u0219nuite fac rezolvarea multor probleme cu arbori mult mai facil\u0103 dec\u00e2t \u00een mod uzual. \u00cen acest articol vom discuta tipurile de arbori, modalit\u0103\u021bile de a fi parcur\u0219i precum \u0219i c\u00e2teva probleme elementare care pun \u00een eviden\u021b\u0103 modul \u00een care folosim arborii.</p>","tags":["arbori","grafuri","diametru"]},{"location":"mediu/tree-1/#terminologie-de-baza","title":"Terminologie de baz\u0103","text":"<p>Pe l\u00e2ng\u0103 termenii folosi\u021bi la grafuri, vom mai defini c\u00e2\u021biva termeni care sunt frecvent utiliza\u021bi \u00een contextul arborilor.</p> <ul> <li>Un nod cu gradul 1 se nume\u0219te frunz\u0103.</li> <li>Definim nivelul unui nod ca fiind distan\u021ba de la r\u0103d\u0103cin\u0103 la acesta.</li> <li>Pentru o muchie \\((x, y)\\) cu \\(nivel_x &lt; nivel_y\\), vom spune c\u0103 \\(x\\) este   p\u0103rintele lui \\(y\\).</li> <li>\u00cen\u0103l\u021bimea unui subarbore reprezint\u0103 distan\u021ba maxim\u0103 a unui nod fa\u021b\u0103 de   r\u0103d\u0103cina arborelui.</li> <li>Dac\u0103 avem dou\u0103 noduri \\(x\\) \u0219i \\(y\\) cu \\(nivel_x &lt; nivel_y\\) \u0219i distan\u021ba de la \\(x\\)   la \\(y\\) este \\(nivel_y - nivel_x\\), atunci \\(x\\) este str\u0103mo\u0219 al lui \\(y\\). \u00cen   contrast, \\(y\\) este un descendent al lui \\(x\\).</li> <li>Totalitatea nodurilor care sunt descenden\u021bii unui nod \\(x\\) formeaz\u0103 subarborele   nodului \\(x\\).</li> </ul>","tags":["arbori","grafuri","diametru"]},{"location":"mediu/tree-1/#tipuri-de-arbori","title":"Tipuri de arbori","text":"<p>\u00cen func\u021bie de particularit\u0103\u021bile pe care le au arborii, putem vorbi de urm\u0103toarele tipuri de arbori.</p> <ul> <li>Arbori cu r\u0103d\u0103cin\u0103 - arbori la care \u0219tim nodul de la care vom \u00eencepe   parcurgerile. De regul\u0103, r\u0103d\u0103cina se afl\u0103 \u00een primul nod al arborelui.</li> <li>Arbore stea - arbore \u00een care toate nodurile sunt conectate cu o muchie la un   singur alt nod.</li> <li>Arbore lan\u021b - arbore care are forma unui lan\u021b.</li> <li>Arbore binar - arbore cu proprietatea c\u0103 orice nod are cel mult doi fii.   Datorit\u0103 importan\u021bei lor, vom insista mai mult asupra lor pentru anumite   defini\u021bii viitoare.</li> </ul>","tags":["arbori","grafuri","diametru"]},{"location":"mediu/tree-1/#arbori-binari","title":"Arbori binari","text":"<p>Un arbore binar este un arbore cu proprietatea c\u0103 orice nod are cel mult doi fii. \u00cen func\u021bie de tipul acestui arbore putem defini urm\u0103toarele feluri de arbori binari.</p> <p>Observatie</p> <p>Arborii binari, datorit\u0103 structurii lor foarte versatile, ajung s\u0103 reprezinte o funda\u021bie solid\u0103 \u00een vederea \u00een\u021belegerii foarte multor algoritmi \u0219i structuri de date arborescente, foarte multe implement\u0103ri ale structurilor de date din STL av\u00e2nd la baz\u0103 arborii binari \u00een diverse forme.</p> <ul> <li>Arbore binar strict - un arbore binar \u00een care fiecare nod, cu excep\u021bia celor   terminale, are exact doi descenden\u021bi.</li> <li>Arbore binar plin - un arbore binar \u00een care fiecare nivel \\(k   \\in{0,1,2,\\dots,h}\\), unde \\(h\\) este \u00een\u0103l\u021bimea arborelui, con\u021bine \\(2^k\\) noduri.</li> <li>Arbore binar complet - un arbore binar \u00een care fiecare nivel \\(k   \\in{0,1,2,\\dots,h}\\), unde \\(h\\) este \u00een\u0103l\u021bimea arborelui, con\u021bine \\(2^k\\) noduri,   cu excep\u021bia ultimului nivel, nivelul \\(k\\) con\u021bine eventual mai pu\u021bin de \\(2^h\\)   noduri, acestea fiind grupate de regul\u0103 \u00een partea st\u00e2ng\u0103..</li> <li>Arbore binar echilibrat - un arbore binar \u00een care pentru fiecare nod,   \u00een\u0103l\u021bimea subarborilor din st\u00e2nga \u0219i din dreapta difer\u0103 cu cel mult 1.</li> <li>Arbore binar de c\u0103utare - un arbore binar \u00een care fiecare nod are o cheie   unic\u0103 de identificare care respect\u0103 urm\u0103toarele condi\u021bii: pentru orice   subarbore, cheile nodurilor din subarborele st\u00e2ng sunt mai mici dec\u00e2t cheia   r\u0103d\u0103cinii, iar pentru orice subarbore, cheile nodurilor din subarborele drept   sunt mai mari dec\u00e2t cheia r\u0103d\u0103cinii.</li> </ul>","tags":["arbori","grafuri","diametru"]},{"location":"mediu/tree-1/#parcurgerile-preordine-inordine-postordine","title":"Parcurgerile preordine, inordine, postordine","text":"<p>\u00cen func\u021bie de ordinea \u00een care parcurgem nodurile \u00eentr-un arbore binar, putem avea urm\u0103toarele tipuri de parcurgere:</p>","tags":["arbori","grafuri","diametru"]},{"location":"mediu/tree-1/#parcurgerea-preordine-rsd","title":"Parcurgerea preordine (RSD)","text":"<ul> <li>Vizit\u0103m mai \u00eent\u00e2i nodul curent</li> <li>Vizit\u0103m recursiv subarborele st\u00e2ng al nodului curent.</li> <li>Vizit\u0103m recursiv subarborele drept al nodului curent.</li> </ul> <p>Parcurgerea preordine e o parcurgere ordonat\u0103 topologic, deoarece un nod p\u0103rinte va fi mereu vizitat \u00eenaintea copiilor s\u0103i.</p>","tags":["arbori","grafuri","diametru"]},{"location":"mediu/tree-1/#parcurgerea-inordine-srd","title":"Parcurgerea inordine (SRD)","text":"<ul> <li>Vizit\u0103m recursiv subarborele st\u00e2ng al nodului curent.</li> <li>Vizit\u0103m mai \u00eent\u00e2i nodul curent</li> <li>Vizit\u0103m recursiv subarborele drept al nodului curent.</li> </ul> <p>\u00centr-un arbore binar de c\u0103utare construit astfel \u00eenc\u00e2t fiecare nod e mai mare dec\u00e2t nodurile din subarborele st\u00e2ng \u0219i mai mic dec\u00e2t nodurile din subarborele drept, parcurgerea \u00eenordine returneaz\u0103 valorile \u00een ordine cresc\u0103toare.</p>","tags":["arbori","grafuri","diametru"]},{"location":"mediu/tree-1/#parcurgerea-postordine-sdr","title":"Parcurgerea postordine (SDR)","text":"<ul> <li>Vizit\u0103m recursiv subarborele st\u00e2ng al nodului curent.</li> <li>Vizit\u0103m recursiv subarborele drept al nodului curent.</li> <li>Vizit\u0103m mai \u00eent\u00e2i nodul curent</li> </ul> <p>Parcurgerea postordine poate fi util\u0103 pentru a ob\u021bine expresia postfix a unui arbore binar pentru evaluarea unei expresii.</p>","tags":["arbori","grafuri","diametru"]},{"location":"mediu/tree-1/#aplicatii-ale-arborilor","title":"Aplica\u021bii ale arborilor","text":"<p>Arborii sunt utili \u00een cazul multor probleme, ace\u0219tia dovedindu-\u0219i utilitatea c\u00e2nd vine vorba de procesarea unor rela\u021bii dintre noduri \u00eentr-un mod mult mai facil dec\u00e2t cel al grafurilor. Exist\u0103 algoritmi \u00een capitolele viitoare, precum aflarea arborelui par\u021bial de cost minim, care se bazeaz\u0103 \u00eentr-un mod extensiv pe ei.</p>","tags":["arbori","grafuri","diametru"]},{"location":"mediu/tree-1/#problema-exemplu-aflarea-dimensiunilor-subarborilor-unui-nod","title":"Problem\u0103 exemplu - aflarea dimensiunilor subarborilor unui nod","text":"<p>Pentru a rezolva aceast\u0103 problem\u0103, va trebui s\u0103 parcurgem arborele (de preferat, folosind un DFS) de la r\u0103d\u0103cin\u0103, cu scopul de a ajunge pe r\u00e2nd la toate frunzele arborelui. Pentru fiecare frunz\u0103, dimensiunea subarborelui s\u0103u va fi 1, iar pentru fiecare nod care nu e frunz\u0103, va fi suma subarborilor fiilor s\u0103i. \u00cen final, vom avea un algoritm ce ruleaz\u0103 \u00een \\(\\mathcal{O}(n)\\).</p> <pre><code>vector&lt;vector&lt;int&gt; &gt; tree;\nint sz[100001];\nvoid dfs(int nod, int tata) {\n    sz[nod] = 1;\n    for (int i = 0; i &lt; (int)tree[nod].size(); i++) {\n        int fiu = tree[nod][i];\n        if (fiu != tata) {\n            dfs(fiu, nod);\n            sz[nod] += sz[fiu];\n        }\n    }\n}\n</code></pre>","tags":["arbori","grafuri","diametru"]},{"location":"mediu/tree-1/#problema-exemplu-aflarea-diametrului-unui-arbore","title":"Problem\u0103 exemplu - aflarea diametrului unui arbore","text":"<p>Definim diametrul unui graf ca fiind distan\u021ba minim\u0103 cea mai mare \u00eentre dou\u0103 noduri din graf. De\u0219i \u00een mod normal, aceast\u0103 problem\u0103 este NP-hard, \u00een cazul unui arbore exist\u0103 un algoritm simplu care func\u021bioneaz\u0103 \u00een \\(\\mathcal{O}(n)\\). Pentru a putea ob\u021bine aceast\u0103 distan\u021b\u0103, avem nevoie de dou\u0103 parcurgeri, ambele pot fi DFS sau BFS.</p> <p>Prima parcurgere este dintr-un nod oarecare, scopul fiind s\u0103 afl\u0103m cel mai \u00eendep\u0103rtat nod de acesta. Apoi, vom rula a doua parcurgere din acest nod cel mai \u00eendep\u0103rtat pentru a afla distan\u021ba maxim\u0103 de la acesta la celelalte noduri din arbore. \u00centr-un final, vom ob\u021bine r\u0103spunsul c\u0103utat \u00een \\(\\mathcal{O}(n)\\) folosind doar dou\u0103 parcurgeri.</p> <pre><code>#include &lt;iostream&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\nint n, root = 1, a, b;\nvector&lt;vector&lt;int&gt; &gt; graph;\nvector&lt;int&gt; dist;\n\nvoid dfs(int parent, int node) {\n    if (dist[node] &gt; dist[root]) {\n        root = node;\n    }\n    for (int i = 0; i &lt; (int)graph[node].size(); i++) {\n        int nxt = graph[node][i];\n        if (nxt == parent) {\n            continue;\n        }\n        dist[nxt] = dist[node] + 1;\n        dfs(node, nxt);\n    }\n}\nint main() {\n    cin &gt;&gt; n;\n    graph.resize(n + 1);\n    dist.resize(n + 1);\n    for (int i = 1; i &lt; n; i++) {\n        cin &gt;&gt; a &gt;&gt; b;\n        graph[a].push_back(b);\n        graph[b].push_back(a);\n    }\n    dfs(0, root);\n    dist[root] = 0;\n    dfs(0, root);\n    cout &lt;&lt; dist[root] &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["arbori","grafuri","diametru"]},{"location":"mediu/tree-1/#probleme-suplimentare","title":"Probleme suplimentare","text":"<ul> <li>Subordinates</li> <li>nivele2 infoarena</li> <li>Grarb infoarena</li> <li>Sum in the Tree</li> <li>IIOT tourdetree</li> <li>Tree Diameter</li> <li>Mootube USACO   Silver</li> <li>Milk Visits USACO   Silver</li> <li>Sap</li> </ul>","tags":["arbori","grafuri","diametru"]},{"location":"mediu/tree-1/#resurse-suplimentare","title":"Resurse suplimentare","text":"<ul> <li>Introduction to Tree   Algorithms</li> <li>Grafuri \u0219i arbori - no\u021biuni de   baz\u0103</li> </ul>","tags":["arbori","grafuri","diametru"]},{"location":"mediu/two-pointers/","title":"Two pointers","text":"","tags":["vectori","sortare","cautari"]},{"location":"mediu/two-pointers/#fundamente-si-cunostinte-necesare","title":"Fundamente \u0219i cuno\u0219tin\u021be necesare","text":"<p>Tehnica Two pointers este o tehnic\u0103 pe care o putem folosi \u00een foarte multe tipuri de probleme \u00een care avem de c\u0103utat subsecven\u021be cu diverse propriet\u0103\u021bi, condi\u021bia principal\u0103 fiind aceea c\u0103 vrem s\u0103 g\u0103sim o pereche de valori sau de indici ce respect\u0103 anumite reguli, f\u0103r\u0103 s\u0103 dep\u0103\u0219im o anumit\u0103 valoare sau o anumit\u0103 condi\u021bie. Aceast\u0103 tehnic\u0103 apare \u00een foarte multe tipuri de probleme ce se dau la concursurile de informatic\u0103, de foarte multe ori reprezent\u00e2nd o optimizare la posibile solu\u021bii cu c\u0103utare binar\u0103 sau alte structuri de date ce ar ad\u0103uga un factor de complexitate \u00een plus la solu\u021bie.</p> <p>\u00cen articol voi \u00eencepe prin a explica tipurile de probleme unde putem folosi Two pointers, urm\u00e2nd ca apoi s\u0103 prezint c\u00e2teva probleme de diverse dificult\u0103\u021bi, explic\u00e2nd principalele strategii de abordare a acestor tipuri de probleme \u0219i pun\u00e2nd accentul \u0219i pe implement\u0103ri clare, care au drept scop evitarea gre\u0219elilor tipice c\u00e2nd vine vorba de implementarea acestei metode.</p> <p>Pentru a folosi aceast\u0103 metod\u0103, e nevoie s\u0103 st\u0103p\u00e2nim lucrul cu secven\u021be \u0219i ideal \u0219i c\u0103utarea binar\u0103, deoarece pentru multe dintre exemplele ce vor fi men\u021bionate, exist\u0103 solu\u021bii \u0219i folosind acest algoritm. Nu \u00een ultimul r\u00e2nd, pentru anumite probleme e posibil s\u0103 fie nevoie de structuri de date adi\u021bionale, cum ar fi map sau set.</p> <p>\u00cen ceea ce prive\u0219te modul \u00een care \u00eencepem implement\u0103rile, avem dou\u0103 tipuri majore de implement\u0103ri, \u00een func\u021bie de algoritm. Merit\u0103 men\u021bionat faptul c\u0103 ace\u0219ti pointeri sunt de fapt variabile corespunz\u0103toare indicilor din vector la care ne afl\u0103m la momentul respectiv.</p> <p>\u00cen primul r\u00e2nd, vorbim de problemele \u00een care vrem s\u0103 plec\u0103m de la prima pozi\u021bie \u0219i s\u0103 proces\u0103m secven\u021bele care respect\u0103 o anumit\u0103 proprietate monoton\u0103 (cresc\u0103toare sau descresc\u0103toare). \u00cen acest caz, vom avea ambii pointeri cu indexul de \u00eenceput de la 1 \u0219i vom avansa cu pointerul din dreapta at\u00e2ta timp c\u00e2t \u00eenc\u0103 se mai respect\u0103 condi\u021bia cerut\u0103 din enun\u021b.</p> <p>De asemenea, mai exist\u0103 probleme \u00een care plec\u0103m cu pointerul st\u00e2ng de la prima pozi\u021bie \u0219i cu pointerul drept de la ultima pozi\u021bie \u0219i vrem s\u0103 mergem cu ace\u0219ti pointeri \u00een direc\u021bii opuse, deoarece c\u0103ut\u0103m o proprietate ce are o varia\u021bie descresc\u0103toare fa\u021b\u0103 de scopul problemei.</p>","tags":["vectori","sortare","cautari"]},{"location":"mediu/two-pointers/#problema-1-subarray-sums-i","title":"Problema 1 - Subarray Sums I","text":"<p>Dat fiind un vector cu \\(n\\) elemente numere naturale, determina\u021bi num\u0103rul de subsecven\u021be din vector pentru care suma elementelor este egal\u0103 cu \\(x\\).</p> <p>Pentru a rezolva aceast\u0103 problem\u0103, trebuie s\u0103 ne folosim de faptul c\u0103 toate numerele din \u0219irul dat sunt pozitive, ceea ce face rezolvarea mult mai u\u0219oar\u0103. Astfel, vom putea afla pentru fiecare pozi\u021bie de \u00eenceput a \u0219irului, care este pozi\u021bia cea mai din dreapta astfel \u00eenc\u00e2t suma valorilor din acel interval s\u0103 fie mai mic\u0103 sau egal\u0103 cu \\(x\\). Dac\u0103 acea sum\u0103 este egal\u0103 cu \\(x\\), vom incrementa r\u0103spunsul. Vom avea grij\u0103 la fiecare pas s\u0103 increment\u0103m variabila \\(st\\), av\u00e2nd grij\u0103 s\u0103 sc\u0103dem valoarea curent\u0103 din sum\u0103 mai \u00eent\u00e2i.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint n, v[200002], x;\nint st, dr, sum, ans;\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(nullptr);\n\n    cin &gt;&gt; n &gt;&gt; x;\n    for (int i = 1; i &lt;= n; i++) {\n        cin &gt;&gt; v[i];\n    }\n\n    st = dr = 1;\n    sum = ans = 0;\n    while (st &lt;= n) {\n        while (dr &lt;= n &amp;&amp; sum &lt; x) {\n            sum += v[dr];\n            dr++;\n        }\n        if (sum == x) {\n            ans++;\n        }\n        sum -= v[st];\n        st++;\n    }\n    cout &lt;&lt; ans;\n    return 0;\n}\n</code></pre>","tags":["vectori","sortare","cautari"]},{"location":"mediu/two-pointers/#problema-2-sum-of-two-values","title":"Problema 2 - Sum of Two Values","text":"<p>Se d\u0103 un vector cu \\(n\\) valori pozitive \u0219i o valoare \\(x\\). Scrie\u021bi un program care s\u0103 determine dou\u0103 valori aflate pe pozi\u021bii distincte care adunate s\u0103 dea suma \\(x\\).</p> <p>Pentru a rezolva aceast\u0103 problem\u0103, trebuie s\u0103 folosim o variant\u0103 diferit\u0103 a tehnicii celor doi pointeri. Astfel, de data asta vom \u00eencepe cu un pointer la pozi\u021bia 1, iar cu cel\u0103lalt la pozi\u021bia \\(n\\). Pe parcurs, vom avea trei cazuri \u00een func\u021bie de suma \\(a_{p_1} + a_{p_2}\\), iar dac\u0103 g\u0103sim dou\u0103 pozi\u021bii cu suma valorilor egal\u0103 cu \\(x\\), afi\u0219\u0103m pozi\u021biile corespunz\u0103toare, altfel modific\u0103m \\(p_1\\) sau \\(p_2\\) dup\u0103 caz. Dac\u0103 nu g\u0103sim nicio pereche, afi\u0219\u0103m IMPOSSIBLE.</p> <pre><code>#include &lt;algorithm&gt;\n#include &lt;iostream&gt;\n\nusing namespace std;\n\nint n, x, a[200002], b[200002];\n\nint main() {\n    cin &gt;&gt; n &gt;&gt; x;\n    for (int i = 1; i &lt;= n; ++i) {\n        cin &gt;&gt; a[i];\n        b[i] = a[i];\n    }\n\n    sort(a + 1, a + n + 1);\n    int p1 = 1, p2 = n;\n\n    while (p1 &lt; p2) {\n        if (a[p1] + a[p2] == x) {\n            int valA = a[p1];\n            int valB = a[p2];\n\n            for (int i = 1; i &lt;= n; ++i) {\n                if (b[i] == valA) {\n                    cout &lt;&lt; i &lt;&lt; \" \";\n                    valA = 0;\n                } else if (b[i] == valB) {\n                    cout &lt;&lt; i &lt;&lt; \" \";\n                    valB = 0;\n                }\n            }\n            return 0;\n        } else {\n            if (a[p1] + a[p2] &gt; x) {\n                --p2;\n            } else {\n                ++p1;\n            }\n        }\n    }\n\n    cout &lt;&lt; \"IMPOSSIBLE\";\n    return 0;\n}\n</code></pre>","tags":["vectori","sortare","cautari"]},{"location":"mediu/two-pointers/#problema-3-nane","title":"Problema 3 - Nane","text":"<p>Nane de pe Jiu, mare algoritmician fiind, v\u0103 provoac\u0103 s\u0103 rezolva\u021bi o problem\u0103 prea u\u0219oar\u0103 pentru el. Nane v\u0103 d\u0103 \\(N\\) numere naturale \u0219i un num\u0103r \\(K\\). Numim subsecven\u021b\u0103 special\u0103 o subsecven\u021b\u0103 pentru care efectu\u00e2nd opera\u021bia OR pe bi\u021bi pentru elementele din subsecven\u021b\u0103 (s\u0103 numim aceast\u0103 opera\u021bie sum\u0103 OR) ob\u021binem un rezultat care are, \u00een reprezentare binar\u0103, cel mult \\(K\\) bi\u021bi de 1. Dou\u0103 subsecven\u021be sunt diferite dac\u0103 cel pu\u021bin o pozi\u021bie din una nu se reg\u0103se\u0219te \u00een cealalt\u0103. Scrie\u021bi un program care s\u0103 determine num\u0103rul de subsecven\u021be speciale.</p> <p>Pentru a rezolva aceast\u0103 problem\u0103, vom folosi metoda celor doi pointeri pentru a afla num\u0103rul de secven\u021be care au suma OR cu cel mult \\(k\\) de 1, actualiz\u0103rile fiind foarte similare cu cele de la celelalte probleme de acest tip. De asemenea, deoarece vorbim de suma OR, trebuie s\u0103 folosim c\u00e2te un vector de frecven\u021b\u0103 pentru fiecare bit pentru a evita calculele adi\u021bionale.</p> <pre><code>#include &lt;fstream&gt;\n#define ll long long\nusing namespace std;\n\nint n, k, v[100002], fr[32];\n\nll ans;\n\nbool ok() {\n    int cnt = 0;\n    for (int i = 0; i &lt;= 30; ++i) {\n        if (fr[i]) {\n            ++cnt;\n        }\n    }\n    if (cnt &lt;= k) {\n        return 1;\n    }\n    return 0;\n}\n\nvoid add(int poz, int val) {\n    for (int i = 0; i &lt;= 30; ++i) {\n        if ((v[poz] &amp; (1 &lt;&lt; i))) {\n            fr[i] += val;\n        }\n    }\n}\nint main() {\n    ifstream cin(\"nane.in\");\n    ofstream cout(\"nane.out\");\n\n    cin &gt;&gt; n &gt;&gt; k;\n    for (int i = 1; i &lt;= n; ++i) {\n        cin &gt;&gt; v[i];\n    }\n    int st = 1;\n    int dr = 1;\n    while (st &lt;= n) {\n        while (dr &gt; n || !ok()) {\n            if (ok()) {\n                ans += dr - st;\n                add(st, -1);\n                ++st;\n            } else {\n                add(st, -1);\n                ++st;\n                ans += dr - st;\n            }\n        }\n        while (dr &lt;= n &amp;&amp; ok()) {\n            add(dr, 1);\n            ++dr;\n        }\n    }\n    cout &lt;&lt; ans &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["vectori","sortare","cautari"]},{"location":"mediu/two-pointers/#problema-4-jjooii","title":"Problema 4 - JJOOII","text":"<p>Se consider\u0103 un \u0219ir format din \\(N\\) caractere din mul\u021bimea {J, O, I}. Se nume\u0219te JOI-\u0219ir de nivel \\(K\\) un \u0219ir format din \\(K\\) litere J, \\(K\\) litere O \u0219i \\(K\\) litere I (\u00een aceast\u0103 ordine). De exemplu, JJOOII este un JOI-\u0219ir de nivel 2. Bitaro dore\u0219te s\u0103 transforme \u0219irul \\(S\\) \u00eentr-un JOI-\u0219ir de nivel \\(K\\), utiliz\u00e2nd urm\u0103toarele 3 opera\u021bii, de oric\u00e2te ori \u0219i \u00een orice ordine:</p> <ul> <li>Opera\u021bia 1: Bitaro \u0219terge primul caracter din \\(S\\);</li> <li>Opera\u021bia 2: Bitaro \u0219terge ultimul caracter din \\(S\\);</li> <li>Opera\u021bia 3: Bitaro \u0219terge un caracter din interiorul lui \\(S\\) (care nu este   nici primul nici ultimul).</li> </ul> <p>Deoarece opera\u021biile de tip 3 necesit\u0103 mult timp, Bitaro dore\u0219te s\u0103 transforme \u0219irul \\(S\\) \u00eentr-un JOI-\u0219ir de nivel \\(K\\) folosind un num\u0103r minim de opera\u021bii de tip 3. Scrie\u021bi un program care, cunosc\u00e2nd \\(N\\), \\(S\\) \u0219i \\(K\\), determin\u0103 num\u0103rul minim de opera\u021bii de tip 3 necesare pentru a transforma \u0219irul \\(S\\) \u00eentr-un JOI-\u0219ir de nivel \\(K\\). Dac\u0103 acest lucru nu este posibil, programul va afi\u0219a valoarea \\(-1\\).</p> <p>Pentru a rezolva aceast\u0103 problem\u0103, va trebui mai \u00eent\u00e2i s\u0103 afl\u0103m unde sunt situate literele J, O \u0219i I \u00een \u0219irul nostru de caractere. Ulterior, pe m\u0103sur\u0103 ce fix\u0103m secven\u021bele de \\(k\\) de J, avem pointeri care duc la secven\u021bele corespunz\u0103toare de O \u0219i I din celelalte dou\u0103 \u0219iruri, calculele ulterioare devenind destul de u\u0219oare.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint vj[200001], vo[200001], vi[200001];\n\nint lj, lo, li;\n\nint main() {\n    int n, k;\n    cin &gt;&gt; n &gt;&gt; k;\n\n    string s;\n    cin &gt;&gt; s;\n\n    for (int i = 0; i &lt; n; i++) {\n        if (s[i] == 'J') {\n            vj[++lj] = i;\n        }\n        if (s[i] == 'O') {\n            vo[++lo] = i;\n        }\n        if (s[i] == 'I') {\n            vi[++li] = i;\n        }\n    }\n\n    int pj = 1;\n    int po = 1;\n    int pi = 1;\n\n    int ans = n + 1;\n\n    for (int pj = 0; pj + k - 1 &lt; lj; ++pj) {\n        int po = 0;\n        while (po + k - 1 &lt; lo &amp;&amp; vo[po] &lt;= vj[pj + k - 1]) {\n            po++;\n        }\n\n        if (po + k - 1 &lt; lo) {\n            int pi = 0;\n            while (pi + k - 1 &lt; li &amp;&amp; vi[pi] &lt;= vo[po + k - 1]) {\n                pi++;\n            }\n\n            if (pi + k - 1 &lt; li) {\n                int start = vj[pj];\n                int end = vi[pi + k - 1];\n                int segment_length = (end - start + 1) - 3 * k;\n\n                ans = min(ans, segment_length);\n            }\n        }\n    }\n\n    cout &lt;&lt; (ans == n + 1 ? -1 : ans);\n    return 0;\n}\n</code></pre>","tags":["vectori","sortare","cautari"]},{"location":"mediu/two-pointers/#probleme-suplimentare","title":"Probleme suplimentare","text":"","tags":["vectori","sortare","cautari"]},{"location":"mediu/two-pointers/#probleme-de-la-olimpiade","title":"Probleme de la olimpiade","text":"<ul> <li>Infoarena 3secv</li> <li>JOI JJOOII 2</li> <li>CSES Apartments</li> <li>pbinfo maru</li> <li>NOI Singapore Global Warming</li> <li>Baraj Seniori 2023 sirbun</li> <li>Infoarena nane</li> <li>Infoarena teren</li> <li>USACO Paired Up </li> <li>USACO Social   Distancing</li> <li>USACO MooTube</li> <li>USACO Wormhole   Sort</li> <li>USACO Sprinklers</li> <li>USACO Cow Dating</li> <li>Probleme cu two pointers de pe kilonova</li> <li>Probleme cu two pointers de pe   pbinfo</li> </ul>","tags":["vectori","sortare","cautari"]},{"location":"mediu/two-pointers/#probleme-de-pe-codeforces","title":"Probleme de pe Codeforces","text":"<ul> <li>Towers -   Codeforces</li> <li>Two Pointers -   Codeforces</li> <li>Quiz Master - Codeforces</li> <li>Into Blocks (easy) - Codeforces</li> <li>Slime Escape - Codeforces</li> <li>Range Deletion - Codeforces</li> <li>Two Pointers Step 1 - Codeforces   EDU</li> <li>Two Pointers Step 2 - Codeforces   EDU</li> <li>Two Pointers Step 3 - Codeforces   EDU</li> </ul>","tags":["vectori","sortare","cautari"]},{"location":"mediu/two-pointers/#bibliografie-si-lectura-suplimentara","title":"Bibliografie \u0219i lectur\u0103 suplimentar\u0103","text":"<ul> <li>Two Pointers - USACO Guide</li> <li>Link ce trebuie accesat pentru inscrierea la cursul despre DSU facut de ITMO   Academy</li> <li>Curs despre Two Pointers - Codeforces (este necesar un cont pentru a putea   accesa acest curs, plus accesarea linkului de mai   sus)</li> <li>Using the Two Pointers   Technique</li> <li>Edu - Two pointers</li> <li>Competitive Programmer's Handbook - Capitolul   8</li> </ul>","tags":["vectori","sortare","cautari"]},{"location":"olimpiada/baraj-lot-juniori/","title":"Baraj \u0219i lot juniori","text":"","tags":["meta","sfaturi","olimpiada"]},{"location":"olimpiada/baraj-lot-juniori/#introducere","title":"Introducere","text":"<p>Aici g\u0103si\u021bi programa pentru barajul \u0219i lotul de juniori pentru Olimpiada de Informatic\u0103, conform programei create de SEPI \u00een anul \u0219colar 2023-2024, \u00eempreun\u0103 cu locurile de unde pute\u021bi \u00eenv\u0103\u021ba aceste con\u021binuturi \u00een arhiva noastr\u0103.</p> <p>Pe l\u00e2ng\u0103 con\u021binuturile de mai jos, programa include \u0219i materia clasei a opta (care include celelalte programe pentru clasele de gimnaziu), care poate fi accesat\u0103 \u00een articolul corespunz\u0103tor.</p>","tags":["meta","sfaturi","olimpiada"]},{"location":"olimpiada/baraj-lot-juniori/#baraj-juniori","title":"Baraj juniori","text":"<ul> <li>Opera\u021bii pe bi\u021bi - link articol</li> <li>Indicatorul lui Euler - link articol</li> <li>Tablouri de diferen\u021be (Difference Arrays) 2D - link articol</li> <li>Recursivitate - link articol</li> <li>Algoritmul de fill - link articol</li> <li>Algoritmul lui Lee - link articol</li> <li>Tehnica Square root decomposition - link articol</li> <li>Metoda program\u0103rii dinamice<ul> <li>Introducere \u00een programarea dinamic\u0103 - link articol</li> <li>Problema rucsacului - link articol</li> <li>Sub\u0219ir comun maximal - link articol</li> <li>Sub\u0219ir cresc\u0103tor maximal - link articol</li> </ul> </li> <li>Principiul includerii \u0219i excluderii. Func\u021bia Mobius -     link articol - nu apare \u00een program\u0103, dar se recomand\u0103     cunoa\u0219terea no\u021biunilor explicate aici</li> </ul>","tags":["meta","sfaturi","olimpiada"]},{"location":"olimpiada/baraj-lot-juniori/#lot-juniori","title":"Lot Juniori","text":"<p>Observa\u021bie</p> <p>Materia include no\u021biunile din programa de baraj \u0219i no\u021biunile din programa claselor V-VIII.</p> <p>Programa lotului de juniori include toate no\u021biunile din programa EJOI \u0219i programa claselor V-VIII \u0219i a barajului, \u00eempreun\u0103 cu o list\u0103 de no\u021biuni suplimentare.</p> <p>Mai jos vom enun\u021ba lucrurile care nu au fost incluse \u00een articolele anterioare, care reprezint\u0103 un nivel minim al cuno\u0219tin\u021belor ce trebuie acumulate, elevii de top de multe ori \u00eenv\u0103\u021b\u00e2nd \u0219i no\u021biuni suplimentare.</p> <p>\u00cen general, trebuie s\u0103 fi\u021bi familiari cu tot ce se afl\u0103 \u00een sec\u021biunile U\u0219or \u0219i Mediu ale arhivei noastre, dar voi puncta o list\u0103 de con\u021binuturi foarte importante \u0219i frecvent \u00eent\u00e2lnite \u00een probleme. De asemenea, trebuie s\u0103 fi\u021bi familiariza\u021bi cu sintaxa C++ \u0219i \u00een special cu STL.</p> <ul> <li>Matematic\u0103:<ul> <li>Introducere \u00een combinatoric\u0103 -     link articol - se d\u0103 foarte des la     concursurile de juniori, \u00eencep\u00e2nd de la lot</li> <li>Invers modular - link articol</li> </ul> </li> <li>Teoria grafurilor \u0219i arbori:<ul> <li>Introducere \u00een grafuri - link articol</li> <li>Introducere \u00een arbori. Diametrul unui arbore - link articol</li> <li>Sortare topologic\u0103 - link articol</li> <li>P\u0103duri de mul\u021bimi disjuncte (DSU) - link articol</li> <li>Arbore par\u021bial de cost minim - link articol</li> <li>Algoritmi pentru drumuri minime - link articol</li> <li>Tehnica celor dou\u0103 DFS-uri (rerooting) - link articol</li> <li>Binary lifting. Lowest common ancestor (LCA) - link articol</li> </ul> </li> <li>Programarea dinamic\u0103:<ul> <li>Programare dinamic\u0103 pe st\u0103ri exponen\u021biale (bitmask DP) - link articol</li> <li>Programare dinamic\u0103 pe grafuri - link articol</li> <li>Programare dinamic\u0103 pe arbore - link articol</li> <li>Programare dinamic\u0103 pe intervale (range DP) - link articol</li> <li>Programare dinamic\u0103 pe cifre (digit DP) - link articol</li> <li>Programare dinamic\u0103 cu structuri de date - link articol</li> <li>Programare dinamic\u0103 pe permut\u0103ri - link articol</li> </ul> </li> <li>Structuri de date:<ul> <li>Arbori de intervale (+ lazy propagation) - link articol</li> <li>Arbori indexa\u021bi binar - link articol</li> <li>Range Minimum Query (sparse tables) - link articol</li> <li>Trie - link articol</li> </ul> </li> <li>\u0218iruri de caractere \u0219i similare:<ul> <li>Hashing - link articol</li> <li>Meet in the middle - link articol</li> <li>KMP - link articol</li> <li>Evaluarea unei expresii - link articol</li> </ul> </li> <li>Tipuri speciale de probleme:<ul> <li>Probleme interactive - link articol</li> <li>Probleme output only - link articol</li> </ul> </li> </ul>","tags":["meta","sfaturi","olimpiada"]},{"location":"olimpiada/baraj-lot-seniori/","title":"Baraj \u0219i lot seniori","text":"","tags":["meta","sfaturi","olimpiada"]},{"location":"olimpiada/baraj-lot-seniori/#introducere","title":"Introducere","text":"<p>Aici g\u0103si\u021bi programa pentru barajul \u0219i lotul de seniori pentru Olimpiada de Informatic\u0103, conform programei create de SEPI \u00een anul \u0219colar 2023-2024, \u00eempreun\u0103 cu locurile de unde pute\u021bi \u00eenv\u0103\u021ba aceste con\u021binuturi \u00een arhiva noastr\u0103.</p> <p>Dat fiind nivelul avansat al acestor concursuri, cunoa\u0219terea c\u00e2t mai temeinic\u0103 a con\u021binuturilor din arhiva educa\u021bional\u0103, \u00eempreun\u0103 cu \u00eensu\u0219irea cuno\u0219tin\u021belor din problemele anterioare este obligatorie.</p> <p>Deoarece a\u0219a cum s-ar spune, trebuie \u00eenv\u0103\u021bat (aproape) tot, vom insista \u0219i pe alte sfaturi practice ce trebuie avute \u00een vedere.</p>","tags":["meta","sfaturi","olimpiada"]},{"location":"olimpiada/baraj-lot-seniori/#cum-sa-inveti-si-de-unde-sa-lucrezi","title":"Cum s\u0103 \u00eenve\u021bi \u0219i de unde s\u0103 lucrezi?","text":"<p>Pentru a \u00eenv\u0103\u021ba aceste con\u021binuturi, pe l\u00e2ng\u0103 sfaturile date de-a lungul acestei arhive, trebuie s\u0103 ave\u021bi \u00een vedere programa IOI, aceasta fiind un punct de baz\u0103 pentru studiul vostru, precum \u0219i programa claselor V-XII.</p> <p>Pentru a v\u0103 preg\u0103ti de acest concurs, recomand\u0103m lucratul problemelor de la competi\u021biile de seniori rom\u00e2ne\u0219ti, mai jos g\u0103si\u021bi linkurile pentru barajul \u0219i lotul de seniori.</p> <ul> <li>baraj seniori</li> <li>lot seniori</li> <li>list\u0103 concursuri</li> </ul>","tags":["meta","sfaturi","olimpiada"]},{"location":"olimpiada/baraj-lot-seniori/#alte-sfaturi-si-recomandari","title":"Alte sfaturi \u0219i recomand\u0103ri","text":"<p>Pe l\u00e2ng\u0103 concursurile rom\u00e2ne\u0219ti, recomand\u0103m lucratul problemelor de la diverse olimpiade interna\u021bionale \u0219i ale altor \u021b\u0103ri, concursuri precum IOI, CEOI, COCI, BOI, JOI, USACO Platinum sunt foarte apreciate de olimpicii de top din toat\u0103 lumea, foarte multe din aceste probleme pot fi g\u0103site pe oj.uz sau descrise pe USACO Guide.</p> <p>De asemenea, concursurile pe platforme precum Codeforces, AtCoder \u0219i DMOJ nu trebuie neglijate, deoarece chiar dac\u0103 stilul lor nu este acela\u0219i cu cel de la olimpiad\u0103, acestea pot fi utile pentru \u00eembun\u0103t\u0103\u021birea abilit\u0103\u021bilor \u00een condi\u021bii de concurs.</p> <p>Chiar dac\u0103 de regul\u0103 cei care ajung \u00een lotul de seniori se preg\u0103tesc timp de mul\u021bi ani, lucrul consistent poate ajuta pe oricine vrea s\u0103 ating\u0103 acest obiectiv ambi\u021bios, at\u00e2ta timp c\u00e2t efortul este pe m\u0103sur\u0103 \u0219i con\u021binuturile sunt urmate \u00een ordinea descris\u0103 de mai sus.</p>","tags":["meta","sfaturi","olimpiada"]},{"location":"olimpiada/clasa-IX/","title":"Clasa a IX-a","text":"","tags":["meta","sfaturi","olimpiada"]},{"location":"olimpiada/clasa-IX/#introducere","title":"Introducere","text":"<p>Aici g\u0103si\u021bi programa clasei a noua pentru Olimpiada de Informatic\u0103, conform programei create de SEPI \u00een anul \u0219colar 2023-2024, \u00eempreun\u0103 cu locurile de unde pute\u021bi \u00eenv\u0103\u021ba aceste con\u021binuturi \u00een arhiva noastr\u0103.</p> <p>Observa\u021bie</p> <p>Urm\u0103toarele capitole sunt at\u00e2t pentru etapa jude\u021bean\u0103, c\u00e2t \u0219i pentru etapa na\u021bional\u0103.</p>","tags":["meta","sfaturi","olimpiada"]},{"location":"olimpiada/clasa-IX/#algoritmi-elementari","title":"Algoritmi elementari","text":"<ul> <li>Tipuri simple de date (\u00eentreg, real, caracter, logic) - link articol</li> <li>Structura liniar\u0103, alternativ\u0103 \u0219i repetitiv\u0103:<ul> <li>Structura liniar\u0103: link articol</li> <li>Structura alternativ\u0103: link articol</li> <li>Structura repetitiv\u0103: link articol</li> </ul> </li> <li>Prelucrarea cifrelor numerelor naturale scrise \u00een baza 10 -     link articol</li> <li>Divizibilitate (divizorii numerelor naturale, numere prime, determinarea     cmmdc prin algoritmul lui Euclid, cmmmc, numere prime \u00eentre ele,     simplificarea frac\u021biilor, descompunerea numerelor \u00een factori primi) -     link articol</li> <li>Calculul unor expresii (de exemplu, factorial, ridicare la putere) -     link articol</li> <li>Algoritmul de exponen\u021biere rapid\u0103 -     link articol</li> </ul>","tags":["meta","sfaturi","olimpiada"]},{"location":"olimpiada/clasa-IX/#generari-de-siruri-link-articol","title":"Gener\u0103ri de \u0219iruri - link articol","text":"<ul> <li>Generarea \u0219irurilor pe baza unor reguli</li> <li>\u0218irul lui Fibonacci \u0219i alte \u0219iruri recurente</li> </ul>","tags":["meta","sfaturi","olimpiada"]},{"location":"olimpiada/clasa-IX/#sisteme-de-numeratie-si-reguli-de-conversie-link-articol","title":"Sisteme de numera\u021bie \u0219i reguli de conversie - link articol","text":"","tags":["meta","sfaturi","olimpiada"]},{"location":"olimpiada/clasa-IX/#reprezentarea-numerelor-naturale-si-intregi-in-memoria-calculatorului-operatii-pe-biti-link-articol","title":"Reprezentarea numerelor naturale \u0219i \u00eentregi \u00een memoria calculatorului. Opera\u021bii pe bi\u021bi - link articol","text":"","tags":["meta","sfaturi","olimpiada"]},{"location":"olimpiada/clasa-IX/#fisiere-text-link-articol","title":"Fi\u0219iere text - link articol","text":"","tags":["meta","sfaturi","olimpiada"]},{"location":"olimpiada/clasa-IX/#tablouri-unidimensionale-vectori","title":"Tablouri unidimensionale (vectori)","text":"<ul> <li>Prelucr\u0103ri elementare (de exemplu, parcurgere, inversare, verificarea unor     propriet\u0103\u021bi) - link articol</li> <li>Algoritmi de sortare \u00een complexitate p\u0103tratic\u0103 (sortarea prin selec\u021bie,     sortarea prin inser\u021bie, metoda bulelor) - link     articol</li> <li>Sortare prin num\u0103rare (folosind vectori de frecven\u021b\u0103) - link     articol</li> <li>Interclasarea tablourilor unidimensionale - link     articol</li> <li>Vectori caracteristici/ de frecven\u021b\u0103 - link     articol</li> <li>Opera\u021bii cu mul\u021bimi</li> <li>Ciurul lui Eratostene - f\u0103r\u0103 precalcul\u0103ri avansate/aplicarea direct\u0103 - link     articol</li> <li>C\u0103utare binar\u0103 - link articol</li> <li>Determinarea elementului majoritar</li> <li>Sume par\u021biale \u00een tablouri unidimensionale - link     articol</li> <li>Probleme cu secven\u021be de valori (de exemplu, determinarea unei secven\u021be     maximale cu o anumit\u0103 proprietate, num\u0103rarea secven\u021belor, determinarea     secven\u021bei de sum\u0103 maxim\u0103, prelucrarea secven\u021belor de lungime fixat\u0103, tehnica     Two Pointers, tablouri de diferen\u021be - Difference Arrays)<ul> <li>Probleme cu secven\u021be: - link articol</li> <li>Determinarea secven\u021bei de sum\u0103 maxim\u0103 - link     articol</li> <li>Prelucrarea secven\u021belor de lungime fixat\u0103 -     link articol</li> <li>Tehnica Two Pointers - link articol</li> <li>Tablouri de diferen\u021be - Difference Arrays - link     articol</li> </ul> </li> </ul>","tags":["meta","sfaturi","olimpiada"]},{"location":"olimpiada/clasa-IX/#tablouri-bidimensionale-matrice-link-articol","title":"Tablouri bidimensionale (matrice) - link articol","text":"<ul> <li>Prelucr\u0103ri elementare ale tablourilor bidimensionale (de exemplu, parcurgeri,     gener\u0103ri, simul\u0103ri)</li> <li>Prelucr\u0103ri specifice tablourilor bidimensionale p\u0103tratice (de exemplu,     diagonale \u0219i zone determinate de diagonale)</li> <li>Sume par\u021biale pe matrice - link     articol</li> </ul>","tags":["meta","sfaturi","olimpiada"]},{"location":"olimpiada/clasa-IX/#structuri-de-date-neomogene-tipul-struct","title":"Structuri de date neomogene (tipul struct)","text":"","tags":["meta","sfaturi","olimpiada"]},{"location":"olimpiada/clasa-IX/#metoda-greedy-link-articol","title":"Metoda Greedy - link articol","text":"<p>Observa\u021bie</p> <p>Urm\u0103toarele capitole sunt doar pentru etapa na\u021bional\u0103.</p>","tags":["meta","sfaturi","olimpiada"]},{"location":"olimpiada/clasa-IX/#tabele-de-diferente-difference-arrays-2d-link-articol","title":"Tabele de diferen\u021be (Difference Arrays) 2D - link articol","text":"","tags":["meta","sfaturi","olimpiada"]},{"location":"olimpiada/clasa-IX/#indicatorul-lui-euler-link-articol","title":"Indicatorul lui Euler - link articol","text":"","tags":["meta","sfaturi","olimpiada"]},{"location":"olimpiada/clasa-IX/#functii-link-articol","title":"Func\u021bii - link articol","text":"<ul> <li>Declarare, definire, apel</li> <li>Variabile locale, variabile globale</li> <li>Transmiterea parametrilor prin valoare \u0219i prin referin\u021b\u0103</li> </ul>","tags":["meta","sfaturi","olimpiada"]},{"location":"olimpiada/clasa-IX/#utilizarea-functiilor-din-biblioteca-stl-pentru-sortare-si-cautare","title":"Utilizarea func\u021biilor din biblioteca STL pentru sortare \u0219i c\u0103utare","text":"<ul> <li>Introducere STL - link articol</li> <li>Func\u021bia pentru sortare - link articol</li> <li>Func\u021bii pentru c\u0103utarea binar\u0103 - link     articol</li> </ul>","tags":["meta","sfaturi","olimpiada"]},{"location":"olimpiada/clasa-IX/#generarea-elementelor-combinatoriale-prin-algoritmi-de-tip-succesor-link-articol","title":"Generarea elementelor combinatoriale prin algoritmi de tip succesor - link articol","text":"<ul> <li>Submul\u021bimi</li> <li>Produs cartezian</li> <li>Permut\u0103ri</li> <li>Combin\u0103ri</li> <li>Aranjamente</li> </ul>","tags":["meta","sfaturi","olimpiada"]},{"location":"olimpiada/clasa-V/","title":"Clasa a V-a","text":"","tags":["meta","sfaturi","olimpiada","gimnaziu"]},{"location":"olimpiada/clasa-V/#introducere","title":"Introducere","text":"<p>Aici g\u0103si\u021bi programa clasei a cincea pentru Olimpiada de Informatic\u0103, conform programei create de SEPI \u00een anul \u0219colar 2023-2024, \u00eempreun\u0103 cu locurile de unde pute\u021bi \u00eenv\u0103\u021ba aceste con\u021binuturi \u00een arhiva noastr\u0103.</p> <p>Observa\u021bie</p> <p>Urm\u0103toarele capitole sunt at\u00e2t pentru etapa jude\u021bean\u0103, c\u00e2t \u0219i pentru etapa na\u021bional\u0103.</p>","tags":["meta","sfaturi","olimpiada","gimnaziu"]},{"location":"olimpiada/clasa-V/#algoritmi-elementari","title":"Algoritmi elementari","text":"<ul> <li>Tipuri simple de date. Tipul \u00eentreg (pe 4 octe\u021bi), tipul logic - link     articol</li> <li>Structura liniar\u0103, alternativ\u0103 \u0219i repetitiv\u0103:<ul> <li>Structura liniar\u0103: link articol</li> <li>Structura alternativ\u0103: link articol</li> <li>Structura repetitiv\u0103: link articol</li> </ul> </li> <li>Prelucrarea cifrelor numerelor naturale scrise \u00een baza 10 - link     articol</li> <li>Divizibilitate (divizorii numerelor naturale, numere prime, determinarea cmmdc     prin algoritmul lui Euclid, cmmmc, numere prime \u00eentre ele, simplificarea     frac\u021biilor) - link articol</li> <li>Calculul unor expresii (de exemplu, factorial, ridicare la putere) - link     articol</li> </ul>","tags":["meta","sfaturi","olimpiada","gimnaziu"]},{"location":"olimpiada/clasa-V/#generari-de-siruri-link-articol","title":"Gener\u0103ri de \u0219iruri - link articol","text":"<ul> <li>Generarea \u0219irurilor pe baza unor reguli</li> <li>\u0218irul lui Fibonacci \u0219i alte \u0219iruri recurente</li> </ul>","tags":["meta","sfaturi","olimpiada","gimnaziu"]},{"location":"olimpiada/clasa-V/#fisiere-text-link-articol","title":"Fi\u0219iere text - link articol","text":"","tags":["meta","sfaturi","olimpiada","gimnaziu"]},{"location":"olimpiada/clasa-V/#prelucrari-de-siruri-de-numere-citite-succesiv-fara-memorarea-lor","title":"Prelucr\u0103ri de \u0219iruri de numere citite succesiv, f\u0103r\u0103 memorarea lor","text":"<ul> <li>Prelucr\u0103ri ce necesit\u0103 stocarea ultimului element (de exemplu, determinare     maxim/minim, primele dou\u0103 maxime sau minime) - link     articol</li> <li>Prelucr\u0103ri ce necesit\u0103 stocarea ultimelor p (p=2, 3, ..) elemente (de exemplu,     cea mai lung\u0103 subsecven\u021b\u0103 cu anumite propriet\u0103\u021bi, num\u0103rarea secven\u021belor cu     anumite propriet\u0103\u021bi) - link articol</li> </ul> <p>Observa\u021bie</p> <p>Urm\u0103toarele capitole sunt doar pentru etapa na\u021bional\u0103.</p>","tags":["meta","sfaturi","olimpiada","gimnaziu"]},{"location":"olimpiada/clasa-V/#tablouri-unidimensionale","title":"Tablouri unidimensionale","text":"<ul> <li>Prelucr\u0103ri elementare (de exemplu, parcurgere, inversare, verificare     propriet\u0103\u021bi) - link articol</li> <li>C\u0103utarea liniar\u0103 a unor valori - link     articol</li> <li>Vectori caracteristici/ de frecven\u021b\u0103 - link     articol</li> <li>Algoritmi de sortare \u00een complexitate p\u0103tratic\u0103 (sortarea prin selec\u021bie,     sortarea prin inser\u021bie, metoda bulelor) - link     articol</li> <li>Sortare prin num\u0103rare (folosind vectori de frecven\u021b\u0103) - link     articol</li> </ul>","tags":["meta","sfaturi","olimpiada","gimnaziu"]},{"location":"olimpiada/clasa-VI/","title":"Clasa a VI-a","text":"","tags":["meta","sfaturi","olimpiada"]},{"location":"olimpiada/clasa-VI/#introducere","title":"Introducere","text":"<p>Aici g\u0103si\u021bi programa clasei a \u0219asea pentru Olimpiada de Informatic\u0103, conform programei create de SEPI \u00een anul \u0219colar 2023-2024, \u00eempreun\u0103 cu locurile de unde pute\u021bi \u00eenv\u0103\u021ba aceste con\u021binuturi \u00een arhiva noastr\u0103.</p> <p>Pe l\u00e2ng\u0103 con\u021binuturile de mai jos, programa include \u0219i materia clasei a cincea, care poate fi accesat\u0103 \u00een articolul corespunz\u0103tor.</p> <p>Observa\u021bie</p> <p>Urm\u0103toarele capitole sunt at\u00e2t pentru etapa jude\u021bean\u0103, c\u00e2t \u0219i pentru etapa na\u021bional\u0103.</p>","tags":["meta","sfaturi","olimpiada"]},{"location":"olimpiada/clasa-VI/#tipuri-simple-de-date-intregi-reale-char-link-articol","title":"Tipuri simple de date (\u00eentregi, reale, char) - link articol","text":"","tags":["meta","sfaturi","olimpiada"]},{"location":"olimpiada/clasa-VI/#sisteme-de-numeratie-si-reguli-de-conversie-link-articol","title":"Sisteme de numera\u021bie \u0219i reguli de conversie - link articol","text":"","tags":["meta","sfaturi","olimpiada"]},{"location":"olimpiada/clasa-VI/#aritmetica-modulara-adunari-scaderi-inmultiri-link-articol","title":"Aritmetica modular\u0103 (adun\u0103ri, sc\u0103deri, \u00eenmul\u021biri) - link articol","text":"","tags":["meta","sfaturi","olimpiada"]},{"location":"olimpiada/clasa-VI/#divizibilitate-link-articol","title":"Divizibilitate - link articol","text":"<ul> <li>Ciurul lui Eratostene - link articol</li> <li>Descompunerea numerelor naturale \u00een factori primi - link   articol</li> </ul>","tags":["meta","sfaturi","olimpiada"]},{"location":"olimpiada/clasa-VI/#tablouri-unidimensionale-vectori","title":"Tablouri unidimensionale (vectori)","text":"<ul> <li>Opera\u021bii cu mul\u021bimi</li> <li>C\u0103utare binar\u0103 - link articol</li> <li>Precalcularea unor informa\u021bii pentru prefixe/sufixe \u00een tablouri   unidimensionale (de exemplu sume par\u021biale, maxime par\u021biale) - link   articol</li> <li>Probleme cu secven\u021be de valori (de exemplu, determinarea unei secven\u021be   maximale cu o anumit\u0103 proprietate, num\u0103rarea secven\u021belor, prelucrarea   secven\u021belor de lungime fixat\u0103 ce nu implic\u0103 stive, cozi sau alte structuri de   date avansate) - link articol</li> <li>C\u0103utarea apari\u021biilor unei subsecven\u021be \u00eentr-o secven\u021b\u0103 de valori \u00een timp   p\u0103tratic</li> <li>Interclasarea tablourilor unidimensionale - link   articol</li> </ul> <p>Observa\u021bie</p> <p>Urm\u0103toarele capitole sunt doar pentru etapa na\u021bional\u0103.</p>","tags":["meta","sfaturi","olimpiada"]},{"location":"olimpiada/clasa-VI/#tablouri-bidimensionale-link-articol","title":"Tablouri bidimensionale - link articol","text":"<ul> <li>Prelucr\u0103ri elementare ale tablourilor bidimensionale (de exemplu, parcurgeri   pe linii/coloane/diagonale/\u00een spiral\u0103, gener\u0103ri, transpunere, bordare)</li> <li>Prelucr\u0103ri specifice tablourilor bidimensionale p\u0103tratice (de exemplu,   diagonale \u0219i zone determinate de diagonale)</li> <li>C\u0103ut\u0103ri secven\u021biale \u00een tablouri bidimensionale (de exemplu, a unui element, a   unei secven\u021be de valori, a unei submatrice)</li> <li>Utilizarea vectorilor de direc\u021bie - link   articol</li> </ul>","tags":["meta","sfaturi","olimpiada"]},{"location":"olimpiada/clasa-VI/#simulari-link-articol","title":"Simul\u0103ri - link articol","text":"<ul> <li>reprezentarea sistemului de simulat, starea sistemului</li> <li>bucla de evenimente ce modific\u0103 starea sistemului</li> </ul>","tags":["meta","sfaturi","olimpiada"]},{"location":"olimpiada/clasa-VII/","title":"Clasa a VII-a","text":"","tags":["meta","sfaturi","olimpiada"]},{"location":"olimpiada/clasa-VII/#introducere","title":"Introducere","text":"<p>Aici g\u0103si\u021bi programa clasei a \u0219aptea pentru Olimpiada de Informatic\u0103, conform programei create de SEPI \u00een anul \u0219colar 2023-2024, \u00eempreun\u0103 cu locurile de unde pute\u021bi \u00eenv\u0103\u021ba aceste con\u021binuturi \u00een arhiva noastr\u0103.</p> <p>Pe l\u00e2ng\u0103 con\u021binuturile de mai jos, programa include \u0219i materia clasei a \u0219asea, care poate fi accesat\u0103 \u00een articolul corespunz\u0103tor.</p> <p>Observa\u021bie</p> <p>Urm\u0103toarele capitole sunt at\u00e2t pentru etapa jude\u021bean\u0103, c\u00e2t \u0219i pentru etapa na\u021bional\u0103.</p>","tags":["meta","sfaturi","olimpiada"]},{"location":"olimpiada/clasa-VII/#functii-link-articol","title":"Func\u021bii - link articol","text":"<ul> <li>Declarare, definire, apel</li> <li>Variabile locale, variabile globale</li> <li>Transmiterea parametrilor prin valoare \u0219i prin referin\u021b\u0103</li> </ul>","tags":["meta","sfaturi","olimpiada"]},{"location":"olimpiada/clasa-VII/#tablouri","title":"Tablouri","text":"<ul> <li>Tehnica Two Pointers - link     articol</li> <li>Tablouri de diferen\u021be - Difference Arrays - link     articol</li> <li>Determinarea secven\u021bei de sum\u0103 maxim\u0103 - link     articol</li> <li>Determinarea elementului majoritar</li> <li>Precalcularea unor informa\u021bii \u00een tablouri bidimensionale (de exemplu sume     par\u021biale pe prefixe/sufixe de linii/coloane, suma elementelor dintr-o     submatrice cu unul dintre col\u021buri fixat \u00een unul dintre col\u021burile matricei) -     link     articol</li> <li>Tablouri multidimensionale</li> </ul>","tags":["meta","sfaturi","olimpiada"]},{"location":"olimpiada/clasa-VII/#tipuri-de-date-neomogene-struct","title":"Tipuri de date neomogene (struct)","text":"","tags":["meta","sfaturi","olimpiada"]},{"location":"olimpiada/clasa-VII/#utilizarea-functiilor-din-biblioteca-stl-pentru-sortare-si-cautare","title":"Utilizarea func\u021biilor din biblioteca STL pentru sortare \u0219i c\u0103utare","text":"<ul> <li>Introducere STL - link articol</li> <li>Func\u021bia pentru sortare - link     articol</li> <li>Func\u021bii pentru c\u0103utarea binar\u0103 - link     articol</li> </ul>","tags":["meta","sfaturi","olimpiada"]},{"location":"olimpiada/clasa-VII/#metoda-greedy-link-articol","title":"Metoda Greedy - link articol","text":"<p>Observa\u021bie</p> <p>Urm\u0103toarele capitole sunt doar pentru etapa na\u021bional\u0103</p>","tags":["meta","sfaturi","olimpiada"]},{"location":"olimpiada/clasa-VII/#operatii-cu-numere-mari-link-articol","title":"Opera\u021bii cu numere mari - link articol","text":"<ul> <li>Adunarea numerelor mari - link     articol</li> <li>Sc\u0103derea numerelor mari - link     articol</li> <li>\u00cenmul\u021birea unui num\u0103r mare cu un num\u0103r natural - link     articol</li> <li>\u00cemp\u0103r\u021birea cu rest a unui num\u0103r mare la un num\u0103r natural nenul - link     articol</li> </ul>","tags":["meta","sfaturi","olimpiada"]},{"location":"olimpiada/clasa-VII/#algoritmul-de-exponentiere-rapida-link-articol","title":"Algoritmul de exponen\u021biere rapid\u0103 - link articol","text":"","tags":["meta","sfaturi","olimpiada"]},{"location":"olimpiada/clasa-VII/#stiva-aplicatii-specifice-link-articol","title":"Stiva. Aplica\u021bii specifice - link articol","text":"","tags":["meta","sfaturi","olimpiada"]},{"location":"olimpiada/clasa-VIII/","title":"Clasa a VIII-a","text":"","tags":["meta","sfaturi","olimpiada"]},{"location":"olimpiada/clasa-VIII/#introducere","title":"Introducere","text":"<p>Aici g\u0103si\u021bi programa clasei a opta pentru Olimpiada de Informatic\u0103, conform programei create de SEPI \u00een anul \u0219colar 2023-2024, \u00eempreun\u0103 cu locurile de unde pute\u021bi \u00eenv\u0103\u021ba aceste con\u021binuturi \u00een arhiva noastr\u0103.</p> <p>Pe l\u00e2ng\u0103 con\u021binuturile de mai jos, programa include \u0219i materia clasei a \u0219aptea, care poate fi accesat\u0103 \u00een articolul corespunz\u0103tor.</p> <p>Observa\u021bie</p> <p>Urm\u0103toarele capitole sunt at\u00e2t pentru etapa jude\u021bean\u0103, c\u00e2t \u0219i pentru etapa na\u021bional\u0103.</p>","tags":["meta","sfaturi","olimpiada"]},{"location":"olimpiada/clasa-VIII/#siruri-de-caractere-functii-specifice-link-articol","title":"\u0218iruri de caractere. Func\u021bii specifice - link articol","text":"","tags":["meta","sfaturi","olimpiada"]},{"location":"olimpiada/clasa-VIII/#generarea-elementelor-combinatoriale-prin-algoritmi-de-tip-succesor-link-articol","title":"Generarea elementelor combinatoriale prin algoritmi de tip succesor - link articol","text":"<ul> <li>Submul\u021bimi</li> <li>Produs cartezian</li> <li>Permut\u0103ri</li> <li>Combin\u0103ri</li> <li>Aranjamente</li> <li>Utilizarea func\u021biilor din biblioteca STL pentru permut\u0103ri</li> </ul> <p>Observa\u021bie</p> <p>Urm\u0103toarele capitole sunt doar pentru etapa na\u021bional\u0103</p>","tags":["meta","sfaturi","olimpiada"]},{"location":"olimpiada/clasa-VIII/#coada-aplicatii-specifice-link-articol","title":"Coada. Aplica\u021bii specifice - link articol","text":"","tags":["meta","sfaturi","olimpiada"]},{"location":"olimpiada/clasa-VIII/#coada-cu-dubla-prioritate-deque-aplicatii-specifice-link-articol","title":"Coada cu dubl\u0103 prioritate (deque). Aplica\u021bii specifice - link articol","text":"","tags":["meta","sfaturi","olimpiada"]},{"location":"olimpiada/clasa-VIII/#elemente-de-geometrie-link-articol","title":"Elemente de geometrie - link articol","text":"<ul> <li>sistemul de coordonate cartezian \u00een plan</li> <li>puncte \u00een planul cartezian</li> <li>distan\u021ba dintre dou\u0103 puncte</li> <li>arii</li> </ul>","tags":["meta","sfaturi","olimpiada"]},{"location":"olimpiada/clasa-X/","title":"Clasa a X-a","text":"","tags":["meta","sfaturi","olimpiada"]},{"location":"olimpiada/clasa-X/#introducere","title":"Introducere","text":"<p>Aici g\u0103si\u021bi programa clasei a zecea pentru Olimpiada de Informatic\u0103, conform programei create de SEPI \u00een anul \u0219colar 2023-2024, \u00eempreun\u0103 cu locurile de unde pute\u021bi \u00eenv\u0103\u021ba aceste con\u021binuturi \u00een arhiva noastr\u0103.</p> <p>Pe l\u00e2ng\u0103 con\u021binuturile de mai jos, programa include \u0219i materia clasei a noua, care poate fi accesat\u0103 \u00een articolul corespunz\u0103tor.</p> <p>Observa\u021bie</p> <p>Urm\u0103toarele capitole sunt at\u00e2t pentru etapa jude\u021bean\u0103, c\u00e2t \u0219i pentru etapa na\u021bional\u0103.</p>","tags":["meta","sfaturi","olimpiada"]},{"location":"olimpiada/clasa-X/#siruri-de-caractere-functii-specifice-link-articol","title":"\u0218iruri de caractere. Func\u021bii specifice - link articol","text":"","tags":["meta","sfaturi","olimpiada"]},{"location":"olimpiada/clasa-X/#structuri-de-date","title":"Structuri de date","text":"<ul> <li>Stiva (stack). Aplica\u021bii specifice - link     articol</li> <li>Coada (queue). Aplica\u021bii specifice. Algoritmul lui Lee<ul> <li>Coada - link articol</li> <li>Algoritmul lui Lee - link     articol</li> </ul> </li> <li>Deque. Aplica\u021bii specifice - link     articol</li> <li>Lista (liste simplu \u0219i dublu \u00eenl\u0103n\u021buite alocate dinamic)</li> <li>Structuri de date din biblioteca STL (Standard Template Library): pair,     vector, list, deque, queue, priority_queue, stack, set (inclusiv variantele     unordered_set \u0219i multiset), map (inclusiv variantele unordered_map \u0219i     multimap), bitset.<ul> <li>Introducere STL - link articol</li> <li>Bitset - link articol</li> </ul> </li> </ul>","tags":["meta","sfaturi","olimpiada"]},{"location":"olimpiada/clasa-X/#operatii-cu-numere-mari-link-articol","title":"Opera\u021bii cu numere mari - link articol","text":"<ul> <li>Adunarea numerelor mari - link     articol</li> <li>Sc\u0103derea numerelor mari - link     articol</li> <li>\u00cenmul\u021birea unui num\u0103r mare cu un num\u0103r natural - link     articol</li> <li>\u00cemp\u0103r\u021birea cu rest a unui num\u0103r mare la un num\u0103r natural nenul - link     articol</li> </ul>","tags":["meta","sfaturi","olimpiada"]},{"location":"olimpiada/clasa-X/#elemente-de-combinatorica-link-articol","title":"Elemente de combinatoric\u0103 - link articol","text":"<ul> <li>Num\u0103rarea elementelor combinatoriale (submul\u021bimi, produs cartezian, permut\u0103ri,     aranjamente, combin\u0103ri, parantez\u0103ri, parti\u021bii)</li> <li>Determinarea num\u0103rului de ordine pentru elementele combinatoriale</li> <li>Aritmetic\u0103 modular\u0103 (adunare, sc\u0103dere, \u00eenmul\u021bire, invers modular - pentru     modulo num\u0103r prim) - link     articol</li> </ul>","tags":["meta","sfaturi","olimpiada"]},{"location":"olimpiada/clasa-X/#recursivitate-link-articol","title":"Recursivitate - link articol","text":"","tags":["meta","sfaturi","olimpiada"]},{"location":"olimpiada/clasa-X/#metoda-divide-et-impera-link-articol","title":"Metoda Divide et Impera - link articol","text":"<p>Observa\u021bie</p> <p>Urm\u0103toarele capitole sunt doar pentru etapa na\u021bional\u0103.</p>","tags":["meta","sfaturi","olimpiada"]},{"location":"olimpiada/clasa-X/#elemente-de-geometrie-link-articol","title":"Elemente de geometrie - link articol","text":"<ul> <li>sistemul de coordonate cartezian</li> <li>distan\u021ba dintre dou\u0103 puncte</li> <li>ecua\u021bia dreptei</li> <li>distan\u021ba dintre un punct \u0219i o dreapt\u0103</li> <li>panta unei drepte</li> <li>intersec\u021bii de drepte \u0219i segmente</li> <li>arii</li> <li>algoritmi de baleiere - link     articol</li> <li>\u00eenf\u0103\u0219ur\u0103toare convex\u0103 - link     articol</li> </ul>","tags":["meta","sfaturi","olimpiada"]},{"location":"olimpiada/clasa-X/#metoda-backtracking-varianta-elementara-si-varianta-in-plan-link-articol","title":"Metoda Backtracking (varianta elementar\u0103 \u0219i varianta \u00een plan) - link articol","text":"","tags":["meta","sfaturi","olimpiada"]},{"location":"olimpiada/clasa-X/#metoda-programarii-dinamice","title":"Metoda program\u0103rii dinamice","text":"<ul> <li>Probleme de num\u0103rare - link articol</li> <li>Probleme de determinare a unei solu\u021bii optime - link     articol</li> <li>Memoizarea rela\u021biilor de recuren\u021b\u0103 - link     articol</li> <li>Problema rucsacului - link articol     (nu este \u00een program\u0103, dar se recomand\u0103 citirea acestui articol)</li> <li>Sub\u0219ir comun maximal - link articol (nu     este \u00een program\u0103, dar se recomand\u0103 citirea acestui articol)</li> <li>Sub\u0219ir cresc\u0103tor maximal - link articol     (nu este \u00een program\u0103, dar se recomand\u0103 citirea acestui articol)</li> </ul>","tags":["meta","sfaturi","olimpiada"]},{"location":"olimpiada/clasa-XI-XII/","title":"Clasele XI-XII","text":"","tags":["meta","sfaturi","olimpiada"]},{"location":"olimpiada/clasa-XI-XII/#introducere","title":"Introducere","text":"<p>Aici g\u0103si\u021bi programa claselor XI-XII pentru Olimpiada de Informatic\u0103, conform programei create de SEPI \u00een anul \u0219colar 2023-2024, \u00eempreun\u0103 cu locurile de unde pute\u021bi \u00eenv\u0103\u021ba aceste con\u021binuturi \u00een arhiva noastr\u0103.</p> <p>Pe l\u00e2ng\u0103 con\u021binuturile de mai jos, programa include \u0219i materia clasei a zecea, care poate fi accesat\u0103 \u00een articolul corespunz\u0103tor.</p> <p>Observa\u021bie</p> <p>Urm\u0103toarele capitole sunt at\u00e2t pentru etapa jude\u021bean\u0103, c\u00e2t \u0219i pentru etapa na\u021bional\u0103.</p>","tags":["meta","sfaturi","olimpiada"]},{"location":"olimpiada/clasa-XI-XII/#metoda-programarii-dinamice","title":"Metoda program\u0103rii dinamice","text":"<ul> <li>Programare dinamic\u0103 pe arbori \u0219i grafuri</li> <li>Programare dinamic\u0103 pe grafuri - link     articol</li> <li>Programare dinamic\u0103 pe arbore - link     articol</li> <li>Programare dinamic\u0103 pe st\u0103ri exponen\u021biale (bitmask DP) - link   articol</li> </ul>","tags":["meta","sfaturi","olimpiada"]},{"location":"olimpiada/clasa-XI-XII/#grafuri-orientate-si-neorientate-link-articol","title":"Grafuri orientate \u0219i neorientate - link articol","text":"<ul> <li>Terminologie (graf neorientat, graf orientat, lan\u0163, lan\u0163 elementar, drum, drum   elementar, ciclu, ciclu elementar, circuit, circuit elementar, grad, graf   par\u0163ial, subgraf, conexitate, tare conexitate, arbore, graf ponderat, arbore   par\u0163ial, arbore par\u0163ial de cost minim) - link   articol</li> <li>Tipuri speciale de grafuri (graf complet, graf hamiltonian, graf eulerian,   graf bipartit, graf turneu) - link   articol</li> <li>Reprezentarea grafurilor (matrice de adiacen\u0163\u0103, liste de adiacen\u0163\u0103, lista   muchiilor/arcelor) - link   articol</li> <li>Grafuri ponderate. Reprezentarea grafurilor ponderate (matricea costurilor,   liste de adiacen\u021b\u0103 cu costuri, lista muchiilor/arcelor cu costuri) - link   articol</li> <li>Algoritmi de prelucrare a grafurilor</li> <li>Parcurgerea grafurilor \u00een l\u0103\u0163ime (BFS), \u00een ad\u00e2ncime (DFS), parcurgerea     eulerian\u0103<ul> <li>DFS - link   articol</li> <li>BFS - link   articol</li> </ul> </li> <li>Determinarea componentelor conexe ale unui graf neorientat - link     articol</li> <li>Determinarea componentelor tare conexe ale unui graf orientat. Algoritmul     Kosaraju-Sharir. Graful componentelor tare-conexe - link     articol</li> <li>Determinarea matricei lan\u0163urilor/drumurilor (algoritmul Roy-Warshall) -     link     articol</li> <li>Descompunerea unui graf orientat f\u0103r\u0103 circuite pe niveluri. Sortare     topologic\u0103 - link articol</li> <li>Determinarea drumurilor de cost minim \u00eentr-un graf. Algoritmul lui Dijkstra,     algoritmul Bellman-Ford, algoritmul Roy-Floyd - link     articol</li> <li>Determinarea unui lan\u021b/ciclu hamiltonian - link     articol</li> <li>Determinarea unui lan\u021b/ciclu eulerian - link     articol</li> </ul>","tags":["meta","sfaturi","olimpiada"]},{"location":"olimpiada/clasa-XI-XII/#arbori","title":"Arbori","text":"<ul> <li>Defini\u021bie, propriet\u0103\u021bi - link articol</li> <li>Arbori par\u021biali - link articol</li> <li>Arbori par\u0163iali de cost minim (algoritmul lui Kruskal \u0219i algoritmul lui Prim -   link articol</li> </ul>","tags":["meta","sfaturi","olimpiada"]},{"location":"olimpiada/clasa-XI-XII/#structuri-de-date-arborescente-link-articol","title":"Structuri de date arborescente  - link articol","text":"<ul> <li>Arbori cu r\u0103d\u0103cin\u0103 (defini\u0163ie, propriet\u0103\u0163i, reprezentarea arborilor cu   r\u0103d\u0103cin\u0103) - link   articol</li> <li>Arbori binari (defini\u0163ie, propriet\u0103\u0163i specifice; reprezentarea arborilor   binari) - link articol</li> <li>Opera\u021bii pe structuri de date (interog\u0103ri, actualiz\u0103ri)</li> <li>Arbore binar complet \u2013 defini\u0163ie, propriet\u0103\u0163i, reprezentare secven\u0163ial\u0103</li> <li>Heap-uri \u2013 defini\u0163ie, propriet\u0103\u0163i, opera\u0163ii specifice (inserare nod,   extragerea nodului cu cheie maxim\u0103/minim\u0103) (std::priority_queue \u00een C++)</li> <li>Arbore binar de c\u0103utare \u2013 defini\u0163ie, propriet\u0103\u0163i, opera\u0163ii specifice (inserare   nod, \u015ftergere nod, c\u0103utare element) (std::set \u00een C++)</li> <li>Reprezentarea mul\u021bimilor disjuncte. Algoritmii Union-Find - link   articol</li> </ul> <p>Observa\u021bie</p> <p>Urm\u0103toarele capitole sunt doar pentru etapa na\u021bional\u0103.</p>","tags":["meta","sfaturi","olimpiada"]},{"location":"olimpiada/clasa-XI-XII/#algoritmi-pe-grafuri","title":"Algoritmi pe grafuri","text":"<ul> <li>Determinarea punctelor de articula\u021bie, a pun\u021bilor \u0219i descompunerea grafurilor   \u00een componente biconexe. - link   articol</li> <li>Algoritmul lui Dial (optimizarea algoritmului lui Dijkstra pentru grafuri cu   ponderi dintr-un interval mic de valori) - link   articol</li> </ul>","tags":["meta","sfaturi","olimpiada"]},{"location":"olimpiada/clasa-XI-XII/#structuri-de-date-arborescente","title":"Structuri de date arborescente","text":"<ul> <li>Determinarea celui mai apropiat str\u0103mo\u0219 comun a dou\u0103 noduri dintr-un arbore   (lowest common ancestor - LCA) - link   articol</li> <li>Determinarea diametrului unui arbore - link   articol</li> <li>Arbori indexa\u021bi binar - link   articol</li> <li>Arbori de intervale - link   articol</li> </ul>","tags":["meta","sfaturi","olimpiada"]},{"location":"olimpiada/clasa-XI-XII/#square-root-decomposition-algoritmul-lui-mo-link-articol","title":"Square Root Decomposition. Algoritmul lui Mo - link articol","text":"","tags":["meta","sfaturi","olimpiada"]},{"location":"olimpiada/clasa-XI-XII/#range-minimum-query-rmq-link-articol","title":"Range Minimum Query (RMQ) - link articol","text":"","tags":["meta","sfaturi","olimpiada"]},{"location":"olimpiada/clasa-XI-XII/#tehnica-meet-in-the-middle-link-articol","title":"Tehnica Meet in the Middle - link articol","text":"","tags":["meta","sfaturi","olimpiada"]},{"location":"olimpiada/clasa-XI-XII/#ridicarea-la-putere-a-matricilor-in-timp-logaritmic-rezolvarea-recurentelor-liniare-link-articol","title":"Ridicarea la putere a matricilor \u00een timp logaritmic. Rezolvarea recuren\u021belor liniare - link articol","text":"","tags":["meta","sfaturi","olimpiada"]},{"location":"olimpiada/clasa-XI-XII/#principiul-includerii-si-excluderii-functia-mobius-link-articol","title":"Principiul includerii \u0219i excluderii. Func\u021bia Mobius - link articol","text":"","tags":["meta","sfaturi","olimpiada"]},{"location":"olimpiada/gimnaziu/","title":"Sfaturi generale pentru gimnaziu","text":"","tags":["meta","sfaturi","olimpiada","gimnaziu"]},{"location":"olimpiada/gimnaziu/#introducere","title":"Introducere","text":"<p>Aici g\u0103si\u021bi linkuri c\u0103tre articolele noastre \u00een care prezent\u0103m programele claselor de gimnaziu pentru Olimpiada de Informatic\u0103, conform programei create de SEPI \u00een anul \u0219colar 2023-2024, \u00eempreun\u0103 cu sfaturi specifice pe care le pute\u021bi urma pentru a putea ob\u021bine rezultate mai bune la concursurile \u0219i olimpiadele specifice claselor de gimnaziu.</p>","tags":["meta","sfaturi","olimpiada","gimnaziu"]},{"location":"olimpiada/gimnaziu/#programa","title":"Programa","text":"<ul> <li>Clasa a V-a</li> <li>Clasa a VI-a</li> <li>Clasa a VII-a</li> <li>Clasa a VIII-a</li> <li>Baraj, lot juniori</li> </ul>","tags":["meta","sfaturi","olimpiada","gimnaziu"]},{"location":"olimpiada/gimnaziu/#sfaturi-utile","title":"Sfaturi utile","text":"<p>Pe l\u00e2ng\u0103 roadmapul prezentat aici, \u00een ceea ce prive\u0219te materia de gimnaziu, recomand\u0103m mai ales rezolvarea problemelor date \u00een anii anteriori la olimpiada de informatic\u0103, linkuri care pot fi g\u0103site \u00een articolele corespunz\u0103toare claselor respective.</p> <p>De asemenea, foarte multe probleme de la concursurile de gimnaziu au cerin\u021be complet separate care v\u0103 pot ajuta s\u0103 ob\u021bine\u021bi puncte importante care v\u0103 pot ajuta fie c\u0103 este vorba de calificarea la na\u021bional\u0103, c\u00e2\u0219tigarea unei medalii sau calificarea la lotul de juniori.</p> <p>Nu \u00een ultimul r\u00e2nd, este important s\u0103 exersa\u021bi implementarea algoritmilor de care ave\u021bi nevoie, deoarece \u00een condi\u021bii de concurs, lucrurile pot fi mai dificile \u0219i este foarte important s\u0103 fi\u021bi siguri pe voi pentru a reu\u0219i la concurs.</p>","tags":["meta","sfaturi","olimpiada","gimnaziu"]},{"location":"olimpiada/gimnaziu/#concluzii","title":"Concluzii","text":"<p>Pentru a fi buni la informatic\u0103 \u00eenc\u0103 din clasele mici, este important \u00een primul r\u00e2nd s\u0103 v\u0103 plac\u0103 s\u0103 lucra\u021bi \u0219i s\u0103 rezolva\u021bi probleme, dar de asemenea \u0219i s\u0103 lucra\u021bi constant, pentru a putea asimila materia c\u00e2t mai repede \u0219i s\u0103 v\u0103 obi\u0219nui\u021bi cu problemele date la concursuri, iar dac\u0103 ave\u021bi timp \u0219i merg lucrurile bine, pute\u021bi oric\u00e2nd s\u0103 \u00eenv\u0103\u021ba\u021bi lucruri \u00een plus pentru a ajunge c\u00e2t mai buni.</p>","tags":["meta","sfaturi","olimpiada","gimnaziu"]},{"location":"olimpiada/liceu/","title":"Sfaturi generale pentru liceu","text":"","tags":["meta","sfaturi","olimpiada","liceu"]},{"location":"olimpiada/liceu/#introducere","title":"Introducere","text":"<p>Aici g\u0103si\u021bi linkuri c\u0103tre articolele noastre \u00een care prezent\u0103m programele claselor de liceu pentru Olimpiada de Informatic\u0103, conform programei create de SEPI \u00een anul \u0219colar 2023-2024, \u00eempreun\u0103 cu sfaturi specifice pe care le pute\u021bi urma pentru a putea ob\u021bine rezultate mai bune la concursurile \u0219i olimpiadele specifice claselor de liceu.</p>","tags":["meta","sfaturi","olimpiada","liceu"]},{"location":"olimpiada/liceu/#programa","title":"Programa","text":"<ul> <li>Clasa a IX-a</li> <li>Clasa a X-a</li> <li>Clasele XI-XII</li> <li>Baraj, lot seniori</li> </ul>","tags":["meta","sfaturi","olimpiada","liceu"]},{"location":"olimpiada/liceu/#sfaturi-utile","title":"Sfaturi utile","text":"<p>Pe l\u00e2ng\u0103 roadmapul prezentat aici, \u00een ceea ce prive\u0219te materia de liceu, recomand\u0103m mai ales rezolvarea problemelor date \u00een anii anteriori la olimpiada de informatic\u0103, linkuri care pot fi g\u0103site \u00een articolele corespunz\u0103toare claselor respective.</p> <p>Problemele date la concursurile de liceu con\u021bin diverse subtaskuri (cerin\u021be mai u\u0219oare) care v\u0103 pot ajuta fie s\u0103 lua\u021bi puncte mai multe, fie chiar s\u0103 ajunge\u021bi s\u0103 folosi\u021bi acele observa\u021bii pentru a rezolva problema \u00een \u00eentregime.</p> <p>Nu \u00een ultimul r\u00e2nd, este important s\u0103 exersa\u021bi implementarea algoritmilor de care ave\u021bi nevoie, mai ales cei mai avansa\u021bi, deoarece \u00een condi\u021bii de concurs, lucrurile pot fi mai dificile \u0219i este foarte important s\u0103 fi\u021bi siguri pe voi pentru a reu\u0219i la concurs.</p> <p>Spre deosebire de clasele de gimnaziu, participarea la alte competi\u021bii este mult mai important\u0103, o list\u0103 de concursuri la care pute\u021bi participa poate fi g\u0103sit\u0103 aici.</p>","tags":["meta","sfaturi","olimpiada","liceu"]},{"location":"olimpiada/liceu/#concluzii","title":"Concluzii","text":"<p>Pentru a fi buni la informatic\u0103, este important \u00een primul r\u00e2nd s\u0103 v\u0103 plac\u0103 s\u0103 lucra\u021bi \u0219i s\u0103 rezolva\u021bi probleme, dar de asemenea \u0219i s\u0103 lucra\u021bi constant, pentru a putea asimila materia c\u00e2t mai repede \u0219i s\u0103 v\u0103 obi\u0219nui\u021bi cu problemele date la concursuri, iar dac\u0103 ave\u021bi timp \u0219i merg lucrurile bine, pute\u021bi oric\u00e2nd s\u0103 \u00eenv\u0103\u021ba\u021bi lucruri \u00een plus pentru a ajunge c\u00e2t mai buni.</p>","tags":["meta","sfaturi","olimpiada","liceu"]},{"location":"olimpiada/olympiad-improvement/","title":"Cum ajungi s\u0103 iei rezultate tot mai bune la olimpiad\u0103?","text":"<p>Daca vreti sa ne ajutati cu acest articol, ne puteti gasi pe github sau pe serverul nostru de discord</p> <p>Mai jos g\u0103si\u021bi resurse pe care le pute\u021bi citi p\u00e2n\u0103 atunci.</p>","tags":["meta","sfaturi","strategie"]},{"location":"olimpiada/olympiad-improvement/#introducere","title":"Introducere","text":"","tags":["meta","sfaturi","strategie"]},{"location":"olimpiada/olympiad-improvement/#problema-exemplu","title":"Problema exemplu","text":"","tags":["meta","sfaturi","strategie"]},{"location":"olimpiada/olympiad-improvement/#concluzii","title":"Concluzii","text":"","tags":["meta","sfaturi","strategie"]},{"location":"olimpiada/olympiad-improvement/#probleme-suplimentare","title":"Probleme suplimentare","text":"","tags":["meta","sfaturi","strategie"]},{"location":"olimpiada/olympiad-improvement/#resurse-suplimentare","title":"Resurse suplimentare","text":"<ul> <li>Ghid complet pentru concursurile de informatica -   infoarena</li> <li>Psihologia concursurilor de informatica -   Algopedia</li> </ul>","tags":["meta","sfaturi","strategie"]},{"location":"olimpiada/olympiad-info/","title":"Informa\u021bii despre olimpiada de informatic\u0103","text":"","tags":["meta","olimpiada","informatii"]},{"location":"olimpiada/olympiad-info/#introducere","title":"Introducere","text":"<p>Ai lucrat diferite tipuri de probleme \u0219i vrei s\u0103 participi la olimpiad\u0103? Dac\u0103 vrei s\u0103 ajungi s\u0103 ai \u0219ansa s\u0103 reprezin\u021bi \u0219coala, jude\u021bul sau chiar \u021bara \u00een diferite competi\u021bii, olimpiada este \u0219ansa ta.</p> <p>\u00cen acest articol, voi prezenta cum po\u021bi participa la olimpiad\u0103 \u0219i la alte concursuri de informatic\u0103 rom\u00e2ne\u0219ti, precum \u0219i informa\u021bii legate de ce trebuie s\u0103 \u00eenve\u021bi \u0219i formatul concursurilor.</p> <p>Disclaimer</p> <p>Acest articol are un caracter neoficial \u0219i reprezint\u0103 totalitatea informa\u021biilor str\u00e2nse de autor de-a lungul experien\u021bei sale la olimpiad\u0103, at\u00e2t ca participant, c\u00e2t \u0219i ca propun\u0103tor, \u00eempreun\u0103 cu informa\u021biile culese de pe siteul olimpiadei, a\u0219a cum erau ele \u00een septembrie 2024. Pentru informa\u021bii oficiale, contacta\u021bi organizatorii olimpiadei.</p>","tags":["meta","olimpiada","informatii"]},{"location":"olimpiada/olympiad-info/#olimpiada-nationala-de-informatica-oni","title":"Olimpiada Na\u021bional\u0103 de Informatic\u0103 (ONI)","text":"<p>Cu o tradi\u021bie de aproape 5 decenii \u00een diverse forme, olimpiada na\u021bional\u0103 de informatic\u0103 este principala competi\u021bie de algoritmic\u0103 rom\u00e2neasc\u0103 pentru elevii de gimnaziu \u0219i liceu. Competi\u021bia este organizat\u0103 separat pentru fiecare clas\u0103, astfel ai posibilitatea s\u0103 concurezi cu al\u021bi elevi din aceea\u0219i clas\u0103 cu tine.</p> <p>Observa\u021bie</p> <p>Po\u021bi concura \u0219i la o clas\u0103 superioar\u0103 v\u00e2rstei tale, iar \u00een mod particular dac\u0103 e\u0219ti \u00eentr-o clas\u0103 mai mic\u0103 de clasa a cincea, po\u021bi concura la olimpiad\u0103 la clasa a V-a \u0219i chiar s-o c\u00e2\u0219tigi.</p> <p>Aceast\u0103 olimpiad\u0103 s-a \u021binut \u00een fiecare an cu excep\u021bia anului 2020, atunci c\u00e2nd restric\u021biile impuse de virusul COVID-19 au for\u021bat anularea fazelor de dup\u0103 cea jude\u021bean\u0103.</p> <p>\u00cencep\u00e2nd cu anul 2021, olimpiada este organizat\u0103 de Societatea pentru Excelen\u021b\u0103 \u0219i Performan\u021b\u0103 \u00een Informatic\u0103 (SEPI), organiza\u021bie creat\u0103 de profesori, studen\u021bi \u0219i al\u021bi membri ai comisiilor de lucru ale olimpiadelor na\u021bionale de-a lungul anilor, cu scopul de a asigura continuitatea olimpiadei \u00een timpul pandemiei, iar ulterior, o desf\u0103\u0219urare c\u00e2t mai bun\u0103 a competi\u021biilor de informatic\u0103 rom\u00e2ne\u0219ti, \u00eempreun\u0103 cu ministerul educa\u021biei.</p>","tags":["meta","olimpiada","informatii"]},{"location":"olimpiada/olympiad-info/#cum-participi","title":"Cum participi?","text":"<p>Pentru a participa la olimpiad\u0103, trebuie s\u0103 iei leg\u0103tura cu profesorul t\u0103u de la clas\u0103 \u0219i atunci c\u00e2nd se public\u0103 formularul de \u00eenscriere, s\u0103 \u00eel completezi cu aten\u021bie, folosind datele tale de identificare corecte, respect\u00e2nd regulile \u00een vigoare.</p> <p>De asemenea, trebuie s\u0103 ai \u00een vedere c\u0103 limbajele de programare acceptate la olimpiad\u0103 sunt C, C++ \u0219i Pascal, dar de departe, cea mai bun\u0103 op\u021biune este limbajul C++, cu precizarea c\u0103 \u0219i limbajul C este o op\u021biune viabil\u0103 \u00een cele mai multe situa\u021bii.</p> <p>\u00cen timpul desf\u0103\u0219ur\u0103rii olimpiadei, toate informa\u021biile importante vor fi prezente pe site-ul SEPI, ei fiind responsabili de tot ce \u021bine informa\u021bii oficiale legate de olimpiad\u0103, premii \u0219i alte informa\u021bii ce \u021bin de jurisdic\u021bia SEPI.</p> <p>Dup\u0103 ce prime\u0219ti confirmarea de la organizatorii olimpiadei, po\u021bi participa la olimpiada jude\u021bean\u0103!</p>","tags":["meta","olimpiada","informatii"]},{"location":"olimpiada/olympiad-info/#formatul-si-etapele-olimpiadei","title":"Formatul \u0219i etapele olimpiadei","text":"<p>\u00cen cele mai multe jude\u021be, olimpiada de informatic\u0103 \u00eencepe cu etapa jude\u021bean\u0103 (OJI), dar \u00een unele jude\u021be \u0219i \u0219coli, exist\u0103 \u0219i o faz\u0103 preliminar\u0103, colocvial numit\u0103 etapa local\u0103.</p> <p>\u00cen unele jude\u021be, acest concurs este unul organizat \u00eentr-un format similar celui de la OJI, fiind o prim\u0103 selec\u021bie pentru elevi. Un astfel de exemplu este jude\u021bul Ia\u0219i, unde Olimpiada Municipal\u0103 de Informatic\u0103 are o tradi\u021bie de peste 20 de ani, problemele din anii anteriori g\u0103sindu-se aici.</p> <p>Fiecare problem\u0103 din concurs valoreaz\u0103 100 de puncte, punctajul ob\u021binut fiind corespunz\u0103tor calit\u0103\u021bii solu\u021biilor pe care le trimi\u021bi. Cu alte cuvinte, cu c\u00e2t solu\u021bia ta trece de mai multe teste \u00een restric\u021biile impuse (timp \u0219i memorie), cu at\u00e2t vei ob\u021bine mai multe puncte.</p> <p>\u00cencep\u00e2nd cu anul 2021, sistemul de evaluare folosit este unul automat, \u00een timp real, serverul de concurs este bazat pe Contest Management System (CMS), sistemul folosit la competi\u021biile \u0219i olimpiadele interna\u021bionale de informatic\u0103.</p> <p>Observa\u021bie</p> <p>P\u00e2n\u0103 \u00een anul 2020, sistemul de evaluare era unul bazat pe colectarea solu\u021biilor participan\u021bilor folosind un stick USB, rezultatele fiind aflate dup\u0103 c\u00e2teva ore de la finalizarea concursului, acestea fiind publicate pe siteul olimpiada.info.</p> <p>La fel ca orice concurs, olimpiada de informatica are \u0219i ea programa ei, aici pute\u021bi g\u0103si cea mai recent\u0103 versiune a programei olimpiadei de informatic\u0103, cuno\u0219tin\u021bele fiind \u00eemp\u0103r\u021bite pe clase, \u00een func\u021bie de clasa la care pot \u00eencepe s\u0103 apar\u0103 astfel de probleme \u00een concurs.</p> <p>De asemenea, este evident faptul c\u0103 orice tentativ\u0103 de a frauda sau perturba concursul are drept consecin\u021b\u0103 excluderea de la olimpiada de informatic\u0103.</p>","tags":["meta","olimpiada","informatii"]},{"location":"olimpiada/olympiad-info/#olimpiada-judeteana-de-informatica-oji","title":"Olimpiada Jude\u021bean\u0103 de Informatic\u0103 (OJI)","text":"<p>Olimpiada Jude\u021bean\u0103 de Informatic\u0103 (OJI) reprezint\u0103 prima etap\u0103 de selec\u021bie ce are loc la nivel na\u021bional, aceasta organiz\u00e2ndu-se \u00een fiecare an, de regul\u0103 la mijlocul lunii martie.</p> <p>Aceasta const\u0103 \u00eentr-o singur\u0103 prob\u0103 de concurs, ce are loc la un centru jude\u021bean, iar \u00een func\u021bie de clasa \u00een care e\u0219ti, proba are urm\u0103torul format:</p> <ul> <li>Clasele V-VIII: O singur\u0103 prob\u0103 de concurs, cu durata de 3 ore \u0219i care   con\u021bine 2 probleme.</li> <li>Clasele IX-XII: O singur\u0103 prob\u0103 de concurs, cu durata de 4 ore \u0219i care   con\u021bine 3 probleme.</li> </ul> <p>Pentru a te califica la etapa na\u021bional\u0103, trebuie s\u0103 ob\u021bii m\u0103car \\(40\\%\\) din punctajul maxim (80 sau 120 de puncte, \u00een func\u021bie de clas\u0103) \u0219i s\u0103 respec\u021bi m\u0103car unul din cele dou\u0103 criterii:</p> <ul> <li>Rezultatul ob\u021binut este cel mai bun din jude\u021bul/sectorul de unde e\u0219ti</li> <li>Rezultatul ob\u021binut nu este cel mai bun din jude\u021bul/sectorul de unde e\u0219ti, dar   este \u00een primele \\(90 - x\\) locuri, unde \\(x\\) este num\u0103rul de elevi care s-au   calificat conform primului criteriu (locul 1 pe jude\u021b/sector). \u00cen situa\u021bia   \u00een care sunt mai mul\u021bi elevi pe locul 90 cu punctaj egal, to\u021bi se calific\u0103   la etapa na\u021bional\u0103.</li> </ul> <p>Pentru a rezolva problemele date \u00een anii anteriori, pute\u021bi s\u0103 accesa\u021bi urm\u0103toarea list\u0103: OJI pe Kilonova.</p>","tags":["meta","olimpiada","informatii"]},{"location":"olimpiada/olympiad-info/#olimpiada-nationala-de-informatica-oni_1","title":"Olimpiada Na\u021bional\u0103 de Informatic\u0103 (ONI)","text":"<p>Olimpiada Na\u021bional\u0103 de Informatic\u0103 (ONI) reprezint\u0103 faza na\u021bional\u0103 a olimpiadei, aici calific\u00e2ndu-se cei mai buni elevi din fiecare jude\u021b, aceasta organiz\u00e2ndu-se \u00een fiecare an, de regul\u0103 \u00een luna aprilie. \u00cen mod tradi\u021bional, faza na\u021bional\u0103 este \u00eemp\u0103r\u021bit\u0103 \u00een dou\u0103 (gimnaziu \u0219i liceu), fiecare dintre ele are loc \u00eentr-un alt ora\u0219, iar \u00een mod uzual, olimpiada are loc \u00een fiecare an \u00een ora\u0219e diferite.</p> <p>De\u0219i au existat diferite formate de-a lungul istoriei, \u00een prezent, proba olimpiadei na\u021bionale de informatic\u0103 este la fel pentru gimnaziu \u0219i liceu, const\u00e2nd \u00eentr-o singur\u0103 prob\u0103 ce are 3 probleme \u0219i 4 ore de concurs.</p> <p>Pentru a rezolva problemele date \u00een anii anteriori, pute\u021bi s\u0103 accesa\u021bi urm\u0103toarea list\u0103: ONI pe Kilonova.</p>","tags":["meta","olimpiada","informatii"]},{"location":"olimpiada/olympiad-info/#premii-mentiuni-si-medalii","title":"Premii, men\u021biuni \u0219i medalii","text":"<p>\u00cen func\u021bie de rezultatul ob\u021binut la clasa unde participi, se acord\u0103 urm\u0103toarele distinc\u021bii:</p> <p>Premii oferite de Ministerul Educa\u021biei:</p> <ul> <li>Premiile I, II \u0219i III care se acord\u0103 primilor 3 clasa\u021bi la olimpiad\u0103.</li> <li>Men\u021biuni care se acord\u0103 urm\u0103torilor \\(15\\%\\) dintre participan\u021bi.</li> </ul> <p>Premii oferite de SEPI:</p> <ul> <li>Medalie de aur - se acord\u0103 primilor \\(\\frac{1}{12}\\) participan\u021bi (dac\u0103 la   olimpiad\u0103 particip\u0103 90 de elevi, de regul\u0103 se acord\u0103 \\(7-8\\) medalii de aur)</li> <li>Medalie de argint - se acord\u0103 urm\u0103torilor \\(\\frac{2}{12}\\) participan\u021bi (dac\u0103 la   olimpiad\u0103 particip\u0103 90 de elevi, de regul\u0103 se acord\u0103 15 medalii de argint)</li> <li>Medalie de bronz - se acord\u0103 urm\u0103torilor \\(\\frac{3}{12}\\) participan\u021bi (dac\u0103 la   olimpiad\u0103 particip\u0103 90 de elevi, de regul\u0103 se acord\u0103 \\(22-23\\) medalii de   bronz)</li> </ul> <p>\u00cen general, primii \\(50\\%\\) dintre participan\u021bi ob\u021bin o medalie la olimpiad\u0103, aceasta fiind echivalentul calific\u0103rii la proba de baraj.</p> <p>Observa\u021bie</p> <p>Dac\u0103 exist\u0103 punctaje egale, comisia poate decide acordarea aceluia\u0219i premiu/medalie sau departajarea folosind regulamentul \u00een vigoare.</p> <p>Nu \u00een ultimul r\u00e2nd, \u00een func\u021bie de bugetul asigurat de sponsorii olimpiadei, rezultatele superioare vin \u0219i cu premii materiale valoroase, c\u00e2\u0219tig\u0103torii olimpiadei adjudec\u00e2ndu-\u0219i de regul\u0103 \u0219i device-uri precum laptopuri, telefoane sau alte obiecte similare \u00een valoare.</p> <p>Premiile ob\u021binute mai au un alt rol, \u00een func\u021bie de universitatea la care vrei s\u0103 studiezi, un premiu mai valoros \u00ee\u021bi poate asigura admiterea f\u0103r\u0103 examen, pe locurile specifice olimpicilor. De regul\u0103, o men\u021biune la olimpiada na\u021bional\u0103 ob\u021binut\u0103 \u00een clasele IX-XII este \u00eendeajuns pentru admiterea la facult\u0103\u021bile de profil din Rom\u00e2nia.</p>","tags":["meta","olimpiada","informatii"]},{"location":"olimpiada/olympiad-info/#proba-de-baraj","title":"Proba de baraj","text":"<p>Dac\u0103 ai ob\u021binut o medalie la ONI, ai dreptul s\u0103 participi la barajul de selec\u021bie pentru lotul na\u021bional. \u00cen func\u021bie de rezultatul pe care \u00eel ob\u021bii, po\u021bi deveni unul din membrii lotului na\u021bional de seniori sau juniori.</p> <p>Spre deosebire de OJI \u0219i ONI, barajul const\u0103 \u00een subiecte unice pentru grupa de v\u00e2rst\u0103 (juniori \u0219i seniori), dup\u0103 cum urmeaz\u0103:</p> <ul> <li>Juniori: o singur\u0103 prob\u0103 de concurs, cu 3 probleme \u0219i 4 ore. Se calific\u0103   20 de elevi la lotul de juniori.</li> <li>Seniori: dou\u0103 probe de concurs, cu 3 probleme \u0219i 5 ore. Se calific\u0103 30   de elevi la lotul de seniori.</li> </ul> <p>Un elev junior este un elev care este eligibil pentru participarea la Olimpiada European\u0103 de Informatic\u0103 pentru Juniori (EJOI), ceea ce presupune de regul\u0103 a fi n\u0103scut \u00een anul \\(x - 15\\) sau mai t\u00e2rziu. De exemplu, elevii eligibili pentru EJOI 2024 au fost cei n\u0103scu\u021bi \u00een 2009 sau mai t\u00e2rziu.</p> <p>Un elev senior este un elev care este eligibil pentru participarea la Olimpiada Interna\u021bional\u0103 de Informatic\u0103 (IOI), ceea ce presupune de regul\u0103 a avea cel mult 19 ani \u00eemplini\u021bi atunci c\u00e2nd IOI are loc. De exemplu, elevii eligibili pentru IOI 2024 au fost cei n\u0103scu\u021bi \u00een septembrie 2004 sau mai t\u00e2rziu.</p> <p>Pentru a rezolva problemele date \u00een anii anteriori, pute\u021bi s\u0103 accesa\u021bi urm\u0103toarele liste:</p> <ul> <li>Baraj Juniori pe Kilonova.</li> <li>Baraj Seniori pe Kilonova.</li> </ul> <p>Locurile corespunz\u0103toare loturilor na\u021bionale se acord\u0103 astfel:</p> <p>Se acord\u0103 c\u00e2te dou\u0103 locuri fiec\u0103rei clase, locuri ce revin celor mai buni 2 elevi de la acea clas\u0103, at\u00e2ta timp c\u00e2t ob\u021bin m\u0103car 20 de puncte la juniori, respectiv 30 de puncte la seniori.</p> <p>Celelalte 12, respectiv 22 de locuri se acord\u0103 elevilor r\u0103ma\u0219i cu punctajele cele mai mari la proba/probele de baraj.</p> <p>De asemenea, \u00een func\u021bie de rezultatele ob\u021binute la probele de baraj (juniori \u0219i seniori), se decide \u0219i echipa care reprezint\u0103 Rom\u00e2nia la Olimpiada European\u0103 de Informatic\u0103 pentru Fete (EGOI), fiind prioritare reprezentantele din lotul na\u021bional, iar mai apoi fetele cu cele mai bune rezultate la probele de baraj pentru seniori \u0219i juniori.</p>","tags":["meta","olimpiada","informatii"]},{"location":"olimpiada/olympiad-info/#lotul-national-de-informatica","title":"Lotul na\u021bional de informatic\u0103","text":"<p>Dac\u0103 ai ajuns la lot, vei avea \u0219ansa s\u0103 reprezin\u021bi Rom\u00e2nia la concursurile interna\u021bionale de juniori sau seniori, cu condi\u021bia s\u0103 te plasezi \u00een primele locuri la lotul na\u021bional.</p> <p>Formatul concursurilor este acela\u0219i cu cel de la baraj, 3 probleme \u0219i 4 ore la juniori, respectiv 3 probleme \u0219i 5 ore la seniori, nivelul problemelor fiind similar rigorilor concursurilor interna\u021bionale la care particip\u0103 \u021bara noastr\u0103.</p> <p>Pentru a rezolva problemele date \u00een anii anteriori, pute\u021bi s\u0103 accesa\u021bi urm\u0103toarele liste:</p> <ul> <li>Lot Juniori pe Kilonova.</li> <li>Lot Seniori pe Kilonova.</li> </ul> <p>\u00cen anul 2024, lotul na\u021bional a fost format din dou\u0103 tabere de preg\u0103tire \u0219i selec\u021bie, care au avut loc la Cluj-Napoca \u0219i Or\u0103\u0219tie \u00een luna mai. Fiecare dintre tabere a avut dou\u0103 probe de concurs, numeroase activit\u0103\u021bi educative dar \u0219i excursii \u0219i multe alte experien\u021be.</p> <p>\u00cen prima tab\u0103r\u0103, 30 de seniori \u0219i 20 de juniori au participat, iar la finalul primelor dou\u0103 baraje, primii 20 de seniori \u0219i 12 juniori s-au calificat la lotul restr\u00e2ns de informatic\u0103.</p> <p>\u00cen cea de-a doua tab\u0103r\u0103, 20 de seniori \u0219i 12 juniori au participat, iar la finalul celor patru baraje, s-au ales echipele reprezentative \u00een func\u021bie de rezultatele ob\u021binute de elevi de-a lungul barajelor.</p> <p>De regul\u0103, primii 4 seniori reprezint\u0103 Rom\u00e2nia la IOI \u0219i CEOI, iar urm\u0103torii 4 seniori reprezint\u0103 Rom\u00e2nia la BOI. \u00cen func\u021bie de competi\u021biile care mai apar, membrii lotului pot reprezenta \u021bara noastr\u0103 \u0219i la alte competi\u021bii, precum RMI, IATI etc.</p> <p>De regul\u0103, primii 4 juniori reprezint\u0103 Rom\u00e2nia la EJOI \u0219i JBOI, iar membrii lotului restr\u00e2ns reprezint\u0103 Rom\u00e2nia la Info(1) Cup. \u00cen func\u021bie de competi\u021biile care mai apar, membrii lotului pot reprezenta \u021bara noastr\u0103 \u0219i la alte competi\u021bii, precum IATI etc.</p> <p>Lista complet\u0103 de competi\u021bii interna\u021bionale la care particip\u0103 Rom\u00e2nia \u00een 2024 poate fi accesat\u0103 aici.</p>","tags":["meta","olimpiada","informatii"]},{"location":"olimpiada/olympiad-info/#concluzii","title":"Concluzii","text":"<p>De\u0219i drumul spre glorie la nivel na\u021bional \u0219i interna\u021bional este unul destul de lung, este un drum care merit\u0103 str\u0103b\u0103tut dac\u0103 e\u0219ti pasionat \u0219i vrei s\u0103 devii c\u00e2t mai bun.</p> <p>Personal, de-a lungul anilor am cunoscut foarte mul\u021bi oameni de valoare datorit\u0103 olimpiadelor \u0219i pe l\u00e2ng\u0103 succesul oferit de medalii, diplome \u0219i alte asemenea distinc\u021bii, prietenii \u0219i colegii pe care i-am cunoscut reprezint\u0103 de departe cel mai mare avantaj al atingerii unui nivel \u00eenalt, fie c\u0103 e vorba de gimnaziu, liceu sau chiar ulterior, \u00een comisiile de lucru.</p>","tags":["meta","olimpiada","informatii"]},{"location":"olimpiada/olympiad-info/#informatii-suplimentare","title":"Informa\u021bii suplimentare","text":"<ul> <li>Regulamentul oficial al olimpiadei \u00een anul \u0219colar   2023-2024</li> <li>Programa olimpiadei de   informatic\u0103</li> </ul>","tags":["meta","olimpiada","informatii"]},{"location":"olimpiada/olympiad-prep/","title":"Cum te preg\u0103te\u0219ti pentru olimpiad\u0103?","text":"","tags":["meta","sfaturi","olimpiada"]},{"location":"olimpiada/olympiad-prep/#introducere","title":"Introducere","text":"<p>O \u00eentrebare pe care foarte mul\u021bi oameni o pun \u00een fiecare an const\u0103 \u00een modul cel mai bun (sau unul c\u00e2t mai optim, deoarece nu exist\u0103 un r\u0103spuns \\(100 \\%\\) corect) de a te preg\u0103ti pentru olimpiada de informatic\u0103.</p> <p>Acest articol \u00ee\u0219i propune s\u0103 ofere un r\u0103spuns c\u00e2t se poate de bun, care este adaptat la diverse contexte, deoarece fiecare elev este diferit \u0219i sfaturile care func\u021bioneaz\u0103 pentru un elev nu neap\u0103rat func\u021bioneaz\u0103 pentru al\u021bi elevi.</p> <p>Pe parcurs, vom men\u021biona diverse scenarii de start, \u00eempreun\u0103 cu mijloacele prin care s\u0103 po\u021bi deveni tot mai bun la concursurile \u0219i olimpiadele de informatic\u0103.</p>","tags":["meta","sfaturi","olimpiada"]},{"location":"olimpiada/olympiad-prep/#sfaturi-generale","title":"Sfaturi generale","text":"<p>\u00cen general, pentru a deveni foarte bun la informatic\u0103, va fi foarte important s\u0103 lucrezi constant (ideal, \u00een fiecare zi) \u0219i s\u0103 ai un plan bine pus la punct.</p> <p>De asemenea, recomand\u0103m \u00eenv\u0103\u021barea materiei folosind articolele scrise de noi, iar \u00een func\u021bie de clas\u0103, po\u021bi g\u0103si programa, \u00eempreun\u0103 cu locurile de unde o po\u021bi \u00eenv\u0103\u021ba \u00een articolele din aceea\u0219i sec\u021biune.</p> <p>Un alt aspect important \u0219i ceva care recomand este p\u0103strarea ultimilor ani ai OJI/ONI pentru eventuale simul\u0103ri de concurs, o simulare fiind recrearea condi\u021biilor de concurs, practic e\u0219ti contra cronometru \u0219i vrei s\u0103 ob\u021bii c\u00e2t mai multe puncte \u00een timpul de concurs. Chiar dac\u0103 vom detalia acest lucru \u00een articolul despre abordarea olimpiadei, acest sfat trebuie s\u0103-l ave\u021bi \u00een vedere \u00een general, pentru a v\u0103 preg\u0103ti mai bine de olimpiad\u0103.</p> <p>Nu \u00een ultimul r\u00e2nd, este foarte important s\u0103 prive\u0219ti parcursul t\u0103u la informatic\u0103 \u0219i ca o activitate social\u0103. Fie c\u0103 e vorba de colegii t\u0103i de la clas\u0103, profesorul t\u0103u sau prietenii pe care \u021bi-i faci pe serverul nostru, latura social\u0103 a parcursului la informatic\u0103 este mult mai important\u0103 dec\u00e2t pare. Po\u021bi progresa mult mai repede, \u00een special dac\u0103 lucrezi \u00eempreun\u0103 cu colegi de diverse niveluri, astfel \u00eenc\u00e2t nel\u0103muririle tale s\u0103 fie rezolvate mai u\u0219or.</p>","tags":["meta","sfaturi","olimpiada"]},{"location":"olimpiada/olympiad-prep/#scenariu-1-incepi-in-gimnaziu-sau-chiar-mai-devreme","title":"Scenariu 1 - \u00cencepi \u00een gimnaziu sau chiar mai devreme","text":"<p>Dac\u0103 ai \u0219ansa s\u0103 descoperi informatica sau programarea destul de devreme, ai foarte mult timp s\u0103 \u00eenve\u021bi materia \u0219i s\u0103 o parcurgi treptat pentru a putea deveni tot mai bun. Ideal, dup\u0103 ce te obi\u0219nuie\u0219ti cu limbajul de programare C++, vrei s\u0103 \u00eencepi mai \u00eent\u00e2i cu programa clasei a V-a (chiar dac\u0103 \u00eencepi un pic mai t\u00e2rziu) \u0219i s\u0103 o iei treptat prin programa claselor, iar \u00een func\u021bie de ritmul \u00een care avansezi, po\u021bi ajunge s\u0103 devii foarte bun \u0219i de ce nu, dup\u0103 un efort sus\u021binut, s\u0103 ajungi la lotul de juniori sau dac\u0103 nu, s\u0103 ajungi s\u0103 iei rezultate foarte bune la olimpiad\u0103 \u0219i la celelalte concursuri de informatic\u0103.</p> <p>Dup\u0103 ce te-ai obi\u0219nuit cu materia claselor a V-a \u0219i a VI-a, recomand\u0103m participarea \u0219i la rundele de pe Codeforces, unde po\u021bi lua parte \u0219i la discu\u021biile de dup\u0103 concursuri care au loc pe serverul RoAlgo.</p> <p>Treptat, recomand\u0103m familiarizarea \u0219i cu problemele de la barajul de juniori, \u00een special dup\u0103 ce \u00eenve\u021bi majoritatea materiei de gimnaziu, lucru ce poate fi util \u0219i din perspectiva faptului c\u0103 \u00een vederea selec\u021biei lotului de juniori, cei mai buni doi elevi de la fiecare clas\u0103 sunt selecta\u021bi, lucru ce poate reprezenta un beneficiu imens \u00een special dac\u0103 e\u0219ti \u00een anii mai mici de gimnaziu \u0219i vrei s\u0103 ai \u0219ansa s\u0103 devii unul din cei mai buni elevi rom\u00e2ni.</p>","tags":["meta","sfaturi","olimpiada"]},{"location":"olimpiada/olympiad-prep/#scenariu-2-incepi-in-clasa-a-ix-a-sau-cel-tarziu-la-inceputul-clasei-a-x-a","title":"Scenariu 2 - \u00cencepi \u00een clasa a IX-a (sau cel t\u00e2rziu la \u00eenceputul clasei a X-a)","text":"<p>Chiar dac\u0103 \u00eencepi mai t\u00e2rziu informatica, po\u021bi profita de num\u0103rul crescut de ore pe s\u0103pt\u0103m\u00e2n\u0103 de informatic\u0103, precum \u0219i de un plan bine structurat pentru a putea \u00eenv\u0103\u021ba materia foarte rapid \u0219i de a te obi\u0219nui cu tipurile de problemele care se dau la olimpiadele \u0219i concursurile de informatic\u0103.</p> <p>La fel ca \u0219i la scenariul 1, dac\u0103 ajungi s\u0103 \u00eenve\u021bi materia \u0219i s\u0103 fii \u00eenaintea programei specifice clasei tale, po\u021bi ajunge s\u0103 lucrezi probleme tot mai dificile, care treptat s\u0103 te duc\u0103 prin materie \u0219i s\u0103 ajungi la v\u00e2rf. Chiar dac\u0103 \u00eencepi \u00eentr-a IX-a, po\u021bi ajunge s\u0103 recuperezi materia \u0219i s\u0103 \u00eenve\u021bi materia de liceu chiar \u0219i \u00eentr-un an dac\u0103 e\u0219ti dedicat \u0219i lucrezi intens \u00een fiecare zi.</p> <p>Pe l\u00e2ng\u0103 programa pe care o avem men\u021bionat\u0103 \u00een articolele din aceast\u0103 sec\u021biune, recomand\u0103m \u0219i urm\u0103rirea roadmap-ului nostru, care te poate ghida prin con\u021binuturi conform recomand\u0103rilor noastre, dar \u0219i s\u0103 lucrezi probleme interesante de la concursurile de juniori (baraje \u0219i loturi de juniori, dar \u0219i concursul Info1Cup), \u00een special dup\u0103 ce ai \u00eenv\u0103\u021bat materia claselor a IX-a \u0219i a X-a.</p> <p>Dup\u0103 ce te-ai obi\u0219nuit cu materia claselor a IX-a, recomand\u0103m participarea \u0219i la rundele de pe Codeforces, unde po\u021bi lua parte \u0219i la discu\u021biile de dup\u0103 concursuri care au loc pe serverul RoAlgo.</p> <p>Treptat, dac\u0103 vrei s\u0103 faci pasul spre concursurile superioare de seniori, problemele din anii trecu\u021bi de la barajul \u0219i lotul de seniori devin obligatorii, dar chiar \u0219i dac\u0103 lotul de informatic\u0103 nu este neap\u0103rat unul din obiectivele tale, ob\u021binerea unor rezultate bune (de regul\u0103, men\u021biune MEN) la olimpiad\u0103 te poate ajuta s\u0103 intri la facultate f\u0103r\u0103 examen sau s\u0103 ai o medie mult mai mare drept consecin\u021b\u0103.</p>","tags":["meta","sfaturi","olimpiada"]},{"location":"olimpiada/olympiad-prep/#scenariu-3-incepi-mai-tarziu","title":"Scenariu 3 - \u00cencepi mai t\u00e2rziu","text":"<p>Dac\u0103 \u00eencepi mai t\u00e2rziu informatica, nu \u00eenseamn\u0103 c\u0103 nu po\u021bi deveni olimpic la informatic\u0103, dar trebuie s\u0103 ai \u00een vedere faptul c\u0103 poten\u021bialul de cre\u0219tere al nivelului \u0219i atingerea unor rezultate de top va fi mult mai dificil\u0103, deoarece concurezi cu al\u021bi elevi care au lucrat intens de foarte mult timp, \u00eens\u0103 acest lucru nu trebuie s\u0103 reprezinte o barier\u0103, deoarece exist\u0103 oameni care au lucrat intens \u0219i au ajuns s\u0103 ia premii la olimpiada de informatic\u0103 chiar si dac\u0103 au \u00eenceput poate chiar \u00een clasa a XI-a.</p> <p>Dac\u0103 lucrezi intens \u0219i ajungi s\u0103 recuperezi \u0219i s\u0103 \u00een\u021belegi materia anilor anteriori, sfaturile de la scenariul 2 se vor aplica pentru tine ulterior. Altfel, o alt\u0103 posibilitate care merit\u0103 luat\u0103 \u00een calcul este participarea la olimpiad\u0103 cu scopul de a avea un test mai greu \u00een vederea admiterii la facultatea dorit\u0103, lucru ce este \u00eencurajat \u0219i de faptul c\u0103 \u00een cazul multor specializ\u0103ri \u0219i centre universitare, participarea \u0219i ob\u021binerea unor rezultate la olimpiad\u0103 poate aduce beneficii \u00een vederea accederii la facultatea dorit\u0103.</p> <p>Nu \u00een ultimul r\u00e2nd, chiar \u0219i dac\u0103 \u00eencepi \u00een clasa a XI-a, po\u021bi ajunge la na\u021bional\u0103 dac\u0103 depui efortul necesar, \u00eens\u0103 rezultatele de acolo depind mult de nivelul \u0219i cantitatea de timp pe care le po\u021bi depune \u00een vederea atingerii unui rezultat c\u00e2t mai bun.</p>","tags":["meta","sfaturi","olimpiada"]},{"location":"olimpiada/olympiad-prep/#concluzii","title":"Concluzii","text":"<p>\u00cen general, pentru a fi bun la informatic\u0103, trebuie s\u0103 depui efort sus\u021binut, iar pe parcurs, rezultatele vor veni \u0219i ele.</p> <p>Chiar dac\u0103 uneori, rezultatele vor \u00eent\u00e2rzia s\u0103 apar\u0103, trebuie s\u0103 prive\u0219ti \u00eenv\u0103\u021batul pentru olimpiada de informatic\u0103 drept un maraton \u0219i nu un sprint.</p> <p>Te a\u0219tept\u0103m s\u0103 lucrezi cu noi \u0219i pe parcurs s\u0103 devii tot mai bun la informatic\u0103!</p>","tags":["meta","sfaturi","olimpiada"]},{"location":"olimpiada/olympiad-strategy/","title":"Cum abordezi proba de concurs la olimpiad\u0103?","text":"","tags":["meta","sfaturi","strategie"]},{"location":"olimpiada/olympiad-strategy/#introducere","title":"Introducere","text":"<p>Te-ai preg\u0103tit pentru olimpiad\u0103, rezolv\u00e2nd problemele din anii anteriori de la OJI, ONI \u0219i alte concursuri, ai fost activ pe serverul nostru \u0219i \u021bi-ai f\u0103cut prieteni noi, dar vine concursul \u0219i \u00eentrebarea care se pune este una simpl\u0103:</p> <p>Cum abordez concursul astfel \u00eenc\u00e2t s\u0103 iau c\u00e2t mai multe puncte posibile?</p> <p>Aceast\u0103 \u00eentrebare este una complicat\u0103 \u0219i depinde mult de obiectivele tale, precum \u0219i de nivelul t\u0103u de cuno\u0219tin\u021be, deoarece chiar dac\u0103 toat\u0103 lumea vrea s\u0103 ob\u021bin\u0103 punctajul maxim posibil la fiecare concurs, se poate \u00eent\u00e2mpla ca acest lucru s\u0103 fie foarte greu sau chiar imposibil de realizat, fie din cauza dificult\u0103\u021bii problemelor, fie din cauza lipsei de experien\u021b\u0103 la acel nivel sau din alte cauze.</p> <p>Pe parcursul acestui articol, vom prezenta anumite scenarii, \u00eempreun\u0103 cu sfaturile pe care le recomand\u0103m. Acest articol este unul subiectiv \u0219i exist\u0103 \u0219i alte strategii care func\u021bioneaz\u0103, dar o mare parte din sfaturi se aplic\u0103 oric\u0103rui concurent, indiferent de nivel sau experien\u021b\u0103.</p>","tags":["meta","sfaturi","strategie"]},{"location":"olimpiada/olympiad-strategy/#ce-trebuie-sa-faci-inainte-de-concurs","title":"Ce trebuie s\u0103 faci \u00eenainte de concurs?","text":"<p>Se spune c\u0103 drumul spre succes \u00eencepe \u00eenc\u0103 de dinaintea \u00eenceperii unui concurs, iar \u00een zilele noastre, c\u00e2nd concuren\u021ba este una tot mai acerb\u0103, acest lucru este tot mai adev\u0103rat. Aici sunt c\u00e2teva dintre cele mai importante lucruri care trebuie s\u0103 fie f\u0103cute pentru a putea fi la poten\u021bialul maxim \u00eenaintea olimpiadei sau oric\u0103rui alt concurs important (aceste sfaturi pot fi folosite \u0219i pentru alte examene importante sau chiar de-a lungul vie\u021bii).</p>","tags":["meta","sfaturi","strategie"]},{"location":"olimpiada/olympiad-strategy/#odihna-inainte-de-concurs","title":"Odihna \u00eenainte de concurs","text":"<p>Un lucru comun tuturor celor care ajung s\u0103 ob\u021bin\u0103 cele mai bune rezultate posibile este odihna corespunz\u0103toare. Chiar dac\u0103 a\u021bi petrecut mult timp lucr\u00e2nd probleme, \u00eenv\u0103\u021b\u00e2nd algoritmi \u0219i tehnici noi, aceste lucruri nu v\u0103 vor ajuta la fel de mult dac\u0103 nu ave\u021bi un regim de odihn\u0103 (\u0219i alimenta\u021bie) corespunz\u0103tor. Informa\u021bia are nevoie de timp pentru a fi asimilat\u0103, iar la fel ca \u00een cazul atle\u021bilor profesioni\u0219ti, randamentul maxim vine atunci c\u00e2nd v\u0103 odihni\u021bi cum trebuie \u00eenainte de concurs.</p> <p>Recomandarea strict\u0103 este s\u0103 dormi\u021bi m\u0103car 7h30m \u00eenainte de olimpiad\u0103, iar dac\u0103 programul de somn nu este compatibil cu cel specific concursurilor (de regul\u0103, probele \u00eencep la ora 9 sau 10), o perioad\u0103 de adaptare este mai mult dec\u00e2t necesar\u0103. Un alt lucru important este s\u0103 evita\u021bi lucratul de probleme \u00een ziua de dinainte de proba de concurs, pentru a fi complet relaxa\u021bi \u0219i deta\u0219a\u021bi de tot ce \u00eenseamn\u0103 algoritmic\u0103 atunci c\u00e2nd intra\u021bi \u00een sala de concurs.</p> <p>Chiar dac\u0103 pe termen scurt, exist\u0103 \u0219i alte solu\u021bii care pot ajuta cu rezolvarea acestei probleme, cea mai s\u0103n\u0103toas\u0103 op\u021biune pe termen lung constituie odihna natural\u0103 \u0219i un regim corespunz\u0103tor.</p>","tags":["meta","sfaturi","strategie"]},{"location":"olimpiada/olympiad-strategy/#interactiunile-de-dinainte-de-concurs","title":"Interac\u021biunile de dinainte de concurs","text":"<p>\u00cen cele mai multe cazuri, este bine s\u0103 fii c\u00e2t mai deta\u0219at de ce \u00eenseamn\u0103 algoritmic\u0103, probleme sau programare \u00eenainte de concurs, deoarece discu\u021biile despre alte probleme au de cele mai multe ori un efect contrar celui a\u0219teptat (nu vei \u00eenv\u0103\u021ba niciodat\u0103 o idee nou\u0103 cu 30 de minute \u00eenainte de prob\u0103, iar memoria \u021bi se va \u00eenc\u0103rca cu o informa\u021bie probabil inutil\u0103).</p> <p>Din experien\u021ba personal\u0103, cele mai potrivite interac\u021biuni sunt cele complet off-topic, iar \u00een lipsa lor, \u00eencearc\u0103 s\u0103 evi\u021bi expunerea la zgomot inutil (aici includem \u0219i navigarea prin re\u021belele sociale).</p>","tags":["meta","sfaturi","strategie"]},{"location":"olimpiada/olympiad-strategy/#abordarea-concursului-si-a-problemelor-in-sine","title":"Abordarea concursului \u0219i a problemelor \u00een sine","text":"<p>Ai ajuns la concurs \u0219i acum vrei s\u0103 ob\u021bii c\u00e2t mai multe puncte. Deoarece nu toat\u0103 lumea este la fel de bine preg\u0103tit\u0103, vom da sfaturi c\u00e2t mai generale, dar \u0219i punctuale \u00een anumite situa\u021bii.</p>","tags":["meta","sfaturi","strategie"]},{"location":"olimpiada/olympiad-strategy/#citirea-problemelor-la-inceput","title":"Citirea problemelor la \u00eenceput","text":"<p>Imediat ce primi\u021bi subiectele de concurs la olimpiad\u0103, \u00eenainte s\u0103 scrie\u021bi orice linie de cod, citi\u021bi cu aten\u021bie toate problemele care vi s-au dat. De preferat, petrece\u021bi c\u00e2teva minute uit\u00e2ndu-v\u0103 cu aten\u021bie peste fiecare dintre probleme (de recomandat, cel pu\u021bin 5 minute/problem\u0103), iar pentru fiecare problem\u0103, nota\u021bi-v\u0103 primele idei care v\u0103 vin, precum \u0219i alte observa\u021bii pe care le face\u021bi.</p> <p>Observa\u021bie</p> <p>Chiar dac\u0103 problema este foarte u\u0219oar\u0103, este bine s\u0103 evita\u021bi s\u0103 trage\u021bi concluzii pripite, deoarece se poate \u00eent\u00e2mpla s\u0103 rata\u021bi anumite detalii din cerin\u021ba problemei.</p> <p>Dup\u0103 aceast\u0103 etap\u0103, care ar trebui s\u0103 ia \\(15-20\\) minute, ar trebui s\u0103 ave\u021bi o idee destul de bun\u0103 legat\u0103 de dificultatea relativ\u0103 a problemelor, precum \u0219i tipurile de algoritmi \u0219i idei care vor fi aplicate \u00een cele 3 probleme. \u00cen cele ce urmeaz\u0103, vom vrea s\u0103 abord\u0103m problemele, de la cea mai u\u0219oar\u0103 la cea mai grea.</p>","tags":["meta","sfaturi","strategie"]},{"location":"olimpiada/olympiad-strategy/#abordarea-unei-probleme","title":"Abordarea unei probleme","text":"<p>Presupun\u00e2nd c\u0103 am ordonat problemele dup\u0103 dificultate, vom vrea s\u0103 folosim urm\u0103torul algoritm aproximativ:</p> <pre><code>c\u00e2t timp nu ai punctajul maxim\n  g\u0103se\u0219te problema cea mai u\u0219oar\u0103 ramas\u0103\n  \u00eencearc\u0103 s\u0103 \u00ee\u021bi \u00eembun\u0103t\u0103\u021be\u0219ti scorul c\u00e2t mai mult posibil\n  dac\u0103 \u00ee\u021bi va lua prea mult timp, \u00eencearc\u0103 s\u0103 ob\u021bii altfel punctele\n</code></pre> <p>Evident, \u00een func\u021bie de situa\u021bie, trebuie s\u0103 adapt\u0103m anumite condi\u021bii, dar \u00een cele mai multe cazuri, nu vom putea ob\u021bine punctajul maxim, a\u0219a c\u0103 \u00een lipsa unor alte stimulente, scopul final este ob\u021binerea unui num\u0103r c\u00e2t mai mare de puncte. De regul\u0103, vom vrea s\u0103 le ob\u021binem rezolv\u00e2nd problemele u\u0219oare \u0219i ob\u021bin\u00e2nd c\u00e2t mai multe puncte posibil pe problemele grele.</p>","tags":["meta","sfaturi","strategie"]},{"location":"olimpiada/olympiad-strategy/#ideile","title":"Ideile","text":"<p>Dac\u0103 la un moment dat, nu ai idei de niciun fel, \u00eencepe cu explorarea punctajelor par\u021biale (subtaskurile). \u00cen multe situa\u021bii, po\u021bi scrie un algoritm mai \u00eencet, dar corect, fiind o op\u021biune mult mai bun\u0103 dec\u00e2t un algoritm mai rapid, dar incorect. Motivul principal fiind acela c\u0103 un algoritm corect poate fi ulterior optimizat, aduc\u00e2ndu-ne mai multe puncte. De asemenea, observa\u021biile g\u0103site pentru algoritmul mai \u00eencet se pot dovedi a fi importante pentru solu\u021bia complet\u0103 (sau cel pu\u021bin o solu\u021bie care ne aduce multe puncte).</p> <p>Presupun\u00e2nd c\u0103 ai o idee \u0219i vrei s\u0103 o implementezi, este foarte important s\u0103 ai ideea clar\u0103, deoarece gre\u0219elile de implementare pot dura \u00een anumite situa\u021bii foarte mult s\u0103 fie corectate \u0219i e mult mai bine s\u0103 prevenim dec\u00e2t s\u0103 avem erori nefor\u021bate.</p> <p>Ulterior, dac\u0103 ob\u021binem punctele pe care le \u021bintim, felicit\u0103ri, dar \u00een caz contrar, trebuie s\u0103 facem ceva ce chiar dac\u0103 nu este ideal, apare la orice concurs: debuggingul.</p>","tags":["meta","sfaturi","strategie"]},{"location":"olimpiada/olympiad-strategy/#debuggingul","title":"Debuggingul","text":"<p>Observa\u021bie</p> <p>Pentru mai multe detalii, accesa\u021bi acest articol aici,</p> <p>Mai \u00eent\u00e2i, e bine s\u0103 verific\u0103m erorile mici (overflow-uri, erori de scriere \u0219i alte asemenea), iar dac\u0103 nu ob\u021binem \u00eenc\u0103 punctele, trebuie s\u0103 \u00eencepem s\u0103 ne g\u00e2ndim la eventualele gre\u0219eli mai majore, precum erori de idee sau erori majore de implementare.</p> <p>Dac\u0103 ne d\u0103m seama prin ni\u0219te teste c\u0103 ideea e gre\u0219it\u0103, cel mai bine este s\u0103 reg\u00e2ndim anumi\u021bi pa\u0219i ai algoritmului pentru a corecta eroarea.</p> <p>Dac\u0103 eroarea este una de implementare, recomand\u0103m crearea unui generator de teste care s\u0103 poat\u0103 detecta teste pe care solu\u021bia voastr\u0103 ob\u021bine r\u0103spunsuri gre\u0219ite, prin compararea cu un program de tip brute-force.</p>","tags":["meta","sfaturi","strategie"]},{"location":"olimpiada/olympiad-strategy/#rezolvarea-situatiilor-de-impas","title":"Rezolvarea situa\u021biilor de impas","text":"<p>Dac\u0103 la un moment dat \u00een concurs, observa\u021bi c\u0103 scorul vostru este sub a\u0219tept\u0103rile voastre, un sfat util este s\u0103 lua\u021bi o mic\u0103 pauz\u0103 (c\u00e2teva minute, pute\u021bi s\u0103 v\u0103 duce\u021bi la toalet\u0103 eventual) \u0219i s\u0103 v\u0103 relaxa\u021bi, pentru a aborda restul concursului f\u0103r\u0103 stresul suplimentar generat de scorul mic pe care \u00eel ave\u021bi p\u00e2n\u0103 acum.</p> <p>Concursul poate fi unul greu pentru toat\u0103 lumea, iar \u00een cazul olimpiadei jude\u021bene, un obiectiv pe care \u00eel pute\u021bi avea atunci este s\u0103 v\u0103 asigura\u021bi mai \u00eent\u00e2i punctele pentru pragul minim (80 sau 120 de puncte, \u00een func\u021bie de clas\u0103), iar mai apoi s\u0103 face\u021bi progres \u00eencep\u00e2nd de acolo.</p> <p>Un alt g\u00e2nd pe care \u00eel pute\u021bi avea este faptul c\u0103 indiferent de rezultat, vor exista \u0219i alte oportunit\u0103\u021bi, iar un concurs e\u0219uat nu este o reflec\u021bie a valorii voastre individuale ca persoane. Olimpiada reprezint\u0103 doar un ciclu al vie\u021bii voastre \u0219i nu doar un scop \u00een sine.</p>","tags":["meta","sfaturi","strategie"]},{"location":"olimpiada/olympiad-strategy/#alte-aspecte-de-avut-in-vedere","title":"Alte aspecte de avut \u00een vedere","text":"<p>Chiar dac\u0103 aceste sfaturi nu par at\u00e2t de importante, foarte mul\u021bi concuren\u021bi pierd timp pre\u021bios cu lucruri care la prima vedere, nu par importante. C\u00e2teva dintre cele mai frecvente exemple includ:</p> <ul> <li>A\u0219teptarea unui anumit verdict dup\u0103 o submisie: Coada de evaluare poate fi   lung\u0103, iar la o medie de 20 de submisii per concurs \u0219i 1 minut de   a\u0219teptare, pute\u021bi pierde p\u00e2n\u0103 la \\(10 \\%\\) din timpul de concurs alocat, ceea ce   poate face diferen\u021ba \u00een anumite situa\u021bii. De asemenea, aceste momente de pauz\u0103   dese pot afecta concentrarea \u0219i g\u0103sirea ideilor mai dificile. Sfatul pe care   \u00eel recomand\u0103m este s\u0103 v\u0103 g\u00e2ndi\u021bi la o alt\u0103 problem\u0103 sau s\u0103 verifica\u021bi idei   pentru alte probleme.</li> <li>Distragerea aten\u021biei de c\u0103tre colegii din sal\u0103/supraveghetor etc.: inevitabil,   la un concurs, sunte\u021bi \u00een sal\u0103 cu un num\u0103r de colegi de diferite clase,   fiecare dintre ei av\u00e2nd obiceiurile, stilurile lor \u0219i alte aspecte (posibil)   diferite fa\u021b\u0103 de ale voastre. Concursul este unul individual \u0219i nu are niciun   sens s\u0103 v\u0103 preocupe ce fac cei din jurul vostru.</li> <li>A\u0219teptarea r\u0103spunsului la \u00eentreb\u0103ri: La fel ca \u00een cazul cozii de evaluare,   comisia nu va r\u0103spunde la \u00eentreb\u0103ri imediat, deoarece pot fi \u0219i al\u021bi elevi   care s\u0103 aib\u0103 \u00eentreb\u0103ri (posibil similare cu a voastr\u0103), caz \u00een care pot ap\u0103rea   anun\u021buri generale care pot afecta problemele din concurs.</li> <li>M\u0103surarea timpului: Este bine s\u0103 \u021bine\u021bi o oarecare eviden\u021b\u0103 a timpului r\u0103mas   (\u00een s\u0103li, profesorii de regul\u0103 ha\u0219ureaz\u0103 folosind cadrane timpul scurs) pentru   a v\u0103 p\u0103stra ritmul pe toat\u0103 durata probei (\\(3-5\\) ore).</li> </ul>","tags":["meta","sfaturi","strategie"]},{"location":"olimpiada/olympiad-strategy/#ce-faci-dupa-concurs","title":"Ce faci dup\u0103 concurs?","text":"<p>Dup\u0103 ce runda s-a terminat, inevitabil vei ajunge s\u0103 discu\u021bi problemele cu colegii \u0219i prietenii t\u0103i, \u00eenv\u0103\u021b\u00e2nd diverse idei \u0219i afl\u00e2nd solu\u021bii pe care ei le-au g\u0103sit. Din nou, fiecare concurs este unic \u0219i pute\u021bi folosi aceste experiente pentru a \u00eenv\u0103\u021ba lec\u021bii valoroase, chiar \u0219i dac\u0103 ob\u021bine\u021bi punctajul maxim.</p>","tags":["meta","sfaturi","strategie"]},{"location":"olimpiada/olympiad-strategy/#concluzii","title":"Concluzii","text":"<p>Chiar dac\u0103 succesul este determinat \u00een mare m\u0103sur\u0103 de munca depus\u0103 \u00een preg\u0103tirea continu\u0103 de-a lungul anilor, aici am prezentat detalii care pot face diferen\u021ba \u00een anumite situa\u021bii, \u0219i care \u00een general v\u0103 ajut\u0103 s\u0103 ob\u021bine\u021bi cele mai bune rezultate posibile. Aceste sfaturi nu sunt complete, dar sunt o colec\u021bie de experien\u021be adunate de mine de-a lungul celor 8 ani de competi\u021bii na\u021bionale, precum \u0219i a peste 12 ani de interac\u021bionat cu elevi \u0219i studen\u021bi dup\u0103 diverse probe.</p>","tags":["meta","sfaturi","strategie"]},{"location":"olimpiada/olympiad-strategy/#resurse-suplimentare","title":"Resurse suplimentare","text":"<ul> <li>Ghid complet pentru concursurile de informatica -   infoarena</li> <li>Psihologia concursurilor de informatica -   Algopedia</li> <li>Contest strategy - USACO Guide</li> </ul>","tags":["meta","sfaturi","strategie"]},{"location":"olimpiada/solutii/OJI/2002/V-balaur/","title":"Solu\u021bia problemei balaur (OJI 2002, clasa a V-a)","text":"<p>Aceast\u0103 problem\u0103 poate fi rezolvat\u0103 observ\u00e2nd modul \u00een care evolueaz\u0103 num\u0103rul de capete al balaurului.</p> <ul> <li>dup\u0103 prima zi, avem 5 capete (erau 6 iar F\u0103t-Frumos taie unul din ele).</li> <li>dup\u0103 cea de-a doua zi, balaurul va ajunge la 11 capete iar F\u0103t-Frumos taie   unul din ele, deci r\u0103m\u00e2n 10.</li> </ul> <p>Se poate observa c\u0103 \u00een fiecare zi, balaurul va avea 5 capete mai mult dec\u00e2t \u00een ziua precedent\u0103, deci putem defini r\u0103spunsul ca fiind egal cu \\(5 \\cdot n\\), unde \\(n\\) este num\u0103rul de zile dat \u00een datele de intrare.</p> <p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;fstream&gt;\nusing namespace std;\n\nifstream cin(\"balaur.in\");\nofstream cout(\"balaur.out\");\n\nint main() {\n    int n;\n    cin &gt;&gt; n;\n\n    cout &lt;&lt; 5 * n &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["OJI","clasa V"]},{"location":"olimpiada/solutii/OJI/2002/V-lascoala/","title":"Solu\u021bia problemei La \u0218coal\u0103 (OJI 2002, clasa a V-a)","text":"<p>Aceast\u0103 problem\u0103 poate fi rezolvat\u0103 afl\u00e2nd cel mai mare p\u0103trat perfect mai mic dec\u00e2t \\(n\\), lucru ce se poate afla verific\u00e2nd toate p\u0103tratele perfecte \u0219i aleg\u00e2nd valoarea maxim\u0103.</p> <p>Ulterior, afl\u0103m diferen\u021ba dintre \\(n\\) \u0219i \\(k^2\\), iar mai apoi afi\u0219\u0103m liniile cu elevi \u00een ordine descresc\u0103toare a valorilor, c\u00e2te \\(k\\) pe r\u00e2nd.</p> <p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;fstream&gt;\nusing namespace std;\n\nifstream cin(\"lascoala.in\");\nofstream cout(\"lascoala.out\");\n\nint main() {\n    int n;\n    cin &gt;&gt; n;\n\n    int k = 1;\n    while ((k + 1) * (k + 1) &lt; n) {\n        k++;\n    }\n    cout &lt;&lt; n - k * k &lt;&lt; '\\n';\n    for (int i = k * k; i &gt; 0; i -= k) {\n        for (int j = i; j &gt; i - k; j--) {\n            cout &lt;&lt; j &lt;&lt; \" \";\n        }\n        cout &lt;&lt; '\\n';\n    }\n\n    return 0;\n}\n</code></pre>","tags":["OJI","clasa V"]},{"location":"olimpiada/solutii/OJI/2002/VI-cuburi/","title":"Solu\u021bia problemei cuburi (OJI 2002, clasa a VI-a)","text":"<p>Pentru primele dou\u0103 cerin\u021be, vom afla frecven\u021ba maxim\u0103 a unei valori din \u0219ir, precum \u0219i care sunt valorile care au acea frecven\u021b\u0103 maxim\u0103.</p> <p>Pentru cea de-a treia cerin\u021b\u0103, putem precalcula doi vectori, \\(st\\) \u0219i \\(dr\\), cu semnifica\u021bia c\u0103 \\(st[i]\\) reprezint\u0103 num\u0103rul maxim de pozi\u021bii consecutive cu valoare egal\u0103 care con\u021bin pozi\u021bia \\(i\\) de la st\u00e2nga, iar \\(dr[i]\\) este definit \u00een mod similar, dar pentru o secven\u021b\u0103 care \u00eencepe la pozi\u021bia \\(i\\) \u0219i se extinde la dreapta.</p> <p>Pentru fiecare pozi\u021bie \\(i\\), acum ce putem face este s\u0103 verific\u0103m dac\u0103 pozi\u021biile \\(i-1\\) \u0219i \\(i+1\\) au valori egale pentru a verifica dac\u0103 putem pune laolalt\u0103 \u0219irurile de cuburi, iar maximul dintre lungimile verificate va fi r\u0103spunsul final al problemei.</p> <p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;fstream&gt;\n#include &lt;iostream&gt;\n\nusing namespace std;\nifstream fin(\"cuburi.in\");\nofstream fout(\"cuburi.out\");\n\nint f[11];\nint v[200002], st[200002], dr[200002], mst[200002], mdr[200002];\n\nint main() {\n    int n, x;\n    fin &gt;&gt; n;\n    int fmax = 0;\n    int nrculori = 0;\n\n    for (int i = 1; i &lt;= n; i++) {\n        fin &gt;&gt; x;\n        v[i] = x;\n        if (f[x] == 0) {  // daca culoarea x e intalnita prima data\n            nrculori++;   // cresc numarul de culori\n        }\n        f[x]++;\n        if (f[x] &gt; fmax) {\n            fmax = f[x];\n        }\n    }\n    fout &lt;&lt; nrculori &lt;&lt; '\\n';\n    for (int i = 1; i &lt;= 10; i++) {\n        if (f[i] == fmax) {\n            fout &lt;&lt; i &lt;&lt; \" \";\n        }\n    }\n    fout &lt;&lt; '\\n';\n    /// cer 3\n    for (int i = 1; i &lt;= n; i++) {\n        if (v[i] == v[i - 1]) {\n            st[i] = st[i - 1] + 1;\n        } else {\n            st[i] = 1;\n        }\n        mst[i] = max(mst[i - 1], st[i]);\n    }\n\n    for (int i = n; i &gt;= 1; i--) {\n        if (v[i] == v[i + 1]) {\n            dr[i] = dr[i + 1] + 1;\n        } else {\n            dr[i] = 1;\n        }\n        mdr[i] = max(mdr[i + 1], dr[i]);\n    }\n    // lung maxima\n    int p[200002], j = 0;  // in p retinem pozitiile de unde pot scoate cuburi\n                           // pt a obtine lmax\n    int lmax = -1, l;\n    for (int i = 1; i &lt;= n; i++) {\n        if (v[i - 1] == v[i + 1]) {  // daca prin taiere alipesc doua siruri cu\n                                     // aceleasi elemente\n            l = st[i - 1] + dr[i + 1];  // lungimea rezultata e nr de elem egale\n                                        // de la stanga, resp de la dr\n        } else {\n            l = 0;\n        }\n        l = max(l, max(mst[i - 1], mdr[i + 1]));\n        if (l &gt; lmax) {  // daca am obtinut o lungime mai mare , memorez poz\n                         // elem de taiat, prima in vect p\n            lmax = l;\n            j = 0;\n            p[j++] = i;\n        } else {\n            if (l == lmax) {  // daca am obtinut aceeasi lungime , adaugam la\n                              // lungimea existenta\n                p[j++] = i;\n            }\n        }\n    }\n\n    for (int i = 0; i &lt; j; i++) {\n        fout &lt;&lt; p[i] &lt;&lt; \" \";\n    }\n    return 0;\n}\n</code></pre>","tags":["OJI","clasa VI"]},{"location":"olimpiada/solutii/OJI/2002/VI-valoripanta/","title":"Solu\u021bia problemei valori-panta (OJI 2002, clasa a VI-a)","text":"<p>Pentru fiecare num\u0103r, putem afla parcurg\u00e2nd cifrele lui dac\u0103 toate sunt a\u0219ezate \u00een ordine cresc\u0103toare sau descresc\u0103toare, iar mai apoi dup\u0103 ce facem aceast\u0103 parcurgere, tot ce trebuie s\u0103 facem este s\u0103 afl\u0103m valoarea maxim\u0103 \u0219i minim\u0103 care sunt valori-pant\u0103.</p> <p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;fstream&gt;\n#include &lt;iostream&gt;\n\nusing namespace std;\n\nifstream fin(\"valori-panta.in\");\nofstream fout(\"valori-panta.out\");\n\nint v[200001];\n\nint main() {\n    int n, cnt = 0, mx = -1;\n    long long mn = 100000000;\n    fin &gt;&gt; n;\n    for (int i = 1; i &lt;= n; i++) {\n        fin &gt;&gt; v[i];\n        int a = 0, b = 0, aux = v[i], t = aux % 10;\n        aux /= 10;\n        while (aux &gt; 0) {\n            int cif = aux % 10;\n            if (cif &gt; t) {\n                a = 1;\n            } else {\n                if (cif &lt; t) {\n                    b = 1;\n                }\n            }\n            aux /= 10;\n            t = cif;\n        }\n        if (a == 0 || b == 0) {\n            cnt++;\n            if (v[i] &gt; mx) {\n                mx = v[i];\n            }\n            if (v[i] &lt; mn) {\n                mn = v[i];\n            }\n        }\n    }\n\n    if (cnt != 0) {\n        fout &lt;&lt; cnt &lt;&lt; \"\\n\" &lt;&lt; mx &lt;&lt; \" \";\n\n        for (int i = 1; i &lt;= n; i++) {\n            if (v[i] == mx) {\n                fout &lt;&lt; i &lt;&lt; \" \";\n            }\n        }\n        fout &lt;&lt; \"\\n\" &lt;&lt; mn &lt;&lt; \" \";\n        for (int i = 1; i &lt;= n; i++) {\n            if (v[i] == mn) {\n                fout &lt;&lt; i &lt;&lt; \" \";\n            }\n        }\n    }\n\n    else {\n        fout &lt;&lt; \"0\\n\";\n        fout &lt;&lt; \"NU EXISTA\";\n    }\n\n    return 0;\n}\n</code></pre>","tags":["OJI","clasa VI"]},{"location":"olimpiada/solutii/OJI/2002/VII-joc/","title":"Solu\u021bia problemei joc (OJI 2002, clasa a VII-a)","text":"<p>Tot ce trebuie s\u0103 facem \u00een aceast\u0103 problem\u0103 este s\u0103 simul\u0103m mut\u0103rile f\u0103cute de c\u0103tre cei doi juc\u0103tori. Vom verifica pe r\u00e2nd momentele c\u00e2nd suma dep\u0103\u0219e\u0219te suma precedent\u0103 \u0219i vom aduna aceste sume la r\u0103spuns.</p> <p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n\nint main() {\n    ifstream cin(\"joc.in\");\n    ofstream cout(\"joc.out\");\n\n    int n;\n    cin &gt;&gt; n;\n\n    long long sm = 0;\n    long long ans = -1;\n    for (int i = 1; i &lt;= n; i++) {\n        long long x;\n        cin &gt;&gt; x;\n        if (x &gt; sm + 1) {\n            if (ans == -1) {\n                ans = sm;\n            }\n        } else {\n            sm += x;\n        }\n    }\n\n    if (ans == -1) {\n        ans = sm;\n    }\n\n    cout &lt;&lt; sm;\n    return 0;\n}\n</code></pre>","tags":["OJI","clasa VII"]},{"location":"olimpiada/solutii/OJI/2002/VII-panglica/","title":"Solu\u021bia problemei panglica (OJI 2002, clasa a VII-a)","text":"<p>Pentru a afla lungimea maxim\u0103 a unei benzi pe care o putem ob\u021bine, vom avea nevoie s\u0103 \u0219tim pentru fiecare culoare prima \u0219i ultima pozitie a acesteia \u00een \u0219irul dat. Apoi, vom afla culoarea care are cea mai mare diferen\u021b\u0103 \u00eentre aceste pozi\u021bii, precum \u0219i pozi\u021biile ei de \u00eenceput \u0219i final, folosind precalcularea anterioar\u0103.</p> <p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n\nifstream fin(\"panglica.in\");\nofstream fout(\"panglica.out\");\n\nint v[10005];\nint ppoz[202], upoz[202];\nint lpf[202];\n\nint main() {\n    int n, c;\n    fin &gt;&gt; n &gt;&gt; c;\n    for (int i = 1; i &lt;= n; ++i) {\n        fin &gt;&gt; v[i];\n        if (ppoz[v[i]] == 0) {\n            ppoz[v[i]] = i;\n        }\n        upoz[v[i]] = i;\n    }\n    int lmax = 0;\n    for (int i = 1; i &lt;= c; ++i) {\n        lpf[i] = upoz[i] - ppoz[i] + 1;\n        if (lpf[i] &gt; lmax) {\n            lmax = lpf[i];\n        }\n    }\n    int cf = 0;\n    int rs = 0, rf = 0;\n    for (int i = 1; i &lt;= n; ++i) {\n        if (lpf[v[i]] == lmax) {\n            cf = v[i];\n            rs = ppoz[v[i]] - 1;\n            rf = n - upoz[v[i]];\n            break;\n        }\n    }\n    fout &lt;&lt; lmax &lt;&lt; '\\n' &lt;&lt; cf &lt;&lt; '\\n' &lt;&lt; rs &lt;&lt; '\\n' &lt;&lt; rf &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["OJI","clasa VII"]},{"location":"olimpiada/solutii/OJI/2002/VIII-anagrame/","title":"Solu\u021bia problemei anagrame (OJI 2002, clasa a VIII-a)","text":"<p>Aceast\u0103 problem\u0103 reprezint\u0103 un exerci\u021biu de generare a tuturor permut\u0103rilor unui \u0219ir de caractere care poate avea litere care se repet\u0103. Cea mai simpl\u0103 metod\u0103 const\u0103 \u00een aplicarea func\u021biei next_permutation, urmat\u0103 de afi\u0219area caracterelor \u00een sine.</p> <p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n\nint main() {\n    ifstream cin(\"anagrame.in\");\n    ofstream cout(\"anagrame.out\");\n\n    string s;\n    cin &gt;&gt; s;\n\n    sort(s.begin(), s.end());\n\n    do {\n        cout &lt;&lt; s &lt;&lt; '\\n';\n    } while (next_permutation(s.begin(), s.end()));\n    return 0;\n}\n</code></pre>","tags":["OJI","clasa VIII"]},{"location":"olimpiada/solutii/OJI/2002/VIII-sir/","title":"Solu\u021bia problemei sir (OJI 2002, clasa a VIII-a)","text":"<p>Dac\u0103 observ\u0103m cum se schimb\u0103 \u0219irul de caractere, se poate vedea c\u0103 dac\u0103 avem \u0219irul dup\u0103 \\(i\\) zile, \u0219irul dup\u0103 \\(i+1\\) zile va con\u021bine grupe care sunt formate din dou\u0103 valori: dimensiunea unei grupe de cifre consecutive, respectiv cifra \u00een sine.</p> <p>De exemplu, dup\u0103 ziua 4, \u0219irul este 1211. Avem o grup\u0103 de lungime 1 cu 1, lungime 1 cu 2 \u0219i lungime 2 cu 1. De aceea, urm\u0103torul \u0219ir va fi 111221.</p> <p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n\nifstream in(\"sir.in\");\nofstream out(\"sir.out\");\n\nint main() {\n    int n;\n    in &gt;&gt; n;\n    string s = \"1\";\n    while (--n) {\n        int f = 1;\n        char v = s[0];\n        string newS = \"\";\n        for (int i = 1; i &lt; (int)s.size(); i++) {\n            if (s[i] == s[i - 1]) {\n                f++;\n            } else {\n                newS += to_string(f);\n                newS += v;\n                f = 1;\n                v = s[i];\n            }\n        }\n        if (f) {\n            newS += to_string(f), newS += v;\n        }\n        s = newS;\n    }\n    out &lt;&lt; s;\n    return 0;\n}\n</code></pre>","tags":["OJI","clasa VIII"]},{"location":"olimpiada/solutii/OJI/2003/X-spirala/","title":"Solu\u021bia problemei Spirala (OJI 2003, clasa a X-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["OJI","clasa X"]},{"location":"olimpiada/solutii/OJI/2003/X-spirala/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["OJI","clasa X"]},{"location":"olimpiada/solutii/OJI/2003/X-taxe/","title":"Solu\u021bia problemei Taxe (OJI 2003, clasa a X-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["OJI","clasa X"]},{"location":"olimpiada/solutii/OJI/2003/X-taxe/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["OJI","clasa X"]},{"location":"olimpiada/solutii/OJI/2003/XI-XII-compus/","title":"Solu\u021bia problemei compus (OJI 2003, clasele XI-XII)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["OJI","clasa XI-XII"]},{"location":"olimpiada/solutii/OJI/2003/XI-XII-compus/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["OJI","clasa XI-XII"]},{"location":"olimpiada/solutii/OJI/2003/XI-XII-zmeu/","title":"Solu\u021bia problemei zmeu (OJI 2003, clasele XI-XII)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["OJI","clasa XI-XII"]},{"location":"olimpiada/solutii/OJI/2003/XI-XII-zmeu/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["OJI","clasa XI-XII"]},{"location":"olimpiada/solutii/OJI/2004/IX-reactivi/","title":"Solu\u021bia problemei reactivi (OJI 2004, clasa a IX-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["OJI","clasa IX"]},{"location":"olimpiada/solutii/OJI/2004/IX-reactivi/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["OJI","clasa IX"]},{"location":"olimpiada/solutii/OJI/2004/V-cifre/","title":"Solu\u021bia problemei cifre (OJI 2004, clasa a V-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["OJI","clasa V"]},{"location":"olimpiada/solutii/OJI/2004/V-cifre/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["OJI","clasa V"]},{"location":"olimpiada/solutii/OJI/2004/V-concurs/","title":"Solu\u021bia problemei concurs (OJI 2004, clasa a V-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["OJI","clasa V"]},{"location":"olimpiada/solutii/OJI/2004/V-concurs/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["OJI","clasa V"]},{"location":"olimpiada/solutii/OJI/2004/VI-control/","title":"Solu\u021bia problemei control (OJI 2004, clasa a VI-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["OJI","clasa VI"]},{"location":"olimpiada/solutii/OJI/2004/VI-control/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["OJI","clasa VI"]},{"location":"olimpiada/solutii/OJI/2004/VI-vanatoare/","title":"Solu\u021bia problemei vanatoare (OJI 2004, clasa a VI-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["OJI","clasa VI"]},{"location":"olimpiada/solutii/OJI/2004/VI-vanatoare/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["OJI","clasa VI"]},{"location":"olimpiada/solutii/OJI/2004/VII-nutesuparafrate/","title":"Solu\u021bia problemei NU te sup\u0103ra, FRATE! (OJI 2004, clasa a VII-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["OJI","clasa VII"]},{"location":"olimpiada/solutii/OJI/2004/VII-nutesuparafrate/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["OJI","clasa VII"]},{"location":"olimpiada/solutii/OJI/2004/VII-siruri/","title":"Solu\u021bia problemei siruri (OJI 2004, clasa a VII-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["OJI","clasa VII"]},{"location":"olimpiada/solutii/OJI/2004/VII-siruri/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["OJI","clasa VII"]},{"location":"olimpiada/solutii/OJI/2004/VIII-culmi/","title":"Solu\u021bia problemei culmi (OJI 2004, clasa a VIII-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["OJI","clasa VIII"]},{"location":"olimpiada/solutii/OJI/2004/VIII-culmi/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["OJI","clasa VIII"]},{"location":"olimpiada/solutii/OJI/2004/VIII-ron/","title":"Solu\u021bia problemei ron (OJI 2004, clasa a VIII-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["OJI","clasa VIII"]},{"location":"olimpiada/solutii/OJI/2004/VIII-ron/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["OJI","clasa VIII"]},{"location":"olimpiada/solutii/OJI/2004/X-perle/","title":"Solu\u021bia problemei perle (OJI 2004, clasa a X-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["OJI","clasa X"]},{"location":"olimpiada/solutii/OJI/2004/X-perle/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["OJI","clasa X"]},{"location":"olimpiada/solutii/OJI/2004/X-rj/","title":"Solu\u021bia problemei rj (OJI 2004, clasa a X-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["OJI","clasa X"]},{"location":"olimpiada/solutii/OJI/2004/X-rj/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["OJI","clasa X"]},{"location":"olimpiada/solutii/OJI/2004/XI-XII-lanterna/","title":"Solu\u021bia problemei lanterna (OJI 2004, clasele XI-XII)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["OJI","clasa XI-XII"]},{"location":"olimpiada/solutii/OJI/2004/XI-XII-lanterna/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["OJI","clasa XI-XII"]},{"location":"olimpiada/solutii/OJI/2004/XI-XII-mosia/","title":"Solu\u021bia problemei mosia (OJI 2004, clasele XI-XII)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["OJI","clasa XI-XII"]},{"location":"olimpiada/solutii/OJI/2004/XI-XII-mosia/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["OJI","clasa XI-XII"]},{"location":"olimpiada/solutii/OJI/2005/IX-maxd/","title":"Solu\u021bia problemei maxd (OJI 2005, clasa a IX-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["OJI","clasa IX"]},{"location":"olimpiada/solutii/OJI/2005/IX-maxd/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["OJI","clasa IX"]},{"location":"olimpiada/solutii/OJI/2005/IX-numere/","title":"Solu\u021bia problemei numere (OJI 2005, clasa a IX-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["OJI","clasa IX"]},{"location":"olimpiada/solutii/OJI/2005/IX-numere/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["OJI","clasa IX"]},{"location":"olimpiada/solutii/OJI/2005/VI-numere/","title":"Solu\u021bia problemei numere (OJI 2005, clasa a VI-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["OJI","clasa VI"]},{"location":"olimpiada/solutii/OJI/2005/VI-numere/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["OJI","clasa VI"]},{"location":"olimpiada/solutii/OJI/2005/VI-sir/","title":"Solu\u021bia problemei sir (OJI 2005, clasa a VI-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["OJI","clasa VI"]},{"location":"olimpiada/solutii/OJI/2005/VI-sir/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["OJI","clasa VI"]},{"location":"olimpiada/solutii/OJI/2005/VIII-muzica/","title":"Solu\u021bia problemei muzica (OJI 2005, clasa a VIII-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["OJI","clasa VIII"]},{"location":"olimpiada/solutii/OJI/2005/VIII-muzica/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["OJI","clasa VIII"]},{"location":"olimpiada/solutii/OJI/2005/VIII-volei/","title":"Solu\u021bia problemei volei (OJI 2005, clasa a VIII-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["OJI","clasa VIII"]},{"location":"olimpiada/solutii/OJI/2005/VIII-volei/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["OJI","clasa VIII"]},{"location":"olimpiada/solutii/OJI/2005/X-lacusta/","title":"Solu\u021bia problemei L\u0103custa (OJI 2005, clasa a X-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["OJI","clasa X"]},{"location":"olimpiada/solutii/OJI/2005/X-lacusta/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["OJI","clasa X"]},{"location":"olimpiada/solutii/OJI/2005/X-scara/","title":"Solu\u021bia problemei Scara (OJI 2005, clasa a X-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["OJI","clasa X"]},{"location":"olimpiada/solutii/OJI/2005/X-scara/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["OJI","clasa X"]},{"location":"olimpiada/solutii/OJI/2005/XI-XII-lant/","title":"Solu\u021bia problemei lant (OJI 2005, clasele XI-XII)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["OJI","clasa XI-XII"]},{"location":"olimpiada/solutii/OJI/2005/XI-XII-lant/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["OJI","clasa XI-XII"]},{"location":"olimpiada/solutii/OJI/2005/XI-XII-scara/","title":"Solu\u021bia problemei scara (OJI 2005, clasele XI-XII)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["OJI","clasa XI-XII"]},{"location":"olimpiada/solutii/OJI/2005/XI-XII-scara/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["OJI","clasa XI-XII"]},{"location":"olimpiada/solutii/OJI/2006/IX-flori/","title":"Solu\u021bia problemei flori (OJI 2006, clasa a IX-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["OJI","clasa IX"]},{"location":"olimpiada/solutii/OJI/2006/IX-flori/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim. <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre></p>","tags":["OJI","clasa IX"]},{"location":"olimpiada/solutii/OJI/2006/IX-pluton/","title":"Solu\u021bia problemei pluton (OJI 2006, clasa a IX-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["OJI","clasa IX"]},{"location":"olimpiada/solutii/OJI/2006/IX-pluton/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["OJI","clasa IX"]},{"location":"olimpiada/solutii/OJI/2006/V-case/","title":"Solu\u021bia problemei case (OJI 2006, clasa a V-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["OJI","clasa V"]},{"location":"olimpiada/solutii/OJI/2006/V-case/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["OJI","clasa V"]},{"location":"olimpiada/solutii/OJI/2006/V-vraji/","title":"Solu\u021bia problemei vraji (OJI 2006, clasa a V-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["OJI","clasa V"]},{"location":"olimpiada/solutii/OJI/2006/V-vraji/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["OJI","clasa V"]},{"location":"olimpiada/solutii/OJI/2006/VI-cifre/","title":"Solu\u021bia problemei cifre (OJI 2006, clasa a VI-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["OJI","clasa VI"]},{"location":"olimpiada/solutii/OJI/2006/VI-cifre/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["OJI","clasa VI"]},{"location":"olimpiada/solutii/OJI/2006/VI-piramida/","title":"Solu\u021bia problemei piramida (OJI 2006, clasa a VI-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["OJI","clasa VI"]},{"location":"olimpiada/solutii/OJI/2006/VI-piramida/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["OJI","clasa VI"]},{"location":"olimpiada/solutii/OJI/2006/VII-grupe/","title":"Solu\u021bia problemei grupe (OJI 2006, clasa a VII-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["OJI","clasa VII"]},{"location":"olimpiada/solutii/OJI/2006/VII-grupe/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["OJI","clasa VII"]},{"location":"olimpiada/solutii/OJI/2006/VII-harry/","title":"Solu\u021bia problemei harry (OJI 2006, clasa a VII-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["OJI","clasa VII"]},{"location":"olimpiada/solutii/OJI/2006/VII-harry/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["OJI","clasa VII"]},{"location":"olimpiada/solutii/OJI/2006/VIII-elfi/","title":"Solu\u021bia problemei elfi (OJI 2006, clasa a VIII-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["OJI","clasa VIII"]},{"location":"olimpiada/solutii/OJI/2006/VIII-elfi/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["OJI","clasa VIII"]},{"location":"olimpiada/solutii/OJI/2006/VIII-mare/","title":"Solu\u021bia problemei mare (OJI 2006, clasa a VIII-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["OJI","clasa VIII"]},{"location":"olimpiada/solutii/OJI/2006/VIII-mare/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["OJI","clasa VIII"]},{"location":"olimpiada/solutii/OJI/2006/X-ecuatii/","title":"Solu\u021bia problemei ecuatii (OJI 2006, clasa a X-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["OJI","clasa X"]},{"location":"olimpiada/solutii/OJI/2006/X-ecuatii/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["OJI","clasa X"]},{"location":"olimpiada/solutii/OJI/2006/X-sudest/","title":"Solu\u021bia problemei sudest (OJI 2006, clasa a X-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["OJI","clasa X"]},{"location":"olimpiada/solutii/OJI/2006/X-sudest/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["OJI","clasa X"]},{"location":"olimpiada/solutii/OJI/2006/XI-XII-graf/","title":"Solu\u021bia problemei graf (OJI 2006, clasele XI-XII)","text":"<p>Dac\u0103 definim distan\u021ba \u00eentre dou\u0103 v\u00e2rfuri ale unui graf neorientat ca fiind lungimea celui mai scurt lan\u021b dintre care are drept capete v\u00e2rfurile, atunci putem s\u0103 observ\u0103m c\u0103 un v\u00e2rf oarecare \\(Z\\) se afl\u0103 pe un lan\u021b de lungime minim\u0103 dintre \\(X\\) \u0219i \\(Y\\) dac\u0103 \u0219i numai dac\u0103 \\(d(X,Z) + d(Z,Y) = d(X,Y)\\), pentru cazul \u00een care consider\u0103m lungimea lan\u021bului ca fiind num\u0103rul muchiilor, \u0219i \\(d(X,Z) + d(Z,Y) = d(X,Y) + 1\\), pentru cazul \u00een care consider\u0103m lungimea ca fiind num\u0103rul v\u00e2rfurilor.</p> <p>Stabilim, prin c\u00e2te o parcurgere \u00een l\u0103\u021bime, distan\u021bele tuturor v\u00e2rfurilor fa\u021b\u0103 de \\(X\\) \u0219i respectiv \\(Y\\) (capetele lan\u021bului, citite din fi\u0219ier). Vedem care dintre v\u00e2rfurile ce apar\u021bin cel pu\u021bin unui lan\u021b de lungime minim\u0103 \u00eentre \\(X\\) \u0219i \\(Y\\) au proprietatea c\u0103 sunt singurele aflate la o anumit\u0103 distan\u021b\u0103 de \\(X\\). Acestea sunt v\u00e2rfurile care apar\u021bin tuturor lan\u021burilor de lungime minim\u0103 dintre \\(X\\) \u0219i \\(Y\\). Algoritmul are complexitate \\(\\mathcal{O}(n + m)\\).</p> <p>Facem o parcurgere \u00een l\u0103\u021bime din \\(X\\) \u0219i o parcurgere \u00een l\u0103\u021bime pornind din \\(Y\\), \u00een urma c\u0103rora determin\u0103m, pentru fiecare v\u00e2rf \\(z\\), distan\u021bele \\(d(X,z)\\) \u0219i respectiv \\(d(Y,z)\\), precum \u0219i num\u0103rul de drumuri optime dintre \\(X\\) \u0219i \\(z\\), notate \\(nr(X,z)\\) \u0219i \\(nr(Y,z)\\).</p> <p>Un v\u00e2rf \\(z\\) are proprietatea de a apar\u021bine tuturor drumurilor optime dintre \\(X\\) \u0219i \\(Y\\) dac\u0103 \u0219i numai dac\u0103 \\(d(X,z) + d(Y,z) = d(X,Y)\\), iar \\(nr(X,z) \\cdot nr(Y,z) = nr(X,Y)\\).</p> <p>\u00cen final, num\u0103r\u0103m c\u00e2te noduri sunt singurele noduri de pe lan\u021burile optime aflate la distan\u021ba \\(d\\), unde \\(d\\) este o valoare \u00eentre 0 \u0219i \\(d(X, Y)\\).</p> <p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;fstream&gt;\n#include &lt;queue&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\nconstexpr int MAXN = 7500;\n\nvector&lt;vector&lt;int&gt;&gt; graph(MAXN + 1);\nvector&lt;int&gt; ans;\n\nvoid bfs(int startNode, vector&lt;int&gt;&amp; dist) {\n    queue&lt;int&gt; q;\n    q.push(startNode);\n    dist[startNode] = 0;\n\n    while (!q.empty()) {\n        int node = q.front();\n        q.pop();\n\n        for (auto neighbor : graph[node]) {\n            if (dist[neighbor] == -1) {\n                dist[neighbor] = dist[node] + 1;\n                q.push(neighbor);\n            }\n        }\n    }\n}\n\nvector&lt;int&gt; distX, distY, solFreq;\n\nint main() {\n    distX.reserve(MAXN + 1);\n    distY.reserve(MAXN + 1);\n    solFreq.reserve(MAXN + 1);\n\n    ifstream fin(\"graf.in\");\n    ofstream fout(\"graf.out\");\n\n    int n, m, x, y;\n    fin &gt;&gt; n &gt;&gt; m &gt;&gt; x &gt;&gt; y;\n\n    while (m--) {\n        int a, b;\n        fin &gt;&gt; a &gt;&gt; b;\n        graph[a].push_back(b);\n        graph[b].push_back(a);\n    }\n\n    distX.resize(n + 1, -1);\n    distY.resize(n + 1, -1);\n    solFreq.resize(n + 1, 0);\n\n    bfs(x, distX);\n    bfs(y, distY);\n\n    int totalDist = distX[y];\n    // Lungimea total\u0103 a drumului va fi egal\u0103 cu distX[y].\n    for (int i = 1; i &lt;= n; i++) {\n        if (distX[i] == -1 || distY[i] == -1) {\n            continue;\n        }\n\n        if (distX[i] + distY[i] == totalDist) {\n            solFreq[distX[i]]++;\n        }\n    }\n\n    for (int i = 1; i &lt;= n; i++) {\n        if (distX[i] == -1 || distY[i] == -1) {\n            continue;\n        }\n\n        if (distX[i] + distY[i] == totalDist &amp;&amp; solFreq[distX[i]] == 1) {\n            ans.push_back(i);\n        }\n    }\n\n    fout &lt;&lt; ans.size() &lt;&lt; '\\n';\n    for (const auto&amp; node : ans) {\n        fout &lt;&lt; node &lt;&lt; ' ';\n    }\n\n    return 0;\n}\n</code></pre>","tags":["OJI","clasa XI-XII"]},{"location":"olimpiada/solutii/OJI/2006/XI-XII-secretulcifrului/","title":"Solu\u021bia problemei Secretul cifrului (OJI 2006, clasele XI-XII)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["OJI","clasa XI-XII"]},{"location":"olimpiada/solutii/OJI/2006/XI-XII-secretulcifrului/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["OJI","clasa XI-XII"]},{"location":"olimpiada/solutii/OJI/2007/IX-cartele/","title":"Solu\u021bia problemei cartele (OJI 2007, clasa a IX-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["OJI","clasa IX"]},{"location":"olimpiada/solutii/OJI/2007/IX-cartele/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["OJI","clasa IX"]},{"location":"olimpiada/solutii/OJI/2007/IX-paritate/","title":"Solu\u021bia problemei paritate (OJI 2007, clasa a IX-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["OJI","clasa IX"]},{"location":"olimpiada/solutii/OJI/2007/IX-paritate/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["OJI","clasa IX"]},{"location":"olimpiada/solutii/OJI/2007/V-telecabina/","title":"Solu\u021bia problemei telecabina (OJI 2007, clasa a V-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["OJI","clasa V"]},{"location":"olimpiada/solutii/OJI/2007/V-telecabina/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["OJI","clasa V"]},{"location":"olimpiada/solutii/OJI/2007/VI-cod/","title":"Solu\u021bia problemei cod (OJI 2007, clasa a VI-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["OJI","clasa VI"]},{"location":"olimpiada/solutii/OJI/2007/VI-cod/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["OJI","clasa VI"]},{"location":"olimpiada/solutii/OJI/2007/VI-furnica/","title":"Solu\u021bia problemei furnica (OJI 2007, clasa a VI-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["OJI","clasa VI"]},{"location":"olimpiada/solutii/OJI/2007/VI-furnica/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["OJI","clasa VI"]},{"location":"olimpiada/solutii/OJI/2007/VII-ceas/","title":"Solu\u021bia problemei ceas (OJI 2007, clasa a VII-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["OJI","clasa VII"]},{"location":"olimpiada/solutii/OJI/2007/VII-ceas/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["OJI","clasa VII"]},{"location":"olimpiada/solutii/OJI/2007/VII-excel/","title":"Solu\u021bia problemei excel (OJI 2007, clasa a VII-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["OJI","clasa VII"]},{"location":"olimpiada/solutii/OJI/2007/VII-excel/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["OJI","clasa VII"]},{"location":"olimpiada/solutii/OJI/2007/VIII-afise/","title":"Solu\u021bia problemei afise (OJI 2007, clasa a VIII-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["OJI","clasa VIII"]},{"location":"olimpiada/solutii/OJI/2007/VIII-afise/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["OJI","clasa VIII"]},{"location":"olimpiada/solutii/OJI/2007/VIII-dreptc/","title":"Solu\u021bia problemei dreptc (OJI 2007, clasa a VIII-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["OJI","clasa VIII"]},{"location":"olimpiada/solutii/OJI/2007/VIII-dreptc/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["OJI","clasa VIII"]},{"location":"olimpiada/solutii/OJI/2007/X-dir/","title":"Solu\u021bia problemei Dir (OJI 2007, clasa a X-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["OJI","clasa X"]},{"location":"olimpiada/solutii/OJI/2007/X-dir/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["OJI","clasa X"]},{"location":"olimpiada/solutii/OJI/2007/XI-XII-cezar/","title":"Solu\u021bia problemei cezar (OJI 2007, clasele XI-XII)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["OJI","clasa XI-XII"]},{"location":"olimpiada/solutii/OJI/2007/XI-XII-cezar/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["OJI","clasa XI-XII"]},{"location":"olimpiada/solutii/OJI/2007/XI-XII-numere/","title":"Solu\u021bia problemei numere (OJI 2007, clasele XI-XII)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["OJI","clasa XI-XII"]},{"location":"olimpiada/solutii/OJI/2007/XI-XII-numere/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["OJI","clasa XI-XII"]},{"location":"olimpiada/solutii/OJI/2008/IX-concurs/","title":"Solu\u021bia problemei concurs (OJI 2008, clasa a IX-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["OJI","clasa IX"]},{"location":"olimpiada/solutii/OJI/2008/IX-concurs/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["OJI","clasa IX"]},{"location":"olimpiada/solutii/OJI/2008/IX-pluricex/","title":"Solu\u021bia problemei pluricex (OJI 2008, clasa a IX-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["OJI","clasa IX"]},{"location":"olimpiada/solutii/OJI/2008/IX-pluricex/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["OJI","clasa IX"]},{"location":"olimpiada/solutii/OJI/2008/X-colaj/","title":"Solu\u021bia problemei Colaj (OJI 2008, clasa a X-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["OJI","clasa X"]},{"location":"olimpiada/solutii/OJI/2008/X-colaj/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["OJI","clasa X"]},{"location":"olimpiada/solutii/OJI/2008/X-piata/","title":"Solu\u021bia problemei Pia\u021ba (OJI 2008, clasa a X-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["OJI","clasa X"]},{"location":"olimpiada/solutii/OJI/2008/X-piata/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["OJI","clasa X"]},{"location":"olimpiada/solutii/OJI/2008/XI-XII-iepuri/","title":"Solu\u021bia problemei iepuri (OJI 2008, clasele XI-XII)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["OJI","clasa XI-XII"]},{"location":"olimpiada/solutii/OJI/2008/XI-XII-iepuri/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["OJI","clasa XI-XII"]},{"location":"olimpiada/solutii/OJI/2008/XI-XII-numar/","title":"Solu\u021bia problemei numar (OJI 2008, clasele XI-XII)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["OJI","clasa XI-XII"]},{"location":"olimpiada/solutii/OJI/2008/XI-XII-numar/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["OJI","clasa XI-XII"]},{"location":"olimpiada/solutii/OJI/2009/IX-expresie/","title":"Solu\u021bia problemei expresie (OJI 2009, clasa a IX-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["OJI","clasa IX"]},{"location":"olimpiada/solutii/OJI/2009/IX-expresie/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["OJI","clasa IX"]},{"location":"olimpiada/solutii/OJI/2009/IX-placare/","title":"Solu\u021bia problemei placare (OJI 2009, clasa a IX-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["OJI","clasa IX"]},{"location":"olimpiada/solutii/OJI/2009/IX-placare/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["OJI","clasa IX"]},{"location":"olimpiada/solutii/OJI/2009/V-divizor/","title":"Solu\u021bia problemei divizor (OJI 2009, clasa a V-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["OJI","clasa V"]},{"location":"olimpiada/solutii/OJI/2009/V-divizor/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["OJI","clasa V"]},{"location":"olimpiada/solutii/OJI/2009/V-inimioare/","title":"Solu\u021bia problemei inimioare (OJI 2009, clasa a V-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["OJI","clasa V"]},{"location":"olimpiada/solutii/OJI/2009/V-inimioare/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["OJI","clasa V"]},{"location":"olimpiada/solutii/OJI/2009/VI-factori/","title":"Solu\u021bia problemei factori (OJI 2009, clasa a VI-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["OJI","clasa VI"]},{"location":"olimpiada/solutii/OJI/2009/VI-factori/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["OJI","clasa VI"]},{"location":"olimpiada/solutii/OJI/2009/VI-ruleta/","title":"Solu\u021bia problemei ruleta (OJI 2009, clasa a VI-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["OJI","clasa VI"]},{"location":"olimpiada/solutii/OJI/2009/VI-ruleta/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["OJI","clasa VI"]},{"location":"olimpiada/solutii/OJI/2009/VII-grad/","title":"Solu\u021bia problemei grad (OJI 2009, clasa a VII-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["OJI","clasa VII"]},{"location":"olimpiada/solutii/OJI/2009/VII-grad/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["OJI","clasa VII"]},{"location":"olimpiada/solutii/OJI/2009/VII-startrek/","title":"Solu\u021bia problemei startrek (OJI 2009, clasa a VII-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["OJI","clasa VII"]},{"location":"olimpiada/solutii/OJI/2009/VII-startrek/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["OJI","clasa VII"]},{"location":"olimpiada/solutii/OJI/2009/VIII-235/","title":"Solu\u021bia problemei 235 (OJI 2009, clasa a VIII-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["OJI","clasa VIII"]},{"location":"olimpiada/solutii/OJI/2009/VIII-235/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["OJI","clasa VIII"]},{"location":"olimpiada/solutii/OJI/2009/VIII-vecini/","title":"Solu\u021bia problemei vecini (OJI 2009, clasa a VIII-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["OJI","clasa VIII"]},{"location":"olimpiada/solutii/OJI/2009/VIII-vecini/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["OJI","clasa VIII"]},{"location":"olimpiada/solutii/OJI/2009/X-insule/","title":"Solu\u021bia problemei insule (OJI 2009, clasa a X-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["OJI","clasa X"]},{"location":"olimpiada/solutii/OJI/2009/X-insule/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["OJI","clasa X"]},{"location":"olimpiada/solutii/OJI/2009/X-reteta/","title":"Solu\u021bia problemei Re\u021bet\u0103 (OJI 2009, clasa a X-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["OJI","clasa X"]},{"location":"olimpiada/solutii/OJI/2009/X-reteta/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["OJI","clasa X"]},{"location":"olimpiada/solutii/OJI/2009/XI-XII-cerc/","title":"Solu\u021bia problemei cerc (OJI 2009, clasele XI-XII)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["OJI","clasa XI-XII"]},{"location":"olimpiada/solutii/OJI/2009/XI-XII-cerc/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["OJI","clasa XI-XII"]},{"location":"olimpiada/solutii/OJI/2009/XI-XII-projectmanagement/","title":"Solu\u021bia problemei Project Management (OJI 2009, clasele XI-XII)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["OJI","clasa XI-XII"]},{"location":"olimpiada/solutii/OJI/2009/XI-XII-projectmanagement/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["OJI","clasa XI-XII"]},{"location":"olimpiada/solutii/OJI/2010/IX-livada/","title":"Solu\u021bia problemei livada (OJI 2010, clasa a IX-a)","text":"<p>Evident, cele dou\u0103 cerin\u0163e se rezolv\u0103 \u00een paralel, pentru fiecare r\u00e2nd.</p> <p>Pentru rezolvarea primei cerin\u0163e am folosit un contor \\(rsm\\) \u015fi apoi, pentru fiecare r\u00e2nd, am verificat dac\u0103 el are soi majoritar sau nu folosind urm\u0103torul algoritm:</p> <ul> <li>consider\u0103m prima valoare de pe r\u00e2ndul respectiv ca fiind posibilul soi majoritar (variabila \\(sm\\)) \u015fi ini\u0163ializ\u0103m un contor \\(cnt\\) (care num\u0103r\u0103 de c\u00e2te ori se g\u0103se\u015fte posibilul soi majoritar de pe acel r\u00e2nd cu \\(1\\);</li> <li>parcurgem restul r\u00e2ndului \u015fi ori de c\u00e2te ori g\u0103sim un soi egal cu \\(sm\\) cre\u015ftem valoarea lui \\(cnt\\) cu \\(1\\) (cre\u015fte probabilitatea ca \\(sm\\) s\u0103 fie soi majoritar) \u015fi ori de c\u00e2te ori g\u0103sim un soi diferit sc\u0103dem valoarea lui \\(cnt\\) cu \\(1\\) (scade probabilitatea ca \\(sm\\) s\u0103 fie soi majoritar). Dac\u0103 la un moment dat \\(cnt\\) devine \\(0\\), atunci reini\u0163ializ\u0103m soiul majoritar cu soiul curent, iar \\(cnt\\) devine \\(1\\).</li> <li>dup\u0103 ce termin\u0103m de parcurs r\u00e2ndul curent verific\u0103m dac\u0103 valoarea lui cnt este \\(0\\) sau nu. \u00cen caz afirmativ \u00eenseamn\u0103 c\u0103 nu avem soi majoritar pe r\u00e2ndul respectiv. Altfel, dac\u0103 valoarea lui \\(cnt\\) este diferit\u0103 de \\(0\\), \u00eenseamn\u0103 c\u0103 \u00een \\(sm\\) avem cel mai bun candidat pentru soiul majoritar \u015fi verific\u0103m dac\u0103 el este \u00eentr-adev\u0103r soi majoritar, reparcurg\u00e2nd r\u00e2ndul respectiv. Acest lucru este obligatoriu, pentru c\u0103 \u00een cazul r\u00e2ndului \\(1,3,1,2,3,3,3\\) contorul \\(cnt\\) va fi \\(3\\), iar soiul majoritar este \u00eentr-adev\u0103r, soiul \\(3\\). \u00cen schimb, \u00een cazul r\u00e2ndului \\(1,2,1,2,3,3,3\\) contorul va fi tot \\(3\\), f\u0103r\u0103 ca soiul \\(3\\) s\u0103 fie majoritar!</li> <li>dac\u0103 r\u00e2ndul curent are soi majoritar, cre\u015ftem valoarea contorului \\(rsm\\) cu 1.</li> </ul> <p>Pentru rezolvarea celei de-a doua cerin\u0163e am folosit un contor \\(max\\) care va p\u0103stra maximul lungimilor celor mai lungi secven\u0163e ce au proprietatea cerut\u0103 pe fiecare r\u00e2nd. Algoritmul folosit este unul clasic, \u00een care se folosesc doi indec\u015fi (\\(j\\) \u015fi \\(k\\)) cu care se parcurge fiecare r\u00e2nd, element cu element. Dac\u0103 valoarea lui \\(v[k]\\) este egal\u0103 cu valoarea lui \\(v[j]\\), atunci se cre\u015fte valoarea lui \\(k\\). \u00cen momentul \u00een care se termin\u0103 o secven\u0163a format\u0103 din copaci de acela\u015fi soi \\((v[j] \\neq v[k])\\), se verific\u0103 dac\u0103 lungimea ultimei secven\u0163e este mai mare dec\u00e2t valoarea maxim\u0103 ob\u0163inut\u0103 p\u00e2n\u0103 \u00een acel moment (variabila rmax) sau nu.</p> <p>Fiecare dintre cele dou\u0103 cerin\u0163e a fost rezolvat\u0103 folosind algoritmi cu complexitatea \\(O(n)\\), deci complexitatea solu\u0163iei este \\(O(m \\cdot n)\\). Observa\u0163i c\u0103 aceast\u0103 comlexitate nu depinde de valoarea lui \\(p\\)!</p> <p>Exist\u0103 \u015fi alte posibilit\u0103\u0163i de rezolvare ale acestei probleme, care pot ob\u0163ine punctaje par\u0163iale sau chiar 100 de puncte.</p>","tags":["OJI","clasa IX"]},{"location":"olimpiada/solutii/OJI/2010/IX-livada/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;fstream&gt;\nusing namespace std;\nifstream f(\"livada.in\");\nofstream g(\"livada.out\");\nint n, m, p, l, lmax = 1, nr;\nint a[700002], fr[250002];\nint main() {\n    f &gt;&gt; n &gt;&gt; m &gt;&gt; p;\n    for (int i = 1; i &lt;= n; ++i) {\n        int l = 0;\n        int min1 = 1000000000;\n        for (int j = 1; j &lt;= m; ++j) {\n            f &gt;&gt; a[j];\n            min1 = min(min1, a[j]);\n            if (a[j] != a[j - 1]) {\n                if (l &gt; lmax) \n                    lmax = l;\n                l = 1;\n            } \n            else\n                ++l;\n        }\n        lmax = max(lmax, l);\n        for (int j = 1; j &lt;= m; ++j) {\n            fr[a[j] - min1]++;\n            if (fr[a[j] - min1] &gt;= m / 2 + 1) {\n                ++nr;\n                break;\n            }\n        }\n        for (int j = 1; j &lt;= m; ++j) \n            fr[a[j] - min1] = 0;\n    }\n    g &lt;&lt; nr &lt;&lt; '\\n' &lt;&lt; lmax &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["OJI","clasa IX"]},{"location":"olimpiada/solutii/OJI/2010/IX-numar/","title":"Solu\u021bia problemei numar (OJI 2010, clasa a IX-a)","text":"<p>Se ia initial</p> <ul> <li>\\(a\\) = numarul format din cifrele lui \\(q\\) din care se \u201cscoate\u201d punctual zecimal</li> <li>\\(b = 1\\) urmat de atatea cifre de \\(0\\) cate cifre are partea zecimala (fractionara).</li> </ul> <p>Evident, \\(a\\) si \\(b\\) trebuie implementate ca numere mari \u2013 fiecare cifra ca element al unui vector.</p> <p>Apoi simplificam fractia formata din \\(a\\) si \\(b\\). Matematic, simplificarea ar trebui facuta cu cmmmdc-ul dintre \\(a\\) si \\(b\\), dar nu are rost sa calculam acest numar deoarece \\(a\\) si \\(b\\) sunt numere mari si acest calcul s-ar face prin scaderi repetate sau implementarea impartirii pe numere mari, ceea ce e complicat si nu garanteaza incadrarea in timp.</p> <p>De fapt, cele doua numere \\(a\\) si \\(b\\) nu se pot simplifica decat cu o putere a lui \\(2\\) sau a lui \\(5\\), avand in vedere ca \\(b\\) este o putere a lui \\(10\\) \u2013 asa ca tot ce trebuie sa facem este sa implementam impartirea unui numar mare la un numar de o singura cifra.</p>","tags":["OJI","clasa IX"]},{"location":"olimpiada/solutii/OJI/2010/IX-numar/#punctaje-partiale","title":"Punctaje partiale","text":"<p>Pentru punctaje partiale, putem lucra cu variabile numerice:</p> <ul> <li>daca folosim tipuri pe 16 biti (integer in pascal) obtinem 10 puncte</li> <li>daca folosim tipuri pe 32 biti (longint in pascal respective long sau int in C/C++) obtinem 20 de puncte</li> <li>daca folosim tipuri pe 64 biti (int64 in pascal respective long long in C/C++) obtinem 35 de puncte</li> </ul>","tags":["OJI","clasa IX"]},{"location":"olimpiada/solutii/OJI/2010/IX-numar/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["OJI","clasa IX"]},{"location":"olimpiada/solutii/OJI/2010/V-sir/","title":"Solu\u021bia problemei sir (OJI 2010, clasa a V-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["OJI","clasa V"]},{"location":"olimpiada/solutii/OJI/2010/V-sir/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;fstream&gt;\n\nusing namespace std;\nifstream fin(\"sir.in\");\nofstream fout(\"sir.out\");\nlong long k, x, a, b, k2, i, sm, x2, pow = 1, cnt;\nint main() {\n    fin &gt;&gt; k &gt;&gt; x &gt;&gt; a &gt;&gt; b;\n    k2 = k;\n    for (i = 1; i &lt;= k; i++) {\n        sm = sm + k2 * i;\n        k2--;\n    }\n    fout &lt;&lt; sm % 10 &lt;&lt; '\\n';\n    x2 = x;\n    while (x2 &gt; 0) {\n        x2 = x2 / 10;\n        cnt++;\n        pow = pow * 10;\n    }\n    pow = pow / 10;\n    if (x / pow == cnt) {\n        for (i = 1; i &lt;= cnt + 1; i++) {\n            fout &lt;&lt; i;\n        }\n        fout &lt;&lt; endl;\n    } else {\n        fout &lt;&lt; (x % pow) * 10 + (x / pow) &lt;&lt; '\\n';\n    }\n    fout &lt;&lt; max(1LL * 0, b - a);\n    return 0;\n}\n</code></pre>","tags":["OJI","clasa V"]},{"location":"olimpiada/solutii/OJI/2010/V-tren/","title":"Solu\u021bia problemei tren (OJI 2010, clasa a V-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["OJI","clasa V"]},{"location":"olimpiada/solutii/OJI/2010/V-tren/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;fstream&gt;\nusing namespace std;\nifstream fi(\"tren.in\");\nofstream fo(\"tren.out\");\nint x, t, y, z, u, t1, l, h, m, s, i, j, vine, pleaca, g[1441], v[101], inc = 1441, sf;\nint main() {\n    fi &gt;&gt; t;\n    for (i = 1; i &lt;= t; i++) {\n        fi &gt;&gt; l &gt;&gt; h &gt;&gt; m &gt;&gt; s;\n        vine = h * 60 + m;\n        pleaca = vine + s;\n        if (i == 1) \n            inc = vine;\n        if (sf &lt; pleaca) \n            sf = pleaca;\n        if (l == 1) {\n            t1++;\n            for (j = vine; j &lt;= pleaca; j++) \n                g[j] = i;\n        } else\n            for (j = vine; j &lt;= pleaca; j++)\n                if (g[j] == 0) \n                    g[j] = i;\n        // trenul de pe linia 2 este vizibil numai daca nu avem tren pe linia 1\n    }\n    z = (t1 &gt; t - t1) ? t1 : t - t1;  // num\u0103rul maxim de trenuri de pe o linie\n    y = 0;\n    for (i = inc; i &lt;= sf; i++) {\n        v[g[i]] = 1;         // trenul care se afl\u0103 \u00een momentul i \u00een gar\u0103 este vizibil\n        if (g[i] == 0) u++;  // u=num\u0103rul de minute consecutive \u00een care\n        // ambele linii sunt libere\n        else {\n            if (u &gt; y) y = u;\n            u = 0;\n        }\n    }\n    x = 0;\n    for (i = 1; i &lt;= t; i++) \n        x = x + v[i];\n    fo &lt;&lt; z &lt;&lt; ' ' &lt;&lt; x &lt;&lt; ' ' &lt;&lt; y;\n    return 0;\n}\n</code></pre>","tags":["OJI","clasa V"]},{"location":"olimpiada/solutii/OJI/2010/VI-loto/","title":"Solu\u021bia problemei loto (OJI 2010, clasa a VI-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["OJI","clasa VI"]},{"location":"olimpiada/solutii/OJI/2010/VI-loto/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;algorithm&gt;\n#include &lt;fstream&gt;\nusing namespace std;\nifstream f(\"loto.in\");\nofstream g(\"loto.out\");\nlong int i, j, N, mx, mn, maxim, minim, x;\nint a[10001], b[7];\nint main() {\n    f &gt;&gt; N;\n    for (int i = 0; i &lt;= 10000; i++) \n        a[i] = 0;\n    for (int i = 1; i &lt;= N; i++) {\n        f &gt;&gt; x;\n        a[x] = 1;\n    }\n    maxim = 0;\n    minim = 10000;\n    mx = 0;\n    mn = 0;\n    for (int i = 1; i &lt;= 6; i++) {\n        f &gt;&gt; b[i];\n        a[b[i]] = 0;\n        if (b[i] &lt; minim) {\n            minim = b[i];\n            mn = i;\n        }\n        if (b[i] &gt; maxim) {\n            maxim = b[i];\n            mx = i;\n        }\n    }\n    int i = minim;\n    int j = minim;\n    do {\n        if (i &lt; 10000) i++;\n        if (j &gt; 1) j--;\n    } while (!(a[i] || a[j]));\n    if (a[i])\n        b[mn] = i;\n    else\n        b[mn] = j;\n    a[b[mn]] = 0;\n    i = maxim;\n    j = maxim;\n    do {\n        if (i &lt; 10000) i++;\n        if (j &gt; 1) j--;\n    } while (!(a[i] || a[j]));\n    if (a[i])\n        b[mx] = i;\n    else\n        b[mx] = j;\n    sort(b + 1, b + 7);\n\n    for (i = 1; i &lt;= 5; i++) \n        g &lt;&lt; b[i] &lt;&lt; ' ';\n    g &lt;&lt; b[6] &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["OJI","clasa VI"]},{"location":"olimpiada/solutii/OJI/2010/VI-submit/","title":"Solu\u021bia problemei submit (OJI 2010, clasa a VI-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["OJI","clasa VI"]},{"location":"olimpiada/solutii/OJI/2010/VI-submit/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;algorithm&gt;\n#include &lt;fstream&gt;\nusing namespace std;\nifstream f(\"submit.in\");\nofstream g(\"submit.out\");\n\nint n, pct[101], bonus, m, p, i, j, complet, crt, maxim;\nint main() {\n    f &gt;&gt; n;\n    for (i = 1; i &lt;= n; i++)\n        f &gt;&gt; pct[i];\n    f &gt;&gt; bonus;\n    f &gt;&gt; m;\n    maxim = 0;\n    for (j = 1; j &lt;= m; j++) {\n        complet = 1;\n        crt = 0;\n        for (i = 1; i &lt;= n; i++) {\n            f &gt;&gt; p;\n            if (p == 0)\n                complet = 0;\n            else\n                crt += pct[i];\n        }\n        if (complet) \n            crt += bonus;\n        crt -= 2 * (j - 1);\n        if (crt &gt; maxim) \n            maxim = crt;\n    }\n    g &lt;&lt; maxim;\n    return 0;\n}\n</code></pre>","tags":["OJI","clasa VI"]},{"location":"olimpiada/solutii/OJI/2010/VII-cuvinte/","title":"Solu\u021bia problemei cuvinte (OJI 2010, clasa a VII-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["OJI","clasa VII"]},{"location":"olimpiada/solutii/OJI/2010/VII-cuvinte/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n\nvector&lt;string&gt; words;\nvector&lt;int&gt; ordine;\n\nifstream fin(\"cuvinte.in\");\nofstream fout(\"cuvinte.out\");\n\nint main() {\n    int cnt, i, firstRemovePnt;\n    char ch;\n    string word;\n\n    word = \"\";\n    cnt = 1;\n    while (fin.get(ch)) {\n        if (ch != ' ' &amp;&amp; ch != '!') {\n            word += ch;\n        } else {\n            words.push_back(word);\n            ordine.push_back(cnt++);\n            word = \"\";\n        }\n    }\n\n    i = 1;\n    firstRemovePnt = -1;\n    while (i &lt; words.size()) {\n        cnt = 0;\n        string original = words[i - 1];\n        do {\n            words[i - 1] = words[i - 1].substr(1, words[i - 1].size()) + words[i - 1][0];\n            ++cnt;\n        } while (cnt &lt; words[i - 1].size() - 1 &amp;&amp; words[i - 1] != words[i]);\n\n        if (words[i - 1] == words[i]) {\n            words[i - 1] = original;\n\n            words.erase(words.begin() + i);\n            ordine.erase(ordine.begin() + i);\n            if (firstRemovePnt == -1) firstRemovePnt = i;\n            i--;\n        } else {\n            words[i - 1] = original;\n        }\n\n        ++i;\n    }\n\n    fout &lt;&lt; ++firstRemovePnt &lt;&lt; '\\n';\n    for (i = 0; i &lt; words.size(); i++) {\n        fout &lt;&lt; ordine[i] &lt;&lt; \" \";\n    }\n    return 0;\n}\n</code></pre>","tags":["OJI","clasa VII"]},{"location":"olimpiada/solutii/OJI/2010/VII-zar/","title":"Solu\u021bia problemei zar (OJI 2010, clasa a VII-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["OJI","clasa VII"]},{"location":"olimpiada/solutii/OJI/2010/VII-zar/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n\nifstream fin(\"zar.in\");\nofstream fout(\"zar.out\");\n\nconst int DIR = 4;\n\nint dlin[DIR] = {0, 1, 0, -1};\nint dcol[DIR] = {1, 0, -1, 0};\n\nint main() {\n    int n, k, dir, i, cnt;\n    int x, cx, y, cy, z, cz;\n\n    fin &gt;&gt; n &gt;&gt; k &gt;&gt; z &gt;&gt; y &gt;&gt; x;\n\n    cnt = 0;\n    while(cnt &lt; k){\n        for (dir = 0; dir &lt; DIR &amp;&amp; cnt &lt; k; dir++) {\n            for (i = 1; i &lt; n &amp;&amp; cnt &lt; k; i++) {\n                if (dir == 0) {\n                    // X devine Y\n                    // Y devine 7 - X (X original)\n                    // Z ramane Z\n\n                    cx = x;\n                    x = y;\n                    y = 7 - cx;\n                } else if (dir == 1) {\n                    // X ramane X\n                    // Z devine Y\n                    // Y devine 7 - Z (Z original)\n\n                    cz = z;\n                    z = y;\n                    y = 7 - cz;\n                } else if (dir == 2) {\n                    // Y devine X\n                    // X devine 7 - Y (Y original)\n                    // Z ramane Z\n\n                    cy = y;\n                    y = x;\n                    x = 7 - cy;\n                } else {\n                    // X ramane X\n                    // Y devine Z\n                    // Z devine 7 - Y (Y original)\n\n                    cy = y;\n                    y = z;\n                    z = 7 - cy;\n                }\n\n                cnt++;\n            }\n        }\n    }\n    fout &lt;&lt; z &lt;&lt; \" \" &lt;&lt; y &lt;&lt; \" \" &lt;&lt; x;\n    return 0;\n}\n</code></pre>","tags":["OJI","clasa VII"]},{"location":"olimpiada/solutii/OJI/2010/VIII-cladiri/","title":"Solu\u021bia problemei cladiri (OJI 2010, clasa a VIII-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["OJI","clasa VIII"]},{"location":"olimpiada/solutii/OJI/2010/VIII-cladiri/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n\nifstream fin(\"cladiri.in\");\nofstream fout(\"cladiri.out\");\n\nconst int MAXLEVEL = 1e4;\n\nint affectedOnLevel[MAXLEVEL + 1];\n\nint main() {\n    int longitude, lng, latitude, lat, intensity, grad, level, numAffected, maxAffectedLevel;\n\n    fin &gt;&gt; longitude &gt;&gt; latitude &gt;&gt; intensity;\n\n    numAffected = 0;\n    while(fin &gt;&gt; lng &gt;&gt; lat &gt;&gt; grad){\n        level = max(abs(longitude - lng), abs(latitude - lat)); // The distance till the center\n        if(grad + level &lt;= intensity){ // Is the building affected?\n            numAffected++;\n            affectedOnLevel[level]++; \n        }\n    }\n\n    maxAffectedLevel = 0;\n    for(level = 0; level &lt;= MAXLEVEL; level++){\n        if(affectedOnLevel[level] &gt; affectedOnLevel[maxAffectedLevel]){\n            maxAffectedLevel = level;\n        }\n    }\n\n    fout &lt;&lt; numAffected &lt;&lt; '\\n' &lt;&lt; affectedOnLevel[maxAffectedLevel] &lt;&lt; '\\n';\n\n    if(affectedOnLevel[maxAffectedLevel] != 0){\n        for(level = 0; level &lt;= MAXLEVEL; level++){\n            if(affectedOnLevel[level] == affectedOnLevel[maxAffectedLevel]){\n                fout &lt;&lt; level &lt;&lt; ' ';\n            }\n        }\n    }\n    return 0;\n}\n</code></pre>","tags":["OJI","clasa VIII"]},{"location":"olimpiada/solutii/OJI/2010/VIII-secvente/","title":"Solu\u021bia problemei secvente (OJI 2010, clasa a VIII-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["OJI","clasa VIII"]},{"location":"olimpiada/solutii/OJI/2010/VIII-secvente/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["OJI","clasa VIII"]},{"location":"olimpiada/solutii/OJI/2010/X-expozitie/","title":"Solu\u021bia problemei Expozitie (OJI 2010, clasa a X-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["OJI","clasa X"]},{"location":"olimpiada/solutii/OJI/2010/X-expozitie/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["OJI","clasa X"]},{"location":"olimpiada/solutii/OJI/2010/X-text/","title":"Solu\u021bia problemei Text (OJI 2010, clasa a X-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["OJI","clasa X"]},{"location":"olimpiada/solutii/OJI/2010/X-text/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["OJI","clasa X"]},{"location":"olimpiada/solutii/OJI/2010/XI-XII-immortal/","title":"Solu\u021bia problemei immortal (OJI 2010, clasele XI-XII)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["OJI","clasa XI-XII"]},{"location":"olimpiada/solutii/OJI/2010/XI-XII-immortal/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["OJI","clasa XI-XII"]},{"location":"olimpiada/solutii/OJI/2010/XI-XII-joc/","title":"Solu\u021bia problemei joc (OJI 2010, clasele XI-XII)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["OJI","clasa XI-XII"]},{"location":"olimpiada/solutii/OJI/2010/XI-XII-joc/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["OJI","clasa XI-XII"]},{"location":"olimpiada/solutii/OJI/2011/IX-cri/","title":"Solu\u021bia problemei cri (OJI 2011, clasa a IX-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["OJI","clasa IX"]},{"location":"olimpiada/solutii/OJI/2011/IX-cri/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["OJI","clasa IX"]},{"location":"olimpiada/solutii/OJI/2011/IX-vase/","title":"Solu\u021bia problemei vase (OJI 2011, clasa a IX-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["OJI","clasa IX"]},{"location":"olimpiada/solutii/OJI/2011/IX-vase/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["OJI","clasa IX"]},{"location":"olimpiada/solutii/OJI/2011/V-magic/","title":"Solu\u021bia problemei magic (OJI 2011, clasa a V-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["OJI","clasa V"]},{"location":"olimpiada/solutii/OJI/2011/V-magic/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["OJI","clasa V"]},{"location":"olimpiada/solutii/OJI/2011/V-numerus/","title":"Solu\u021bia problemei numerus (OJI 2011, clasa a V-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["OJI","clasa V"]},{"location":"olimpiada/solutii/OJI/2011/V-numerus/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["OJI","clasa V"]},{"location":"olimpiada/solutii/OJI/2011/VI-carte/","title":"Solu\u021bia problemei carte (OJI 2011, clasa a VI-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["OJI","clasa VI"]},{"location":"olimpiada/solutii/OJI/2011/VI-carte/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["OJI","clasa VI"]},{"location":"olimpiada/solutii/OJI/2011/VI-grad/","title":"Solu\u021bia problemei grad (OJI 2011, clasa a VI-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["OJI","clasa VI"]},{"location":"olimpiada/solutii/OJI/2011/VI-grad/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["OJI","clasa VI"]},{"location":"olimpiada/solutii/OJI/2011/VII-grupe/","title":"Solu\u021bia problemei grupe (OJI 2011, clasa a VII-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["OJI","clasa VII"]},{"location":"olimpiada/solutii/OJI/2011/VII-grupe/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["OJI","clasa VII"]},{"location":"olimpiada/solutii/OJI/2011/VII-litere/","title":"Solu\u021bia problemei litere (OJI 2011, clasa a VII-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["OJI","clasa VII"]},{"location":"olimpiada/solutii/OJI/2011/VII-litere/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["OJI","clasa VII"]},{"location":"olimpiada/solutii/OJI/2011/VIII-adunscad/","title":"Solu\u021bia problemei adunscad (OJI 2011, clasa a VIII-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["OJI","clasa VIII"]},{"location":"olimpiada/solutii/OJI/2011/VIII-adunscad/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["OJI","clasa VIII"]},{"location":"olimpiada/solutii/OJI/2011/VIII-comp/","title":"Solu\u021bia problemei comp (OJI 2011, clasa a VIII-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["OJI","clasa VIII"]},{"location":"olimpiada/solutii/OJI/2011/VIII-comp/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["OJI","clasa VIII"]},{"location":"olimpiada/solutii/OJI/2011/X-ai/","title":"Solu\u021bia problemei ai (OJI 2011, clasa a X-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["OJI","clasa X"]},{"location":"olimpiada/solutii/OJI/2011/X-ai/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["OJI","clasa X"]},{"location":"olimpiada/solutii/OJI/2011/X-expresie/","title":"Solu\u021bia problemei Expresie (OJI 2011, clasa a X-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["OJI","clasa X"]},{"location":"olimpiada/solutii/OJI/2011/X-expresie/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["OJI","clasa X"]},{"location":"olimpiada/solutii/OJI/2011/XI-XII-suma/","title":"Solu\u021bia problemei suma (OJI 2011, clasele XI-XII)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["OJI","clasa XI-XII"]},{"location":"olimpiada/solutii/OJI/2011/XI-XII-suma/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["OJI","clasa XI-XII"]},{"location":"olimpiada/solutii/OJI/2011/XI-XII-ubuntzei/","title":"Solu\u021bia problemei ubuntzei (OJI 2011, clasele XI-XII)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["OJI","clasa XI-XII"]},{"location":"olimpiada/solutii/OJI/2011/XI-XII-ubuntzei/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["OJI","clasa XI-XII"]},{"location":"olimpiada/solutii/OJI/2012/IX-elicop/","title":"Solu\u021bia problemei elicop (OJI 2012, clasa a IX-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["OJI","clasa IX"]},{"location":"olimpiada/solutii/OJI/2012/IX-elicop/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["OJI","clasa IX"]},{"location":"olimpiada/solutii/OJI/2012/IX-roata/","title":"Solu\u021bia problemei roata (OJI 2012, clasa a IX-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["OJI","clasa IX"]},{"location":"olimpiada/solutii/OJI/2012/IX-roata/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["OJI","clasa IX"]},{"location":"olimpiada/solutii/OJI/2012/V-alice/","title":"Solu\u021bia problemei alice (OJI 2012, clasa a V-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["OJI","clasa V"]},{"location":"olimpiada/solutii/OJI/2012/V-alice/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["OJI","clasa V"]},{"location":"olimpiada/solutii/OJI/2012/V-porumb/","title":"Solu\u021bia problemei porumb (OJI 2012, clasa a V-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["OJI","clasa V"]},{"location":"olimpiada/solutii/OJI/2012/V-porumb/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["OJI","clasa V"]},{"location":"olimpiada/solutii/OJI/2012/VI-cifru/","title":"Solu\u021bia problemei cifru (OJI 2012, clasa a VI-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["OJI","clasa VI"]},{"location":"olimpiada/solutii/OJI/2012/VI-cifru/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["OJI","clasa VI"]},{"location":"olimpiada/solutii/OJI/2012/VI-flori/","title":"Solu\u021bia problemei flori (OJI 2012, clasa a VI-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["OJI","clasa VI"]},{"location":"olimpiada/solutii/OJI/2012/VI-flori/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["OJI","clasa VI"]},{"location":"olimpiada/solutii/OJI/2012/VII-arme/","title":"Solu\u021bia problemei arme (OJI 2012, clasa a VII-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["OJI","clasa VII"]},{"location":"olimpiada/solutii/OJI/2012/VII-arme/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["OJI","clasa VII"]},{"location":"olimpiada/solutii/OJI/2012/VII-triunghi/","title":"Solu\u021bia problemei triunghi (OJI 2012, clasa a VII-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["OJI","clasa VII"]},{"location":"olimpiada/solutii/OJI/2012/VII-triunghi/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["OJI","clasa VII"]},{"location":"olimpiada/solutii/OJI/2012/VIII-deal/","title":"Solu\u021bia problemei deal (OJI 2012, clasa a VIII-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["OJI","clasa VIII"]},{"location":"olimpiada/solutii/OJI/2012/VIII-deal/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["OJI","clasa VIII"]},{"location":"olimpiada/solutii/OJI/2012/VIII-ozn/","title":"Solu\u021bia problemei ozn (OJI 2012, clasa a VIII-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["OJI","clasa VIII"]},{"location":"olimpiada/solutii/OJI/2012/VIII-ozn/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["OJI","clasa VIII"]},{"location":"olimpiada/solutii/OJI/2012/X-compresie/","title":"Solu\u021bia problemei Compresie (OJI 2012, clasa a X-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["OJI","clasa X"]},{"location":"olimpiada/solutii/OJI/2012/X-compresie/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["OJI","clasa X"]},{"location":"olimpiada/solutii/OJI/2012/X-culori/","title":"Solu\u021bia problemei Culori (OJI 2012, clasa a X-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["OJI","clasa X"]},{"location":"olimpiada/solutii/OJI/2012/X-culori/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["OJI","clasa X"]},{"location":"olimpiada/solutii/OJI/2012/XI-XII-blis/","title":"Solu\u021bia problemei blis (OJI 2012, clasele XI-XII)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["OJI","clasa XI-XII"]},{"location":"olimpiada/solutii/OJI/2012/XI-XII-blis/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["OJI","clasa XI-XII"]},{"location":"olimpiada/solutii/OJI/2012/XI-XII-parc/","title":"Solu\u021bia problemei Parc (OJI 2012, clasele XI-XII)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["OJI","clasa XI-XII"]},{"location":"olimpiada/solutii/OJI/2012/XI-XII-parc/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["OJI","clasa XI-XII"]},{"location":"olimpiada/solutii/OJI/2013/IX-betasah/","title":"Solu\u021bia problemei betasah (OJI 2013, clasa a IX-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["OJI","clasa IX"]},{"location":"olimpiada/solutii/OJI/2013/IX-betasah/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["OJI","clasa IX"]},{"location":"olimpiada/solutii/OJI/2013/IX-clepsidru/","title":"Solu\u021bia problemei clepsidru (OJI 2013, clasa a IX-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["OJI","clasa IX"]},{"location":"olimpiada/solutii/OJI/2013/IX-clepsidru/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["OJI","clasa IX"]},{"location":"olimpiada/solutii/OJI/2013/V-bete/","title":"Solu\u021bia problemei bete (OJI 2013, clasa a V-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["OJI","clasa V"]},{"location":"olimpiada/solutii/OJI/2013/V-bete/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["OJI","clasa V"]},{"location":"olimpiada/solutii/OJI/2013/V-chibrituri/","title":"Solu\u021bia problemei chibrituri (OJI 2013, clasa a V-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["OJI","clasa V"]},{"location":"olimpiada/solutii/OJI/2013/V-chibrituri/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["OJI","clasa V"]},{"location":"olimpiada/solutii/OJI/2013/VI-cladiri/","title":"Solu\u021bia problemei cladiri (OJI 2013, clasa a VI-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["OJI","clasa VI"]},{"location":"olimpiada/solutii/OJI/2013/VI-cladiri/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["OJI","clasa VI"]},{"location":"olimpiada/solutii/OJI/2013/VI-galbeni/","title":"Solu\u021bia problemei galbeni (OJI 2013, clasa a VI-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["OJI","clasa VI"]},{"location":"olimpiada/solutii/OJI/2013/VI-galbeni/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["OJI","clasa VI"]},{"location":"olimpiada/solutii/OJI/2013/VII-compar/","title":"Solu\u021bia problemei compar (OJI 2013, clasa a VII-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["OJI","clasa VII"]},{"location":"olimpiada/solutii/OJI/2013/VII-compar/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["OJI","clasa VII"]},{"location":"olimpiada/solutii/OJI/2013/VII-unific/","title":"Solu\u021bia problemei unific (OJI 2013, clasa a VII-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["OJI","clasa VII"]},{"location":"olimpiada/solutii/OJI/2013/VII-unific/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["OJI","clasa VII"]},{"location":"olimpiada/solutii/OJI/2013/VIII-maxp/","title":"Solu\u021bia problemei maxp (OJI 2013, clasa a VIII-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["OJI","clasa VIII"]},{"location":"olimpiada/solutii/OJI/2013/VIII-maxp/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["OJI","clasa VIII"]},{"location":"olimpiada/solutii/OJI/2013/VIII-puncte/","title":"Solu\u021bia problemei puncte (OJI 2013, clasa a VIII-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["OJI","clasa VIII"]},{"location":"olimpiada/solutii/OJI/2013/VIII-puncte/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["OJI","clasa VIII"]},{"location":"olimpiada/solutii/OJI/2013/X-calcule/","title":"Solu\u021bia problemei Calcule (OJI 2013, clasa a X-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["OJI","clasa X"]},{"location":"olimpiada/solutii/OJI/2013/X-calcule/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["OJI","clasa X"]},{"location":"olimpiada/solutii/OJI/2013/X-zona/","title":"Solu\u021bia problemei Zona (OJI 2013, clasa a X-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["OJI","clasa X"]},{"location":"olimpiada/solutii/OJI/2013/X-zona/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["OJI","clasa X"]},{"location":"olimpiada/solutii/OJI/2013/XI-XII-biperm/","title":"Solu\u021bia problemei biperm (OJI 2013, clasele XI-XII)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["OJI","clasa XI-XII"]},{"location":"olimpiada/solutii/OJI/2013/XI-XII-biperm/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["OJI","clasa XI-XII"]},{"location":"olimpiada/solutii/OJI/2013/XI-XII-subsecvente/","title":"Solu\u021bia problemei subsecvente (OJI 2013, clasele XI-XII)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["OJI","clasa XI-XII"]},{"location":"olimpiada/solutii/OJI/2013/XI-XII-subsecvente/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["OJI","clasa XI-XII"]},{"location":"olimpiada/solutii/OJI/2014/IX-cool/","title":"Solu\u021bia problemei cool (OJI 2014, clasa a IX-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["OJI","clasa IX"]},{"location":"olimpiada/solutii/OJI/2014/IX-cool/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["OJI","clasa IX"]},{"location":"olimpiada/solutii/OJI/2014/IX-pseudobil/","title":"Solu\u021bia problemei pseudobil (OJI 2014, clasa a IX-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["OJI","clasa IX"]},{"location":"olimpiada/solutii/OJI/2014/IX-pseudobil/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["OJI","clasa IX"]},{"location":"olimpiada/solutii/OJI/2014/V-martisoare/","title":"Solu\u021bia problemei martisoare (OJI 2014, clasa a V-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["OJI","clasa V"]},{"location":"olimpiada/solutii/OJI/2014/V-martisoare/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["OJI","clasa V"]},{"location":"olimpiada/solutii/OJI/2014/V-piramide/","title":"Solu\u021bia problemei piramide (OJI 2014, clasa a V-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["OJI","clasa V"]},{"location":"olimpiada/solutii/OJI/2014/V-piramide/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["OJI","clasa V"]},{"location":"olimpiada/solutii/OJI/2014/VI-imprimanta/","title":"Solu\u021bia problemei imprimanta (OJI 2014, clasa a VI-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["OJI","clasa VI"]},{"location":"olimpiada/solutii/OJI/2014/VI-imprimanta/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["OJI","clasa VI"]},{"location":"olimpiada/solutii/OJI/2014/VI-munte/","title":"Solu\u021bia problemei munte (OJI 2014, clasa a VI-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["OJI","clasa VI"]},{"location":"olimpiada/solutii/OJI/2014/VI-munte/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["OJI","clasa VI"]},{"location":"olimpiada/solutii/OJI/2014/VII-patrat/","title":"Solu\u021bia problemei patrat (OJI 2014, clasa a VII-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["OJI","clasa VII"]},{"location":"olimpiada/solutii/OJI/2014/VII-patrat/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["OJI","clasa VII"]},{"location":"olimpiada/solutii/OJI/2014/VII-schi/","title":"Solu\u021bia problemei schi (OJI 2014, clasa a VII-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["OJI","clasa VII"]},{"location":"olimpiada/solutii/OJI/2014/VII-schi/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["OJI","clasa VII"]},{"location":"olimpiada/solutii/OJI/2014/VIII-arrows/","title":"Solu\u021bia problemei arrows (OJI 2014, clasa a VIII-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["OJI","clasa VIII"]},{"location":"olimpiada/solutii/OJI/2014/VIII-arrows/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["OJI","clasa VIII"]},{"location":"olimpiada/solutii/OJI/2014/VIII-tcif/","title":"Solu\u021bia problemei tcif (OJI 2014, clasa a VIII-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["OJI","clasa VIII"]},{"location":"olimpiada/solutii/OJI/2014/VIII-tcif/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["OJI","clasa VIII"]},{"location":"olimpiada/solutii/OJI/2014/X-ferma/","title":"Solu\u021bia problemei Ferma (OJI 2014, clasa a X-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["OJI","clasa X"]},{"location":"olimpiada/solutii/OJI/2014/X-ferma/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["OJI","clasa X"]},{"location":"olimpiada/solutii/OJI/2014/X-triunghi/","title":"Solu\u021bia problemei Triunghi (OJI 2014, clasa a X-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["OJI","clasa X"]},{"location":"olimpiada/solutii/OJI/2014/X-triunghi/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["OJI","clasa X"]},{"location":"olimpiada/solutii/OJI/2014/XI-XII-cartite/","title":"Solu\u021bia problemei cartite (OJI 2014, clasele XI-XII)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["OJI","clasa XI-XII"]},{"location":"olimpiada/solutii/OJI/2014/XI-XII-cartite/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["OJI","clasa XI-XII"]},{"location":"olimpiada/solutii/OJI/2014/XI-XII-fractii2/","title":"Solu\u021bia problemei fractii2 (OJI 2014, clasele XI-XII)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["OJI","clasa XI-XII"]},{"location":"olimpiada/solutii/OJI/2014/XI-XII-fractii2/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["OJI","clasa XI-XII"]},{"location":"olimpiada/solutii/OJI/2015/IX-arc/","title":"Solu\u021bia problemei arc (OJI 2015, clasa a IX-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["OJI","clasa IX"]},{"location":"olimpiada/solutii/OJI/2015/IX-arc/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["OJI","clasa IX"]},{"location":"olimpiada/solutii/OJI/2015/IX-defrag/","title":"Solu\u021bia problemei defrag (OJI 2015, clasa a IX-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["OJI","clasa IX"]},{"location":"olimpiada/solutii/OJI/2015/IX-defrag/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["OJI","clasa IX"]},{"location":"olimpiada/solutii/OJI/2015/V-cuart/","title":"Solu\u021bia problemei cuart (OJI 2015, clasa a V-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["OJI","clasa V"]},{"location":"olimpiada/solutii/OJI/2015/V-cuart/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["OJI","clasa V"]},{"location":"olimpiada/solutii/OJI/2015/V-speciale/","title":"Solu\u021bia problemei speciale (OJI 2015, clasa a V-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["OJI","clasa V"]},{"location":"olimpiada/solutii/OJI/2015/V-speciale/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["OJI","clasa V"]},{"location":"olimpiada/solutii/OJI/2015/VI-covor/","title":"Solu\u021bia problemei covor (OJI 2015, clasa a VI-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["OJI","clasa VI"]},{"location":"olimpiada/solutii/OJI/2015/VI-covor/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["OJI","clasa VI"]},{"location":"olimpiada/solutii/OJI/2015/VI-ordine/","title":"Solu\u021bia problemei ordine (OJI 2015, clasa a VI-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["OJI","clasa VI"]},{"location":"olimpiada/solutii/OJI/2015/VI-ordine/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["OJI","clasa VI"]},{"location":"olimpiada/solutii/OJI/2015/VII-ech/","title":"Solu\u021bia problemei ech (OJI 2015, clasa a VII-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["OJI","clasa VII"]},{"location":"olimpiada/solutii/OJI/2015/VII-ech/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["OJI","clasa VII"]},{"location":"olimpiada/solutii/OJI/2015/VII-lasere/","title":"Solu\u021bia problemei lasere (OJI 2015, clasa a VII-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["OJI","clasa VII"]},{"location":"olimpiada/solutii/OJI/2015/VII-lasere/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["OJI","clasa VII"]},{"location":"olimpiada/solutii/OJI/2015/VIII-dominant/","title":"Solu\u021bia problemei dominant (OJI 2015, clasa a VIII-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["OJI","clasa VIII"]},{"location":"olimpiada/solutii/OJI/2015/VIII-dominant/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["OJI","clasa VIII"]},{"location":"olimpiada/solutii/OJI/2015/VIII-pavare/","title":"Solu\u021bia problemei pavare (OJI 2015, clasa a VIII-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["OJI","clasa VIII"]},{"location":"olimpiada/solutii/OJI/2015/VIII-pavare/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["OJI","clasa VIII"]},{"location":"olimpiada/solutii/OJI/2015/X-charlie/","title":"Solu\u021bia problemei charlie (OJI 2015, clasa a X-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["OJI","clasa X"]},{"location":"olimpiada/solutii/OJI/2015/X-charlie/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["OJI","clasa X"]},{"location":"olimpiada/solutii/OJI/2015/X-panda/","title":"Solu\u021bia problemei Panda (OJI 2015, clasa a X-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["OJI","clasa X"]},{"location":"olimpiada/solutii/OJI/2015/X-panda/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["OJI","clasa X"]},{"location":"olimpiada/solutii/OJI/2015/XI-XII-2sah/","title":"Solu\u021bia problemei 2sah (OJI 2015, clasele XI-XII)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["OJI","clasa XI-XII"]},{"location":"olimpiada/solutii/OJI/2015/XI-XII-2sah/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["OJI","clasa XI-XII"]},{"location":"olimpiada/solutii/OJI/2015/XI-XII-dragoni/","title":"Solu\u021bia problemei dragoni (OJI 2015, clasele XI-XII)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["OJI","clasa XI-XII"]},{"location":"olimpiada/solutii/OJI/2015/XI-XII-dragoni/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["OJI","clasa XI-XII"]},{"location":"olimpiada/solutii/OJI/2016/IX-cifre/","title":"Solu\u021bia problemei cifre (OJI 2016, clasa a IX-a)","text":"<p>De-a lungul acestei abord\u0103ri, va fi foarte important s\u0103 ne g\u00e2ndim la folosirea cifrelor pentru a codifica num\u0103rul de pozi\u021bii pe care s-a plasat un anumit segment. Deoarece ni se dau segmentele, putem deja s\u0103 codific\u0103m cifrele care sunt incluse una \u00een alta, sau pur \u0219i simplu s\u0103 num\u0103r\u0103m \u00eentr-o list\u0103 c\u00e2te cifre mai mari sunt incluse \u00een alta.</p> <p>Pentru prima cerin\u021b\u0103, nu trebuie dec\u00e2t s\u0103 num\u0103r\u0103m segmentele care apar \u00een numere.</p> <p>Pentru cea de-a doua cerin\u021b\u0103, ne putem g\u00e2ndi s\u0103 fix\u0103m cifra care va determina gradul de comparare \u00eentre numere, iar pentru acea cifr\u0103 s\u0103 afl\u0103m la c\u00e2te cifre mai mari putem ajunge. Ulterior, pentru toate celelalte cifre vom afla c\u00e2te numere pot fi ob\u021binute, indiferent c\u0103 sunt mai mari sau mai mici dec\u00e2t ea.</p> <p>Pentru a afla formula specific\u0103 fiec\u0103rei pozi\u021bii, ne putem g\u00e2ndi la regula produsului, deoarece \u0219tim c\u00e2te variante avem pentru fiecare pozi\u021bie \u0219i le putem \u00eenmul\u021bi pentru a afla contribu\u021bia la r\u0103spuns a pozi\u021biei curente.</p> <p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;fstream&gt;\n\nint c[] = {6, 2, 5, 5, 4, 5, 6, 3, 7, 6};  // nr de segmente\nint t[] = {2, 7, 2, 3, 3,\n           4, 2, 5, 1, 2};  // nr de numere pe care le putem obtine\nint mm[] = {1, 5, 1, 2, 2, 3, 1, 2, 0, 0};  // nr de numere mai mari\nint cif[25];\nchar s[25];\nunsigned long long p, sol;\n\nint main() {\n    std::ifstream cin(\"cifre.in\");\n    std::ofstream cout(\"cifre.out\");\n    int t1, k = 0, sum = 0, g;\n    cin &gt;&gt; t1;\n    cin &gt;&gt; s;\n    for (k = 0; s[k]; k++) {\n        cif[k] = s[k] - '0';\n    }\n    if (t1 == 1) {\n        for (int i = 0; i &lt; k; i++) {\n            sum += c[cif[i]];\n        }\n        cout &lt;&lt; sum;\n    } else {\n        for (int i = 0; i &lt; k; i++) {\n            p = 1;\n            for (int j = i + 1; j &lt; k; j++) {\n                g = cif[j];\n                p *= t[g];\n            }\n            sol += mm[cif[i]] * p;\n        }\n        cout &lt;&lt; sol;\n    }\n    return 0;\n}\n</code></pre>","tags":["OJI","clasa IX"]},{"location":"olimpiada/solutii/OJI/2016/IX-pic/","title":"Solu\u021bia problemei pic (OJI 2016, clasa a IX-a)","text":"<p>Pentru a rezolva prima cerin\u021b\u0103, tot ce trebuie s\u0103 facem este s\u0103 parcurgem fiecare linie \u0219i s\u0103 calcul\u0103m suma capacit\u0103\u021bilor.</p> <p>Pentru cea de-a doua cerin\u021b\u0103, o prim\u0103 solu\u021bie la care ne putem g\u00e2ndi este s\u0103 simul\u0103m procesul de turnare al lichidului \u0219i s\u0103 afl\u0103m primul moment de timp \u00een care se termin\u0103 de turnat lichidul. Din p\u0103cate, aceast\u0103 solu\u021bie este prea \u00eenceat\u0103, deoarece ne poate lua foarte mult timp s\u0103 ajungem la acest obiectiv.</p> <p>Totu\u0219i, putem observa faptul c\u0103 pe m\u0103sur\u0103 ce turn\u0103m tot mai mult lichid, vom avea tot mai mult progres cu umplerea paharelor, ceea ce impune folosirea unei alte metode de a g\u00e2ndi turnarea apei \u00een pahare.</p> <p>Observa\u021bie</p> <p>Acum, ne putem g\u00e2ndi invers: Oare dac\u0103 turn\u0103m toat\u0103 apa la \u00eenceput?</p> <p>Dac\u0103 turn\u0103m toat\u0103 apa la \u00eenceput, putem verifica \u00een \\(\\mathcal{O}(n^2)\\) dac\u0103 aceast\u0103 cantitate de ap\u0103 este \u00eendeajuns pentru a realiza obiectivul propus. Astfel, ne putem g\u00e2ndi acum mai departe la o idee pe baza unei c\u0103ut\u0103ri binare pe r\u0103spuns, deoarece acum putem simula eficient dac\u0103 putem ob\u021bine un r\u0103spuns, iar \u00een caz afirmativ, vom putea \u00eencerca un r\u0103spuns mai mic.</p> <p>Tot ce ne mai r\u0103m\u00e2ne s\u0103 facem este s\u0103 aproxim\u0103m valoarea maxim\u0103 a r\u0103spunsului, fapt ce se poate afla g\u00e2ndindu-ne la frecven\u021ba cu care ajung valorile mai mici s\u0103 fie umplute. Pentru o valoare de pe linia \\(i\\), va fi atins\u0103 aproximativ o dat\u0103 la \\(2^{i-1}\\) pa\u0219i, iar deoarece limita maxim\u0103 este \\(25\\) pentru cantitatea unui pahar, \u00eenseamn\u0103 c\u0103 vom avea nevoie de aproximativ \\(2^{49} \\cdot 25\\) pic\u0103turi pentru a ajunge la r\u0103spunsul final. Astfel, putem pune un cap\u0103t dreapta egal cu \\(2^{60}\\) f\u0103r\u0103 probleme, lucru f\u0103cut \u00een solu\u021bia de mai jos. </p> <p>Complexitatea va fi \\(\\mathcal{O}(60 \\cdot n^2)\\).</p> <p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;fstream&gt;\n#include &lt;vector&gt;\n\nbool check(long long T, const std::vector&lt;int&gt;&amp; C, int N, int M) {\n    std::vector&lt;long long&gt; inflow(M + 1, 0);\n    inflow[1] = T;\n    for (int l = 1; l &lt;= N; ++l) {\n        int start = (l - 1) * l / 2 + 1;\n        int end = l * (l + 1) / 2;\n        for (int j = start; j &lt;= end; ++j) {\n            if (j &gt; M) {\n                break;\n            }\n            long long c = C[j - 1];\n            long long oj = std::max(0LL, inflow[j] - c);\n            if (l &lt; N) {\n                int left = j + l;\n                int right = j + l + 1;\n                if (left &lt;= M) {\n                    inflow[left] += (oj + 1) / 2;\n                }\n                if (right &lt;= M) {\n                    inflow[right] += oj / 2;\n                }\n            }\n        }\n    }\n    for (int j = 1; j &lt;= M; ++j) {\n        if (inflow[j] &lt; C[j - 1]) {\n            return false;\n        }\n    }\n    return true;\n}\n\nint main() {\n    std::ifstream cin(\"pic.in\");\n    std::ofstream cout(\"pic.out\");\n\n    int V, N;\n    cin &gt;&gt; V &gt;&gt; N;\n    int M = N * (N + 1) / 2;\n    std::vector&lt;int&gt; C(M);\n    for (int i = 0; i &lt; M; ++i) {\n        cin &gt;&gt; C[i];\n    }\n    if (V == 1) {\n        int max_sum = -1, best_level = 0;\n        for (int l = 1; l &lt;= N; ++l) {\n            int start = (l - 1) * l / 2;\n            int sum = 0;\n            for (int i = start; i &lt; start + l; ++i) {\n                sum += C[i];\n            }\n            if (sum &gt; max_sum || (sum == max_sum &amp;&amp; l &lt; best_level)) {\n                max_sum = sum;\n                best_level = l;\n            }\n        }\n        cout &lt;&lt; best_level &lt;&lt; \"\\n\";\n    } else {\n        long long sum_C = 0;\n        for (int i = 0; i &lt; C.size(); i++) {\n            sum_C += C[i];\n        }\n        long long low = sum_C, high = (1LL &lt;&lt; 60), ans_T = high;\n        while (low &lt;= high) {\n            long long mid = (low + high) / 2;\n            if (check(mid, C, N, M)) {\n                ans_T = mid;\n                high = mid - 1;\n            } else {\n                low = mid + 1;\n            }\n        }\n        cout &lt;&lt; ans_T &lt;&lt; \" \" &lt;&lt; ans_T - sum_C &lt;&lt; \"\\n\";\n    }\n    return 0;\n}\n</code></pre>","tags":["OJI","clasa IX"]},{"location":"olimpiada/solutii/OJI/2016/V-colier/","title":"Solu\u021bia problemei colier (OJI 2016, clasa a V-a)","text":"","tags":["OJI","clasa V","cifre"]},{"location":"olimpiada/solutii/OJI/2016/V-colier/#cerinta-1","title":"Cerin\u021ba 1","text":"<p>Vom g\u0103si pentru fiecare num\u0103r cifra maxim\u0103, a c\u00e2ta cifr\u0103 este \u0219i la fel pentru cifra minim\u0103. Dac\u0103 cifra minim\u0103 este \u00eenainte de cifra maxim\u0103, num\u0103rul este de tip 1.</p> <p>Pentru a ne u\u0219ura implementarea, vom numerota pozi\u021biile de la ultima cifr\u0103 la prima, deci num\u0103rul va fi de tip 1 dac\u0103 pozi\u021bia cifrei minime este mai mare dec\u00e2t pozi\u021bia cifrei maxime.</p>","tags":["OJI","clasa V","cifre"]},{"location":"olimpiada/solutii/OJI/2016/V-colier/#cerinta-2","title":"Cerin\u021ba 2","text":"<p>Din fiecare pereche de numere adiacente (unul l\u00e2ng\u0103 cel\u0103lalt) de acela\u0219i tip, noi trebuie s\u0103 p\u0103str\u0103m doar unul. Chiar dac\u0103 avem trei la r\u00e2nd de acela\u0219i tip, din primele dou\u0103 va r\u0103m\u00e2ne doar unul, iar din aceste dou\u0103 va r\u0103m\u00e2ne doar unul. Aveam dou\u0103 perechi de numere adiacente de acela\u0219i tip \u0219i am eliminat dou\u0103 numere.</p> <p>Deci noi trebuie s\u0103 calcul\u0103m c\u00e2te perechi de numere adiacente au acela\u0219i tip, fie acest num\u0103r \\(P\\). R\u0103spunsul va fi \\(N - P\\) (pentru c\u0103 \u0219tergem exact \\(P\\) numere, unul din fiecare astfel de pereche, cum am zis \u0219i mai sus). De notat este faptul c\u0103 numerele \\(1\\) \u0219i \\(N\\) sunt adiacente \u0219i trebuie s\u0103 le lu\u0103m \u0219i pe ele \u00een considerare.</p> <p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;fstream&gt;\n\nusing namespace std;\n\nifstream fin(\"colier.in\");\nofstream fout(\"colier.out\");\n\nint tip(int n) {\n    int maxcif = 0, pozmax = 0, mincif = 10, pozmin = 0, poz = 0;\n    while (n &gt; 0) {\n        poz++;\n        if (n % 10 &gt; maxcif) {\n            maxcif = n % 10;\n            pozmax = poz;\n        }\n        if (n % 10 &lt; mincif) {\n            mincif = n % 10;\n            pozmin = poz;\n        }\n        n /= 10;\n    }\n    if (pozmin &gt; pozmax) {\n        return 1;\n    } else {\n        return 2;\n    }\n}\n\nint main() {\n    int c, n;\n    fin &gt;&gt; c &gt;&gt; n;\n    if (c == 1) {\n        int cnt = 0;\n        for (int i = 1; i &lt;= n; i++) {\n            int val;\n            fin &gt;&gt; val;\n            int maxcif = 0, pozmax = 0, mincif = 10, pozmin = 0, poz = 0;\n            while (val &gt; 0) {\n                poz++;\n                if (val % 10 &gt; maxcif) {\n                    maxcif = val % 10;\n                    pozmax = poz;\n                }\n                if (val % 10 &lt; mincif) {\n                    mincif = val % 10;\n                    pozmin = poz;\n                }\n                val /= 10;\n            }\n            if (pozmin &gt; pozmax) {\n                cnt++;\n            }\n        }\n        fout &lt;&lt; cnt;\n    } else {\n        int prim = 0, ultim = 0, prec = 0, rasp = 0;\n        for (int i = 1; i &lt;= n; i++) {\n            int val;\n            fin &gt;&gt; val;\n            int maxcif = 0, pozmax = 0, mincif = 10, pozmin = 0, poz = 0,\n                copie = val;\n            while (copie &gt; 0) {\n                poz++;\n                if (copie % 10 &gt; maxcif) {\n                    maxcif = copie % 10;\n                    pozmax = poz;\n                }\n                if (copie % 10 &lt; mincif) {\n                    mincif = copie % 10;\n                    pozmin = poz;\n                }\n                copie /= 10;\n            }\n            int valtip;\n            if (pozmin &gt; pozmax) {\n                valtip = 1;\n            } else {\n                valtip = 2;\n            }\n            if (i == 1) {\n                prim = valtip;\n            } else {\n                if (valtip == prec) {\n                    rasp++;\n                }\n            }\n            if (i == n) {\n                ultim = valtip;\n            }\n            prec = valtip;\n        }\n        if (prim == ultim) {\n            rasp++;\n        }\n        fout &lt;&lt; n - rasp;\n    }\n    return 0;\n}\n</code></pre>","tags":["OJI","clasa V","cifre"]},{"location":"olimpiada/solutii/OJI/2016/V-palindrom/","title":"Solu\u021bia problemei palindrom (OJI 2016, clasa a V-a)","text":"","tags":["OJI","clasa V","cifre"]},{"location":"olimpiada/solutii/OJI/2016/V-palindrom/#cerinta-1","title":"Cerin\u021ba 1","text":"<p>Calcul\u0103m oglinditul fiec\u0103rui num\u0103r \u0219i verific\u0103m num\u0103rul \u0219i oglinditul lui sunt egale. De notat este faptul c\u0103 oglinditul poate fi peste limita tipului <code>int</code>, a\u0219a c\u0103 va trebui s\u0103 folosim <code>long long</code>.</p>","tags":["OJI","clasa V","cifre"]},{"location":"olimpiada/solutii/OJI/2016/V-palindrom/#cerinta-2","title":"Cerin\u021ba 2","text":"<p>Calcul\u0103m oglinditul fiec\u0103rui num\u0103r \u0219i vedem c\u00e2te cifre sunt diferite \u00eentre num\u0103r \u0219i oglindit. Dac\u0103 num\u0103rul este aproape palindrom, ar trebui s\u0103 fie exact dou\u0103 diferen\u021be.</p> <p>Cifra din mijloc nu ar putea s\u0103 fie diferit\u0103, a\u0219a c\u0103 vor exista exact dou\u0103 pozi\u021bii cu cifre diferite. De exemplu, pentru num\u0103rul \\(12 \\ 341\\), oglinditul este \\(14 \\ 321\\), iar diferen\u021bele sunt la a doua \u0219i la a patra cifr\u0103.</p>","tags":["OJI","clasa V","cifre"]},{"location":"olimpiada/solutii/OJI/2016/V-palindrom/#cerinta-3","title":"Cerin\u021ba 3","text":"<p>Fiecare num\u0103r palindrom poate fi descris ca o concatenare a unui num\u0103r, a unei cifre \u0219i a r\u0103sturnatului acelui num\u0103r (cu eventuale 0-uri ad\u0103ugate la \u00eenceput). De exemplu, num\u0103rul \\(12 \\ 321\\) este concatenarea lui \\(12\\) cu \\(3\\) \u0219i cu \\(21\\), r\u0103sturnatul lui \\(12\\), iar num\u0103rul \\(1 \\ 221\\) este concatenarea lui \\(12\\) cu \\(21\\) (din nou, r\u0103sturnatul lui \\(12\\)).</p> <p>Pentru fiecare num\u0103r, vom nota cu \\(d\\) num\u0103rul de cifre ale lui. Fie \\(d = 2 \\cdot k + r\\), cu \\(r &lt; 2\\). S\u0103 calcul\u0103m num\u0103rul format din primele \\(k+r\\) cifre \u0219i s\u0103 \u00eel not\u0103m cu \\(j\\). Atunci num\u0103rul format din primele \\(k+r\\) cifre al palindromului asociat va fi egal cu \\(j\\) sau cu \\(j+1\\). Astfel, putem s\u0103 test\u0103m doar dou\u0103 numere. Pentru mai multe detalii despre vede\u021bi implementarea.</p> <p>Un caz particular pe care aceast\u0103 solu\u021bie gre\u0219e\u0219te este un num\u0103r de forma \\(X = 999 \\dots 9\\). Putem verifica \u00een special acest caz, r\u0103spunsul fiind \\(X + 2\\).</p> <p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;fstream&gt;\n\nusing namespace std;\n\nifstream fin(\"palindrom.in\");\nofstream fout(\"palindrom.out\");\n\nint main() {\n    int c, n;\n    fin &gt;&gt; c &gt;&gt; n;\n    if (c == 1) {\n        int cnt = 0;\n        for (int i = 1; i &lt;= n; i++) {\n            int val;\n            fin &gt;&gt; val;\n            long long ogl = 0;\n            int copie = val;\n            while (copie &gt; 0) {\n                ogl = ogl * 10 + copie % 10;\n                copie /= 10;\n            }\n            if (val == ogl) {\n                cnt++;\n            }\n        }\n        fout &lt;&lt; cnt;\n    } else if (c == 2) {\n        int cnt = 0;\n        for (int i = 1; i &lt;= n; i++) {\n            int val;\n            fin &gt;&gt; val;\n            long long ogl = 0;\n            int copie = val;\n            while (copie &gt; 0) {\n                ogl = ogl * 10 + copie % 10;\n                copie /= 10;\n            }\n            int nrdif = 0;\n            while (val &gt; 0) {\n                if (val % 10 != ogl % 10) {\n                    nrdif++;\n                }\n                val /= 10;\n                ogl /= 10;\n            }\n            if (nrdif == 2) {\n                cnt++;\n            }\n        }\n        fout &lt;&lt; cnt;\n    } else {\n        for (int i = 1; i &lt;= n; i++) {\n            int val;\n            fin &gt;&gt; val;\n            int copie = val, nrcifre = 0, doar_noua = 1;\n            long long p10 = 1;\n            while (copie &gt; 0) {\n                if (copie % 10 != 9) {\n                    doar_noua = 0;\n                }\n                nrcifre++;\n                copie /= 10;\n                p10 *= 10;\n            }\n            if (doar_noua) {\n                fout &lt;&lt; val + 2 &lt;&lt; \" \";\n            } else {\n                int primele = 0;  // primele k+r cifre\n                for (int j = 0; j &lt; nrcifre / 2 + nrcifre % 2; j++) {\n                    p10 /= 10;\n                    primele = primele * 10 + (val / p10 % 10);\n                }\n                // completez primele cu rasturnatul sau, iar daca nrcifre % 2 =\n                // 1 ultima cifra nu o mai rastorn\n                long long answer = primele;\n                copie = primele;\n                if (nrcifre % 2 == 1) {\n                    copie /= 10;\n                }\n                p10 = 1;\n                while (p10 &lt;= copie) {\n                    p10 *= 10;\n                }\n                long long ogl = 0;\n                while (copie &gt; 0) {\n                    ogl = ogl * 10 + copie % 10;\n                    copie /= 10;\n                }\n                answer = answer * p10 + ogl;\n                if (answer &lt;= val) {\n                    primele++;  // incerc acum cu primele + 1\n                    answer = primele;\n                    if (nrcifre % 2 == 1) {\n                        primele /= 10;\n                    }\n                    p10 = 1;\n                    while (p10 &lt;= primele) {\n                        p10 *= 10;\n                    }\n                    ogl = 0;\n                    while (primele &gt; 0) {\n                        ogl = ogl * 10 + primele % 10;\n                        primele /= 10;\n                    }\n                    answer = answer * p10 + ogl;\n                }\n                fout &lt;&lt; answer &lt;&lt; \" \";\n            }\n        }\n    }\n    return 0;\n}\n</code></pre>","tags":["OJI","clasa V","cifre"]},{"location":"olimpiada/solutii/OJI/2016/VI-cifre/","title":"Solu\u021bia problemei cifre (OJI 2016, clasa a VI-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["OJI","clasa VI"]},{"location":"olimpiada/solutii/OJI/2016/VI-cifre/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["OJI","clasa VI"]},{"location":"olimpiada/solutii/OJI/2016/VI-litere/","title":"Solu\u021bia problemei litere (OJI 2016, clasa a VI-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["OJI","clasa VI"]},{"location":"olimpiada/solutii/OJI/2016/VI-litere/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["OJI","clasa VI"]},{"location":"olimpiada/solutii/OJI/2016/VII-axyz/","title":"Solu\u021bia problemei axyz (OJI 2016, clasa a VII-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["OJI","clasa VII"]},{"location":"olimpiada/solutii/OJI/2016/VII-axyz/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["OJI","clasa VII"]},{"location":"olimpiada/solutii/OJI/2016/VII-galerie/","title":"Solu\u021bia problemei galerie (OJI 2016, clasa a VII-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["OJI","clasa VII"]},{"location":"olimpiada/solutii/OJI/2016/VII-galerie/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["OJI","clasa VII"]},{"location":"olimpiada/solutii/OJI/2016/VIII-arma/","title":"Solu\u021bia problemei arma (OJI 2016, clasa a VIII-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["OJI","clasa VIII"]},{"location":"olimpiada/solutii/OJI/2016/VIII-arma/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["OJI","clasa VIII"]},{"location":"olimpiada/solutii/OJI/2016/VIII-ks/","title":"Solu\u021bia problemei ks (OJI 2016, clasa a VIII-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["OJI","clasa VIII"]},{"location":"olimpiada/solutii/OJI/2016/VIII-ks/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["OJI","clasa VIII"]},{"location":"olimpiada/solutii/OJI/2016/X-interesant/","title":"Solu\u021bia problemei Interesant (OJI 2016, clasa a X-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["OJI","clasa X"]},{"location":"olimpiada/solutii/OJI/2016/X-interesant/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["OJI","clasa X"]},{"location":"olimpiada/solutii/OJI/2016/X-miting/","title":"Solu\u021bia problemei Miting (OJI 2016, clasa a X-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["OJI","clasa X"]},{"location":"olimpiada/solutii/OJI/2016/X-miting/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["OJI","clasa X"]},{"location":"olimpiada/solutii/OJI/2016/XI-XII-elicoptere/","title":"Solu\u021bia problemei elicoptere (OJI 2016, clasele XI-XII)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["OJI","clasa XI-XII"]},{"location":"olimpiada/solutii/OJI/2016/XI-XII-elicoptere/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["OJI","clasa XI-XII"]},{"location":"olimpiada/solutii/OJI/2016/XI-XII-summax/","title":"Solu\u021bia problemei summax (OJI 2016, clasele XI-XII)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["OJI","clasa XI-XII"]},{"location":"olimpiada/solutii/OJI/2016/XI-XII-summax/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["OJI","clasa XI-XII"]},{"location":"olimpiada/solutii/OJI/2017/IX-ace/","title":"Solu\u021bia problemei ace (OJI 2017, clasa a IX-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["OJI","clasa IX"]},{"location":"olimpiada/solutii/OJI/2017/IX-ace/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["OJI","clasa IX"]},{"location":"olimpiada/solutii/OJI/2017/IX-admitere/","title":"Solu\u021bia problemei admitere (OJI 2017, clasa a IX-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["OJI","clasa IX"]},{"location":"olimpiada/solutii/OJI/2017/IX-admitere/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["OJI","clasa IX"]},{"location":"olimpiada/solutii/OJI/2017/IX-roboti/","title":"Solu\u021bia problemei roboti (OJI 2017, clasa a IX-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["OJI","clasa IX"]},{"location":"olimpiada/solutii/OJI/2017/IX-roboti/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["OJI","clasa IX"]},{"location":"olimpiada/solutii/OJI/2017/V-numere/","title":"Solu\u021bia problemei numere (OJI 2017, clasa a V-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["OJI","clasa V"]},{"location":"olimpiada/solutii/OJI/2017/V-numere/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["OJI","clasa V"]},{"location":"olimpiada/solutii/OJI/2017/V-robot/","title":"Solu\u021bia problemei robot (OJI 2017, clasa a V-a)","text":"","tags":["OJI","clasa V","cifre","simulare"]},{"location":"olimpiada/solutii/OJI/2017/V-robot/#cerinta-1","title":"Cerin\u021ba 1","text":"<p>Trebuie doar s\u0103 num\u0103r\u0103m c\u00e2te caractere A sunt.</p>","tags":["OJI","clasa V","cifre","simulare"]},{"location":"olimpiada/solutii/OJI/2017/V-robot/#cerinta-2","title":"Cerin\u021ba 2","text":"<p>Putem s\u0103 simul\u0103m programul, men\u021bin\u00e2nd o variabil\u0103 \\(cf\\) care s\u0103 ne spun\u0103 la ce cifr\u0103 suntem.</p> <ul> <li>C\u00e2nd mergem la dreapta cu \\(P\\) pozi\u021bii, \\(cf = cf + p\\), iar dac\u0103 \\(cf \\geq 10\\)   (de la 9 mergem la 0), \\(cf = cf - 10\\)</li> <li>C\u00e2nd mergem la st\u00e2nga cu \\(P\\) pozi\u021bii, \\(cf = cf - p\\), iar dac\u0103 \\(cf &lt; 0\\) (de la   0 mergem la 9), \\(cf = cf + 10\\)</li> </ul>","tags":["OJI","clasa V","cifre","simulare"]},{"location":"olimpiada/solutii/OJI/2017/V-robot/#cerinta-3","title":"Cerin\u021ba 3","text":"<p>Vom citi cifrele caracter cu caracter. Noi trebuie s\u0103 mergem de la cifr\u0103 la cifr\u0103 pe cel mai scurt drum posibil, plec\u00e2nd de la cifra 0.</p> <p>Drumul cel mai scurt posibil de la cifra \\(a\\) la cifra \\(b\\) este:</p> <ul> <li>Dac\u0103 \\(a &lt; b\\), cel mai scurt dintre:</li> <li>\u00cen st\u00e2nga cu \\(a-b\\) pozi\u021bii</li> <li>\u00cen dreapta cu \\(10+b-a\\) pozi\u021bii</li> <li>Dac\u0103 \\(a &lt; b\\), cel mai scurt dintre:</li> <li>\u00cen dreapta cu \\(b-a\\) pozi\u021bii</li> <li>\u00cen st\u00e2nga cu \\(10+a-b\\) pozi\u021bii</li> <li>Dac\u0103 \\(a = b\\), nu trebuie s\u0103 facem nimic</li> </ul> <p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;fstream&gt;\n\nusing namespace std;\n\nifstream fin(\"robot.in\");\nofstream fout(\"robot.out\");\n\nint main() {\n    short cerinta, comenzi = 0, cifra = 0, aux;\n    char comanda;\n    fin &gt;&gt; cerinta;\n\n    if (cerinta == 1) {\n        fin &gt;&gt; comanda;\n\n        while (comanda != 'T') {\n            if (comanda == 'A') {\n                comenzi++;\n            }\n\n            fin &gt;&gt; comanda;\n        }\n\n        fout &lt;&lt; comenzi;\n    } else if (cerinta == 2) {\n        fin &gt;&gt; comanda;\n\n        while (comanda != 'T') {\n            if (comanda == 'D') {\n                fin &gt;&gt; comanda;\n                cifra += comanda - '0';\n\n                if (cifra &gt; 9) {\n                    cifra -= 10;\n                }\n            } else if (comanda == 'S') {\n                fin &gt;&gt; comanda;\n                aux = comanda - '0';\n\n                if (aux &gt; cifra) {\n                    aux -= cifra;\n                    cifra = 10 - aux;\n                } else {\n                    cifra -= aux;\n                }\n            } else {\n                fout &lt;&lt; cifra;\n            }\n            fin &gt;&gt; comanda;\n        }\n    } else {\n        while (fin &gt;&gt; comanda) {\n            aux = comanda - '0';\n\n            if (cifra &gt; aux) {\n                if (cifra - aux &lt;= 10 - cifra + aux) {\n                    fout &lt;&lt; 'S' &lt;&lt; cifra - aux;\n                } else {\n                    fout &lt;&lt; 'D' &lt;&lt; 10 - cifra + aux;\n                }\n            } else if (aux &gt; cifra) {\n                if (aux - cifra &lt;= 10 - aux + cifra) {\n                    fout &lt;&lt; 'D' &lt;&lt; aux - cifra;\n                } else {\n                    fout &lt;&lt; 'S' &lt;&lt; 10 - aux + cifra;\n                }\n            }\n            cifra = aux;\n\n            fout &lt;&lt; 'A';\n        }\n\n        fout &lt;&lt; 'T';\n    }\n\n    return 0;\n}\n</code></pre>","tags":["OJI","clasa V","cifre","simulare"]},{"location":"olimpiada/solutii/OJI/2017/VI-accesibil/","title":"Solu\u021bia problemei accesibil (OJI 2017, clasa a VI-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["OJI","clasa VI"]},{"location":"olimpiada/solutii/OJI/2017/VI-accesibil/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["OJI","clasa VI"]},{"location":"olimpiada/solutii/OJI/2017/VI-fermier/","title":"Solu\u021bia problemei fermier (OJI 2017, clasa a VI-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["OJI","clasa VI"]},{"location":"olimpiada/solutii/OJI/2017/VI-fermier/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["OJI","clasa VI"]},{"location":"olimpiada/solutii/OJI/2017/VII-cursuri/","title":"Solu\u021bia problemei cursuri (OJI 2017, clasa a VII-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["OJI","clasa VII"]},{"location":"olimpiada/solutii/OJI/2017/VII-cursuri/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["OJI","clasa VII"]},{"location":"olimpiada/solutii/OJI/2017/VII-joc/","title":"Solu\u021bia problemei joc (OJI 2017, clasa a VII-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["OJI","clasa VII"]},{"location":"olimpiada/solutii/OJI/2017/VII-joc/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["OJI","clasa VII"]},{"location":"olimpiada/solutii/OJI/2017/VIII-tablou/","title":"Solu\u021bia problemei tablou (OJI 2017, clasa a VIII-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["OJI","clasa VIII"]},{"location":"olimpiada/solutii/OJI/2017/VIII-tablou/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["OJI","clasa VIII"]},{"location":"olimpiada/solutii/OJI/2017/VIII-triunghiuri/","title":"Solu\u021bia problemei triunghiuri (OJI 2017, clasa a VIII-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["OJI","clasa VIII"]},{"location":"olimpiada/solutii/OJI/2017/VIII-triunghiuri/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["OJI","clasa VIII"]},{"location":"olimpiada/solutii/OJI/2017/X-caps/","title":"Solu\u021bia problemei Caps (OJI 2017, clasa a X-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["OJI","clasa X"]},{"location":"olimpiada/solutii/OJI/2017/X-caps/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["OJI","clasa X"]},{"location":"olimpiada/solutii/OJI/2017/X-rover/","title":"Solu\u021bia problemei Rover (OJI 2017, clasa a X-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["OJI","clasa X"]},{"location":"olimpiada/solutii/OJI/2017/X-rover/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["OJI","clasa X"]},{"location":"olimpiada/solutii/OJI/2017/X-sir/","title":"Solu\u021bia problemei \u0218ir (OJI 2017, clasa a X-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["OJI","clasa X"]},{"location":"olimpiada/solutii/OJI/2017/X-sir/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["OJI","clasa X"]},{"location":"olimpiada/solutii/OJI/2017/XI-XII-armonica/","title":"Solu\u021bia problemei armonica (OJI 2017, clasele XI-XII)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["OJI","clasa XI-XII"]},{"location":"olimpiada/solutii/OJI/2017/XI-XII-armonica/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["OJI","clasa XI-XII"]},{"location":"olimpiada/solutii/OJI/2017/XI-XII-ninjago/","title":"Solu\u021bia problemei ninjago (OJI 2017, clasele XI-XII)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["OJI","clasa XI-XII"]},{"location":"olimpiada/solutii/OJI/2017/XI-XII-ninjago/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim. <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre></p>","tags":["OJI","clasa XI-XII"]},{"location":"olimpiada/solutii/OJI/2017/XI-XII-permutare/","title":"Solu\u021bia problemei permutare (OJI 2017, clasele XI-XII)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["OJI","clasa XI-XII"]},{"location":"olimpiada/solutii/OJI/2017/XI-XII-permutare/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["OJI","clasa XI-XII"]},{"location":"olimpiada/solutii/OJI/2018/IX-cufar/","title":"Solu\u021bia problemei cufar (OJI 2018, clasa a IX-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["OJI","clasa IX"]},{"location":"olimpiada/solutii/OJI/2018/IX-cufar/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["OJI","clasa IX"]},{"location":"olimpiada/solutii/OJI/2018/IX-fadema/","title":"Solu\u021bia problemei fadema (OJI 2018, clasa a IX-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["OJI","clasa IX"]},{"location":"olimpiada/solutii/OJI/2018/IX-fadema/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["OJI","clasa IX"]},{"location":"olimpiada/solutii/OJI/2018/IX-tnia/","title":"Solu\u021bia problemei tnia (OJI 2018, clasa a IX-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["OJI","clasa IX"]},{"location":"olimpiada/solutii/OJI/2018/IX-tnia/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["OJI","clasa IX"]},{"location":"olimpiada/solutii/OJI/2018/V-forus/","title":"Solu\u021bia problemei forus (OJI 2018, clasa a V-a)","text":"","tags":["OJI","clasa V"]},{"location":"olimpiada/solutii/OJI/2018/V-forus/#cerinta-1","title":"Cerin\u021ba 1","text":"<p>Trebuie de fapt s\u0103 afl\u0103m c\u00e2te numere nu con\u021bin cifra 0.</p>","tags":["OJI","clasa V"]},{"location":"olimpiada/solutii/OJI/2018/V-forus/#cerinta-2","title":"Cerin\u021ba 2","text":"<p>Observ\u0103m c\u0103 atunci c\u00e2nd facem o t\u0103ietur\u0103, noi vom lua un prefix \u0219i un sufix al num\u0103rului \u0219i le vom alipi (mai \u00eent\u00e2i sufixul \u0219i apoi prefixul). Putem s\u0103 lu\u0103m cifrele num\u0103rului de la final la \u00eenceput, s\u0103 \u00eencepem cu prefixul egal cu num\u0103rul, iar, pe m\u0103sur\u0103 ce avans\u0103m, s\u0103 mai t\u0103iem c\u00e2te o cifr\u0103 din prefix \u0219i s\u0103 o ad\u0103ug\u0103m \u00een sufix.</p> <p>Num\u0103rul de divizori va fi calculat la fel cum este prezentat \u00een articolul de divizibilitate men\u021bionat mai sus, iar alipirea se va face \u00eenmul\u021bind sufixul cu 10 la puterea num\u0103rului de cifre din prefix (pe care \u00eel vom calcula la fel cum facem cu prefixul).</p> <p>Pentru mai multe detalii vede\u021bi implementarea.</p> <p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;fstream&gt;\n\nusing namespace std;\n\nifstream fin(\"forus.in\");\nofstream fout(\"forus.out\");\n\nint main() {\n    int c, n;\n    fin &gt;&gt; c &gt;&gt; n;\n    if (c == 1) {\n        int cnt = 0;\n        for (int i = 1; i &lt;= n; i++) {\n            int val;\n            fin &gt;&gt; val;\n            int are_zero = 0;\n            while (val &gt; 0) {\n                if (val % 10 == 0) {\n                    are_zero = 1;\n                }\n                val /= 10;\n            }\n            if (are_zero == 0) {\n                cnt++;\n            }\n        }\n        fout &lt;&lt; cnt;\n    } else {\n        for (int i = 1; i &lt;= n; i++) {\n            int val;\n            fin &gt;&gt; val;\n            int p10prefix = 1;\n            while (p10prefix &lt;= val) {\n                p10prefix *= 10;\n            }\n            int rasp = val, raspdiv = 0;\n            for (int d = 1; d * d &lt;= val; d++) {\n                if (val % d == 0) {\n                    raspdiv++;\n                    if (val / d != d) {\n                        raspdiv++;\n                    }\n                }\n            }\n            int p10sufix = 1, sufix = 0;\n            while (val &gt;= 10) {\n                sufix += p10sufix * (val % 10);\n                p10prefix /= 10;\n                if (val % 10 &gt; 0) {\n                    int nrnou = sufix * p10prefix + val / 10, nrdiv = 0;\n                    for (int d = 1; d * d &lt;= nrnou; d++) {\n                        if (nrnou % d == 0) {\n                            nrdiv++;\n                            if (nrnou / d != d) {\n                                nrdiv++;\n                            }\n                        }\n                    }\n                    if (nrdiv &lt; raspdiv) {\n                        raspdiv = nrdiv;\n                        rasp = nrnou;\n                    } else if (nrdiv == raspdiv &amp;&amp; nrnou &lt; rasp) {\n                        rasp = nrnou;\n                    }\n                }\n                val /= 10;\n                p10sufix *= 10;\n            }\n            fout &lt;&lt; rasp &lt;&lt; \" \";\n        }\n    }\n    return 0;\n}\n</code></pre>","tags":["OJI","clasa V"]},{"location":"olimpiada/solutii/OJI/2018/V-patrate/","title":"Solu\u021bia problemei patrate (OJI 2018, clasa a V-a)","text":"","tags":["OJI","clasa V"]},{"location":"olimpiada/solutii/OJI/2018/V-patrate/#cerinta-1","title":"Cerin\u021ba 1","text":"<p>Primul element din p\u0103tratul \\(M\\) este \\((2 \\cdot M - 1) ^ 2\\), iar ultimul este \\((2 \\cdot M + 1) ^ 2 - 1\\). Sunt \\((2 \\cdot M + 1) ^ 2 - 1 - (2 \\cdot M - 1) + 1 = (2 \\cdot M + 1) ^ 2 - (2 \\cdot M - 1) ^ 2\\) elemente.</p>","tags":["OJI","clasa V"]},{"location":"olimpiada/solutii/OJI/2018/V-patrate/#cerinta-2","title":"Cerin\u021ba 2","text":"<p>C\u0103ut\u0103m primul num\u0103r \\(T\\) pentru care \\((2 \\cdot T - 1) ^ 2 \\leq N \\leq (2 \\cdot T + 1) ^ 2 - 1\\) (adic\u0103 \\(N\\) s\u0103 fie \u00een intervalul de numere de pe p\u0103tratul \\(T\\)).</p> <p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;fstream&gt;\n\nusing namespace std;\n\nifstream fin(\"patrate.in\");\nofstream fout(\"patrate.out\");\n\nint main() {\n    int c, n, i;\n    fin &gt;&gt; c &gt;&gt; n;\n\n    if (c == 1) {\n        fout &lt;&lt; (1 + 2 * n) * (1 + 2 * n)\n                    - (1 + 2 * (n - 1)) * (1 + 2 * (n - 1));\n    } else {\n        int i = 0;\n        while (!((2 * i - 1) * (2 * i - 1) &lt;= n\n                 &amp;&amp; n &lt;= (2 * i + 1) * (2 * i + 1) - 1)) {\n            i++;\n        }\n\n        fout &lt;&lt; i;\n    }\n\n    return 0;\n}\n</code></pre>","tags":["OJI","clasa V"]},{"location":"olimpiada/solutii/OJI/2018/VI-numere/","title":"Solu\u021bia problemei numere (OJI 2018, clasa a VI-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["OJI","clasa VI"]},{"location":"olimpiada/solutii/OJI/2018/VI-numere/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["OJI","clasa VI"]},{"location":"olimpiada/solutii/OJI/2018/VI-turnuri/","title":"Solu\u021bia problemei turnuri (OJI 2018, clasa a VI-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["OJI","clasa VI"]},{"location":"olimpiada/solutii/OJI/2018/VI-turnuri/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["OJI","clasa VI"]},{"location":"olimpiada/solutii/OJI/2018/VII-puzzle/","title":"Solu\u021bia problemei puzzle (OJI 2018, clasa a VII-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["OJI","clasa VII"]},{"location":"olimpiada/solutii/OJI/2018/VII-puzzle/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["OJI","clasa VII"]},{"location":"olimpiada/solutii/OJI/2018/VII-tbile/","title":"Solu\u021bia problemei tbile (OJI 2018, clasa a VII-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["OJI","clasa VII"]},{"location":"olimpiada/solutii/OJI/2018/VII-tbile/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["OJI","clasa VII"]},{"location":"olimpiada/solutii/OJI/2018/VIII-cruce/","title":"Solu\u021bia problemei cruce (OJI 2018, clasa a VIII-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["OJI","clasa VIII"]},{"location":"olimpiada/solutii/OJI/2018/VIII-cruce/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["OJI","clasa VIII"]},{"location":"olimpiada/solutii/OJI/2018/VIII-pal/","title":"Solu\u021bia problemei pal (OJI 2018, clasa a VIII-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["OJI","clasa VIII"]},{"location":"olimpiada/solutii/OJI/2018/VIII-pal/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["OJI","clasa VIII"]},{"location":"olimpiada/solutii/OJI/2018/X-castel/","title":"Solu\u021bia problemei Castel (OJI 2018, clasa a X-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["OJI","clasa X"]},{"location":"olimpiada/solutii/OJI/2018/X-castel/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["OJI","clasa X"]},{"location":"olimpiada/solutii/OJI/2018/X-eq4/","title":"Solu\u021bia problemei eq4 (OJI 2018, clasa a X-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["OJI","clasa X"]},{"location":"olimpiada/solutii/OJI/2018/X-eq4/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["OJI","clasa X"]},{"location":"olimpiada/solutii/OJI/2018/X-turnuri/","title":"Solu\u021bia problemei Turnuri (OJI 2018, clasa a X-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["OJI","clasa X"]},{"location":"olimpiada/solutii/OJI/2018/X-turnuri/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["OJI","clasa X"]},{"location":"olimpiada/solutii/OJI/2018/XI-XII-aquapark/","title":"Solu\u021bia problemei aquapark (OJI 2018, clasele XI-XII)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["OJI","clasa XI-XII"]},{"location":"olimpiada/solutii/OJI/2018/XI-XII-aquapark/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["OJI","clasa XI-XII"]},{"location":"olimpiada/solutii/OJI/2018/XI-XII-galeti/","title":"Solu\u021bia problemei galeti (OJI 2018, clasele XI-XII)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["OJI","clasa XI-XII"]},{"location":"olimpiada/solutii/OJI/2018/XI-XII-galeti/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["OJI","clasa XI-XII"]},{"location":"olimpiada/solutii/OJI/2018/XI-XII-ramen/","title":"Solu\u021bia problemei ramen (OJI 2018, clasele XI-XII)","text":"<p>Pentru a rezolva aceast\u0103 problem\u0103, plec\u0103m de la urm\u0103toarea presupunere, care se poate demonstra foarte u\u0219or: Dac\u0103 o por\u021bie de m\u00e2ncare ajunge la persoana aflat\u0103 la pozi\u021bia \\(x\\), iar aceast\u0103 persoan\u0103 are o comand\u0103 deja, respectiva persoan\u0103 va lua por\u021bia, chiar dac\u0103 nu este por\u021bia pe care a comandat-o.</p> <p>Pe baza acestui fapt, putem s\u0103 sort\u0103m comenzile \u00een ordine cresc\u0103toare a pozi\u021biei persoanei care face acea comand\u0103 \u0219i la fiecare pas, persoana respectiv\u0103 va ob\u021bine prima comand\u0103 care trece \u00een dreptul ei, dup\u0103 ce a f\u0103cut comanda, indiferent de timpul necesar pentru preg\u0103tirea ei.</p> <p>Pentru a putea simula acest proces, vom folosi o structur\u0103 de tip set, care ne permite inserarea \u0219i \u0219tergerea valorilor \u00een timp logaritmic. Mai jos g\u0103si\u021bi o solu\u021bie care ob\u021bine punctajul maxim.</p> <pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\nifstream in(\"ramen.in\");\nofstream out(\"ramen.out\");\nint n, d;\nset&lt;int&gt; s;\nint ans[100002];\nstruct aa {\n    int care, timp, pi;\n};\naa v[100002];\nbool cmp(aa a, aa b) {\n    if (a.care == b.care) {\n        return a.timp &lt; b.timp;\n    }\n    return a.care &lt; b.care;\n}\nint main() {\n    in &gt;&gt; n &gt;&gt; d;\n    for (int i = 1; i &lt;= n; ++i) {\n        in &gt;&gt; v[i].timp &gt;&gt; v[i].care;\n        v[i].pi = i;\n        s.insert(v[i].timp + d);\n    }\n    sort(v + 1, v + n + 1, cmp);\n    for (int i = 1; i &lt;= n; ++i) {\n        auto it = s.lower_bound(v[i].timp - v[i].care);\n        ans[v[i].pi] = *it + v[i].care;\n        s.erase(it);\n    }\n    for (int i = 1; i &lt;= n; ++i) {\n        out &lt;&lt; ans[i] &lt;&lt; '\\n';\n    }\n    return 0;\n}\n</code></pre>","tags":["OJI","clasa XI-XII"]},{"location":"olimpiada/solutii/OJI/2019/IX-abx/","title":"Solu\u021bia problemei abx (OJI 2019, clasa a IX-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["OJI","clasa IX"]},{"location":"olimpiada/solutii/OJI/2019/IX-abx/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["OJI","clasa IX"]},{"location":"olimpiada/solutii/OJI/2019/IX-deminare/","title":"Solu\u021bia problemei deminare (OJI 2019, clasa a IX-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["OJI","clasa IX"]},{"location":"olimpiada/solutii/OJI/2019/IX-deminare/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["OJI","clasa IX"]},{"location":"olimpiada/solutii/OJI/2019/IX-mostenire/","title":"Solu\u021bia problemei mostenire (OJI 2019, clasa a IX-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["OJI","clasa IX"]},{"location":"olimpiada/solutii/OJI/2019/IX-mostenire/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["OJI","clasa IX"]},{"location":"olimpiada/solutii/OJI/2019/V-aur/","title":"Solu\u021bia problemei aur (OJI 2019, clasa a V-a)","text":"","tags":["OJI","clasa V","cifre","citire caractere"]},{"location":"olimpiada/solutii/OJI/2019/V-aur/#cerinta-1","title":"Cerin\u021ba 1","text":"<p>Putem citi toate numerele \u0219i s\u0103 calcul\u0103m pentru fiecare c\u00e2te cifre are (not\u0103m acest num\u0103r cu \\(ncf\\)). Acum trebuie s\u0103 afl\u0103m suma \\(ncf\\)-urilor.</p> <p>Mai u\u0219or, putem citi caracter cu caracter cifrele (citind cu <code>while (fin &gt;&gt; c)</code> \u00eentr-o variabil\u0103 c de tip char, a\u0219a cum este men\u021bionat \u0219i \u00een acest articol) \u0219i s\u0103 num\u0103r\u0103m c\u00e2te sunt. Vom folosi pentru celelalte cerin\u021be aceast\u0103 metod\u0103, deoarece este mai u\u0219oar\u0103 dec\u00e2t s\u0103 citim numerele \u0219i s\u0103 le prelucr\u0103m cifrele.</p>","tags":["OJI","clasa V","cifre","citire caractere"]},{"location":"olimpiada/solutii/OJI/2019/V-aur/#cerinta-2","title":"Cerin\u021ba 2","text":"<p>Citim caracter cu caracter cifrele, p\u00e2n\u0103 c\u00e2nd ajungem la a \\(K\\)-a, pe care o afi\u0219\u0103m.</p>","tags":["OJI","clasa V","cifre","citire caractere"]},{"location":"olimpiada/solutii/OJI/2019/V-aur/#cerinta-3","title":"Cerin\u021ba 3","text":"<p>Citim mai \u00eent\u00e2i primele \\(P\\) cifre \u0219i form\u0103m primul num\u0103r (fie acesta \\(nr\\)). Pentru a forma urm\u0103torul num\u0103r ar trebui s\u0103 \u0219tergem prima cifr\u0103 din \\(nr\\) \u0219i s\u0103 ad\u0103ug\u0103m \u00eenc\u0103 o cifr\u0103 \\(cf\\) la final. Acest lucru este echivalent cu a ad\u0103uga cifra \\(cf\\) la finalul lui \\(nr\\) \u0219i a p\u0103stra ultimele \\(P\\) cifre (\\(nr = (nr \\cdot 10 + cf) \\ \\% \\ 10^p\\), unde \\(10^p\\) este calculat la \u00eenceputul programului).</p> <p>Pentru a ne fi \u0219i mai u\u0219or s\u0103 implement\u0103m acest cod, observ\u0103m c\u0103 nici m\u0103car nu trebuie s\u0103 afl\u0103m num\u0103rul format din primele \\(P\\) cifre, putem s\u0103 \u00eencepem cu \\(0\\) \u0219i s\u0103 ad\u0103ug\u0103m c\u00e2te o cifr\u0103, deoarece aceste numere nu vor afecta r\u0103spunsul (un num\u0103r format din \\(P-1\\) cifre este mereu mai mic dec\u00e2t un num\u0103r format din \\(P\\) cifre).</p> <p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;fstream&gt;\n\nusing namespace std;\n\nifstream fin(\"aur.in\");\nofstream fout(\"aur.out\");\n\nint main() {\n    int cerinta, n;\n    fin &gt;&gt; cerinta &gt;&gt; n;\n\n    if (cerinta == 1) {\n        int cnt = 0;\n        char c;\n        while (fin &gt;&gt; c) {\n            cnt++;\n        }\n\n        fout &lt;&lt; cnt;\n    } else if (cerinta == 2) {\n        int k;\n        fin &gt;&gt; k;\n        int cnt = 0;\n        char c;\n        while (fin &gt;&gt; c) {\n            cnt++;\n\n            if (cnt == k) {\n                fout &lt;&lt; c;\n            }\n        }\n    } else {\n        int k;\n        fin &gt;&gt; k;\n\n        int put = 1;\n        while (k &gt; 0) {\n            put *= 10;\n            k--;\n        }\n\n        int nr = 0, maxim = 0;\n        char c;\n        while (fin &gt;&gt; c) {\n            nr = nr * 10 + c - '0';\n            nr = nr % put;\n\n            if (nr &gt; maxim) {\n                maxim = nr;\n            }\n        }\n\n        fout &lt;&lt; maxim;\n    }\n\n    return 0;\n}\n</code></pre>","tags":["OJI","clasa V","cifre","citire caractere"]},{"location":"olimpiada/solutii/OJI/2019/V-cartele/","title":"Solu\u021bia problemei cartele (OJI 2019, clasa a V-a)","text":"","tags":["OJI","clasa V","timp"]},{"location":"olimpiada/solutii/OJI/2019/V-cartele/#cerinta-1","title":"Cerin\u021ba 1","text":"<p>C\u00e2t timp parcurgem evenimentele, men\u021binem doi contori pentru num\u0103rul de b\u0103ie\u021bi, respectiv num\u0103rul de fete din \u0219coal\u0103 la momentul respectiv, \u0219i \u00eei actualiz\u0103m corespunz\u0103tor evenimentului citit.</p>","tags":["OJI","clasa V","timp"]},{"location":"olimpiada/solutii/OJI/2019/V-cartele/#cerinta-2","title":"Cerin\u021ba 2","text":"<p>Men\u021binem aceia\u0219i doi contori de la cerin\u021ba 1.</p> <p>Observa\u021bia important\u0103 este c\u0103, dac\u0103 la un moment dat num\u0103rul de fete este egal cu num\u0103rul de b\u0103ie\u021bi, dup\u0103 urm\u0103torul eveniment aceste dou\u0103 numere nu vor mai fi egale. A\u0219a c\u0103 vom men\u021bine \u0219i \u00eenc\u0103 dou\u0103 variabile, care s\u0103 ne spun\u0103 dac\u0103 la evenimentul precedent num\u0103rul de b\u0103ie\u021bi este egal cu num\u0103rul de fete, respectiv timpul (\u00een secunde) al ultimului eveniment de acest fel.</p>","tags":["OJI","clasa V","timp"]},{"location":"olimpiada/solutii/OJI/2019/V-cartele/#cerinta-3","title":"Cerin\u021ba 3","text":"<p>Men\u021binem aceia\u0219i doi contori ca la cerin\u021ba 1 \u0219i \u00eenc\u0103 dou\u0103 variabile care ne vor spune dac\u0103 la ultimul eveniment am avut un num\u0103r impar de b\u0103ie\u021bi \u0219i pentru c\u00e2t timp a fost acest num\u0103r de b\u0103ie\u021bi impar. C\u00e2nd num\u0103rul de b\u0103ie\u021bi devine par, timpul se reseteaz\u0103 la 0 \u0219i variabila cealalt\u0103 va fi setat\u0103 la fals.</p> <p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;fstream&gt;\n\nusing namespace std;\n\nifstream fin(\"cartele.in\");\nofstream fout(\"cartele.out\");\n\nint main() {\n    int cerinta, n;\n    fin &gt;&gt; cerinta &gt;&gt; n;\n\n    if (cerinta == 1) {\n        int baieti = 0, fete = 0;\n        for (int i = 0; i &lt; n; i++) {\n            char g, c;\n            int h, m, s;\n            fin &gt;&gt; g &gt;&gt; c &gt;&gt; h &gt;&gt; m &gt;&gt; s;\n\n            if (g == 'b') {\n                if (c == 'i') {\n                    baieti++;\n                } else {\n                    baieti--;\n                }\n            } else {\n                if (c == 'i') {\n                    fete++;\n                } else {\n                    fete--;\n                }\n            }\n        }\n\n        fout &lt;&lt; baieti &lt;&lt; ' ' &lt;&lt; fete;\n    } else if (cerinta == 2) {\n        int baieti = 0, fete = 0, bine = false, ps, maxim = 0;\n        for (int i = 0; i &lt; n; i++) {\n            char g, c;\n            int h, m, s;\n            fin &gt;&gt; g &gt;&gt; c &gt;&gt; h &gt;&gt; m &gt;&gt; s;\n\n            if (g == 'b') {\n                if (c == 'i') {\n                    baieti++;\n                } else {\n                    baieti--;\n                }\n            } else {\n                if (c == 'i') {\n                    fete++;\n                } else {\n                    fete--;\n                }\n            }\n\n            if (bine) {\n                bine = false;\n                maxim += s + 60 * m + 60 * 60 * h - ps;\n            }\n\n            if (baieti == fete &amp;&amp; baieti != 0) {\n                bine = true;\n                ps = s + 60 * m + 60 * 60 * h;\n            }\n        }\n\n        fout &lt;&lt; maxim;\n    } else {\n        int baieti = 0, fete = 0, bine = false, ps, maxim = 0, aux = 0, cs;\n        for (int i = 0; i &lt; n; i++) {\n            char g, c;\n            int h, m, s;\n            fin &gt;&gt; g &gt;&gt; c &gt;&gt; h &gt;&gt; m &gt;&gt; s;\n\n            if (g == 'b') {\n                if (c == 'i') {\n                    baieti++;\n                } else {\n                    baieti--;\n                }\n            } else {\n                if (c == 'i') {\n                    fete++;\n                } else {\n                    fete--;\n                }\n            }\n\n            if (bine &amp;&amp; baieti % 2 == 0) {\n                cs = s + 60 * m + 60 * 60 * h;\n                maxim = max(maxim, cs - ps + aux);\n            }\n\n            if (baieti % 2) {\n                if (bine) {\n                    aux += cs - ps;\n                } else {\n                    aux = 0;\n                }\n\n                bine = true;\n                ps = s + 60 * m + 60 * 60 * h;\n            } else {\n                bine = false;\n            }\n        }\n\n        fout &lt;&lt; maxim;\n    }\n\n    return 0;\n}\n</code></pre>","tags":["OJI","clasa V","timp"]},{"location":"olimpiada/solutii/OJI/2019/VI-album/","title":"Solu\u021bia problemei album (OJI 2019, clasa a VI-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["OJI","clasa VI"]},{"location":"olimpiada/solutii/OJI/2019/VI-album/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["OJI","clasa VI"]},{"location":"olimpiada/solutii/OJI/2019/VI-maxim/","title":"Solu\u021bia problemei maxim (OJI 2019, clasa a VI-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["OJI","clasa VI"]},{"location":"olimpiada/solutii/OJI/2019/VI-maxim/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["OJI","clasa VI"]},{"location":"olimpiada/solutii/OJI/2019/VII-poarta/","title":"Solu\u021bia problemei poarta (OJI 2019, clasa a VII-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["OJI","clasa VII"]},{"location":"olimpiada/solutii/OJI/2019/VII-poarta/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["OJI","clasa VII"]},{"location":"olimpiada/solutii/OJI/2019/VII-valutar/","title":"Solu\u021bia problemei valutar (OJI 2019, clasa a VII-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["OJI","clasa VII"]},{"location":"olimpiada/solutii/OJI/2019/VII-valutar/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["OJI","clasa VII"]},{"location":"olimpiada/solutii/OJI/2019/VIII-cate3cifre/","title":"Solu\u021bia problemei cate3cifre (OJI 2019, clasa a VIII-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["OJI","clasa VIII"]},{"location":"olimpiada/solutii/OJI/2019/VIII-cate3cifre/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["OJI","clasa VIII"]},{"location":"olimpiada/solutii/OJI/2019/VIII-paralele/","title":"Solu\u021bia problemei paralele (OJI 2019, clasa a VIII-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["OJI","clasa VIII"]},{"location":"olimpiada/solutii/OJI/2019/VIII-paralele/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["OJI","clasa VIII"]},{"location":"olimpiada/solutii/OJI/2019/X-pif/","title":"Solu\u021bia problemei pif (OJI 2019, clasa a X-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["OJI","clasa X"]},{"location":"olimpiada/solutii/OJI/2019/X-pif/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["OJI","clasa X"]},{"location":"olimpiada/solutii/OJI/2019/X-traseu/","title":"Solu\u021bia problemei traseu (OJI 2019, clasa a X-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["OJI","clasa X"]},{"location":"olimpiada/solutii/OJI/2019/X-traseu/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["OJI","clasa X"]},{"location":"olimpiada/solutii/OJI/2019/X-yinyang/","title":"Solu\u021bia problemei yinyang (OJI 2019, clasa a X-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["OJI","clasa X"]},{"location":"olimpiada/solutii/OJI/2019/X-yinyang/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["OJI","clasa X"]},{"location":"olimpiada/solutii/OJI/2019/XI-XII-conexidad/","title":"Solu\u021bia problemei conexidad (OJI 2019, clasele XI-XII)","text":"<p>Pentru a rezolva aceast\u0103 problem\u0103, ne putem g\u00e2ndi mai \u00eent\u00e2i s\u0103 afl\u0103m componentele conexe, \u00eempreun\u0103 cu dimensiunile lor.</p> <p>O prim\u0103 idee pe care o putem folosi este aceea de a conecta componentele conexe \u00eentr-un lan\u021b, ceea ce duce s\u0103 avem \\(max_{extra} = 2\\). De\u0219i aceasta este o solu\u021bie rezonabil\u0103, nu este suficient de bun\u0103 pentru a ob\u021bine punctajul maxim, deoarece putem ob\u021bine rezultate mai bune folosind un alt algoritm.</p> <p>Acum, \u00eentrebarea se pune cum putem ob\u021bine \\(max_{extra} = 1\\). Cu alte cuvinte, vrem s\u0103 putem conecta componentele conexe f\u0103r\u0103 s\u0103 folosim un nod de dou\u0103 ori. Cu alte cuvinte, vrem s\u0103 avem c\u00e2t mai multe variante s\u0103 folosim un nod nou atunci c\u00e2nd avem o alt\u0103 component\u0103 conex\u0103 pe care o folosim.</p> <p>Acest lucru ne duce cu g\u00e2ndul la o sortare \u00een ordine descresc\u0103toare dup\u0103 dimensiunea componentelor conexe, iar la un anumit pas, p\u0103str\u0103m nodurile care nu au fost conectate \u00eenc\u0103 cu o muchie nou\u0103 \u0219i folosim unul din aceste noduri pentru a conecta noua component\u0103 conex\u0103, iar mai apoi ad\u0103ug\u0103m celelalte noduri \u00een lista noastr\u0103.</p> <p>Deoarece dimensiunea datelor de intrare este mic\u0103, complexitatea nu este foarte relevant\u0103 pentru calculele problemei, dar acest algoritm poate fi \u00eembun\u0103t\u0103\u021bit pentru restric\u021bii mult mai mari ale datelor de intrare.</p> <p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;algorithm&gt;\n#include &lt;fstream&gt;\n#include &lt;vector&gt;\n\nint n, m, cc[102], nrcc, max_extra = 1, frq[102], ord[102];\nbool viz[102], ad[102];\n\nstd::vector&lt;std::vector&lt;int&gt;&gt; v, compc;\n\nvoid dfs(int nod) {\n    compc[nrcc].push_back(nod);\n    viz[nod] = 1;\n    for (int i = 0; i &lt; (int)v[nod].size(); ++i) {\n        int vecin = v[nod][i];\n        if (!viz[vecin]) {\n            dfs(vecin);\n        }\n    }\n}\nbool cmp(int a, int b) { return (int)compc[a].size() &lt; (int)compc[b].size(); }\n\nint main() {\n    std::ifstream cin(\"conexidad.in\");\n    std::ofstream cout(\"conexidad.out\");\n\n    cin &gt;&gt; n &gt;&gt; m;\n\n    v.resize(n + 1);\n    compc.resize(n + 1);\n    for (int i = 1; i &lt;= m; ++i) {\n        int a, b;\n        cin &gt;&gt; a &gt;&gt; b;\n        v[a].push_back(b);\n        v[b].push_back(a);\n    }\n    for (int i = 1; i &lt;= n; ++i) {\n        if (!viz[i]) {\n            ++nrcc;\n            dfs(i);\n        }\n    }\n    for (int i = 1; i &lt;= nrcc; ++i) {\n        ord[i] = i;\n    }\n    std::vector&lt;std::pair&lt;int, int&gt;&gt; ans;\n    std::sort(ord + 1, ord + nrcc + 1, cmp);\n    std::vector&lt;int&gt; pos;\n    for (int i = nrcc; i &gt;= 1; --i) {\n        int z = ord[i];\n        if (i == nrcc) {\n            for (int j = 0; j &lt; (int)compc[z].size(); ++j) {\n                pos.push_back(compc[z][j]);\n            }\n            continue;\n        }\n        int mn = 105;\n        int el = 0;\n        for (int j = 0; j &lt; (int)pos.size(); ++j) {\n            if (frq[pos[j]] &lt; mn) {\n                mn = frq[pos[j]];\n                el = pos[j];\n            }\n        }\n        ans.push_back({el, compc[z][0]});\n        frq[el]++, frq[compc[z][0]]++;\n        max_extra = std::max(max_extra, std::max(frq[el], frq[compc[z][0]]));\n        for (int j = 0; j &lt; (int)compc[z].size(); ++j) {\n            pos.push_back(compc[z][j]);\n        }\n    }\n    cout &lt;&lt; max_extra &lt;&lt; '\\n';\n    cout &lt;&lt; nrcc - 1 &lt;&lt; '\\n';\n    for (int i = 0; i &lt; (int)ans.size(); ++i) {\n        cout &lt;&lt; ans[i].first &lt;&lt; \" \" &lt;&lt; ans[i].second &lt;&lt; '\\n';\n    }\n    return 0;\n}\n</code></pre>","tags":["OJI","clasa XI-XII","grafuri","sortare"]},{"location":"olimpiada/solutii/OJI/2019/XI-XII-rufe/","title":"Solu\u021bia problemei rufe (OJI 2019, clasele XI-XII)","text":"<p>Pentru a rezolva aceast\u0103 problem\u0103, ne putem g\u00e2ndi mai \u00eent\u00e2i la o solu\u021bie \u00eenceat\u0103, care va calcula pentru fiecare punct distan\u021ba de la punctul central la toate celelalte puncte, le ordoneaz\u0103 cresc\u0103tor \u0219i ia cele mai mari \\(k\\), afi\u0219\u00e2nd distan\u021ba corespunz\u0103toare.</p> <p>Totu\u0219i, aceast\u0103 abordare este foarte \u00eenceat\u0103 \u0219i nu ne va aduce punctajul maxim. Astfel, vom vrea s\u0103 ne g\u00e2ndim la optimiz\u0103ri. \u00cen primul r\u00e2nd, o idee pe care o putem explora este aceea c\u0103 dac\u0103 ne g\u00e2ndim la o linie sau o coloan\u0103, distan\u021ba de la origine la punctele de pe acea linie/coloan\u0103 sunt mai \u00eent\u00e2i descresc\u0103toare, iar mai apoi cresc\u0103toare, cu punctul paralel cu originea fiind cel mai apropiat de aceasta.</p> <p>Aceast\u0103 distribu\u021bie a distan\u021belor ne duce cu g\u00e2ndul la a reprezenta aceste regiuni ale matricii, \u00eemp\u0103r\u021bind astfel suprafa\u021ba \u00een patru zone, pentru care putem simplifica r\u0103spunsurile foarte mult, dup\u0103 modelul de mai jos.</p> <p></p> <p>Apoi, deoarece cu c\u00e2t ne apropiem mai mult de origine, vom acoperi tot mai multe puncte, ne putem g\u00e2ndi la o c\u0103utare binar\u0103 pe r\u0103spuns, scopul nostru este s\u0103 afl\u0103m num\u0103rul de puncte aflate la o distan\u021b\u0103 mai mare dec\u00e2t valoarea \u021bint\u0103.</p> <p>Deoarece am \u00eemp\u0103r\u021bit \u00een patru regiuni, este \u00eendeajuns s\u0103 afl\u0103m aria suprafe\u021belor acoperite, care se reduce la aria unor triunghiuri cu puncte \u00een jurul col\u021burilor cele mai \u00eendep\u0103rtate, un exemplu fiind ar\u0103tat mai jos.</p> <p></p> <p>Folosind formulele pentru aria unui triunghi dreptunghic (mai multe detalii pute\u021bi g\u0103si \u00een implementare, num\u0103rul de cazuri necesare devine mult mai mic, implementarea devenind mult mai facil\u0103).</p> <p>Astfel, solu\u021bia voastr\u0103 va rula \u00een timp logaritmic, fiind \u00eendeajuns de rapid\u0103 pentru ob\u021binerea celor 100 de puncte.</p> <p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;fstream&gt;\n\nstruct Rect {\n    long long cornerVal;\n    int height, width;\n};\n\nint N, M, A, B;\nlong long K;\nRect rects[4];\n\nlong long tri(long long n) { return n * (n + 1) / 2; }\n\nbool check(long long val) {\n    long long total = 0;\n    for (int i = 0; i &lt; 4; i++) {\n        long long cornerVal = rects[i].cornerVal;\n        long long height = rects[i].height;\n        long long width = rects[i].width;\n        if (cornerVal &lt; val) {\n            continue;\n        }\n        long long dist = cornerVal - val + 1;\n        long long cur = tri(dist);\n        if (dist &gt; height) {\n            cur -= tri(dist - height);\n        }\n        if (dist &gt; width) {\n            cur -= tri(dist - width);\n        }\n        total += cur;\n    }\n    return (total &gt;= K);\n}\n\nint main() {\n    std::ifstream cin(\"rufe.in\");\n    std::ofstream cout(\"rufe.out\");\n\n    cin &gt;&gt; N &gt;&gt; M &gt;&gt; A &gt;&gt; B &gt;&gt; K;\n    rects[0] = {A + B - 2, A - 1, B - 1};\n    rects[1] = {A + (M - B) - 1, A - 1, (M - B) + 1};\n    rects[2] = {(N - A) + B - 1, (N - A) + 1, B - 1};\n    rects[3] = {(N - A) + (M - B), (N - A) + 1, (M - B) + 1};\n    long long low = 0, high = 2e9;\n    while (low &lt; high) {\n        int mid = (low + high + 1) / 2;\n        if (check(mid)) {\n            low = mid;\n        } else {\n            high = mid - 1;\n        }\n    }\n    cout &lt;&lt; low &lt;&lt; \"\\n\";\n}\n</code></pre>","tags":["OJI","clasa XI-XII","cautare binara","matematica"]},{"location":"olimpiada/solutii/OJI/2019/XI-XII-tairos/","title":"Solu\u021bia problemei tairos (OJI 2019, clasele XI-XII)","text":"<p>Pentru a rezolva aceast\u0103 problem\u0103, trebuie s\u0103 ne g\u00e2ndim mai \u00eent\u00e2i la o precalculare pe baza arborelui ini\u021bial. Astfel, putem face o parcurgere de tip DFS s\u0103 afl\u0103m pentru arborele dat c\u00e2te noduri \u0219i c\u00e2te frunze (excluz\u00e2nd r\u0103d\u0103cina) se afl\u0103 pe fiecare nivel, acest lucru fiind realizabil f\u0103r\u0103 prea mari probleme.</p> <p>Motivul pentru care este important s\u0103 num\u0103r\u0103m \u0219i frunzele de pe un anumit nivel este acela c\u0103 din frunze, putem genera noi arbori conform construc\u021biei men\u021bionate \u00een cerin\u021ba problemei.</p> <p>Ulterior, nevoia de a num\u0103ra nodurile aflate la o anumit\u0103 distan\u021b\u0103 face natural\u0103 folosirea unei dinamici pentru a num\u0103ra nodurile \u0219i frunzele de pe un anumit nivel.</p> <p>Astfel, ne putem g\u00e2ndi la o serie de st\u0103ri de tipul urm\u0103tor:</p> <ul> <li>\\(dst[i]\\) - num\u0103rul de noduri aflate la nivelul \\(i\\) \u00een arborele ini\u021bial.</li> <li>\\(leaves[i]\\) - num\u0103rul de frunze aflate la nivelul \\(i\\) \u00een arborele ini\u021bial.</li> <li>\\(dp[i]\\) - num\u0103rul de noduri aflate la nivelul \\(i\\) \u00een arborele infinit.</li> <li>\\(cntleaves[i]\\) - num\u0103rul de frunze aflate la nivelul \\(i\\) \u00een arborele infinit.</li> </ul> <p>Astfel, pentru a calcula \\(dp[i]\\) \u0219i \\(cntleaves[i]\\), ne putem duce \u00eenapoi pe urma nivelelor \u0219i s\u0103 adun\u0103m produsele dintre valorile de pe nivelurile precedente \u0219i num\u0103rul de frunze de la un anumit nivel.</p> <p>Complexitatea final\u0103 a solu\u021biei va fi \\(\\mathcal{O}(n \\cdot d)\\), iar ca un detaliu suplimentar, trebuie s\u0103 fim aten\u021bi \u00een ceea ce prive\u0219te opera\u021biile cu modulo, deoarece r\u0103spunsurile pot deveni foarte mari.</p> <p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;fstream&gt;\n#include &lt;vector&gt;\n\nconst int mod = 1000000007;\n\nint n, d, dst[102], leaves[102];\nstd::vector&lt;int&gt; v[102];\nlong long dp[10002], cntleaves[10002];\n\nvoid dfs(int parent, int node, int lvl) {\n    dst[lvl]++;\n    bool leaf = 1;\n    if (node == 1) {\n        leaf = 0;\n    }\n    for (int i = 0; i &lt; (int)v[node].size(); ++i) {\n        int vecin = v[node][i];\n        if (vecin == parent) {\n            continue;\n        }\n        dfs(node, vecin, lvl + 1);\n        leaf = 0;\n    }\n    if (leaf) {\n        leaves[lvl]++;\n    }\n}\n\nint main() {\n    std::ifstream cin(\"tairos.in\");\n    std::ofstream cout(\"tairos.out\");\n\n    cin &gt;&gt; n &gt;&gt; d;\n    for (int i = 1; i &lt; n; ++i) {\n        int a, b;\n        cin &gt;&gt; a &gt;&gt; b;\n        v[a].push_back(b);\n        v[b].push_back(a);\n    }\n    dfs(0, 1, 0);\n    for (int i = 0; i &lt; n; ++i) {\n        dp[i] = dst[i];\n        cntleaves[i] = leaves[i];\n    }\n    for (int i = 0; i &lt;= d; ++i) {\n        if (!cntleaves[i]) {\n            continue;\n        }\n        for (int j = i + 1; j &lt;= std::min(d, i + n); ++j) {\n            dp[j] = (dp[j] + 1LL * cntleaves[i] * dst[j - i]) % mod;\n            cntleaves[j] =\n                (cntleaves[j] + 1LL * cntleaves[i] * leaves[j - i]) % mod;\n        }\n    }\n    cout &lt;&lt; dp[d] &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["OJI","clasa XI-XII","programare dinamica","arbori"]},{"location":"olimpiada/solutii/OJI/2020/IX-buldo/","title":"Solu\u021bia problemei buldo (OJI 2020, clasa a IX-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["OJI","clasa IX"]},{"location":"olimpiada/solutii/OJI/2020/IX-buldo/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["OJI","clasa IX"]},{"location":"olimpiada/solutii/OJI/2020/IX-cetate/","title":"Solu\u021bia problemei cetate (OJI 2020, clasa a IX-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["OJI","clasa IX"]},{"location":"olimpiada/solutii/OJI/2020/IX-cetate/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["OJI","clasa IX"]},{"location":"olimpiada/solutii/OJI/2020/IX-spiralmatrix/","title":"Solu\u021bia problemei spiralmatrix (OJI 2020, clasa a IX-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["OJI","clasa IX"]},{"location":"olimpiada/solutii/OJI/2020/IX-spiralmatrix/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["OJI","clasa IX"]},{"location":"olimpiada/solutii/OJI/2020/V-cartonase/","title":"Solu\u021bia problemei cartonase (OJI 2020, clasa a V-a)","text":"<p>Se citesc numerele de pe cartona\u0219e, re\u021bin\u00e2nd la un moment dat numerele de pe dou\u0103 cartona\u0219e al\u0103turate (citite consecutiv), anume cartona\u0219ul precedent \u0219i cel curent.</p> <p>Pentru a rezolva cerin\u021ba 1, folosim un contor pentru a verifica c\u00e2te dintre perechile de cartona\u0219e se potrivesc (mai precis, dac\u0103 cap\u0103tul dreapta precedent este egal cu cap\u0103tul st\u00e2nga curent).</p> <p>Pentru cerin\u021bele 2 \u0219i 3, vom proceda similar, singura diferen\u021b\u0103 fiind faptul c\u0103 vom p\u0103stra num\u0103rul de perechi consecutive valide, precum \u0219i lungimea maxim\u0103 a unei asemenea secven\u021be.</p> <p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;fstream&gt;\nusing namespace std;\n\nifstream fin(\"cartonase.in\");\nofstream fout(\"cartonase.out\");\n\nint c, n, i, lp, rp, l, r, cnt, lg, lgmax;\n\nint main() {\n    fin &gt;&gt; c &gt;&gt; n;\n\n    if (c == 1) {\n        fin &gt;&gt; lp &gt;&gt; rp;\n        for (i = 2; i &lt;= n; i++) {\n            fin &gt;&gt; l &gt;&gt; r;\n            if (l == rp) {\n                cnt++;\n            }\n            lp = l, rp = r;\n        }\n        fout &lt;&lt; cnt &lt;&lt; '\\n';\n    } else if (c == 2) {\n        fin &gt;&gt; lp &gt;&gt; rp;\n        lg = 1;\n        for (i = 2; i &lt;= n; i++) {\n            fin &gt;&gt; l &gt;&gt; r;\n            if (l == rp) {\n                lg++;\n                if (lg &gt; lgmax) {\n                    lgmax = lg;\n                }\n            } else {\n                lg = 1;\n            }\n            lp = l, rp = r;\n        }\n        fout &lt;&lt; lgmax &lt;&lt; '\\n';\n    } else {\n        fin &gt;&gt; lp &gt;&gt; rp;\n        lg = 1;\n        for (i = 2; i &lt;= n; i++) {\n            fin &gt;&gt; l &gt;&gt; r;\n            if (l == rp) {\n                lg++;\n                if (lg &gt; lgmax) {\n                    lgmax = lg;\n                    cnt = 1;\n                } else if (lg == lgmax) {\n                    cnt++;\n                }\n            } else {\n                lg = 1;\n            }\n            lp = l, rp = r;\n        }\n        fout &lt;&lt; cnt &lt;&lt; '\\n';\n    }\n    return 0;\n}\n</code></pre>","tags":["OJI","clasa V"]},{"location":"olimpiada/solutii/OJI/2020/V-tai/","title":"Solu\u021bia problemei tai (OJI 2020, clasa a V-a)","text":"<p>Pentru a verifica dac\u0103 un num\u0103r este prim sau nu, folosim un algoritm de num\u0103rare al divizorilor sau un algoritm care afl\u0103 primul divizor propriu, iar \u00een func\u021bie de implementare, se pot ob\u021bine punctaje par\u021biale.</p> <p>Pentru a ob\u021bine punctajul maxim, este optim s\u0103 verific\u0103m dac\u0103 un num\u0103r este prim folosind algoritmul clasic de aflare al divizorilor \u00een \\(\\sqrt n\\).</p> <p>\u0218tim deja conform propriet\u0103\u021bilor divizorilor c\u0103 dac\u0103 un num\u0103r \\(n\\) are un divizor propriu mai mic sau egal cu \\(\\sqrt n\\), atunci nu este prim.</p> <p>Pentru a rezolva cerin\u021bele \\(2\\) \u0219i \\(3\\), vom \u00eemp\u0103r\u021bi numerele \u00een buc\u0103\u021bi folosind structuri repetitive de tip for, care s\u0103 proceseze fiecare bucat\u0103 \u00een parte \u0219i s\u0103 verifice primalitatea numerelor folosind algoritmul descris mai sus. Dac\u0103 \u0219ti\u021bi deja s\u0103 lucra\u021bi cu vectori, acest lucru poate fi f\u0103cut chiar mai u\u0219or deoarece v\u0103 pute\u021bi afla numerele parcurg\u00e2nd cifrele de la cap\u0103tul din st\u00e2nga la cel din dreapta.</p> <p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim care nu foloseste vectori.</p> <pre><code>#include &lt;fstream&gt;\n#include &lt;iostream&gt;\n\nusing namespace std;\n\nifstream fin(\"tai.in\");\nofstream fout(\"tai.out\");\n\nbool este_prim(int n) {\n    if (n &lt; 2) {\n        return false;\n    }\n    int a = 2;\n    while (a * a &lt;= n) {\n        if (n % a == 0) {\n            return false;\n        }\n        a++;\n    }\n    return true;\n}\n\nint main() {\n    int c, n, x;\n    fin &gt;&gt; c &gt;&gt; n;\n\n    if (c == 1) {\n        int vmax = 0;\n        for (int i = 1; i &lt;= n; i++) {\n            fin &gt;&gt; x;\n            if (este_prim(x)) {\n                if (x &gt; vmax) {\n                    vmax = x;\n                }\n            }\n        }\n        fout &lt;&lt; vmax;\n    } else if (c == 2) {\n        int vmax = 0;\n        for (int i = 1; i &lt;= n; i++) {\n            fin &gt;&gt; x;\n            int cif = 1, aux = 1;\n            int j = 1;\n            while (aux &gt; 0) {\n                cif = x % (j * 10);\n                aux = x / (j * 10);\n                if (aux &gt; 0) {\n                    if (este_prim(cif)) {\n                        if (cif &gt; vmax) {\n                            vmax = cif;\n                        }\n                    }\n                    if (este_prim(aux)) {\n                        if (aux &gt; vmax) {\n                            vmax = aux;\n                        }\n                    }\n                }\n                j *= 10;\n            }\n        }\n        fout &lt;&lt; vmax;\n    } else {\n        int vmax = 0;\n        for (int i = 1; i &lt;= n; i++) {\n            fin &gt;&gt; x;\n            for (int a = 10; a &lt;= x; a *= 10) {\n                for (int b = a * 10; b &lt;= x; b *= 10) {\n                    int st = x % a;\n                    int mij = (x % b) / a;\n                    int dr = x / b;\n                    if (este_prim(st)) {\n                        if (vmax &lt; st) {\n                            vmax = st;\n                        }\n                    }\n                    if (este_prim(mij)) {\n                        if (vmax &lt; mij) {\n                            vmax = mij;\n                        }\n                    }\n                    if (este_prim(dr)) {\n                        if (vmax &lt; dr) {\n                            vmax = dr;\n                        }\n                    }\n                }\n            }\n        }\n        fout &lt;&lt; vmax;\n    }\n\n    return 0;\n}\n</code></pre>","tags":["OJI","clasa V","divizibilitate"]},{"location":"olimpiada/solutii/OJI/2020/VI-forta/","title":"Solu\u021bia problemei forta (OJI 2020, clasa a VI-a)","text":"<p>Pentru a afla for\u021ba maxim\u0103 a unei valori din \u0219ir, trebuie s\u0103 afl\u0103m eficient pentru fiecare num\u0103r c\u00e2\u021bi divizori are. Acest lucru poate fi f\u0103cut fie folosind algoritmul consacrat p\u00e2n\u0103 la radicalul unui num\u0103r, fie folosind o optimizare a ciurului lui Eratostene, \u00een care afl\u0103m numerele prime p\u00e2n\u0103 la \\(45000\\) \u0219i mai apoi afl\u0103m descompunerea \u00een factori primi ai acelui num\u0103r, folosind formula descris\u0103 \u00een articolul de mai sus despre divizibilitate.</p> <p>Deoarece limita de timp este una str\u00e2ns\u0103, trebuie s\u0103 avem grij\u0103 la implementare pentru a putea afla eficient num\u0103rul de divizori, precum \u0219i num\u0103rul maxim de valori cu acela\u0219i num\u0103r de divizori.</p> <p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;cmath&gt;\n#include &lt;iostream&gt;\nusing namespace std;\n\nconst int MAX_N = 100000;\nint arr[MAX_N];\n\nconst int MAX_SIEVE = 45000;\nbool isPrimeSieve[MAX_SIEVE + 1];\nint primes[50000];\nint primesCount;\n\nvoid buildSieve() {\n    for (int i = 0; i &lt;= MAX_SIEVE; i++) {\n        isPrimeSieve[i] = true;\n    }\n    isPrimeSieve[0] = isPrimeSieve[1] = false;\n    for (int i = 2; i * i &lt;= MAX_SIEVE; i++) {\n        if (isPrimeSieve[i]) {\n            for (int j = i * i; j &lt;= MAX_SIEVE; j += i) {\n                isPrimeSieve[j] = false;\n            }\n        }\n    }\n    primesCount = 0;\n    for (int i = 2; i &lt;= MAX_SIEVE; i++) {\n        if (isPrimeSieve[i]) {\n            primes[primesCount++] = i;\n        }\n    }\n}\n\nint getForce(int x) {\n    int force = 1;\n    int temp = x;\n    for (int i = 0; i &lt; primesCount &amp;&amp; (long long)primes[i] * primes[i] &lt;= temp;\n         i++) {\n        if (temp % primes[i] == 0) {\n            int cnt = 0;\n            while (temp % primes[i] == 0) {\n                cnt++;\n                temp /= primes[i];\n            }\n            force *= (cnt + 1);\n        }\n    }\n    if (temp &gt; 1) {\n        force *= 2;\n    }\n    return force;\n}\n\nint main() {\n    ifstream cin(\"forta.in\");\n    ofstream cout(\"forta.out\");\n\n    int task, n;\n    cin &gt;&gt; task &gt;&gt; n;\n\n    for (int i = 0; i &lt; n; i++) {\n        cin &gt;&gt; arr[i];\n    }\n\n    buildSieve();\n\n    if (task == 1) {\n        int maxForce = -1;\n        int bestNumber = 0;\n        for (int i = 0; i &lt; n; i++) {\n            int f = getForce(arr[i]);\n            if (f &gt; maxForce) {\n                maxForce = f;\n                bestNumber = arr[i];\n            } else {\n                if (f == maxForce) {\n                    if (arr[i] &lt; bestNumber) {\n                        bestNumber = arr[i];\n                    }\n                }\n            }\n        }\n        cout &lt;&lt; bestNumber;\n    } else if (task == 2) {\n        const int MAXF = 2500;\n        int freq[MAXF + 1] = {0};\n\n        int maxCount = 0;\n        for (int i = 0; i &lt; n; i++) {\n            int f = getForce(arr[i]);\n            freq[f]++;\n            if (freq[f] &gt; maxCount) {\n                maxCount = freq[f];\n            }\n        }\n        cout &lt;&lt; maxCount;\n    }\n\n    return 0;\n}\n</code></pre>","tags":["OJI","clasa VI","numere prime","ciur"]},{"location":"olimpiada/solutii/OJI/2020/VI-furnica/","title":"Solu\u021bia problemei furnica (OJI 2020, clasa a VI-a)","text":"<p>Pentru rezolvarea problemei identific\u0103m pe traseul furnicii por\u021biunile \u00een care furnica urc\u0103 cu c\u00e2te un centimetru \u00een fiecare 5 secunde, por\u021biunile de pe traseu \u00een care coboar\u0103 c\u00e2te un centimetru la fiecare 2 secunde precum si por\u021biunile de pe traseu \u00een care se deplaseaz\u0103 pe orizontal\u0103 cu c\u00e2te un centimetru la fiecare 3 secunde.</p> <p>Furnica urc\u0103 pe latura vertical\u0103 a primei foi, apoi parcurge conform traseului specificat, fiecare foaie.</p> <p>Pentru a identifica tipul por\u0163iunii (urcare, cobor\u00e2re, deplasare pe orizontal\u0103) compar\u0103m laturile foii curente \\(K\\), cu laturile foii anterioare \\(K-1\\).</p> <p>La cerin\u021ba 1, calcul\u0103m timpul necesar furnicii pentru fiecare por\u021biune din traseul s\u0103u, cu ajutorul unei variabile sumative care are urm\u0103toarea formul\u0103:</p> <p>\\(Timp=5*(portiune_{urcare})+2*(portiune_{cobor\u00e2re})+3*(portiune_{orizontal\u0103})\\)</p> <p>La cerin\u021ba 2, identific\u0103m doar por\u021biunile de pe traseul \u00een care aceasta se deplaseaz\u0103 doar pe orizontal\u0103 sau pe vertical\u0103 (\u00een urcare) \u0219i calcul\u0103m cea mai mare lungime (exprimat\u0103 \u00een centimetri) a unei por\u021biuni continue de pe traseul furnicii ce respect\u0103 condi\u0163iile din cerin\u0163\u0103 (furnica NU coboar\u0103).</p> <p>\u00centr-un final, la cerin\u021ba 3, contoriz\u0103m pas cu pas timpul necesar deplas\u0103rii furnicii pe traseul determinat de marginile libere ale foilor galbene, p\u00e2n\u0103 \u00een momentul \u00een care am ajuns la valoarea T. Afi\u0219\u0103m num\u0103rul de ordine al foii galbene pe care se afl\u0103 furnica \u00een acest moment.</p> <p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;fstream&gt;\nusing namespace std;\nifstream fin(\"furnica.in\");\nofstream fout(\"furnica.out\");\nlong long c, n, lun, f, rez, sum, l, lmax, cnt, k;\nint main() {\n    fin &gt;&gt; c &gt;&gt; n;\n    if (c == 1) {\n        while (n--) {\n            fin &gt;&gt; lun &gt;&gt; f;\n            if (rez &lt; f) {\n                sum += 5 * (f - rez);\n                sum += 3 * lun;\n                rez = f;\n            } else if (rez &gt; f) {\n                sum += 2 * (rez - f);\n                sum += 3 * lun;\n                rez = f;\n            } else if (rez == f) {\n                sum += 3 * lun;\n            }\n        }\n        fout &lt;&lt; sum + rez * 2;\n    } else if (c == 2) {\n        while (n--) {\n            fin &gt;&gt; lun &gt;&gt; f;\n            if (rez &gt; f) {\n                if (l &gt; lmax) {\n                    lmax = l;\n                }\n                l = 0;\n                l += lun;\n                rez = f;\n            } else if (rez == f) {\n                l += lun;\n            } else if (rez &lt; f) {\n                l += lun;\n                l += (f - rez);\n                rez = f;\n            }\n        }\n        if (l &gt; lmax) {\n            lmax = l;\n        }\n        fout &lt;&lt; lmax;\n    } else {\n        fin &gt;&gt; k;\n        for (int i = 1; i &lt;= n; ++i) {\n            fin &gt;&gt; lun &gt;&gt; f;\n            if (rez &lt; f) {\n                sum += 5 * (f - rez);\n            }\n            if (rez &gt; f) {\n                sum += 2 * (rez - f);\n            }\n            if (sum &gt;= k &amp;&amp; rez &gt; f) {\n                fout &lt;&lt; i - 1;\n                return 0;\n            }\n            sum += 3 * lun;\n            if (sum &gt;= k) {\n                fout &lt;&lt; i;\n                return 0;\n            }\n            rez = f;\n        }\n        fout &lt;&lt; n;\n    }\n    return 0;\n}\n</code></pre>","tags":["OJI","clasa VI","implementare","simulare"]},{"location":"olimpiada/solutii/OJI/2020/VII-foto/","title":"Solu\u021bia problemei foto (OJI 2020, clasa a VII-a)","text":"<p>Aceast\u0103 problem\u0103 are foarte multe solu\u021bii posibile, aici voi descrie doar una dintre ele.</p> <p>Pentru a rezolva cerin\u021ba 1, vom num\u0103ra c\u00e2te celule sunt egale cu 0, acest lucru fiind \u00eendeajuns.</p> <p>La cerin\u021ba 2, noi vrem s\u0103 afl\u0103m num\u0103rul maxim de fulgere situate consecutiv, iar pentru a \u021bine num\u0103r\u0103toarea c\u00e2t mai u\u0219or, ne putem folosi de sume par\u021biale pentru fiecare pozi\u021bie, av\u00e2nd grij\u0103 la respectarea condi\u021biilor din enun\u021b.</p> <p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;fstream&gt;\nusing namespace std;\n\nint mat[105][105];\n\nint main() {\n    ifstream cin(\"foto.in\");\n    ofstream cout(\"foto.out\");\n\n    int cer, n, m, lin, col, cnt, ans, num, cer2;\n    cin &gt;&gt; cer &gt;&gt; n &gt;&gt; m;\n\n    for (lin = 1; lin &lt;= n; lin++) {\n        for (col = 1; col &lt;= m; col++) {\n            cin &gt;&gt; mat[lin][col];\n        }\n    }\n\n    ans = num = cer2 = 0;\n    for (lin = 1; lin &lt;= n; lin++) {\n        cnt = 0;\n        for (col = 1; col &lt;= m; col++) {\n            if (!mat[lin][col]) {\n                cnt++;\n            } else {\n                cnt = 0;\n            }\n\n            ans = max(ans, cnt);\n        }\n    }\n\n    for (lin = 1; lin &lt;= n; lin++) {\n        for (col = 1; col &lt;= m; col++) {\n            if (mat[lin][col]) {\n                if (mat[lin - 1][col - 1] == 0 &amp;&amp; mat[lin - 1][col + 1] == 0\n                    &amp;&amp; mat[lin - 1][col] == 0) {\n                    num++;\n                }\n                cer2 = max(cer2, (mat[lin][col] +=\n                                  (mat[lin - 1][col - 1] + mat[lin - 1][col + 1]\n                                   + mat[lin - 1][col])));\n            }\n        }\n    }\n    if (cer == 1) {\n        cout &lt;&lt; ans;\n    } else {\n        cout &lt;&lt; num &lt;&lt; \" \" &lt;&lt; cer2 &lt;&lt; \"\\n\";\n    }\n    return 0;\n}\n</code></pre>","tags":["OJI","clasa VII","sume partiale"]},{"location":"olimpiada/solutii/OJI/2020/VII-wind/","title":"Solu\u021bia problemei wind (OJI 2020, clasa a VII-a)","text":"<p>Pentru a putea \u00eemp\u0103r\u021bi cele \\(n\\) eoliene \u00een mod egal \u00een \\(k\\) ora\u0219e trebuie s\u0103 determin\u0103m divizorii num\u0103rului \\(n\\).</p> <p>La cerin\u021ba 1, se determin\u0103 num\u0103rul de divizori al lui \\(n\\). Rezultatul va fi num\u0103rul de divizori - 1 deoarece se specific\u0103 \u00een enun\u021b c\u0103 se vor construi cel pu\u021bin dou\u0103 ora\u0219e, deci \\(n\\) nu este un divizor valid.</p> <p>La cerin\u021ba 2, vom avea nevoie de sume par\u021biale pentru a afla suma energiilor corespunz\u0103toare pe primele i pozi\u021bii, \\(suma[i]\\) va reprezenta suma valorilor energiilor generate (pierdute) de centralele de la \\(1\\) la \\(i\\).</p> <p>Pentru a \u00eemp\u0103r\u021bi centralele \u00een mod corect trebuie s\u0103 detrmin\u0103m divizorii num\u0103rului \\(n\\). Pentru fiecare divizor se parcurge vectorul de sume din divizor in divizor \u0219i se calculeaz\u0103 diferen\u021ba dintre sumele de  pe pozi\u021biile respective, aleg\u00e2ndu-se \u00eemp\u0103r\u021birea optim\u0103.</p> <p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;fstream&gt;\nusing namespace std;\n\nint main() {\n    ifstream in(\"wind.in\");\n    ofstream out(\"wind.out\");\n\n    int c, n, r, rx, re, cur, x[200005];\n    long long so[200005];\n    in &gt;&gt; c &gt;&gt; n;\n    if (c == 1) {\n        r = 1;\n        for (int i = 2; i * i &lt;= n; i++) {\n            cur = 1;\n            while (!(n % i)) {\n                cur++;\n                n /= i;\n            }\n            r *= cur;\n        }\n        if (n &gt; 1) {\n            r *= 2;\n        }\n        out &lt;&lt; r - 1;\n    }\n    if (c == 2) {\n        r = -1;\n        for (int i = 0; i &lt; n; i++) {\n            in &gt;&gt; x[i];\n        }\n        for (int i = 2; i &lt;= n; i++) {\n            if (!(n % i)) {\n                long long ec = -(1LL &lt;&lt; 60), rec,\n                          mi = (1LL &lt;&lt; 60);  // (1LL &lt;&lt; 60) = 2^60, un numar\n                                             // foarte mare\n                for (int j = 0; j &lt; n; j += n / i) {\n                    so[j / (n / i)] = 0;\n                    for (int k = j; k &lt; j + n / i; k++) {\n                        so[j / (n / i)] += x[k];\n                    }\n                }\n                for (int j = 0; j &lt; i; j++) {\n                    if (so[j] &lt; mi || mi == (1LL &lt;&lt; 60)) {\n                        mi = so[j];\n                    }\n                    if (so[j] &gt;= ec || ec == -(1LL &lt;&lt; 60)) {\n                        ec = so[j];\n                        rec = j * (n / i) + 1;\n                    }\n                }\n                if (ec - mi &lt;= r || r == -1) {\n                    r = ec - mi;\n                    rx = i;\n                    re = rec;\n                }\n            }\n        }\n        out &lt;&lt; rx &lt;&lt; \" \" &lt;&lt; re;\n    }\n}\n</code></pre>","tags":["OJI","clasa VII","sume partiale","divizibilitate"]},{"location":"olimpiada/solutii/OJI/2020/VIII-datorii/","title":"Solu\u021bia problemei datorii (OJI 2020, clasa a VIII-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["OJI","clasa VIII"]},{"location":"olimpiada/solutii/OJI/2020/VIII-datorii/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["OJI","clasa VIII"]},{"location":"olimpiada/solutii/OJI/2020/VIII-triunghi/","title":"Solu\u021bia problemei triunghi (OJI 2020, clasa a VIII-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["OJI","clasa VIII"]},{"location":"olimpiada/solutii/OJI/2020/VIII-triunghi/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["OJI","clasa VIII"]},{"location":"olimpiada/solutii/OJI/2020/X-alinieri/","title":"Solu\u021bia problemei alinieri (OJI 2020, clasa a X-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["OJI","clasa X"]},{"location":"olimpiada/solutii/OJI/2020/X-alinieri/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["OJI","clasa X"]},{"location":"olimpiada/solutii/OJI/2020/X-arh/","title":"Solu\u021bia problemei arh (OJI 2020, clasa a X-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["OJI","clasa X"]},{"location":"olimpiada/solutii/OJI/2020/X-arh/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["OJI","clasa X"]},{"location":"olimpiada/solutii/OJI/2020/X-leftmax/","title":"Solu\u021bia problemei leftmax (OJI 2020, clasa a X-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["OJI","clasa X"]},{"location":"olimpiada/solutii/OJI/2020/X-leftmax/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["OJI","clasa X"]},{"location":"olimpiada/solutii/OJI/2020/XI-XII-ateleport/","title":"Solu\u021bia problemei ateleport (OJI 2020, clasele XI-XII)","text":"<p>\u00cenc\u0103 de la citirea enun\u021bului, se poate observa foarte clar faptul c\u0103 aceast\u0103 problem\u0103 va folosi \u00eentr-o oarecare m\u0103sur\u0103 cuno\u0219tin\u021bele legate de drumuri minime, mai cu seam\u0103 algoritmul lui Dijkstra.</p> <p>\u00cenainte de a explica solu\u021bii par\u021biale \u0219i implicit, solu\u021bia ce ob\u021bine punctajul maxim, vom recurge la folosirea unei observa\u021bii care se va dovedi foarte important\u0103 de-a lungul rezolv\u0103rii acestei probleme:</p> <p>Deoarece \\(L\\) \u0219i \\(K\\) sunt foarte mici, ne vom putea g\u00e2ndi la o stare care s\u0103 \u021bin\u0103 cont de num\u0103rul de teleport\u0103ri folosite p\u00e2n\u0103 acum, precum \u0219i de num\u0103rul de mut\u0103ri pe care l-am efectuat \u00een teleportarea curent\u0103 (dat fiind c\u0103 o teleportare poate fi folosit\u0103 pe o raz\u0103 de cel mult \\(L\\) noduri, ne putem g\u00e2ndi la aceast\u0103 mutare ca o mutare care ne cost\u0103 la \u00eenceput \\(P\\) secunde, iar mai apoi celelalte mut\u0103ri sunt gratis).</p> <p>Av\u00e2nd aceast\u0103 observa\u021bie \u00een minte, vom recurge la explicarea diverselor solu\u021bii, \u021bin\u00e2nd cont de faptul c\u0103 graful nostru va avea acum \\(N \\cdot K \\cdot L\\) st\u0103ri, corespunz\u0103toare fiec\u0103rui nod, num\u0103rului de teleport\u0103ri folosite \u0219i num\u0103rului de mut\u0103ri folosite \u00een teleportarea curent\u0103 (0 dac\u0103 nu folosim vreo teleportare).</p> <p>Mai \u00eent\u00e2i, pentru testele cu restric\u021bii mici, va fi \u00eendeajuns o implementare corect\u0103 a algoritmului lui Dijkstra \u00een care plec\u0103m din nodul 1 \u0219i ajungem \u00een nodul \\(n\\).</p> <p>Ba mai mult, pentru primul subtask vom putea folosi chiar un simplu algoritm de tip BFS deoarece costurile muchiilor sunt toate identice.</p> <p>Pentru a ajunge la punctajul maxim, va trebui s\u0103 folosim observa\u021bia ini\u021bial\u0103, av\u00e2nd o stare de tip \\(dp[i][j][x]\\), cu semnifica\u021bia c\u0103 avem costul minim p\u00e2n\u0103 la nodul \\(i\\), dac\u0103 am folosit \\(j\\) teleport\u0103ri \u0219i teleportarea curent\u0103 a avut \\(x\\) mut\u0103ri.</p> <p>Aceast\u0103 solu\u021bie va avea o complexitate \\(\\mathcal{O}(N \\cdot K \\cdot L \\log N)\\), fiind suficient de bun\u0103 pentru ob\u021binerea celor 100 de puncte.</p> <p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;fstream&gt;\n#include &lt;set&gt;\n#include &lt;vector&gt;\n\n#define fi first\n#define se second\n\nint n, m, p, l, k;\n\nint dp[10002][12][12];\nbool viz[10002][12][12];\n\nstd::vector&lt;std::pair&lt;int, int&gt; &gt; v[10002];\n\nvoid djk() {\n    std::set&lt;std::pair&lt;std::pair&lt;int, int&gt;, std::pair&lt;int, int&gt; &gt; &gt; s;\n    viz[1][0][0] = 1;\n    s.insert({\n        {0, 1},\n        {0, 0}\n    });\n    while (!s.empty()) {\n        std::pair&lt;std::pair&lt;int, int&gt;, std::pair&lt;int, int&gt; &gt; state = *s.begin();\n        s.erase(state);\n        int cost = state.fi.fi;\n        int node = state.fi.se;\n        int used = state.se.fi;\n        int lft = state.se.se;\n        if (lft) {\n            for (int i = 0; i &lt; (int)v[node].size(); ++i) {\n                int nxt = v[node][i].fi;\n                std::pair&lt;std::pair&lt;int, int&gt;, std::pair&lt;int, int&gt; &gt; newstate =\n                    {\n                        {cost, nxt    },\n                        {used, lft - 1}\n                };\n                if (!viz[nxt][used][lft - 1]) {\n                    viz[nxt][used][lft - 1] = 1;\n                    dp[nxt][used][lft - 1] = cost;\n                    s.insert(newstate);\n                } else if (cost &lt; dp[nxt][used][lft - 1]) {\n                    newstate.fi.fi = dp[nxt][used][lft - 1];\n                    s.erase(newstate);\n\n                    dp[nxt][used][lft - 1] = cost;\n                    newstate.fi.fi = dp[nxt][used][lft - 1];\n\n                    s.insert(newstate);\n                }\n            }\n        }\n        if (l &amp;&amp; used + 1 &lt;= k) {\n            for (int i = 0; i &lt; (int)v[node].size(); ++i) {\n                int nxt = v[node][i].fi;\n                std::pair&lt;std::pair&lt;int, int&gt;, std::pair&lt;int, int&gt; &gt; newstate =\n                    {\n                        {cost + p, nxt  },\n                        {used + 1, l - 1}\n                };\n                if (!viz[nxt][used + 1][l - 1]) {\n                    viz[nxt][used + 1][l - 1] = 1;\n                    dp[nxt][used + 1][l - 1] = cost + p;\n                    s.insert(newstate);\n                } else if (cost + p &lt; dp[nxt][used + 1][l - 1]) {\n                    newstate.fi.fi = dp[nxt][used + 1][l - 1];\n                    s.erase(newstate);\n\n                    dp[nxt][used + 1][l - 1] = cost + p;\n                    newstate.fi.fi = dp[nxt][used + 1][l - 1];\n\n                    s.insert(newstate);\n                }\n            }\n        }\n        for (int i = 0; i &lt; (int)v[node].size(); ++i) {\n            int nxt = v[node][i].fi;\n            int adcost = v[node][i].se;\n            std::pair&lt;std::pair&lt;int, int&gt;, std::pair&lt;int, int&gt; &gt; newstate = {\n                {cost + adcost, nxt},\n                {used,          0  }\n            };\n            if (!viz[nxt][used][0]) {\n                viz[nxt][used][0] = 1;\n                dp[nxt][used][0] = cost + adcost;\n                s.insert(newstate);\n            } else if (cost + adcost &lt; dp[nxt][used][0]) {\n                newstate.fi.fi = dp[nxt][used][0];\n                s.erase(newstate);\n\n                dp[nxt][used][0] = cost + adcost;\n                newstate.fi.fi = dp[nxt][used][0];\n\n                s.insert(newstate);\n            }\n        }\n    }\n}\nint main() {\n    std::ifstream cin(\"ateleport.in\");\n    std::ofstream cout(\"ateleport.out\");\n    cin &gt;&gt; n &gt;&gt; m &gt;&gt; p &gt;&gt; l &gt;&gt; k;\n    for (int i = 1; i &lt;= m; ++i) {\n        int x, y, t;\n        cin &gt;&gt; x &gt;&gt; y &gt;&gt; t;\n        v[x].push_back({y, t});\n        v[y].push_back({x, t});\n    }\n    djk();\n    int minans = (1 &lt;&lt; 30);\n    for (int i = 0; i &lt;= k; ++i) {\n        for (int j = 0; j &lt;= l; ++j) {\n            if (viz[n][i][j]) {\n                minans = std::min(minans, dp[n][i][j]);\n            }\n        }\n    }\n    cout &lt;&lt; minans &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["OJI","clasa XI-XII","dijkstra","programare dinamica"]},{"location":"olimpiada/solutii/OJI/2020/XI-XII-partit/","title":"Solu\u021bia problemei partit (OJI 2020, clasele XI-XII)","text":"<p>Pentru a rezolva aceast\u0103 problem\u0103, va trebui s\u0103 observ\u0103m mai \u00eent\u00e2i faptul c\u0103 pentru un num\u0103r dat \\(n\\), exist\u0103 \\(2^{n-1} - 1\\) parti\u021bii cu suma \\(n\\), lucru ce se poate demonstra destul de u\u0219or folosind induc\u021bie, ideea de baz\u0103 fiind c\u0103 dac\u0103 \u0219tim num\u0103rul de parti\u021bii pentru \\(1, 2, \\dots, n-1\\), vom putea extinde parti\u021bia cu diferen\u021ba dintre \\(n\\) \u0219i acea sum\u0103.</p> <p>Pentru a afla cea de-a \\(k\\)-a parti\u021bie \u00een ordine lexicografic\u0103, vom putea merge din aproape \u00een aproape s\u0103 vedem c\u00e2te parti\u021bii \u00eencep cu fiecare num\u0103r de la \\(1\\) la \\(n\\) (acest lucru se poate face fie folosind formule matematice, fie folosind o recuren\u021b\u0103 foarte simpl\u0103), iar implementarea se poate face f\u0103r\u0103 probleme recursiv.</p> <p>Pentru a afla num\u0103rul de ordine al unei parti\u021bii, vom proceda similar, \u021bin\u00e2nd cont de num\u0103rul de parti\u021bii care \u00eencep cu un anumit num\u0103r \u0219i au o anumit\u0103 sum\u0103. Din nou, se poate proceda din aproape \u00een aproape, iar deoarece valorile pentru \\(n\\) \u0219i numerele de ordine ale parti\u021biilor sunt destul de mici, complexitatea va fi una foarte bun\u0103, permi\u021b\u00e2nd chiar \u0219i unor solu\u021bii mai incete s\u0103 ruleze \u00een timp bun.</p> <p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;fstream&gt;\n\nstd::ifstream cin(\"partit.in\");\nstd::ofstream cout(\"partit.out\");\n\nint c, n, v[10002];\nlong long k, dp[10002];\n\nvoid solve(int n, long long k) {\n    if (n == 0) {\n        return;\n    }\n    long long sum = 0;\n    for (int i = 1; i &lt;= n; ++i) {\n        if (sum + dp[n - i] &lt; k) {\n            sum = sum + dp[n - i];\n        } else {\n            cout &lt;&lt; i &lt;&lt; \" \";\n            solve(n - i, k - sum);\n            break;\n        }\n    }\n}\nint main() {\n    cin &gt;&gt; c &gt;&gt; n;\n    dp[0] = 1;\n    for (int i = 1; i &lt;= 10000; ++i) {\n        if (i &gt;= 61) {\n            dp[i] = (1LL &lt;&lt; 60);\n        } else {\n            dp[i] = (1LL &lt;&lt; (i - 1));\n        }\n    }\n    if (c == 1) {\n        cin &gt;&gt; k;\n        solve(n, k);\n    } else {\n        int x = 0;\n        int n2 = n;\n        while (n2) {\n            int nr;\n            cin &gt;&gt; nr;\n            v[++x] = nr;\n            n2 = n2 - nr;\n        }\n        long long ord = 1;\n        for (int i = 1; i &lt;= x; ++i) {\n            for (int j = 1; j &lt; v[i]; ++j) {\n                ord = ord + dp[n - j];\n            }\n            n -= v[i];\n        }\n        cout &lt;&lt; ord &lt;&lt; '\\n';\n    }\n    return 0;\n}\n</code></pre>","tags":["OJI","clasa XI-XII","combinatorica","partitii","programare dinamica"]},{"location":"olimpiada/solutii/OJI/2020/XI-XII-recyclebin/","title":"Solu\u021bia problemei RecycleBin (OJI 2020, clasele XI-XII)","text":"<p>Aceast\u0103 problem\u0103 poate fi reformulat\u0103 \u00een felul urm\u0103tor: Se d\u0103 un \u0219ir de lungime \\(n\\) \u0219i se scot secven\u021be de lungimi puteri ale lui 2, cu condi\u021bia ca lungimile secven\u021belor s\u0103 fie distincte. S\u0103 se afle subsecven\u021ba de sum\u0103 maxim\u0103 pe care o putem ob\u021bine dup\u0103 efectuarea unui set de opera\u021bii optim.</p> <p>Dup\u0103 aceast\u0103 reformulare, ne putem g\u00e2ndi mai \u00eent\u00e2i la o abordare de tip greedy \u00een care am putea alege \u00eentr-un mod sau altul secven\u021bele pe care s\u0103 le scoatem, iar mai apoi s\u0103 rul\u0103m algoritmul pentru subsecven\u021ba de sum\u0103 maxim\u0103 pentru \u0219irul r\u0103mas.</p> <p>Din p\u0103cate, avem mult prea multe cazuri din care putem alege, a\u0219a c\u0103 este mai bine s\u0103 ne g\u00e2ndim la o idee bazat\u0103 pe o dinamic\u0103. Aici putem recurge la restric\u021bia men\u021bionat\u0103 \u00een enunt, prin care suntem constr\u00e2n\u0219i s\u0103 nu folosim aceea\u0219i lungime de dou\u0103 ori, iar dat fiind c\u0103 lungimile sunt puteri ale lui 2, ne putem g\u00e2ndi la o dinamic\u0103 pe m\u0103\u0219ti pe bi\u021bi, \u00een care s\u0103 avem \\(dp[i][msk]\\) ca fiind suma maxim\u0103 a unui \u0219ir care se termin\u0103 la pozi\u021bia \\(i\\) \u0219i de unde am scos deja secven\u021be cu suma lungimilor \\(msk\\). </p> <p>Dintr-o asemenea stare, putem fie s\u0103 avans\u0103m la pozi\u021bia urm\u0103toare, actualiz\u00e2nd suma maxim\u0103 cu \\(max(dp[i][msk] + v[i+1], 0)\\), fie s\u0103 alegem lungimea unei secven\u021be pe care s\u0103 o \u0219tergem, actualiz\u00e2nd st\u0103ri de tip \\(dp[i + L][msk + L]\\), unde \\(L\\) este o putere a lui \\(2\\) ce nu apare \u00een masca curent\u0103.</p> <p>Acest mod de abordare al dinamicii este inspirat din algoritmul lui Kadane pentru subsecven\u021ba de sum\u0103 maxim\u0103 a unui \u0219ir, condi\u021biile fiind identice cu cele folosite pentru acest algoritm.</p> <p>Astfel, complexitatea algoritmului va deveni \\(\\mathcal{O}(n^2)\\), deoarece suma maxim\u0103 a unor m\u0103\u0219ti folosite este \\(n\\).</p> <p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;fstream&gt;\n\nint n, v[1002], dp[1002][1002];\nbool viz[1002][1002];\n\nint main() {\n    std::ifstream f(\"recyclebin.in\");\n    std::ofstream g(\"recyclebin.out\");\n    f &gt;&gt; n;\n    for (int i = 1; i &lt;= n; ++i) {\n        f &gt;&gt; v[i];\n    }\n    int ans = 0;\n    for (int i = 0; i &lt;= n; ++i) {\n        for (int j = 0; j &lt;= i; ++j) {\n            dp[i][j] = std::max(dp[i][j], 0);\n            ans = max(ans, dp[i][j]);\n            if (i == n) {\n                continue;\n            }\n            if (!viz[i + 1][j]) {\n                viz[i + 1][j] = 1;\n                dp[i + 1][j] = dp[i][j] + v[i + 1];\n            } else {\n                if (dp[i][j] + v[i + 1] &gt; dp[i + 1][j]) {\n                    dp[i + 1][j] = dp[i][j] + v[i + 1];\n                }\n            }\n            for (int pw = 0; i + (1 &lt;&lt; pw) &lt;= n; ++pw) {\n                if (j &amp; (1 &lt;&lt; pw)) {\n                    continue;\n                }\n                if (!viz[i + (1 &lt;&lt; pw)][j + (1 &lt;&lt; pw)]) {\n                    viz[i + (1 &lt;&lt; pw)][j + (1 &lt;&lt; pw)] = 1;\n                    dp[i + (1 &lt;&lt; pw)][j + (1 &lt;&lt; pw)] = dp[i][j];\n                } else {\n                    if (dp[i][j] &gt; dp[i + (1 &lt;&lt; pw)][j + (1 &lt;&lt; pw)]) {\n                        dp[i + (1 &lt;&lt; pw)][j + (1 &lt;&lt; pw)] = dp[i][j];\n                    }\n                }\n            }\n        }\n    }\n    g &lt;&lt; ans &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["OJI","clasa XI-XII","secvente","programare dinamica"]},{"location":"olimpiada/solutii/OJI/2021/IX-aproape/","title":"Solu\u021bia problemei aproape (OJI 2021, clasa a IX-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["OJI","clasa IX"]},{"location":"olimpiada/solutii/OJI/2021/IX-aproape/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["OJI","clasa IX"]},{"location":"olimpiada/solutii/OJI/2021/IX-cochilie/","title":"Solu\u021bia problemei cochilie (OJI 2021, clasa a IX-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["OJI","clasa IX"]},{"location":"olimpiada/solutii/OJI/2021/IX-cochilie/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["OJI","clasa IX"]},{"location":"olimpiada/solutii/OJI/2021/IX-logic/","title":"Solu\u021bia problemei logic (OJI 2021, clasa a IX-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["OJI","clasa IX"]},{"location":"olimpiada/solutii/OJI/2021/IX-logic/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["OJI","clasa IX"]},{"location":"olimpiada/solutii/OJI/2021/V-concurs/","title":"Solu\u021bia problemei concurs (OJI 2021, clasa a V-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["OJI","clasa V"]},{"location":"olimpiada/solutii/OJI/2021/V-concurs/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["OJI","clasa V"]},{"location":"olimpiada/solutii/OJI/2021/V-sir/","title":"Solu\u021bia problemei sir (OJI 2021, clasa a V-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["OJI","clasa V"]},{"location":"olimpiada/solutii/OJI/2021/V-sir/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["OJI","clasa V"]},{"location":"olimpiada/solutii/OJI/2021/VI-formula1/","title":"Solu\u021bia problemei formula1 (OJI 2021, clasa a VI-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["OJI","clasa VI"]},{"location":"olimpiada/solutii/OJI/2021/VI-formula1/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["OJI","clasa VI"]},{"location":"olimpiada/solutii/OJI/2021/VI-seism/","title":"Solu\u021bia problemei seism (OJI 2021, clasa a VI-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["OJI","clasa VI"]},{"location":"olimpiada/solutii/OJI/2021/VI-seism/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["OJI","clasa VI"]},{"location":"olimpiada/solutii/OJI/2021/VII-campionat/","title":"Solu\u021bia problemei campionat (OJI 2021, clasa a VII-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["OJI","clasa VII"]},{"location":"olimpiada/solutii/OJI/2021/VII-campionat/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["OJI","clasa VII"]},{"location":"olimpiada/solutii/OJI/2021/VII-exclusiv/","title":"Solu\u021bia problemei exclusiv (OJI 2021, clasa a VII-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["OJI","clasa VII"]},{"location":"olimpiada/solutii/OJI/2021/VII-exclusiv/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["OJI","clasa VII"]},{"location":"olimpiada/solutii/OJI/2021/VIII-cartofi/","title":"Solu\u021bia problemei cartofi (OJI 2021, clasa a VIII-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["OJI","clasa VIII"]},{"location":"olimpiada/solutii/OJI/2021/VIII-cartofi/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["OJI","clasa VIII"]},{"location":"olimpiada/solutii/OJI/2021/VIII-tunel/","title":"Solu\u021bia problemei tunel (OJI 2021, clasa a VIII-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["OJI","clasa VIII"]},{"location":"olimpiada/solutii/OJI/2021/VIII-tunel/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["OJI","clasa VIII"]},{"location":"olimpiada/solutii/OJI/2021/X-labirint/","title":"Solu\u021bia problemei Labirint (OJI 2021, clasa a X-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["OJI","clasa X"]},{"location":"olimpiada/solutii/OJI/2021/X-labirint/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["OJI","clasa X"]},{"location":"olimpiada/solutii/OJI/2021/X-sdistante/","title":"Solu\u021bia problemei SDistan\u021be (OJI 2021, clasa a X-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["OJI","clasa X"]},{"location":"olimpiada/solutii/OJI/2021/X-sdistante/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["OJI","clasa X"]},{"location":"olimpiada/solutii/OJI/2021/X-tort/","title":"Solu\u021bia problemei Tort (OJI 2021, clasa a X-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["OJI","clasa X"]},{"location":"olimpiada/solutii/OJI/2021/X-tort/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["OJI","clasa X"]},{"location":"olimpiada/solutii/OJI/2021/XI-XII-bob/","title":"Solu\u021bia problemei Bob (OJI 2021, clasele XI-XII)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["OJI","clasa XI-XII"]},{"location":"olimpiada/solutii/OJI/2021/XI-XII-bob/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["OJI","clasa XI-XII"]},{"location":"olimpiada/solutii/OJI/2021/XI-XII-dreptunghi/","title":"Solu\u021bia problemei dreptunghi (OJI 2021, clasele XI-XII)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["OJI","clasa XI-XII"]},{"location":"olimpiada/solutii/OJI/2021/XI-XII-dreptunghi/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["OJI","clasa XI-XII"]},{"location":"olimpiada/solutii/OJI/2021/XI-XII-polihroniade/","title":"Solu\u021bia problemei Polihroniade (OJI 2021, clasele XI-XII)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["OJI","clasa XI-XII"]},{"location":"olimpiada/solutii/OJI/2021/XI-XII-polihroniade/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["OJI","clasa XI-XII"]},{"location":"olimpiada/solutii/OJI/2022/IX-balba/","title":"Solu\u021bia problemei balba (OJI 2022, clasa a IX-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["OJI","clasa IX"]},{"location":"olimpiada/solutii/OJI/2022/IX-balba/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n\nint main() {\n    ifstream cin(\"balba.in\");\n    ofstream cout(\"balba.out\");\n\n    int c, n;\n    cin &gt;&gt; c &gt;&gt; n;\n\n    vector&lt;int&gt; v(n+1), fr(10), fr2(10);\n    for (int i = 1; i &lt;= n; i++) {\n        cin &gt;&gt; v[i];\n        fr[v[i]]++;\n        fr2[v[i]]++;\n    }\n\n    if (c == 1) {\n        int grp = 0, consec = 0, strk = 0;\n        for (int i = 1; i &lt;= n; i++) {\n            if (i == 1 || v[i] != v[i-1]) {\n                grp++;\n                strk = 1;\n            }\n            else {\n                strk++;\n                if (strk == 2) {\n                    consec++;\n                }\n            }\n        }\n        cout &lt;&lt; grp &lt;&lt; '\\n';\n        cout &lt;&lt; consec &lt;&lt; '\\n';\n    }\n    else {\n        string s;\n        for (int i = 9; i &gt;= 0; i--) {\n            if (i == 0 &amp;&amp; s.empty())\n                break;\n            while (fr[i] &gt;= 2) {\n                s += (char) ('0' + i);\n                fr[i] -= 2;\n            }\n        }\n\n        // group all chars w/ even frequency and add the biggest odd in the middle\n        string ans = s;\n\n        int biggestodd = -1;\n        for (int i = 9; i &gt;= 0; i--) \n            if (fr[i] == 1) {\n                biggestodd = i;\n                break;\n            }\n\n        if (biggestodd != -1) \n            ans += (char) ('0' + biggestodd);\n\n        for (int i = (int) s.size() - 1; i &gt;= 0; i--) \n            ans += s[i];\n\n        string ans2, ans3;\n\n        // starting from string made of even frequency, add one more char \n\n        for (int i = 0; i &lt; (int) s.size(); i++) \n            if (fr[s[i] - '0']) {\n                for (int j = 0; j &lt; i; j++) \n                    ans2 += s[j];\n                ans2 += s[i];\n                for (int j = i; j &lt; (int) s.size(); j++) \n                    ans2 += s[j];\n                for (int j = (int) s.size() - 1; j &gt;= 0; j--) \n                    ans2 += s[j];\n                break;\n            }\n\n        for (int i = 0; i &lt; (int) s.size(); i++) \n            if (fr[s[i] - '0']) {\n                for (int j = 0; j &lt; (int) s.size(); j++) \n                    ans3 += s[j];\n                for (int j = (int) s.size() - 1; j &gt;= i; j--) \n                    ans3 += s[j];\n                ans3 += s[i];\n                for (int j = i-1; j &gt;= 0; j--) \n                    ans3 += s[j];\n                break;\n            }\n\n        string finalans = ans;\n        if (ans2.size() &gt; finalans.size() || (ans2.size() == finalans.size() &amp;&amp; ans2 &gt; finalans))\n            finalans = ans2;\n        if (ans3.size() &gt; finalans.size() || (ans3.size() == finalans.size() &amp;&amp; ans3 &gt; finalans))\n            finalans = ans3;\n\n        // fix middle char \n\n        for (int digit = 0; digit &lt;= 9; digit++) {\n            if (fr2[digit])\n            {\n                fr2[digit]--;\n                string ss;\n                for (int i = 9; i &gt;= 0; i--) {\n                    if (i == 0 &amp;&amp; ss.empty())\n                        break;\n                    while (fr2[i] &gt;= 2) {\n                        ss += (char) ('0' + i);\n                        fr2[i] -= 2;\n                    }\n                }\n                string variant;\n                for (int j = 0; j &lt; (int) ss.size(); j++)\n                    variant += ss[j];\n                variant += (char) ('0' + digit);\n\n                for (int i = 0; i + 1 &lt; (int) variant.size(); i++) {\n                    if (fr2[variant[i] - '0']) {\n                        string anss;\n                        for (int j = 0; j &lt; i; j++)\n                            anss += variant[j];\n                        anss += variant[i];\n                        for (int j = i; j &lt; (int) variant.size(); j++)\n                            anss += variant[j];\n                        for (int j = (int) variant.size() - 2; j &gt;= 0; j--)\n                            anss += variant[j];\n                        if (anss.size() &gt; finalans.size() || (anss.size() == finalans.size() &amp;&amp; anss &gt; finalans))\n                            finalans = anss;\n                        break;\n                    }\n\n                }\n\n                for (int j = 0; j &lt; (int) ss.size(); j++)\n                    fr2[ss[j] - '0'] += 2;\n                fr2[digit]++;\n            }\n        }\n        cout &lt;&lt; finalans &lt;&lt; '\\n';\n    }\n    return 0;\n}\n</code></pre>","tags":["OJI","clasa IX"]},{"location":"olimpiada/solutii/OJI/2022/IX-oneout/","title":"Solu\u021bia problemei oneout (OJI 2022, clasa a IX-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["OJI","clasa IX"]},{"location":"olimpiada/solutii/OJI/2022/IX-oneout/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\n#include &lt;fstream&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\nint main() {\n    ifstream cin(\"oneout.in\");\n    ofstream cout(\"oneout.out\");\n\n    int c, n;\n    cin &gt;&gt; c;\n    cin &gt;&gt; n;\n\n    vector &lt;int&gt; v(n+1); \n\n    for (int i = 1; i &lt;= n; i++) {\n        cin &gt;&gt; v[i];\n    }\n\n    vector &lt;int&gt; squarefree(1000001, 1);\n\n    for (int i = 2; i &lt;= 1000; i++) {\n        for (int j = i*i; j &lt;= 1000000; j += i*i) {\n            squarefree[j] = 0;\n        }\n    }\n\n    int ans = 0;\n\n    if (c == 1) {\n        for (int i = 1; i &lt;= n; i++) {\n            ans += squarefree[v[i]];\n        }\n        cout &lt;&lt; ans &lt;&lt; '\\n';\n    }\n    else {\n        vector &lt;int&gt; streakL(n+1), streakR(n+1);\n        for (int i = 1; i &lt;= n; i++) {\n            if (squarefree[v[i]]) {\n                streakL[i] = streakL[i-1] + 1;\n            }\n        }\n        for (int i = n; i &gt;= 1; i--) {\n            if (squarefree[v[i]]) {\n                if (i != n) {\n                    streakR[i] = streakR[i+1] + 1;\n                }\n                else {\n                    streakR[i] = 1;\n                }\n            }\n        }\n        ans = -1;\n        int cnt = 0;\n        for (int i = 2; i &lt; n; i++) {\n            if (squarefree[v[i]] == 0 &amp;&amp; streakL[i-1] &amp;&amp; streakR[i+1]) {\n                if (streakL[i-1] + streakR[i+1] &gt; ans) {\n                    ans = streakL[i-1] + streakR[i+1];\n                    cnt = 1;\n                }\n                else {\n                    if (streakL[i-1] + streakR[i+1] == ans) {\n                        cnt++;\n                    }\n                }\n            }\n        }\n\n        if (ans == -1) {\n            cout &lt;&lt; -1 &lt;&lt; '\\n';\n        }\n        else {\n            cout &lt;&lt; ans &lt;&lt; \" \" &lt;&lt; cnt &lt;&lt; '\\n';\n            for (int i = 2; i &lt; n; i++) {\n                if (squarefree[v[i]] == 0 &amp;&amp; streakL[i-1] &amp;&amp; streakR[i+1]) {\n                    if (streakL[i-1] + streakR[i+1] == ans) {\n                        cout &lt;&lt; i - streakL[i-1] &lt;&lt; \" \" &lt;&lt; i + streakR[i+1] &lt;&lt; '\\n';\n                    }\n                }\n            }\n        }\n    }\n    return 0;\n}\n</code></pre>","tags":["OJI","clasa IX"]},{"location":"olimpiada/solutii/OJI/2022/IX-pergament/","title":"Solu\u021bia problemei pergament (OJI 2022, clasa a IX-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["OJI","clasa IX"]},{"location":"olimpiada/solutii/OJI/2022/IX-pergament/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\n#include &lt;fstream&gt;\n#include &lt;vector&gt;\n#include &lt;algorithm&gt;\nusing namespace std;\n\nint main() {\n\n    ifstream cin(\"pergament.in\");\n    ofstream cout(\"pergament.out\");\n\n    int N, K, Q, A, B, C, D, x, y, rez = 0;\n    cin &gt;&gt; N &gt;&gt; K &gt;&gt; Q &gt;&gt; A &gt;&gt; B &gt;&gt; C &gt;&gt; D &gt;&gt; x &gt;&gt; y;\n\n    vector&lt;int&gt; sum(51, 0);\n    vector&lt;pair&lt;int, pair&lt;int, int&gt; &gt; &gt; q;\n\n    for (int i = 1; i &lt;= Q; i++) {\n        int coloana, rand, distanta;\n        cin &gt;&gt; coloana &gt;&gt; rand &gt;&gt; distanta;\n        q.push_back({rand, {coloana, 1}});\n        q.push_back({rand + distanta, {coloana, -1}});\n    }\n    sort(q.begin(), q.end());\n\n    int n = q.size() - 1;\n    int ind = 0;\n\n    for (int i = 1; i &lt;= N; i++) {\n        while (ind &lt;= n &amp;&amp; q[ind].first &lt;= i) {\n            for (int lungime = q[ind].second.first; lungime &lt;= K; lungime++) {\n                sum[lungime] += q[ind].second.second;\n            }\n            ind++;\n        }\n        rez += sum[x + y - 1] - sum[x - 1];\n        x = 1 + (x * A + B) % K;\n        y = 1 + (y * C + D) % (K - x + 1);\n    }\n\n    cout &lt;&lt; rez &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["OJI","clasa IX"]},{"location":"olimpiada/solutii/OJI/2022/V-ceas/","title":"Solu\u021bia problemei ceas (OJI 2022, clasa a V-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["OJI","clasa V"]},{"location":"olimpiada/solutii/OJI/2022/V-ceas/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>/*\n\nC = 1 -&gt; se numara cifrele in mod standard, atentie la cazul x = 0\n\nC = 2 -&gt; se simuleaza grupele, din nou trebuie atentie la cifrele egale cu 0\nraspunsul final este numarul de grupe create - n\n\n*/\n\n#include &lt;fstream&gt;\n#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    ifstream cin(\"ceas.in\");\n    ofstream cout(\"ceas.out\");\n\n    int c, x, n;\n    cin &gt;&gt; c &gt;&gt; x &gt;&gt; n;\n\n    int ans1 = 0, ans2 = 0;\n    for (int i = 1; i &lt;= n; i++) {\n        int nr;\n        cin &gt;&gt; nr;\n        int grupa = -1;\n        if (nr == 0) {\n            if (x == 0) ans1++;\n            ans2++;\n        }\n        while (nr) {\n            if (nr % 10 == x) ans1++;\n            if (grupa == -1)\n                ans2++, grupa = nr % 10;\n            else if ((nr % 10) != 0 &amp;&amp; (nr % 10) * 10 + grupa &lt;= 12)\n                grupa = -1;\n            else\n                ans2++, grupa = nr % 10;\n            nr /= 10;\n        }\n    }\n    if (c == 1)\n        cout &lt;&lt; ans1 &lt;&lt; '\\n';\n    else\n        cout &lt;&lt; ans2 - n &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["OJI","clasa V"]},{"location":"olimpiada/solutii/OJI/2022/V-sss/","title":"Solu\u021bia problemei sss (OJI 2022, clasa a V-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["OJI","clasa V"]},{"location":"olimpiada/solutii/OJI/2022/V-sss/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>/*\nMai intai se afla ultima cifra nenula pentru cerinta 1. Apoi, e simplu de aflat suma ultimelor valori conform enuntului\n\nPentru cerinta 2, trebuie aflat numarul de grupe folosind sume gauss si apoi simulam suma fiecarei grupe\n*/\n\n#include &lt;iostream&gt;\n#include &lt;fstream&gt;\nusing namespace std;\n\nint main()\n{\n    ifstream cin(\"sss.in\");\n    ofstream cout(\"sss.out\");\n\n    int c, n;\n    cin &gt;&gt; c &gt;&gt; n;\n\n    int ans1 = 0, ans2 = 0;\n    int lastdigit = 0, sm = 0;\n\n    int grp = 1;\n    while(grp * (grp+1) / 2 &lt; n)\n        grp++;\n    for(int i = 1; i &lt;= n; i++)\n    {\n        int x, x2;\n        cin &gt;&gt; x;\n        x2 = x;\n        if(i == 1)\n        {\n            while(x)\n            {\n                if(x % 10 != 0)\n                {\n                    lastdigit = x%10;\n                    break;\n                }\n                x /= 10;\n            }\n        }\n\n        if(i &gt;= n - lastdigit + 1)\n            ans1 += x2;\n        sm += x2;\n        if(sm &gt; ans2)\n            ans2 = sm;\n        if(n - i == grp * (grp-1) / 2)\n            grp--, sm = 0;\n    }\n\n    if(c == 1)\n        cout &lt;&lt; ans1;\n    else\n        cout &lt;&lt; ans2;\n    return 0;\n}\n</code></pre>","tags":["OJI","clasa V"]},{"location":"olimpiada/solutii/OJI/2022/VI-cmmdc/","title":"Solu\u021bia problemei cmmdc (OJI 2022, clasa a VI-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["OJI","clasa VI"]},{"location":"olimpiada/solutii/OJI/2022/VI-cmmdc/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;bits/stdc++.h&gt;\n#define ll long long\n\nusing namespace std;\n\nlong long cmmdc(long long a, long long b)\n{\n    long long c;\n    while(b)\n    {\n        c = a%b;\n        a = b;\n        b = c;\n    }\n    return a;\n} \n\nlong long v[100002], prfs[100002], prfd[100002];\nlong long prf[2002][2002];\n\nint main() \n{\n\n    ifstream cin(\"cmmdc.in\");\n    ofstream cout(\"cmmdc.out\");\n\n    int c, n;\n    cin &gt;&gt; c &gt;&gt; n;\n\n    for(int i = 1; i &lt;= n; i++)\n        cin &gt;&gt; v[i];\n\n    if(c == 1)\n    {\n        long long ans = v[1];\n        for(int i = 2; i &lt;= n; i++)\n            ans = cmmdc(ans, v[i]);\n        cout &lt;&lt; ans;\n        return 0;\n    }\n    else\n    {\n        if(c == 2)\n        {\n            for(int i = 1; i &lt;= n; i++)\n                prfs[i] = cmmdc(prfs[i-1], v[i]);\n            for(int i = n; i &gt;= 1; i--)\n                prfd[i] = cmmdc(prfd[i+1], v[i]);\n            ll ans = max(prfs[n-1], prfd[2]); // alegem 1 sau n\n            for(int i = 2; i &lt; n; i++)\n                ans = max(ans, cmmdc(prfs[i-1], prfd[i+1]));\n\n            cout &lt;&lt; ans &lt;&lt; '\\n';\n        }\n        if(c == 3)\n        {\n            for(int i = 1; i &lt;= n; i++)\n            {\n                prf[i][i] = v[i];\n                for(int j = i+1; j &lt;= n; j++)\n                    prf[i][j] = cmmdc(prf[i][j-1], v[j]);\n            }\n            long long ans = 0;\n            for(int poz1 = 1; poz1 &lt;= n; poz1++)\n                for(int poz2 = poz1+1; poz2 &lt;= n; poz2++)\n                {\n                    long long c1 = 0;\n                    long long c2 = 0;\n                    long long c3 = 0;\n                    if(poz1 &gt; 1)\n                        c1 = prf[1][poz1-1];\n                    if(poz2 - 1 &gt; poz1)\n                        c2 = prf[poz1+1][poz2-1];\n                    if(poz2 &lt; n)\n                        c3 = prf[poz2+1][n];\n                    ans = max(ans, cmmdc(cmmdc(c1, c2), c3));\n                }\n            cout &lt;&lt; ans &lt;&lt; '\\n';\n        }\n    }\n    return 0;\n}\n</code></pre>","tags":["OJI","clasa VI"]},{"location":"olimpiada/solutii/OJI/2022/VI-vecine/","title":"Solu\u021bia problemei vecine (OJI 2022, clasa a VI-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["OJI","clasa VI"]},{"location":"olimpiada/solutii/OJI/2022/VI-vecine/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["OJI","clasa VI"]},{"location":"olimpiada/solutii/OJI/2022/VII-patratele/","title":"Solu\u021bia problemei patratele (OJI 2022, clasa a VII-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["OJI","clasa VII"]},{"location":"olimpiada/solutii/OJI/2022/VII-patratele/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["OJI","clasa VII"]},{"location":"olimpiada/solutii/OJI/2022/VII-pseudocmp/","title":"Solu\u021bia problemei pseudocmp (OJI 2022, clasa a VII-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["OJI","clasa VII"]},{"location":"olimpiada/solutii/OJI/2022/VII-pseudocmp/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["OJI","clasa VII"]},{"location":"olimpiada/solutii/OJI/2022/VIII-pelican/","title":"Solu\u021bia problemei pelican (OJI 2022, clasa a VIII-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["OJI","clasa VIII"]},{"location":"olimpiada/solutii/OJI/2022/VIII-pelican/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["OJI","clasa VIII"]},{"location":"olimpiada/solutii/OJI/2022/VIII-strips/","title":"Solu\u021bia problemei strips (OJI 2022, clasa a VIII-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["OJI","clasa VIII"]},{"location":"olimpiada/solutii/OJI/2022/VIII-strips/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["OJI","clasa VIII"]},{"location":"olimpiada/solutii/OJI/2022/X-circular/","title":"Solu\u021bia problemei circular (OJI 2022, clasa a X-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["OJI","clasa X"]},{"location":"olimpiada/solutii/OJI/2022/X-circular/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["OJI","clasa X"]},{"location":"olimpiada/solutii/OJI/2022/X-pulsar/","title":"Solu\u021bia problemei pulsar (OJI 2022, clasa a X-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["OJI","clasa X"]},{"location":"olimpiada/solutii/OJI/2022/X-pulsar/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["OJI","clasa X"]},{"location":"olimpiada/solutii/OJI/2022/X-transport/","title":"Solu\u021bia problemei transport (OJI 2022, clasa a X-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["OJI","clasa X"]},{"location":"olimpiada/solutii/OJI/2022/X-transport/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["OJI","clasa X"]},{"location":"olimpiada/solutii/OJI/2022/XI-XII-dulciuri/","title":"Solu\u021bia problemei dulciuri (OJI 2022, clasele XI-XII)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["OJI","clasa XI-XII"]},{"location":"olimpiada/solutii/OJI/2022/XI-XII-dulciuri/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["OJI","clasa XI-XII"]},{"location":"olimpiada/solutii/OJI/2022/XI-XII-investitie/","title":"Solu\u021bia problemei investitie (OJI 2022, clasele XI-XII)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["OJI","clasa XI-XII"]},{"location":"olimpiada/solutii/OJI/2022/XI-XII-investitie/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["OJI","clasa XI-XII"]},{"location":"olimpiada/solutii/OJI/2022/XI-XII-superhedgy/","title":"Solu\u021bia problemei superhedgy (OJI 2022, clasele XI-XII)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["OJI","clasa XI-XII"]},{"location":"olimpiada/solutii/OJI/2022/XI-XII-superhedgy/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["OJI","clasa XI-XII"]},{"location":"olimpiada/solutii/OJI/2023/IX-cufere/","title":"Solu\u021bia problemei cufere (OJI 2023, clasa a IX-a)","text":"<p>Se vor re\u021bine \u00eentr-un tablou unidimensional \\(fr\\) num\u0103rul de obiecte \u00eent\u00e2lnite pentru fiecare tip de obiect (etichet\u0103). Acesta se poate construi \u00een timpul citirii datelor de intrare. C\u00e2nd citim num\u0103rul \\(xxyy\\) ce codific\u0103 o celul\u0103 dintr-un cuf\u0103r, increment\u0103m num\u0103rul de obiecte \u00eent\u00e2lnite cu eticheta \\(yy\\) cu \\(xx\\), adic\u0103 \\(fr[xx] = fr[xx] + yy\\).</p> <p>Tabloul va avea lungime maxim 100, \u00eentruc\u00e2t etichetele iau valori \u00een intervalul \\([10, 99]\\).</p>","tags":["OJI","clasa IX"]},{"location":"olimpiada/solutii/OJI/2023/IX-cufere/#cerinta-1","title":"Cerin\u021ba 1","text":"<p>Se afi\u0219eaz\u0103 \u00een ordinea cresc\u0103toare a etichetelor din intervalul \\([10,99 ]\\) toate perechile \\((x, fr[x])\\) pentru care \\(fr[x] &gt; 0\\).</p>","tags":["OJI","clasa IX"]},{"location":"olimpiada/solutii/OJI/2023/IX-cufere/#cerinta-2","title":"Cerin\u021ba 2","text":"<p>Se parcurge tabloul \\(fr\\) \u00een ordinea cresc\u0103toare a etichetelor, de la \\(10\\), p\u00e2n\u0103 la \\(99\\) inclusiv. Pentru fiecare etichet\u0103 \\(x\\) se verific\u0103 primalitatea acesteia: dac\u0103 x este num\u0103r prim, se seteaz\u0103 dimensiunea maxim\u0103 a unui grup \\(g = 16\\), altfel se seteaz\u0103 \\(g = 64\\).</p> <p>C\u00e2t timp \u00eenc\u0103 exist\u0103 obiecte cu eticheta curent\u0103 \\((fr[x] &gt; 0)\\), se adaug\u0103 pe urm\u0103toarea celul\u0103 liber\u0103 din cele \\(n\\) cufere un nou grup de obiecte cu eticheta \\(x\\) de dimensiune \\(min(g, fr[x])\\) \u0219i se scade \\(fr[x]\\) cu \\(g\\) (sau se seteaz\u0103 cu \\(0\\) \u00een cazul \u00een care \\(fr[x] &lt; g\\)). Dac\u0103 mai r\u0103m\u00e2n celule libere \u00een cufere, se completeaz\u0103 cu 0.</p> <p>Verificarea primalit\u0103\u021bii unui num\u0103r poate fi precalculat\u0103 \u00eentr-un tablou unidimensional \\(prim[i] = 1\\) dac\u0103 \\(i\\) este prim \u0219i \\(0\\) altfel, \u0219i poate fi calculat\u0103 \u00een diverse modalit\u0103\u021bi.</p> <p>Complexitatea temporal\u0103 este: \\(O(N)\\). Complexitatea spa\u021bial\u0103 este: \\(O(1)\\), \u00eentruc\u00e2t dimensiunea tablourilor \\(fr\\) \u0219i \\(prim\\) este constant\u0103.</p>","tags":["OJI","clasa IX"]},{"location":"olimpiada/solutii/OJI/2023/IX-cufere/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;fstream&gt;\n\nusing namespace std;\nifstream fin(\"cufere.in\");\nofstream fout(\"cufere.out\");\n\nint row = 3, col = 9;\nint f[101], p[100], c, n;\n\nvoid numar(int x) {\n    int eticheta;\n    eticheta = x % 100;\n    f[eticheta] += x / 100;\n}\n\nvoid ciur() {\n    for (int i = 2; i &lt;= 99; i++) {\n        if (p[i] == 0) {\n            for (int j = 2 * i; j &lt;= 99; j += i) {\n                p[j] = 1;\n            }\n        }\n    }\n}\n\nvoid afisarespatiu(int d) {\n    if (d % 9 == 0) {\n        fout &lt;&lt; \"\\n\";\n    }\n}\n\nvoid ordonare() {\n    int afisare = 0;\n    for (int i = 10; i &lt;= 99; i++) {\n        if (f[i] != 0) {\n            if (f[i] &gt; 64 &amp;&amp; p[i] != 0) {\n                for (int j = 1; j &lt;= f[i] / 64; j++) {\n                    fout &lt;&lt; 64 &lt;&lt; i &lt;&lt; \" \";\n                    afisare++, afisarespatiu(afisare);\n                }\n                if (f[i] % 64 != 0) {\n                    fout &lt;&lt; f[i] % 64 &lt;&lt; i &lt;&lt; \" \";\n                    afisare++, afisarespatiu(afisare);\n                }\n            } else if (f[i] &lt; 64 &amp;&amp; p[i] != 0) {\n                if (f[i] % 64 != 0) {\n                    fout &lt;&lt; f[i] % 64 &lt;&lt; i &lt;&lt; \" \";\n                    afisare++, afisarespatiu(afisare);\n                }\n            } else if (f[i] &gt; 16 &amp;&amp; p[i] == 0) {\n                for (int j = 1; j &lt;= f[i] / 16; j++) {\n                    fout &lt;&lt; 16 &lt;&lt; i &lt;&lt; \" \";\n                    afisare++, afisarespatiu(afisare);\n                }\n                if (f[i] % 16 != 0) {\n                    fout &lt;&lt; f[i] % 16 &lt;&lt; i &lt;&lt; \" \";\n                    afisare++, afisarespatiu(afisare);\n                }\n            } else if (f[i] &lt; 16 &amp;&amp; p[i] == 0) {\n                if (f[i] % 16 != 0) {\n                    fout &lt;&lt; f[i] % 16 &lt;&lt; i &lt;&lt; \" \";\n                    afisare++, afisarespatiu(afisare);\n                }\n            }\n        }\n    }\n    for (int i = afisare; i &lt; row * col * n; i++) {\n        fout &lt;&lt; 0 &lt;&lt; \" \";\n        afisare++;\n        afisarespatiu(afisare);\n    }\n}\n\nint main() {\n    int c, x;\n    fin &gt;&gt; c &gt;&gt; n;\n\n    for (int i = 1; i &lt;= n * row * col; i++) {\n        fin &gt;&gt; x;\n        numar(x);\n    }\n\n    if (c == 1) {\n        for (int i = 10; i &lt;= 99; i++) {\n            if (f[i] != 0) {\n                fout &lt;&lt; i &lt;&lt; \" \" &lt;&lt; f[i] &lt;&lt; \"\\n\";\n            }\n        }\n    }\n\n    if (c == 2) {\n        ciur();\n        ordonare();\n    }\n    return 0;\n}\n</code></pre>","tags":["OJI","clasa IX"]},{"location":"olimpiada/solutii/OJI/2023/IX-fibosnek/","title":"Solu\u021bia problemei fibosnek (OJI 2023, clasa a IX-a)","text":"","tags":["OJI","clasa IX"]},{"location":"olimpiada/solutii/OJI/2023/IX-fibosnek/#observatii","title":"Observa\u021bii","text":"<ul> <li> <p>Av\u00e2nd \u00een vedere restric\u021biile problemei, vom memora \u00eentr-un tablou unidimensional \\(fib\\) doar primii \\(nrF = 46\\) termeni ai \u0219irului Fibonacci, ultimul termen fiind \\(fib[46] = 1836311903\\).</p> </li> <li> <p>Nu este necesar\u0103 re\u021binerea valorilor matricei ini\u021biale, matricea de int-uri dep\u0103\u0219ind memoria maxim\u0103 alocat\u0103 (6MB). Se vor re\u021bine indicii din \u0219irul Fibonacci corespunz\u0103tori valorilor citite. \u00cen cazul valorilor care nu apar\u021bin \u0219irului Fibonacci, se poate re\u021bine indicele celui mai apropiat num\u0103r din \u0219ir, cu semn negativ. A\u0219adar, \\(8\\) va fi re\u021binut ca \\(5\\), \\(13\\) ca \\(6\\), \\(11\\) ca \\(\u22126\\), iar \\(4\\) ca \\(\u22123\\). Astfel, se poate reduce semnificativ memoria, deoarece poate fi folosit\u0103 o matrice de \\(char\\), \u00eentruc\u00e2t valorile din noua matrice sunt \u00eentre \\(\u221246\\) \u0219i \\(46\\).</p> </li> <li> <p>Matricea ini\u021bial\u0103 se poate liniariza, adic\u0103 se poate memora \u00eentr-un tablou unidimensional prin parcurgerea \\(snek\\). Elementul de pe celula \\((i, j)\\) din matrice va ap\u0103rea \u00een tablou pe pozi\u021bia \\((j \u2212 1) \\cdot n + i\\), pentru oricare \\(1 \\leq i \\leq n\\), \\(1 \\leq j \\leq m\\).</p> </li> </ul> <p>Astfel, \u00een urma acestor transform\u0103ri asupra problemei, se reduce la determinarea lungimii maxime a cel mult trei secven\u021be consecutive, compacte, ce alterneaz\u0103 \\(fibosnek\\), \\(non-fibosnek\\), \\(fibosnek\\).</p>","tags":["OJI","clasa IX"]},{"location":"olimpiada/solutii/OJI/2023/IX-fibosnek/#cazul-c-1-si-n-m-leq-1000","title":"Cazul \\(c = 1\\) \u0219i \\(n, m \\leq 1000\\)","text":"<p>Se vor precalcula primii \\(46\\) de termeni ai \u0219irului Fibonacci \u00een tabloul \\(fib\\). Pentru fiecare valoare citit\u0103 din matricea ini\u021bial\u0103, se va verifica dac\u0103 aceasta se afl\u0103 \u00een vectorul \\(fib\\) utiliz\u00e2nd c\u0103utare binar\u0103 \u0219i se vor num\u0103ra c\u00e2te numere Fibonacci au fost \u00eent\u00e2lnite.</p> <p>Complexitate temporal\u0103: \\(O(n \\cdot m \\cdot \\log nr_F + nr_F)\\). Complexitate spa\u021bial\u0103: \\(O(nr_F)\\).</p>","tags":["OJI","clasa IX"]},{"location":"olimpiada/solutii/OJI/2023/IX-fibosnek/#cazul-c-2-si-n-m-leq-100","title":"Cazul \\(c = 2\\) \u0219i \\(n, m \\leq 100\\)","text":"<p>Se parcurge matricea pe coloane, conform parcurgerii \\(snek\\), \u0219i pentru fiecare element al matricei se determin\u0103 dac\u0103 este sau nu num\u0103r Fibonacci parcurg\u00e2nd secven\u021bial tabloul \\(fib\\).</p> <p>Pentru fiecare triplet de secven\u021be alternative (\\(fibosnek\\), \\(non-fibosnek\\), \\(fibosnek\\)), se va calcula r\u0103spunsul astfel:</p> <ul> <li>\\(S_1\\) \u2014 suma primei secven\u021be din triplet \\(fibosnek\\) ce are \\(n_1\\) termeni;</li> <li>\\(S_2\\) \u2014 suma secven\u021bei din mijloc \\(non-fibosnek\\) ce are \\(n_2\\) termeni;</li> <li>\\(S_3\\) \u2014 suma ultimei secven\u021bei \\(fibosnek\\) ce are \\(n_3\\) termeni.</li> </ul> <p>Se pot \u00eent\u00e2lni urm\u0103toarele cazuri particulare:</p> <ol> <li>\\(n_1 = 0\\) \u2013 secven\u021ba \\(fibosnek\\) curent\u0103 este prima din parcurgere.</li> <li>\\(n_1 = 0\\), \\(n_3 = 0\\) \u2013 nu exist\u0103 nicio secven\u021b\u0103 \\(fibosnek\\) \u00een parcurgere.</li> <li>\\(n_3 = 0\\) \u2013 parcurgerea se termin\u0103 \u00eentr-o secven\u021b\u0103 \\(non-fibosnek\\).</li> </ol> <p>Se re\u021bine suma \\(S_1 + S_2 + S_3\\) a primului triplet \u00eent\u00e2lnit de lungime maxim\u0103 \\(n_1^2 + n_2^2 + n_3^2\\).</p> <p>Complexitate temporal\u0103: \\(O(n \\cdot m \\cdot nr_F + nr_F)\\). Complexitate spa\u021bial\u0103: \\(O(n \\cdot m)\\).</p>","tags":["OJI","clasa IX"]},{"location":"olimpiada/solutii/OJI/2023/IX-fibosnek/#cazul-c-2-si-n-m-leq-1000","title":"Cazul \\(c = 2\\) \u0219i \\(n, m \\leq 1000\\)","text":"<p>Pentru acest caz este necesar\u0103 \u00eembun\u0103t\u0103\u021birea algoritmului anterior prezentat. Putem verifica dac\u0103 un num\u0103r este sau nu Fibonacci c\u0103ut\u00e2nd binar \u00een loc de secven\u021bial acel num\u0103r \u00een tabloul \\(fib\\), astfel, reduc\u00e2nd complexitatea pentru verificarea fiec\u0103rui num\u0103r de la \\(O(nr_F)\\) la \\(O(\\log nr_F)\\).</p> <p>Complexitate temporal\u0103: \\(O(n \\cdot m \\cdot \\log nr_F)\\).</p>","tags":["OJI","clasa IX"]},{"location":"olimpiada/solutii/OJI/2023/IX-fibosnek/#solutia-finala","title":"Solu\u021bia final\u0103","text":"<p>Pentru a ob\u021bine punctajul maxim, este necesar\u0103 implementarea artificiului de memorare a indicilor \u0219i nu a termenilor Fibonacci propriu-zi\u0219i pentru a mic\u0219ora memoria utilizat\u0103.</p>","tags":["OJI","clasa IX"]},{"location":"olimpiada/solutii/OJI/2023/IX-fibosnek/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n\nvector&lt;long long&gt; fib;\n\nint closestfibleft (long long x) {\n    int L = 0;\n    int R = fib.size() - 1;\n    int ans = 0;\n    while (L &lt;= R) {\n        int mid = (L + R) / 2;\n        if (fib[mid] &lt;= x) {\n            ans = mid;\n            L = mid + 1;\n        }\n        else {\n            R = mid - 1;\n        }\n    }\n\n    return ans;\n}\n\nint closestfibright (long long x) {\n    int L = 0;\n    int R = fib.size() - 1;\n    int ans = 0;\n    while (L &lt;= R) {\n        int mid = (L + R) / 2;\n        if (fib[mid] &lt; x) {\n            L = mid + 1;\n        }\n        else {\n            ans = mid;\n            R = mid - 1;\n        }\n    }\n\n    return ans;\n}\nint main() {\n\n    ifstream cin(\"fibosnek.in\");\n    ofstream cout(\"fibosnek.out\");\n\n    int c, n, m;\n    cin &gt;&gt; c &gt;&gt; n &gt;&gt; m;\n\n    fib.push_back(0);\n    fib.push_back(1); \n    fib.push_back(2); \n\n    while(1) {\n        int sz = fib.size();\n        long long x = fib[sz-1] + fib[sz - 2];\n        fib.push_back(x); \n        if (x &gt;= (1LL&lt;&lt;36)) {\n            break;\n        }\n    }\n\n    char grid[n+1][m+1];\n    for (int i = 1; i &lt;= n; i++) {\n        for (int j = 1; j &lt;= m; j++) {\n            long long val;\n            cin &gt;&gt; val;\n\n            int posL = closestfibleft(val);\n            int posR = closestfibright(val);\n            if (fib[posL] == val) {\n                grid[i][j] = posL;\n            }\n            else {\n                if (abs(val - fib[posR]) &lt; abs(val - fib[posL])) {\n                    posL = posR;\n                }\n                grid[i][j] = -posL;\n            }\n        }\n    }\n\n    if (c == 1) {\n        int ans = 0;\n        for (int i = 1; i &lt;= n; i++) {\n            for (int j = 1; j &lt;= m; j++) {\n                if (grid[i][j] &gt; 0) {\n                    ans++;\n                }\n            }\n        }\n\n        cout &lt;&lt; ans &lt;&lt; '\\n';\n    }\n    else {\n        deque &lt;pair&lt;int, long long&gt; &gt; seqs;\n        int streak = 0;\n        long long sum = 0;\n\n        int maxlen = 0;\n        long long sm = 0;\n        for (int j = 1; j &lt;= m; j++) {\n            for (int i = 1; i &lt;= n; i++) {\n                if (grid[i][j] &gt; 0) {\n                    if (streak &gt;= 0) {\n                        streak++;\n                        sum += fib[grid[i][j]];\n                    }\n                    else {\n                        seqs.push_back ({streak, sum});\n                        streak = 1;\n                        sum = fib[grid[i][j]];\n                    }\n                }\n                else {\n                    grid[i][j] *= -1;\n                    if (streak &lt; 0) {\n                        streak--;\n                        sum += fib[grid[i][j]];\n                    }\n                    else {\n                        seqs.push_back ({streak, sum});\n                        streak = -1;\n                        sum = fib[grid[i][j]];\n                    }\n                }\n\n                if (seqs.size() &gt;= 4) {\n                    int N = (int) seqs.size();\n\n                    for (int i = 0; i &lt; N; i++) {\n                        if (seqs[i].first &gt; maxlen) {\n                            maxlen = seqs[i].first;\n                            sm = seqs[i].second;\n                        }\n                    }\n\n                    for (int i = 0; i &lt; N; i++) {\n                        if (seqs[i].first &lt; 0) {\n                            if (abs(seqs[i].first) + (i &gt; 0) * seqs[i-1].first + (i + 1 &lt; N) * seqs[i+1].first &gt; maxlen) {\n                                maxlen = abs(seqs[i].first) + (i &gt; 0) * seqs[i-1].first + (i + 1 &lt; N) * seqs[i+1].first;\n                                sm = seqs[i].second + (i &gt; 0) * seqs[i-1].second + (i + 1 &lt; N) * seqs[i+1].second;\n                            }\n                        }\n                    }\n\n                    seqs.pop_front();\n                }\n            }\n        }\n        seqs.push_back({streak, sum});\n\n\n        int N = (int) seqs.size();\n\n        for (int i = 0; i &lt; N; i++) {\n            if (seqs[i].first &gt; maxlen) {\n                maxlen = seqs[i].first;\n                sm = seqs[i].second;\n            }\n        }\n\n        for (int i = 0; i &lt; N; i++) {\n            if (seqs[i].first &lt; 0) {\n                if (abs(seqs[i].first) + (i &gt; 0) * seqs[i-1].first + (i + 1 &lt; N) * seqs[i+1].first &gt; maxlen) {\n                    maxlen = abs(seqs[i].first) + (i &gt; 0) * seqs[i-1].first + (i + 1 &lt; N) * seqs[i+1].first;\n                    sm = seqs[i].second + (i &gt; 0) * seqs[i-1].second + (i + 1 &lt; N) * seqs[i+1].second;\n                }\n            }\n        }\n\n        cout &lt;&lt; sm &lt;&lt; '\\n';\n    }\n    return 0;\n}\n</code></pre>","tags":["OJI","clasa IX"]},{"location":"olimpiada/solutii/OJI/2023/V-aeriana/","title":"Solu\u021bia problemei aeriana (OJI 2023, clasa a V-a)","text":"<p>Pentru cerin\u021ba \\(1\\), se calculeaz\u0103 toate duratele zborurilor, iar pe urm\u0103 trebuie afi\u0219at maximul dintre acestea. Pentru calculul duratei unui zbor, at\u00e2t momentul decol\u0103rii, c\u00e2t \u0219i momentul ateriz\u0103rii \u201ese convertesc \u00een minute\u201d, adic\u0103 se afl\u0103, pentru fiecare moment, \u201edistan\u021ba \u00een minute\u201d dintre momentul \\(00:00\\) al primei zile \u0219i momentul respectiv, presupun\u00e2nd c\u0103 ambele momente sunt \u00een ziua  1, cu formula \\(total_{minute} = H \\cdot 60 + M\\).</p> <p>\u00cen cazul \u00een care decolarea \u0219i aterizarea au loc \u00een aceea\u0219i zi, durata zborului (\u00een minute) este dat\u0103 de diferen\u021ba dintre \\(total_{{minute}_2}\\) \u0219i \\(total_{{minute}_1}\\). \u00cen cazul \u00een care decolarea \u0219i aterizarea au loc \u00een zile diferite, diferen\u021ba anterioar\u0103 ar fi negativ\u0103. \u00cen acest caz, se adun\u0103 \u201e\u00eenc\u0103 o zi\u201d, adic\u0103 \\(24 \\cdot 60\\) minute la \\(total_{{minute}_2}\\), deoarece ini\u021bial am presupus c\u0103 momentul ateriz\u0103rii este \u00een ziua 1.</p> <p>Pentru cerin\u021ba 2, se verific\u0103 pentru fiecare zbor dac\u0103 este \u201ezbor special\u201d. \u00cen primul r\u00e2nd, primul cod (notat \u00een enun\u021b \\(A_1\\)) trebuie s\u0103 fie un num\u0103r prim (deci obligatoriu mai mare sau egal cu 2). Pentru a c\u0103uta mai rapid dac\u0103 are alt divizor \u00een afar\u0103 de 1 \u0219i el \u00eensu\u0219i, ne folosim de faptul c\u0103 pentru orice divizor \\(d\\) al lui \\(A_1\\), automat \\(A_1 / d\\) ar fi divizor al lui \\(A_1\\). Astfel c\u0103ut\u0103m divizori posibili \\(d\\) ai lui \\(A_1\\) pornind cu \\(d = 2\\) \u0219i merg\u00e2nd c\u00e2t timp \\(d \\leq A_1 / d\\). Dac\u0103 primul cod este prim, se calculeaz\u0103 suma cifrelor acestuia \u0219i se verific\u0103 dac\u0103 al doilea cod e divizibil cu suma calculat\u0103. \u00cen cazul \u00een care un zbor este \u201especial\u201d, se interschimb\u0103 \\(h_1\\) cu \\(h_2\\) \u0219i \\(m_1\\) cu \\(m_2\\).</p> <p>Se calculeaz\u0103 duratele zborurilor \u0219i maximul dintre acestea, precum \u00een cazul cerin\u021bei 1.</p> <p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;fstream&gt;\nusing namespace std;\n\nint c, n, a, b, h1, m1, h2, m2;\n\nint main() {\n    ifstream cin(\"aeriana.in\");\n    ofstream cout(\"aeriana.out\");\n\n    cin &gt;&gt; c;\n    cin &gt;&gt; n;\n\n    int maxh = 0, maxm = 0;\n    for (int i = 1; i &lt;= n; i++) {\n        cin &gt;&gt; a &gt;&gt; b &gt;&gt; h1 &gt;&gt; m1 &gt;&gt; h2 &gt;&gt; m2;\n        bool prim = 1;\n        if (a &lt; 2) {\n            prim = 0;\n        }\n        for (int j = 2; j * j &lt;= a; j++) {\n            if (a % j == 0) {\n                prim = 0;\n            }\n        }\n        int sc = 0;\n        while (a) {\n            sc += a % 10;\n            a /= 10;\n        }\n        if (c == 2 &amp;&amp; prim == 1 &amp;&amp; b % sc == 0) {\n            swap(h1, h2);\n            swap(m1, m2);\n        }\n        int timp = h2 * 60 + m2 - h1 * 60 - m1;\n        if (timp &lt; 0) {\n            timp += 1440;\n        }\n        if (timp &gt; maxh * 60 + maxm) {\n            maxh = timp / 60;\n            maxm = timp % 60;\n        }\n    }\n\n    cout &lt;&lt; maxh &lt;&lt; \" \" &lt;&lt; maxm &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["OJI","clasa V"]},{"location":"olimpiada/solutii/OJI/2023/V-castel/","title":"Solu\u021bia problemei castel (OJI 2023, clasa a V-a)","text":"<p>Pentru cerin\u021ba, 1, se contorizeaz\u0103 toate valorile citite care au o singur\u0103 cifr\u0103, ele sunt strict mai mari dec\u00e2t 0, \u0219i mai mici sau egale cu 9.  </p> <p>Pentru cerin\u021ba 2, se calculeaz\u0103, pentru fiecare r\u00e2nd \\(R\\) al castelului, num\u0103rul cuburilor galbene aflate pe acesta. \u0218tim c\u0103 pe ultimul r\u00e2nd este un singur cub galben, pe penultimul r\u00e2nd sunt 2 cuburi galbene, pe antepenultimul 3 cuburi galbene, \u0219i, proced\u00e2nd \u00een acest fel, pe primul r\u00e2nd al castelului (numerotat  cu 1) sunt \\(K\\) cuburi galbene. Astfel, castelul construit, are \u00een total \\(1+2+3+4+\\ldots+K\\) cuburi galbene, aranjate pe cele \\(K\\) r\u00e2nduri.  </p> <p>Determin\u0103m cea mai mare valoare a lui \\(K\\) pentru care suma \\(1+2+3+4+\\ldots+K\\) nu dep\u0103\u0219e\u0219te valoarea lui \\(N\\). R\u00e2ndul pe care se afl\u0103 cubul din v\u00e2rful castelului este \\(K\\) iar num\u0103rul scris pe acesta este cel de pe pozi\u021bia \\(p\\) \u00een \u0219irul de intrare, unde \\(p = 1 + 2 + \\ldots + K\\).  </p> <p>Alternativ \\(p\\) poate fi determinat \u0219i cu formula \\(\\frac{K \\cdot (K+1)}{2}\\).  </p> <p>Pentru cerin\u021ba 3, observ\u0103m c\u0103 pe fiecare r\u00e2nd al castelului num\u0103rul cuburilor albastre este cu 1 mai mic dec\u00e2t num\u0103rul cuburilor galbene. P\u0103str\u00e2nd acelea\u0219i nota\u021bii ca la cerin\u021ba anterioar\u0103, num\u0103rul cuburilor albastre din castel este egal cu \\(1+2+3+\\ldots+(K-1)\\).  </p> <p>Pentru fiecare cub albastru, calcul\u0103m num\u0103rul scris pe acesta ca fiind suma a dou\u0103 valori preluate succesiv din fi\u0219ierul de intrare. Acestea reprezint\u0103 numerele scrise pe cuburile galbene situate pe acela\u0219i r\u00e2nd, \u00een st\u00e2nga \u0219i dreapta fiec\u0103rui cub albastru. Calcul\u0103m suma tuturor valorilor scrise pe cuburile albastre din castel.</p> <p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;fstream&gt;\nusing namespace std;\n\nint main() {\n    ifstream cin(\"castel.in\");\n    ofstream cout(\"castel.out\");\n\n    int c, n;\n    cin &gt;&gt; c &gt;&gt; n;\n\n    if (c == 1) {\n        int cnt = 0;\n        for (int i = 1; i &lt;= n; i++) {\n            int x;\n            cin &gt;&gt; x;\n            if (x &lt;= 9) {\n                cnt++;\n            }\n        }\n        cout &lt;&lt; cnt &lt;&lt; '\\n';\n    }\n    if (c == 2) {\n        int sum = 0;\n        int x = 1;\n        while (sum + x &lt;= n) {\n            sum += x;\n            x++;\n        }\n        cout &lt;&lt; x - 1 &lt;&lt; \" \";\n        for (int i = 1; i &lt;= n; i++) {\n            int x;\n            cin &gt;&gt; x;\n            if (i == sum) {\n                cout &lt;&lt; x &lt;&lt; \" \";\n            }\n        }\n    }\n    if (c == 3) {\n        int sum = 0;\n        int x = 1;\n        while (sum + x &lt;= n) {\n            sum += x;\n            x++;\n        }\n        cout &lt;&lt; sum - x + 1 &lt;&lt; \" \";\n        long long total = 0;\n        long long sum2 = 0;\n        long long x2 = x - 1;\n\n        for (int i = 1; i &lt; sum; i++) {\n            int x;\n            cin &gt;&gt; x;\n            if (i == sum2 + 1 || i == sum2 + x2) {\n                total += x;\n                if (i == sum2 + x2) {\n                    sum2 += x2;\n                    x2--;\n                }\n            } else {\n                total += 2 * x;\n            }\n        }\n        cout &lt;&lt; total &lt;&lt; \" \";\n    }\n    return 0;\n}\n</code></pre>","tags":["OJI","clasa V"]},{"location":"olimpiada/solutii/OJI/2023/VI-ciocolata/","title":"Solu\u021bia problemei ciocolata (OJI 2023, clasa a VI-a)","text":"<p>Pentru cerin\u021ba, 1, se contorizeaz\u0103 toate valorile citite care au o singur\u0103 cifr\u0103, ele sunt strict mai mari dec\u00e2t 0, \u0219i mai mici sau egale cu 9.  </p> <p>Pentru cerin\u021ba 2, se calculeaz\u0103, pentru fiecare r\u00e2nd \\(R\\) al castelului, num\u0103rul cuburilor galbene aflate pe acesta. \u0218tim c\u0103 pe ultimul r\u00e2nd este un singur cub galben, pe penultimul r\u00e2nd sunt 2 cuburi galbene, pe antepenultimul 3 cuburi galbene, \u0219i, proced\u00e2nd \u00een acest fel, pe primul r\u00e2nd al castelului (numerotat cu 1) sunt \\(K\\) cuburi galbene. Astfel, castelul construit, are \u00een total \\(1+2+3+4+\\ldots+K\\) cuburi galbene, aranjate pe cele \\(K\\) r\u00e2nduri.  </p> <p>Determin\u0103m cea mai mare valoare a lui \\(K\\) pentru care suma \\(1+2+3+4+\\ldots+K\\) nu dep\u0103\u0219e\u0219te valoarea lui \\(N\\). R\u00e2ndul pe care se afl\u0103 cubul din v\u00e2rful castelului este \\(K\\) iar num\u0103rul scris pe acesta este cel de pe pozi\u021bia \\(p\\) \u00een \u0219irul de intrare, unde \\(p = 1 + 2 + \\ldots + K\\).  </p> <p>Alternativ \\(p\\) poate fi determinat \u0219i cu formula \\(\\frac{K \\cdot (K+1)}{2}\\).  </p> <p>Pentru cerin\u021ba 3, observ\u0103m c\u0103 pe fiecare r\u00e2nd al castelului num\u0103rul cuburilor albastre este cu 1 mai mic dec\u00e2t num\u0103rul cuburilor galbene. P\u0103str\u00e2nd acelea\u0219i nota\u021bii ca la cerin\u021ba anterioar\u0103, num\u0103rul cuburilor albastre din castel este egal cu \\(1+2+3+\\ldots+(K-1)\\).  </p> <p>Pentru fiecare cub albastru, calcul\u0103m num\u0103rul scris pe acesta ca fiind suma a dou\u0103 valori preluate succesiv din fi\u0219ierul de intrare. Acestea reprezint\u0103 numerele scrise pe cuburile galbene situate pe acela\u0219i r\u00e2nd, \u00een st\u00e2nga \u0219i dreapta fiec\u0103rui cub albastru. Calcul\u0103m suma tuturor valorilor scrise pe cuburile albastre din castel.</p> <p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n\nint main() {\n    ifstream cin(\"ciocolata.in\");\n    ofstream cout(\"ciocolata.out\");\n\n    int c, n, v[100001];\n    cin &gt;&gt; c &gt;&gt; n;\n\n    for (int i = 1; i &lt;= n; i++) {\n        cin &gt;&gt; v[i];\n    }\n\n    int fr[10001] = {0};\n\n    // cerinta 1 se rezolva cu vectori de frecventa\n    if (c == 1) {\n        for (int i = 1; i &lt;= n; i++) {\n            fr[v[i]]++;\n        }\n        int maxi = 0;\n        for (int i = 1; i &lt;= 10000; i++) {\n            if (fr[i] &gt; fr[maxi]) {\n                maxi = i;\n            }\n        }\n        cout &lt;&lt; maxi &lt;&lt; '\\n';\n    } else {\n        int mindif = 1000000000;\n        int sumIrina = 0;\n\n        // pozitia pana unde a mancat Mihaela\n        int j = n;\n        int sumMihaela = 0;\n        for (int i = 1; i &lt;= n; i++) {\n            sumIrina += v[i];\n            while (sumMihaela + v[j] &lt;= sumIrina &amp;&amp; j &gt; i) {\n                sumMihaela += v[j];\n                j--;\n            }\n            while (j &lt; i) {\n                j++;\n                sumMihaela -= v[j];\n            }\n            if (j != n) {\n                mindif = min(mindif, sumIrina - sumMihaela);\n            }\n        }\n\n        cout &lt;&lt; mindif;\n    }\n    return 0;\n}\n</code></pre>","tags":["OJI","clasa VI"]},{"location":"olimpiada/solutii/OJI/2023/VI-unificare/","title":"Solu\u021bia problemei unificare (OJI 2023, clasa a VI-a)","text":"<p>Cerin\u021ba 1. Pentru fiecare num\u0103r din cele \\(n\\) citite determin\u0103m num\u0103rul de cifre. Dac\u0103 acesta este egal cu \\(k\\), atunci compar\u0103m num\u0103rul cu maximul determinat p\u00e2n\u0103 atunci, pentru a identifica cel mai mare num\u0103r.  </p> <p>Cerin\u021ba 2. Pentru fiecare pereche de valori aflate pe pozi\u021bii al\u0103turate \u00een \u0219ir determin\u0103m valoarea ob\u021binut\u0103 prin unificarea celor dou\u0103 numere \u00een vederea determin\u0103rii maximului posibil. O variant\u0103 pentru a determina valoarea unificat\u0103 pentru dou\u0103 numere este s\u0103 consider\u0103m toate cifrele \u00een ordine descresc\u0103toare \u0219i s\u0103 ad\u0103ug\u0103m la num\u0103rul pe care \u00eel form\u0103m acele cifre care apar \u00een scrierea fiec\u0103rui num\u0103r.  </p> <p>Cerin\u021ba 3. Trebuie s\u0103 unific\u0103m c\u00e2te \\(k\\) valori aflate pe pozi\u021bii consecutive \u00een \u0219irul dat, iar valoarea ob\u021binut\u0103 ar fi prea mare pentru a putea fi re\u021binut\u0103 \u00eentr-o variabil\u0103 simpl\u0103 de memorie. Putem utiliza un vector de num\u0103rare \u00een care s\u0103 re\u021binem, pentru fiecare cifr\u0103, \u00een c\u00e2te dintre numerele dintr-o secven\u021b\u0103 de \\(k\\) valori aflate pe pozi\u021bii consecutive \u00een \u0219ir, apare cifra respectiv\u0103. Pentru a compara num\u0103rul curent cu maximul pe care \u00eel determin\u0103m va trebui mai \u00eent\u00e2i s\u0103 verific\u0103m dac\u0103 am ob\u021binut un num\u0103r cu mai multe cifre, caz \u00een care ar fi mai mare, sau dac\u0103 avem acela\u0219i num\u0103r de cifre, verific\u0103m dac\u0103 avem o cifr\u0103 mai mare cu un num\u0103r mai mare de apari\u021bii. Maximul ob\u021binut \u00eel vom afi\u0219a, cifr\u0103 cu cifr\u0103, \u00een fi\u0219ierul de ie\u0219ire.  </p> <p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;fstream&gt;\n#include &lt;iostream&gt;\n\nusing namespace std;\n\nifstream fin(\"unificare.in\");\nofstream fout(\"unificare.out\");\n\nbool v1[10], v2[10], v[100005][10];\nshort sume[100005][10], maxc[C10];\n\nint main() {\n    short cerinta, nrc, nrcmax = 0;\n    int n, k, x, copie, maxim = 0;\n    long long maxnr = 0, nr;\n    fin &gt;&gt; cerinta &gt;&gt; n &gt;&gt; k;\n\n    if (cerinta == 1) {\n        for (int i = 1; i &lt;= n; i++) {\n            fin &gt;&gt; x;\n            nrc = 0;\n            copie = x;\n\n            do {\n                nrc++;\n                x /= 10;\n            } while (x);\n\n            if (nrc == k) {\n                maxim = max(maxim, copie);\n            }\n        }\n\n        fout &lt;&lt; maxim;\n    } else if (cerinta == 2) {\n        fin &gt;&gt; x;\n\n        while (x) {\n            v1[x % 10] = true;\n            x /= 10;\n        }\n\n        for (int i = 2; i &lt;= n; i++) {\n            fin &gt;&gt; x;\n\n            for (short j = 0; j &lt;= 9; j++) {\n                v2[j] = false;\n            }\n\n            while (x) {\n                v2[x % 10] = true;\n                x /= 10;\n            }\n\n            nr = 0;\n\n            for (short j = 9; j &gt;= 0; j--) {\n                if (v1[j]) {\n                    nr = nr * 10 + j;\n                }\n\n                if (v2[j]) {\n                    nr = nr * 10 + j;\n                }\n            }\n\n            maxnr = max(maxnr, nr);\n\n            for (short j = 0; j &lt;= 9; j++) {\n                v1[j] = v2[j];\n            }\n        }\n\n        fout &lt;&lt; maxnr;\n    } else {\n        for (int i = 1; i &lt;= n; i++) {\n            fin &gt;&gt; x;\n\n            while (x) {\n                v[i][x % 10] = true;\n                x /= 10;\n            }\n\n            for (short j = 0; j &lt;= 9; j++) {\n                sume[i][j] = sume[i - 1][j] + v[i][j];\n            }\n        }\n\n        for (int i = 1; i &lt;= n - k + 1; i++) {\n            short curent[10], nrc = 0;\n\n            for (short j = 0; j &lt;= 9; j++) {\n                curent[j] = sume[i + k - 1][j] - sume[i - 1][j];\n                nrc += curent[j];\n            }\n\n            if (nrc &gt; nrcmax) {\n                nrcmax = nrc;\n\n                for (short j = 9; j &gt;= 0; j--) {\n                    maxc[j] = curent[j];\n                }\n            } else if (nrc == nrcmax) {\n                for (short j = 9; j &gt;= 0; j--) {\n                    if (curent[j] &gt; maxc[j]) {\n                        for (short k = 9; k &gt;= 0; k--) {\n                            maxc[k] = curent[k];\n                        }\n\n                        break;\n                    }\n\n                    if (curent[j] &lt; maxc[j]) {\n                        break;\n                    }\n                }\n            }\n        }\n\n        for (short i = 9; i &gt;= 0; i--) {\n            for (short j = 1; j &lt;= maxc[i]; j++) {\n                fout &lt;&lt; i;\n            }\n        }\n    }\n\n    return 0;\n}\n</code></pre>","tags":["OJI","clasa VI"]},{"location":"olimpiada/solutii/OJI/2023/VII-palindrom/","title":"Solu\u021bia problemei palindrom (OJI 2023, clasa a VII-a)","text":"<p>Cerin\u021ba 1. Vom citi succesiv numerele \u0219i vom determina pentru fiecare num\u0103r citit num\u0103rul minim de cifre care trebuie s\u0103 fie ad\u0103ugate pentru a transforma num\u0103rul respectiv \u00een palindrom. Pentru numere mari (de maximum 50 de cifre), vom citi fiecare num\u0103r caracter cu caracter, p\u00e2n\u0103 la \u00eent\u00e2lnirea marcajului de sf\u00e2r\u0219it de linie \u0219i vom re\u021bine cifrele num\u0103rului \u00eentr-un vector.  </p> <p>Pentru punctaj par\u021bial (numere de maximum 18 cifre), se va citi num\u0103rul \u00eentr-o variabil\u0103 de tip <code>long long int</code>, apoi se vor extrage cifrele num\u0103rului \u0219i se vor plasa \u00eentr-un vector. Pentru a determina num\u0103rul minim de cifre care trebuie ad\u0103ugate la finalul num\u0103rului pentru a transforma acest num\u0103r \u00een palindrom, putem determina lungimea celui mai lung sufix al num\u0103rului care are proprietatea de a fi palindrom. S\u0103 not\u0103m aceast\u0103 lungime cu \\(lgs\\), iar lungimea num\u0103rului cu \\(lg\\). Num\u0103rul minim de cifre care trebuie s\u0103 fie ad\u0103ugate este \\(nr = lg - lgs\\) (se adaug\u0103 la final primele \\(nr\\) cifre ale num\u0103rului \u00een ordine inversat\u0103). Desigur, pentru punctaj par\u021bial este posibil\u0103 \u0219i o abordare \u201eprin \u00eencerc\u0103ri\u201d:</p> <ul> <li>dac\u0103 num\u0103rul este deja palindrom, \\(nr = 0\\);  </li> <li>dac\u0103 num\u0103rul nu este palindrom, ad\u0103ug\u0103m la sf\u00e2r\u0219itul lui o cifr\u0103 (prima cifr\u0103   a num\u0103rului) \u0219i verific\u0103m dac\u0103 se ob\u021bine un palindrom (\u00een acest caz \\(nr\\) va fi   1);</li> <li>apoi \u00eencerc\u0103m cu dou\u0103 cifre, trei cifre, \u0219.a.m.d.;  </li> <li>\u00een cel mai defavorabil caz vom ad\u0103uga \\(nr = lg - 1\\) cifre (primele \\(lg - 1\\)   cifre \u00een ordine inversat\u0103).  </li> </ul> <p>Nu este necesar s\u0103 re\u021binem toate numerele citite, vom re\u021bine \u00eentr-un vector \\(nr\\) cu \\(n\\) elemente num\u0103rul minim de cifre care trebuie s\u0103 fie ad\u0103ugate pentru a transforma fiecare num\u0103r din \u0219ir \u00een palindrom. Rezultatul la cerin\u021ba 1 este suma valorilor memorate \u00een vectorul \\(nr\\).  </p> <p>Cerin\u021ba 2. Trebuie s\u0103 determin\u0103m cea mai lung\u0103 subsecven\u021b\u0103 a vectorului \\(nr\\), construit la cerin\u021ba anterioar\u0103, care are suma elementelor mai mic\u0103 sau egal\u0103 cu \\(S\\). Pentru aceasta vom parcurge vectorul \\(nr\\) c\u00e2t timp suma elementelor din secven\u021ba curent\u0103 (s\u0103 o not\u0103m \\(sum\\)) este \\(\\leq S\\). C\u00e2nd am ajuns la o pozi\u021bie \\(i\\) pentru care \\(sum + nr[i] &gt; S\\), elementul curent nu mai poate fi \u201e\u00eenghi\u021bit\u201d \u00een solu\u021bie. Prin urmare:  </p> <ul> <li>compar\u0103m lungimea secven\u021bei curente cu lungimea maxim\u0103 \u0219i o re\u021binem dac\u0103 este   mai mare;  </li> <li>elimin\u0103m elementele de la \u00eenceputul secven\u021bei curente, actualiz\u00e2nd   corespunz\u0103tor \\(sum\\), p\u00e2n\u0103 c\u00e2nd este posibil s\u0103 \u201e\u00eenghi\u021bim\u201d valoarea \\(nr[i]\\) \u00een   solu\u021bie (\\(sum + nr[i] \\leq S\\)).  </li> </ul> <p>C\u00e2nd parcurgerea vectorului \\(nr\\) s-a \u00eencheiat, trebuie s\u0103 compar\u0103m \u0219i lungimea ultimei secven\u021be cu lungimea maxim\u0103.  </p> <p>Pentru punctaje par\u021biale sunt posibile \u0219i abord\u0103ri de complexitate \\(\\mathcal{O}(n^2)\\) sau \\(\\mathcal{O}(n^3)\\).  </p> <p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n\nint prevAns[50005];\n\nint main() {\n    ifstream cin(\"palindrom.in\");\n    ofstream cout(\"palindrom.out\");\n\n    int cer, n, i, s, j, k, ans, st, dr, sum;\n    string str, aux;\n\n    cin &gt;&gt; cer &gt;&gt; n;\n\n    ans = 0;\n    for (i = 1; i &lt;= n; i++) {\n        cin &gt;&gt; str;\n\n        for (j = 0; j &lt; (int)str.size(); j++) {\n            st = j, dr = (int)str.size() - 1;\n            while (st &lt; dr &amp;&amp; str[st] == str[dr]) {\n                st++;\n                dr--;\n            }\n\n            if (st &gt;= dr) {\n                break;\n            }\n        }\n\n        ans += j;\n        prevAns[i] = j;\n    }\n\n    if (cer == 1) {\n        cout &lt;&lt; ans;\n    } else {\n        cin &gt;&gt; s;\n\n        ans = INT_MIN;\n        sum = 0, j = 1;\n        for (i = 1; i &lt;= n; i++) {\n            sum += prevAns[i];\n            while (sum &gt; s) {\n                sum -= prevAns[j++];\n            }\n            ans = max(ans, i - j + 1);\n        }\n\n        cout &lt;&lt; ans;\n    }\n\n    return 0;\n}\n</code></pre>","tags":["OJI","clasa VII"]},{"location":"olimpiada/solutii/OJI/2023/VII-primprim/","title":"Solu\u021bia problemei primprim (OJI 2023, clasa a VII-a)","text":"<p>Pentru ambele cerin\u021be va fi necesar s\u0103 determin\u0103m c\u00e2t mai rapid pentru un num\u0103r dat distan\u021ba fa\u021b\u0103 de cel mai apropiat num\u0103r prim. O prim\u0103 abordare ar fi ca pentru fiecare num\u0103r s\u0103 verific\u0103m mai \u00eent\u00e2i dac\u0103 este prim (\u00een acest caz, costul ar fi 0), iar \u00een caz contrar ne deplas\u0103m la st\u00e2nga \u0219i la dreapta sa p\u00e2n\u0103 c\u00e2nd identific\u0103m un num\u0103r prim, calcul\u00e2nd apoi costul folosind formula dat\u0103 din enun\u021b. Totu\u0219i, o asemenea abordare ar avea complexitatea O(\\(x * \\sqrt{valmax}\\)), unde \\(x\\) reprezint\u0103 distan\u021ba maxim\u0103 fa\u021b\u0103 de un num\u0103r prim. Deoarece \\(x\\) este cel mult 57, o asemenea abordare nu ob\u021bine punctaj maxim.</p> <p>Pentru a optimiza aceast\u0103 abordare, vom precalcula costurile pentru toate numerele de la 1 la \\(10^6\\). Pentru aceasta, vom utiliza ciurul lui Eratostene, pentru a genera numerele prime \\(\\leq 10^6\\), urm\u00e2nd ca mai apoi costul s\u0103 fie calculat \u00een O(1) pentru fiecare num\u0103r. Complexitatea precalcul\u0103rii este O(\\(n \\log \\log n\\)).</p> <p>Cerin\u0163a 1. Vom citi succesiv numerele \u0219i vom afla succesiv costul pentru fiecare num\u0103r de la intrare, re\u021bin\u00e2nd \u00eentr-o variabil\u0103 suma costurilor. \u00cen func\u021bie de abordarea folosit\u0103 pentru calcularea costurilor, se pot ob\u021bine diverse punctaje par\u021biale, dar punctajul maxim pe cerin\u021b\u0103 se poate ob\u021bine doar folosind metoda bazat\u0103 pe ciurul lui Eratostene, abordare explicat\u0103 mai sus.</p> <p>Cerin\u0163a 2. Pentru aceast\u0103 cerin\u021b\u0103 vom citi succesiv opera\u021biile \u0219i le vom executa.Pentru a ob\u021bine un cost total minim trebuie s\u0103 adun\u0103m cele mai mici \\(p\\) costuri. O abordare eficient\u0103 se bazeaz\u0103 pe observa\u021bia c\u0103 pentru orice num\u0103r costul este cel mult 57, fapt ce ne permite s\u0103 utiliz\u0103m un vector de frecven\u021b\u0103 \\(fr\\), unde \\(fr[i]\\) = num\u0103rul de elemente din vectorul \\(v\\) care au costul \\(i\\).</p> <p>Pentru fiecare opera\u021bie, la modificarea unei valori din vector, vom decrementa frecven\u021ba costului pentru vechea valoare \u0219i vom incrementa frecven\u021ba costului pentru noua valoare.</p> <p>Pentru a determina costul total minim pentru a ob\u021bine cel pu\u021bin \\(p\\) numere prime \u00een vector (valoarea afi\u0219at\u0103 dup\u0103 executarea opera\u021biei), vom parcurge vectorul de frecven\u021b\u0103 de la st\u00e2nga la dreapta (\\(i=0, \\dots, 57\\)). La fiecare pas \\(i\\), pentru a calcula costul total minim adun\u0103m la o variabil\u0103 \\(cmin\\) produsul dintre \\(fr[i]\\) \u0219i \\(i\\) (exist\u0103 \\(fr[i]\\) numere care pot fi transformate \u00een numere prime cu costul \\(i\\)), iar \u00eentr-o variabil\u0103 \\(nr\\) re\u021binem c\u00e2te numere prime au fost deja ob\u021binute. \u00cen momentul \u00een care \\(nr+fr[i]&gt;p\\), parcurgerea se opre\u0219te \u0219i adun\u0103m la \\(cmin\\) doar costul ob\u021binerii celor \\(p-nr\\) numere prime care mai sunt necesare (adic\u0103 adun\u0103m \\(fr[i] \\cdot (p-nr)\\).</p> <p>\u00cen func\u021bie de cum select\u0103m cele mai mici \\(p\\) costuri \u0219i \u00een func\u021bie de cum calcul\u0103m costurile, se pot ob\u021bine diverse punctaje par\u021biale.</p> <p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;cmath&gt;\n#include &lt;fstream&gt;\n\nusing namespace std;\n\nifstream fin(\"primprim.in\");\nofstream fout(\"primprim.out\");\n\nint vals[1000002], primes[200002], cnt, ans[1100002];\nbool pr[1100002];\n\nint fr[202];\n\nint main() {\n    int c;\n    fin &gt;&gt; c;\n\n    int n, a = 1100000, i, j;\n    fin &gt;&gt; n;\n\n    for (i = 1; i &lt;= n; i++) {\n        fin &gt;&gt; vals[i];\n    }\n\n    // precalculam raspunsul optim pentru fiecare numar de la 1 la a folosind\n    // ciurul lui Eratostene\n\n    for (i = 2; i &lt;= a; i++) {\n        if (pr[i] == 0) {\n            primes[cnt++] = i;\n            for (j = i + i; j &lt;= a; j += i) {\n                pr[j] = 1;\n            }\n        }\n    }\n\n    int poz = -1;\n\n    // parcurg valorile de la 1 la a pentru a afla raspunsul optim dupa ce am\n    // aflat numerele prime\n    ans[1] = 1;\n    for (i = 2; i &lt;= a; i++) {\n        if (pr[i] == 0) {\n            poz++;\n        }\n        ans[i] = abs(i - primes[poz]);\n        if (poz + 1 &lt; cnt) {\n            ans[i] = min(ans[i], abs(i - primes[poz + 1]));\n        }\n    }\n\n    // voi folosi vector de frecventa pentru a tine aceste diferente, care de\n    // altfel sunt destul de mici\n\n    for (i = 1; i &lt;= n; i++) {\n        fr[ans[vals[i]]]++;\n    }\n\n    if (c == 1) {\n        int total = 0;\n        for (i = 1; i &lt;= n; i++) {\n            total += ans[vals[i]];\n        }\n        fout &lt;&lt; total;\n        return 0;\n    }\n\n    int q;\n    fin &gt;&gt; q;\n\n    for (i = 1; i &lt;= q; i++) {\n        int a, b, p;\n        fin &gt;&gt; a &gt;&gt; b &gt;&gt; p;\n\n        fr[ans[vals[a]]]--;\n        vals[a] = b;\n        fr[ans[vals[a]]]++;\n\n        int dif = 0;\n        int sol = 0;\n\n        // la fiecare pas parcurg vectorul de frecventa pana cand dau de p\n        // diferente\n\n        while (p) {\n            sol += min(p, fr[dif]) * dif;\n            p -= min(p, fr[dif]);\n            dif++;\n        }\n\n        fout &lt;&lt; sol &lt;&lt; '\\n';\n    }\n    return 0;\n}\n</code></pre>","tags":["OJI","clasa VII"]},{"location":"olimpiada/solutii/OJI/2023/VIII-hibrid/","title":"Solu\u021bia problemei hibrid (OJI 2023, clasa a VIII-a)","text":"<p>Observa\u021bie ini\u021bial\u0103: Pentru c\u0103 cele \\(P\\) por\u021biuni taxabile sunt disjuncte dou\u0103 c\u00e2te dou\u0103, iar nicio born\u0103 dintre cele \\(N\\) nu se poate afla la capetele sau \u00een interiorul segmentelor ce descriu por\u021biunile taxabile (mai formal, nu exist\u0103 nicio pereche de indici \\((i, j)\\): \\(1 \\leq i \\leq P\\) \u0219i \\(1 \\leq j \\leq N\\) pentru care \\(s_i \\leq x_j \\leq d_i\\)), \u00eenseamn\u0103 c\u0103 \\(d_i\\) ar putea fi ignorat pentru fiecare \\(i: 1 \\leq i \\leq P\\).  </p> <p>Astfel, dac\u0103 ar fi nevoie s\u0103 verific\u0103m, de exemplu, de c\u00e2te ori s-a trecut peste o por\u021biune taxabil\u0103, ar trebui doar verificat de c\u00e2te ori punctul de coordonat\u0103 \\(s_i\\) a fost vizitat \u00een timp ce se efectua deplasarea \u00eentre dou\u0103 borne consecutive de pe traseu; a num\u0103ra de c\u00e2te ori s-a trecut peste o por\u021biune taxabil\u0103 \\(i\\) \\((1 \\leq i \\leq P)\\) este echivalent cu a num\u0103ra num\u0103rul de indici \\(j\\) \\((1 \\leq j &lt; N)\\) pentru care: \\(\\min(x_j, x_{j+1}) &lt; s_i &lt; \\max(x_j, x_{j+1}).\\) \\(d_i\\), observ\u0103m, nu mai influen\u021beaz\u0103 aceast\u0103 abordare.  </p> <p>Nota\u021bii: \\(\\min(a, b) = a \\ \\text{dac\u0103} \\ a &lt; b, b \\ \\text{altfel.}\\). \\(\\max(a, b) = a \\ \\text{dac\u0103} \\ a &gt; b, b \\ \\text{altfel.}\\)</p> <p>Subtask 1: \u00centruc\u00e2t se cunoa\u0219te faptul c\u0103 pentru efectuarea traseului nu se va trece peste niciuna dintre cele \\(P\\) por\u021biuni taxabile (unde este impus\u0103 folosirea motorului termic), \u00een fi\u0219ierul de ie\u0219ire se va afi\u0219a \\(-1\\) (\u00een cazul \u00een care \\(C = 1\\)) sau 0 (\u00een cazul \u00een care \\(C = 2\\)).  </p> <p>Subtask 2: \u00centruc\u00e2t \\(0 \\leq x_i \\leq 70\\), pentru fiecare \\(i: 1 \\leq i \\leq N\\), \u00eenseamn\u0103 c\u0103 lungimea fiec\u0103rui segment de dreapt\u0103 \u00eentre dou\u0103 borne consecutive de pe traseu va fi de cel mult 70 (\\(|x_{i+1} - x_i| \\leq 70\\), pentru fiecare \\(i: 1 \\leq i &lt; N\\)).  </p> <p>S\u0103 consider\u0103m introducerea urm\u0103torului tablou unidimensional \\(\\text{fr}[0, \\ldots, 70]\\) ce con\u021bine exact 71 de elemente, cu urm\u0103toarea semnifica\u021bie: \\(\\text{fr}[x] \\, (0 \\leq x \\leq 70) = \\text{de c\u00e2te ori s-a trecut, \u00een timpul efectu\u0103rii traseului, prin coordonata } x \\text{ (de pe axa numerelor)}\\). Observ\u0103m c\u0103 \\(\\text{fr}[x] = 0\\) \u00een cazul \u00een care nu s-a trecut niciodat\u0103 prin dreptul coordonatei \\(x\\).  </p> <p>Pentru a calcula \u00eentr-o complexitate de \\(\\mathcal{O}(71 \\times N)\\) care vor fi valorile elementelor din vectorul \\(\\text{fr}[0, \\ldots, 70]\\), putem utiliza urm\u0103toarea metod\u0103, de tip brute-force:  </p> <p><pre><code>for (int i = 1; i &lt; N; ++i) {      /// iteram prin lista coordonatelor de borne\n    int p1 = min(x[i], x[i + 1]);  /// capat \"stanga\" pe axa numerelor intregi\n    int p2 = max(x[i], x[i + 1]);  /// capat \"dreapta\" pe axa numerelor intregi\n    for (int j = p1; j &lt;= p2;\n         ++j) {   /// iteram prin coordonatele de pe axa numerelor\n        ++fr[j];  /// incrementam numarul de \"vizite\" prin dreptul coordonatei j\n    }\n}\n</code></pre> Apoi, pentru cerin\u021ba \\(C = 1\\), se determin\u0103 care este indicele minim \\(i\\) \\((1 \\leq i \\leq P)\\) pentru care valoarea \\(\\text{fr}[s_i]\\) este maxim\u0103. Pentru cerin\u021ba \\(C = 2\\), se calculeaz\u0103 suma: \\(\\sum_{i=1}^P c_i \\cdot \\text{fr}[s_i].\\)</p> <p>Complexitate temporal\u0103 total\u0103: \\(\\mathcal{O}(P + N \\cdot 71)\\).  </p> <p>De remarcat: Pentru acest subtask se \u0219tie, \u00een plus, c\u0103 \\(0 \\leq s_i &lt; d_i \\leq 70\\), pentru fiecare \\(i: 1 \\leq i \\leq P\\). De asemenea, de vreme ce por\u021biunile taxabile sunt disjuncte dou\u0103 c\u00e2te dou\u0103, \u00eenseamn\u0103 c\u0103 num\u0103rul \\(P\\) nu poate fi prea mare. Mai exact, acesta este cel mult egal cu 35, \u0219i se poate ob\u021bine, de exemplu, pentru: \\(s_i = (i - 1) \\cdot 2\\) \u0219i \\(d_i = s_i + 1\\), pentru fiecare \\(i: 1 \\leq i \\leq P\\), rezult\u00e2nd \u00een intervalele: \\([0, 1], [2, 3], \\ldots,   [68, 69]\\).</p> <p>Astfel, \u00eenseamn\u0103 c\u0103 \u0219i o solu\u021bie cu o complexitate de \\(\\mathcal{O}(P \\cdot N) = O(35 \\cdot N)\\) va trece toate testele aferente acestui subtask.  </p> <p>Subtask 3: Ca \u0219i \u00een cazul precedent, avem \u00een continuare c\u0103 \\(|x_{i+1} - x_i| \\leq 70\\), pentru fiecare \\(i: 1 \\leq i &lt; N\\), ceea ce \u00eenseamn\u0103 c\u0103 am putea simula traseul descris, iter\u00e2nd prin fiecare coordonat\u0103 prin care ma\u0219ina hibrid\u0103 se deplaseaz\u0103.</p> <p>De asemenea, valoarea absolut\u0103 a coordonatelor bornelor este cel mult egal\u0103 cu 300000; prin urmare, pentru fiecare deplasare \u00eentre dou\u0103 borne consecutive am putea aplica acela\u0219i algoritm ca \u0219i mai sus. Trebuie avut grij\u0103 la faptul c\u0103 indicii ale c\u0103ror valori dorim s\u0103 le modific\u0103m \u00eentr-un tablou unidimensional de frecven\u021b\u0103/num\u0103rare ar putea deveni negativi.  </p> <p>A\u0219adar, vom aplica indicilor o transla\u021bie spre dreapta cu 300000 pozi\u021bii: mai exact, pozi\u021bia \\(-300000\\) va fi translatat\u0103 \u00een pozi\u021bia 0, pozi\u021bia \\(-299999\\) va fi translatat\u0103 \u00een pozi\u021bia 1, ..., pozi\u021bia 0 va fi translatat\u0103 \u00een pozi\u021bia 300000, ..., pozi\u021bia 300000 va fi translatat\u0103 \u00een pozi\u021bia 600000.  </p> <pre><code>for (int i = 1; i &lt; N; ++i) {      /// iteram prin lista coordonatelor de borne\n    int p1 = min(x[i], x[i + 1]);  /// capat \"stanga\" pe axa numerelor intregi\n    int p2 = max(x[i], x[i + 1]);  /// capat \"dreapta\" pe axa numerelor intregi\n    for (int j = p1; j &lt;= p2;\n         ++j) {            /// iteram prin coordonatele de pe axa numerelor\n        ++fr[j + 300000];  /// incrementam numarul de \"vizite\" prin dreptul\n                           /// coordonatei j\n    }\n}\n</code></pre> <p>\\(\\text{fr}[0, \\ldots, 600000]\\) este tabloul unidimensional cu ajutorul c\u0103ruia num\u0103r\u0103m de c\u00e2te ori s-a trecut prin dreptul fiec\u0103rei coordonate. Astfel, dac\u0103 dorim s\u0103 \u0219tim, de exemplu, de c\u00e2te ori am trecut prin coordonata \\(x\\) \\((-300000 \\leq x \\leq 300000)\\), acces\u0103m valoarea \\(\\text{fr}[x + 300000]\\). Complexitatea temporal\u0103 total\u0103 r\u0103m\u00e2ne: \\(\\mathcal{O}(P + N \\cdot 71)\\).  </p> <p>Subtask 4: Vom simula, \u00een continuare, traseul ma\u0219inii pe \u0219osea, \u00eens\u0103, pentru a ne \u00eencadra \u00een limita de timp dat\u0103, nu vom mai parcurge coordonate de pe axa numerelor, ci vom parcurge direct lista de intervale ce descriu cele \\(P\\) por\u021biuni taxabile.  </p> <p>Mai exact spus, vom parcurge fiecare segment \\((i, i + 1)\\) \\((1 \\leq i &lt; N)\\) al traseului. Vom itera, apoi, prin lista celor \\(P\\) por\u021biuni, un indice \\(j\\) \\((1 \\leq j \\leq P)\\) \u0219i dac\u0103 se \u00eent\u00e2mpl\u0103 s\u0103 avem: \\(\\min(x_i, x_{i+1}) &lt; s_j &lt; \\max(x_i, x_{i+1})\\), \u00een lumina observa\u021biei ini\u021biale, \u00eenseamn\u0103 c\u0103 por\u021biunea taxabil\u0103 cu indicele \\(j\\) a fost traversat\u0103 \u00een timp ce se f\u0103cea deplasarea de la coordonata bornei \\(i\\) la cea a bornei \\((i + 1)\\).  </p> <p>Astfel, tot \u00eentr-un tablou unidimensional de frecven\u021b\u0103 (ce con\u021bine \\(P\\) elemente), se va contoriza de c\u00e2te ori s-a trecut peste fiecare por\u021biune taxabil\u0103.</p> <pre><code>for (int i = 1; i &lt; N; ++i) {       /// iteram prin lista coordonatelor de borne\n    int p1 = min(x[i], x[i + 1]);   /// capat \"stanga\" pe axa numerelor intregi\n    int p2 = max(x[i], x[i + 1]);   /// capat \"dreapta\" pe axa numerelor intregi\n    for (int j = 1; j &lt;= P; ++j) {  /// iteram prin lista de coordonate taxabile\n        if (p1 &lt; st[j] &amp;&amp; st[j] &lt; p2) {\n            ++fr2[j];\n        }\n    }\n}\n</code></pre> <p>\u00cen mod similar cu solu\u021biile descrise anterior, pentru cerin\u021ba \\(C = 1\\), se determin\u0103 care este indicele minim \\(i\\) \\((1 \\leq i \\leq P)\\) pentru care valoarea \\(\\text{fr2}[i]\\) este maxim\u0103. Pentru cerin\u021ba \\(C = 2\\), se calculeaz\u0103 suma: \\(\\sum_{i=1}^P c_i \\cdot \\text{fr2}[i]\\). Complexitatea total\u0103 este: \\(\\mathcal{O}(P \\cdot N)\\).  </p> <p>Subtask 5: Remarc\u0103m c\u0103 cele \\(P\\) por\u021biuni de \u0219osea sunt incluse complet \u00een por\u021biunea reprezentat\u0103 de segmentul \\([-300000, 300000]\\) de pe \u0219osea. Astfel, o observa\u021bie este c\u0103, dac\u0103 ma\u0219ina hibrid trebuie s\u0103 parcurg\u0103 un segment \\([l, r]\\) \\((l \\leq r)\\) de pe \u0219osea, se poate modifica acest interval astfel \u00eenc\u00e2t s\u0103 reprezinte intersec\u021bia: \\([l, r] \\cap [-300000, 300000];\\) \u00een cazul \u00een care intersec\u021bia este vid\u0103, se poate ignora segmentul \\([l, r]\\) de pe traseu, din moment ce parcurgerea acestuia nu va influen\u021ba niciuna dintre cele \\(P\\) por\u021biuni taxabile.</p> <p>De aceast\u0103 dat\u0103, este nevoie ca marcarea unui interval \\([l, r]\\) s\u0103 fie efectuat\u0103 \u00een timp constant, \\(\\mathcal{O}(1)\\). Astfel, poate fi folosit\u0103, de exemplu, metoda Vectorului de Diferen\u021be (Difference Array \u00een Englez\u0103); \u00een Rom\u00e2nia, aceast\u0103 tehnic\u0103 mai este cunoscut\u0103 sub numele de \u0218menul lui Mars.  </p> <p>\u00centruc\u00e2t \\(l\\) sau \\(r\\) pot avea valori negative, se va alege din nou o transla\u021bie spre dreapta cu 300000 de pozi\u021bii. \u00cen momentul actualiz\u0103rii intervalului, valoarea de pe pozi\u021bia \\((l + 300000)\\) \u00een tabloul unidimensional folosit pentru \u0218menul lui Mars va cre\u0219te cu o unitate, iar cea de pe pozi\u021bia \\((r + 300000 + 1)\\) va sc\u0103dea cu o unitate.  </p> <p>Complexitatea total\u0103 a acestei solu\u021bii este \\(\\mathcal{O}(P + N + \\text{maxd})\\), unde \\(\\text{maxd}\\) reprezint\u0103 diferen\u021ba maxim\u0103 dintre dou\u0103 coordonate vizitate \u00een timpul efectu\u0103rii traseului (consider\u00e2nd intersec\u021biile cu segmentul \\([-300000, 300000]\\)): \\(\\text{maxd} \\leq 600000\\).</p> <p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n\nconst int NMAX = 300001;\nint t[600005], m[600005], s2[600005], s1[600005], v[200005];\nlong long cost[200005], maxx[200005];\nint main() {\n    ifstream cin(\"hibrid.in\");\n    ofstream cout(\"hibrid.out\");\n\n    int cer, k, n;\n    cin &gt;&gt; cer &gt;&gt; k &gt;&gt; n;\n    for (int i = 1; i &lt;= k; i++) {\n        int a, b;\n        cin &gt;&gt; a &gt;&gt; b &gt;&gt; cost[i];\n        a += NMAX;\n        b += NMAX;\n        m[a] += i;\n        m[b + 1] -= i;\n    }\n    s1[0] = m[0];\n    for (int i = 1; i &lt;= NMAX * 2; i++) {\n        s1[i] = s1[i - 1] + m[i];\n    }\n    for (int i = 1; i &lt;= n; i++) {\n        cin &gt;&gt; v[i];\n        if (v[i] &lt; -NMAX) {\n            v[i] = -NMAX;\n        }\n        if (v[i] &gt; NMAX) {\n            v[i] = NMAX;\n        }\n        v[i] += NMAX;\n    }\n    for (int i = 1; i &lt; n; i++) {\n        int a = min(v[i], v[i + 1]);\n        int b = max(v[i], v[i + 1]) + 1;\n        t[a]++;\n        t[b]--;\n    }\n    s2[0] = t[0];\n    for (int i = 1; i &lt;= NMAX * 2; i++) {\n        s2[i] = s2[i - 1] + t[i];\n    }\n    int r = 0, sol = -1;\n    for (int i = 0; i &lt;= NMAX * 2; i++) {\n        if (s1[i] &gt; 0 &amp;&amp; s2[i] &gt; 0) {\n            if (s2[i] &gt; r) {\n                r = s2[i];\n                sol = s1[i];\n            } else if (s2[i] == r) {\n                sol = min(sol, s1[i]);\n            }\n        }\n    }\n    if (cer == 1) {\n        cout &lt;&lt; sol;\n    } else {\n        for (int i = 0; i &lt;= NMAX * 2; i++) {\n            if (s1[i] &gt; 0 &amp;&amp; s2[i] &gt; maxx[s1[i]]) {\n                maxx[s1[i]] = s2[i];\n            }\n        }\n        long long r2 = 0;\n        for (int i = 1; i &lt;= k; i++) {\n            r2 += maxx[i] * cost[i];\n        }\n        cout &lt;&lt; r2;\n    }\n    return 0;\n}\n</code></pre>","tags":["OJI","clasa VIII"]},{"location":"olimpiada/solutii/OJI/2023/VIII-tema/","title":"Solu\u021bia problemei tema (OJI 2023, clasa a VIII-a)","text":"<p>Pentru cerin\u021ba 1, solu\u021bie \u00een complexitate \\(\\mathcal{O}(\\text{ValMax} \\times \\log(\\text{ValMax}) + N)\\) ob\u021bine punctaj maxim, adic\u0103 50 de puncte. Folosind Ciurul lui Eratostene, \u00een complexitate \\(\\mathcal{O}(\\text{ValMax} \\times \\log(\\text{ValMax}))\\), se vor determina toate numerele prime \\(\\leq \\text{ValMax}\\), \u0219i pentru fiecare num\u0103r compus, re\u021binem cel mai mic \u0219i cel mai mare factor prim al s\u0103u.</p> <p>Algoritmul de ciur genereaz\u0103 toate numerele prime. \u00cen momentul g\u0103sirii unui num\u0103r prim \\(p\\), marc\u0103m to\u021bi multiplii lui de la \\(2 \\times p\\) p\u00e2n\u0103 la cel mult ValMax ca fiind neprimi. Pentru fiecare multiplu (notat cu \\(x\\)), \\(p\\) devine cel mai mare factor prim al lui \\(x\\) (iar dac\u0103 \\(x\\) avea deja un factor prim, \\(p\\) \u00eel suprascrie). Acest lucru este natural, deoarece \\(p\\) este cel mai mare num\u0103r prim \u00eent\u00e2lnit p\u00e2n\u0103 la acest moment. \u00cen plus, dac\u0103 la momentul curent \\(x\\) era considerat prim, atunci \\(p\\) devine \u0219i cel mai mic factor prim al acestuia.</p> <p>Determinarea secven\u021bei de lungime maxim\u0103, pentru care costul acesteia este mai mic sau egal\u0103 cu \\(K\\), se realizeaz\u0103 \u00een complexitate \\(\\mathcal{O}(N)\\), folosind doi indici. Pentru fiecare indice curent \\(i\\), considerat cap\u0103t drept al secven\u021bei curente, determin\u0103m indicele de \u00eenceput (din st\u00e2nga) al secven\u021bei pentru care produsul nu dep\u0103\u0219e\u0219te \\(K\\). Dac\u0103 produsul este mai mare, se renun\u021b\u0103 la \\(A[\\text{st}]\\), increment\u00e2nd \\(\\text{st}\\), \u0219i actualiz\u00e2nd valoarea produsului. Se va re\u021bine lungimea maxim\u0103 a secven\u021bei ce respect\u0103 cerin\u021ba.</p> <p>Odat\u0103 determinat \\(\\text{st}\\) pentru pozi\u021bia \\(i\\), dorim s\u0103 calcul\u0103m valoarea \\(\\text{st}'\\) pentru pozi\u021bia \\(i + 1\\). \u00cencorpor\u0103m \\(A[i +1]\\) \u00een costul curent. C\u00e2t timp costul dep\u0103\u0219e\u0219te, este clar c\u0103 pentru niciun \\(i\\) viitor \\(A[\\text{st}]\\) nu va mai fi parte din solu\u021bie (deoarece, cu c\u00e2t vom deplasa \\(i\\) spre dreapta, cu at\u00e2t mai mult vom dep\u0103\u0219i \u0219i costul \\(K\\)). Deci, elimin\u0103m \\(A[\\text{st}]\\), \u0219i \u00eencerc\u0103m pe r\u00e2nd valorile \\(\\text{st} + 1\\), \\(\\text{st} + 2\\), \\dots p\u00e2n\u0103 c\u0103nd revenim sub costul \\(K\\). Prima valoare acceptabil\u0103 este cap\u0103tul st\u00e2ng \\(\\text{st}'\\) corespunz\u0103tor lui \\(i + 1\\).</p> <p>Pentru o solu\u021bie care determin\u0103 \u00een \\(\\mathcal{O}(N^3)\\) secven\u021ba, a, se ob\u021bin aproximativ 20 de puncte. Pentru o solu\u021bie care determin\u0103 \u00een \\(\\mathcal{O}(N^2)\\) secven\u021ba, a, se ob\u021bin aproximativ 35 de puncte.</p> <p>Pentru cerin\u021ba 2, solu\u021bia \u00een complexitate \\(\\mathcal{O}(N)\\) ob\u021bine punctaj maxim, adic\u0103 50 de puncte.</p> <p>Consider\u00e2nd, ciurul ob\u021binut dup\u0103 transformarea elementelor compuse, vom determina, pentru fiecare pozi\u021bie \\(i\\) din \u0219ir, c\u00e2t de mult ne putem extinde spre st\u00e2nga, \u0219i spre dreapta cu o secven\u021b\u0103 care con\u021bine cel mai mic factor prim al lui \\(A[i]\\) (notat \\(fpmin[A[i]]\\)), respectiv cel mai mare factor prim al lui \\(A[i]\\) (notat \\(fpmax[A[i]]\\)), astfel:</p> <ul> <li>\\(\\text{st}[0][i]\\) - cel mai mic indice din st\u00e2nga unde reg\u0103sim \\(fpmin[A[i]]\\)   ca factor \u00een toate elementele dintre acel indice \u0219i \\(i\\);</li> <li>\\(\\text{st}[1][i]\\) - cel mai mic indice din st\u00e2nga unde reg\u0103sim \\(fpmax[A[i]]\\)   ca factor \u00een toate elementele dintre acel indice \u0219i \\(i\\);</li> <li>\\(\\text{dr}[0][i]\\) - cel mai mare indice din dreapta unde reg\u0103sim   \\(fpmin[A[i]]\\) ca factor \u00een toate elementele de la \\(i\\) p\u00e2n\u0103 la acea pozi\u021bie;</li> <li>\\(\\text{dr}[1][i]\\) - cel mai mare indice din dreapta unde reg\u0103sim   \\(fpmax[A[i]]\\) ca factor \u00een toate elementele de la \\(i\\) p\u00e2n\u0103 la acea pozi\u021bie.</li> </ul> <p>Pentru fiecare element \\(A[i]\\), lungimea maxim\u0103 a secven\u021bei care \u00eel con\u021bine, \u0219i care are cel mai mare divizor comun diferit de 1 este: \\(\\max((\\text{dr}[0][i] - \\text{st}[0][i] + 1), (\\text{dr}[1][i] - \\text{st}[1][i] + 1))\\).</p> <p>Pentru o solu\u021bie care determin\u0103 \u00een \\(\\mathcal{O}(N^3)\\) secven\u021ba, se ob\u021bin aproximativ 20 de puncte. Pentru o solu\u021bie care determin\u0103 \u00een \\(\\mathcal{O}(N^2)\\) secven\u021ba, se ob\u021bin aproximativ 35 de puncte.</p> <p>O alt\u0103 abordare \u00een \\(\\mathcal{O}(N)\\) folose\u0219te aceea\u0219i tehnica a celor doi indici de la cerin\u021ba 1. Pentru un cap\u0103t drept \\(i\\), presupunem c\u0103 am calculat cap\u0103tul st\u00e2ng \\(\\text{st}\\) care produce cea mai lung\u0103 secven\u021b\u0103 cu c.m.m.d.c. diferit de 1. Cum actualiz\u0103m secven\u021ba pentru \\(i + 1\\)? Putem men\u021bine un vector de frecven\u021b\u0103 al tuturor factorilor primi din secven\u021ba curent\u0103. C\u00e2nd ad\u0103ug\u0103m sau elimin\u0103m un element \u00een/din secven\u021b\u0103, increment\u0103m sau decrement\u0103m frecven\u021bele celor doi factori (dac\u0103 factorii unui element sunt egali, modific\u0103m frecven\u021bele doar cu 1, nu cu 2). Atunci o secven\u021b\u0103 cu c.m.m.d.c. diferit de 1 are proprietatea c\u0103 frecven\u021ba cel put\u00een a unui factor de la cap\u0103tul secven\u021bei este egal\u0103 cu lungimea secven\u021bei. C\u00e2nd avans\u0103m de la \\(i\\) la \\(i + 1\\), verific\u0103m dac\u0103 secven\u021ba, \\([\\text{st}, i + 1]\\) mai are aceea\u0219i proprietate. C\u00e2t timp nu o are, elimin\u0103m cap\u0103tul st\u00e2nga al secven\u021bei.</p> <p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n\nifstream fin(\"tema.in\");\nofstream fout(\"tema.out\");\n\nint pr[1000005], gpd[1000005], spd[1000005];\nint spr[100005], scm[100005];\nint v[100005];\nint fr[1000005];\n\nvoid Ciur() {\n    pr[0] = 2;\n    pr[1] = 2;\n    for (int i = 2; i &lt;= 1000000; ++i) {\n        pr[i] = 1;\n    }\n    for (int i = 2; i &lt;= 1000000; ++i) {\n        if (pr[i] == 0) {\n            continue;\n        }\n        for (int j = 2 * i; j &lt;= 1000000; j += i) {\n            if (pr[j] == 1) {\n                spd[j] = i;\n            }\n            pr[j] = 0;\n            gpd[j] = i;\n        }\n    }\n}\n\nint main() {\n    Ciur();\n    long long C, n, k;\n    fin &gt;&gt; C &gt;&gt; n &gt;&gt; k;\n    for (int i = 1; i &lt;= n; ++i) {\n        fin &gt;&gt; v[i];\n        spr[i] = spr[i - 1];\n        scm[i] = scm[i - 1];\n        if (pr[v[i]] == 1) {\n            spr[i] += v[i];\n        } else if (pr[v[i]] == 0) {\n            scm[i] += v[i];\n        }\n    }\n    if (C == 1) {\n        int ans = 0, st = 1;\n        for (int i = 1; i &lt;= n; ++i) {\n            while (st &lt;= i\n                   &amp;&amp; 1LL * (spr[i] - spr[st - 1]) * (scm[i] - scm[st - 1])\n                          &gt; k) {\n                st++;\n            }\n            ans = max(ans, i - st + 1);\n        }\n        fout &lt;&lt; ans;\n    } else {\n        int st = 1, dr = 1, loc = 1;\n        for (int i = 1; i &lt;= n; ++i) {\n            int G = gpd[v[i]], S = spd[v[i]];\n            if (pr[v[i]] == 1) {\n                G = v[i];\n                S = v[i];\n            }\n            if (v[i] == 1) {\n                G = 1;\n                S = 1;\n            }\n            fr[G]++;\n            if (G != S) {\n                fr[S]++;\n            }\n            while (loc &lt;= i &amp;&amp; (i - loc + 1 &gt; fr[G] &amp;&amp; i - loc + 1 &gt; fr[S])) {\n                int G1 = gpd[v[loc]], S1 = spd[v[loc]];\n                if (pr[v[loc]] == 1) {\n                    G1 = v[i];\n                    S1 = v[i];\n                }\n                if (v[loc] == 1) {\n                    G1 = 1;\n                    S1 = 1;\n                }\n                fr[G1]--;\n                if (G1 != S1) {\n                    fr[S1]--;\n                }\n                loc++;\n            }\n            if (dr - st + 1 &lt;= i - loc + 1) {\n                st = loc;\n                dr = i;\n            }\n        }\n        fout &lt;&lt; st &lt;&lt; ' ' &lt;&lt; dr;\n    }\n    return 0;\n}\n</code></pre>","tags":["OJI","clasa VIII"]},{"location":"olimpiada/solutii/OJI/2023/X-arhitect/","title":"Solu\u021bia problemei arhitect (OJI 2023, clasa a X-a)","text":"<p>Segmentele sunt paralele cu axele sau bisectoarele. Atunci segmentele au pantele cu unghiuri de 0\u00b0, 45\u00b0, 90\u00b0 sau 135\u00b0 \u0219i se pot num\u0103ra segmentele care sunt aliniate de la \u00eenceput, adic\u0103 verticale deci \\(x_1 = x_2\\) sau orizontale deci \\(y_1 = y_2\\), fie num\u0103rul acestora \\(a\\). </p> <p>Toate celelalte segmente se pot alinia printr-o rota\u021bie cu 45\u00b0. Deci r\u0103spunsul va fi \\(max(a, N - a)\\): fie nu rotim segmentele, fie le rotim cu 45\u00b0.</p>","tags":["OJI","clasa X"]},{"location":"olimpiada/solutii/OJI/2023/X-arhitect/#solutie-on2-aproximativ-50-puncte","title":"Solu\u021bie \\(O(N^2)\\) aproximativ \\(50\\) puncte","text":"<p>Fix\u0103m orice segment \\(1 \\leq i \\leq N\\) pentru a fi aliniat. Prin rotirea tuturor segmentelor cu unghiul necesar alinierii lui \\(i\\), se vor alinia \u0219i alte segmente: cele care sunt paralele \u0219i cele care sunt perpendiculare pe \\(i\\).</p> <p>Putem evita implementarea efectiv\u0103 a rota\u021biilor dac\u0103 doar num\u0103r\u0103m aceste segmente printr-o alt\u0103 parcurgere. Pentru a testa dac\u0103 dou\u0103 segmente sunt paralele, putem translata un segment astfel \u00eenc\u00e2t segmentele s\u0103 aib\u0103 un cap\u0103t comun. Segmentele sunt paralele dac\u0103 triunghiul format are aria zero. Segmentele sunt perpendiculare dac\u0103 \u00een triunghiul format se verific\u0103 teorema lui Pitagora.</p>","tags":["OJI","clasa X"]},{"location":"olimpiada/solutii/OJI/2023/X-arhitect/#solutie-on-log-n-punctaj-maxim","title":"Solu\u021bie O(N log N) punctaj maxim","text":"<p>Putem reprezenta fiecare segment printr-un singur punct dac\u0103 translat\u0103m toate segmentele astfel ca un cap\u0103t al lor s\u0103 fie \\((0, 0)\\). Mai departe, pentru simplitate, mut\u0103m orice segment cu valoarea y negativ\u0103 \u00een simetricul lui fa\u021b\u0103 de \\((0, 0)\\), adic\u0103 \\((x, y &lt; 0)\\) devine \\((\u2212x, \u2212y)\\), iar panta este aceea\u0219i. </p> <p>Acum, pentru a trata cazul segmentelor perpendiculare, orice segment cu \\(x &lt; 0\\) poate fi rotit cu 45\u00b0 \u0219i astfel vom avea toate segmentele reprezentate de puncte cu ambele coordonate pozitive. Rota\u021bia cu 45\u00b0 se poate aplica transform\u00e2nd punctul \\((x &lt; 0, y)\\) \u00een punctul \\((y, \u2212x)\\). </p> <p>\u00cen sf\u00e2r\u0219it, acum este suficient s\u0103 calcul\u0103m num\u0103rul maxim de segmente ce au aceea\u0219i pant\u0103. Coordonatele fiind naturale, putem reprezenta pantele prin perechi de coordonate simplificate: \\((x, y)\\) devine \\((x / cmmdc(x, y), y / cmmdc(x, y))\\). Acum trebuie s\u0103 determin\u0103m num\u0103rul maxim de segmente egale. Pentru aceasta, putem sorta segmentele dup\u0103 pant\u0103 sau coordonate.</p> <p>Apoi, printr-o singur\u0103 parcurgere, g\u0103sim num\u0103rul maxim de segmente de pe pozi\u021bii consecutive egale sau, alternativ, segmentele pot fi num\u0103rate printr-un tablou asociativ, adic\u0103 un map&lt;&gt;. \u00cen func\u021bie de opera\u021biile care se folosesc pentru calcule, trebuie folosit tipul long long evit\u00e2nd dep\u0103\u0219irile.</p>","tags":["OJI","clasa X"]},{"location":"olimpiada/solutii/OJI/2023/X-arhitect/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;fstream&gt;\n#include &lt;map&gt;\n\nusing namespace std;\n\nifstream fin(\"arhitect.in\");\nofstream fout(\"arhitect.out\");\n\nmap&lt;pair&lt;int, int&gt;, int&gt; M;\n\nint cmmdc(int a, int b) {\n    while (b != 0) {\n        int r = a % b;\n        a = b;\n        b = r;\n    }\n    return a;\n}\n\nint main() {\n    int n, fmax = 0;\n    fin &gt;&gt; n;\n    for (int i = 1; i &lt;= n; i++) {\n        int x1, y1, x2, y2;\n        fin &gt;&gt; x1 &gt;&gt; y1 &gt;&gt; x2 &gt;&gt; y2;\n        if (x1 &gt; x2) \n            swap(x1, x2), swap(y1, y2);\n        int x = x2 - x1, y = y2 - y1;\n        if (y &lt; 0)\n            swap(x, y), x = -x;\n        else if (x == 0)\n            swap(x, y);\n        if (x == 0)\n            y = 1;\n        else {\n            int d = cmmdc(x, y);\n            x /= d, y /= d;\n        }\n        M[{y, x}]++;\n    }\n    for (auto x : M)\n        if (x.second &gt; fmax) \n            fmax = x.second;\n    fout &lt;&lt; fmax;\n    return 0;\n}\n</code></pre>","tags":["OJI","clasa X"]},{"location":"olimpiada/solutii/OJI/2023/X-bingo/","title":"Solu\u021bia problemei bingo (OJI 2023, clasa a X-a)","text":"<p>Problema ne cere s\u0103 afl\u0103m num\u0103rul minim de interschimb\u0103ri de elemente adiacente ce trebuie efectuate pentru a ob\u021bine o subsecven\u021b\u0103 egal\u0103 cu bingo \u00eentr-un \u0219ir dat.</p>","tags":["OJI","clasa X"]},{"location":"olimpiada/solutii/OJI/2023/X-bingo/#subtask-1","title":"Subtask 1","text":"<p>\u00cen acest subtask, fiecare \u0219ir primit are \\(5\\) caractere, dar cum se garanteaz\u0103 faptul c\u0103 fiecare element din mul\u021bimea \\(\\{ b, i, n, g, o \\}\\) apare cel pu\u021bin o dat\u0103, rezult\u0103 c\u0103 toate \u0219irurile date sunt, de fapt, anagrame ale \u0219irului \u021bint\u0103 bingo, deci trebuie doar s\u0103 rearanj\u0103m literele date. Consider\u00e2nd \u0219irul bingo permutarea identic\u0103 de lungime 5, iar \u0219irul S permutarea asociat\u0103 lui \\((b \\rightarrow 1, i \\rightarrow 2, \\dots)\\), rezultatul este num\u0103rul de inversiuni din aceast\u0103 permutare.</p> <p>Exemplu: \\(biong \\rightarrow (1, 2, 3, 4, 5) \\rightarrow 2\\) inversiuni \\(\\rightarrow 2\\) interschimb\u0103ri necesare.</p>","tags":["OJI","clasa X"]},{"location":"olimpiada/solutii/OJI/2023/X-bingo/#subtask-2","title":"Subtask 2","text":"<p>\u0218irurile con\u021bin tot o singur\u0103 anagram\u0103 a \u0219irului \\(bingo\\), dar de data aceasta pozi\u021biile caracterelor ce o formeaz\u0103 nu mai sunt consecutive. Am rezolvat mai sus cazul \u00een care pozi\u021biile sunt consecutive, deci ar fi folositor s\u0103 reducem \u0219i acest caz la problema anterioar\u0103. Pentru orice \u0219ir, exist\u0103 cel pu\u021bin o solu\u021bie optim\u0103 \u00een care, mai \u00eent\u00e2i, caracterele ce duc la solu\u021bia optim\u0103 sunt aduse pe pozi\u021bii consecutive (f\u0103r\u0103 a se schimba ordinea relativ\u0103 a lor), dup\u0103 care se rezolv\u0103 anagrama ob\u021binut\u0103 ca la subtask-ul \\(1\\). </p> <p>De asemenea, se poate demonstra c\u0103 este optim s\u0103 aducem caracterele l\u00e2ng\u0103 cel din mijloc, iar pe acesta s\u0103 nu \u00eel mut\u0103m. Consider\u00e2nd c\u0103 pozi\u021biile celor \\(5\\) caractere formeaz\u0103 un vector (sortat strict cresc\u0103tor), interschimb\u0103rile dintre elemente pot fi simulate cu ad\u0103ugarea sau sc\u0103derea unui \\(1\\) la un element din \u0219ir at\u00e2ta timp c\u00e2t NU se interschimb\u0103 \u00eentre ele dou\u0103 caractere dintre cele \\(5\\) selectate. Ne-am dori ca vectorul s\u0103 fie format din numere consecutive, \u00eens\u0103 este mai u\u0219or s\u0103 vedem cum facem vectorul s\u0103 fie format doar din elemente egale.</p> <p>A\u0219adar, ad\u0103ug\u0103m un \\(2\\) la primul element, un \\(1\\) la al doilea, sc\u0103dem un \\(1\\) din penultimul \u0219i sc\u0103dem un \\(2\\) din ultimul. Astfel, \u021binem cont de faptul c\u0103 nu trebuie s\u0103 aducem toate elementele pe pozi\u021bia din mijloc (ci fiecare pe pozi\u021biile adiacente corespunz\u0103toare), iar \u0219irul r\u0103m\u00e2ne sortat cresc\u0103tor.</p> <p>Acum, num\u0103rul minim de interschimb\u0103ri necesare pentru a aduce cele \\(5\\) caractere pe pozi\u021bii consecutive este egal cu num\u0103rul minim de increment\u0103ri/ decrement\u0103ri necesare pentru a face toate elementele egale. \u0218tim c\u0103 este optim s\u0103 le facem egale cu valoarea median\u0103, iar \u0219irul nostru fiind sortat, aceasta este cea din mijloc.</p> <p>Exemplu: \\(hhnhbingog \\rightarrow \\{3, 5, 6, 8, 9 \\} \\rightarrow \\{5, 6, 6, 7, 7 \\} \\rightarrow 3\\) increment\u0103ri/decrement\u0103ri necesare pentru a aduce toate elementele la aceea\u0219i valoare \\((6) \\rightarrow 3\\) interschimb\u0103ri necesare pentru a ajunge la \\(hhhnbiogh \\rightarrow\\) continu\u0103m cu rezolvarea anagramei ca la subtask-ul 1.</p>","tags":["OJI","clasa X"]},{"location":"olimpiada/solutii/OJI/2023/X-bingo/#subtask-3","title":"Subtask 3","text":"<p>\u00centruc\u00e2t singurele caractere ce ne intereseaz\u0103, de fapt, sunt cele din mul\u021bimea \\(\\{b, i, n, g, o\\}\\), acest subtask ne permite s\u0103 verific\u0103m pentru fiecare variant\u0103 de a alege caracterele cu care s\u0103 form\u0103m subsecven\u021ba bingo, c\u00e2te interschimb\u0103ri sunt necesare. Pentru un \\(5\\)-tuplu (format din pozi\u021biile celor \\(5\\) caractere) fixat, aplic\u0103m ra\u021bionamentul de la subtask-ul \\(2\\). Complexitatea unei astfel de abord\u0103ri este de ordinul \\(O(N^5)\\), unde \\(N\\) este lungimea \u0219irului de caractere.</p> <p>Exemplu: \\(xboting \\rightarrow \\{2, 3, 4, 6, 7\\} \\rightarrow subtask \\ 2 \\rightarrow \\{2, 3, 5, 6, 7\\} \\rightarrow subtask \\ 2\\).</p>","tags":["OJI","clasa X"]},{"location":"olimpiada/solutii/OJI/2023/X-bingo/#solutia-completa","title":"Solu\u021bia complet\u0103","text":"<p>Pentru fiecare permutare (dintre cele \\(120 = 5!\\)) a lui \\(bingo\\), \u00eencerc\u0103m s\u0103 aplic\u0103m ra\u021bionamentul de la subtask-ul \\(3\\) \u00eentr-un mod mai eficient.</p> <p>Pentru o permutare fixat\u0103, ne intereseaz\u0103 doar \\(5\\)-tuplurile care p\u0103streaz\u0103 ordinea relativ\u0103 a caracterelor dat\u0103 de permutare. Dintre acestea, majoritatea nu pot duce la solu\u021bia optim\u0103, fiind dep\u0103\u0219ite de \\(5\\)-tuplurile ale c\u0103ror termeni au pozi\u021biile mai apropiate \u00eentre ele.</p> <p>Pentru o permutare fixat\u0103, este de ajuns s\u0103 consider\u0103m doar apari\u021biile caracterului din mijloc (pozi\u021bia \\(2\\), index\u00e2nd de la \\(0\\)) \u0219i s\u0103 calcul\u0103m pozi\u021biile primului caracter valid din st\u00e2nga (cel cu indicele \\(1\\) din permutare), respectiv primul valid din dreapta (indicele \\(3\\)). Folosim acela\u0219i ra\u021bionament pentru caracterele cu indicii \\(0\\) \u0219i \\(4\\).</p> <p>Observa\u021bie: Consider\u0103m apari\u021biile caracterului din mijloc, deoarece ulterior l\u00e2ng\u0103 acela trebuie aduse \u0219i celelalte, deci de la \u00eenceput \u0219i celelalte trebuie alese c\u00e2t mai aproape de acesta.</p> <p>Exemplu: Dac\u0103 anagrama fixat\u0103 este \\(nibog\\), pentru fiecare apari\u021bie a lui b din \u0219ir, c\u0103ut\u0103m primul \\(i\\) din st\u00e2nga lui \\(b\\), respectiv primul \\(o\\) din dreapta. Analog, c\u0103ut\u0103m primul \\(g\\) din dreapta lui \\(o\\) \u0219i primul \\(n\\) din st\u00e2nga lui \\(i\\). Pentru indicii g\u0103si\u021bi, aplic\u0103m rezolvarea de la subtask-ul \\(2\\). Putem precalcula aceste pozi\u021bii succesor/predecesor ale caracterelor \\(b, i, n, g, o\\) pentru fiecare pozi\u021bie din \u0219ir sau le putem c\u0103uta binar la fiecare pas. Pentru g\u0103sirea rezultatului pentru un \u0219ir de lungime \\(N\\), complexitatea este \\(O(N \\cdot \\log N)\\) sau \\(O(N)\\). Trebuie men\u021bionat c\u0103 avem un factor constant aproximativ egal cu \\(120-130\\).</p>","tags":["OJI","clasa X"]},{"location":"olimpiada/solutii/OJI/2023/X-bingo/#solutie-alternativa-vlad-mihai-bogdan-universitatea-din-bucuresti","title":"Solu\u021bie alternativ\u0103 (Vlad-Mihai Bogdan, Universitatea din Bucure\u0219ti)","text":"<p>Pentru fiecare pozi\u021bie \\(i\\), vom \u00eencerca s\u0103 form\u0103m \u0219irul bingo pe pozi\u021biile \\(i, i + 1, \\dots, i + 4\\). Pentru fiecare liter\u0103 \\(l\\), care ar urma s\u0103 fie pe pozi\u021bia i + k \u00een \u0219irul cu subsecven\u021ba bingo pe pozi\u021biile \\(i, i + 1, \\dots, i + 4\\), avem cel mult trei op\u021biuni:</p> <ul> <li>S\u0103 lu\u0103m litera \\(l\\) din st\u00e2nga pozi\u021biei \\(i + k\\), dac\u0103 este posibil;</li> <li>S\u0103 lu\u0103m litera \\(l\\) din dreapta pozi\u021biei \\(i + k\\), dac\u0103 este posibil;</li> <li>S\u0103 lu\u0103m litera \\(l\\) chiar de pe pozi\u021bia \\(i + k\\), dac\u0103 este posibil.</li> </ul> <p>Astfel, pentru fiecare pozi\u021bie \\(i\\), avem cel mult \\(3^5\\) configura\u021bii posibile de alegeri pentru cele \\(5\\) litere. Vom calcula num\u0103rul de swap-uri necesare pentru a aduce literele pe pozi\u021biile \\(i, i + 1, \\dots, i + 4\\) \u00een ordinea pozi\u021biilor lor din \u0219irul ini\u021bial (spre exemplu, dac\u0103 decidem s\u0103 lu\u0103m litera n de pe o pozi\u021bie de dinaintea pozi\u021biei literei i, ordinea \u00een care vom aduce literele este \\(n\\), iar mai apoi \\(i\\)). La final, trebuie s\u0103 ad\u0103ug\u0103m la r\u0103spuns num\u0103rul de swap-uri necesare pentru a transforma anagrama rezultat\u0103 \u00een \u0219irul bingo. Dup\u0103 precalcularea num\u0103rului de swap-uri necesare pentru fiecare anagram\u0103 a cuv\u00e2ntului bingo, complexitatea devine \\(O(N)\\), dar cu o constant\u0103 aproximativ egal\u0103 cu \\(243\\).</p>","tags":["OJI","clasa X"]},{"location":"olimpiada/solutii/OJI/2023/X-bingo/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si solu\u021bia autorului care ia punctajul maxim.</p> <pre><code>// Popa Sebastian, Universitatea din Bucuresti\n#include &lt;bits/stdc++.h&gt;\nusing namespace std;\nifstream f(\"bingo.in\");\nofstream g(\"bingo.out\");\nconst string bingo = \"bingo\";\nvoid get_pre();\nint solve(const string &amp;);\nint solve2(const string &amp;, const string &amp;);\nint solve3(const vector&lt;int&gt;);\nint letind[130];\nvector&lt;int&gt; indpre[5], indsuf[5], pre;\nvector&lt;string&gt; allp;\nint main() {\n    get_pre();\n    string s;\n    int t;\n    for (f &gt;&gt; t; t; t--) f &gt;&gt; s, g &lt;&lt; solve(s) &lt;&lt; '\\n';\n    return 0;\n}\nint solve(const string &amp;s) {\n    // precalculam pt fiecare pozitie prima aparitie din stanga si prima\n    // din dreapta a caracterelor {b,i,n,g,o}\n    for (int i = 0; i &lt; 5; i++)\n        indpre[i].assign(s.size(), -1), indsuf[i].assign(s.size(), -1);\n    for (int i = 0; i &lt; (int)s.size(); i++)\n        for (int j = 0; j &lt; 5; j++)\n            if (s[i] == bingo[j])\n                indpre[j][i] = i;\n            else if (i)\n                indpre[j][i] = indpre[j][i - 1];\n    // indpre[j][i] = primul caracter egal cu bingo[j] din stanga lui i\n    // (inclusiv)\n    for (int i = s.size() - 1; i &gt;= 0; i--)\n        for (int j = 0; j &lt; 5; j++)\n            if (s[i] == bingo[j])\n                indsuf[j][i] = i;\n            else if (i != s.size() - 1)\n                indsuf[j][i] = indsuf[j][i + 1];\n    // indsuf[j][i] = priul caracter egal cu bingo[j] din dreapta lui i\n    // (inclusiv)\n\n    static int minim;\n    minim = (1 &lt;&lt; 28);\n    // pentru fiecare anagrama vedem cum o putem obtine optim drept substring\n    // dupa care adaugam costul de transformare a ei in bingo\n    for (int i = 0; i &lt; 120; i++)\n        minim = min(minim, solve2(s, allp[i]) + pre[i]);\n    return minim;\n}\nint solve2(const string &amp;s,\n           const string &amp;p)  // pentru fiecare caracter egal cu cel din mijloc\n// gasim cele mai apropiate pozitii pentru celelalte caractere\n{\n    static int minim;\n    minim = (1 &lt;&lt; 28);\n    for (int i = 0, p0, p1, p2, p3, p4; i &lt; (int)s.size(); i++)\n        if (s[i] == p[2]) {\n            p2 = i;\n            p1 = indpre[letind[p[1]]][p2];\n            if (p1 == -1) continue;\n            p0 = indpre[letind[p[0]]][p1];\n            if (p0 == -1) continue;\n            p3 = indsuf[letind[p[3]]][p2];\n            if (p3 == -1) continue;\n            p4 = indsuf[letind[p[4]]][p3];\n            if (p4 == -1) continue;\n            minim = min(minim, solve3({p0, p1, p2, p3, p4}));\n        }\n    return minim;\n}\nint solve3(const vector&lt;int&gt; v)  // cate mutari trebuie facute sa aducem\n                                 // caracterele langa cel din mijloc\n{\n    static int s;\n    s = 0;\n    for (int j = 0; j &lt; 5; j++)\n        if (j &lt; 2)\n            s += v[2] - v[j] + j - 2;\n        else\n            s += v[j] - v[2] + 2 - j;\n    return s;\n}\nvoid get_pre()  // precalculam toate anagramele sirului bingo (allp[]) si cate\n                // inversiuni are fiecare   (pre[])\n{\n    string s;\n    int cnt, i0, i1, i2, i3, i4;\n    for (int i = 0; i &lt; 5; i++) letind[bingo[i]] = i;\n    for (i0 = 0; i0 &lt; 5; i0++)  // instead of next_permutation()\n        for (i1 = 0; i1 &lt; 5; i1++)\n            if (i1 != i0)\n                for (i2 = 0; i2 &lt; 5; i2++)\n                    if (i2 != i0 &amp;&amp; i2 != i1)\n                        for (i3 = 0; i3 &lt; 5; i3++)\n                            if (i3 != i0 &amp;&amp; i3 != i1 &amp;&amp; i3 != i2) {\n                                i4 = 10 - i0 - i1 - i2 - i3;\n                                s = \"\", cnt = 0;\n                                s += bingo[i0], s += bingo[i1], s += bingo[i2];\n                                s += bingo[i3], s += bingo[i4];\n                                for (int i = 0; i &lt; 4; i++)\n                                    for (int j = i + 1; j &lt; 5; j++)\n                                        if (letind[s[i]] &gt; letind[s[j]]) cnt++;\n                                allp.push_back(s), pre.push_back(cnt);\n                            }\n}\n</code></pre>","tags":["OJI","clasa X"]},{"location":"olimpiada/solutii/OJI/2023/X-fotbal/","title":"Solu\u021bia problemei fotbal (OJI 2023, clasa a X-a)","text":"<p>Problema ne cere num\u0103rul de moduri \u00een care putem alege \\(K\\) intervale, a c\u0103ror intersec\u021bie nu este mul\u021bimea vid\u0103 \u0219i printre care se reg\u0103se\u0219te cel pu\u021bin un interval colorat \u00een negru (\\(f_i = 1\\)) \u0219i cel pu\u021bin un interval colorat \u00een alb (\\(f_i = 0\\)), dintr-o mul\u021bime de \\(N\\) intervale date.</p>","tags":["OJI","clasa X"]},{"location":"olimpiada/solutii/OJI/2023/X-fotbal/#subtask-1","title":"Subtask 1","text":"<p>\u00cen acest subtask, este suficient s\u0103 verific\u0103m fiecare pereche de intervale. Intervalele trebuie s\u0103 aib\u0103 culori diferite \u0219i intersec\u021bia nevid\u0103. Complexitatea unei astfel de solu\u021bii brute-force este \\(O(N^2)\\).</p>","tags":["OJI","clasa X"]},{"location":"olimpiada/solutii/OJI/2023/X-fotbal/#subtask-2","title":"Subtask 2","text":"<p>Vom avea o abordare asem\u0103n\u0103toare cu cea de la subtask-ul anterior. Observa\u021bia cheie este c\u0103 trebuie s\u0103 fix\u0103m un interval cu \\(f_i = 0\\), iar mai apoi putem trece prin restul de \\(N\\) intervale \u0219i s\u0103 verific\u0103m condi\u021biile de mai sus. O astfel de solu\u021bie are complexitate \\(O(N \\cdot cnt_0)\\), unde \\(cnt_0\\) este num\u0103rul de intervale cu \\(f_i = 0\\).</p>","tags":["OJI","clasa X"]},{"location":"olimpiada/solutii/OJI/2023/X-fotbal/#subtask-3","title":"Subtask 3","text":"<p>Pentru ca intersec\u021bia a \\(K\\) intervale s\u0103 fie nevid\u0103, trebuie s\u0103 se respecte urm\u0103toarea proprietate: \\(max(left_i) \\leq min(right_i)\\) cu \\(i\\) de la \\(1\\) la \\(K\\), unde \\(left_i\\) reprezint\u0103 cap\u0103tul din st\u00e2nga al intervalului \\(i\\) (dintre cele \\(K\\) alese), iar \\(right_i\\) cap\u0103tul din dreapta al intervalului \\(i\\) (dintre cele \\(K\\) alese). Prin urmare, vom sorta cresc\u0103tor intervalele \u00een func\u021bie de cap\u0103tul din st\u00e2nga. Vom parcurge intervalele \u00een noua ordine \u0219i vom men\u021bine dou\u0103 variabile, \\(cnt_0\\) \u0219i \\(cnt_1\\), reprezent\u00e2nd num\u0103rul de intervale active de culoare alb\u0103, respectiv num\u0103rul de intervale active de culoare neagr\u0103. C\u00e2nd vrem s\u0103 trecem de la intervalul \\(i - 1\\) la intervalul \\(i\\), trebuie s\u0103 actualiz\u0103m \\(cnt_0\\) \u0219i \\(cnt_1\\), elimin\u00e2nd toate intervalele pentru care \\(right_i &lt; left_i\\). Pentru a nu num\u0103ra intervale de mai multe ori, vom calcula pentru fiecare interval \\(i\\), num\u0103rul de moduri \u00een care putem alege \\(K\\) intervale care s\u0103 respecte condi\u021biile de mai sus, fix\u00e2nd cel mai din dreapta dintre intervale c\u0103 fiind intervalul cu num\u0103rul \\(i\\). Cu variabilele \\(cnt_0\\) \u0219i \\(cnt_1\\) actualizate, singura condi\u021bie de care trebuie s\u0103 \u021binem cont este condi\u021bia c\u0103 trebuie s\u0103 avem cel pu\u021bin un interval din fiecare culoare. Pentru a \u021bine cont de aceast\u0103 condi\u021bie, vom calcula mai \u00eent\u00e2i num\u0103rul de moduri prin care putem alege restul de \\(K - 1\\) intervale, iar mai apoi vom sc\u0103dea num\u0103rul de moduri \u00een care putem alege \\(K - 1\\) intervale de aceea\u0219i culoare cu intervalul \\(i\\). Acest num\u0103r este dat de formula:</p> \\[ \\binom{cnt0 + cnt1}{K - 1} - \\binom{cnt_i}{K - 1} \\] <p>unde \\(cnt_i\\) este num\u0103rul de intervale de aceea\u0219i culoare cu intervalul \\(i\\). Pentru a calcula combin\u0103rile \\(\\binom{N}{K}\\), ne vom folosi de triunghiul lui Pascal \u0219i de formula recurent\u0103:</p> \\[ \\binom{N}{K} = \\binom{N - 1}{K - 1} + \\binom{N - 1}{K} \\] <p>Complexitatea unei astfel de solu\u021bii este \\(O(N^2)\\).</p>","tags":["OJI","clasa X"]},{"location":"olimpiada/solutii/OJI/2023/X-fotbal/#solutia-completa","title":"Solu\u021bia complet\u0103","text":"<p>Este solu\u021bia anterioar\u0103, pentru calcul combin\u0103rilor se va folosi inversul modular \u0219i algoritmul lui Euclid extins. Aceast\u0103 solu\u021bie are complexitate \\(O(N \\cdot \\log N)\\).</p>","tags":["OJI","clasa X"]},{"location":"olimpiada/solutii/OJI/2023/X-fotbal/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["OJI","clasa X"]},{"location":"olimpiada/solutii/OJI/2023/XI-XII-parcare/","title":"Solu\u021bia problemei Parcare (OJI 2023, clasele XI-XII)","text":"","tags":["OJI","clasa XI-XII"]},{"location":"olimpiada/solutii/OJI/2023/XI-XII-parcare/#subtask-1-24-puncte","title":"Subtask 1 (24 puncte)","text":"<p>Deoarece fiecare ma\u0219in\u0103 st\u0103 exact o secund\u0103, iar timpii de sosire \u0219i plecare sunt distinc\u021bi, deducem c\u0103 fiecare ma\u0219in\u0103 va fi singur\u0103 \u00een parcare, deci se poate afi\u0219a locul \\(1\\). Dac\u0103 ultima ma\u0219in\u0103 are timpul de plecare cel mult egal cu \\(T\\), atunci se va afi\u0219a timpul s\u0103u de sosire urmat de \\(N - 1\\) de valori \\(-1\\), altfel se vor afi\u0219a \\(N\\) de \\(-1\\).</p> <p>Complexitate: \\(O(N + M)\\).</p>","tags":["OJI","clasa XI-XII"]},{"location":"olimpiada/solutii/OJI/2023/XI-XII-parcare/#subtask-2-26-puncte","title":"Subtask 2 (26 puncte)","text":"<p>Se va atribui c\u00e2te un loc de parcare fiec\u0103rei ma\u0219ini \u00een ordinea sosirii \u0219i se va afi\u0219a locul respectiv. Dup\u0103 sosirea tuturor ma\u0219inilor, se vor elibera locurile de parcare ale ma\u0219inilor al c\u0103ror timp de plecare este cel mult \\(T\\) \u0219i se va afi\u0219a configura\u021bia parc\u0103rii.</p> <p>Complexitate: \\(O(N + M)\\).</p>","tags":["OJI","clasa XI-XII"]},{"location":"olimpiada/solutii/OJI/2023/XI-XII-parcare/#subtask-3-26-puncte","title":"Subtask 3 (26 puncte)","text":"<p>Se va procesa fiecare ma\u0219in\u0103 \u00een ordinea sosirii. Mai \u00eent\u00e2i se vor elibera locurile de parcare ale ma\u0219inilor care au timpul de plecare cel mult egal cu timpul actual. Apoi se va c\u0103uta secven\u021bial un loc de parcare pentru ma\u0219ina tocmai sosit\u0103. La final, se vor elibera locurile de parcare ale ma\u0219inilor cu timpul de plecare mai mic sau egal cu \\(T\\) \u0219i se va afi\u0219a configura\u021bia parc\u0103rii.</p> <p>Complexitate: \\(O(N \\cdot M)\\).</p>","tags":["OJI","clasa XI-XII"]},{"location":"olimpiada/solutii/OJI/2023/XI-XII-parcare/#subtask-4-24-puncte","title":"Subtask 4 (24 puncte)","text":"<p>Pentru a \u0219ti \u00een fiecare moment dac\u0103 exist\u0103 locuri libere \u00een parcare, se va folosi o structur\u0103 de heap (set) \u00een care se vor re\u021bine perechi de forma \\((t, j)\\), unde \\(t\\) reprezint\u0103 secunda la care locul \\(j\\) va fi liber. Ini\u021bial, \u00een heap, toate perechile vor fi de forma \\((0, j)\\) pentru orice \\(j\\) de la \\(1\\) la \\(N\\). Pentru fiecare ma\u0219in\u0103 sosit\u0103 la secunda \\(s_i\\) cu plecare la \\(p_i\\), dac\u0103 perechea din heap \\((t, j)\\), cu \\(t\\) minim, verific\u0103 condi\u021bia \\(t &lt; s_i\\), atunci se elimin\u0103 din heap aceast\u0103 pereche, se afi\u0219eaz\u0103 locul j disponibil pentru ma\u0219in\u0103 \u0219i se adaug\u0103 \u00een heap perechea \\((p_i, j)\\). \u00cen caz contrar, se va afi\u0219a \\(-1\\) deoarece nu exist\u0103 loc de parcare pentru ma\u0219ina curent\u0103. La final, se elibereaz\u0103 locurile de parcare pentru ma\u0219inile care au timpul de plecare cel mult \\(T\\) \u0219i se afi\u0219eaz\u0103 configura\u021bia parc\u0103rii.</p> <p>Complexitate: \\(O(M \\cdot \\log N)\\)</p>","tags":["OJI","clasa XI-XII"]},{"location":"olimpiada/solutii/OJI/2023/XI-XII-parcare/#solutie-alternativa","title":"Solu\u021bie alternativ\u0103","text":"<p>Deoarece la fiecare moment de timp se \u00eent\u00e2mpl\u0103 maxim un eveniment (venirea/plecarea unei ma\u0219ini), putem re\u021bine pentru fiecare secund\u0103 informa\u021biile ce descriu acest eveniment. Astfel, pentru fiecare secund\u0103 re\u021binem una sau dou\u0103 valori: \\(0\\) - niciun eveniment, \\(1\\) - venirea unei ma\u0219ini, \\(2 \\ x\\) - plecarea ma\u0219inii de pe locul de parcare \\(x\\). \u00cen acela\u0219i timp, vom men\u021bine locurile de parcare libere \u00eentr-o stiv\u0103/coad\u0103, pentru a putea g\u0103si \u00een timp constant un loc de parcare liber sau a vedea dac\u0103 parcarea este plin\u0103. Astfel, putem itera prin secunde de la \\(1\\) la \\(T\\) \u0219i procesa evenimentele. La venirea unei ma\u0219ini la timpul s_i care va sta p\u00e2n\u0103 la timpul \\(p_i\\), verific\u0103m dac\u0103 stiva este goal\u0103, caz \u00een care afi\u0219\u0103m \\(-1\\). \u00cen caz contrar, vom ob\u021bine un loc liber de parcare \\(x\\) (din v\u00e2rful stivei), pe care \u00eel vom elimina din stiv\u0103 \u0219i \u00eel vom aloca ma\u0219inii curente, dup\u0103 care vom actualiza configura\u021bia parc\u0103rii \u0219i informa\u021biile despre evenimentul de plecare al ma\u0219inii la timpul \\(p_i\\). La plecarea unei ma\u0219ini, vom actualiza configura\u021bia parc\u0103rii \u0219i vom insera noul loc gol de parcare \u00een v\u00e2rful stivei. Dup\u0103 procesarea evenimentelor din intervalul de timp \\([1, T]\\), afi\u0219\u0103m configura\u021bia parc\u0103rii.</p> <p>Complexitate: \\(O(N + M)\\).</p>","tags":["OJI","clasa XI-XII"]},{"location":"olimpiada/solutii/OJI/2023/XI-XII-parcare/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;fstream&gt;\n#include &lt;set&gt;\nusing namespace std;\nifstream f(\"parcare.in\");\nofstream g(\"parcare.out\");\nint n, m, t, i, h, j, s, p, timp, poz;\nint v[200005];\nset&lt;pair&lt;int, int&gt; &gt; mul;\nset&lt;pair&lt;int, int&gt; &gt;::iterator it;\n\nint main() {\n    f &gt;&gt; n &gt;&gt; m &gt;&gt; t;\n    for (i = 1; i &lt;= n; i++) {\n        mul.insert({0, i});\n        v[i] = -1;\n    }\n    for (i = 1; i &lt;= m; i++) {\n        f &gt;&gt; s &gt;&gt; p;\n        it = mul.begin();\n        timp = (*it).first;\n        poz = (*it).second;\n        if (timp &lt; s) {\n            g &lt;&lt; poz &lt;&lt; \"\\n\";\n            mul.erase(it);\n            mul.insert({p, poz});\n            v[poz] = s;\n        } \n        else\n            g &lt;&lt; \"-1\\n\";\n    }\n    while (!mul.empty()) {\n        it = mul.begin();\n        timp = (*it).first;\n        poz = (*it).second;\n        if (timp &lt;= t)\n            v[poz] = -1;\n        else\n            break;\n        mul.erase(it);\n    }\n    for (i = 1; i &lt;= n; i++) \n        g &lt;&lt; v[i] &lt;&lt; \" \";\n\n    return 0;\n}\n</code></pre>","tags":["OJI","clasa XI-XII"]},{"location":"olimpiada/solutii/OJI/2023/XI-XII-turcane/","title":"Solu\u021bia problemei Turcane (OJI 2023, clasele XI-XII)","text":"","tags":["OJI","clasa XI-XII"]},{"location":"olimpiada/solutii/OJI/2023/XI-XII-turcane/#subtask-1-26-puncte","title":"Subtask 1 (26 puncte)","text":"<p>Avem de calculat num\u0103rul minim de s\u0103rituri pentru o matrice cu o linie. Dac\u0103 \\(N - 1\\) este divizibil cu \\(P\\), rezultatul este \\((N - 1) / P\\), altfel este \\(\u2308(N - 1) / P\u2309 + 1\\), unde \\(\u2308x\u2309\\) reprezint\u0103 partea \u00eentreag\u0103 a lui \\(x\\).</p> <p>Complexitate: \\(O(1)\\).</p>","tags":["OJI","clasa XI-XII"]},{"location":"olimpiada/solutii/OJI/2023/XI-XII-turcane/#subtask-2-15-puncte","title":"Subtask 2 (15 puncte)","text":"<p>Avem de calculat num\u0103rul minim de s\u0103rituri pentru o matrice cu dou\u0103 linii. Pentru aceasta, se va determina minimul dintre num\u0103rul de s\u0103rituri ob\u021binut \u00een fiecare din urm\u0103toarele situa\u021bii:</p> <ul> <li>Se efectueaz\u0103 o s\u0103ritur\u0103 a calului, dac\u0103 este posibil, ajung\u00e2nd \u00een p\u0103tr\u0103\u021belul \\((2, 3)\\), dup\u0103 care se aplic\u0103 formula de la subtask 1;</li> <li>Se efectueaz\u0103 o s\u0103ritur\u0103 pe diagonal\u0103, dac\u0103 este posibil, pentru \\(N = 2\\);</li> <li>Se efectueaz\u0103 o s\u0103ritur\u0103 pe vertical\u0103, apoi pe orizontal\u0103, dac\u0103 este posibil, pentru \\(N = 2\\).</li> </ul> <p>Complexitate: \\(O(1)\\).</p>","tags":["OJI","clasa XI-XII"]},{"location":"olimpiada/solutii/OJI/2023/XI-XII-turcane/#subtask-3-7-puncte","title":"Subtask 3 (7 puncte)","text":"<p>Avem de calculat num\u0103rul minim de s\u0103rituri pentru o matrice cu trei linii. Pentru aceasta, se va determina minimul dintre num\u0103rul de s\u0103rituri ob\u021binut \u00een fiecare din urm\u0103toarele situa\u021bii:</p> <ul> <li>Se efectueaz\u0103 dou\u0103 s\u0103rituri ale calului, dac\u0103 este posibil, ajung\u00e2nd \u00een p\u0103tr\u0103\u021belul \\((3, 5)\\), dup\u0103 care se aplic\u0103 formula de la subtask 1;</li> <li>Se efectueaz\u0103 una sau dou\u0103 s\u0103rituri pe diagonal\u0103, dac\u0103 este posibil, pentru a ajunge pe linia a treia, apoi se aplic\u0103 formula de la subtask 1;</li> <li>Se efectueaz\u0103 una sau dou\u0103 s\u0103rituri pe vertical\u0103, dac\u0103 este posibil, pentru a ajunge pe linia a treia, apoi se aplic\u0103 formula de la subtask 1;</li> <li>Se efectueaz\u0103 o s\u0103ritur\u0103 a calului combinat\u0103 cu o s\u0103ritur\u0103 pe vertical\u0103 sau diagonal\u0103 pentru a ajunge pe linia a treia, apoi se aplic\u0103 formula de la subtask 1.</li> </ul> <p>Complexitate: \\(O(1)\\)</p>","tags":["OJI","clasa XI-XII"]},{"location":"olimpiada/solutii/OJI/2023/XI-XII-turcane/#subtask-4-7-puncte","title":"Subtask 4 (7 puncte)","text":"<p>Se folose\u0219te programarea dinamic\u0103. Vom nota cu \\(d[i][j]\\) num\u0103rul minim de s\u0103rituri necesare pentru a ajunge \u00een p\u0103tr\u0103\u021belul \\((i, j)\\). Astfel, se ini\u021bializeaz\u0103 \\(d[1][1] = 0\\) \u0219i \\(d[i][j] = m + n\\) pentru orice indici \\(i, j\\). Se parcurge matricea \\(d\\) \u0219i pentru fiecare pozi\u021bie \\((i, j)\\) se fac actualiz\u0103rile:</p> <ul> <li>\\(d[i][j + k] = min(d[i][j + k], d[i][j] + 1)\\), pentru fiecare \\(1 \\leq k \\leq P\\) cu \\(j + k \\leq N\\);</li> <li>\\(d[i + k][j] = min(d[i + k][j], d[i][j] + 1)\\), pentru fiecare \\(1 \\leq k \\leq Q\\) cu \\(i + k \\leq M\\);</li> <li>\\(d[i + k][j + k] = min(d[i + k][j + k], d[i][j] + 1)\\), pentru fiecare \\(1 \\leq k \\leq R\\) cu \\(i + k \\leq M\\), \\(j + k \\leq N\\);</li> <li>\\(d[i + 1][j + 2] = min(d[i + 1][j + 2], d[i][j] + 1)\\) \u0219i \\(d[i + 2][j + 1] = min(d[i + 2][j + 1], d[i][j] + 1)\\), c\u00e2nd indicii nu dep\u0103\u0219esc dimensiunile matricei.</li> </ul> <p>Complexitate: \\(O(M \\cdot N \\cdot (M + N + min(M, N)))\\).</p>","tags":["OJI","clasa XI-XII"]},{"location":"olimpiada/solutii/OJI/2023/XI-XII-turcane/#subtask-5-8-puncte","title":"Subtask 5 (8 puncte)","text":"<p>Se folose\u0219te programarea dinamic\u0103. Vom nota cu \\(d[i][j]\\) num\u0103rul minim de s\u0103rituri necesare pentru a ajunge \u00een p\u0103tr\u0103\u021belul \\((i, j)\\). Astfel, se ini\u021bializeaz\u0103 \\(d[1][1] = 0\\) \u0219i \\(d[i][j] = m + n\\) pentru orice indici \\(i, j\\). Se parcurge matricea \\(d\\) \u0219i pentru fiecare pozi\u021bie \\((i, j)\\) se fac actualiz\u0103rile:</p> <ul> <li>\\(d[i][j + k] = min(d[i][j + k], d[i][j] + 1)\\), pentru \\(k = min(P, N - j)\\);</li> <li>\\(d[i + k][j] = min(d[i + k][j], d[i][j] + 1)\\), pentru \\(k = min(Q, M - i)\\);</li> <li>\\(d[i + k][j + k] = min(d[i + k][j + k], d[i][j] + 1)\\), pentru \\(k = min(R, M - i, N - j)\\);</li> <li>\\(d[i + 1][j + 2] = min(d[i + 1][j + 2], d[i][j] + 1)\\) \u0219i \\(d[i + 2][j + 1] = min(d[i + 2][j + 1], d[i][j] + 1)\\), c\u00e2nd indicii nu dep\u0103\u0219esc dimensiunile matricei.</li> </ul> <p>Complexitate: \\(O(M \\cdot N)\\).</p>","tags":["OJI","clasa XI-XII"]},{"location":"olimpiada/solutii/OJI/2023/XI-XII-turcane/#solutie-alternativa","title":"Solu\u021bie alternativ\u0103","text":"<p>Se folose\u0219te programarea dinamic\u0103. Astfel, se ini\u021bializeaz\u0103 \\(d[1][1] = 1\\) \u0219i \\(d[i][j] = m + n\\) pentru orice indici \\(i, j\\) \u00een rest. Se parcurge matricea \\(d\\) \u0219i pentru fiecare pozi\u021bie \\((i, j)\\) diferit\u0103 de pozi\u021bia \\((1, 1)\\), se actualizeaz\u0103 \\(d[i][j] = min(a, b, c, e, f)\\), unde:</p> <ul> <li>\\(a = min(d[i][j - k] | 1 \\leq k \\leq P, 1 \\leq j - k)\\);</li> <li>\\(b = min(d[i - k][j] | 1 \\leq k \\leq Q, 1 \\leq i - k)\\);</li> <li>\\(c = min(d[i - k][j - k] | 1 \\leq k \\leq R, 1 \\leq i - k, 1 \\leq j - k)\\);</li> <li>\\(e = d[i - 1][j - 2]\\);</li> <li>\\(f = d[i - 2][j - 1]\\).</li> </ul> <p>Pentru a calcula \\(a\\), \\(b\\), \\(c\\) \u00een \\(O(1)\\), se folose\u0219te deque pe fiecare linie, coloan\u0103 \u0219i diagonal\u0103.</p> <p>Complexitate: \\(O(M \\cdot N)\\).</p> <p>O solu\u021bie asem\u0103n\u0103toare, dar care nu trece toate testele, este ca \u00een locul structurii deque s\u0103 folosim set.</p> <p>Complexitate: \\(O(M \\cdot N \\cdot \\log(max(M, N)))\\).</p>","tags":["OJI","clasa XI-XII"]},{"location":"olimpiada/solutii/OJI/2023/XI-XII-turcane/#subtask-6-11-puncte","title":"Subtask 6 (11 puncte)","text":"<p>Se folose\u0219te metoda backtracking pentru a genera toate drumurile de la p\u0103tr\u0103\u021belul de coordonate \\((1, 1)\\) la p\u0103tr\u0103\u021belul \\((M, N)\\).</p> <p>Complexitate: \\(O(2^(M + N + min(M, N)))\\).</p>","tags":["OJI","clasa XI-XII"]},{"location":"olimpiada/solutii/OJI/2023/XI-XII-turcane/#subtask-7-12-puncte","title":"Subtask 7 (12 puncte)","text":"<p>Se folose\u0219te programarea dinamic\u0103. Vom nota cu \\(d[i][j]\\) num\u0103rul de moduri \u00een care se poate ajunge \u00een p\u0103tr\u0103\u021belul \\((i, j)\\). Se ini\u021bializeaz\u0103 \\(d[1][1] = 1\\), se parcurge matricea \\(d\\) \u0219i pentru fiecare pozi\u021bie \\((i, j)\\) se fac actualiz\u0103rile:</p> <ul> <li>\\(d[i][j + k] += d[i][j]\\), pentru fiecare \\(1 \\leq k \\leq P\\) cu \\(j + k \\leq N\\);</li> <li>\\(d[i + k][j] += d[i][j]\\), pentru fiecare \\(1 \\leq k \\leq Q\\) cu \\(i + k \\leq M\\);</li> <li>\\(d[i + k][j + k] += d[i][j]\\), pentru fiecare \\(1 \\leq k \\leq R\\) cu \\(i + k \\leq M\\), \\(j + k \\leq N\\);</li> <li>\\(d[i + 1][j + 2] += d[i][j]\\) \u0219i \\(d[i + 2][j + 1] += d[i][j]\\), c\u00e2nd indicii nu dep\u0103\u0219esc dimensiunile matricei.</li> </ul> <p>Complexitate: \\(O(M \\cdot N \\cdot (M + N + min(M, N)))\\).</p>","tags":["OJI","clasa XI-XII"]},{"location":"olimpiada/solutii/OJI/2023/XI-XII-turcane/#subtask-8-14-puncte","title":"Subtask 8 (14 puncte)","text":"<p>Se folose\u0219te programarea dinamic\u0103. Vom nota cu \\(d[i][j]\\) num\u0103rul de moduri \u00een care se poate ajunge \u00een p\u0103tr\u0103\u021belul \\((i, j)\\). Se ini\u021bializeaz\u0103 \\(d[1][1] = 1\\), se parcurge matricea \\(d\\) \u0219i pentru fiecare pozi\u021bie \\((i, j)\\) se fac actualiz\u0103rile:</p> <ul> <li>\\(d[i][j] += \u2211d[i][j - k]\\), pentru fiecare \\(1 \\leq k \\leq P\\) cu \\(1 \\leq j - k\\);</li> <li>\\(d[i][j] += \u2211d[i - k][j]\\), pentru fiecare \\(1 \\leq k \\leq Q\\) cu \\(1 \\leq i - k\\);</li> <li>\\(d[i][j] += \u2211d[i - k][j - k]\\), pentru fiecare \\(1 \\leq k \\leq R\\) cu \\(1 \\leq i - k\\), \\(1 \\leq j - k\\);</li> <li>\\(d[i][j] += d[i - 2][j - 1]\\) \u0219i \\(d[i][j] += d[i - 1][j - 2]\\), c\u00e2nd indicii nu dep\u0103\u0219esc dimensiunile matricei.</li> </ul> <p>Pentru aceasta, se vor calcula dinamic sumele par\u021biale ale elementelor matricei \\(d\\), pentru fiecare linie, coloan\u0103 \u0219i diagonal\u0103.</p> <p>Complexitate: \\(O(M \\cdot N)\\).</p>","tags":["OJI","clasa XI-XII"]},{"location":"olimpiada/solutii/OJI/2023/XI-XII-turcane/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n\nifstream fin(\"turcane.in\");\nofstream fout(\"turcane.out\");\n\nconst int mod = 1e9 + 7;\nint n, m, p, q, r;\n\nvoid minSelf(int &amp;x, int y) {\n  if (y &lt; x) {\n    x = y;\n  }\n}\n\nvoid addSelf(int &amp;x, int y) {\n  x += y;\n  if (x &gt;= mod) {\n    x -= mod;\n  }\n}\n\nvoid solveFirstTask() {\n  vector&lt;vector&lt;int&gt;&gt; dp(n + 1, vector&lt;int&gt;(m + 1, mod));\n\n  dp[1][1] = 0;\n\n  for (int i = 1; i &lt;= n; ++i) {\n    for (int j = 1; j &lt;= m; ++j) {\n      minSelf(dp[i][j + min(p, m - j)], dp[i][j] + 1);\n      minSelf(dp[i + min(q, n - i)][j], dp[i][j] + 1);\n      minSelf(dp[i + min({r, n - i, m - j})][j + min({r, n - i, m - j})], dp[i][j] + 1);\n\n      if (i + 1 &lt;= n &amp;&amp; j + 2 &lt;= m) {\n        minSelf(dp[i + 1][j + 2], dp[i][j] + 1);\n      }\n\n      if (i + 2 &lt;= n &amp;&amp; j + 1 &lt;= m) {\n        minSelf(dp[i + 2][j + 1], dp[i][j] + 1);\n      }\n    }\n  }\n\n  fout &lt;&lt; dp[n][m] &lt;&lt; '\\n';\n}\n\nvoid solveSecondTask() {\n  vector&lt;vector&lt;int&gt;&gt; dp(n + 1, vector&lt;int&gt;(m + 1));\n  vector&lt;int&gt; lin(m + 2);\n  vector&lt;vector&lt;int&gt;&gt; col(n + 2, vector&lt;int&gt;(m + 1));\n  vector&lt;vector&lt;int&gt;&gt; diag(n + 2, vector&lt;int&gt;(m + 2));\n\n  dp[1][1] = 1;\n\n  for (int i = 1; i &lt;= n; ++i) {\n    for (int j = 1; j &lt;= m; ++j) {\n      lin[j] = 0;\n    }\n\n    for (int j = 1; j &lt;= m; ++j) {\n      addSelf(lin[j], lin[j - 1]);\n      addSelf(col[i][j], col[i - 1][j]);\n      addSelf(diag[i][j], diag[i - 1][j - 1]);\n\n      addSelf(dp[i][j], lin[j]);\n      addSelf(dp[i][j], col[i][j]);\n      addSelf(dp[i][j], diag[i][j]);\n\n      if (p &amp;&amp; j + 1 &lt;= m) {\n        addSelf(lin[j + 1], dp[i][j]);\n        addSelf(lin[j + min(p, m - j) + 1], mod - dp[i][j]);\n      }\n\n      if (q &amp;&amp; i + 1 &lt;= n) {\n        addSelf(col[i + 1][j], dp[i][j]);\n        addSelf(col[i + min(q, n - i) + 1][j], mod - dp[i][j]);\n      }\n\n      if (r &amp;&amp; i + 1 &lt;= n &amp;&amp; j + 1 &lt;= m) {\n        addSelf(diag[i + 1][j + 1], dp[i][j]);\n        addSelf(diag[i + min({r, n - i, m - j}) + 1][j + min({r, n - i, m - j}) + 1], mod - dp[i][j]);\n      }\n\n      if (i + 1 &lt;= n &amp;&amp; j + 2 &lt;= m) {\n        addSelf(dp[i + 1][j + 2], dp[i][j]);\n      }\n\n      if (i + 2 &lt;= n &amp;&amp; j + 1 &lt;= m) {\n        addSelf(dp[i + 2][j + 1], dp[i][j]);\n      }\n    }\n  }\n\n  fout &lt;&lt; dp[n][m] &lt;&lt; '\\n';\n}\n\nint main() {\n  int task;\n  fin &gt;&gt; task &gt;&gt; n &gt;&gt; m &gt;&gt; p &gt;&gt; q &gt;&gt; r;\n\n  if (task == 1) {\n    solveFirstTask();\n  } else {\n    solveSecondTask();\n  }\n  return 0;\n}\n</code></pre>","tags":["OJI","clasa XI-XII"]},{"location":"olimpiada/solutii/OJI/2023/XI-XII-veri/","title":"Solu\u021bia problemei Veri (OJI 2023, clasele XI-XII)","text":"","tags":["OJI","clasa XI-XII"]},{"location":"olimpiada/solutii/OJI/2023/XI-XII-veri/#subtask-1-30-puncte","title":"Subtask 1 (30 puncte)","text":"<p>Tot graful este un ciclu. Primul drum are lungimea \\(n\\). Urm\u0103torul drum are lungimea \\((n + A - S) \\mod n\\), analog pentru ultimul drum.</p> <p>Complexitate: \\(O(n)\\).</p>","tags":["OJI","clasa XI-XII"]},{"location":"olimpiada/solutii/OJI/2023/XI-XII-veri/#subtask-2-50-puncte","title":"Subtask 2 (50 puncte)","text":"<p>Observa\u021bia principal\u0103 a problemei implic\u0103 recunoa\u0219terea formei drumului optim:</p> <p>Trebuie s\u0103 existe un nod \\(i\\) astfel \u00eenc\u00e2t drumurile \\(s \\rightarrow i\\), \\(i \\rightarrow a\\) \u0219i \\(i \\rightarrow b\\) au lungime minim\u0103 \u0219i ne putem folosi de cel mai scurt ciclu care \u00eencepe \u0219i se termin\u0103 \u00een \\(i\\).</p> <p>Toate constr\u00e2ngerile de mai sus pot fi rezolvate cu algoritmul Roy-Floyd, cu dou\u0103 men\u021biuni:</p> <ul> <li>\\(d[i][j]\\) va fi folosit pentru ciclul de lungime minim\u0103 care \u00eencepe \u0219i se termin\u0103 \u00een \\(i\\), \\(\\forall i \\in {1, \\dots, n}\\).</li> <li>Pentru reconstruirea oric\u0103rui drum, trebuie s\u0103 re\u021binem o matrice suplimentar\u0103 \\(p\\). Dac\u0103 am ameliorat lungimea drumului \\(i \\rightarrow j\\) cu ajutorul nodului \\(z\\), atunci actualiz\u0103m \\(p[i][j] \\leftarrow z\\). C\u00e2nd vrem s\u0103 reconstruim drumul \\(i \\rightarrow j\\) de lungime minim\u0103, construim recursiv \u0219i unim drumurile \\(i \\rightarrow p[i][j]\\) \u0219i \\(p[i][j] \\rightarrow j\\).</li> </ul> <p>Trebuie s\u0103 reconstruim 4 drumuri, fiecare \u00een \\(O(n^2)\\). Complexitatea total\u0103 a algoritmului este \\(O(n^3)\\).</p>","tags":["OJI","clasa XI-XII"]},{"location":"olimpiada/solutii/OJI/2023/XI-XII-veri/#subtask-3-20-puncte","title":"Subtask 3 (20 puncte)","text":"<p>C\u0103ut\u0103m ciclul optim \\((i \\rightarrow i)\\) astfel: oricum ar ar\u0103ta ciclul, exist\u0103 un arbore BFS al grafului astfel \u00eenc\u00e2t ciclul s\u0103 fie reprezentat de un lan\u021b \u00een jos din r\u0103d\u0103cin\u0103, \u00eenchis de un back edge \u00eenapoi \u00een r\u0103d\u0103cin\u0103.</p> <p>Constr\u00e2ngerile ne permit s\u0103 construim fiecare arbore BFS din graf (adic\u0103 s\u0103 facem \\(n\\) BFS-uri, unul pentru fiecare r\u0103d\u0103cin\u0103 posibil\u0103), care vor lua \\(O(n(n + m)) \\in O(n^2)\\), deoarece \\(m \\leq 4n\\).</p> <p>Putem reconstrui orice drum \u00een \\(O(n)\\), deci solu\u021bia are complexitatea  \\(O(n^2)\\) pentru acest subtask. Pentru celelalte subtaskuri, solu\u021bia are complexitatea \\(O(n^3)\\), \u00eencadr\u00e2ndu-se \u00een limita de timp.</p>","tags":["OJI","clasa XI-XII"]},{"location":"olimpiada/solutii/OJI/2023/XI-XII-veri/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;bits/stdc++.h&gt;\n\nusing namespace std;\n\nifstream f(\"veri.in\");\nofstream g(\"veri.out\");\n\nconst int NMAX = 5e3 + 5, INF = 1e9;\n\nint dist[NMAX][NMAX], dist1[NMAX];\nint parent[NMAX][NMAX];\n\nvector&lt;int&gt; v[NMAX];\nqueue&lt;int&gt; q;\n\nvoid bfs(int src) {\n    dist[src][src] = 0;\n    q.push(src);\n\n    while (!q.empty()) {\n        int nod = q.front();\n        q.pop();\n\n        for (auto&amp; i : v[nod]) {\n            if (src == i &amp;&amp; !dist1[src]) {\n                dist1[src] = dist[src][nod] + 1;\n                parent[src][src] = nod;\n            } else if (dist[src][nod] + 1 &lt; dist[src][i]) {\n                dist[src][i] = dist[src][nod] + 1;\n                parent[src][i] = nod;\n                q.push(i);\n            }\n        }\n    }\n}\n\nvoid inapoi(int nod, int start, bool rep) {\n    if (nod == start &amp;&amp; rep == false)\n        g &lt;&lt; start &lt;&lt; \" \";\n    else \n        if (nod != start) {\n            inapoi(parent[start][nod], start, rep);\n            g &lt;&lt; nod &lt;&lt; \" \";\n        }\n}\n\nint main() {\n    int cer;\n    f &gt;&gt; cer;\n\n    int n, m, s, a, b;\n    f &gt;&gt; n &gt;&gt; m &gt;&gt; s &gt;&gt; a &gt;&gt; b;\n\n    for (int i = 1; i &lt;= m; i++) {\n        int x, y;\n        f &gt;&gt; x &gt;&gt; y;\n        v[x].push_back(y);\n    }\n\n    for (int i = 1; i &lt;= n; i++) {\n        for (int j = 1; j &lt;= n; j++) {\n            dist[i][j] = INF;\n        }\n    }\n\n    for (int i = 1; i &lt;= n; i++) {\n        bfs(i);\n    }\n\n    int ind;\n    int ans = INF;\n\n    for (int i = 1; i &lt;= n; i++) {\n        int aux = dist[s][i] + dist1[i] + dist[i][a];\n        int aux1 = dist[s][i] + dist1[i] + dist[i][b];\n\n        if (max(aux, aux1) &lt; ans &amp;&amp; dist1[i] &amp;&amp; dist[s][i] != INF &amp;&amp; dist[i][a] != INF &amp;&amp; dist[i][b] != INF) {\n            ans = max(aux, aux1), ind = i;\n        } \n        else if (max(aux, aux1) == ans &amp;&amp; dist1[i] &amp;&amp; dist[s][i] != INF &amp;&amp; dist[i][a] != INF &amp;&amp; dist[i][b] != INF &amp;&amp;\n                   dist[s][i] + dist1[i] &lt; dist[s][ind] + dist1[ind]) {\n            ind = i;\n        }\n    }\n\n    if (cer == 1) {\n        g &lt;&lt; ans;\n    } \n    else {\n        g &lt;&lt; dist[s][ind] + dist1[ind] &lt;&lt; '\\n';\n        inapoi(ind, s, 0);\n        inapoi(parent[ind][ind], ind, 1);\n        g &lt;&lt; ind &lt;&lt; '\\n';\n\n        g &lt;&lt; dist[ind][a] &lt;&lt; '\\n';\n        inapoi(a, ind, 0);\n        g &lt;&lt; '\\n';\n\n        g &lt;&lt; dist[ind][b] &lt;&lt; '\\n';\n        inapoi(b, ind, 0);\n    }\n\n    return 0;\n}\n</code></pre>","tags":["OJI","clasa XI-XII"]},{"location":"olimpiada/solutii/OJI/2024/IX-macarie/","title":"Solu\u021bia problemei Macarie (OJI 2024, clasa a IX-a)","text":"<p>Subtask 1: Complexitatea \\(\\mathcal{O}(Valmax \\cdot N)\\), unde \\(Valmax\\) este valoarea maxim\u0103 din \u0219irul \\(A\\). Pentru fiecare valoare \\(x\\), \u00een ordine de la 1 la \\(Valmax\\), se parcurge \u0219irul \\(A\\) \u0219i se creaz\u0103 lista \\(D\\), introduc\u00e2nd \\(x\\) de fiecare dat\u0103 c\u00e2nd acesta divide un element al \u0219irului. R\u0103spunsul la fiecare din cele \\(Q\\) \u00eentreb\u0103ri este realizat \u00een \\(\\mathcal{O}(1)\\).</p> <p>Subtask 2: Complexitatea \\(\\mathcal{O}(Valmax + N + Q)\\). \u00centruc\u00e2t valorile din fi\u0219ier sunt numere prime, lista \\(D\\) con\u021bine \\(N\\) valori egale cu 1, \u0219i valorile \u0219irului \\(A\\), \u00een ordine cresc\u0103toare. Cum acestea sunt mai mici dec\u00e2t 1000000 se pot re\u021bine \u00eentr-un vector de frecven\u021b\u0103. Pe baza acestuia se poate construi \u0219irul \\(D\\) \u0219i r\u0103spunde \u00een \\(\\mathcal{O}(1)\\) la cele \\(Q\\) \u00eentreb\u0103ri.</p> <p>Subtask 3: Complexitatea \\(\\mathcal{O}(N \\cdot \\sqrt{Valmax} + PozMax)\\). Pentru fiecare num\u0103r din \u0219irul \\(A\\), vom determina \u00een \\(\\mathcal{O}(\\sqrt{Valmax})\\) divizorii acestuia, marc\u00e2ndu-i \u00eentr-un vector de frecven\u021b\u0103. Pe baza acestuia se va construi \u0219irul \\(D\\) \u0219i r\u0103spunde \u00een \\(\\mathcal{O}(1)\\) la cele \\(Q\\) \u00eentreb\u0103ri.</p> <p>Subtask 4: Complexitatea \\(\\mathcal{O}(Valmax \\cdot \\log{Valmax} + Q)\\). Se garanteaz\u0103 c\u0103 pozi\u021biile din \u0219irul \\(D\\) pentru care trebuie s\u0103 identific\u0103m divizorii sunt mai mici dec\u00e2t 2000000. Vom construi un vector \\(NrMultipli\\) \u00een care se va re\u021bine, pentru fiecare valoare \\(x\\) de la 1 la \\(ValMax\\), c\u00e2te numere din \u0219irul \\(A\\) se divid cu \\(x\\). Construc\u021bia se face \u00een complexitate \\(Valmax \\cdot \\log{Valmax}\\), similar cu Ciurul lui Eratostene. Pe baza acestui vector se va construi \u0219irul \\(D\\) \u0219i r\u0103spunde \u00een \\(\\mathcal{O}(1)\\) la cele \\(Q\\) \u00eentreb\u0103ri.</p> <p>Subtask 5: Complexitatea \\(\\mathcal{O}(ValMax \\cdot \\log{Valmax} + Q \\cdot \\log{Valmax})\\) Neav\u00e2nd restric\u021bii suplimentare, vom contrui vectorul \\(NrMultipli\\) la fel ca la subtaskul 4. \u0218irul \\(D\\) \u00eel vom construi memor\u00e2nd \\((divizor, frecventa)\\). Folosind sumele par\u021biale, putem re\u021bine \u00een \\(D[x].frecventa\\) ultima pozi\u021bie pe care apare \\(x\\) \u00een lista divizorilor. Cum \u0219irul acestor pozi\u021bii este cresc\u0103tor, pentru a r\u0103spunde la cele \\(Q\\) \u00eentreb\u0103ri, vom folosi c\u0103utarea binar\u0103.</p> <p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n\nint n, m, fr[1000001], sp[1000001];\n\nvoid sieve() {\n    for (int i = 1; i &lt;= 1000000; i++) {\n        for (int j = i; j &lt;= 1000000; j += i) {\n            sp[i] += fr[j];\n        }\n        sp[i] += sp[i - 1];\n    }\n}\n\nint main() {\n    ifstream cin(\"macarie.in\");\n    ofstream cout(\"macarie.out\");\n\n    cin &gt;&gt; n &gt;&gt; m;\n    for (int i = 1; i &lt;= n; i++) {\n        int x;\n        cin &gt;&gt; x;\n        fr[x]++;\n    }\n\n    sieve();\n\n    for (int i = 1; i &lt;= m; i++) {\n        int x;\n        cin &gt;&gt; x;\n\n        int st = 1;\n        int dr = 1000000;\n        int ans = 0;\n        while (st &lt;= dr) {\n            int mid = (st + dr) / 2;\n            if (sp[mid] &gt;= x) {\n                ans = mid, dr = mid - 1;\n            } else {\n                st = mid + 1;\n            }\n        }\n\n        cout &lt;&lt; ans &lt;&lt; \" \";\n    }\n    return 0;\n}\n</code></pre>","tags":["OJI","clasa IX"]},{"location":"olimpiada/solutii/OJI/2024/IX-santinele/","title":"Solu\u021bia problemei Santinele (OJI 2024, clasa a IX-a)","text":"<p>Subtask 1: Santinela trebuie amplasat\u0103 \u00een primele \\(K + 1\\) \u00een\u0103l\u021bimi. Fie \\(h_i\\) cel mai din dreapta maxim din primele \\(K +1\\) \u00een\u0103l\u021bimi. Atunci, \\(i\\) este cea mai din dreapta pozi\u021bie \u00een care putem plasa santinela. Dac\u0103 am plasa-o \u00eentr-o pozi\u021bie \\(j\\) mai la dreapta, atunci \\(h_j &lt; h_i\\), deci santinela nu va acoperi \\(h_i\\). Vom calcula num\u0103rul maxim de \u00een\u0103l\u021bimi ce pot fi vegheate pornind spre dreapta de la pozi\u021bia \\(i\\) p\u00e2n\u0103 ce d\u0103m de o \u00een\u0103l\u021bime strict mai mare, fie dep\u0103\u0219im pozi\u021bia \\(2 \\cdot K + 1\\). Complexitate: \\(\\mathcal{O}(K)\\) timp, \\(\\mathcal{O}(1)\\) memorie.</p> <p>Subtask 2: Fie \\(H\\) maximul dintre \u00een\u0103l\u021bimi. Avem dou\u0103 situa\u021bii:</p> <ul> <li>\\(h_{N/2} = H\\) sau \\(h_{N/2+1} = H\\). Avem nevoie de o singur\u0103 santinel\u0103 ce poate   fi amplasat\u0103 la una din acele pozi\u021bii \u0219i va veghea tot muntele.</li> <li>\\(h_{N/2} \\neq H\\) \u0219i \\(h_{N/2+1} \\neq H\\). Avem nevoie de dou\u0103 santinele, una   pentru primele \\(K + 1\\) \u00een\u0103l\u021bimi \u0219i una pentru ultimele \\(K\\). Cele dou\u0103   santinele vor fi amplasate \u00een maximele zonelor vegheate de ele. Complexitate:   \\(\\mathcal{O}(N)\\) timp, \\(\\mathcal{O}(1)\\) memorie.</li> </ul> <p>Subtask 3: \u00cen\u0103l\u021bimile fiind strict cresc\u0103toare putem plasa santinele pe pozi\u021biile \\(K + 1\\), \\(2 \\cdot K + 2\\), \\(3 \\cdot K + 3\\), etc. Num\u0103rul minim de santinele este \\(N/(K + 1)\\) dac\u0103 \\(N\\) se divide cu \\(K + 1\\), sau \\(N/(K +1)+1\\) \u00een caz contrar. Expresia C/C++ ce calculeaz\u0103 acest num\u0103r este \\((N +K)/(K +1)\\). Complexitate: \\(\\mathcal{O}(1)\\) timp \u0219i memorie.</p> <p>Subtask 4: Acest subtask este similar cu cel anterior. Vom calcula maximul. S\u0103 presupunem c\u0103 se afl\u0103 pe pozi\u021bia \\(i\\). \u00cemp\u0103r\u021bim logic \u0219irul \u00een dou\u0103 sub\u0219iruri: elementele de la 1 la \\(i\\) (inclusiv) \u0219i cele de la \\(i\\) la \\(N\\) (inclusiv). Pentru fiecare din sub\u0219iruri este necesar s\u0103 amplas\u0103m un num\u0103r de santinele calculabil cu formula anterioar\u0103. Pentru primul sub\u0219ir num\u0103rul de santinele este \\((i + K)/(K +1)\\). Pentru al doilea sub\u0219ir num\u0103rul de santinele este \\((N -i +1+ K)/(K +1)\\) care este totuna cu (N - i)/(K + 1). Suma acestor expresii este num\u0103rul total de santinele necesar, cu o ajustare: santinela plasat\u0103 \u00een pozi\u021bia \\(i\\) este comun\u0103 ambelor sub\u0219iruri, deci vom sc\u0103dea 1 din expresia final\u0103. Num\u0103rul minim de santinele este \\((i + K)/(K + 1) + (N - i)/(K + 1) - 1\\). Complexitate: \\(\\mathcal{O}(N)\\) timp, \\(\\mathcal{O}(1)\\) memorie.</p> <p>Subtask 5: Vom construi un vector v[] \u00eencerc\u00e2nd s\u0103 folosim c\u00e2t mai pu\u021bine santinele pentru a veghea muntele p\u00e2n\u0103 la \\(h_i\\). Pentru aceasta vom \u00eencerca s\u0103 plas\u0103m o santinel\u0103 pe fiecare \\(h_i\\), variind \\(i\\) de la 1 la \\(N\\). Pentru o pozi\u021bie \\(i\\) vom parcurge \u00een\u0103l\u021bimile la st\u00e2nga \u0219i la dreapta pentru a determina limitele \\(st\\) \u0219i \\(dr\\) p\u00e2n\u0103 unde vegheaz\u0103 santinela plasat\u0103 pe \u00een\u0103l\u021bimea \\(hi\\). Apoi vom testa ce se \u00eent\u00e2mpl\u0103 dac\u0103 plas\u0103m santinela la aceast\u0103 pozi\u021bie: \u0219tim c\u0103 pozi\u021biile p\u00e2n\u0103 la \\(st - 1\\) sunt deja vegheate \u0219i \u0219tim c\u0103 avem nevoie de \\(v[st - 1]\\) santinele. Vom parcurge pozi\u021biile de la \\(st\\) la \\(dr\\) \u0219i ne vom \u00eentreba dac\u0103 nu cumva num\u0103rul de santinele necesare la acele pozi\u021bii \\(j\\) se poate \u00eembun\u0103t\u0103\u021bi cu santinela curent\u0103. Cu alte cuvinte dac\u0103 \\(v[j] &gt; v[st - 1] + 1\\), actualiz\u0103m \\(v[j]\\) la \\(v[st - 1] + 1\\). La final vom afi\u0219a \\(v[N]\\). Complexitate: \\(\\mathcal{O}(N \\cdot K)\\) timp \u0219i \\(\\mathcal{O}(N)\\) memorie.</p> <p>Subtask 6: Solu\u021bia 1</p> <p>La subtaskul 1 am ar\u0103tat c\u0103 cea mai la dreapta pozi\u021bie pe care putem plasa prima santinel\u0103 este pozi\u021bia celui mai din dreapta maxim din primele \\(K + 1\\) \u00een\u0103l\u021bimi. Aceasta ne duce la un algoritm tip Greedy: g\u0103sim \\(h_i\\), ultimul maxim din primele \\(K + 1\\) \u0219i plas\u0103m prima santinela pe pozi\u021bia \\(i\\). Apoi verific\u0103m spre dreapta santinelei p\u00e2n\u0103 unde vegheaz\u0103 ea. Fie \\(h_j\\) prima \u00een\u0103l\u021bime care nu este vegheat\u0103 de prima santinel\u0103. Rezult\u0103 c\u0103 avem, acum, un nou sub\u0219ir, format din \u00een\u0103l\u021bimile \\(h_j, h_{j+1}, h_{j+2}, \\dots, h_N\\). Acest sub\u0219ir trebuie vegheat \u00een \u00eentregime, folosind c\u00e2t mai pu\u021bine santinele. Avem, deci, o problema identic\u0103 cu cea original\u0103, dar cu un \u0219ir mai mic. Vom relua, deci, calculul, p\u00e2n\u0103 ce \u00eentregul munte este vegheat. Complexitate: O(N) ca timp \u0219i memorie.</p> <p>Subtask 6: Solu\u021bia 2</p> <p>S\u0103 presupunem c\u0103 amplas\u0103m c\u00e2te o santinel\u0103 pe fiecare \u00een\u0103l\u021bime. Fiecare din santinele va avea c\u00e2te un interval st\u00e2nga-dreapta pe care \u00eel va veghea. Problema ne cere s\u0103 select\u0103m un num\u0103r minim de intervale care s\u0103 acopere indicii de la 1 p\u00e2n\u0103 la \\(N\\). Aceasta este o problem\u0103 cunoscut\u0103, care se rezolv\u0103 prin parcurgerea intervalelor \u00een ordinea cresc\u0103toare a deschiderii intervalului. La fiecare pas vom selecta intervalul care \u00eencepe \u00een zon\u0103 acoperit\u0103 \u0219i se termin\u0103 c\u00e2t mai departe spre dreapta. Capetele intervalelor sunt indici \u00eentre 1 \u0219i \\(N\\). Un interval \\([i, j]\\) poate fi stocat \u00eentr-un vector \u00een care set\u0103m \\(sfarsit[i] = j\\). Dac\u0103 avem mai multe intervale ce \u00eencep \u00een acela\u0219i punct \\(i\\) \u00eel p\u0103str\u0103m pe cel care are \\(j\\) maxim. \u00cen acest fel nu avem nevoie s\u0103 sort\u0103m intervalele.</p> <p>R\u0103m\u00e2ne s\u0103 stabilim cum determin\u0103m acele intervale. Pentru aceasta vom folosi alt\u0103 problem\u0103 cunoscut\u0103: pentru fiecare indice \\(i\\) din vectorul de \u00een\u0103l\u021bimi dorim s\u0103 calcul\u0103m primul element la st\u00e2nga strict mai mare dec\u00e2t \\(h_i\\). Acesta va fi cap\u0103tul st\u00e2nga al intervalului, dac\u0103 el se afl\u0103 la distan\u021b\u0103 mai mic\u0103 sau egal\u0103 cu \\(K\\). \u00cen caz contrar vom seta \\(i - K\\) drept cap\u0103tul st\u00e2nga al intervalului. Pentru a rezolva g\u0103sirea maximelor vom ne vom folosi de faptul c\u0103 avem deja calculat r\u0103spunsul pentru indicii anteriori. Pentru \\(i\\) ne vom \u00eentreba dac\u0103 \\(h_{i-1} &gt; h_i\\). Dac\u0103 da, am g\u0103sit raspunsul, dac\u0103 nu, vom avansa pe indicele primului maxim la st\u00e2nga al lui \\(h_{i-1}\\). Vom continua a\u0219a p\u00e2n\u0103 g\u0103sim maximul dorit. Vom proceda similar \u0219i pentru primul maxim la dreapta. Complexitate: \\(\\mathcal{O}(N)\\) at\u00e2t ca timp c\u00e2t \u0219i ca memorie.</p> <p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;bits/stdc++.h&gt;\nconst int NMAX = 1e5;\nusing namespace std;\nifstream fin(\"santinele.in\");\nofstream fout(\"santinele.out\");\nint arr[2 * NMAX + 5], task, n, k;\nint get_next(int idx) {\n    int maxi = INT_MIN, poz = 0;\n    for (int i = idx; i &lt;= min(n + 1, idx + k); i++) {\n        if (arr[i] &gt;= maxi) {\n            maxi = arr[i], poz = i;\n        }\n    }\n    for (int j = poz + 1; j &lt;= min(n + 1, poz + k); j++) {\n        if (arr[j] &gt; arr[poz]) {\n            return j - 1;\n        }\n    }\n    return poz + k;\n}\nsigned main() {\n    fin &gt;&gt; task &gt;&gt; n &gt;&gt; k;\n    for (int i = 1; i &lt;= n; i++) {\n        fin &gt;&gt; arr[i];\n    }\n    if (task == 1) {\n        fout &lt;&lt; get_next(1);\n    } else {\n        int pos = 1, cnt = 0;\n        while (pos &lt;= n) {\n            pos = get_next(pos) + 1;\n            cnt++;\n        }\n        fout &lt;&lt; cnt;\n    }\n    return 0;\n}\n</code></pre>","tags":["OJI","clasa IX"]},{"location":"olimpiada/solutii/OJI/2024/IX-trafalet/","title":"Solu\u021bia problemei Trafalet (OJI 2024, clasa a IX-a)","text":"<p>Subtask 1: Consider\u0103m fiecare submatrice a matricei ini\u021biale. Punctajul acesteia este reprezentat de diferen\u021ba \u00een modul dintre suma celulelor albe \u0219i suma celulelor negre. Aceste dou\u0103 sume le putem calcula prin parcurgerea submatricei. Rezultatul final este maximul dintre toate punctajele considerate. Complexitate: \\(\\mathcal{O}(N^2 \\cdot M^2)\\) pentru fixarea submatricei, \\(\\mathcal{O}(N \\cdot M)\\) pentru calcularea sumelor. \u00cen total, \\(\\mathcal{O}(N^3 \\cdot M^3)\\).</p> <p>Subtask 2: Solu\u021bia este aceea\u0219i ca la subtaskul precedent, doar c\u0103 vom optimiza aflarea celor dou\u0103 sume. Astfel, vom precalcula sume par\u021biale 2D \u0219i vom ob\u021bine punctajul fiec\u0103rei submatrice cu ajutorul acestora. Complexitate: \\(\\mathcal{O}(N^2 \\cdot M^2)\\) pentru fixarea submatricei, \\(\\mathcal{O}(1)\\) pentru calcularea sumelor. \u00cen total, \\(\\mathcal{O}(N^2 \\cdot M^2)\\).</p> <p>Subtask 3: Pentru \u00eenceput, vom \u00eenmul\u021bi toate celulele uneia dintre culori cu \\(-1\\). Acum, \u00een loc s\u0103 calcul\u0103m diferen\u021ba \u00eentre cele dou\u0103 sume, avem doar de calculat suma \u00een modul. Pentru a rezolva asta, vom fixa dou\u0103 linii, reprezent\u00e2nd latura superioar\u0103, respectiv inferioar\u0103 a submatricei. Am r\u0103mas cu un vector, unde elementul de pe pozi\u021bia \\(i\\) reprezint\u0103 suma elementelor de pe coloana \\(i\\), cuprinse \u00eentre cele dou\u0103 linii fixate anterior.</p> <p>Problema s-a redus la a calcula secven\u021ba de sum\u0103 maxim\u0103 \u00een modul. Aceasta este data de diferen\u021ba dintre suma par\u021bial\u0103 maxim\u0103 \u0219i cea minim\u0103. Fie pozi\u021biile acestora Pmax \u0219i Pmin. Dac\u0103 \\(P_{max} &gt; P_{min}\\), atunci r\u0103spunsul \u00eel reprezint\u0103 suma intervalului dat de acestea. Dac\u0103 \\(P_{min} &gt; P_{max}\\), atunci intervalul dintre cele dou\u0103 este cel de sum\u0103 minim\u0103, care, dup\u0103 aplicarea modulului, se transform\u0103 \u00een suma maxim\u0103. Complexitate: \\(\\mathcal{O}(N^2 \\cdot M)\\).</p> <p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n\nint n, m, mat[502][502];\nlong long sp[502][502];\n\nint main() {\n    ifstream cin(\"trafalet.in\");\n    ofstream cout(\"trafalet.out\");\n\n    cin &gt;&gt; n &gt;&gt; m;\n    for (int i = 1; i &lt;= n; i++) {\n        for (int j = 1; j &lt;= m; j++) {\n            cin &gt;&gt; mat[i][j];\n            if ((i + j) &amp; 1) {\n                sp[i][j] = sp[i - 1][j] + mat[i][j];\n            } else {\n                sp[i][j] = sp[i - 1][j] - mat[i][j];\n            }\n        }\n    }\n\n    long long ans = -(1LL &lt;&lt; 60);\n    for (int i = 1; i &lt;= n; i++) {\n        for (int j = i; j &lt;= n; j++) {\n            long long sm = 0, minsp = 0, maxsp = 0;\n            for (int q = 1; q &lt;= m; q++) {\n                sm += sp[j][q] - sp[i - 1][q];\n                ans = max(ans, abs(sm - minsp));\n                ans = max(ans, abs(sm - maxsp));\n                minsp = min(minsp, sm);\n                maxsp = max(maxsp, sm);\n            }\n        }\n    }\n\n    cout &lt;&lt; ans &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["OJI","clasa IX"]},{"location":"olimpiada/solutii/OJI/2024/V-bomboane/","title":"Solu\u021bia problemei Bomboane (OJI 2024, clasa a V-a)","text":"<p>Mai jos, nota\u021biile \\(N\\), \\(X\\), \\(Y\\) au semnifica\u021bia din enun\u021b.</p> <p>Cerin\u021ba 1: Valoarea cerut\u0103 se ob\u021bine ca rezultat al expresiei \\(\\frac{N}{X}\\).</p> <p>Cerin\u021ba 2: Num\u0103rul de copii \u0219i num\u0103rul de bomboane trebuie s\u0103 fie divizori ai lui \\(N\\) \u0219i totodat\u0103 produsul lor trebuie s\u0103 fie egal cu \\(N\\). Divizorii cu aceast\u0103 proprietate se ob\u021bin c\u0103ut\u00e2nd un divizor \\(d\\), iar perechea lui va fi atunci \\(\\frac{N}{d}\\). Este suficient s\u0103 g\u0103sim pe d ca fiind cel mai mic divizor propriu al lui \\(N\\) \u0219i solu\u021bia va fi \\(\\frac{N}{d}\\).</p> <p>Cerin\u021ba 3: Datele de intrare ne permit s\u0103 c\u0103ut\u0103m solu\u021bie consider\u00e2nd pe r\u00e2nd cazurile: nu l\u0103s\u0103m \u00een cutie bomboane, l\u0103s\u0103m o singur\u0103 bomboan\u0103, l\u0103s\u0103m dou\u0103 bomboane, etc. La prima astfel de valoare pentru care putem determina o distribuire, ne oprim. Odat\u0103 fixat num\u0103rul \\(b\\) de bomboane l\u0103sate \u00een cutie (parcurg\u00e2nd valorile de la 0 la 100 cu o instruc\u021biune repetitiv\u0103), r\u0103m\u00e2ne ca toate celelalte bomboane \\(n = N \u2212 b\\) s\u0103 fie distribuite. Avem \u0219i \u00een acest caz de determinat o pereche de divizori ai lui \\(n\\) al c\u0103ror produs este chiar \\(n\\). Aceste perechi sunt deci de forma \\((d, \\frac{n}{d})\\).</p> <p>Este suficient s\u0103 c\u0103ut\u0103m astfel de perechi c\u00e2t timp \\(d \\leq \\frac{n}{d}\\). Pentru fiecare pereche determinat\u0103 \\((d, \\frac{n}{d})\\) analiz\u0103m dac\u0103 putem avea \\(d\\) = num\u0103rul de copii \u0219i \\(\\frac{n}{d}\\) num\u0103rul de bomboane \u0219i se respect\u0103 condi\u021biile \\(d \\geq X\\) \u0219i \\(\\frac{n}{d} \\geq Y\\) sau respectiv \\(d =\\) num\u0103rul de bomboane \u0219i \\(\\frac{n}{d}\\) num\u0103rul de copii \u0219i se respect\u0103 condi\u021biile \\(d \\geq Y\\) \u0219i \\(\\frac{n}{d} \\geq X\\).</p> <p>Cerin\u021ba 3 poate fi abordat\u0103 \u0219i \u00een modul descris \u00een continuare. Not\u0103m cu \\(x\\) num\u0103rul de copii c\u0103utat, cu \\(y\\) num\u0103rul de bomboane c\u0103utat \u0219i cu \\(dif\\) num\u0103rul de bomboane care vor r\u0103m\u00e2ne \u00een cutie. O solu\u021bie simpl\u0103 este aceea de a parcurge cu \\(x\\) toate valorile $1, \\(2, \\dots, N\\) \u0219i la fiecare pas calcul\u0103m \\(y = N/x\\), \\(dif = N \u2212 x \\cdot y\\) \u0219i p\u0103str\u0103m tripletul \\((dif, x, y)\\) cu diferen\u021ba \\(dif\\) minim\u0103, iar la aceea\u0219i diferen\u021b\u0103 minim\u0103 \\(x\\) s\u0103 fie maxim.</p> <p>C\u00e2nd p\u0103str\u0103m un triplet avem grij\u0103 s\u0103 fie respectate \u0219i condi\u021biile \\(x \\geq X\\) \u0219i \\(y \\geq Y\\). Din ideea anterioar\u0103 se ob\u021bine o solu\u021bie mai rapid\u0103 analiz\u00e2nd, pe r\u00e2nd, dou\u0103 cazuri:</p> <ul> <li>Cazul \\(x \\leq y\\) c\u00e2nd parcurgem valorile \\(x = 1, 2, \\dots\\), c\u00e2t timp \\(x \\leq   \\frac{N}{x}\\)</li> <li>Cazul \\(x \\geq y\\) c\u00e2nd parcurgem valorile \\(y = 1, 2, \\dots\\), c\u00e2t timp \\(y \\leq   \\frac{N}{y}\\).</li> </ul> <p>Mai jos pute\u021bi g\u0103si o solu\u021bie care ia punctajul maxim.</p> <pre><code>#include &lt;fstream&gt;\nusing namespace std;\n\nint main() {\n    ifstream cin(\"bomboane.in\");\n    ofstream cout(\"bomboane.out\");\n\n    int c, n, x, y;\n    cin &gt;&gt; c &gt;&gt; n &gt;&gt; x &gt;&gt; y;\n\n    if (c == 1) {\n        cout &lt;&lt; n / x &lt;&lt; '\\n';\n        return 0;\n    }\n\n    if (c == 2) {\n        for (int i = 2; i * i &lt;= n; i++) {\n            if (n % i == 0) {\n                cout &lt;&lt; n / i &lt;&lt; '\\n';\n                return 0;\n            }\n        }\n    }\n\n    if (c == 3) {\n        for (int cnt = n; cnt &gt;= n - 100; cnt--) {\n            for (int i = 1; i * i &lt;= cnt; i++) {\n                if (cnt % i == 0) {\n                    if (cnt / i &gt;= x &amp;&amp; i &gt;= y) {\n                        cout &lt;&lt; n - cnt &lt;&lt; \" \" &lt;&lt; cnt / i &lt;&lt; \" \" &lt;&lt; i &lt;&lt; '\\n';\n                        return 0;\n                    }\n                }\n            }\n            for (int i = 1; i * i &lt;= cnt; i++) {\n                if (cnt % i == 0) {\n                    if (i &gt;= x &amp;&amp; cnt / i &gt;= y) {\n                        cout &lt;&lt; n - cnt &lt;&lt; \" \" &lt;&lt; i &lt;&lt; \" \" &lt;&lt; cnt / i &lt;&lt; '\\n';\n                        return 0;\n                    }\n                }\n            }\n        }\n    }\n    return 0;\n}\n</code></pre>","tags":["OJI","clasa V"]},{"location":"olimpiada/solutii/OJI/2024/V-microbist/","title":"Solu\u021bia problemei Microbist (OJI 2024, clasa a V-a)","text":"<p>Cerin\u021ba 1: Pentru a afla scorul final, vom parcurge \u0219irul de goluri \u0219i vom num\u0103ra c\u00e2te goluri a marcat fiecare echip\u0103. Pentru aceasta putem folosi dou\u0103 variabile contor pe care s\u0103 le actualiz\u0103m \u00een momentul citirii \u00een func\u021bie de echipa care marcheaz\u0103.</p> <p>Cerin\u021ba 2: Pentru a determina c\u00e2te scoruri au fost egale, vom \u021bine eviden\u021ba num\u0103rului de goluri marcate de fiecare echip\u0103, la fel ca mai sus, \u0219i vom incrementa un contor de fiecare dat\u0103 c\u00e2nd scorurile devin egale.</p> <p>Cerin\u021ba 3: Putem determina secven\u021be de elemente egale aflate pe pozi\u021bii consecutive. O astfel de secven\u021b\u0103 este revenire \u00een for\u021b\u0103 dac\u0103 atunci c\u00e2nd ea \u00eencepe, echipa pe care o reprezint\u0103 este condus\u0103 \u0219i atunci c\u00e2nd se termin\u0103 echipa pe care o reprezint\u0103 conduce cu un gol.</p> <p>Detectarea \u0219i calcularea revenirii \u00een for\u021b\u0103 pentru cerin\u021ba 3:</p> <p>Dup\u0103 primul gol, se actualizeaz\u0103 scorul echipei corespunz\u0103toare \u0219i se determin\u0103 echipa care este condus\u0103. Pentru urm\u0103toarele goluri marcate vom \u021bine cont de urm\u0103toarele aspecte:</p> <ul> <li>dac\u0103 golul curent este diferit de cel anterior (marcheaz\u0103 alt\u0103 echip\u0103) atunci   test\u0103m dac\u0103 putem \u00eencepe o nou\u0103 revenire \u00een for\u021b\u0103 \u0219i \u00een caz afirmativ stabilim   contorul de revenire la unu.</li> <li>dac\u0103 golul curent este marcat de aceea\u0219i echip\u0103 ca \u0219i golul anterior atunci   cre\u0219tem contorul pentru revenirea \u00een for\u021b\u0103 \u0219i dac\u0103 s-a schimbat echipa   c\u00e2\u0219tig\u0103toare.</li> </ul> <p>Mai jos pute\u021bi g\u0103si o solu\u021bie care ia punctajul maxim.</p> <pre><code>#include &lt;fstream&gt;\nusing namespace std;\n\nint main() {\n    ifstream cin(\"microbist.in\");\n    ofstream cout(\"microbist.out\");\n\n    int c, n, ga = 0, gb = 0, eq = 1, strk = 0, maxstrk = 0, curr = 0;\n    cin &gt;&gt; c &gt;&gt; n;\n\n    for (int i = 1; i &lt;= n; i++) {\n        int nr;\n        cin &gt;&gt; nr;\n        if (nr == 1) {\n            ga++;\n        } else {\n            gb++;\n        }\n        if (ga == gb) {\n            eq++;\n        }\n        if (i == 1) {\n            strk = 1;\n        } else if (nr == curr) {\n            strk++;\n        } else {\n            strk = 1;\n        }\n        curr = nr;\n        if (curr == 1) {\n            if (ga &gt; gb &amp;&amp; ga - strk &lt; gb &amp;&amp; ga - gb == 1) {\n                maxstrk = max(maxstrk, strk);\n            }\n        } else {\n            if (gb &gt; ga &amp;&amp; gb - strk &lt; ga &amp;&amp; gb - ga == 1) {\n                maxstrk = max(maxstrk, strk);\n            }\n        }\n    }\n    if (c == 1) {\n        cout &lt;&lt; ga &lt;&lt; \" \" &lt;&lt; gb &lt;&lt; '\\n';\n        return 0;\n    }\n\n    if (c == 2) {\n        cout &lt;&lt; eq &lt;&lt; '\\n';\n        return 0;\n    }\n\n    if (c == 3) {\n        cout &lt;&lt; maxstrk &lt;&lt; '\\n';\n    }\n    return 0;\n}\n</code></pre>","tags":["OJI","clasa V"]},{"location":"olimpiada/solutii/OJI/2024/VI-avid/","title":"Solu\u021bia problemei Avid (OJI 2024, clasa a VI-a)","text":"<p>Cerin\u021ba 1: Pentru 12 puncte, se citesc numerele din fi\u0219ierul de intrare \u00eentr-un vector \u0219i num\u0103r\u0103m c\u00e2te triplete respect\u0103 condi\u021bia din enun\u021b. Vom calcula cel mai mare divizor comun al fiec\u0103rui triplet de valori de pe pozi\u021bii consecutive, dup\u0103 care vom calcula num\u0103rul de divizori al acestuia, iar dac\u0103 este mai mic sau egal cu \\(p\\), vom incrementa r\u0103spunsul. Vom folosi algoritmul lui Euclid prin \u00eemp\u0103r\u021biri repetate \u0219i descompunerea \u00een factori primi p\u00e2n\u0103 la radical. Complexitatea este: \\(\\mathcal{O}(n(\\log \\max\\{a_i\\} + \\sqrt{\\max\\{a_i\\}})) = O(n\\sqrt{\\max\\{a_i\\}}).\\)</p> <p>Pentru restul de 17 puncte, vom folosi acela\u0219i procedeu pentru a calcula num\u0103rul de triplete, dar vom calcula mai eficient num\u0103rul de divizori. Vom precalcula numerele prime p\u00e2n\u0103 la \\(5\\,000\\,000 \\approx 2\\,236\\), folosind ciurul lui Eratostene. Astfel, c\u00e2nd vom face descompunerea \u00een factori primi p\u00e2n\u0103 la radicalul num\u0103rului nostru, vom folosi doar numerele prime. Complexitatea este: \\(\\mathcal{O}(n\\sqrt{\\max\\{a_i\\}} + \\sqrt{\\max\\{a_i\\}} \\log \\log \\sqrt{\\max\\{a_i\\}}).\\)</p> <p>Observ\u0103m c\u0103, de\u0219i complexitatea este similar\u0103, algoritmul este mult mai rapid \u00een practic\u0103.</p> <p>Cerin\u021ba 2: Pentru 29 de puncte, se citesc numerele din fi\u0219ierul de intrare \u00eentr-un vector. Parcurgem vectorul \u0219i verific\u0103m dac\u0103 tripletul care se termin\u0103 pe pozi\u021bia curent\u0103 respect\u0103 condi\u021bia din enun\u021b, folosind algoritmul lui Euclid prin \u00eemp\u0103r\u021biri repetate \u0219i descompunerea \u00een factori primi p\u00e2n\u0103 la radical. \u00cen caz afirmativ, increment\u0103m lungimea secven\u021bei curente. Altfel, se \u00eencearc\u0103 actualizarea maximului, doar dac\u0103 lungimea curent\u0103 este cel pu\u021bin 3, \u0219i dup\u0103 se reseteaz\u0103 lungimea secven\u021bei curente la valoarea 2. La finalul parcurgerii se va mai \u00eencerca o dat\u0103 actualizarea maximului, cu aceea\u0219i condi\u021bie ca mai sus, deoarece este posibil ca secven\u021ba curent\u0103 s\u0103 fie maximal\u0103. Complexitatea este: \\(\\mathcal{O}(n(\\log \\max\\{a_i\\} + \\sqrt{\\max\\{a_i\\}})) = O(n\\sqrt{\\max\\{a_i\\}}).\\)</p> <p>Pentru restul de 42 de puncte, se procedeaz\u0103 similar, dar vom calcula mai eficient num\u0103rul de divizori, folosind modul descris \u00een cel de-al doilea paragraf de la descrierea cerin\u021bei 1. Complexitatea este: \\(\\mathcal{O}(n\\sqrt{\\max\\{a_i\\}} + \\sqrt{\\max\\{a_i\\}} \\log \\log \\sqrt{\\max\\{a_i\\}}).\\) Observ\u0103m c\u0103, de\u0219i complexitatea este similar\u0103, algoritmul este mult mai rapid \u00een practic\u0103.</p> <p>Observa\u021bii:</p> <ol> <li>Pentru ambele cerin\u021be putem s\u0103 rezolv\u0103m problema f\u0103r\u0103 a re\u021bine datele citite    \u00eentr-un vector. Totu\u0219i, pentru simplitate \u0219i pentru c\u0103 limita de memorie este    generoas\u0103, nu este nevoie s\u0103 facem acest lucru.</li> <li>Descompunerea \u00een factori primi a lui \\(n\\) (merg\u00e2nd p\u00e2n\u0103 la \\(\\sqrt{n}\\)) este    folosit\u0103 pentru determinarea num\u0103rului s\u0103u de divizori astfel: \\(n = p_1^{e_1}    \\cdot p_2^{e_2} \\cdot \\ldots \\cdot p_k^{e_k},\\) atunci num\u0103rul \\(n\\) are \\((e_1 +    1)(e_2 + 1) \\cdots (e_k + 1)\\) divizori, conform regulii produsului.</li> <li>Pentru solu\u021bia f\u0103r\u0103 ciur, num\u0103rul de divizori al lui \\(n\\) poate fi calculat \u00een    \\(\\mathcal{O}(\\sqrt{n})\\) \u0219i f\u0103r\u0103 formula precedent\u0103. Este suficient s\u0103    parcurgem divizorii lui \\(n\\) cuprin\u0219i \u00eentre 1 \u0219i \\(\\sqrt{n}\\). De fiecare dat\u0103    c\u00e2nd g\u0103sim un divizor \\(d\\), deducem c\u0103 \u0219i \\(\\frac{n}{d}\\) este un divizor al lui    \\(n\\), a\u0219a c\u0103 adun\u0103m 2 la rezultat. Singura excep\u021bie const\u0103 \u00een cazul \u00een care \\(d    = \\frac{n}{d}\\), c\u00e2nd se adun\u0103 doar 1.</li> </ol> <p>Mai jos pute\u021bi g\u0103si o solu\u021bie care ia punctajul maxim.</p> <pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n\nint c, n, p, v[5000002];\nint cntdiv[5000002];\n\nint cmmdc(int a, int b) {\n    while (b &gt; 0) {\n        int c = a % b;\n        a = b;\n        b = c;\n    }\n    return a;\n}\nint main() {\n    ifstream cin(\"avid.in\");\n    ofstream cout(\"avid.out\");\n\n    for (int i = 1; i &lt;= 5000000; i++) {\n        for (int j = i; j &lt;= 5000000; j += i) {\n            cntdiv[j]++;\n        }\n    }\n\n    cin &gt;&gt; c;\n    cin &gt;&gt; n &gt;&gt; p;\n\n    int cnt = 0, strk = 0, maxstrk = 0;\n    for (int i = 1; i &lt;= n; i++) {\n        cin &gt;&gt; v[i];\n    }\n\n    for (int i = 2; i &lt; n; i++) {\n        int x = cmmdc(v[i - 1], cmmdc(v[i], v[i + 1]));\n        if (cntdiv[x] &lt;= p) {\n            cnt++;\n            strk++;\n            if (strk &gt;= maxstrk) {\n                maxstrk = strk;\n            }\n        } else {\n            strk = 0;\n        }\n    }\n    if (c == 1) {\n        cout &lt;&lt; cnt &lt;&lt; '\\n';\n    } else {\n        cout &lt;&lt; maxstrk + 2 &lt;&lt; '\\n';\n    }\n    return 0;\n}\n</code></pre>","tags":["OJI","clasa VI"]},{"location":"olimpiada/solutii/OJI/2024/VI-perechi/","title":"Solu\u021bia problemei Perechi (OJI 2024, clasa a VI-a)","text":"<p>Cerin\u021ba 1: Pentru 27 de puncte, se citesc numerele din fi\u0219ierul de intrare \u00eentr-un vector, se parcurg elementele vectorului, iar pentru fiecare element aflat pe pozi\u021bia \\(i\\), cu \\(1 \\leq i \\leq n - 1\\), se verific\u0103 toate elementele aflate pe pozi\u021biile \\(j\\), cu \\(i + 1 \\leq j \\leq n\\), num\u0103r\u00e2ndu-se toate elementele care sunt egale cu oglinditul lui \\(a_i\\) \u0219i formeaz\u0103 o pereche oglindit\u0103 cu \\(a_i\\). Complexitatea algoritmului este: \\(\\mathcal{O}(n^2)\\).</p> <p>Pentru 50 de puncte, se construie\u0219te un vector de frecven\u021b\u0103 pe baza numerelor citite. Se parcurge vectorul de frecven\u021b\u0103 \u0219i, pentru fiecare valoare \\(x\\) care exist\u0103 \u00een acesta, se calculeaz\u0103 oglinditul lui \\(x\\) \u00een variabila \\(y\\). Dac\u0103 \\(y\\) exist\u0103 \u00een vectorul de frecven\u021b\u0103, este strict mai mare dec\u00e2t \\(x\\) \u0219i formeaz\u0103 o pereche oglindit\u0103 cu \\(x\\), atunci se va aduna la num\u0103rul de perechi produsul dintre frecven\u021ba lui \\(x\\) \u0219i frecven\u021ba lui \\(y\\). Din moment ce \\(n\\) poate fi \\(100\\,000\\), rezultatul poate dep\u0103\u0219i valoarea maxim\u0103 reprezentabil\u0103 pe tipul de date <code>int</code>. Complexitatea algoritmului este: \\(\\mathcal{O}(n + \\text{max})\\), unde \\(\\text{max}\\) este num\u0103rul maxim din \u0219ir.</p> <p>Cerin\u021ba 2: Pentru 27 de puncte, se citesc numerele din fi\u0219ierul de intrare \u00eentr-un vector. Se parcurg elementele vectorului, iar fiecare element aflat pe pozi\u021bia \\(i\\), cu \\(1 \\leq i \\leq n - 1\\), se compune cu toate elementele aflate pe pozi\u021biile \\(j\\), cu \\(i + 1 \\leq j \\leq n\\), verific\u00e2ndu-se dac\u0103 cele dou\u0103 valori rezultate din compunere sunt numere palindrom. Pe parcurs, se re\u021bine valoarea maxim\u0103 ob\u021binut\u0103. Complexitatea algoritmului este: \\(\\mathcal{O}(n^2)\\).</p> <p>Pentru 50 de puncte, se construie\u0219te un vector de frecven\u021b\u0103 pe baza numerelor citite. Se parcurge vectorul de frecven\u021b\u0103 \u0219i, pentru fiecare valoare \\(x\\) care exist\u0103 \u00een acesta, se calculeaz\u0103 oglinditul lui \\(x\\) \u00een variabila \\(y\\).</p> <ul> <li>Dac\u0103 \\(y\\) exist\u0103 \u00een vectorul de frecven\u021b\u0103 \u0219i este diferit de \\(x\\), atunci se     compun cele dou\u0103 numere, rezult\u00e2nd dou\u0103 numere palindrom.</li> <li>Din num\u0103rul \\(y\\) se elimin\u0103 pe r\u00e2nd c\u00e2te o cifr\u0103. Se verific\u0103 dac\u0103 num\u0103rul     rezultat exist\u0103 \u00een vectorul de frecven\u021b\u0103 \u0219i, \u00een caz afirmativ, se alipe\u0219te la     \u00eenceputul num\u0103rului \\(x\\) ini\u021bial.</li> <li>Din num\u0103rul \\(x\\) se elimin\u0103 pe r\u00e2nd c\u00e2te o cifr\u0103. Se verific\u0103 dac\u0103 num\u0103rul     rezultat exist\u0103 \u00een vectorul de frecven\u021b\u0103 \u0219i, \u00een caz afirmativ, se alipe\u0219te la     \u00eenceputul num\u0103rului \\(y\\) ini\u021bial.</li> </ul> <p>Pe parcurs, dintre toate numerele palindrom ob\u021binute \u00een acest proces, se re\u021bine maximul. Complexitatea algoritmului este: \\(\\mathcal{O}(n + \\text{max})\\), unde \\(\\text{max}\\) este num\u0103rul maxim din \u0219ir.</p> <p>Mai jos pute\u021bi g\u0103si o solu\u021bie care ia punctajul maxim.</p> <pre><code>#include &lt;fstream&gt;\n#include &lt;iostream&gt;\nusing namespace std;\n\nint c, n, rev[10002], v[100002], fr[10002], cif[12];\n\nint og(int x) {\n    int ans = 0;\n    while (x &gt; 0) {\n        ans = ans * 10 + x % 10;\n        x /= 10;\n    }\n    return ans;\n}\n\nint merge(int a, int b) {\n    int p10 = 10;\n    while (p10 &lt;= b) {\n        p10 *= 10;\n    }\n    return a * p10 + b;\n}\n\nint main() {\n    ifstream cin(\"perechi.in\");\n    ofstream cout(\"perechi.out\");\n\n    cin &gt;&gt; c;\n    cin &gt;&gt; n;\n\n    for (int i = 1; i &lt;= n; i++) {\n        cin &gt;&gt; v[i], fr[v[i]]++;\n    }\n\n    for (int i = 1; i &lt;= 10000; i++) {\n        rev[i] = og(i);\n    }\n\n    if (c == 1) {\n        long long ans = 0;\n        for (int i = 1; i &lt;= 10000; i++) {\n            if (rev[i] &gt; i) {\n                ans = ans + 1LL * fr[i] * fr[rev[i]];\n            }\n        }\n        cout &lt;&lt; ans &lt;&lt; '\\n';\n    }\n    if (c == 2) {\n        int ans = 0;\n        for (int st = 1; st &lt;= 9999; st++) {       // numarul din stanga\n            for (int mid = -1; mid &lt;= 9; mid++) {  // eventual, cifra din mijloc\n                int val = st;\n                if (mid != -1) {\n                    val = val * 10 + mid;\n                }\n                int cop = st;\n                int cnt = 0;\n                while (cop) {  // numarul din dreapta\n                    cif[cnt++] = cop % 10;\n                    cop /= 10;\n                }\n                for (int i = 0; i &lt; cnt; i++) {\n                    val = val * 10 + cif[i];\n                }\n                int tog = 0;\n                int tval = val;\n                int p10 = 1;\n                while (val) {  // trecem prin cifre sa vedem daca cele doua\n                               // jumatati exista\n                    tog = tog + p10 * (val % 10);\n                    val /= 10;\n                    p10 *= 10;\n                    if (tog &lt;= 10000 &amp;&amp; val &lt;= 10000 &amp;&amp; fr[tog] &amp;&amp; fr[val]\n                        &amp;&amp; merge(val, tog) == tval) {\n                        if (tog == val &amp;&amp; fr[tog] &lt; 2)\n                            ;\n                        else {\n                            ans = max(ans, tval);\n                        }\n                    }\n                }\n            }\n        }\n        cout &lt;&lt; ans &lt;&lt; '\\n';\n    }\n    return 0;\n}\n</code></pre>","tags":["OJI","clasa VI"]},{"location":"olimpiada/solutii/OJI/2024/VII-parking/","title":"Solu\u021bia problemei Parking (OJI 2024, clasa a VII-a)","text":"<p>Vom reprezenta o ma\u0219in\u0103 ca o structur\u0103 (struct) cu 4 c\u00e2mpuri: linia \u0219i coloana pe care se afl\u0103 ma\u0219ina, orientarea ma\u0219inii (0 pentru orizontal, 1 pentru vertical) \u0219i num\u0103rul seriei \u00een care ma\u0219ina a ie\u0219it, respectiv 0 dac\u0103 ma\u0219ina este \u00eenc\u0103 \u00een parcare. Vom re\u021bine ma\u0219inile \u00eentr-un vector \\(vm\\), astfel vom putea identifica \u00een continuare fiecare ma\u0219in\u0103 prin pozi\u021bia sa \u00een vector (un num\u0103r \u00eentre 1 \u0219i \\(q\\)). O ie\u0219ire din parcare o vom identifica prin pozi\u021bia sa (linia \u0219i coloana pe care se afl\u0103). Vom re\u021bine ie\u0219irile \u00eentr-un vector \\(vi\\). Pentru a identifica ma\u0219inile care pot ie\u0219i din parcare putem parcurge vectorul de ma\u0219ini \u0219i pentru fiecare ma\u0219in\u0103 verific\u0103m dac\u0103 poate ie\u0219i din parcare \u00een seria curent\u0103 (ajunge la o ie\u0219ire deplas\u00e2ndu-se \u00een una dintre cele dou\u0103 direc\u021bii de mi\u0219care posibile) \u0219i dac\u0103 da, o re\u021binem \u00een seria curent\u0103. O astfel de abordare ob\u021bine un punctaj substan\u021bial, dar pe testele mari va ob\u021bine dep\u0103\u0219ire de timp, datorit\u0103 num\u0103rului mare de ma\u0219ini, complexitatea fiind \\(\\mathcal{O}(q \\cdot nr_{serii})\\).</p> <p>O abordare mai eficient\u0103 ar fi s\u0103 parcurgem ie\u0219irile \u0219i s\u0103 verific\u0103m, pentru fiecare ie\u0219ire, dac\u0103 exist\u0103 o ma\u0219in\u0103 care poate ie\u0219i \u00een seria curent\u0103 utiliz\u00e2nd ie\u0219irea respectiv\u0103. Apar 4 cazuri:</p> <ol> <li>dac\u0103 ie\u0219irea se afl\u0103 pe coloana 0, aceast\u0103 ie\u0219ire poate fi utilizat\u0103 doar de    prima ma\u0219in\u0103 de pe linia pe care se afl\u0103 ie\u0219irea (dac\u0103 aceasta este    pozi\u021bionat\u0103 orizontal);</li> <li>dac\u0103 ie\u0219irea se afl\u0103 pe coloana \\(m + 1\\), aceast\u0103 ie\u0219ire poate fi utilizat\u0103    doar de ultima ma\u0219in\u0103 de pe linia pe care se afl\u0103 ie\u0219irea (dac\u0103 aceasta este    pozi\u021bionat\u0103 orizontal);</li> <li>dac\u0103 ie\u0219irea se afl\u0103 pe linia 0, aceast\u0103 ie\u0219ire poate fi utilizat\u0103 doar de    prima ma\u0219in\u0103 de pe coloana pe care se afl\u0103 ie\u0219irea (dac\u0103 aceasta este    pozi\u021bionat\u0103 vertical);</li> <li>dac\u0103 ie\u0219irea se afl\u0103 pe linia \\(n +1\\), aceast\u0103 ie\u0219ire poate fi utilizat\u0103 doar    de ultima ma\u0219in\u0103 de pe coloana pe care se afl\u0103 ie\u0219irea (dac\u0103 aceasta este    pozi\u021bionat\u0103 vertical).</li> </ol> <p>C\u00e2nd analiz\u0103m cazurile \\((1)\\) \u0219i \\((2)\\), respectiv \\((3)\\) \u0219i \\((4)\\) trebuie s\u0103 avem grij\u0103 la situa\u021bia \u00een care exist\u0103 o singur\u0103 ma\u0219in\u0103 pe linie, respectiv pe coloan\u0103, situa\u021bie \u00een care aceast\u0103 ma\u0219in\u0103 este at\u00e2t prima, c\u00e2t \u0219i ultima (deci trebuie s\u0103 evit\u0103m s\u0103 scoatem din parcare aceea\u0219i ma\u0219in\u0103 de dou\u0103 ori \u0219i s\u0103 contoriz\u0103m eronat ma\u0219inile care ies din parcare).</p> <p>Pentru a trata simplu \u0219i eficient cele 4 cazuri vom construi dou\u0103 matrici auxiliare \\(ml\\) \u0219i \\(mc\\), av\u00e2nd \\(n\\) linii \u0219i \\(m\\) coloane, respectiv \\(m\\) linii \u0219i \\(n\\) coloane. Pe linia \\(i (1 \\leq i \\leq n)\\) \u00een matricea \\(ml\\) se afl\u0103 lista ma\u0219inilor de pe linia \\(i\\) a parc\u0103rii, sortate cresc\u0103tor dup\u0103 coloan\u0103. Pe linia \\(j (1 \\leq j \\leq m)\\) a matricii \\(mc\\) se afl\u0103 lista ma\u0219inilor de pe coloana \\(j\\) a parc\u0103rii, sortate cresc\u0103tor dup\u0103 linie. Ca urmare pentru ie\u0219irile de pe coloana 0 verific\u0103m doar prima ma\u0219in\u0103 de pe linia corespunz\u0103toare din \\(ml\\), pentru ie\u0219irile de pe coloana \\(m + 1\\) doar ultima ma\u0219in\u0103 de pe linia corespunz\u0103toare din \\(ml\\). Similar, pentru ie\u0219irile de pe linia 0 verific\u0103m doar prima ma\u0219in\u0103 de pe coloana corespunz\u0103toare din \\(mc\\), iar pentru ie\u0219irile de pe linia \\(n + 1\\), doar ultima ma\u0219in\u0103 de pe coloana corespunz\u0103toare din \\(mc\\).</p> <p>Pentru cerin\u021ba 1 efectu\u0103m ie\u0219irea ma\u0219inilor din prima serie. Pentru cerin\u021ba 2 vom efectua ie\u0219irea ma\u0219inilor \u00een serii succesive, p\u00e2n\u0103 c\u00e2nd \u00een seria curent\u0103 nu mai iese nicio ma\u0219in\u0103 din parcare. Pentru ie\u0219irea ma\u0219inilor dintr-o serie vom proceda \u00een dou\u0103 etape:</p> <ol> <li>Parcurgem ie\u0219irile \u0219i identific\u0103m ma\u0219inile care pot ie\u0219i \u00een seria curent\u0103,    re\u021bin\u00e2nd aceste ma\u0219ini \u00eentr-un vector \u0219i memor\u00e2nd \u00een structura care    reprezint\u0103 ma\u0219ina num\u0103rul seriei curente.</li> <li>Parcurgem vectorul care con\u021bine ma\u0219inile care pot ie\u0219i \u00een seria curent\u0103 \u0219i    elimin\u0103m aceste ma\u0219ini din matricile \\(ml\\) \u0219i \\(mc\\).</li> </ol> <p>Este obligatorie ie\u0219irea ma\u0219inilor dintr-o serie \u00een dou\u0103 etape, \u00een alt mod nu putem simula simultaneitatea ie\u0219irii ma\u0219inilor din parcare. Dac\u0103 vom elimina ma\u0219inile succesiv pe m\u0103sur\u0103 ce identific\u0103m c\u0103 pot ie\u0219i, este posibil s\u0103 ias\u0103 din parcare \u00een seria curent\u0103 ma\u0219ini care nu ar fi trebuit s\u0103 ias\u0103 (de exemplu ma\u0219ina \\(a\\) poate ie\u0219i din parcare \u00een seria curent\u0103; ma\u0219ina \\(a\\) blocheaz\u0103 ma\u0219ina \\(b\\); dac\u0103 elimin\u0103m imediat ma\u0219ina \\(a\\), atunci c\u00e2nd ajungem la ma\u0219ina \\(b\\) aceasta nu va mai fi blocat\u0103 \u0219i va ie\u0219i \u0219i ea \u00een aceea\u0219i serie cu \\(a\\), ceea ce este evident incorect).</p> <p>Complexitatea algoritmului: pentru fiecare serie, \u00een etapa 1 se parcurg toate ie\u0219irile pentru a identifica ma\u0219inile \\((O(K))\\), iar \u00een etapa 2 trebuie s\u0103 elimin\u0103m ma\u0219inile care ies \u00een seria curent\u0103 din \\(ml\\) \u0219i \\(mc\\) (din una dintre matrici se poate elimina \u00een \\(\\mathcal{O}(1)\\), dar pentru cealalt\u0103 matrice este necesar\u0103 o c\u0103utare secven\u021bial\u0103 a ma\u0219inii urmat\u0103 de eliminarea acesteia, deci complexitatea va fi \\(\\mathcal{O}(lg)\\), unde cu \\(lg\\) not\u0103m num\u0103rul de ma\u0219ini existente pe linia/coloana respectiv\u0103 (deci putem spune c\u0103, \u00een cazul cel mai defavorabil, eliminarea unei ma\u0219ini din \\(ml\\), respectiv \\(mc\\) se realizeaz\u0103 \u00een timp liniar \u00een func\u021bie de \\(n\\), respectiv de \\(m\\)).</p> <p>Exist\u0103 algoritmi mai eficien\u021bi de rezolvare a acestei probleme, dar necesit\u0103 cuno\u0219tin\u021be care dep\u0103\u0219esc programa clasei a VII-a.</p> <p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n\nint c, n, m, k, q;\nint mat[1002][1002];\nset&lt;int&gt; wallsL[1002], wallsC[1002];\n\nvoid insert(int L, int C) {\n    wallsL[L].insert(C);\n    wallsC[C].insert(L);\n}\nint main() {\n    ifstream cin(\"parking.in\");\n    ofstream cout(\"parking.out\");\n\n    cin &gt;&gt; c &gt;&gt; n &gt;&gt; m &gt;&gt; k &gt;&gt; q;\n    for (int i = 1; i &lt;= k; i++) {\n        int L, C;\n        cin &gt;&gt; L &gt;&gt; C;\n        mat[L][C] = -1;\n    }\n    for (int i = 0; i &lt;= m + 1; i++) {\n        if (mat[0][i] != -1) {\n            insert(0, i);\n        }\n        if (mat[n + 1][i] != -1) {\n            insert(n + 1, i);\n        }\n    }\n    for (int i = 0; i &lt;= n + 1; i++) {\n        if (mat[i][0] != -1) {\n            insert(i, 0);\n        }\n        if (mat[i][m + 1] != -1) {\n            insert(i, m + 1);\n        }\n    }\n    for (int i = 1; i &lt;= q; i++) {\n        int x, y, p;\n        cin &gt;&gt; x &gt;&gt; y &gt;&gt; p;\n        mat[x][y] = p + 1;\n        insert(x, y);\n    }\n\n    int cnt = 0;\n    int tot = 0;\n    for (int stp = 1; stp &lt;= 10000; stp++) {\n        deque&lt;pair&lt;int, int&gt; &gt; d;\n        for (int i = 1; i &lt;= n; i++) {\n            int of = -1;\n            for (int xx = 1; xx &lt;= 2; xx++) {\n                if (wallsL[i].empty()) {\n                    continue;\n                }\n                set&lt;int&gt;::iterator x;\n                if (xx == 1) {\n                    x = wallsL[i].begin();\n                } else {\n                    x = wallsL[i].end(), x--;\n                }\n                int poz = *x;\n                if (poz != 0 &amp;&amp; poz != m + 1 &amp;&amp; mat[i][poz] == 1) {\n                    tot = stp;\n                    if (of != poz) {\n                        d.push_back({i, poz});\n                        of = poz;\n                    }\n                }\n            }\n        }\n        for (int i = 1; i &lt;= m; i++) {\n            int of = -1;\n            for (int xx = 1; xx &lt;= 2; xx++) {\n                if (wallsC[i].empty()) {\n                    continue;\n                }\n                set&lt;int&gt;::iterator x;\n                if (xx == 1) {\n                    x = wallsC[i].begin();\n                } else {\n                    x = wallsC[i].end(), x--;\n                }\n                int poz = *x;\n                if (poz != 0 &amp;&amp; poz != n + 1 &amp;&amp; mat[poz][i] == 2) {\n                    tot = stp;\n                    if (of != poz) {\n                        d.push_back({poz, i});\n                        of = poz;\n                    }\n                }\n            }\n        }\n        if (tot != stp) {\n            break;\n        }\n        for (auto x : d) {\n            cnt++;\n            wallsL[x.first].erase(x.second);\n            wallsC[x.second].erase(x.first);\n        }\n        if (c == 1) {\n            break;\n        }\n    }\n    cout &lt;&lt; cnt &lt;&lt; \" \";\n    if (c == 2) {\n        cout &lt;&lt; tot &lt;&lt; '\\n';\n    }\n    return 0;\n}\n</code></pre>","tags":["OJI","clasa VII"]},{"location":"olimpiada/solutii/OJI/2024/VII-ron/","title":"Solu\u021bia problemei Ron (OJI 2024, clasa a VII-a)","text":"<p>Observa\u021bie ini\u021bial\u0103: O creang\u0103 de lungime \\(lg\\) a\u0219ezat\u0103 pe rigl\u0103 cu cap\u0103tul din st\u00e2nga \u00een dreptul num\u0103rului \\(poz\\) reprezint\u0103, din punct de vedere matematic, intervalul \\([poz, poz + lg \u2212 1]\\).</p> <p>Cerin\u021ba 1: Pentru rezolvarea cerin\u021bei 1, este necesar s\u0103 determin\u0103m num\u0103rul maxim de numere fermecate aflate \u00een unul dintre intervalele corespunz\u0103toare crengilor de soc. Matematic, num\u0103rul p\u0103tratelor numerelor prime dintr-un interval \\([x, y]\\) este egal cu num\u0103rul numerelor prime din intervalul \\([\\sqrt x, \\sqrt y]\\) Vom utiliza Ciurul lui Eratostene pentru a determina numerele prime mai mici sau egale cu \\(\\sqrt{2 \\cdot 10^9}\\), apoi vom construi un vector auxiliar \\(a\\) \u00een care vom memora pentru fiecare num\u0103r natural \\(x\\), num\u0103rul numerelor prime mai mici sau egale cu \\(x\\). Num\u0103rul p\u0103tratelor numerelor prime din intervalul \\([x, y]\\) este \\(a \\lfloor \\sqrt y \\rfloor - a \\lfloor \\sqrt {x-1} \\rfloor\\).</p> <p>Vom citi succesiv descrierea fiec\u0103rei crengi de soc, vom determina num\u0103rul numerelor fermecate acoperite de fiecare creang\u0103 \u0219i vom re\u021bine maximul.</p> <p>Cerin\u021ba 2: Pentru rezolvarea cerin\u021bei 2 este necesar s\u0103 determin\u0103m num\u0103rul de intervale ob\u021binute \u00een urma reuniunii celor \\(n\\) intervale corespunz\u0103toare crengilor de soc. Vom ordona intervalele cresc\u0103tor dup\u0103 extremitatea ini\u021bial\u0103 (cap\u0103tul din st\u00e2nga). Vom parcurge intervalele \u00een ordine \u0219i vom reuni toate intervalele care pot fi reunite \u00een unul singur (s\u0103 numim rezultatul reuniunii interval-reuniune). La fiecare pas compar\u0103m cap\u0103tul din st\u00e2nga al intervalului curent (\\(st_i\\)) cu cap\u0103tul din dreapta al intervalului-reuniune curent (s\u0103-l not\u0103m \\(dr_R\\)). Dac\u0103 \\(st_i \\leq 1 + dr_R\\) (cele dou\u0103 crengi se suprapun sau se ating) atunci intervalul curent poate fi ad\u0103ugat la intervalul-reuniune curent (adic\u0103 \\(dr_R = dr_i\\), dac\u0103 \\(dr_i &gt; dr_R\\)). \u00cen caz contrar, intervalul-reuniune curent nu mai poate fi extins, ca urmare cre\u0103m un nou interval-reuniune, pe care \u00eel ini\u021bializ\u0103m cu intervalul curent.</p> <p>Problema admite numeroase abord\u0103ri pentru punctaje par\u021biale. De exemplu, pentru valorile mici ale lui \\(poz\\) \u0219i \\(lg\\) se poate utiliza un vector caracteristic \u00een care vor fi marcate cu 1 pozi\u021biile ocupate de crengile de soc, problema reduc\u00e2ndu-se astfel la determinarea num\u0103rului de secven\u021be formate numai din 1.</p> <p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n\nint c, n;\nbool pr[45002];\nint cnt, poz, pp[45002];\n\nint cb(int x) {\n    int st = 1;\n    int dr = cnt;\n    int ans = 0;\n    while (st &lt;= dr) {\n        int mid = (st + dr) / 2;\n        if (pp[mid] &lt;= x) {\n            ans = mid;\n            st = mid + 1;\n        } else {\n            dr = mid - 1;\n        }\n    }\n    return ans;\n}\nint main() {\n    ifstream cin(\"ron.in\");\n    ofstream cout(\"ron.out\");\n\n    cin &gt;&gt; c &gt;&gt; n;\n    vector&lt;pair&lt;int, int&gt; &gt; v(n);\n\n    for (int i = 0; i &lt; n; i++) {\n        cin &gt;&gt; v[i].first &gt;&gt; v[i].second;\n    }\n    for (int i = 2; i &lt;= 45000; i++) {\n        if (pr[i] == 0) {\n            pp[++cnt] = i * i;\n            for (int j = i + i; j &lt;= 45000; j += i) {\n                pr[j] = 1;\n            }\n        }\n    }\n\n    if (c == 1) {\n        int maxi = 0;\n        for (int i = 0; i &lt; n; i++) {\n            maxi = max(maxi,\n                       cb(v[i].first + v[i].second - 1) - cb(v[i].first - 1));\n        }\n        cout &lt;&lt; maxi &lt;&lt; '\\n';\n    }\n    if (c == 2) {\n        sort(v.begin(), v.end());\n        int cnt = 1, lpoz = -1;\n        for (int i = 0; i &lt; n; i++) {\n            if (i == 0) {\n                lpoz = v[i].first + v[i].second;\n            } else {\n                if (lpoz &lt; v[i].first) {\n                    cnt++;\n                    lpoz = v[i].first + v[i].second;\n                } else {\n                    lpoz = max(lpoz, v[i].first + v[i].second);\n                }\n            }\n        }\n        cout &lt;&lt; cnt &lt;&lt; '\\n';\n    }\n    return 0;\n}\n</code></pre>","tags":["OJI","clasa VII"]},{"location":"olimpiada/solutii/OJI/2024/VIII-mun/","title":"Solu\u021bia problemei Mun (OJI 2024, clasa a VIII-a)","text":"<p>Cerin\u021ba 1: Solu\u021bia \u00een complexitate \\(\\mathcal{O}(N \\log N)\\) ob\u021bine punctaj maxim, adic\u0103 40 de puncte. Se determin\u0103 pentru fiecare cod, codul ordonat cresc\u0103tor; se ordoneaz\u0103 delega\u021bii cresc\u0103tor dup\u0103 codul ordonat, dac\u0103 doi delega\u021bi de pe pozi\u021bii consecutive au codul ordonat diferit, se incrementeaz\u0103 num\u0103rul de \u021b\u0103ri. Deoarece valoarea lui \\(N\\) nu este foarte mare, exist\u0103 \u0219i alte abord\u0103ri mai pu\u021bin eficiente care \u00een func\u021bie de implementare pot ob\u021bine punctajul maxim. \u00cen cazul testelor cu \\(N \\leq 1000\\) \u0219i codurile formate dintr-un singur caracter, o solu\u021bie care utilizeaz\u0103 vector de apari\u021bii pentru caractere, corect implementat\u0103, va ob\u021bine 30 de puncte.</p> <p>Cerin\u021ba 2: Solu\u021bia \u00een complexitate \\(\\mathcal{O}(N)\\) ob\u021bine punctaj maxim, adic\u0103 30 de puncte. Se determin\u0103 \u00een \\(mx_{freq}\\), frecven\u021ba elementului majoritar (\u021bara gazd\u0103) utiliz\u00e2nd un algoritm liniar, pe vectorul ordonat ob\u021binut la cerin\u021ba 1, se calculeaz\u0103 lungimea maxim\u0103 a unei secven\u021be care are codurile ordonate cresc\u0103tor egale (sunt mai multe abord\u0103ri, se poate utiliza \u0219i algoritmul clasic de determinare a elementului majoritar). Valoarea afi\u0219at\u0103 pentru \\(S\\) este \\(N \u2212 2 \\cdot (N \u2212 mx_{freq})\\). Valoarea afi\u0219at\u0103 pentru \\(V\\) va fi \\(2 \\cdot (N \u2212 mx_{freq})\\)</p> <p>Cerin\u021ba 3. Solu\u021bia \u00een complexitate \\(\\mathcal{O}(N \\log N)\\) ob\u021bine punctaj maxim, adic\u0103 30 de puncte. Se vor construi doi vectori de coduri: codurile delega\u021bilor care fac parte din \u021bara gazd\u0103 \\((hosts[])\\) \u0219i codurile celorlal\u021bi delega\u021bi \\((rest[])\\); se vor ordona lexicografic, se va afi\u0219a un cod dintr-o mul\u021bime \u0219i unul din cealalt\u0103 mul\u021bime conform ordinii lexicografice, av\u00e2nd grij\u0103 s\u0103 nu se dep\u0103\u0219easc\u0103 num\u0103rul de persoane de la masa rotund\u0103. O solu\u021bie care determin\u0103 ordinea lexicografic\u0103 \u00een complexitate \\(\\mathcal{O}(N^2)\\) poate ob\u021bine \u00een func\u021bie de implementare 70 - 80 de puncte.</p> <p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n\nstring inv(string s) {\n    for (int i = 0; i &lt; (int)s.size(); i++) {\n        int poz = 25 - (s[i] - 'A');\n        s[i] = 'A' + poz;\n    }\n    return s;\n}\nint main() {\n    ifstream cin(\"mun.in\");\n    ofstream cout(\"mun.out\");\n\n    int c, n;\n    cin &gt;&gt; c &gt;&gt; n;\n\n    map&lt;int, int&gt; s;\n    vector&lt;string&gt; v(n + 1);\n    for (int i = 1; i &lt;= n; i++) {\n        cin &gt;&gt; v[i];\n    }\n    sort(v.begin() + 1, v.begin() + n + 1, greater&lt;string&gt;());\n    unordered_map&lt;int, vector&lt;string&gt;&gt; s2;\n    for (int i = 1; i &lt;= n; i++) {\n        int msk = 0;\n        for (int j = 0; j &lt; (int)v[i].size(); j++) {\n            msk ^= (1 &lt;&lt; (v[i][j] - 'A'));\n        }\n        s[msk]++;\n        s2[msk].push_back(v[i]);\n    }\n    if (c == 1) {\n        cout &lt;&lt; s.size() &lt;&lt; '\\n';\n        return 0;\n    }\n    multiset&lt;int&gt; st;\n    for (auto x : s) {\n        st.insert(x.second);\n    }\n    int cnt = 0;\n    int prv = 0;\n    while (st.size() + (prv != 0) &gt; 1) {\n        int x = *st.rbegin();\n        st.erase(st.lower_bound(x));\n        cnt++;\n        x--;\n        if (prv != 0) {\n            st.insert(prv), prv = 0;\n        }\n        prv = x;\n    }\n    if (c == 2) {\n        cout &lt;&lt; n - cnt &lt;&lt; \" \" &lt;&lt; cnt &lt;&lt; '\\n';\n        return 0;\n    }\n    if (c == 3) {\n        int prv = -1;\n        int rem = cnt;\n        vector&lt;string&gt; vv;\n        set&lt;pair&lt;string, int&gt;&gt; ss;\n        for (auto x : s2) {\n            if (prv == -1) {\n                prv = x.first;\n            } else if (x.second.size() &gt; s2[prv].size()) {\n                prv = x.first;\n            }\n        }\n        vv = s2[prv];\n        for (auto x : s2) {\n            if (x.first != prv) {\n                ss.insert({x.second.back(), x.first});\n            }\n        }\n        prv = -1;\n        while (rem) {\n            if (prv != -2\n                &amp;&amp; ((vv.size() &gt;= (rem / 2 + rem % 2) &amp;&amp; rem % 2 == 1)\n                    || ss.empty() || vv.back() &lt; (*ss.begin()).first)) {\n                cout &lt;&lt; vv.back() &lt;&lt; \" \";\n                if (prv &gt; 0 &amp;&amp; s2[prv].size()) {\n                    ss.insert({s2[prv].back(), prv});\n                }\n                prv = -2;\n                vv.pop_back();\n            } else {\n                pair&lt;string, int&gt; px = *ss.begin();\n                ss.erase(px);\n                cout &lt;&lt; px.first &lt;&lt; \" \";\n                s2[px.second].pop_back();\n                if (prv &gt; 0 &amp;&amp; s2[prv].size()) {\n                    ss.insert({s2[prv].back(), prv});\n                }\n                prv = px.second;\n            }\n            rem--;\n        }\n    }\n    return 0;\n}\n</code></pre>","tags":["OJI","clasa VIII"]},{"location":"olimpiada/solutii/OJI/2024/VIII-robotron/","title":"Solu\u021bia problemei Robotron (OJI 2024, clasa a VIII-a)","text":"<p>Cerin\u021ba 1: Pentru determinarea valorilor \\(M\\) \u0219i \\(H\\), vom folosi un vector de frecven\u021b\u0103. Pentru fiecare ecuson, determin\u0103m echipa din care face parte, lu\u00e2nd ultimele dou\u0103 cifre din acesta. \\(M\\) va fi egal cu num\u0103rul de pozi\u021bii din vectorul de frecven\u021ba pentru care valoarea este diferit\u0103 de 0, iar \\(H\\) va fi pozi\u021bia din vector pentru care frecven\u021ba are valoarea maxim\u0103.</p> <p>Cerin\u021ba 2: Pentru fiecare echip\u0103, precalcul\u0103m sume par\u021biale. Pentru o anumit\u0103 echipa \\(i\\), avem \\(s[j]\\) \u2013 suma elementelor aflate pe pozi\u021biile \\(1, 2, \\dots, j\\). \u00cen aceast\u0103 problema, \\(s[j]\\) reprezint\u0103 pozi\u021bia pe care se va afla pionul dup\u0103 ce va mut\u0103 al \\(j\\)-lea juc\u0103tor. La calcularea sumelor, trebuie s\u0103 \u021binem cont de faptul c\u0103 ordinea juc\u0103torilor se permuta circular. Juc\u0103torul care ini\u021bial este al \\(j\\)-lea \u00een echipa, va fi \u00een runda \\(k\\) pe pozi\u021bia \\((j + (k \u2212 1) \\ mod \\ cnt) \\ mod \\ cnt\\), unde \\(cnt\\) este num\u0103rul total de membrii din echipa. Pentru fiecare echip\u0103, simul\u0103m parcurgerea. Av\u00e2nd sumele par\u021biale calculate, putem determina de c\u00e2te ori mut\u0103 toat\u0103 echipa p\u00e2n\u0103 c\u00e2nd jocul ar fi c\u00e2\u0219tigat de echipa respectiv\u0103. Pentru ultima secven\u021b\u0103 de mut\u0103ri, vom caut\u0103 secven\u021bial care este juc\u0103torul care va aduce victoria echipei sale. Dintre toate aceste simul\u0103ri, re\u021binem care este echipa care va face cele mai pu\u021bine mut\u0103ri, \u0219i juc\u0103torul care aduce victoria echipei sale \u00een acest caz. \u00cen cazul \u00een care exist\u0103 mai multe echipe care au num\u0103r egal de mut\u0103ri minime pentru a trece de c\u0103su\u021ba de start, se va selecta prima dintre ele, deoarece echipele mut\u0103 \u00een ordinea codului planetei lor.</p> <p>Men\u021bion\u0103m c\u0103 exist\u0103 implement\u0103ri \u00een care simul\u0103m fiecare mutare. Pentru toate echipele, determin\u0103m juc\u0103torul care mut\u0103 pionul. Vom men\u021bine pentru fiecare echip\u0103 pozi\u021bia pionului pe tabl\u0103, \u0219i aceasta se va actualiza dup\u0103 fiecare mutare. Repet\u0103m aceast\u0103 simulare, p\u00e2n\u0103 c\u00e2nd un juc\u0103tor trece de c\u0103su\u021ba de start, moment \u00een care se termin\u0103 jocul. Acest algoritm ar trebui s\u0103 ob\u021bin\u0103, \u00een func\u021bie de implementare, aproximativ 60 de puncte.</p> <p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n\nint main() {\n    ifstream cin(\"robotron.in\");\n    ofstream cout(\"robotron.out\");\n\n    int c, n, l, k;\n    cin &gt;&gt; c &gt;&gt; n &gt;&gt; l &gt;&gt; k;\n\n    vector&lt;vector&lt;pair&lt;int, int&gt;&gt;&gt; v(100);\n    for (int i = 0; i &lt; n; i++) {\n        int e, p;\n        cin &gt;&gt; e &gt;&gt; p;\n        v[e % 100].push_back({e / 100, p});\n    }\n\n    if (c == 1) {\n        int mx = 0;\n        int cnt = 0;\n        for (int i = 0; i &lt;= 99; i++) {\n            if (v[i].size() &gt; 0) {\n                cnt++;\n                if (v[i].size() &gt; v[mx].size()) {\n                    mx = i;\n                }\n            }\n        }\n        cout &lt;&lt; cnt &lt;&lt; \" \" &lt;&lt; mx &lt;&lt; '\\n';\n        return 0;\n    }\n    if (c == 2) {\n        k--;\n        int winner = -1;\n        int rounds = (1 &lt;&lt; 30);\n        int code = -1;\n        for (int i = 0; i &lt;= 99; i++) {\n            if (!v[i].size()) {\n                continue;\n            }\n            vector&lt;pair&lt;int, int&gt;&gt; pv;\n            for (int j = k % v[i].size(); j &lt; v[i].size(); j++) {\n                pv.push_back(v[i][j]);\n            }\n            for (int j = 0; j &lt; k % v[i].size(); j++) {\n                pv.push_back(v[i][j]);\n            }\n            long long sum = 0;\n            for (auto x : pv) {\n                sum += x.second;\n            }\n            int temp_rounds = pv.size() * (l / sum);\n            int rem = l % sum;\n            int whoo = 0;\n            if (rem != 0) {\n                for (auto x : pv) {\n                    rem -= x.second;\n                    temp_rounds++;\n                    whoo = x.first;\n                    if (rem &lt;= 0) {\n                        break;\n                    }\n                }\n            } else {\n                whoo = pv.back().first;\n            }\n            if (temp_rounds &lt; rounds) {\n                rounds = temp_rounds;\n                winner = i;\n                code = whoo;\n            }\n        }\n        cout &lt;&lt; winner &lt;&lt; \" \" &lt;&lt; code &lt;&lt; '\\n';\n    }\n    return 0;\n}\n</code></pre>","tags":["OJI","clasa VIII"]},{"location":"olimpiada/solutii/OJI/2024/X-aprogressive/","title":"Solu\u021bia problemei Aprogressive (OJI 2024, clasa a X-a)","text":"","tags":["OJI","clasa X"]},{"location":"olimpiada/solutii/OJI/2024/X-aprogressive/#cerinta-1","title":"Cerin\u021ba 1","text":"<p>Pentru fiecare linie a matricei \\(T\\) se calculeaz\u0103 suma pe linie prin adunarea elementelor aflate pe aceasta. Sumele ob\u021binute pentru fiecare dintre liniile acestei matrice formeaz\u0103 termenii unui \u0219ir, numit \u0219irul sumelor pe linii \\(S_i\\) cu \\(1 \\leq i \\leq n\\). Se determin\u0103 pentru \u0219irul \\(S\\) valoarea maxim\u0103. La final, se afiseaz\u0103 \u00een ordine strict cresc\u0103toare indicii liniilor matricei pentru care suma \\(S_i\\) este maxim\u0103.</p>","tags":["OJI","clasa X"]},{"location":"olimpiada/solutii/OJI/2024/X-aprogressive/#cerinta-2","title":"Cerin\u021ba 2","text":"<p>Vom privi linia unei matrici ca un \u0219ir (vector) cu \\(m\\) elemente. Cum verific\u0103m dac\u0103 elementele \u0219irului pot fi reanjate astfel \u00eenc\u00e2t s\u0103 formeze o progresie aritmetic\u0103?</p> <ul> <li> <p>Solu\u021bia 1, brute-force \\(\\mathcal{O}(m^2)\\) - Se determin\u0103 cele mai mici dou\u0103   elemente din \u0219ir \\(Min_1\\), respectiv \\(Min_2\\), cu \\(Min_1 \\leq Min_2\\). Dac\u0103 \u0219irul   poate fi rearanjat pentru a forma o progresie aritmetic\u0103, atunci ra\u021bia   progresiei este \\(r = Min_2 \u2212 Min_1\\). Dac\u0103 ra\u021bia este nenul\u0103, atunci se caut\u0103 a   treia cea ma mic\u0103 valoare, a patra cea mai mic\u0103, \u0219i a\u0219a mai departe. Pentru   cea mai mic\u0103 a \\(i\\)-a valoare din \u0219ir se verific\u0103 dac\u0103 diferen\u021ba \u00eentre valoarea   minim\u0103 curent\u0103 \u0219i valoarea minim\u0103 determinat\u0103 anterior este egal\u0103 cu ra\u021bia. \u00cen   caz contrar, \u0219irul nu poate fi reanjat astfel \u00eenc\u00e2t s\u0103 formeze o progresie   aritmetic\u0103.</p> </li> <li> <p>Solu\u021bia 2, \\(\\mathcal{O}(m \\log m)\\) - Se sorteaz\u0103 elementele \u0219irului cresc\u0103tor.   Ra\u021bia progresiei este dat\u0103 de diferen\u021ba dintre al doilea element \u0219i primul   element al \u0219irului sortat. Se verific\u0103 dac\u0103 diferen\u021bele dintre elementele   consecutive din \u0219ir se p\u0103streaz\u0103 \u0219i este egal\u0103 cu ra\u021bia. \u00cen func\u021bie de metoda   de sortare folosit\u0103 se pot ob\u021bine punctaje diferite. Se afiseaz\u0103 \u00een ordine   strict cresc\u0103toare indicii liniilor matricei pentru care elementele pot fi   rearanjate astfel \u00eenc\u00e2t s\u0103 formeze pe linia respectiv\u0103 o progresie aritmetic\u0103   de ra\u021bie nenul\u0103.</p> </li> <li> <p>Solu\u021bia 3, \\(\\mathcal{O}(m)\\) - Se determin\u0103 cele mai mici dou\u0103 elemente din \u0219ir   \\(Min_1\\), respectiv \\(Min_2\\), cu \\(Min_1 \\leq Min_2\\). Calcul\u0103m ra\u021bia progresiei   \\(r = Min_2 \u2212 Min_1\\). Se scade din toate elementele \u0219irului valoarea \\(Min_1\\).   Acum ar trebui ca toate elementele ob\u021binute s\u0103 se se divid\u0103 cu ra\u021bia \\(r\\), caz   \u00een care vom simplifica fiecare element cu \\(r\\). Se ob\u021bine prin simplificare un   \u0219ir cu valori distincte din mul\u021bimea \\(\\{0, \\dots, m\u22121\\}\\) pentru a putea fi   reanjat s\u0103 formeze o progresie aritmetic\u0103. Putem verifica aceast\u0103 condi\u021bie   folosind un vector de apari\u021bii.</p> </li> </ul>","tags":["OJI","clasa X"]},{"location":"olimpiada/solutii/OJI/2024/X-aprogressive/#cerinta-3","title":"Cerin\u021ba 3","text":"<p>Pentru \u00eemp\u0103r\u021birea \u00een submatrici se folose\u0219te un algoritm recursiv (divide et impera). Fie submatricea \\(R\\) cu col\u021bul st\u00e2nga-sus \\((x_1, y_1)\\) \u0219i col\u021bul dreapta-jos \\((x_2, y_2)\\).</p> <ul> <li>Submatricea \\(A\\) are col\u021bul st\u00e2nga-sus \u00een \\((x_1, y_1)\\), iar col\u021bul dreapta-jos   \u00een \\(((x_1 + x_2)/2, (y_1 + y_2)/2)\\).</li> <li>Submatricea \\(B\\) are col\u021bul st\u00e2nga-sus \u00een \\((x_1, (y_1 + y_2)/2 + 1)\\), iar   col\u021bul dreapta-jos \u00een \\(((x_1 + x_2)/2, y_2)\\).</li> <li>Submatricea \\(C\\) are col\u021bul st\u00e2nga-sus \u00een \\(((x_1 +x_2)/2+1, y_1)\\), iar col\u021bul   dreapta-jos \u00een \\((x_2, (y_1 + y_2)/2)\\).</li> <li>Submatricea \\(D\\) are col\u021bul st\u00e2nga-sus \u00een \\(((x_1 + x_2)/2+1, (y_1 + y_2)/2+1)\\),   iar col\u021bul dreapta jos \u00een \\((x_2, y_2)\\).</li> </ul> <p>Pentru determinarea \u0219irului \\(S\\) al unei submatrice \\(R\\) se precalculeaz\u0103 o matrice a sumelor par\u021biale pe linie. Se procedeaz\u0103 similar ca la cerin\u021ba 2 pentru a verifica dac\u0103 o submatrice \\(R\\) este aprogressive.</p> <p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;algorithm&gt;\n#include &lt;fstream&gt;\n#include &lt;vector&gt;\n\nusing namespace std;\n\nifstream cin(\"aprogressive.in\");\nofstream cout(\"aprogressive.out\");\n\nlong long c, n, m, a[1032][1032], sp[1032][1032];\n\nlong long ps(int xa, int ya, int xb, int yb) {\n    return sp[xb][yb] - sp[xa - 1][yb] - sp[xb][ya - 1] + sp[xa - 1][ya - 1];\n}\n\nvoid solve(int xa, int ya, int xb, int yb) {\n    cout &lt;&lt; \"(\";\n    if (xa == xb || ya == yb) {\n        cout &lt;&lt; xa &lt;&lt; \",\" &lt;&lt; ya &lt;&lt; \",\" &lt;&lt; xb &lt;&lt; \",\" &lt;&lt; yb &lt;&lt; \",\" &lt;&lt; 0;\n    } else {\n        vector&lt;int&gt; sum;\n        for (int i = xa; i &lt;= xb; i++) {\n            sum.push_back(ps(i, ya, i, yb));\n        }\n        sort(sum.begin(), sum.end());\n        int ratio = sum[1] - sum[0];\n        bool ok = 1;\n        for (int i = 2; i &lt; sum.size(); i++) {\n            if (sum[i] - sum[i - 1] != ratio) {\n                ok = 0;\n            }\n        }\n        if (ok &amp;&amp; ratio != 0) {\n            cout &lt;&lt; xa &lt;&lt; \",\" &lt;&lt; ya &lt;&lt; \",\" &lt;&lt; xb &lt;&lt; \",\" &lt;&lt; yb &lt;&lt; \",\" &lt;&lt; ratio;\n        } else {\n            int midx = (xa + xb) / 2;\n            int midy = (ya + yb) / 2;\n            solve(xa, ya, midx, midy);\n            solve(xa, midy + 1, midx, yb);\n            solve(midx + 1, ya, xb, midy);\n            solve(midx + 1, midy + 1, xb, yb);\n        }\n    }\n    cout &lt;&lt; \")\";\n}\nint main() {\n    cin &gt;&gt; c &gt;&gt; n &gt;&gt; m;\n\n    for (int i = 1; i &lt;= n; i++) {\n        for (int j = 1; j &lt;= m; j++) {\n            cin &gt;&gt; a[i][j];\n            sp[i][j] = sp[i - 1][j] + sp[i][j - 1] - sp[i - 1][j - 1] + a[i][j];\n        }\n    }\n\n    if (c == 1) {\n        vector&lt;int&gt; maxlines;\n        maxlines.push_back(1);\n        for (int i = 2; i &lt;= n; i++) {\n            if (ps(i, 1, i, m) &gt; ps(maxlines[0], 1, maxlines[0], m)) {\n                maxlines.clear(), maxlines.push_back(i);\n            } else if (ps(i, 1, i, m) == ps(maxlines[0], 1, maxlines[0], m)) {\n                maxlines.push_back(i);\n            }\n        }\n        for (auto x : maxlines) {\n            cout &lt;&lt; x &lt;&lt; '\\n';\n        }\n    }\n\n    if (c == 2) {\n        for (int i = 1; i &lt;= n; i++) {\n            vector&lt;int&gt; vals;\n            for (int j = 1; j &lt;= m; j++) {\n                vals.push_back(a[i][j]);\n            }\n            sort(vals.begin(), vals.end());\n            bool ok = 1;\n            if (m &gt;= 2) {\n                int ratie = vals[1] - vals[0];\n                for (int j = 2; j &lt; vals.size(); j++) {\n                    if (vals[j] - vals[j - 1] != ratie) {\n                        ok = 0;\n                    }\n                }\n            }\n            if (ok) {\n                cout &lt;&lt; i &lt;&lt; '\\n';\n            }\n        }\n    }\n\n    if (c == 3) {\n        solve(1, 1, n, m);\n    }\n    return 0;\n}\n</code></pre>","tags":["OJI","clasa X"]},{"location":"olimpiada/solutii/OJI/2024/X-opsir/","title":"Solu\u021bia problemei Opsir (OJI 2024, clasa a X-a)","text":"","tags":["OJI","clasa X"]},{"location":"olimpiada/solutii/OJI/2024/X-opsir/#cerinta-1","title":"Cerin\u021ba 1","text":"<p>Subtask 1</p> <p>Pentru fiecare \u0219ir se construie\u0219te un vector de frecven\u021b\u0103 ce memoreaz\u0103 num\u0103rul de apari\u021bii al fiec\u0103rei litere. Pe baza acestora se determin\u0103 apoi c\u00e2te caractere distincte exist\u0103 \u00een cele 2 \u0219iruri.</p> <p>Pentru fiecare caracter distinct ce apare se determin\u0103 \u00een care dintre \u0219iruri apare de mai multe ori folosindu-se vectorii de frecven\u021b\u0103.</p>","tags":["OJI","clasa X"]},{"location":"olimpiada/solutii/OJI/2024/X-opsir/#cerinta-2","title":"Cerin\u021ba 2","text":"<p>Subtask 2 - \\(S\\) e sortat</p> <p>\u00cen aceast\u0103 situa\u021bie putem aplica o opera\u021bie de tip 2 pe tot \u0219irul \\(T\\), elimin\u00e2nd apoi literele care apar \u00een plus. Abordarea e echivalent\u0103 cu a verifica dac\u0103, pentru fiecare caracter distinct, frecven\u021ba sa \u00een \\(T\\) e mai mare dec\u00e2t frecven\u021ba sa \u00een \\(S\\).</p> <p>Subtask 3 - \\(S\\) poate fi ob\u021binut doar prin opera\u021bii de tip 1</p> <p>Problema e echivalent\u0103 cu a verifica daca \\(S\\) e sub\u0219ir al lui \\(T\\), ceea ce se poate face cu un algoritm Greedy.</p> <p>Subtask 4 - f\u0103r\u0103 restric\u021bii</p> <p>S\u0103 presupunem c\u0103 exist\u0103 o succesiune de lungime \\(L\\) de opera\u021bii de tip 1 \u0219i 2 care pot transforma \u0219irul \\(T\\) \u00een \u0219irul \\(S\\) (adica e valid\u0103 ca solu\u021bie): \\(op_1, op_2, op_3 \\dots op_L\\). Dac\u0103 \u00eencerc\u0103m s\u0103 interschimb\u0103m 2 opera\u021bii consecutive din aceast\u0103 succesiune (fie ele \\(op_i\\) \u0219i \\(op_{i+1}\\), \\(1 \\leq i &lt; L\\)) pentru a ob\u021bine tot o succesiune valid\u0103, putem observa urm\u0103toarele cazuri:</p> <ul> <li>\\(op_i\\) \u0219i \\(op_{i+1}\\) sunt opera\u021bii de tip 1: echivalent cu a \u0219terge 2 pozi\u021bii   din \u0219irul \\(T\\). Acestea pot fi \u0219terse \u00een orice ordine (cu o eventual\u0103   recalculare de indec\u0219i)</li> <li>\\(op_i\\) \u0219i \\(op_{i+1}\\) sunt opera\u021bii de tip 2: din criteriul color\u0103rii din   cerin\u021b\u0103 \u0219tim c\u0103 intervalele sunt disjuncte, deci nu conteaz\u0103 ordinea \u00een care   se realizeaz\u0103 aceste opera\u021bii</li> <li>\\(op_i\\) \u0219i \\(op_{i+1}\\) sunt opera\u021bii de tipuri diferite: echivalent cu a \u0219terge   o pozi\u021bie \u0219i a sorta un interval, opera\u021bii care se pot realiza \u00een orice ordine   (cu eventuale recalcul\u0103ri de indec\u0219i)</li> </ul> <p>Aceste observa\u021bii ne arat\u0103 faptul c\u0103 putem interschimba 2 opera\u021bii consecutive dintr-o succesiune valid\u0103 (cu anumite modific\u0103ri) pentru a ob\u021bine tot o succesiune valid\u0103. Consider\u0103m \u00een continuare c\u0103 \u201dam adus\u201d, prin interschimb\u0103ri, opera\u021biile de tip 1 pe primele pozi\u021bii din succesiune.</p> <p>De asemenea, consider\u0103m c\u0103 am efectuat deja aceste opera\u021bii de tip 1. Astfel, ob\u021binem din \u0219irul \\(T\\) un \u0219ir de lungime \\(n\\) \u0219i o mul\u021bime de intervale disjuncte ce corespund sort\u0103rilor ce urmeaz\u0103 a fi efectuate.</p> <p>S\u0103 consider\u0103m parti\u021bionarea \u0219irului \\(S\\) \u00een subsecven\u021be cresc\u0103toare maximale. Fie p num\u0103rul subsecven\u021belor din aceast\u0103 parti\u021bionare. \u00cen acest caz, orice interval din mul\u021bimea precizat\u0103 anterior va avea capetele \u00een aceea\u0219i subsecven\u021b\u0103 din aceast\u0103 parti\u021bionare. Observ\u0103m c\u0103, dac\u0103 \u00eenlocuim toate opera\u021biile de tip 2 r\u0103mase cu c\u00e2te o opera\u021bie de tip 2 pentru fiecare subsecven\u021b\u0103 din parti\u021bionarea \u0219irului \\(S\\) ob\u021binem acela\u0219i rezultat.</p> <p>Astfel, folosindu-ne din nou de interschimb\u0103ri, putem ob\u021bine o succesiune de opera\u021bii \u00een care au loc mai \u00eent\u00e2i toate sort\u0103rile, iar fiecare element din \u0219irul \\(T\\) este inclus \u00een cel pu\u021bin o sortare.</p> <p>Problema se reduce, \u00een aceast\u0103 situa\u021bie, la a verifica dac\u0103 exist\u0103 o parti\u021bionare a \u0219irului \\(T\\) \u00een \\(p\\) subsecven\u021be, astfel \u00eenc\u00e2t frecven\u021bele literelor din fiecare subsecven\u021b\u0103 a lui \\(T\\) s\u0103 fie mai mari sau egale dec\u00e2t cele din subsecven\u021ba corespondent\u0103 din \\(S\\) (din parti\u021bionarea de mai sus).</p> <p>Verificarea se poate face prin urm\u0103torul algoritm Greedy: pentru fiecare subsecven\u021b\u0103 din parti\u021bionarea lui \\(S\\) (subsecven\u021bele fiind luate de la st\u00e2nga la dreapta) se determina prefixul de lungime minim\u0103 a lui \\(T\\) pentru care frecven\u021bele literelor sale sunt mai mare sau egale dec\u00e2t cele din subsecven\u021ba actual\u0103 a lui \\(S\\). Se elimin\u0103 acest prefix \u0219i se continu\u0103 cu urm\u0103toarea subsecven\u021b\u0103 din \\(S\\). Dac\u0103 pentru fiecare subsecven\u021b\u0103 a lui \\(S\\) se g\u0103se\u0219te un astfel de prefix, atunci r\u0103spunsul este DA, altfel r\u0103spunsul este NU.</p> <p>Complexitate timp: \\(\\mathcal{O}(n \\cdot dimensiune_{alfabet})\\).</p> <p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n\nint main() {\n    ifstream cin(\"opsir.in\");\n    ofstream cout(\"opsir.out\");\n\n    int c, t;\n    cin &gt;&gt; c;\n    cin &gt;&gt; t;\n\n    for (; t; t--) {\n        int n, m;\n        cin &gt;&gt; n &gt;&gt; m;\n        string s, t;\n        cin &gt;&gt; s &gt;&gt; t;\n\n        vector&lt;int&gt; frq(26), frq2(26);\n        for (int i = 0; i &lt; n; i++) {\n            frq[s[i] - 'a']++;\n        }\n        for (int i = 0; i &lt; m; i++) {\n            frq2[t[i] - 'a']++;\n        }\n\n        if (c == 1) {\n            int cnt = 0;\n            for (int i = 0; i &lt; 26; i++) {\n                if (frq[i] || frq2[i]) {\n                    cnt++;\n                }\n            }\n            cout &lt;&lt; cnt &lt;&lt; '\\n';\n            for (int i = 0; i &lt; 26; i++) {\n                if (frq[i] || frq2[i]) {\n                    if (frq[i] &gt; frq2[i]) {\n                        cout &lt;&lt; (char)('a' + i) &lt;&lt; \" \" &lt;&lt; \"S\\n\";\n                    } else {\n                        cout &lt;&lt; (char)('a' + i) &lt;&lt; \" \" &lt;&lt; \"T\\n\";\n                    }\n                }\n            }\n        } else {\n            int poz = 0;\n            int poz2 = 0;\n            bool ok = 1;\n            while (poz &lt; n &amp;&amp; poz2 &lt; m) {\n                vector&lt;int&gt; frqq(26);\n                vector&lt;int&gt; frqq2(26);\n                int cntdif = 0;\n                while (poz &lt; n) {\n                    frqq[s[poz] - 'a']++;\n                    if (frqq[s[poz] - 'a'] == 1) {\n                        cntdif++;\n                    }\n                    poz++;\n                    if (poz &lt; n &amp;&amp; s[poz] &lt; s[poz - 1]) {\n                        break;\n                    }\n                }\n                while (poz2 &lt; m &amp;&amp; cntdif) {\n                    frqq2[t[poz2] - 'a']++;\n                    if (frqq2[t[poz2] - 'a'] == frqq[t[poz2] - 'a']) {\n                        cntdif--;\n                    }\n                    poz2++;\n                }\n                if (cntdif) {\n                    ok = 0;\n                }\n            }\n            if (poz == n &amp;&amp; ok) {\n                cout &lt;&lt; \"DA\\n\";\n            } else {\n                cout &lt;&lt; \"NU\\n\";\n            }\n        }\n    }\n    return 0;\n}\n</code></pre>","tags":["OJI","clasa X"]},{"location":"olimpiada/solutii/OJI/2024/X-poseidon/","title":"Solu\u021bia problemei Poseidon (OJI 2024, clasa a X-a)","text":"","tags":["OJI","clasa X"]},{"location":"olimpiada/solutii/OJI/2024/X-poseidon/#cerinta-1","title":"Cerin\u021ba 1","text":"<p>Subtask 1. Cazul unei singure insule.</p> <p>Se va afi\u0219a num\u0103rul de valori diferite de 0 \u0219i \\(-1\\) din matrice.</p> <p>Subtask 2. Cazul \\(N = 1\\).</p> <p>Pentru acest caz, se poate parcurge \u0219irul c\u0103tre st\u00e2nga, \u00eencep\u00e2nd cu celula de start, p\u00e2n\u0103 la \u00eent\u00e2lnirea primei valori de \\(-1\\), apoi c\u0103tre dreapta, \u00eentr-un mod similar. Se vor num\u0103ra valorile diferite de 0 \u0219i \\(-1\\).</p> <p>Subtask 3. Restul punctajului.</p> <p>Pentru restul punctajului, se va aplica algoritmul de flood fill, pornind din celula de start.</p>","tags":["OJI","clasa X"]},{"location":"olimpiada/solutii/OJI/2024/X-poseidon/#cerinta-2","title":"Cerin\u021ba 2","text":"<p>Se vor procesa individual toate insulele din matrice, folosind algoritmul de flood fill, \u0219i se vor num\u0103ra comorile din fiecare. Not\u0103m cu \\(D(n)\\) num\u0103rul de permut\u0103ri de \\(n\\) elemente, f\u0103r\u0103 puncte fixe. Rezultatul va consta \u00een produsul valorilor \\(D(x_i)\\), unde \\(x_i\\) este num\u0103rul de comori de pe o insul\u0103. Diferen\u021bele de punctaj sunt date de modul de calcul al valorilor \\(D(n)\\). Not\u0103m cu \\(nc\\) num\u0103rul maxim de comori dintr-o insul\u0103.</p> <p>Subtask 4. Cazul \\(nc \\leq 4\\).</p> <p>Se pot calcula \u201cpe h\u00e2rtie\u201d valorile \\(D(x_i)\\), fiind numere mici.</p> <p>Subtask 5. Cazul \\(nc \\leq 8\\).</p> <p>Se pot genera toate permut\u0103rile de c\u00e2te \\(k\\) elemente, \\(k \\leq nc\\) care respect\u0103 condi\u021bia dat\u0103, cu ajutorul metodei backtracking.</p> <p>Subtask 6. Restul punctajului.</p> <p>Este necesar\u0103 calcularea \u0219irului \\(D\\) \u00eentr-un mod mai eficient. Pentru ilustrarea metodei, ne imagin\u0103m c\u0103 vrem s\u0103 \u201cdezordon\u0103m\u201d \u0219irul format din elementele \\(1, 2, 3, \\dots, n\\), \u00een aceast\u0103 ordine. Pe fiecare pozi\u021bie, se poate amplasa orice num\u0103r diferit de num\u0103rul de ordine al pozi\u021biei respective.</p> <p>Not\u0103m cu \\(k\\) num\u0103rul care se va amplasa pe pozi\u021bia 1. Problema se \u00eemparte \u00een dou\u0103 cazuri, \u00een func\u021bie de elementul de pe pozi\u021bia \\(k\\).</p> <ul> <li>Amplas\u0103m num\u0103rul 1 pe pozi\u021bia \\(k\\). Problema se reduce la a calcula \\(D(n\u22122)\\),   pentru c\u0103 pe pozi\u021bia 1 avem valoarea \\(k\\), iar pe pozi\u021bia \\(k\\) avem valoare 1 \u0219i   restul de \\(n \u22122\\) valori se pot permuta independent de cele dou\u0103 cu respectarea   cerin\u021bei ini\u021biale.</li> <li>Amplas\u0103m un num\u0103r diferit de 1 pe pozi\u021bia \\(k\\). Pentru fiecare pozi\u021bie din cele   cuprinse \u00eentre 2 \u0219i \\(n\\), exist\u0103 \\(n \u2212 2\\) elemente care pot fi amplasate pe   pozi\u021bia respecitv\u0103. Pentru pozi\u021biile diferite de \\(k\\), nu se pot amplasa \\(k\\)   (pentru c\u0103 apare deja pe prima pozi\u021bie) sau elementul cu indicele pozi\u021biei   respective. Pentru pozi\u021bia \\(k\\), nu se pot amplasa \\(k\\) sau 1 (pentru c\u0103 suntem   \u00een cazul 2). Problema se reduce la a calcula \\(D(n\u22121)\\), fiindc\u0103 trebuie s\u0103   amplas\u0103m valorile pe pozi\u021biile cuprinse \u00eentre 2 \u0219i \\(n\\) (adic\u0103 \\(n \u2212 1\\) pozi\u021bii   \u00een total) \u0219i avem \\(n \u2212 2\\) variante pentru fiecare.</li> </ul> <p>Datorit\u0103 faptului c\u0103 num\u0103rul \\(k\\) se poate alege \u00een \\(n \u2212 1\\) moduri, formula final\u0103 este: \\(D(n) = (n \u2212 1) \\cdot (D(n \u2212 2) + D(n \u2212 1))\\), calculele se vor efectua modulo \\(10^9 + 7\\).</p> <p>O alt\u0103 variant\u0103 de abordare este s\u0103 observ\u0103m, c\u0103 \\(D(n)\\) este egal cu num\u0103rul total de permut\u0103ri de \\(n\\) elemente, minus num\u0103rul de permut\u0103ri care con\u021bin puncte fixe. S\u0103 not\u0103m cu \\(F(n, k)\\) num\u0103rul de permut\u0103ri de \\(n\\) elemente, care con\u021bin cel pu\u021bin \\(k\\) puncte fixe. Cele \\(k\\) pozi\u021bii se pot alege \u00een \\(C_n^k\\) feluri, iar restul elementelor se pot permuta oricum, a\u0219adar: \\(F(n, k) = C_n^k \\cdot (n \u2212 k)!\\)</p> <p>Aplic\u00e2nd principiul includerii \u0219i excluderii avem: \\(D(n) = n! \u2212 F(n, 1) + F(n, 2) \u2212 F(n, 3) + \\dots F(n, n)\\).</p> <p>Precalcul\u00e2nd valorile factorialelor \u0219i a inver\u0219ilor modulari a factorialelor modulo \\(10^9 +7\\) p\u00e2n\u0103 la \\(10^6\\) (valoarea maxim\u0103 pentru \\(nc\\)), putem ob\u021bine fiecare termen al formulei de mai sus \u00een \\(\\mathcal{O}(1)\\).</p> <p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n\nconst int mod = 1000000007;\n\nint c, n, m, grid[1001][1001], viz[1001][1001];\nlong long ans[1000002];\n\nint ox[] = {-1, 0, 1, 0};\nint oy[] = {0, 1, 0, -1};\n\nint main() {\n    ifstream cin(\"poseidon.in\");\n    ofstream cout(\"poseidon.out\");\n\n    cin &gt;&gt; c &gt;&gt; n &gt;&gt; m;\n\n    for (int i = 1; i &lt;= n; i++) {\n        for (int j = 1; j &lt;= m; j++) {\n            cin &gt;&gt; grid[i][j];\n        }\n    }\n\n    int xp, yp;\n    if (c == 1) {\n        cin &gt;&gt; xp &gt;&gt; yp;\n    }\n\n    ans[0] = 1, ans[1] = 0, ans[2] = 1;\n    for (int i = 3; i &lt;= n * m; i++) {\n        ans[i] = (1LL * (i - 1) * (ans[i - 1] + ans[i - 2])) % mod;\n    }\n\n    int ans1 = 0;\n    long long ans2 = 1;\n    for (int i = 1; i &lt;= n; i++) {\n        for (int j = 1; j &lt;= m; j++) {\n            if (grid[i][j] &gt;= 0 &amp;&amp; !viz[i][j]) {\n                queue&lt;pair&lt;int, int&gt;&gt; q;\n                viz[i][j] = 1;\n                set&lt;int&gt; s;\n                q.push({i, j});\n                bool isP = 0;\n                while (!q.empty()) {\n                    pair&lt;int, int&gt; nod = q.front();\n                    if (nod.first == xp &amp;&amp; nod.second == yp) {\n                        isP = 1;\n                    }\n                    q.pop();\n\n                    s.insert(grid[nod.first][nod.second]);\n                    for (int dir = 0; dir &lt;= 3; dir++) {\n                        int nxtx = nod.first + ox[dir];\n                        int nxty = nod.second + oy[dir];\n                        if (nxtx &gt;= 1 &amp;&amp; nxtx &lt;= n &amp;&amp; nxty &gt;= 1 &amp;&amp; nxty &lt;= m) {\n                            if (grid[nxtx][nxty] == -1 || viz[nxtx][nxty]) {\n                                continue;\n                            }\n                            viz[nxtx][nxty] = 1;\n                            q.push({nxtx, nxty});\n                        }\n                    }\n                }\n                if (s.find(0) != s.end()) {\n                    s.erase(0);\n                }\n                if (isP) {\n                    ans1 = s.size();\n                }\n                ans2 = (1LL * ans2 * ans[s.size()]) % mod;\n            }\n        }\n    }\n\n    if (c == 1) {\n        cout &lt;&lt; ans1;\n    } else {\n        cout &lt;&lt; ans2;\n    }\n    return 0;\n}\n</code></pre>","tags":["OJI","clasa X"]},{"location":"olimpiada/solutii/OJI/2024/XI-XII-acoperire/","title":"Solu\u021bia problemei Acoperire (OJI 2024, clasele XI-XII)","text":"<p>Subtask 1 (10 puncte). Pentru \\(N = 1\\), doar trebuie afi\u0219at intervalul de la cap\u0103tul st\u00e2nga la mijlocul intervalului.</p> <p>Subtask 2 (10 puncte). C\u00e2nd sunt dou\u0103 intervale disjuncte, pentru \\(K = 2\\) doar se face \\([start,mijloc]\\) pentru fiecare, iar pentru \\(K = 1\\) sunt dou\u0103 cazuri, ca la subtaskul 3.</p> <p>Subtask 3 (20 puncte). C\u00e2nd \\(K = 1\\) solu\u021bia tot timpul este ori \\([primulMijloc, ultimulMijloc]\\), ori se termin\u0103 \u00een ultimul mijloc \u0219i trebuie v\u0103zut pentru fiecare interval \u00een parte unde poate \u00eencepe cel mai t\u00e2rziu.</p> <p>Subtask 4 (20 puncte). C\u00e2nd toate intervalele nu se intersecteaz\u0103, ele pot fi sortate oricum, c\u0103ci b\u0103nuim c\u0103 unii concuren\u021bi instinctiv le sorteaz\u0103 dup\u0103 unul din capete \u0219i apoi \u00eencearc\u0103 un greedy. Problemele de genul de obicei implic\u0103 o ordonare \u0219i parcurgere a evenimentelor, doar aici trebuia v\u0103zut c\u0103 evenimentele interesante sunt mijloacele.</p> <p>Observa\u021bia de baz\u0103 a problemei este c\u0103 dac\u0103 un segment nou acoper\u0103 un segment ini\u021bial, atunci trebuie s\u0103 acopere mijlocul segmentului ini\u021bial. Dac\u0103 intervalul de acoperiri are lungimea minim jum\u0103tate din intervalul initial, este \u0219i garantat suficient. Echivalent ar fi s\u0103 spunem c\u0103 orice interval de lungime minim \\(L/2\\) acoper\u0103 un interval ini\u021bial de lungime \\(L\\) dac\u0103 \u0219i numai dac\u0103 con\u021bine mijlocul intervalului ini\u021bial.</p> <p>Ca s\u0103 ajungem la concluzia de mai sus, consider\u0103m un interval oarecare \\([A, B]\\). Dac\u0103 ne g\u00e2ndim care este segmentul minim cel mai din st\u00e2nga care \u00eel acoper\u0103, care ar fi intervalul \\([A, (A+B)/2]\\), \u0219i cel mai din dreapta, adic\u0103 \\([(A+ B)/2, B]\\), vedem c\u0103 doar elementul din mijloc este intersec\u021bia lor.</p> <p>De aici, putem vedea c\u0103 un interval de acoperire dintr-o solu\u021bie valid\u0103 poate fi translatat f\u0103r\u0103 a-i afecta corectitudinea p\u00e2n\u0103 c\u00e2nd unul din capete coincide cu unul din mijloacele intervalelor acoperite ini\u021bial. Facem asta pentru a putea genera toate intervalele de acoperire pornind de la puncte definite de segmentele ini\u021biale.</p> <p>Pentru solu\u021bia final\u0103 c\u0103ut\u0103m binar lungimea minim\u0103 a celui mai lung interval, folosind \u00eentreb\u0103ri de forma: \u201dDac\u0103 toate intervalele de acoperire au lungima \\(L\\), am putea acoperi cu cel mult \\(K\\) intervale mul\u021bimea celor initiale?\u201d</p> <p>\u00centrebarea nou\u0103 este mai simpl\u0103, \u0219i o r\u0103spundem printr-o parcurgere a intervalelor ini\u021biale, ordonate dup\u0103 mijloacele lor: \u00cencepem un interval de lungime \\(L\\) \u00een primul mijloc \u0219i consider\u0103m acoperite toate segmentele cu mijlocul con\u021binut \u00een acesta. C\u00e2nd \u00eent\u00e2lnim un segment nou care nu este acoperit de ultimul interval ad\u0103ugat, \u00eenseamn\u0103 c\u0103 trebuie s\u0103 \u00eencepem un nou interval \u00een mijlocul intervalului ini\u021bial. Complexitatea pentru pasul acesta este \\(\\mathcal{O}(N)\\) odat\u0103 ce intervalele sunt sortate la \u00eenceput dup\u0103 mijloc.</p> <p>Pentru solu\u021bia minim\u0103 lexicografic tot ce trebuie f\u0103cut e s\u0103 vedem c\u0103 dac\u0103 intervalele trebuie s\u0103 \u00eenceap\u0103 c\u00e2t mai din st\u00e2nga, este echivalent cu a vrea ca intervalele s\u0103 se termine c\u00e2t mai \u00een st\u00e2nga, \u0219i deci doar facem algoritmul \u00een sens invers dup\u0103 mijloace (pornim ultimul interval \u00een ultimul mijloc, etc.).</p> <p>Pentru a nu fi erori de precizie, se dubleaz\u0103 \u00een implementare capetele intervalelor, astfel \u00eenc\u00e2t mijloacele s\u0103 fie \u00eentregi. La afi\u0219are se poate face cu: <code>cout \u00ab setprecision(2) \u00ab (x / 2.0)</code> (f\u0103r\u0103 fixed) sau trat\u00e2nd explicit numere pare sau impare, cu caz particular pentru afi\u0219area lui \\(-1\\).</p> <p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n\nbool cmp(pair&lt;int, int&gt; a, pair&lt;int, int&gt; b) {\n    return (a.first + a.second) &lt; (b.first + b.second);\n}\nint main() {\n    ifstream cin(\"acoperire.in\");\n    ofstream cout(\"acoperire.out\");\n\n    int n;\n    cin &gt;&gt; n;\n\n    vector&lt;pair&lt;int, int&gt;&gt; vp(n + 1);\n    int minlength = 0;\n    for (int i = 1; i &lt;= n; i++) {\n        cin &gt;&gt; vp[i].first &gt;&gt; vp[i].second;\n        minlength = max(minlength, vp[i].second - vp[i].first);\n    }\n    sort(vp.begin() + 1, vp.begin() + n + 1, cmp);\n\n    int q;\n    cin &gt;&gt; q;\n\n    for (; q; q--) {\n        int k;\n        cin &gt;&gt; k;\n\n        int st = minlength;\n        int dr = 2000000000;\n        int ans = dr;\n        vector&lt;pair&lt;double, double&gt;&gt; vans;\n        while (st &lt;= dr) {\n            int mid = (st + dr) / 2;\n            double actualsize = 0.5000 * mid;\n            vector&lt;pair&lt;double, double&gt;&gt; intervals;\n            double lstend = -1;\n            for (int i = 1; i &lt;= n; i++) {\n                double midd = (vp[i].first + vp[i].second) * 0.500;\n                if (lstend &lt; midd) {\n                    intervals.push_back({midd, midd + actualsize});\n                    lstend = midd + actualsize;\n                }\n            }\n            if (intervals.size() &lt;= k) {\n                vans = intervals;\n                ans = mid;\n                dr = mid - 1;\n            } else {\n                st = mid + 1;\n            }\n        }\n\n        double actualsize = 0.5000 * ans;\n        vector&lt;pair&lt;double, double&gt;&gt; intervals;\n        double lstend = 1e9;\n        for (int i = n; i &gt;= 1; i--) {\n            double midd = (vp[i].first + vp[i].second) * 0.500;\n            if (lstend &gt; midd) {\n                intervals.push_back({midd - actualsize, midd});\n                lstend = midd - actualsize;\n            }\n        }\n        vans = intervals;\n\n        cout &lt;&lt; ans / 2 &lt;&lt; (ans % 2 == 0 ? \"\\n\" : \".5\\n\");\n        cout &lt;&lt; vans.size() &lt;&lt; '\\n';\n        sort(vans.begin(), vans.end());\n        for (auto x : vans) {\n            int tval = (2.00 * x.first);\n            int tval2 = (2.00 * x.second);\n            if (tval == -1) {\n                cout &lt;&lt; \"-\";\n            }\n            cout &lt;&lt; tval / 2 &lt;&lt; (tval % 2 == 0 ? \" \" : \".5 \");\n            if (tval2 == -1) {\n                cout &lt;&lt; \"-\";\n            }\n            cout &lt;&lt; tval2 / 2 &lt;&lt; (tval2 % 2 == 0 ? \"\\n\" : \".5\\n\");\n        }\n    }\n    return 0;\n}\n</code></pre>","tags":["OJI","clasa XI-XII"]},{"location":"olimpiada/solutii/OJI/2024/XI-XII-birocratie/","title":"Solu\u021bia problemei Birocratie (OJI 2024, clasele XI-XII)","text":"<p>Subtask 1 (12 puncte): \u00cen cazul \u00een care \\(B\\) are toate elementele pozitive, c\u00e2\u0219tigul maxim se ob\u021bine prin \u00eensumararea tuturor elementelor.</p> <p>Subtask 2 (12 puncte): \u00cen cazul \u00een care \\(B\\) are toate elementele egale \u0219i negative, trebuie s\u0103 minimiz\u0103m pierderea, ceea ce reu\u0219im folosind doar depl\u0103s\u0103ri orizontale \u0219i verticale, renun\u021b\u00e2nd complet la deplas\u0103rile oblice, trec\u00e2nd astfel prin \\(2 \\cdot N \u2212 1\\) birouri. Adic\u0103, \u021bin\u00e2nd cont, c\u0103 toate elementele sunt egale, r\u0103spunsul la aceast\u0103 cerin\u021b\u0103 este \\((2 \\cdot N \u2212 1) \\cdot B[1][1]\\)</p> <p>Subtask 3 (15 puncte): \u00cen cazul \u00een care pe fiecare diagonal\u0103 paralel\u0103 cu diagonala secundar\u0103 elementele din \\(B\\) sunt egale, vom proceda astfel: Fiecare diagonal\u0103 cu elemente egale pozitive se ia \u00een \u00eentregime, iar pentru fiecare diagonal\u0103 cu elemente negative se ia un singur element, astfel ob\u021binem suma maxim\u0103 posibil\u0103.</p> <p>Subtask 4 (13 puncte): \u00cen cazul \u00een care elementele de pe chenarul lui \\(B\\) sunt negative, iar celelalte elemente sunt pozitive, se va calcula suma tuturor elementelor pozitive din matrice (matricea f\u0103r\u0103 chenar) la care se adaug\u0103 primul \u0219i ultimul element: \\(B[1][1]\\), \\(B[N][N]\\), respectiv \u00een cazul diagonalelor de lungime 2, se va alege elementul cu valoarea mai mic\u0103.</p> <p>Subtask 5 (13 puncte): \u00cen cazul \u00een care toate elementele din \\(B\\) sunt egale \u00een valoare absolut\u0103, elementele de pe chenar sunt pozitive, iar celelalte elemente sunt negative, vom trece peste c\u00e2t mai multe elemente pozitive \u0219i vom evita toate elementele negative. Astfel se ob\u021bine formula \\((2 \\cdot N + 1) \\cdot B[1][1]\\)</p> <p>Subtask 6 (16 puncte): Problema se rezolv\u0103 cu programare dinamic\u0103 \u00een complexitate \\(\\mathcal{O}(N^3)\\). Pentru fiecare element, valoarea maxim\u0103 poate fi ob\u021binut\u0103 doar de pe linia anterioar\u0103, ad\u0103ug\u00e2nd elementul curent, de pe coloana anterioar\u0103 ad\u0103ug\u00e2nd elementul curent, sau de pe diagonala secundar\u0103, ad\u0103ug\u00e2nd toate elementele, care formeaz\u0103 secven\u021ba p\u00e2n\u0103 la elementul curent, ceea ce necesit\u0103 o complexitate liniar\u0103 relativ la lungimea diagonalei, deci \u00een ansamblu, \\(N^2\\) elemente vor necesita \\(\\mathcal{O}(N^3)\\) timp.</p> <p>Subtask 7 (19 puncte): Problema se rezolv\u0103 cu programare dinamic\u0103 \u00een complexitate \\(\\mathcal{O}(N^2)\\). Pentru fiecare element, valoarea maxim\u0103 poate fi ob\u021binut\u0103 doar de pe linia anterioar\u0103, ad\u0103ug\u00e2nd elementul curent, de pe coloana anterioar\u0103 ad\u0103ug\u00e2nd elementul curent, sau de pe diagonala secundar\u0103, ad\u0103ug\u00e2nd toate elementele care formeaz\u0103 secven\u021ba p\u00e2n\u0103 la elementul curent. Calculul elementelor de pe diagonale, prin parcurgerea ordonat\u0103 \u0219i complet\u0103 at\u00e2t de la st\u00e2nga la dreapta, c\u00e2t \u0219i de la dreapta la st\u00e2nga, va permite ca cele \\(K\\) elemente ale unei diagonale s\u0103 le putem rezolva cumulativ \u00een timp \\(\\mathcal{O}(K)\\), adic\u0103 pentru fiecare element vom avea un cost de timp \\(\\mathcal{O}(1)\\), deci, \u00een ansamblu problema va avea o complexitate de \\(\\mathcal{O}(N^2)\\).</p> <p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n\nint main() {\n    ifstream cin(\"birocratie.in\");\n    ofstream cout(\"birocratie.out\");\n\n    int n;\n    cin &gt;&gt; n;\n\n    vector&lt;vector&lt;int&gt;&gt; v(n + 1, vector&lt;int&gt;(n + 1)),\n        dp(n + 1, vector&lt;int&gt;(n + 1, -(1 &lt;&lt; 30))),\n        dp2(n + 1, vector&lt;int&gt;(n + 1, -(1 &lt;&lt; 30)));\n    for (int i = 1; i &lt;= n; i++) {\n        for (int j = 1; j &lt;= n; j++) {\n            cin &gt;&gt; v[i][j];\n        }\n    }\n\n    dp[1][1] = v[1][1];\n    for (int sum = 2; sum &lt;= n + n; sum++) {\n        if (sum != 2) {\n            int maxi = -(1 &lt;&lt; 30);\n            for (int lin = 1; lin &lt;= n; lin++) {\n                int col = sum - lin;\n                if (lin &gt;= 1 &amp;&amp; col &gt;= 1 &amp;&amp; lin &lt;= n &amp;&amp; col &lt;= n) {\n                    maxi = max(maxi + v[lin][col], dp[lin][col]);\n                    dp2[lin][col] = maxi;\n                }\n            }\n            maxi = -(1 &lt;&lt; 30);\n            for (int lin = n; lin &gt;= 1; lin--) {\n                int col = sum - lin;\n                if (lin &gt;= 1 &amp;&amp; col &gt;= 1 &amp;&amp; lin &lt;= n &amp;&amp; col &lt;= n) {\n                    maxi = max(maxi + v[lin][col], dp[lin][col]);\n                    dp2[lin][col] = max(dp2[lin][col], maxi);\n                }\n            }\n\n            for (int lin = 1; lin &lt;= n; lin++) {\n                int col = sum - lin;\n                if (lin &gt;= 1 &amp;&amp; col &gt;= 1 &amp;&amp; lin &lt;= n &amp;&amp; col &lt;= n) {\n                    dp[lin][col] = dp2[lin][col];\n                }\n            }\n        }\n        for (int lin = 1; lin &lt;= n; lin++) {\n            int col = sum - lin;\n            if (lin &gt;= 1 &amp;&amp; col &gt;= 1 &amp;&amp; lin &lt;= n &amp;&amp; col &lt;= n) {\n                if (lin &lt; n) {\n                    dp[lin + 1][col] =\n                        max(dp[lin + 1][col], dp[lin][col] + v[lin + 1][col]);\n                }\n                if (col &lt; n) {\n                    dp[lin][col + 1] =\n                        max(dp[lin][col + 1], dp[lin][col] + v[lin][col + 1]);\n                }\n            }\n        }\n    }\n    cout &lt;&lt; dp[n][n] &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["OJI","clasa XI-XII"]},{"location":"olimpiada/solutii/OJI/2024/XI-XII-nestemate/","title":"Solu\u021bia problemei Nestemate (OJI 2024, clasele XI-XII)","text":"<p>Subtask 1 (11 puncte). Se verific\u0103 dac\u0103 cele dou\u0103 nestemate au cel pu\u021bin o proprietate ce coincide, caz \u00een care declar\u0103m c\u0103 este necesar\u0103 o singur\u0103 transformare, \u00een caz contrar se va afi\u0219a \\(\u22121\\).</p> <p>Subtask 2 (13 puncte). Se \u00eencearc\u0103 toate nestematele pentru a vedea dac\u0103 pot fi folosite ca stare intermediar\u0103 sau dac\u0103 nestemata \\(A\\) poate fi transformat\u0103 direct in nestemata \\(B\\). Dac\u0103 nu este posibila transformarea in niciunul din aceste moduri se va afi\u0219a \\(\u22121\\).</p> <p>Subtask 3 (16 puncte). Se \u00eencearc\u0103 toate combina\u021biile de 2 nestemate intermediare, se \u00eencearc\u0103 doar cu o piatr\u0103 intermediar\u0103 \u0219i se \u00eencearc\u0103 \u0219i dac\u0103 este posibil\u0103 transformarea direct\u0103. Se afi\u0219eaz\u0103 num\u0103rul minim de transform\u0103ri iar \u00een caz c\u0103 nu este posibil\u0103 transformarea \u00een niciunul din aceste moduri se va afi\u0219a \\(\u22121\\).</p> <p>Subtask 4 (10 puncte). Folosind o abordare de tip backtracking, \u00eencerc\u0103m s\u0103 lu\u0103m toate posibilit\u0103\u021bile de transform\u0103ri succesive. Re\u021binem lungimea minim\u0103 a unui lan\u021b de transform\u0103ri valid c\u00e2t \u0219i dac\u0103 s-a reu\u0219it g\u0103sirea a cel pu\u021bin un astfel de lan\u021b.</p> <p>Subtask 5 (10 puncte). Model\u0103m rela\u021biile dintre nestemate ca un graf. Pentru fiecare dou\u0103 nestemate se stabile\u0219te dac\u0103 au o proprietate \u00een comun \u0219i prin urmare fiecare din aceste pietre poate fi transformat\u0103 \u00een cealalt\u0103 (transformarea este mereu bidirec\u021bional\u0103). Se va crea o matrice de adiacen\u021b\u0103 \u0219i se va c\u0103uta drumul minim de la nestemata \\(A\\) la nestemata \\(B\\). Drumul minim poate fi g\u0103sit printr-un algoritm precum parcurgerea \u00een l\u0103\u021bime (BFS). Pentru aceast\u0103 cerin\u021b\u0103 este necesar\u0103 o rezolvare \u00een complexitatea \\(\\mathcal{O}(N^2)\\).</p> <p>Subtask 6 (13 puncte). Se vor genera muchiile \u00eentr-o complexitate mai bun\u0103 folosindu-ne de valorile prezente \u00een nestemate. Pentru fiecare valoare se va genera o list\u0103 de nestemate ce con\u021bin valoarea respectiv\u0103 \u00een configura\u021bie. Pentru fiecare valoare, toate nestematele din cadrul unei liste vor fi unite fiecare cu fiecare printr-o muchie. Se va avea grij\u0103 s\u0103 nu se genereze de mai multe ori o muchie \u00eentre acelea\u0219i dou\u0103 nestemate. Se va c\u0103uta drumul minim de la nestemata \\(A\\) la nestemata \\(B\\) printr-un algoritm precum parcurgerea \u00een l\u0103\u021bime (BFS). Deoarece la aceast\u0103 cerin\u021b\u0103 se garanteaz\u0103 c\u0103 o valoare apare la maxim 3 nestemate distincte, la un pas nu vor fi generate mai mult de 3 muchii. Dimensiunea grafului va fi rezonabil\u0103 pentru o complexitate de \\(\\mathcal{O}(N + MaxVal)\\) unde \\(MaxVal\\) este cea mai mare valoare dintre propriet\u0103\u021bile nestematelor.</p> <p>Subtask 7 (27 de puncte). Pentru solu\u021bia final\u0103 nu se va genera deloc graful deoarece num\u0103rul de muchii poate deveni foarte mare. Pentru fiecare valoare vom \u021bine liste cu toate nestematele ce con\u021bin valoarea respectiv\u0103. Vom folosi o abordare de parcurgere \u00een l\u0103\u021bime (BFS) pentru a g\u0103si distan\u021ba minim\u0103. La fiecare pas pornind de la o nestemat\u0103 lu\u0103m toate propriet\u0103\u021bile acesteia \u0219i explor\u0103m doar listele propriet\u0103\u021bilor ce nu au mai fost \u00eent\u00e2lnite p\u00e2n\u0103 \u00een acel moment. Fiecare list\u0103 a unei propriet\u0103\u021bi va fi parcurs\u0103 exact o dat\u0103 pe parcursul algoritmului. Parcurgem listele si ad\u0103ug\u0103m \u00een coad\u0103 doar nestematele ce nu au mai fost parcurse p\u00e2n\u0103 \u00een acel moment. Aceast\u0103 abordare se \u00eencadreaz\u0103 \u00een complexitatea optim\u0103 \\(\\mathcal{O}(N + MaxVal)\\) unde \\(MaxVal\\) este cea mai mare valoare dintre propriet\u0103\u021bile nestematelor.</p> <p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n\nstruct data {\n    int v[3];\n};\nint main() {\n    ifstream cin(\"nestemate.in\");\n    ofstream cout(\"nestemate.out\");\n\n    int t;\n    cin &gt;&gt; t;\n\n    for (; t; t--) {\n        int n, a, b;\n        cin &gt;&gt; n &gt;&gt; a &gt;&gt; b;\n\n        vector&lt;data&gt; nodes(n + 1);\n        vector&lt;int&gt; cost(n + 1, (1 &lt;&lt; 30)), colors(500001, (1 &lt;&lt; 30)),\n            passed(500001, 0);\n        cost[a] = 0;\n\n        vector&lt;vector&lt;int&gt;&gt; who(500001);\n        for (int i = 1; i &lt;= n; i++) {\n            cin &gt;&gt; nodes[i].v[0] &gt;&gt; nodes[i].v[1] &gt;&gt; nodes[i].v[2];\n            who[nodes[i].v[0]].push_back(i);\n            who[nodes[i].v[1]].push_back(i);\n            who[nodes[i].v[2]].push_back(i);\n        }\n\n        queue&lt;int&gt; q;\n        q.push(a);\n\n        while (!q.empty()) {\n            int nod = q.front();\n            q.pop();\n\n            for (int i = 0; i &lt;= 2; i++) {\n                if (colors[nodes[nod].v[i]] &gt; cost[nod]) {\n                    colors[nodes[nod].v[i]] = cost[nod];\n                    for (auto x : who[nodes[nod].v[i]]) {\n                        if (cost[x] &gt; cost[nod] + 1) {\n                            cost[x] = cost[nod] + 1;\n                            q.push(x);\n                        }\n                    }\n                }\n            }\n        }\n\n        cout &lt;&lt; (cost[b] == (1 &lt;&lt; 30) ? -1 : cost[b]) &lt;&lt; '\\n';\n    }\n    return 0;\n}\n</code></pre>","tags":["OJI","clasa XI-XII"]},{"location":"olimpiada/solutii/OJI/2025/IX-natatie/","title":"Solu\u021bia problemei Nata\u021bie (OJI 2025, clasa a IX-a)","text":"<p>Observa\u021bie</p> <p>Pentru solu\u021biile ce folosesc sort\u0103ri, complexitatea pentru fiecare subtask \u00een parte depinde de sortarea folosit\u0103, \u00eens\u0103 orice sortare cu complexitate cel mult p\u0103tratic\u0103 \\(\\mathcal{O} (N^2)\\) ob\u021bine punctaj maxim pentru restric\u021biile date. Solu\u021biile prezentate nu iau \u00een calcul \u0219i aceast\u0103 complexitate, de\u0219i aceasta poate fi mai semnificativ\u0103 dec\u00e2t complexitatea solu\u021biei propriu-zise \u00een care se afl\u0103 timpul minim al cursei.</p>","tags":["OJI","clasa IX"]},{"location":"olimpiada/solutii/OJI/2025/IX-natatie/#subtask-1-17p","title":"Subtask 1 (17p)","text":"<p>Dac\u0103 toate vitezele sunt egale, putem alege oricare \\(M\\) ra\u021be din cele \\(N\\). Toate configura\u021biile \u00een care se respect\u0103 ordinea cresc\u0103toare a rezisten\u021belor sunt valide \u0219i dau acela\u0219i timp pentru curs\u0103. R\u0103spunsul va fi \\((2 \\cdot d_M )/v\\), unde \\(v\\) reprezint\u0103 o vitez\u0103 a oric\u0103rei ra\u021be. Complexitate: \\(\\mathcal{O} (1)\\).</p>","tags":["OJI","clasa IX"]},{"location":"olimpiada/solutii/OJI/2025/IX-natatie/#subtask-2-16p","title":"Subtask 2 (16p)","text":"<p>Dac\u0103 toate rezisten\u021bele sunt egale, cea mai optim\u0103 variant\u0103 este s\u0103 lu\u0103m cele \\(M\\) ra\u021be cu cele mai mari viteze. Putem sorta ra\u021bele cresc\u0103tor dup\u0103 vitez\u0103 pun\u00e2ndu-le \u00een ordinea cresc\u0103toare a vitezelor pe culoarele de la 1 la \\(M\\). Apoi, simul\u0103m cursa, r\u0103spunsul fiind cel mai mare timp \u00een care o ra\u021b\u0103 se \u00eentoarce. Complexitate: \\(\\mathcal{O}(M)\\).</p>","tags":["OJI","clasa IX"]},{"location":"olimpiada/solutii/OJI/2025/IX-natatie/#subtask-3-15p","title":"Subtask 3 (15p)","text":"<p>Din moment ce avem cel mult \\(3 \\cdot 10^3\\) ra\u021be \u0219i trebuie s\u0103 folosim de fiecare dat\u0103 \\(M\\) dintre cele \\(N\\) \u0219i \\(M = N \u2212 1\\), \u00eenseamn\u0103 c\u0103 doar o ra\u021b\u0103 nu va fi folosit\u0103. Deci, putem s\u0103 elimin\u0103m fiecare ra\u021b\u0103 \u00een parte \u0219i s\u0103 simul\u0103m cursa cu cele r\u0103mase. Observa\u021bia cheie este c\u0103 pentru o configura\u021bie aleas\u0103 cu \\(M\\) ra\u021be, cea mai optim\u0103 a\u0219ezare a lor pe cele \\(M\\) culoare este cea \u00een care le sort\u0103m cresc\u0103tor dup\u0103 rezisten\u021b\u0103, iar \u00een caz de egalitate cresc\u0103tor dup\u0103 vitez\u0103. Se sorteaz\u0103 ini\u021bial toate ra\u021bele dup\u0103 acest criteriu, elimin\u0103m fiecare \u00een parte \u0219i simul\u0103m cursa cu cele r\u0103mase, determin\u00e2nd cel mai bun timp dintre curse. Complexitate: \\(\\mathcal{O}(M \\cdot N)\\).</p>","tags":["OJI","clasa IX"]},{"location":"olimpiada/solutii/OJI/2025/IX-natatie/#subtask-4-18p","title":"Subtask 4 (18p)","text":"<p>O prim\u0103 observa\u021bie este faptul c\u0103 r\u0103spunsul apar\u021bine mul\u021bimii \\(\\{t \\mid t = (2 \\cdot d_j )/v_i,\\,1 \u2264 i \u2264 N,\\,1 \u2264 j \u2264 M\\}\\). Pe scurt, timpul cursei optime este cu siguran\u021b\u0103 unul dintre timpii unei perechi (ra\u021b\u0103, baliz\u0103). Putem calcula to\u021bi timpii posibili, \u00eel lu\u0103m pe fiecare \u00een parte, iar apoi verific\u0103m dac\u0103 exist\u0103 vreo configura\u021bie prin care s\u0103 alegem \\(M\\) ra\u021be \u0219i s\u0103 ob\u021binem un timp cel mult egal cu cel ales. \u00cen continuare, trebuie s\u0103 g\u0103sim o strategie prin care putem determina dac\u0103 \\(M\\) dintre cele \\(N\\) ra\u021be pot fi alese \u00eenc\u00e2t s\u0103 ob\u021binem un timp mai mic sau egal dec\u00e2t un timp fixat. \u00cen prim\u0103 faz\u0103, toate ra\u021bele se sorteaz\u0103 dup\u0103 rezisten\u021b\u0103, iar \u00een caz de egalitate dup\u0103 vitez\u0103. Apoi, parcurgem \u00een ordine toate ra\u021bele, \u00eencerc\u00e2nd la fiecare pas s\u0103 punem ra\u021ba curent\u0103 pe cel mai mic culoar neocupat. Acest lucru este corect deoarece dac\u0103 o ra\u021b\u0103 cu rezisten\u021ba \\(r\\) este folosit\u0103 pe un culoar, ra\u021bele cu rezisten\u021be mai mici nu mai pot fi folosite, deci este optim s\u0103 o lu\u0103m pe cea cu rezisten\u021b\u0103 minim\u0103 dac\u0103 se \u00eentoarce \u00een timp util. Legat de vitez\u0103 (la egalitate de rezisten\u021be), este clar c\u0103 dac\u0103 o ra\u021b\u0103 cu viteza \\(v\\) se \u00eentoarce \u00eenapoi \u00een timp util, este optim s\u0103 p\u0103str\u0103m ra\u021bele cu viteze mai mari pentru culoarele cu balize mai \u00eendep\u0103rtate, deci sortarea \u0219i simularea cursei sunt corecte. Dac\u0103 g\u0103sim \\(M\\) ra\u021be care ne ob\u021bin un timp mai mic sau egal dec\u00e2t cel fixat, re\u021binem acel timp, la final r\u0103spunsul fiind cel mai mic astfel de timp. Complexitate: \\(\\mathcal{O} (M \\cdot N^2)\\).</p>","tags":["OJI","clasa IX"]},{"location":"olimpiada/solutii/OJI/2025/IX-natatie/#subtask-5-11p","title":"Subtask 5 (11p)","text":"<p>Din moment ce distan\u021bele balizelor sunt cel mult \\(3 \\cdot 10^3\\) \u0219i vitezele sunt numere naturale, \u00eenseamn\u0103 c\u0103 timpul maxim al unei curse este \\(6 \\cdot 10^3\\). \u0218tiind c\u0103 rezultatul este un timp \u00eentreg \u0219i folosind ideea anterioar\u0103, putem lua to\u021bi timpii naturali \u00een ordine cresc\u0103toare \u0219i s\u0103 verific\u0103m pentru fiecare \u00een parte dac\u0103 exist\u0103 o curs\u0103 posibil\u0103. Primul timp g\u0103sit este r\u0103spunsul c\u0103utat. Complexitate: \\(\\mathcal{O} (N \\cdot d_M)\\).</p>","tags":["OJI","clasa IX"]},{"location":"olimpiada/solutii/OJI/2025/IX-natatie/#subtask-6-13p","title":"Subtask 6 (13p)","text":"<p>O observa\u021bie cheie este c\u0103 dac\u0103 pentru un timp \\(x\\) nu reu\u0219im (folosind ideile anterioare) s\u0103 alegem \\(M\\) ra\u021be astfel \u00eenc\u00e2t s\u0103 ob\u021binem un timp mai mic sau egal pentru cursa noastr\u0103, \u00eenseamn\u0103 c\u0103 nu vom reu\u0219i nici pentru al\u021bi timpi mai mici. Deci, putem face o c\u0103utare binar\u0103 pe rezultat, \u00een care lu\u0103m la fiecare pas mijlocul ca fiind timpul maxim pe care \u00eel poate avea cursa noastr\u0103. \u00cencerc\u0103m s\u0103 c\u0103ut\u0103m o configura\u021bie de \\(M\\) ra\u021be prin care timpul cursei este mai mic sau egal dec\u00e2t cel fixat. Dac\u0103 g\u0103sim, atunci vom c\u0103uta un timp mai mic sau egal (dr = mij). Dac\u0103 nu, atunci avem nevoie de un timp strict mai mare (st = mij + 1). La finalul c\u0103ut\u0103rii binare, timpul g\u0103sit este chiar r\u0103spunsul. Complexitate: \\(\\mathcal{O} (N \\cdot \\log d_M )\\).</p>","tags":["OJI","clasa IX"]},{"location":"olimpiada/solutii/OJI/2025/IX-natatie/#subtask-7-10p","title":"Subtask 7 (10p)","text":"<p>Dac\u0103 rezultatul nu este natural, ideea anterioar\u0103 este valid\u0103 \u00een continuare, \u00eens\u0103 trebuie modificat\u0103 c\u0103utarea binar\u0103. Din moment ce trebuie s\u0103 afi\u0219\u0103m rezultatul cu o eroare maxim\u0103 de \\(10^{\u22123}\\), vom c\u0103uta binar r\u0103spunsul p\u00e2n\u0103 c\u00e2nd diferen\u021ba dintre capete este mai mic\u0103 dec\u00e2t aceast\u0103 eroare. Deoarece c\u0103ut\u0103m binar pe numere reale, se modific\u0103 atribuirile pentru capetele din st\u00e2nga \u0219i dreapta. Dac\u0103 g\u0103sim o configura\u021bie, atunci vom c\u0103uta un timp mai mic sau egal (dr = mij). Dac\u0103 nu, atunci avem nevoie de un timp strict mai mare, \u00eens\u0103 c\u0103utarea fiind pe numere reale, atribuirea e asem\u0103n\u0103toare cu cea din cazul anterior (st = mij). Pentru un punctaj maxim este necesar\u0103 \u0219i afi\u0219area cu precizie, astfel \u00eenc\u00e2t s\u0103 se afi\u0219eze cel pu\u021bin 3 cifre zecimale. Complexitate: \\(\\mathcal{O} (N \\cdot \\log d_M)\\).</p>","tags":["OJI","clasa IX"]},{"location":"olimpiada/solutii/OJI/2025/IX-natatie/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie care ia punctajul maxim.</p> <pre><code>#include &lt;algorithm&gt;\n#include &lt;fstream&gt;\n#include &lt;iomanip&gt;\n#define lol long long\n#define N 3001\nusing namespace std;\nifstream f(\"natatie.in\");\nofstream g(\"natatie.out\");\nint m, n, i;\nlong double rez;\nint v[N], r[N], ind[N], d[N];\nlong long K, sol;\n\nbool cmp(int st, int dr) {\n    if (r[st] == r[dr]) {\n        return v[st] &lt; v[dr];\n    }\n    return r[st] &lt; r[dr];\n}\n\nvoid solve(lol st, lol dr) {\n    if (st &lt; dr) {\n        lol mij = (st + dr) / 2;\n        int nr = 0, h, j, b = 1;\n        long double t, t1;\n\n        for (h = 1; h &lt;= n; h++) {\n            j = ind[h];\n            if (b &lt;= m) {\n                t = (mij * 1.0) / 1000000000;\n                t1 = (2.0 * d[b]) / v[j];\n                if (t1 &lt;= t) {\n                    nr++;\n                    b++;\n                }\n            } else {\n                h = n + 1;\n            }\n        }\n        if (b == m + 1) {\n            if (mij &lt;= rez) {\n                rez = mij;\n            }\n            solve(st, mij);\n        } else {\n            solve(mij + 1, dr);\n        }\n    }\n}\n\nint main() {\n    K = 1000000000000000;\n    f &gt;&gt; n &gt;&gt; m;\n    for (i = 1; i &lt;= n; i++) {\n        f &gt;&gt; v[i];\n        ind[i] = i;\n    }\n    for (i = 1; i &lt;= n; i++) {\n        f &gt;&gt; r[i];\n    }\n    for (i = 1; i &lt;= m; i++) {\n        f &gt;&gt; d[i];\n    }\n    sort(ind + 1, ind + n + 1, cmp);\n    rez = K;\n    solve(0, K);\n    rez = (rez * 1.0) / 1000000000;\n    g &lt;&lt; setprecision(9) &lt;&lt; rez &lt;&lt; \"\\n\";\n\n    return 0;\n}\n</code></pre>","tags":["OJI","clasa IX"]},{"location":"olimpiada/solutii/OJI/2025/IX-summat/","title":"Solu\u021bia problemei Summat (OJI 2025, clasa a IX-a)","text":"<p>Rezolvarea problemei Summat presupune folosirea unor tehnici de programare precum: generarea unei matrice cu elemente date, sume par\u0163iale pe vector, sume par\u0163iale pe matrice, observa\u0163ii referitoare la un \u015fir de numere \u00een care secven\u0163ele de elemente consecutive egale devin din ce \u00een ce mai lungi. Pentru ob\u0163inerea a 100 de puncte nu este necesar\u0103 c\u0103utarea binar\u0103, timpul de execu\u0163ie fiind setat pentru c\u0103utare secven\u0163ial\u0103. Observa\u0163ia esen\u0163ial\u0103 pentru a putea ob\u0163ine 100 de puncte este c\u0103 secven\u0163ele de valori egale din matrice sunt foarte lungi \u015fi astfel vom avea multe linii consecutive cu acelea\u015fi elemente. De asemenea de men\u0163ionat \u015fi faptul c\u0103 valoarea elementelor matricei \\(A\\) nu dep\u0103\u015fe\u015fte 55, deci suma elementelor oric\u0103rei submatrice se va \u00eencadra pe 64 de bi\u0163i.</p>","tags":["OJI","clasa IX"]},{"location":"olimpiada/solutii/OJI/2025/IX-summat/#subtask-1-24p","title":"Subtask 1 (24p)","text":"<p>Se genereaz\u0103 matricea \\(A\\) format\u0103 cu elementele \u015firului 1, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 4, 4, 4, 4, ..., apoi pentru fiecare submatrice se calculeaz\u0103 suma elementelor, prin parcurgerea submatricei respective. Complexitatea solu\u0163iei este \\(\\mathcal{O} (Q \\cdot M \\cdot N)\\).</p>","tags":["OJI","clasa IX"]},{"location":"olimpiada/solutii/OJI/2025/IX-summat/#subtask-2-14p","title":"Subtask 2 (14p)","text":"<p>Deoarece \\(M = 1\\) matricea \\(A\\) are o singura linie, deci este un \u015fir. Se genereaz\u0103 \u015firul \\(A\\), se calculeaz\u0103 \u015firul \\(S\\) al sumelor par\u0163iale ale lui \\(A\\) \u015fi, pentru fiecare submatrice dat\u0103, suma elementelor sale este \\(S[c_2] - S[c_1 - 1]\\). Complexitatea solu\u0163iei este \\(\\mathcal{O} (N + Q)\\).</p>","tags":["OJI","clasa IX"]},{"location":"olimpiada/solutii/OJI/2025/IX-summat/#subtask-3-19p","title":"Subtask 3 (19p)","text":"<p>Se genereaz\u0103 matricea \\(A\\), se calculeaz\u0103 matricea \\(S\\) a sumelor par\u0163iale \u015fi, pentru fiecare submatrice dat\u0103, suma elementelor sale este \\(S[l_2][c_2] - S[l_2][c_1 - 1] - S[l_1 - 1][c_2] + S[l_1 - 1][c_1 - 1]\\). Complexitatea solu\u0163iei este \\(\\mathcal{O} (M \\cdot N + Q)\\).</p>","tags":["OJI","clasa IX"]},{"location":"olimpiada/solutii/OJI/2025/IX-summat/#subtask-4-11p","title":"Subtask 4 (11p)","text":"<p>Deoarece \\(M = 1\\), matricea \\(A\\) are o singur\u0103 linie. Vom nota cu \\(\\operatorname{Sum}(k)\\) suma elementelor de pe aceast\u0103 linie pan\u0103 la elementul de indice \\(k\\). Pentru a calcula \\(\\operatorname{Sum}(k)\\) se determin\u0103 \\(i\\) maxim astfel \u00eenc\u00e2t \\(T = 1 + 2 + 2^2 +2^3 +...+2^i = 2^{i + 1} - 1 \\leq k\\), \u00een acelasi timp calcul\u00e2nd suma \\(S = 2^0 \\cdot 1 +2^1 \\cdot 2+2^2 \\cdot 3+2^3 \\cdot 4+...+2^i \\cdot (i + 1)\\), \u015fi vom ob\u0163ine \\(\\operatorname{Sum}(k) = S + (k - T) \\cdot (i + 1)\\). Suma elementelor unei submatrice date va fi \\(\\operatorname{Sum}(c_2) - \\operatorname{Sum}(c_1 - 1)\\). Complexitatea solu\u0163iei este \\(\\mathcal{O} (C \\cdot Q)\\), unde constanta \\(C\\) este aproximativ 50 pentru c\u0103utarea lui \\(i\\) secven\u0163ial, respectiv aproximativ 6 pentru c\u0103utarea lui \\(i\\) binar.</p>","tags":["OJI","clasa IX"]},{"location":"olimpiada/solutii/OJI/2025/IX-summat/#subtask-5-15p","title":"Subtask 5 (15p)","text":"<p>Pentru fiecare linie \\(i\\) de la \\(l_1\\) la \\(l_2\\) se calculeaz\u0103 \\(\\operatorname{Sum}(c_2 + N \\cdot (i - 1)) - \\operatorname{Sum}(c_1 - 1 + N \\cdot (i - 1))\\) iar suma acestor numere reprezint\u0103 suma elementelor submatricei date. Complexitatea solu\u0163iei este \\(\\mathcal{O} (Q \\cdot 100 + C)\\), unde constanta \\(C\\) are acelea\u0219i valori ca mai sus..</p>","tags":["OJI","clasa IX"]},{"location":"olimpiada/solutii/OJI/2025/IX-summat/#subtask-6-17p","title":"Subtask 6 (17p)","text":"<p>Se determin\u0103 coordonatele elementelor din matricea \\(A\\) \u00een care se schimb\u0103 valoarea elementului din \u015firul 1, 2, 2, 3, 3, 3, 3, ... dat. Fie \\((x_i, y_i)\\) coordonatele acestor elemente, unde \\(1 \u2264 i \u2264 55\\) (se poate aproxima cu u\u015furin\u0163\u0103 c\u0103 num\u0103rul maxim din matricea \\(A\\) nu poate dep\u0103\u015fi valoarea 55). Se determin\u0103 \\(k\\) minim cu \\(l_1 \\leq x_k\\) \u015fi \\(p\\) maxim cu \\(x_p \\leq l_2\\) (acest lucru se poate face secven\u0163ial sau prin c\u0103utare binar\u0103). Pentru fiecare \\(i\\) de la \\(k\\) la \\(p\\) se calculeaz\u0103 \\(\\operatorname{Sum}(c_2 + (x_i - 1) \\cdot N) - \\operatorname{Sum} (c_1 - 1 + x_i \\cdot N)\\) (adic\u0103 suma elementelor de pe linia \\(x_i\\) din submatricea dat\u0103), numar care se adaug\u0103 la suma elementelor submatricei date. De asemenea, pe liniile cuprinse \u00eentre linia \\(x_{i}\\) \u015fi linia \\(x_{i+1}\\), exclusiv acestea, se afl\u0103 acela\u015fi num\u0103r \u00een submatricea dat\u0103 \u015fi anume \\(i\\), deci suma elementelor de pe aceste linii va fi \\((x_{i + 1} \u2212x_i \u22121) \\cdot (c_2 - c_1+1) \\cdot i\\), num\u0103r care se adaug\u0103 la suma elementelor submatricei date. Complexitatea solu\u0163iei este \\(\\mathcal{O} (Q \\cdot C)\\), unde constanta \\(C\\) are acelea\u0219i valori ca mai sus.</p>","tags":["OJI","clasa IX"]},{"location":"olimpiada/solutii/OJI/2025/IX-summat/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie care ia punctajul maxim.</p> <pre><code>#include &lt;bits/stdc++.h&gt;\n\nusing namespace std;\n\nusing i64 = long long;\n\nint main() {\n#ifndef LOCAL\n    freopen(\"summat.in\", \"r\", stdin);\n    freopen(\"summat.out\", \"w\", stdout);\n#endif\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    cout.tie(0);\n    int N, M, Q;\n    cin &gt;&gt; N &gt;&gt; M &gt;&gt; Q;\n    while (Q--) {\n        int x1, y1, x2, y2;\n        cin &gt;&gt; x1 &gt;&gt; y1 &gt;&gt; x2 &gt;&gt; y2;\n        x1--, y1--, x2--, y2--;\n        i64 s = 0;\n        i64 ans = 0;\n        int t = 1;\n        while (s &lt;= 1ll * N * M) {\n            int last_i = s / M;\n            int last_j = s % M;\n            s += (1ll &lt;&lt; (t - 1));\n            int i = (s - 1) / M;\n            int j = (s - 1) % M;\n\n            if (i == last_i &amp;&amp; x1 &lt;= i &amp;&amp; i &lt;= x2) {\n                ans += 1ll * max(0, min(y2, j) - max(last_j - 1, y1 - 1)) * t;\n            } else {\n                if (x1 &lt;= last_i &amp;&amp; last_i &lt;= x2) {\n                    ans += 1ll * max(y2 - max(last_j - 1, y1 - 1), 0) * t;\n                }\n                if (x1 &lt;= i &amp;&amp; i &lt;= x2) {\n                    ans += 1ll * max(min(j, y2) - y1 + 1, 0) * t;\n                }\n                ans += 1ll * max(min(i - 1, x2) - max(x1 - 1, last_i), 0)\n                     * (y2 - y1 + 1) * t;\n            }\n            t++;\n        }\n\n        cout &lt;&lt; ans &lt;&lt; \"\\n\";\n    }\n    return 0;\n}\n</code></pre>","tags":["OJI","clasa IX"]},{"location":"olimpiada/solutii/OJI/2025/IX-teleportor/","title":"Solu\u021bia problemei Teleportor (OJI 2025, clasa a IX-a)","text":"<p>Observ\u0103m c\u0103 dac\u0103 avem dou\u0103 camere vecine pe linie sau coloan\u0103 numerotate cu \\(x\\) \u0219i \\(x+ 1\\), atunci nu trebuie s\u0103 folosim teleportorul pentru a traversa de la camerele numerotate cu \\(x\\) la camerele numerotate cu \\(x+ 1\\). Fie \\(P\\) num\u0103rul de valori \\(x\\) distincte pentru care exist\u0103 cel pu\u021bin dou\u0103 camere numerotate cu \\(x\\) \u0219i \\(x + 1\\) vecine pe linie sau coloan\u0103. Num\u0103rul minim de teleport\u0103ri necesare vizit\u0103rii tuturor camerelor este egal cu \\(K \u2212 P \u2212 1\\).</p>","tags":["OJI","clasa IX"]},{"location":"olimpiada/solutii/OJI/2025/IX-teleportor/#subtask-1","title":"Subtask 1","text":"<p>Pentru fiecare valoare \\(x\\) de la 1 la \\(K \u2212 1\\), parcurgem matricea pentru a depista dac\u0103 exist\u0103 cel pu\u021bin dou\u0103 celule vecine care sunt numerotate cu \\(x\\) respectiv \\(x+ 1\\). Complexitatea acestei solu\u021bii este \\(\\mathcal{O} (N^2 \\cdot Q \\cdot K)\\).</p>","tags":["OJI","clasa IX"]},{"location":"olimpiada/solutii/OJI/2025/IX-teleportor/#subtask-2","title":"Subtask 2","text":"<p>Parcurgem matricea \u0219i pentru fiecare celul\u0103 vom vizita cei 4 vecini ai ei. Dac\u0103 g\u0103sim pe celula curent\u0103 valoarea \\(x\\), iar \u00eentr-unul dintre vecini valoarea \\(x+ 1\\), vom marca acest lucru \u00eentr-un vector de apari\u021bii pe pozi\u021bia \\(x\\). Num\u0103rul de pozi\u021bii marcate \u00een vectorul de apari\u021bii va fi egal valoarea cu \\(P\\). Complexitatea acestei solu\u021bii este \\(\\mathcal{O} (N^2 \\cdot Q)\\).</p>","tags":["OJI","clasa IX"]},{"location":"olimpiada/solutii/OJI/2025/IX-teleportor/#subtask-3","title":"Subtask 3","text":"<p>Observ\u0103m ca fiecare valoare apare de la 1 la \\(K\\) exact o dat\u0103, mai pu\u021bin una singur\u0103, care apare de dou\u0103 ori. Fie \\(b\\) valoarea care apare de exact dou\u0103 ori la un moment dat. Orice transformare \\((i, j, c)\\) poate afecta doar o celul\u0103 cu proprietatea c\u0103 \\(A_{i, j} = b\\) \u00eenainte de transformare. Vom optimiza calculul lui \\(P\\) folosind aceast\u0103 observa\u021bie. La \u00eenceput vom parcurge matricea \u0219i vom calcula \\(P\\) consider\u00e2nd doar perechi de celule vecine numerotate cu valori \\(x\\) \u0219i \\(x+ 1\\) diferite de \\(b\\), dup\u0103 care vom considera \u0219i contribu\u021biile celor dou\u0103 celule care au valoarea egal\u0103 cu \\(b\\). Men\u021bin\u00e2nd aceast\u0103 strategie, putem actualiza valoarea lui \\(P\\) \u00een \\(\\mathcal{O}(1)\\) de la o transformare la alta, astfel se ob\u021bine o solu\u021bie de complexitate \\(\\mathcal{O} (N^2 + Q)\\).</p>","tags":["OJI","clasa IX"]},{"location":"olimpiada/solutii/OJI/2025/IX-teleportor/#subtask-4","title":"Subtask 4","text":"<p>Pe parcursul celor Q transform\u0103ri vom men\u021bine un vector de frecven\u021b\u0103 \\(F_x\\) = c\u00e2te perechi de celule vecine exist\u0103 pe care se afl\u0103 valoarea \\(x\\) respectiv \\(x+ 1\\). Valoarea lui \\(P\\) este dat\u0103 de num\u0103rul de valori nenule din \\(F\\) . Actualizarea unei celule presupune sc\u0103derea (dac\u0103 este cazul) unor valori \\(F_x\\), apoi cre\u0219terea (dac\u0103 este cazul) unor valori \\(F_x\\). De fiecare dat\u0103 c\u00e2nd un \\(F_x\\) devine 0, vom sc\u0103dea \\(P\\) cu 1, de fiecare dat\u0103 c\u00e2nd \\(F_x\\) devine nenul vom cre\u0219te \\(P\\) cu 1. Complexitatea acestei solu\u021bii este \\(\\mathcal{O} (N^2 + Q)\\) \u0219i ob\u021bine 100 de puncte.</p>","tags":["OJI","clasa IX"]},{"location":"olimpiada/solutii/OJI/2025/IX-teleportor/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie care ia punctajul maxim.</p> <pre><code>#include &lt;fstream&gt;\n\nusing namespace std;\nifstream f(\"teleportor.in\");\nofstream g(\"teleportor.out\");\nint n, k, i, j, c, nr, q, h, u;\nint a[1002][1002], v[1000003];\nint dx[4] = {-1, 0, 1, 0}, dy[4] = {0, -1, 0, 1};\n\nint main() {\n    f &gt;&gt; n &gt;&gt; k;\n    for (i = 1; i &lt;= n; i++) {\n        for (j = 1; j &lt;= n; j++) {\n            f &gt;&gt; a[i][j];\n        }\n    }\n    for (i = 0; i &lt;= n + 1; i++) {\n        a[0][i] = -1;\n        a[n + 1][i] = -1;\n        a[i][0] = -1;\n        a[i][n + 1] = -1;\n    }\n    for (i = 1; i &lt;= n; i++) {\n        for (j = 1; j &lt;= n; j++) {\n            for (h = 0; h &lt; 4; h++) {\n                if (a[i][j] == a[i + dx[h]][j + dy[h]] + 1) {\n                    v[a[i][j]]++;\n                }\n            }\n        }\n    }\n\n    for (i = 2; i &lt;= k; i++) {\n        if (v[i]) {\n            nr++;\n        }\n    }\n    g &lt;&lt; k - nr - 1 &lt;&lt; \"\\n\";\n\n    f &gt;&gt; q;\n    for (u = 1; u &lt;= q; u++) {\n        f &gt;&gt; i &gt;&gt; j &gt;&gt; c;\n        for (h = 0; h &lt; 4; h++) {\n            if (a[i][j] == a[i + dx[h]][j + dy[h]] + 1) {\n                v[a[i][j]]--;\n                if (v[a[i][j]] == 0) {\n                    nr--;\n                }\n            }\n        }\n        for (h = 0; h &lt; 4; h++) {\n            if (a[i][j] + 1 == a[i + dx[h]][j + dy[h]]) {\n                v[a[i + dx[h]][j + dy[h]]]--;\n                if (v[a[i + dx[h]][j + dy[h]]] == 0) {\n                    nr--;\n                }\n            }\n        }\n        a[i][j] = c;\n        for (h = 0; h &lt; 4; h++) {\n            if (a[i][j] == a[i + dx[h]][j + dy[h]] + 1) {\n                v[a[i][j]]++;\n                if (v[a[i][j]] == 1) {\n                    nr++;\n                }\n            }\n        }\n        for (h = 0; h &lt; 4; h++) {\n            if (a[i][j] + 1 == a[i + dx[h]][j + dy[h]]) {\n                v[a[i + dx[h]][j + dy[h]]]++;\n                if (v[a[i + dx[h]][j + dy[h]]] == 1) {\n                    nr++;\n                }\n            }\n        }\n\n        g &lt;&lt; k - nr - 1 &lt;&lt; \"\\n\";\n    }\n    return 0;\n}\n</code></pre>","tags":["OJI","clasa IX"]},{"location":"olimpiada/solutii/OJI/2025/V-palindrom/","title":"Solu\u021bia problemei palindrom (OJI 2025, clasa a V-a)","text":"","tags":["OJI","clasa V"]},{"location":"olimpiada/solutii/OJI/2025/V-palindrom/#cerinta-1","title":"Cerin\u021ba 1","text":"<p>\u00cen continuare vom descrie rezolvarea pentru un singur num\u0103r. Pentru rezolvarea problemei se aplic\u0103 algoritmul de mai jos \u00een mod repetat, de \\(N\\) ori.</p> <p>Pentru rezolvarea primei cerin\u021be vom elimina simultan prima \u0219i ultima cifr\u0103 a num\u0103rului c\u00e2t timp acestea coincid \u0219i num\u0103rul are cel pu\u021bin dou\u0103 cifre. La final, dac\u0103 num\u0103rul r\u0103mas este 0 sau are o cifr\u0103, atunci putem afirma c\u0103 num\u0103rul ini\u021bial era palindrom.</p>","tags":["OJI","clasa V"]},{"location":"olimpiada/solutii/OJI/2025/V-palindrom/#cerinta-2","title":"Cerin\u021ba 2","text":"<p>Pentru rezolvarea celei de-a doua cerin\u021be, observ\u0103m c\u0103 opera\u021bia de inserare a unei cifre \u00een num\u0103rul dat \u0219i verificarea ulterioar\u0103 a propriet\u0103 \u021bii de palindrom este echivalent\u0103 cu opera\u021bia de \u0219tergere a unei cifre din num\u0103rul dat \u0219i verificarea propriet\u0103 \u021bii de palindrom a num\u0103rului astfel ob\u021binut.</p> <p>\u00cen plus, observ\u0103m c\u0103 \u00een orice num\u0103r palindrom putem insera o cifr\u0103 (\u00een mijlocul s\u0103u) astfel \u00eenc\u00e2t num\u0103rul nou ob\u021binut s\u0103 fie tot palindrom.</p> <p>Deci, orice num\u0103r care respect\u0103 prima cerin\u021b\u0103 o respect\u0103 \u0219i pe a doua.</p> <p>Pentru a determina eficient care cifr\u0103 ar trebui \u0219tears\u0103, vom efectua urm\u0103torul algoritm:</p> <ol> <li>vom elimina simultan prima \u0219i ultima cifr\u0103 a num\u0103rului c\u00e2t timp acestea    coincid \u0219i num\u0103rul are cel pu\u021bin dou\u0103 cifre;</li> <li>dac\u0103 num\u0103rul r\u0103mas este 0 sau are o cifr\u0103, atunci putem spune c\u0103 r\u0103spunsul la    cerin\u021b\u0103 este afirmativ;</li> <li>altfel vom investiga dou\u0103 cazuri:<ul> <li>dac\u0103 elimin\u0103m prima cifr\u0103;</li> <li>dac\u0103 elimin\u0103m ultima cifr\u0103;</li> </ul> </li> <li>\u00een ambele cazuri, dup\u0103 eliminarea cifrei corespunz\u0103toare, vom repeta pa\u0219ii    (1) \u0219i (2);</li> <li>dac\u0103 la final num\u0103rul r\u0103mas are mai mult de o cifr\u0103, atunci r\u0103spunsul la    cerin\u021b\u0103 este negativ;</li> </ol>","tags":["OJI","clasa V"]},{"location":"olimpiada/solutii/OJI/2025/V-palindrom/#cerinta-3","title":"Cerin\u021ba 3","text":"<p>Pentru rezolvarea celei de-a treia cerin\u021be, observ\u0103m c\u0103 opera\u021bia de inserare a dou\u0103 cifre \u00een num\u0103rul dat \u0219i verificarea ulterioar\u0103 a propriet\u0103\u021bii de palindromicitate este echivalent\u0103 cu opera\u021bia de \u0219tergere a dou\u0103 cifre din num\u0103rul dat \u0219i verificarea propriet\u0103\u021bii de palindromicitate a num\u0103rului astfel ob\u021binut. \u00cen plus, observ\u0103m c\u0103 \u00een orice num\u0103r palindrom putem insera o cifr\u0103 (\u00een mijlocul s\u0103u) astfel \u00eenc\u00e2t num\u0103rul nou ob\u021binut s\u0103 fie tot palindrom.</p> <p>Deci, orice num\u0103r care respect\u0103 a doua cerin\u021b\u0103 o respect\u0103 \u0219i pe a treia. Pentru a determina eficient care cifre ar trebui \u0219terse, vom efectua urm\u0103torul algoritm:</p> <ul> <li>pentru \u0219tergerea primei cifre, vom efectua pa\u0219ii (1), (2) \u0219i (3);</li> <li>pentru \u0219tergerea celei de-a doua cifre, vom efectua din nou pa\u0219ii (1), (2) \u0219i   (3);</li> <li>pentru determinarea r\u0103spunsului, vom efectua iar\u0103\u0219i pa\u0219ii (1), (2) \u0219i (5).</li> </ul> <p>Observa\u021bi c\u0103, efectu\u00e2nd de dou\u0103 ori pasul (3), vom ajunge s\u0103 investig\u0103m 4 scenarii:</p> <ol> <li>la prima nepotrivire elimin\u0103m prima cifr\u0103 iar la a doua nepotrivire elimin\u0103m    din nou prima cifr\u0103;</li> <li>la prima nepotrivire elimin\u0103m prima cifr\u0103 iar la a doua nepotrivire elimin\u0103m    a doua cifr\u0103;</li> <li>la prima nepotrivire elimin\u0103m a doua cifr\u0103 iar la a seconda nepotrivire    elimin\u0103m prima cifr\u0103;</li> <li>la prima nepotrivire elimin\u0103m a doua cifr\u0103 iar la a doua nepotrivire elimin\u0103m    din nou a doua cifr\u0103.</li> </ol> <p>Pentru a evita cazul particular \u00een care nu avem voie s\u0103 ad\u0103ug\u0103m cifra 0 la \u00eenceputul num\u0103rului ini\u021bial, atunci c\u00e2nd elimin\u0103m ultima cifr\u0103 trebuie s\u0103 verific\u0103m \u0219i s\u0103 ignor\u0103m cazul \u00een care num\u0103rul r\u0103mas pe care lucr\u0103m este num\u0103rul original \u0219i ultima sa cifr\u0103 este 0.</p> <p>Complexitatea timp: \\(\\mathcal{O}(N \\cdot X)\\)</p>","tags":["OJI","clasa V"]},{"location":"olimpiada/solutii/OJI/2025/V-palindrom/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie care ia punctajul maxim.</p> <pre><code>#include &lt;fstream&gt;\n\nint main() {\n    std::ifstream fisier_in(\"palindrom.in\");\n    std::ofstream fisier_out(\"palindrom.out\");\n    int C, N;\n    fisier_in &gt;&gt; C &gt;&gt; N;\n    int raspuns = 0;\n    for (int i = 0; i &lt; N; i++) {\n        int nr;\n        fisier_in &gt;&gt; nr;\n        bool este_bun = false;\n        int nr_original = nr;\n        // Calculez puterea lui 10 care are la fel de multe cifre ca \u0219i num\u0103rul\n        // citit. M\u0103 va ajuta s\u0103 aflu care este prima cifr\u0103 a num\u0103rului \u0219i\n        // eventual s\u0103 o elimin.\n        int pow10 = 1;\n        while (nr / pow10 &gt; 9) {\n            pow10 *= 10;\n        }\n        // C\u00e2t timp num\u0103rul are cel pu\u021bin dou\u0103 cifre iar\n        // prima \u0219i ultima cifr\u0103 a num\u0103rului coincid, le elimin.\n        while (pow10 &gt; 1 &amp;&amp; nr / pow10 == nr % 10) {\n            nr %= pow10;\n            nr /= 10;\n            pow10 /= 100;\n        }\n        if (pow10 &lt;= 1) {\n            // Dac\u0103 num\u0103rul r\u0103mas este 0 sau are o singur\u0103 cifr\u0103, atunci\n            // indiferent de cerin\u021ba pe care trebuie s\u0103 o rezolv, r\u0103spunsul este\n            // afirmativ.\n            este_bun = true;\n        } else if (C &gt;= 2) {\n            // Dac\u0103 cerin\u021ba este 2 sau 3, trebuie s\u0103 investighez dou\u0103 scenarii:\n            // (dac\u0103 op1 == 1) din num\u0103rul r\u0103mas voi elimina prima cifr\u0103;\n            // (dac\u0103 op1 == 2) din num\u0103rul r\u0103mas voi elimina ultima cifr\u0103.\n            for (int op1 = 1; op1 &lt;= 2; op1++) {\n                // Voi lucra pe o copie a num\u0103rului.\n                int copie1_nr = nr;\n                if (op1 == 1) {\n                    copie1_nr %= pow10;\n                } else {\n                    // Dac\u0103 \u00eencerc s\u0103 elimin ultima cifr\u0103 din num\u0103rul original\n                    // \u0219i aceasta este 0, atunci \u00eenseamn\u0103 c\u0103 ceea ce fac este\n                    // echivalent cu a insera o cifr\u0103 de 0 \u00een fa\u021ba num\u0103rului\n                    // original, ceea ce nu este permis.\n                    if (copie1_nr == nr_original &amp;&amp; copie1_nr % 10 == 0) {\n                        continue;\n                    }\n                    copie1_nr /= 10;\n                }\n                int copie1_pow10 = pow10 / 10;\n                // C\u00e2t timp num\u0103rul are cel pu\u021bin dou\u0103 cifre iar\n                // prima \u0219i ultima cifr\u0103 a num\u0103rului coincid, le elimin.\n                while (copie1_pow10 &gt; 1\n                       &amp;&amp; copie1_nr / copie1_pow10 == copie1_nr % 10) {\n                    copie1_nr %= copie1_pow10;\n                    copie1_nr /= 10;\n                    copie1_pow10 /= 100;\n                }\n                if (copie1_pow10 &lt;= 1) {\n                    // Dac\u0103 num\u0103rul r\u0103mas este 0 sau are o singur\u0103 cifr\u0103, atunci\n                    // indiferent de cerin\u021ba pe care trebuie s\u0103 o rezolv,\n                    // r\u0103spunsul este afirmativ.\n                    este_bun = true;\n                } else if (C == 3) {\n                    // Dac\u0103 cerin\u021ba este 3, trebuie s\u0103 investighez dou\u0103\n                    // scenarii: (dac\u0103 op2 == 1) din num\u0103rul r\u0103mas voi elimina\n                    // prima cifr\u0103; (dac\u0103 op2 == 2) din num\u0103rul r\u0103mas voi\n                    // elimina ultima cifr\u0103.\n                    for (int op2 = 1; op2 &lt;= 2; op2++) {\n                        // Voi lucra pe o a doua copie a num\u0103rului.\n                        int copie2_nr = copie1_nr;\n                        if (op2 == 1) {\n                            copie2_nr %= copie1_pow10;\n                        } else {\n                            copie2_nr /= 10;\n                        }\n                        int copie2_pow10 = copie1_pow10 / 10;\n                        // C\u00e2t timp num\u0103rul are cel pu\u021bin dou\u0103 cifre iar\n                        // prima \u0219i ultima cifr\u0103 a num\u0103rului coincid, le elimin.\n                        while (copie2_pow10 &gt; 1\n                               &amp;&amp; copie2_nr / copie2_pow10 == copie2_nr % 10) {\n                            copie2_nr %= copie2_pow10;\n                            copie2_nr /= 10;\n                            copie2_pow10 /= 100;\n                        }\n                        // Trebuie s\u0103 rezolv cerin\u021ba 2 \u0219i verific dac\u0103 am r\u0103mas\n                        // cu un num\u0103r de o singur\u0103 cifr\u0103 sau cu 0.\n                        if (copie2_pow10 &lt;= 1) {\n                            este_bun = true;\n                        }\n                    }\n                }\n            }\n        }\n        if (este_bun) {\n            raspuns++;\n            // fisier_out &lt;&lt; nr_original;\n        }\n    }\n    fisier_out &lt;&lt; raspuns;\n    return 0;\n}\n</code></pre>","tags":["OJI","clasa V"]},{"location":"olimpiada/solutii/OJI/2025/V-semafoare/","title":"Solu\u021bia problemei semafoare (OJI 2025, clasa a V-a)","text":"","tags":["OJI","clasa V"]},{"location":"olimpiada/solutii/OJI/2025/V-semafoare/#cerinta-1","title":"Cerin\u021ba 1","text":"<p>Pentru cazurile \u00een care \\(T_1 = 0\\) \u0219i \\(T_2 = 0\\), se poate calcula, cu o formul\u0103 simpl\u0103, dup\u0103 c\u00e2te secunde se face verde la unul dintre cele dou\u0103 semafoare:</p> <ul> <li>Calcul\u0103m pentru fiecare semafor totalul secundelor care trebuie s\u0103 treac\u0103 p\u00e2n\u0103   c\u00e2nd se aprinde galben dup\u0103 ro\u0219u, iar apoi verde dup\u0103 galben.</li> <li>Afi\u0219\u0103m timpul minim astfel calculat.</li> </ul> <p>Algoritm:</p> <ul> <li>calcul\u0103m totalul de secunde necesare fiec\u0103rui semafor</li> <li>afi\u0219\u0103m timpul minim calculat, care este \\(\\min(R_1 + G_1, R_2 + G_2)\\).</li> </ul> <p>Pentru cazurile \u00een care \\(T_1 + T_2 &gt; 0\\) (cel pu\u0163in unul dintre cele dou\u0103 semafoare nu porne\u0219te la momentul curent), observ\u0103m c\u0103 fiecare semafor func\u0163ioneaz\u0103 pe baza unui ciclu temporar ce se repet\u0103 continuu. O solu\u0163ie posibil\u0103 const\u0103 \u00een parcurgerea urm\u0103torilor pa\u0219i:</p> <ul> <li> <p>calcul\u0103m durata ciclului pentru fiecare semafor: \\(c_1 = R_1 + G_1 + V_1 + G_1\\)   \u0219i \\(c_2 = R_2 + G_2 + V_2 + G_2\\)</p> </li> <li> <p>calcul\u0103m pozi\u021bia \u00een ciclul fiec\u0103rui semafor: \\(T_1 = T_1 \\mod c_1\\) \u0219i \\(T_2 =   T_2 \\mod c_2\\)</p> </li> <li> <p>determin\u0103m timpul p\u00e2n\u0103 se aprinde verde la primul semafor (\u00eel vom denota cu \\(tv_1\\)):</p> \\[ tv_1 = \\begin{dcases}  R_1 + G_1 - T_1 &amp; \\text{dac\u0103}~T_1 &lt; R_1 + G_1\\\\  0               &amp; \\text{dac\u0103}~T_1 &lt; R_1 + G_1 + V_1\\\\  c_1 - T_1 + R_1 + G_1 &amp; \\text{\u00een caz contrar} \\end{dcases} \\] </li> <li> <p>determin\u0103m timpul \\(tv_2\\) p\u00e2n\u0103 c\u00e2nd se aprinde verde la cel de-al doilea   semafor (similar)</p> </li> <li>afi\u0219\u0103m \\(\\min(tv_1, tv_2)\\)</li> </ul>","tags":["OJI","clasa V"]},{"location":"olimpiada/solutii/OJI/2025/V-semafoare/#cerinta-2","title":"Cerin\u021ba 2","text":"<p>O solu\u0163ie posibil\u0103 const\u0103 \u00een parcurgerea urm\u0103torilor pa\u015fi:</p> <ul> <li>Calcul\u0103m durata total\u0103 a ciclului pentru fiecare semafor, similar cu cerin\u0163a   anterioar\u0103.</li> <li> <p>Identific\u0103m pentru fiecare semafor culoarea aprins\u0103 la momentul curent. De   exemplu, la momentul curent \\(t_1\\), culoarea primului semafor se poate   determina astfel:</p> <pre><code>dac\u0103 t1 &lt; R1\n    atunci culoare1 = 0 (Ro\u0219u)\naltfel\n    dac\u0103 t1 &lt; R1 + G1\n        atunci culoare1 = 1 (Galben)\n    altfel\n        dac\u0103 t1 &lt; R1 + G1 + V1\n            atunci culoare1 = 2 (Verde)\n        altfel\n            culoare1 = 1 (Galben)\n</code></pre> </li> <li> <p>Simul\u0103m scurgerea timpului, din secund\u0103 \u00een secund\u0103, p\u00e2n\u0103 c\u00e2nd la ambele   semafoare se va observa aceea\u0219i culoare.</p> </li> </ul>","tags":["OJI","clasa V"]},{"location":"olimpiada/solutii/OJI/2025/V-semafoare/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie care ia punctajul maxim.</p> <pre><code>#include &lt;fstream&gt;\nusing namespace std;\nifstream fin(\"semafoare.in\");\nofstream fout(\"semafoare.out\");\nint C;\nint R1, G1, V1, R2, G2, V2, T1, T2;\nint main() {\n    fin &gt;&gt; C;\n    fin &gt;&gt; R1 &gt;&gt; G1 &gt;&gt; V1 &gt;&gt; R2 &gt;&gt; G2 &gt;&gt; V2 &gt;&gt; T1 &gt;&gt; T2;\n    if (C == 1 &amp;&amp; T1 == 0 &amp;&amp; T2 == 0) {\n        if (R1 + G1 &lt; R2 + G2) {\n            fout &lt;&lt; (R1 + G1) &lt;&lt; '\\n';\n        } else {\n            fout &lt;&lt; (R2 + G2) &lt;&lt; '\\n';\n        }\n    }\n    int ciclu1 = R1 + G1 + V1 + G1;\n    int ciclu2 = R2 + G2 + V2 + G2;\n    T1 = T1 % ciclu1;\n    T2 = T2 % ciclu2;\n    if (C == 1 &amp;&amp; T1 + T2 &gt; 0) {\n        int timp_la_verde1;\n        if (T1 &lt; R1 + G1) {\n            timp_la_verde1 = R1 + G1 - T1;\n        } else if (T1 &lt; R1 + G1 + V1) {\n            timp_la_verde1 = 0;\n        } else {\n            timp_la_verde1 = ciclu1 - T1 + R1 + G1;\n        }\n\n        int timp_la_verde2;\n        if (T2 &lt; R2 + G2) {\n            timp_la_verde2 = R2 + G2 - T2;\n        } else if (T2 &lt; R2 + G2 + V2) {\n            timp_la_verde2 = 0;\n        } else {\n            timp_la_verde2 = ciclu2 - T2 + R2 + G2;\n        }\n\n        if (timp_la_verde1 &lt; timp_la_verde2) {\n            fout &lt;&lt; timp_la_verde1 &lt;&lt; '\\n';\n        } else {\n            fout &lt;&lt; timp_la_verde2 &lt;&lt; '\\n';\n        }\n    } else if (C == 2) {\n        int culoare1, culoare2;\n        int timp_minim = 0;\n        bool gasit = false;\n        while (!gasit) {\n            // Calcul\u0103m culoarea pentru fiecare semafor la timpul curent\n            int t1 = (T1 + timp_minim) % ciclu1;\n            int t2 = (T2 + timp_minim) % ciclu2;\n            // Determin\u0103m culoarea semaforului 1\n            if (t1 &lt; R1) {\n                culoare1 = 0;  // Rosu\n            } else if (t1 &lt; R1 + G1) {\n                culoare1 = 1;  // Galben\n            } else if (t1 &lt; R1 + G1 + V1) {\n                culoare1 = 2;  // Verde\n            } else {\n                culoare1 = 1;  // Galben\n            }\n            // Determin\u0103m culoarea semaforului 2\n            if (t2 &lt; R2) {\n                culoare2 = 0;  // Rosu\n            } else if (t2 &lt; R2 + G2) {\n                culoare2 = 1;  // Galben\n            } else if (t2 &lt; R2 + G2 + V2) {\n                culoare2 = 2;  // Verde\n            } else {\n                culoare2 = 1;  // Galben\n            }\n            // Verific\u0103m dac\u0103 cele dou\u0103 semafoare au aceea\u0219i culoare\n            if (culoare1 == culoare2) {\n                gasit = true;\n            } else {\n                timp_minim++;\n            }\n        }\n        fout &lt;&lt; timp_minim &lt;&lt; endl;\n    }\n    return 0;\n}\n</code></pre>","tags":["OJI","clasa V"]},{"location":"olimpiada/solutii/OJI/2025/VI-avion/","title":"Solu\u021bia problemei avion (OJI 2025, clasa a VI-a)","text":"","tags":["OJI","clasa VI"]},{"location":"olimpiada/solutii/OJI/2025/VI-avion/#cerinta-1-50p","title":"Cerin\u021ba 1 - 50p","text":"<p>Av\u00e2nd \u00een vedere c\u0103 num\u0103rul de r\u00e2nduri \\(R\\) este par, exist\u0103 acela\u0219i num\u0103r de r\u00e2nduri \u00een fiecare jum\u0103tate a avionului. Este suficient s\u0103 fie comparat cu \\(R/2\\) r\u00e2ndul de pe biletul fiec\u0103rui pasager. Dac\u0103 r\u00e2ndul \\(r\\) este \u00een prima jum\u0103tate a avionului (\\(r \u2264 R/2\\)) se va afi\u0219a 1, altfel se va afi\u0219a 2.</p>","tags":["OJI","clasa VI"]},{"location":"olimpiada/solutii/OJI/2025/VI-avion/#cerinta-2-50p","title":"Cerin\u021ba 2 - 50p","text":"<p>Pentru fiecare pasager se va compara \u0219i de aceast\u0103 dat\u0103 r\u00e2ndul de pe bilet cu mijlocul avionului (\\(R/2\\)). Dac\u0103 r\u00e2ndul \\(r \u2264 R/2\\) \u0219i pasagerul urc\u0103 \u00een avion pe scara 1, la suma total\u0103 se va ad\u0103uga r\u00e2ndul de pe bilet, iar \u00een caz contrar, c\u00e2nd pasagerul intr\u0103 pe scara 2, el va parcurge p\u00e2n\u0103 la r\u00e2ndul de pe bilet distan\u021ba \\(R \u2212 r + 1\\), care se va ad\u0103uga la suma total\u0103. Apoi, pasagerul va mai parcurge 1, 2 sau 3 metri \u00een func\u021bie de locul ocupat pe r\u00e2ndul de pe bilet: 1 metru dac\u0103 locul este 3 sau 4, 2 metri dac\u0103 locul este 2 sau 5 \u0219i 3 metri dac\u0103 locul este 1 sau 6. Aceste valori se adaug\u0103 \u0219i ele la suma total\u0103. Av\u00e2nd \u00een vedere c\u0103 fiecare dintre cei \\(n\\) pasageri parcurge 3 metri de la intrarea \u00een avion p\u00e2n\u0103 la culoarul central, la suma total\u0103 se mai adaug\u0103 \\(3 \\cdot n\\) metri.</p>","tags":["OJI","clasa VI"]},{"location":"olimpiada/solutii/OJI/2025/VI-avion/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie care ia punctajul maxim.</p> <pre><code>/// Pracsiu Dan\n#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n\nifstream fin(\"avion.in\");\nofstream fout(\"avion.out\");\n\nint a[2001];\n\nint main() {\n    int total, task, NR, n, i, x, y;\n    fin &gt;&gt; task &gt;&gt; NR &gt;&gt; n;\n    if (task == 1) {\n        for (i = 1; i &lt;= n; i++) {\n            fin &gt;&gt; x &gt;&gt; y;\n            if (x &lt;= NR / 2) {\n                a[i] = 1;\n            } else {\n                a[i] = 2;\n            }\n        }\n        for (i = 1; i &lt;= n; i++) {\n            fout &lt;&lt; a[i] &lt;&lt; \"\\n\";\n        }\n    } else {\n        total = 0;\n        for (i = 1; i &lt;= n; i++) {\n            fin &gt;&gt; x &gt;&gt; y;\n            if (x &lt;= NR / 2) {\n                total += (3 + x);\n            } else {\n                total += (3 + (NR - x + 1));\n            }\n            if (y &lt;= 3) {\n                total += (4 - y);\n            } else {\n                total += (y - 3);\n            }\n        }\n        fout &lt;&lt; total &lt;&lt; \"\\n\";\n    }\n    return 0;\n}\n</code></pre>","tags":["OJI","clasa VI"]},{"location":"olimpiada/solutii/OJI/2025/VI-mandatar/","title":"Solu\u021bia problemei mandatar (OJI 2025, clasa a VI-a)","text":"","tags":["OJI","clasa VI"]},{"location":"olimpiada/solutii/OJI/2025/VI-mandatar/#cerinta-1-50p","title":"Cerin\u021ba 1 - 50p","text":"<p>Se re\u021bin numerele citite din fi\u0219ierul de intrare \u00een \u0219irul \\(A\\) - tablou unidimensional (vector). Pentru determinarea celui mai mare num\u0103r prim din \u0219irul \\(A\\) se folose\u0219te un algoritm de verificare a primalit\u0103\u021bii unui num\u0103r. \u00cen func\u021bie de implementarea aleas\u0103 pentru verificarea primalit\u0103\u021bii se pot ob\u021bine punctaje gradual, \u00eentre 20-50p (\\(\\mathcal{O}(n)\\), \\(\\mathcal{O}(\\sqrt{n})\\), ciurul lui Eratostene).</p>","tags":["OJI","clasa VI"]},{"location":"olimpiada/solutii/OJI/2025/VI-mandatar/#cerinta-2-30p","title":"Cerin\u021ba 2 - 30p","text":"<p>Pe baza \u0219irului \\(A\\), construim \u0219irul \\(B\\) folosind un algoritm de descompunere \u00een factori primi, unde fiecare element al \u0219irului \\(B_i\\) este cel mai mic num\u0103r natural care are aceia \u0219i factori primi cu \\(A_i\\), cu \\(1 \\leq i \\leq n\\).</p> <p>Algoritmul de descompunere \u00een factori primi va determina, pentru fiecare element al \u0219irului \\(A\\), at\u00e2t elementele \u0219irului \\(B\\) c\u00e2t \u0219i num\u0103rul de factori primi al fiec\u0103rui element \\(B_i\\) . Se va re\u021bine cel mai mare num\u0103r al \u0219irului \\(B\\) care are un num\u0103r maxim de factori primi.</p> <p>\u00cen func\u021bie de implementarea aleas\u0103 pentru descompunerea \u00een factori primi se pot ob\u021bine punctaje gradual, \u00eentre 10-30p (\\(\\mathcal{O}(n)\\), \\(\\mathcal{O}(\\sqrt{n})\\), ciurul lui Eratostene sau optimizari ale factoriz\u0103rii).</p> <p>Observa\u021bie</p> <p>Printr-un algoritm de descompunere \u00een factori primi se poate rezolva at\u00e2t Cerin\u021ba 1 c\u00e2t \u0219i Cerin\u021ba 2.</p>","tags":["OJI","clasa VI"]},{"location":"olimpiada/solutii/OJI/2025/VI-mandatar/#cerinta-3-20p","title":"Cerin\u021ba 3 - 20p","text":"<p>Pentru determinarea lungimii maxime a unei secven\u021be mandatorii din \u0219irul \\(B\\) se poate folosi o structur\u0103 for ce parcurge numerele mandatare. Acestea pot fi: 2, 3, 5, 6 sau 7.</p> <pre><code>for (int x = 2; x &lt;= 7; x++) {\n    if (x == 4) continue;\n\n    int k = 0;\n    bool ok = false;\n\n    for (int i = 1; i &lt;= n; i++) {\n        if (B[i] % x == 0) {\n            k++;\n\n            if (B[i] == x) {\n                ok = true;\n            }\n\n            if (ok &amp;&amp; k &gt; lgmax) {\n                lgmax = k;\n            }\n        } else {\n            k = 0;\n            ok = false;\n        }\n    }\n}\n</code></pre>","tags":["OJI","clasa VI"]},{"location":"olimpiada/solutii/OJI/2025/VI-mandatar/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie care ia punctajul maxim.</p> <pre><code>//////Pit_Rada Ionel-Vasile\n#include &lt;fstream&gt;\nusing namespace std;\nifstream fin(\"mandatar.in\");\nofstream fout(\"mandatar.out\");\nint Ce, N, A, B[100002], P[5002], nP;\nint pmax = 0, bmax, nrmax = 0, lg, nr, x, y, z, lgmax;\n\nint main() {\n    /// depozitez numerele prime &lt;=3200 in vectorul P[]\n    /// sunt suficiente pentru a verifica primalitatea oricarui numar &lt;= 10^7\n    P[1] = 2;\n    P[2] = 3;\n    P[3] = 5;\n    P[4] = 7;\n    nP = 4;\n    for (int i = 11; i &lt;= 3200; i += 2) {\n        int ok = 1;\n        /// verific daca i este prim folosind numere prime din P[]\n        for (int j = 1; j &lt;= nP &amp;&amp; P[j] * P[j] &lt;= i; j++) {\n            if (i % P[j] == 0) {\n                ok = 0;\n                break;\n            }\n        }\n        if (ok == 1) {\n            P[++nP] = i;\n        }\n    }\n    fin &gt;&gt; Ce &gt;&gt; N;\n    for (int i = 1; i &lt;= N; i++) {\n        fin &gt;&gt; A;\n        /// descompunere in factori primi\n        x = A;\n        y = 1;\n        z = 0;\n        for (int j = 1; P[j] * P[j] &lt;= x; j++) {\n            if (x % P[j] == 0) {\n                z++;\n                y *= P[j];\n                while (x % P[j] == 0) {\n                    x /= P[j];\n                }\n            }\n        }\n        if (x &gt; 1) {\n            z++;\n            y *= x;\n        }\n        B[i] = y;\n        if (z == 1) {\n            if (A &gt; pmax) {\n                pmax = A;\n            }\n        }\n        if (z &gt; nrmax) {\n            nrmax = z;\n            bmax = y;\n        } else {\n            if (z == nrmax &amp;&amp; y &gt; bmax) {\n                bmax = y;\n            }\n        }\n    }\n    lgmax = 0;\n    /// pentru fiecare 2&lt;=y&lt;=7 calculez cea mai buna lungime a unei secvente\n    /// mandatare\n    for (int y = 7; y &gt;= 2; y--) {\n        if (y != 4) {\n            lg = 0;\n            nr = 0;\n            for (int i = 1; i &lt;= N; i++) {\n                if (B[i] % y == 0) {\n                    lg++;\n                    if (B[i] == y) {\n                        nr = 1;\n                    }\n                    if (nr == 1 &amp;&amp; lg &gt; lgmax) {\n                        lgmax = lg;\n                    }\n                } else {\n                    lg = 0;\n                    nr = 0;\n                }\n            }\n        }\n    }\n    if (Ce == 1) {\n        fout &lt;&lt; pmax;\n    }\n    if (Ce == 2) {\n        fout &lt;&lt; bmax;\n    }\n    if (Ce == 3) {\n        fout &lt;&lt; lgmax;\n    }\n    return 0;\n}\n</code></pre>","tags":["OJI","clasa VI"]},{"location":"olimpiada/solutii/OJI/2025/VII-prietenie/","title":"Solu\u021bia problemei prietenie (OJI 2025, clasa a VII-a)","text":"","tags":["OJI","clasa VII"]},{"location":"olimpiada/solutii/OJI/2025/VII-prietenie/#cerinta-1","title":"Cerin\u021ba 1","text":"<p>O observa\u021bie necesar\u0103 pentru rezolvarea primei cerin\u021be este c\u0103 \\((a_i - b_j)^2\\) se poate scrie sub forma \\(a_i^2 - 2a_i b_j + b_j^2\\), iar o alt\u0103 observa\u021bie e c\u0103 fiecare num\u0103r din \u0219irul \\(a\\), va fi implicat \u00een \\(n\\) sume (cu fiecare element din \u0219irul \\(b\\)). Deci pentru fiecare element \\(a_i\\), vom avea suma:</p> \\[ \\begin{align*} (a_i - b_1)^2 + (a_i - b_2)^2 + ... + (a_i - b_n)^2 &amp;= \\sum_{j = 1}^n (a_i - b_j)^2\\\\ &amp;= \\sum_{j = 1}^n (a_i^2 - 2a_i b_j + b_j^2)\\\\ &amp;= \\sum_{j = 1}^n a_i^2 - 2a_i \\sum_{j = 1}^n b_j + \\sum_{j = 1}^n b_j^2\\\\ &amp;= n \\cdot a_i^2 - 2a_i \\cdot S_1 + S_2 \\end{align*} \\] <p>unde \\(S_1 = b_1 + b_2 + ... + b_n\\) este constant \u0219i se va calcula separat. Similar, \\(S_2 = b_1^2 + b_2^2 + ... + b_n^2\\). Astfel se vor calcula pentru fiecare termen al \u0219irului \\(a\\) aceste sume \u0219i se vor ad\u0103uga la suma total\u0103. Complexitatea final\u0103 este \\(\\mathcal{O}(n)\\).</p>","tags":["OJI","clasa VII"]},{"location":"olimpiada/solutii/OJI/2025/VII-prietenie/#cerinta-2","title":"Cerin\u021ba 2","text":"<p>Pentru fiecare element \\(a_i\\) al \u0219irului \\(a\\), vom c\u0103uta c\u00e2te elemente \\(b_j\\) din \u0219irul \\(b\\) au proprietatea c\u0103 \\((a_i - b_j)^2\\) este fie mai mic sau egal cu \\(X\\) , fie mai mare sau egal cu \\(Y\\) . Pentru a ob\u021bine acest lucru se vor calcula frecven\u021bele din \u0219irul \\(b\\) \u0219i sumele par\u021biale pe ele. A\u0219adar, consider\u0103m \\(f_i\\) frecven\u021ba fiec\u0103rui num\u0103r din \u0219irul \\(b\\), iar \\(F_i = f_1 + f_2 + ... + f_i\\) . Vom calcula c\u00e2te numere avem astfel \u00eenc\u00e2t \\((a_i - b_j)^2 \\leq X\\) \u0219i \\(|b_j \u2212 a_i| \\leq \\sqrt{X}\\) , adic\u0103 \\(a_i - \\sqrt{X} \\leq b_j \\leq a_i + \\sqrt{X}\\). Pentru a calcula num\u0103rul de numere dintre aceste 2 valori se va folosi \u0219irul de sume partiale \\(F_i\\) . Acum vom calcula c\u00e2te numere din \u0219irul \\(b\\) exist\u0103 astfel \u00eenc\u00e2t \\((a_i - b_j)^2 \\geq Y\\) , adic\u0103 \\(|a_i - b_j| \\geq \\sqrt{Y}\\), adic\u0103 \\(b_j - a_i \\geq \\sqrt{Y}\\) sau \\(b_j - a_i \\leq -\\sqrt{Y}\\), deci \\(b_j \\geq a_i + \\sqrt{Y}\\) sau \\(b_j \\leq a_i - \\sqrt{Y}\\), cu ajutorul \u0219irului \\(F_i\\) . Complexitatea final\u0103 este \\(\\mathcal{O}(n)\\).</p>","tags":["OJI","clasa VII"]},{"location":"olimpiada/solutii/OJI/2025/VII-prietenie/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie care ia punctajul maxim.</p> <pre><code>/* Mihai Marcu, Student TU Delft*/\n#include &lt;bits/stdc++.h&gt;\n\nusing namespace std;\n\nifstream f(\"prietenie.in\");\nofstream g(\"prietenie.out\");\n\nint n, c;\nint p, q;\nint a[200005];\nint b[200005];\n\nlong long sumA;\nlong long rez1;\n\nint rez[200005];\nint frecvB[300005];\nint sumpartFrecv[300005];\n\nint main() {\n    f &gt;&gt; c;\n    f &gt;&gt; n;\n    f &gt;&gt; p &gt;&gt; q;\n    for (int i = 1; i &lt;= n; ++i) {\n        f &gt;&gt; a[i];\n    }\n    for (int i = 1; i &lt;= n; ++i) {\n        f &gt;&gt; b[i];\n    }\n\n    if (c == 1) {\n        for (int i = 1; i &lt;= n; ++i) {\n            rez1 += 1LL * n * a[i] * a[i];\n            rez1 += 1LL * n * b[i] * b[i];\n            sumA += a[i];\n        }\n        for (int i = 1; i &lt;= n; ++i) {\n            rez1 -= 1LL * 2 * sumA * b[i];\n        }\n        g &lt;&lt; rez1;\n    } else {\n        for (int i = 1; i &lt;= n; ++i) {\n            frecvB[b[i]]++;\n        }\n\n        sumpartFrecv[0] = frecvB[0];\n        for (int i = 1; i &lt;= 300000; ++i) {\n            sumpartFrecv[i] = sumpartFrecv[i - 1] + frecvB[i];\n        }\n\n        int stQ, drQ, stP, drP;\n\n        for (int i = 1; i &lt;= n; ++i) {\n            stQ = -1;\n            drQ = -1;\n            stP = -1;\n            drP = -1;\n\n            stP = a[i] - min(a[i], (int)sqrt(p));\n            stQ = a[i] - min(a[i] + 1, (int)sqrt(q - 1) + 1);\n            drP = (int)sqrt(p) + a[i];\n            drQ = (int)sqrt(q - 1) + 1 + a[i];\n            int x = 0;\n            if (stQ &gt;= 0) {\n                x += sumpartFrecv[stQ];\n            }\n            if (stP &gt;= 0) {\n                x += (sumpartFrecv[a[i] - 1] - sumpartFrecv[stP - 1]);\n            }\n\n            x += (sumpartFrecv[drP] - sumpartFrecv[a[i] - 1]);\n            x += sumpartFrecv[30000] - sumpartFrecv[drQ - 1];\n            g &lt;&lt; x &lt;&lt; \" \";\n        }\n    }\n    return 0;\n}\n</code></pre>","tags":["OJI","clasa VII"]},{"location":"olimpiada/solutii/OJI/2025/VII-teren/","title":"Solu\u021bia problemei teren (OJI 2025, clasa a VII-a)","text":"","tags":["OJI","clasa VII"]},{"location":"olimpiada/solutii/OJI/2025/VII-teren/#cerinta-1","title":"Cerin\u021ba 1","text":"<p>Se citesc coordonatele de \u00eenceput ale \u00eens\u0103m\u00e2n\u021b\u0103rii \\(L_1\\), \\(C_1\\) \u0219i coordonatele de sf\u00e2r\u0219it \\(L_2\\), \\(C_2\\). Dac\u0103 \\(L_1 = L_2\\) la num\u0103rul de semin\u021be aruncate se adun\u0103 \\(1 + |C_1-C_2|\\), altfel se adun\u0103 \\(1 + |L_1-L_2|\\).</p>","tags":["OJI","clasa VII"]},{"location":"olimpiada/solutii/OJI/2025/VII-teren/#precalculari-pentru-cerinta-2-si-3","title":"Precalcul\u0103ri pentru cerin\u021ba 2 \u0219i 3","text":"<p>At\u00e2t pentru cerin\u021ba 2 c\u00e2t \u0219i pentru cerin\u021ba 3 se folosesc 5 matrici: matricea \\(o\\) pentru parcurgerile orizontale, \\(v\\) pentru cele verticale, \\(dp\\) pentru cele paralele cu diagonala principal\u0103, \\(ds\\) pentru parcurgerile paralele cu diagonala secundar\u0103. Pentru fiecare zbor/parcurgere se aplic\u0103 difference array. Deoarece parcurgerea este liniar\u0103 difference array se aplic\u0103 exact ca la vectori: Pentru parcurgerile orizontale (unde \\(L_1 = L_2\\)):</p> <pre><code>o[L1][min(C1, C2)]++;\no[L1][max(C1, C2) + 1]--;\n</code></pre> <p>Pentru parcurgerile verticale (unde \\(C_1 = C_2\\)):</p> <pre><code>v[min(L1, L2)][C1]++;\nv[max(L1, L2) + 1][C1]--;\n</code></pre> <p>Pentru parcurgerile paralele cu diagonala secundar\u0103 (unde \\(L_1 + C_1 = L_2 + C_2\\)): se interschimb\u0103 capetele a.\u00ee. \\(L_1 &lt; L_2\\) \u0219i apoi:</p> <pre><code>ds[L1][C1]++;\nds[L2 + 1][C2 - 1]--;\n</code></pre> <p>Pentru parcurgerile paralele cu diagonala principal\u0103: se interschimb\u0103 capetele a.\u00ee. \\(L_1 &lt; L_2\\) \u0219i apoi:</p> <pre><code>dp[L1][C1]++;\ndp[L2 + 1][C2 + 1]--;\n</code></pre> <p>Se parcurg matricele \u0219i se fac adun\u0103rile corespunz\u0103toare:</p> <pre><code>o[i][j] += o[i][j - 1];\nv[i][j] += v[i - 1][j];\ndp[i][j] += dp[i - 1][j - 1];\nds[i][j] += ds[i - 1][j + 1];\n</code></pre> <p>\u00centr-o matrice rezultat se marcheaz\u0103 acele celule care sunt nenule \u00een cel pu\u021bin una din matricele anterioare.</p>","tags":["OJI","clasa VII"]},{"location":"olimpiada/solutii/OJI/2025/VII-teren/#cerinta-2","title":"Cerin\u021ba 2","text":"<p>Pentru ob\u021binerea rezultatului se num\u0103r\u0103 c\u00e2te valori nenule sunt \u00een matricea rezultat.</p>","tags":["OJI","clasa VII"]},{"location":"olimpiada/solutii/OJI/2025/VII-teren/#cerinta-3","title":"Cerin\u021ba 3","text":"<p>Pentru a ob\u021bine rezultatul se num\u0103r\u0103 pentru fiecare celul\u0103 nenul\u0103 c\u00e2\u021bi vecini au valoarea 0.</p>","tags":["OJI","clasa VII"]},{"location":"olimpiada/solutii/OJI/2025/VII-teren/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie care ia punctajul maxim.</p> <pre><code>// prof Popa Daniel, Colegiul Na\u021bional \"Aurel Vlaicu\", Or\u0103\u0219tie\n#include &lt;cmath&gt;\n#include &lt;fstream&gt;\n#include &lt;iostream&gt;\nusing namespace std;\nifstream fin(\"teren.in\");\nofstream fout(\"teren.out\");\nconst int nm = 1002;\nint o[nm][nm], v[nm][nm], dp[nm][nm], ds[nm][nm], r[nm][nm];\nint n, m, k, i, j, L1, C1, L2, C2, c;\nvoid afis(int a[nm][nm]) {\n    for (int i = 1; i &lt;= n; i++) {\n        for (j = 1; j &lt;= n; j++) {\n            cout &lt;&lt; a[i][j] &lt;&lt; \" \";\n        }\n        cout &lt;&lt; endl;\n    }\n    cout &lt;&lt; endl;\n}\nvoid cerinta1() {\n    int sol = 0;\n    for (int i = 1; i &lt;= m; i++) {\n        fin &gt;&gt; L1 &gt;&gt; C1 &gt;&gt; L2 &gt;&gt; C2;\n        if (L1 == L2) {\n            sol += abs(C1 - C2) + 1;\n        } else {\n            sol += abs(L1 - L2) + 1;\n        }\n    }\n    fout &lt;&lt; sol;\n}\nvoid pentruCerinta2_3() {\n    for (int i = 1; i &lt;= m; i++) {\n        fin &gt;&gt; L1 &gt;&gt; C1 &gt;&gt; L2 &gt;&gt; C2;\n        if (L1 == L2) {\n            o[L1][min(C1, C2)]++;\n            o[L1][max(C1, C2) + 1]--;\n        } else if (C1 == C2) {\n            v[min(L1, L2)][C1]++;\n            v[max(L1, L2) + 1][C1]--;\n        } else if (L1 + C1 == L2 + C2)  /// diagonala secundara\n        {\n            if (L1 &gt; L2) {\n                swap(L1, L2);\n                swap(C1, C2);\n            }\n            ds[L1][C1]++;\n            ds[L2 + 1][C2 - 1]--;\n        } else  /// diagonala principala\n        {\n            if (L1 &gt; L2) {\n                swap(L1, L2);\n                swap(C1, C2);\n            }\n            dp[L1][C1]++;\n            dp[L2 + 1][C2 + 1]--;\n        }\n    }\n    for (i = 1; i &lt;= n; i++) {\n        for (j = 1; j &lt;= n; j++) {\n            o[i][j] += o[i][j - 1];\n            v[i][j] += v[i - 1][j];\n            dp[i][j] += dp[i - 1][j - 1];\n            ds[i][j] += ds[i - 1][j + 1];\n            r[i][j] = (o[i][j] + v[i][j] + dp[i][j] + ds[i][j]) &gt; 0;\n        }\n    }\n    // afis(r);\n}\nvoid cerinta2() {\n    int sol = 0;\n    for (int i = 1; i &lt;= n; i++) {\n        for (j = 1; j &lt;= n; j++) {\n            if (r[i][j] &gt; 0) {\n                sol++;\n            }\n        }\n    }\n    fout &lt;&lt; sol;\n}\n\nvoid cerinta3() {\n    int sol = 0, k;\n    fin &gt;&gt; k;\n    for (int i = 1; i &lt;= n; i++) {\n        for (j = 1; j &lt;= n; j++) {\n            if (r[i][j] != 0) {\n                sol += (r[i - 1][j] == 0) + (r[i][j - 1] == 0)\n                     + (r[i + 1][j] == 0) + (r[i][j + 1] == 0);\n            }\n        }\n    }\n    fout &lt;&lt; sol;\n}\n\nint main() {\n    fin &gt;&gt; c &gt;&gt; n &gt;&gt; m;\n    if (c == 1) {\n        cerinta1();\n    } else {\n        pentruCerinta2_3();\n        if (c == 2) {\n            cerinta2();\n        }\n        if (c == 3) {\n            cerinta3();\n        }\n    }\n\n    return 0;\n}\n</code></pre>","tags":["OJI","clasa VII"]},{"location":"olimpiada/solutii/OJI/2025/VIII-joc/","title":"Solu\u021bia problemei joc (OJI 2025, clasa a VIII-a)","text":"","tags":["OJI","clasa VIII"]},{"location":"olimpiada/solutii/OJI/2025/VIII-joc/#cerinta-1","title":"Cerin\u021ba 1","text":"","tags":["OJI","clasa VIII"]},{"location":"olimpiada/solutii/OJI/2025/VIII-joc/#solutie-in-on3","title":"Solu\u021bie \u00een \\(O(N^3)\\)","text":"<p>Vom fixa cele dou\u0103 valori \\(st\\) (\\(1 \u2264 st \u2264 n\\)) \u0219i \\(v\\) (\\(0 \u2264 v &lt; st\\)) reprezent\u00e2nd \u00eenceputul secven\u021bei \u015fi vizibilitatea. Pentru fiecare secven\u021b\u0103 determinat\u0103 de \\(st\\) \u015fi \\(v\\) vom aplica unul dintre algoritmii liniari de calculare a elementului majoritar (resurs\u0103: Infoarena - Problema majorit\u0103\u021bii votului). Astfel putem verifica, pentru fiecare secven\u021b\u0103 dac\u0103 este riscant\u0103.</p>","tags":["OJI","clasa VIII"]},{"location":"olimpiada/solutii/OJI/2025/VIII-joc/#solutie-in-on2","title":"Solu\u021bie \u00een \\(O(N^2)\\)","text":"<p>Vom folosi un vector de frecven\u021b\u0103, \u00een care vom contoriza num\u0103rul de apari\u021bii pentru fiecare decor. S\u0103 consider\u0103m c\u0103 am determinat vectorul de frecven\u021b\u0103 pentru secven\u021ba \\([i,j]\\) care \u00eencepe la pozi\u021bia \\(i\\) \u015fi se termin\u0103 la pozi\u021bia \\(j\\) (\\(1 \u2264 i \u2264 j &lt; n\\)). C\u00e2nd vom trece la secven\u021ba \\([i,j + 1]\\) vom ad\u0103uga un singur element, deci putem actualiza u\u0219or vectorul de frecven\u021b\u0103. Elementul majoritar se poate recalcula \u00een momentul \u00een care ad\u0103ug\u0103m un element \u00een vectorul de frecven\u021b\u0103 (fie r\u0103m\u00e2ne valoarea precedent\u0103, fie devine noua valoare ad\u0103ugat\u0103). Dup\u0103 ce toate secven\u021bele cu cap\u0103t st\u00e2ng \\(i\\) au fost analizate, reset\u0103m vectorul de frecven\u021b\u0103 pentru a-l refolosi pentru subsecven\u021bele cu cap\u0103tul st\u00e2ng \\(i + 1\\).</p>","tags":["OJI","clasa VIII"]},{"location":"olimpiada/solutii/OJI/2025/VIII-joc/#cerinta-2","title":"Cerin\u021ba 2","text":"","tags":["OJI","clasa VIII"]},{"location":"olimpiada/solutii/OJI/2025/VIII-joc/#solutie-in-on2_1","title":"Solu\u021bie \u00een \\(O(N^2)\\)","text":"<p>Vom simula efectiv jocul. Pentru a afla dac\u0103 o subsecven\u021b\u0103 este sau nu riscant\u0103 vom folosi un algoritm liniar de aflare a elementului majoritar (similar solu\u021biei de la cerin\u021ba 1). Acest\u0103 solu\u021bie are complexitatea \\(\\mathcal{O}(N^2)\\) \u00een cazul cel mai defavorabil.</p>","tags":["OJI","clasa VIII"]},{"location":"olimpiada/solutii/OJI/2025/VIII-joc/#solutie-in-on","title":"Solu\u021bie \u00een \\(O(N)\\)","text":"<p>Pentru a optimiza determinarea elementului majoritar din solu\u021bia precedent\u0103, vom folosi un vector de frecven\u021b\u0103, similar solu\u021biei 2 de la cerin\u021ba 1. S\u0103 presupunem c\u0103 ajungem pe subsecven\u021ba \\([s - v, s]\\) \u0219i \u0219tim dac\u0103 aceasta con\u021bine sau nu element majoritar, care este acesta \u0219i num\u0103rul s\u0103u de apari\u021bii. Avem dou\u0103 cazuri:</p> <ul> <li>Secven\u021ba este riscant\u0103. \u00cen acest caz \u0219tim c\u0103 exist\u0103 element majoritar (fie     acesta \\(E\\)). Juc\u0103torul va mic\u0219ora vizibilitatea, astfel excluz\u00e2nd elementul de     pe pozi\u021bia \\(s - v\\). Datorit\u0103 faptului c\u0103 elementul \\(E\\) avea \\(1 + (v + 1) / 2\\)     apari\u021bii \u00een subsecven\u021ba \\([s - v, s]\\), acesta r\u0103m\u00e2ne elementul cu num\u0103r maxim     de apari\u021bii \u0219i \u00een subsecven\u021ba \\([s - v + 1, s]\\), deci ar fi posibil ca acesta     s\u0103 r\u0103m\u00e2n\u0103 element majoritar sau s\u0103 nu mai existe element majoritar.</li> <li>Secven\u021ba nu este riscant\u0103. \u00cen acest caz \u0219tim c\u0103 nu exist\u0103 element majoritar.     C\u00e2nd ad\u0103ug\u0103m un element \u00een subsecven\u021b\u0103 avem dou\u0103 cazuri posibile. Fie acesta     are acum num\u0103rul necesar de apari\u021bii, caz \u00een care actualiz\u0103m \\(E\\), fie acesta     nu are suficiente apari\u021bii, caz \u00een care nu avem element majoritar.</li> </ul> <p>Complexitatea acestei solu\u021bii este \\(\\mathcal{O}(N)\\) timp \u0219i \\(\\mathcal{O}(N)\\) memorie. Exist\u0103 \u0219i alte solu\u021bii, at\u00e2t pentru punctaj integral, c\u00e2t \u015fi pentru punctaje par\u021biale.</p>","tags":["OJI","clasa VIII"]},{"location":"olimpiada/solutii/OJI/2025/VIII-joc/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie care ia punctajul maxim.</p> <pre><code>// Ilie Dumitru\n#include &lt;cstdio&gt;\n\nconst int NMAX = 100005, NMAX2 = 1024;\n\nint N;\nint decor[NMAX], scor[NMAX];\nint cnt[NMAX];\n\nint cerinta_1() {\n    int i, j, maxAp, rez = 0;\n\n    for (i = 0; i &lt; N; ++i) {\n        for (j = i, maxAp = decor[i]; j &lt; N; ++j) {\n            if (++cnt[decor[j]] &gt; cnt[maxAp]) {\n                maxAp = decor[j];\n            }\n            if (!(i &lt; j &amp;&amp; cnt[maxAp] &gt; (j - i + 1) / 2)) {\n                ++rez;\n            }\n        }\n        for (j = N - 1; j &gt;= i; --j) {\n            --cnt[decor[j]];\n        }\n    }\n\n    return rez;\n}\n\nint cerinta_2() {\n    int i, j, maxAp, total = 0;\n\n    for (i = j = 0, ++cnt[maxAp = decor[0]]; j &lt; N;) {\n        total += scor[j];\n        if (j &gt; i &amp;&amp; cnt[maxAp] &gt; (j - i + 1) / 2) {\n            --cnt[decor[i++]];\n        } else {\n            ++j;\n            if (j &lt; N) {\n                if (++cnt[decor[j]] &gt; cnt[maxAp]) {\n                    maxAp = decor[j];\n                }\n            }\n        }\n    }\n\n    return total;\n}\n\nint main() {\n    FILE *f = fopen(\"joc.in\", \"r\"), *g = fopen(\"joc.out\", \"w\");\n    int i, C;\n\n    fscanf(f, \"%d%d\", &amp;C, &amp;N);\n    for (i = 0; i &lt; N; ++i) {\n        fscanf(f, \"%d\", decor + i);\n    }\n    for (i = 0; i &lt; N; ++i) {\n        fscanf(f, \"%d\", scor + i);\n    }\n\n    fprintf(g, \"%d\\n\", C == 1 ? cerinta_1() : cerinta_2());\n\n    fclose(f);\n    fclose(g);\n    return 0;\n}\n</code></pre>","tags":["OJI","clasa VIII"]},{"location":"olimpiada/solutii/OJI/2025/VIII-reducere/","title":"Solu\u021bia problemei reducere (OJI 2025, clasa a VIII-a)","text":"","tags":["OJI","clasa VIII"]},{"location":"olimpiada/solutii/OJI/2025/VIII-reducere/#cerinta-1","title":"Cerin\u021ba 1","text":"<p>Pentru a determina valoarea de reducere, trebuie s\u0103 determin\u0103m cel mai mare divizor comun al valorilor din secven\u021b\u0103. Pentru a determina cmmdc pentru dou\u0103 valori utiliz\u0103m algoritmul lui Euclid. Pentru a determina cmmdc pentru o secven\u021b\u0103 de \\(n\\) valori utiliz\u0103m asociativitatea opera\u021biei cmmdc, deci determin\u0103m la fiecare pas cmmdc dintre cmmdc-ul curent \u0219i urm\u0103toarea valoare din secven\u021b\u0103:</p> \\[ (a_1, a_2, ..., a_n) = (a_1, (a_2, ..., (a_{n - 1}, a_{n}))) \\] <p>unde \\((a, b)\\) reprezint\u0103 cmmdc-ul lui \\(a\\) \u0219i \\(b\\).</p>","tags":["OJI","clasa VIII"]},{"location":"olimpiada/solutii/OJI/2025/VIII-reducere/#cerinta-2","title":"Cerin\u021ba 2","text":"<p>Descompunem \u00een factori primi fiecare valoare din secven\u021b\u0103 \u015fi determin\u0103m pe parcurs descom punerea \u00een factori primi a celui mai mic multiplu comun al acestor valori (to\u021bi factorii primi care apar \u00een descompunerile valorilor din secven\u021b\u0103 la puterea cea mai mare). Factorii primi comuni la puterea cea mai mic\u0103 constituie cmmdc (deci \u00eei p\u0103str\u0103m \u00een valoarea de reducere). Num\u0103rul minim de opera\u021bii care trebuie s\u0103 fie aplicate pentru a ob\u021bine valoarea de reducere este egal cu suma exponen\u021bilor factorilor primi din descompunerea \u00een factori primi a cmmmc/cmmdc.</p> <p>Pentru subtask-ul 2, restric\u021biile permit utilizarea unui vector \\(nr\\) de \\(10^6\\) elemente, unde \\(nr_i\\) este puterea factorului prim \\(i\\) \u00een descompunerea factori primi a cmmmc/cmmdc. Pentru a ob\u021bine punctele pe acest subtask nu este necesar s\u0103 optimiz\u0103m descompunerea \u00een factori primi utiliz\u00e2nd pregenerarea numerelor prime cu ciurul lui Eratostene, dar, pentru subtask-ul 3, este necesar s\u0103 descompunem \u00een factori primi c\u0103ut\u00e2nd divizorii, doar printre numerele prime p\u00e2n\u0103 la radicalul num\u0103rului.</p> <p>Pentru subtask-ul 3 restric\u021biile nu permit declararea vectorului \\(nr\\). Ca urmare vom re\u021bine o descompunere \u00een factori primi ca o list\u0103 de factori primi \u015fi puterile acestora, list\u0103 \u00een care factorii primi apar \u00een ordine cresc\u0103toare.</p> <p>Pentru fiecare num\u0103r din secven\u021b\u0103:</p> <ul> <li>descompunem num\u0103rul \u00een factori primi;</li> <li>printr-un algoritm similar cu algoritmul de interclasare, actualiz\u0103m     descompunerea \u00een factori primi a cmmmc (\u00een cmmmc trebuie s\u0103 apar\u0103 to\u021bi     factorii primi la puterea cea mai mare).</li> </ul> <p>La final simplific\u0103m cmmmc cu cmmdc, parcurg\u00e2nd descompunerile \u00een factori primi ale acestora \u015fi, pentru factorii primi comuni, sc\u0103z\u00e2nd din puterea factorului prim din cmmmc puterea factorului prim respectiv din cmmdc.</p> <p>Suma puterilor factorilor primi ai cmmmc dup\u0103 simplificarea cu cmmdc va fi num\u0103rul minim de opera\u021bii de reducere necesare.</p>","tags":["OJI","clasa VIII"]},{"location":"olimpiada/solutii/OJI/2025/VIII-reducere/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie care ia punctajul maxim.</p> <pre><code>// Em. Cerchez 100 puncte\n#include &lt;fstream&gt;\n#define VMAX 1000000\n#define PMAX 80000\n#define LGMAX 8\n#define NMAX 2002\nusing namespace std;\nifstream fin(\"reducere.in\");\nofstream fout(\"reducere.out\");\nstruct factor {\n    long long int d;\n    short int p;\n};\nbool ciur[VMAX];\nint prime[PMAX];\nvoid eratostene();\nlong long int cmmdc();\nint c, n, m, nrp;\nlong long int cmd;\nfactor D[LGMAX], dx[LGMAX], rez[LGMAX * NMAX], aux[LGMAX * NMAX];\nint lgD, lgx, lgrez;\nlong long int nr[NMAX];\n\nlong long int cerinta2();\nvoid descompunere(long long int x, factor dx[], int &amp;lgx);\n\nint main() {\n    int i;\n    fin &gt;&gt; c &gt;&gt; n;\n    for (i = 0; i &lt; n; i++) {\n        fin &gt;&gt; nr[i];\n    }\n    cmd = cmmdc();\n    if (c == 1) {\n        fout &lt;&lt; cmd &lt;&lt; '\\n';\n    } else {\n        eratostene();\n        fout &lt;&lt; cerinta2() &lt;&lt; '\\n';\n    }\n    return 0;\n}\n\nvoid eratostene() {\n    int i, j;\n    for (i = 3; i * i &lt; VMAX; i += 2) {\n        if (ciur[i] == 0) {\n            for (j = i * i; j &lt; VMAX; j += i) {\n                ciur[j] = 1;\n            }\n        }\n    }\n    prime[0] = 2;\n    nrp = 1;\n    for (i = 3; i &lt; VMAX; i += 2) {\n        if (ciur[i] == 0) {\n            prime[nrp++] = i;\n        }\n    }\n}\n\nlong long int cmmdc() {\n    int i;\n    long long int d, x, r;\n    d = nr[0];\n    for (i = 1; i &lt; n; i++) {\n        x = nr[i];\n        while (x) {\n            r = d % x;\n            d = x;\n            x = r;\n        }\n    }\n    return d;\n}\n\nvoid descompunere(long long int x, factor dx[], int &amp;lgx) {\n    int i, m;\n    lgx = 0;\n    for (i = 0; i &lt; nrp &amp;&amp; (long long int)prime[i] * prime[i] &lt;= x; i++) {\n        if (x % prime[i] == 0) {\n            m = 0;\n            while (x % prime[i] == 0) {\n                m++;\n                x /= prime[i];\n            }\n            dx[lgx].p = m;\n            dx[lgx].d = prime[i];\n            lgx++;\n        }\n    }\n    if (x &gt; 1) {\n        dx[lgx].d = x;\n        dx[lgx].p = 1;\n        lgx++;\n    }\n}\n\nvoid actualizeaza() {\n    int i = 0, j = 0, k = 0;\n    while (i &lt; lgx &amp;&amp; j &lt; lgrez) {\n        if (dx[i].d == rez[j].d) {\n            aux[k].d = dx[i].d;\n            aux[k].p = max(dx[i].p, rez[j].p);\n            i++;\n            j++;\n            k++;\n        } else if (dx[i].d &lt; rez[j].d) {\n            aux[k++] = dx[i++];\n        } else {\n            aux[k++] = rez[j++];\n        }\n    }\n    while (i &lt; lgx) {\n        aux[k++] = dx[i++];\n    }\n    while (j &lt; lgrez) {\n        aux[k++] = rez[j++];\n    }\n    for (i = 0; i &lt; k; i++) {\n        rez[i] = aux[i];\n    }\n    lgrez = k;\n}\nlong long int cerinta2() {\n    int i, j;\n    long long int nrop = 0;\n    descompunere(cmd, D, lgD);\n    descompunere(nr[0], rez, lgrez);\n    for (i = 1; i &lt; n; i++) {\n        descompunere(nr[i], dx, lgx);\n        actualizeaza();\n    }\n    i = 0;\n    j = 0;\n    while (i &lt; lgD) {\n        if (D[i].d == rez[j].d) {\n            rez[j].p -= D[i].p;\n            i++;\n            j++;\n        } else {\n            j++;\n        }\n    }\n    for (i = 0; i &lt; lgrez; i++) {\n        nrop += rez[i].p;\n    }\n    return nrop;\n}\n</code></pre>","tags":["OJI","clasa VIII"]},{"location":"olimpiada/solutii/OJI/2025/X-anagrame/","title":"Solu\u021bia problemei Anagrame (OJI 2025, clasa a X-a)","text":"","tags":["OJI","clasa X"]},{"location":"olimpiada/solutii/OJI/2025/X-anagrame/#subtask-1","title":"Subtask 1","text":"<p>Complexitatea \\(\\mathcal{O}(M)\\). Structura testelor de intrare face ca \u0219irul suport s\u0103 con\u021bin\u0103 aceea\u0219i liter\u0103 ca \u0219irul \\(A\\), iar lungimea acestuia s\u0103 fie minimul lungimilor intervalelor ce intervin \u00een opera\u021biile de generare, \\(\\min(y_q - x_q)\\).</p>","tags":["OJI","clasa X"]},{"location":"olimpiada/solutii/OJI/2025/X-anagrame/#subtask-2","title":"Subtask 2","text":"<p>Complexitatea \\(\\mathcal{O}(N \\times \\Sigma \\times M)\\). Pentru fiecare liter\u0103 \\(L\\), situat\u0103 \u00een secven\u021ba interogat\u0103, determin\u0103m \\(\\operatorname{Range}[L]\\), \u00een complexitate liniar\u0103 \\(\\mathcal{O}(N)\\), re\u021bin\u00e2ndu-se prima \u0219i ultima apari\u021bie a ei \u00een cadrul secvent, ei.</p>","tags":["OJI","clasa X"]},{"location":"olimpiada/solutii/OJI/2025/X-anagrame/#subtask-3","title":"Subtask 3","text":"<p>Complexitatea \\(\\mathcal{O}(N \\times \\Sigma + M)\\). \u00centruc\u00e2t nu se fac update-uri, se poate precalcula, pentru fiecare pozi\u021bie din \u0219ir, pentru fiecare liter\u0103 a alfabetului, \\(St[poz][lit]\\) reprezent\u00e2nd cea mai apropiat\u0103 pozi\u021bie la st\u00e2nga, respectiv \\(Dr[poz][lit]\\) reprezent\u00e2nd cea mai apropiat\u0103 pozi\u021bie la dreapta unde se reg\u0103se\u0219te aceasta. Complexitatea \\(\\mathcal{O}(N \\times \\Sigma)\\). \u00cen urma precalcul\u0103rii r\u0103spunsul la o interogare se face \u00een timp constant \\(\\mathcal{O}(1)\\).</p>","tags":["OJI","clasa X"]},{"location":"olimpiada/solutii/OJI/2025/X-anagrame/#subtask-4","title":"Subtask 4","text":"<p>Complexitatea \\(\\mathcal{O}(M \\times \\Sigma \\times \\log N)\\). Pentru fiecare liter\u0103 se memoreaz\u0103, \u00eentr-un set, pozi\u021biile unde aceasta apare \u00een \u0219ir. Prima \u0219i ultima pozi\u021bie din cadrul intervalului interogat, pentru fiecare liter\u0103, se determin\u0103 \u00een \\(\\mathcal{O}(\\log N)\\) folosind c\u0103utarea binar\u0103. \u0218irul suport minim lexicografic poate fi determinat printr-o comparare pe vectori de frecven\u021b\u0103.</p>","tags":["OJI","clasa X"]},{"location":"olimpiada/solutii/OJI/2025/X-anagrame/#subtask-6","title":"Subtask 6","text":"<p>Complexitatea \\(\\mathcal{O}(M \\times (\\Sigma + (y \u2212 x)!))\\). Lungimea secven\u021bei interogate permite num\u0103rarea anagramelor \u0219irului suport folosind <code>next_permutation</code> pentru generarea anagramelor distincte \u00een ordine lexicografic\u0103.</p>","tags":["OJI","clasa X"]},{"location":"olimpiada/solutii/OJI/2025/X-anagrame/#subtask-7","title":"Subtask 7","text":"<p>Dac\u0103 \u0219irul suport con \u021bine \\(l = c_a + c_b\\) litere \u00een total (adic\u0103, \\(c_a\\) litere de a \u0219i \\(c_b\\) litere de b), \u00eenseamn\u0103 c\u0103 num\u0103rul de anagrame ale acestuia este egal cu \\(\\frac{l!}{a! \\times b!}\\).</p>","tags":["OJI","clasa X"]},{"location":"olimpiada/solutii/OJI/2025/X-anagrame/#subtask-8-generalizarea-a-subtask-ului-7","title":"Subtask 8 (Generalizarea a subtask-ului 7)","text":"<p>Complexitatea \\(\\mathcal{O}(N \\times \\Sigma + M \\times \\log N \\times \\Sigma)\\). Num\u0103rul anagramelor distincte este egal cu num\u0103rul permut\u0103rilor cu repeti\u021bii. Presupunem c\u0103 \u0219irul suport are Nr caractere \u0219i con\u021bine litera \\(l_1\\) de \\(n_1\\) ori, litera \\(l_2\\) de \\(n_2\\) ori, ..., litera \\(l_k\\) de \\(n_k\\) ori, astfel \u00eenc\u00e2t \\(n_1 + n_2 + ... + n_k = Nr\\). Num\u0103rul de permut\u0103rilor cu repeti\u021bii este egal cu \\(Nr!/(n_1! \\times n_2! . . . \\times n_k!)\\). Not\u0103m cu \\(K = (n_1! \\cdot n_2!... \\cdot n_k!)\\) \u0219i cu \\(Mod = 1999999973\\), atunci deoarece \\(Mod\\) este num\u0103r prim, \\((Nr!/K) \\equiv (\ud835\udc41 \ud835\udc5f! \\times K Mod - 2) \\mod Mod\\). Se pot precalcula factorialele numerelor mai mici sau egale cu \\(Nr\\) iar exponen\u021bierea se implementeaz\u0103 \u00een complexitate logaritmic\u0103.</p>","tags":["OJI","clasa X"]},{"location":"olimpiada/solutii/OJI/2025/X-anagrame/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie care ia punctajul maxim.</p> <pre><code>#include &lt;bits/stdc++.h&gt;\n#define MOD 1999999973\n/// O(sigma * M * logN)\nusing namespace std;\n\nconst int Nmax = 100005;\nint N, M, C, Ans;\nint SirMin[30];\nchar A[Nmax];\nunsigned long long Fact[30 * Nmax];\nset&lt;int&gt; S[30];\nifstream f(\"anagrame.in\");\nofstream g(\"anagrame.out\");\n\nvoid precl()  /// precalculam factorialele numerelor mai mici ca Nmax\n{\n    Fact[0] = 1;\n    for (int i = 1; i &lt; 26 * Nmax; i++) {\n        Fact[i] = (1LL * i * Fact[i - 1]) % MOD;\n    }\n}\n\nint elg(int a, int b)  /// exponentierea logaritmica\n{\n    int rez = 1;\n    while (b &gt; 1) {\n        if (b % 2 == 1) {\n            rez = (1LL * rez * a) % MOD;\n        }\n        a = (1LL * a * a) % MOD;\n        b = b / 2;\n    }\n    return (1LL * a * rez) % MOD;\n}\n\nvoid actualizez_min(int A[], int B[]) {\n    int lg_A = 0, lg_B = 0;\n    for (int i = 0; i &lt;= 25; i++) {\n        lg_A += A[i];\n        lg_B += B[i];\n    }\n    bool ok = false;\n    for (int i = 0; i &lt;= 25 &amp;&amp; !ok; i++) {\n        lg_A -= A[i];\n        lg_B -= B[i];\n\n        if (A[i] &gt; B[i]) {\n            if (lg_B &gt; 0) {\n                ok = true;\n            } else {\n                break;\n            }\n        }\n        if (A[i] &lt; B[i]) {\n            if (lg_A &gt; 0) {\n                break;\n            } else {\n                ok = true;\n            }\n        }\n    }\n    if (ok) {\n        for (int i = 0; i &lt;= 25; i++) {\n            B[i] = A[i];\n        }\n    }\n}\n\nvoid Generare(int x, int y, int &amp;Rez) {\n    int Range[30], P = 1, Nr = 0;\n    for (int i = 0; i &lt;= 25; i++) {\n        Range[i] = 0;\n        auto it1 = S[i].lower_bound(x);\n        if (it1 == S[i].end()) {\n            continue;\n        }\n        auto it2 = S[i].upper_bound(y);\n\n        if (it2 == S[i].begin()) {\n            continue;\n        }\n        it2--;\n        Range[i] = *it2 - *it1;\n\n        if (Range[i] &lt; 0) {\n            Range[i] = 0;\n        }\n\n        P = (1LL * P * Fact[Range[i]]) % MOD;\n        Nr += Range[i];\n    }\n    Rez = (1LL * Fact[Nr] * elg(P, MOD - 2)) % MOD;\n\n    if (C == 1) {\n        actualizez_min(Range, SirMin);\n    }\n}\n\nvoid load() {\n    f &gt;&gt; C &gt;&gt; N &gt;&gt; M;\n    assert(C == 1 || C == 2);\n    assert(N &lt;= 100000);\n    assert(M &lt;= 100000);\n\n    for (int i = 1; i &lt;= N; i++)  /// initializam seturile care mentin pentru\n                                  /// fiecare litera pozitiile din sir\n    {\n        f &gt;&gt; A[i];\n        assert(islower(A[i]));\n        S[A[i] - 'a'].insert(i);\n    }\n    for (int i = 0; i &lt;= 25; i++) {\n        SirMin[i] = 0;\n    }\n    SirMin[25] = N * 30;\n    A[N + 1] = '\\n';\n    for (int i = 1; i &lt;= M; i++) {\n        int x = 0, y, poz;\n        char s[Nmax];\n        f &gt;&gt; s;\n        if (isdigit(s[0]))  /// operatie generare\n        {\n            for (int j = 0; s[j]; j++) {\n                x = x * 10 + (int)s[j] - '0';\n            }\n            f &gt;&gt; y;\n            assert(x &lt;= y);\n            assert(y &lt;= N);\n            Generare(x, y, Ans);\n            if (C == 2) {\n                g &lt;&lt; Ans &lt;&lt; '\\n';\n            }\n        } else \n        {\n            assert(islower(s[0]));\n            f &gt;&gt; poz;\n            S[A[poz] - 'a'].erase(poz);\n            S[s[0] - 'a'].insert(poz);\n            A[poz] = s[0];\n        }\n    }\n\n    if (C == 1) {\n        for (int i = 0; i &lt;= 25; i++) {\n            for (int j = 1; j &lt;= SirMin[i]; j++) {\n                g &lt;&lt; (char)(i + 'a');\n            }\n        }\n        g &lt;&lt; '\\n';\n    }\n}\n\nint main() {\n    precl();\n    load();\n    return 0;\n}\n</code></pre>","tags":["OJI","clasa X"]},{"location":"olimpiada/solutii/OJI/2025/X-bitsir/","title":"Solu\u021bia problemei Bitsir (OJI 2025, clasa a X-a)","text":"","tags":["OJI","clasa X"]},{"location":"olimpiada/solutii/OJI/2025/X-bitsir/#subtask-1","title":"Subtask 1","text":"<p>C\u00e2nd \\(X = 0\\), \u0219irul \\(A_i\\) trebuie s\u0103 fie plin de 0 (\\(A_i = 0,\\,\\forall i \\in {1, 2, \\dots , N }\\)). Fiindc\u0103 \\(Y = 0\\), iar \\(M_i = 0,\\,\\forall i \\in {1, 2, \\dots , N}\\), r\u0103spunsul va fi mereu 1.</p>","tags":["OJI","clasa X"]},{"location":"olimpiada/solutii/OJI/2025/X-bitsir/#subtask-2","title":"Subtask 2","text":"<p>C\u00e2nd \ud835\udc4b = 1, \u0219irul \\(A_i\\) trebuie s\u0103 con\u021bin\u0103 cel pu\u021bin o valoare de 1, restul fiind egale cu 0. Din moment ce \\(Y = 0\\), num\u0103rul de valori de 1 trebuie s\u0103 fie par. Astfel, r\u0103spunsul va fi \\(C_N^2 + C_N^4 + ... = 2^{N-1} - 1\\).</p>","tags":["OJI","clasa X"]},{"location":"olimpiada/solutii/OJI/2025/X-bitsir/#subtask-3","title":"Subtask 3","text":"<p>Observa\u021bie: \u0219irul \\(A_i\\) nu poate avea elemente mai mari dec\u00e2t \\(X\\). Pentru acest subtask, se creeaz\u0103 un for pentru fiecare valoare de la 0 la \\(X\\) \u0219i se verific\u0103 toate condi\u021biile.</p>","tags":["OJI","clasa X"]},{"location":"olimpiada/solutii/OJI/2025/X-bitsir/#subtask-4","title":"Subtask 4","text":"<p>O generalizare a subtaskului 1, trebuie verificat dac\u0103 \u0219irul plin de 0 respect\u0103 propriet\u0103\u021bile 2 \u0219i 3.</p>","tags":["OJI","clasa X"]},{"location":"olimpiada/solutii/OJI/2025/X-bitsir/#subtask-5","title":"Subtask 5","text":"<p>Pe baza observa\u021biei anterioare \u0219i a m\u0103rimii \u0219irului (\\(N \\leq 4\\)), solu\u021bia pentru acest subtask este iterarea prin toate posibilit\u0103\u021bile \u0219i verificarea celor 3 condi\u021bii.</p> <p>Complexitate: \\(\\mathcal{O}(X^4)\\) ca timp.</p>","tags":["OJI","clasa X"]},{"location":"olimpiada/solutii/OJI/2025/X-bitsir/#subtask-6","title":"Subtask 6","text":"<p>Observa\u021bie</p> <p>Opera\u021bia de XOR (\\(\\oplus\\)) are urm\u0103toarea proprietate: \\(a \\oplus b = c \\Rightarrow a = b \\oplus c\\).</p> <p>Se itereaz\u0103 prin toate valorile posibile ale lui \\(A_1\\) (\\(\\{0, 1, \\dots X\\}\\)), se afl\u0103 valoarea lui \\(A_2 = Y \\oplus A_1\\) \u0219i se verific\u0103 celelalte dou\u0103 condi\u021bii.</p> <p>Complexitate: \\(\\mathcal{O}(X)\\).</p>","tags":["OJI","clasa X"]},{"location":"olimpiada/solutii/OJI/2025/X-bitsir/#subtask-7","title":"Subtask 7","text":"<p>\u00cen acest caz, cele 3 condi\u021bii pot fi reformulate astfel:</p> <ul> <li>Dac\u0103 \\(X = 1\\), atunci exist\u0103 cel pu\u021bin o valoare de 1 \u00een \u0219ir, altfel tot \u0219irul   este complet 0.</li> <li>Dac\u0103 \\(Y = 1\\), atunci exist\u0103 un num\u0103r impar de 1 \u00een \u0219ir, altfel exist\u0103 un num\u0103r   par de 1.</li> <li>Dac\u0103 \\(M_i = 1\\), atunci \\(A_i\\) = 1, altfel \\(A_i\\) poate fi 0 sau 1.</li> </ul> <p>Dac\u0103 \\(X = 0\\), atunci problema se reduce la Subtaskul 4. Altfel, \u00een func\u021bie de valoarea lui \\(Y\\) \u0219i c\u00e2te valori de 1 exist\u0103 \u00een \u0219irul \\(M\\), se determin\u0103 paritatea num\u0103rului de valori care pot fi alese. Mai exact, dac\u0103 se noteaz\u0103 cu \\(F\\) num\u0103rul de valori de 1 din \u0219irul \\(M\\) \u0219i cu \\(R\\) r\u0103spunsul, exist\u0103 urm\u0103toarele cazuri:</p> <ul> <li>\\(F\\) impar \u0219i \\(Y = 0\\): \\(R = C_1^{N-F} + C_3^{N-F} + \\dots = 2^{N - F - 1}\\)</li> <li>\\(F\\) impar \u0219i \\(Y = 1\\): \\(R = C_0^{N-F} + C_2^{N-F} + \\dots = 2^{N - F - 1}\\)</li> <li>\\(F\\) par \u0219i \\(Y = 0\\): \\(R = C_0^{N-F} + C_2^{N-F} + \\dots = 2^{N - F - 1}\\)</li> <li>\\(F\\) par \u0219i \\(Y = 1\\): \\(R = C_1^{N-F} + C_3^{N-F} + \\dots = 2^{N - F - 1}\\)</li> </ul> <p>Dac\u0103 \\(X = 1\\), \\(F = 0\\) \u0219i \\(Y = 0\\), atunci la formul\u0103 se scade 1 deoarece se \u00eennum\u0103r\u0103 \u0219i \u0219irul plin de 0.</p> <p>Complexitate: \\(\\mathcal{O}(N)\\)</p>","tags":["OJI","clasa X"]},{"location":"olimpiada/solutii/OJI/2025/X-bitsir/#subtask-8","title":"Subtask 8","text":"<p>Din cauza naturii opera\u021biilor pe bi\u021bi, problema poate fi rezolvat\u0103 bit cu bit, fiind \u00eemp\u0103r\u021bit\u0103 astfel \u00een 30 de subprobleme de tipul subtaskului 7. Mai exact, pentru bitul \\(b\\), subproblema este urm\u0103toarea:</p> <ul> <li>\\(X_b = 1\\), dac\u0103 \\(X\\) con\u021bine bitul \\(b\\), altfel \\(X_b = 0\\).</li> <li>\\(Y_b = 1\\), dac\u0103 \\(Y\\) con\u021bine bitul \\(b\\), altfel \\(Y_b = 0\\).</li> <li>\\(M_i = 1\\), dac\u0103 \\(M_i\\) con\u021bine bitul \\(b\\), altfel \\(M_b = 0\\).</li> </ul> <p>Se rezolv\u0103 toate subproblemele, iar r\u0103spunsul final va fi produsul tuturor r\u0103spunsurilor subproblemelor.</p>","tags":["OJI","clasa X"]},{"location":"olimpiada/solutii/OJI/2025/X-bitsir/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie care ia punctajul maxim.</p> <pre><code>#include &lt;bits/stdc++.h&gt;\n\nusing namespace std;\n\nifstream f(\"bitsir.in\");\nofstream g(\"bitsir.out\");\n\ntypedef long long LL;\nconstexpr int NMAX = 1e5 + 5;\nconstexpr int MOD = 1e9 + 7;\n\nint N;\nLL X, Y;\nLL Mask[NMAX];\n\nint fact[NMAX];\nint inv_fact[NMAX];\n\nint LgPut(int a, int b) {\n    if (b == 1) {\n        return a;\n    }\n\n    if (b == 0) {\n        return 1;\n    }\n\n    int val = LgPut(a, b / 2);\n\n    val = (1LL * val * val) % MOD;\n\n    if (b % 2 == 1) {\n        return (1LL * val * a) % MOD;\n    }\n\n    return val;\n}\n\nvoid Precalculare() {\n    fact[0] = 1;\n\n    for (int i = 1; i &lt;= N; ++i) {\n        fact[i] = (1LL * fact[i - 1] * i) % MOD;\n    }\n    inv_fact[N] = LgPut(fact[N], MOD - 2);\n\n    for (int i = N - 1; i &gt;= 0; --i) {\n        inv_fact[i] = (1LL * inv_fact[i + 1] * (i + 1)) % MOD;\n    }\n}\n\nint Comb(int n, int k) {\n    int ans = (1LL * inv_fact[k] * inv_fact[n - k]) % MOD;\n\n    return (1LL * ans * fact[n]) % MOD;\n}\n\nint main() {\n    f &gt;&gt; N &gt;&gt; X &gt;&gt; Y;\n\n    for (int i = 1; i &lt;= N; ++i) {\n        f &gt;&gt; Mask[i];\n    }\n\n    if (Y &gt; X) {\n        g &lt;&lt; \"NU\\n\" &lt;&lt; 0;\n        return 0;\n    }\n    Precalculare();\n\n    int answer = 1;\n    for (int b = 0; (1LL &lt;&lt; b) &lt;= X; ++b) {\n        if ((X &amp; (1LL &lt;&lt; b)) == 0) {\n            for (int i = 1; i &lt;= N; ++i) {\n                if ((Mask[i] &amp; (1LL &lt;&lt; b))) {\n                    g &lt;&lt; \"NU\\n\" &lt;&lt; 0;\n                    return 0;\n                }\n            }\n\n            if ((Y &amp; (1LL &lt;&lt; b))) {\n                g &lt;&lt; \"NU\\n\" &lt;&lt; 0;\n                return 0;\n            }\n\n            continue;\n        }\n\n        int start = 0;\n        if ((Y &amp; (1LL &lt;&lt; b))) {\n            start = 1;\n        }\n\n        int cnt_forced_one = 0;\n        for (int i = 1; i &lt;= N; ++i) {\n            if ((Mask[i] &amp; (1LL &lt;&lt; b))) {\n                cnt_forced_one++;\n            }\n        }\n\n        if (cnt_forced_one % 2 == 1) {\n            start = (1 - start);\n        }\n\n        int n = N - cnt_forced_one;\n        bool exists_one = (cnt_forced_one &gt; 0);\n\n        if (!exists_one &amp;&amp; start == 0) {\n            start += 2;\n        }\n\n        int coef = 0;\n        for (int i = start; i &lt;= n; i += 2) {\n            coef = (1LL * coef + 1LL * Comb(n, i)) % MOD;\n        }\n\n        if (coef == 0) {\n            g &lt;&lt; \"NU\\n\" &lt;&lt; 0;\n            return 0;\n        }\n        answer = (1LL * answer * coef) % MOD;\n    }\n\n    g &lt;&lt; \"DA\\n\" &lt;&lt; answer;\n\n    return 0;\n}\n</code></pre>","tags":["OJI","clasa X"]},{"location":"olimpiada/solutii/OJI/2025/X-golf/","title":"Solu\u021bia problemei Golf (OJI 2025, clasa a X-a)","text":"","tags":["OJI","clasa X"]},{"location":"olimpiada/solutii/OJI/2025/X-golf/#subtask-1","title":"Subtask 1","text":"<p>Pentru a determina num\u0103rul de celule din golf ce sunt umplute cu p\u0103m\u00e2n\u021bse pot citi caracterele (de 0 sau 1) ce reprezint\u0103 elementele matricei \\(A\\), unul c\u00e2te unul. A\u0219adar, \u00eentr-o variabil\u0103 \\(E\\), se poate re\u021bine r\u0103spunsul pentru prima cerin\u021b\u0103: astfel, pentru fiecare caracter de 1 \u00eent\u00e2lnit \u00een \\(A\\), se incrementeaz\u0103 valoarea lui \\(E\\). La final, dup\u0103 ce toate cele \\(n \\times m\\) elemente din matrice au fost citite, se afi\u0219eaz\u0103 valoarea lui \\(E\\). Complexitatea total\u0103 de timp este de \\(\\mathcal{O} (n \\cdot m)\\), iar spa\u021biul utilizat se \u00eencadreaz\u0103 \u00een \\(\\mathcal{O}(1)\\) (nu este nevoie s\u0103 stoc\u0103m niciun tablou/vector \u2014 totul se efectueaz\u0103 cu ajutorul unui num\u0103r mic, constant de variabile).</p>","tags":["OJI","clasa X"]},{"location":"olimpiada/solutii/OJI/2025/X-golf/#subtask-2","title":"Subtask 2","text":"<p>De vreme ce se garanteaz\u0103 (prin tabelul cu Restric\u021bii \u0219i preciz\u0103ri din enun\u021b) c\u0103 exist\u0103 o singur\u0103 insul\u0103 \u00een golf, \u00eenseamn\u0103 c\u0103 num\u0103rul de insule (din Golful Biscayne) ce con\u021bin un num\u0103r maxim de insule (adic\u0103 r\u0103spunsul la cerin\u021ba de rezolvat) este chiar 1.</p>","tags":["OJI","clasa X"]},{"location":"olimpiada/solutii/OJI/2025/X-golf/#subtask-3","title":"Subtask 3","text":"<p>Pentru a determina num\u0103rul de celule ce fac parte din fiecare insul\u0103 a golfului, se poate folosi un algoritm ce adaug\u0103, \u00een timpul descoperirii unei insule, fiecare element de 1 \u00eentr-o structur\u0103 de date similar\u0103 cu o coad\u0103 exact o singur\u0103 dat\u0103 (spre exemplu, folosind un tablou auxiliar \u00een care se marcheaz\u0103 vizitarea elementelor \u00een cadrul unei itera\u021bii anterioare), cum ar fi Algoritmul lui Lee; dac\u0103 dorim s\u0103 folosim o metod\u0103 recursiv\u0103, recomand\u0103m \u0219i Algoritmul de tip Flood Fill. Pentru fiecare insul\u0103 \\(\\alpha\\), se poate stoca \u0219i o variabil\u0103 \\(\\mathrm{num}_\\alpha\\) (de tip <code>int</code>) care re\u021bine num\u0103rul de celule umplute cu p\u0103m\u00e2nt ce intr\u0103 \u00een alc\u0103tuirea sa. Apoi, printr-o parcurgere a acestei structuri de date (de exemplu, <code>struct</code>, \u00een C/C++) ce re\u021bine informa\u021bii despre insule (structura con\u021bine, \u00een total, cel mult \\(\\mathcal{O}(n \\times m)\\) elemente, corespunz\u0103toare insulelor), se calculeaz\u0103 num\u0103rul elementelor \\(\\mathrm{num}_\\alpha\\) maximale. Astfel, at\u00e2t complexitatea de timp, c\u00e2t \u0219i cea de spa\u021biu, sunt de \\(\\mathcal{O}(n \\times m)\\).</p>","tags":["OJI","clasa X"]},{"location":"olimpiada/solutii/OJI/2025/X-golf/#subtask-4","title":"Subtask 4","text":"<p>Pentru fiecare interogare dintre cele \\(Q\\), se pot g\u0103si insulele ce influen\u021beaz\u0103 (altfel spus, modific\u0103) rezultatul, \u00eentr-o manier\u0103 similar\u0103 cu cea pentru al treilea subtask. Astfel, s\u0103 presupunem c\u0103 avem de rezolvat o interogare de tipul \\((C, p)\\) (unde \\(1 \u2264 p \u2264 m\\)). Fie \\(I_\\alpha = {(\ud835\udc65_{\\alpha,1}, \ud835\udc66_{\\alpha,1}), (\ud835\udc65_{\\alpha,2}, \ud835\udc66_{\\alpha,2}), . . . , (\ud835\udc65_{\\alpha,k_\\alpha} , \ud835\udc66_{\\alpha,k_\\alpha} )}\\) mul\u021bimea ce con\u021bine toate cele \\(k_\\alpha\\) celule (reprezentate prin perechi formate din linia \\(x_{\\alpha,i}\\), respectiv coloana \\(y_{\\alpha,i}\\) \u2014 coordonatele celulelor \u00een matricea \\(A\\)) ce intr\u0103 \u00een alc\u0103tuirea unei insule \\(\\alpha\\); spunem c\u0103 insula \\(\\alpha\\) are dimensiunea egal\u0103 cu \\(k_\\alpha\\).</p> <p>Dac\u0103 \\(\\max(y_{\\alpha,1}, y_{\\alpha,2}, ..., y_{\\alpha,k_\\alpha}) &lt; p\\), \u00eenseamn\u0103 c\u0103 insula \\(\\alpha\\) este situat\u0103 la st\u00e2nga coloanei \\(p\\), a\u0219a c\u0103 valoarea lui \\(b\\) (adic\u0103, conform enun\u021bului, num\u0103rul de celule din toate insulele ce se afl\u0103 la st\u00e2nga coloanei \\(p\\), \u00een cadrul interog\u0103rii curente) cre\u0219te cu \\(k_\\alpha\\); altfel, dac\u0103 \\(\\min(y_{\\alpha,1}, y_{\\alpha,2}, ..., y_{\\alpha,k_\\alpha}) &gt; p\\), \u00eenseamn\u0103 c\u0103 insula \\(\\alpha\\) este situat\u0103 la dreapta coloanei \\(p\\), a\u0219a c\u0103 valoarea lui \\(b\\) (num\u0103rul de celule din toate insulele ce se afl\u0103 la dreapta coloanei \\(p\\)) cre\u0219te cu \\(k_\\alpha\\). \u00cen orice alt caz, valorile lui \\(a\\) \u0219i \\(b\\) nu se modific\u0103 (cu ocazia proces\u0103rii insulei curente \\(\\alpha\\)).</p> <p>\u00cen mod similar, putem ra\u021biona pentru o interogare de tipul \\((L, p)\\) (unde \\(1 \u2264 p \u2264 n\\)) \u2013 \u00een loc s\u0103 folosim coordonatele de tip coloan\u0103 \\(y_{\\alpha,i}\\), le vom folosi pe cele de tip linie \\(x_{\\alpha,i}\\) .</p> <p>Prin urmare, complexitatea total\u0103 de timp este de \\(\\mathcal{O}(Q \\cdot n \\cdot m)\\), iar cea de spa\u021biu este de \\(\\mathcal{O}(n \\cdot m)\\).</p>","tags":["OJI","clasa X"]},{"location":"olimpiada/solutii/OJI/2025/X-golf/#subtask-5","title":"Subtask 5","text":"<p>De vreme ce interog \u0103rile de tip \\((L, p)\\) pot fi rezolvate \u00eentr-un mod analog cu cele de tip \\((C, p)\\) (de exemplu, prin \u00eenlocuirea liniilor matricei cu coloanele acesteia \u0219i viceversa, sau prin folosirea unei structuri de date de forma <code>std::pair&lt;int, int&gt;</code>, \u00een C++), putem s\u0103 presupunem, pentru simplicitate, c\u0103 avem de r\u0103spuns doar la interog\u0103ri de tipul \\((C, p)\\).</p> <p>Determinarea tuturor insulelor \\(\\alpha\\) (adic\u0103 a coordonatelor celulelor ce intr\u0103 \u00een alc\u0103tuirea unei insule \u0219i a dimensiunii acesteia) se poate efectua \u00een complexitatea (total\u0103) de timp \\(\\mathcal{O}(n \\cdot m)\\), a\u0219a cum a fost descris anterior.</p> <p>\u00cen cadrul unei insule \\(\\alpha\\), s\u0103 introducem urm\u0103toarele dou\u0103 nota\u021bii:</p> <ul> <li>\\(\\mu_{y,\\alpha} = \\max(y_{\\alpha,1}, y_{\\alpha,2}, ..., y_{\\alpha,k_\\alpha})\\)</li> <li>\\(\\omega_{y,\\alpha} = \\min(y_{\\alpha,1}, y_{\\alpha,2}, ..., y_{\\alpha,k_\\alpha})\\)</li> </ul> <p>Mai mult, introducem \u0219i urm\u0103toarele dou\u0103 tablouri unidimensionale \\(l[1, ..., m]\\) \u0219i \\(r [1, ..., m]\\), definite astfel (pentru fiecare \\(1 \u2264 i \u2264 m\\)):</p> \\[ l[i] = \\sum_{\\substack{\\alpha \\\\ \\mu_{y,\\alpha} = i}} k_\\alpha; \\qquad r[i] = \\sum_{\\substack{\\alpha \\\\ \\omega_{y,\\alpha} = i}} k_\\alpha \\] <p>Cu alte cuvinte, \\(l[i]\\) reprezint\u0103 suma dimensiunilor insulelor din golf ce au valoarea maximal\u0103 a unei coloane (a unei celule din componen\u021b\u0103) egal\u0103 cu \\(i\\). Similar, \\(r[i]\\) reprezint\u0103 suma dimensiunilor insulelor din golf ce au valoarea minimal\u0103 a unei coloane egal\u0103 cu \\(i\\).</p> <p>A\u0219adar, r\u0103spunsul pentru o interogare de tipul \\((C, p)\\) este dat de valoarea expresiei \\(a \\cdot b\\), unde:</p> \\[ a = \\sum_{\\substack{\\alpha \\\\ \\mu_{y,\\alpha} &lt; p}} k_\\alpha = \\sum_{\\substack{\\alpha \\\\ \\mu_{y,\\alpha} \\in \\{1, ..., p-1\\}}} k_\\alpha = \\sum_{i = 1}^{p - 1} l[i] \\] <p>\u0219i</p> \\[ b = \\sum_{\\substack{\\alpha \\\\ \\omega_{y,\\alpha} &lt; p}} k_\\alpha = \\sum_{\\substack{\\alpha \\\\ \\omega_{y,\\alpha} \\in \\{p + 1, ..., m\\}}} k_\\alpha = \\sum_{i = p + 1}^{m} r[i] \\] <p>At\u00e2t \\(a\\), c\u00e2t \u0219i \\(b\\), pot fi calculate printr-o parcurgere (liniar\u0103) a tablourilor \\(l[1, ..., m]\\) \u0219i \\(r[1, ..., m]\\). \u00cen func\u021bie de elementul \\(i\\) de analizat (dac\u0103 \\(i &lt; p\\) sau \\(i &gt; p\\)), se actualizeaz\u0103 valoarea lui \\(a\\) sau valoarea lui \\(b\\).</p> <p>Astfel, complexitatea de timp necesar\u0103 pentru a rezolva o interogare de tipul \\((C, p)\\) este de \\(\\mathcal{O}(m)\\). Similar, complexitatea de timp necesar\u0103 pentru a rezolva o interogare de tipul \\((L, p)\\) este de \\(\\mathcal{O}(n)\\).</p> <p>Prin urmare, complexitatea total\u0103 a acestui subtask este de \\(\\mathcal{O} (n \\cdot m + Q \\cdot \\max (n, m))\\).</p>","tags":["OJI","clasa X"]},{"location":"olimpiada/solutii/OJI/2025/X-golf/#solutie-completa-pentru-t-3","title":"Solu\u021bie complet\u0103 pentru \\(T = 3\\)","text":"<p>Aplic\u0103m o metod\u0103 de rezolvare similar\u0103 cu cea pentru al cincilea subtask.</p> <p>Observ\u0103m c\u0103, \u00een cadrul unei interog\u0103ri, pentru a determina, de exemplu, valoarea lui \\(a\\), putem utiliza o tehnic\u0103 de sume par\u021biale, pe prefixele \u0219irului \\(l [1, ..., m]\\); de asemenea, valoarea lui \\(b\\) poate fi calculat\u0103 tot cu sume par\u021biale, pe sufixele \u0219irului \\(r [1, ..., m]\\). Procesarea sumelor par\u021biale se poate efectua \u00een complexitatea de timp (c\u00e2t \u0219i de spa\u021biu) de \\(\\mathcal{O}(m)\\) (pentru coloane) sau de \\(\\mathcal{O}(n)\\) (pentru linii). Apoi, rezolvarea oric\u0103rei actualiz\u0103ri se poate efectua \u00een \\(\\mathcal{O}(1)\\). Complexitatea de timp total\u0103 a acestei solu\u021bii este de \\(\\mathcal{O}(n \\cdot m + Q)\\). Spa\u021biul utilizat se \u00eencadreaz\u0103 \u00een \\(\\mathcal{O}(n \\cdot m)\\).</p>","tags":["OJI","clasa X"]},{"location":"olimpiada/solutii/OJI/2025/X-golf/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie care ia punctajul maxim.</p> <pre><code>/*\n    Autor: Andrei Onut (Yale University)\n    Problema: \"Golf\" (OJI 2025, clasa a X-a)\n*/\n\n#include &lt;algorithm&gt;\n#include &lt;fstream&gt;\n#include &lt;queue&gt;\n#include &lt;string&gt;\n#include &lt;vector&gt;\n\nint my_min(const int a, const int b) { return ((a &lt; b) ? a : b); }\nint my_max(const int a, const int b) { return ((a &gt; b) ? a : b); }\n\nstruct island {\n    int first_line, first_column;\n    int last_line, last_column;\n    int size;\n\n    island(const int x, const int y)\n        : first_line(x),\n          first_column(y),\n          last_line(x),\n          last_column(y),\n          size(1) {}\n\n    void update(const int x, const int y) {\n        first_line = my_min(first_line, x),\n        first_column = my_min(first_column, y);\n        last_line = my_max(last_line, x), last_column = my_max(last_column, y);\n        ++size;\n\n        return;\n    }\n};\n\ntemplate &lt;typename T&gt;\nstd::string T_to_string(T x) {\n    if (x == (T)0) {\n        return \"0\";\n    }\n\n    std::string answer;\n    while (x) {\n        answer += ((char)((x % (T)10) + '0')), x /= (T)10;\n    }\n\n    reverse(answer.begin(), answer.end());\n    return answer;\n}\n\nclass golf_solver {\n    const std::string problem_name = \"golf\", dot = \".\", input_format = \"in\",\n                      output_format = \"out\";\n\n    const int dx[4] = {(-1), 0, (+1), 0}, dy[4] = {0, (+1), 0, (-1)};\n\n    int T, n, m, q;\n\n    std::vector&lt;std::string&gt; A;\n\n    std::vector&lt;std::pair&lt;char, int&gt;&gt; queries;\n    std::vector&lt;long long&gt; answer;\n\n    std::vector&lt;island&gt; islands_arr;\n\n    int answer_1, answer_2;\n\n    island find_island(const int i, const int j,\n                       std::vector&lt;std::vector&lt;bool&gt;&gt; &amp;used) {\n        island answer(i, j);\n\n        std::queue&lt;std::pair&lt;int, int&gt;&gt; Q;\n\n        used[i][j] = true, Q.push({i, j});\n        while (!Q.empty()) {\n            for (int dir = 0; dir &lt; 4; ++dir) {\n                int x(Q.front().first + dx[dir]), y(Q.front().second + dy[dir]);\n\n                if ((x &lt; 0) || (x &gt;= n) || (y &lt; 0) || (y &gt;= m)) {\n                    continue;\n                }\n\n                if (A[x][y] == '0') {\n                    continue;\n                }\n                if (used[x][y] == true) {\n                    continue;\n                }\n\n                used[x][y] = true, Q.push({x, y});\n                answer.update(x, y);\n            }\n\n            Q.pop();\n        }\n\n        return answer;\n    }\n\n    void solve_T_1() {\n        for (const island &amp;it : islands_arr) {\n            answer_1 += it.size;\n        }\n\n        return;\n    }\n\n    void solve_T_2() {\n        if (islands_arr.empty()) {\n            return;\n        }\n\n        int max_size(-1);\n        for (const island &amp;it : islands_arr) {\n            if (it.size &gt; max_size) {\n                max_size = it.size, answer_2 = 1;\n            } else if (it.size == max_size) {\n                ++answer_2;\n            }\n        }\n\n        return;\n    }\n\n    std::vector&lt;std::pair&lt;std::pair&lt;int, int&gt;, int&gt;&gt; extract_segments(\n        const int axis) {\n        std::vector&lt;std::pair&lt;std::pair&lt;int, int&gt;, int&gt;&gt; answer;\n\n        for (const island &amp;it : islands_arr) {\n            if (axis == 0) {\n                answer.push_back({\n                    {it.first_column, it.last_column},\n                    it.size\n                });\n            } else {\n                answer.push_back({\n                    {it.first_line, it.last_line},\n                    it.size\n                });\n            }\n        }\n\n        return answer;\n    }\n\n    std::pair&lt;std::vector&lt;int&gt;, std::vector&lt;int&gt;&gt; get_sums(const int axis,\n                                                           const int elements) {\n        std::vector&lt;int&gt; prefix(elements, 0), suffix(elements, 0);\n\n        std::vector&lt;std::pair&lt;std::pair&lt;int, int&gt;, int&gt;&gt; segments =\n            extract_segments(axis);\n\n        std::vector&lt;int&gt; end_num(elements, 0), start_num(elements, 0);\n        for (const std::pair&lt;std::pair&lt;int, int&gt;, int&gt; &amp;it : segments) {\n            end_num[it.first.second] += it.second,\n                start_num[it.first.first] += it.second;\n        }\n\n        prefix[0] = end_num[0],\n        suffix[(elements - 1)] = start_num[(elements - 1)];\n        for (int i = 1; i &lt; elements; ++i) {\n            prefix[i] = (prefix[(i - 1)] + end_num[i]),\n            suffix[(elements - 1 - i)] =\n                (suffix[(elements - i)] + start_num[(elements - 1 - i)]);\n        }\n\n        return {prefix, suffix};\n    }\n\n    long long evaluate(const int q_idx, const int elements,\n                       const std::pair&lt;std::vector&lt;int&gt;, std::vector&lt;int&gt;&gt; &amp;V) {\n        if ((q_idx == 1) || (q_idx == elements)) {\n            return 0LL;\n        }\n        return (1LL * V.first[(q_idx - 2)] * V.second[q_idx]);\n    }\n\n    void solve_T_3() {\n        std::pair&lt;std::vector&lt;int&gt;, std::vector&lt;int&gt;&gt; columns = get_sums(0, m),\n                                                      lines = get_sums(1, n);\n\n        int i = 0;\n        for (const std::pair&lt;char, int&gt; &amp;it : queries) {\n            answer[(i++)] = ((it.first == 'C') ? evaluate(it.second, m, columns)\n                                               : evaluate(it.second, n, lines));\n        }\n\n        return;\n    }\n\npublic:\n    golf_solver() : T(0), n(0), m(0), q(0), answer_1(0), answer_2(0) {}\n\n    void read() {\n        std::ifstream f(problem_name + dot + input_format);\n\n        f &gt;&gt; T &gt;&gt; n &gt;&gt; m;\n\n        A = std::vector&lt;std::string&gt;(n, std::string(m, ' '));\n        for (int i(0); i &lt; n; ++i) {\n            f &gt;&gt; A[i];\n        }\n\n        if (T == 3) {\n            f &gt;&gt; q;\n\n            queries = std::vector&lt;std::pair&lt;char, int&gt;&gt;(q),\n            answer = std::vector&lt;long long&gt;(q);\n            for (int i(0); i &lt; q; ++i) {\n                f &gt;&gt; queries[i].first &gt;&gt; queries[i].second;\n            }\n        }\n\n        f.close();\n        return;\n    }\n\n    void pre_compute() {\n        std::vector&lt;std::vector&lt;bool&gt;&gt; used(n, std::vector&lt;bool&gt;(m, false));\n\n        for (int i = 0; i &lt; n; ++i) {\n            for (int j = 0; j &lt; m; ++j) {\n                if ((A[i][j] == '1') &amp;&amp; (used[i][j] == false)) {\n                    islands_arr.push_back(find_island(i, j, used));\n                }\n            }\n        }\n\n        return;\n    }\n\n    void solve() {\n        ((T == 1) ? solve_T_1() : ((T == 2) ? solve_T_2() : solve_T_3()));\n        return;\n    }\n\n    void print() {\n        std::ofstream g(problem_name + dot + output_format);\n\n        std::vector&lt;std::string&gt; output_lines(((T &lt;= 2) ? 1 : q));\n\n        if (T == 1) {\n            output_lines[0] = T_to_string&lt;int&gt;(answer_1);\n        } else if (T == 2) {\n            output_lines[0] = T_to_string&lt;int&gt;(answer_2);\n        } else {\n            for (int i = 0; i &lt; q; ++i) {\n                output_lines[i] = T_to_string&lt;long long&gt;(answer[i]);\n            }\n        }\n\n        for (const std::string &amp;line : output_lines) {\n            g &lt;&lt; line &lt;&lt; '\\n';\n        }\n\n        g.close();\n        return;\n    }\n};\n\nint main() {\n    golf_solver S;\n\n    S.read();\n    S.pre_compute();\n    S.solve();\n    S.print();\n\n    return 0;\n}\n</code></pre>","tags":["OJI","clasa X"]},{"location":"olimpiada/solutii/OJI/2025/XI-XII-aventura/","title":"Solu\u021bia problemei Aventura (OJI 2025, clasele XI-XII)","text":"<p>Vom nota \\(k_1 + k_2 + \\dots + k_N\\) cu \\(\\sum K\\).</p>","tags":["OJI","clasa XI-XII","grafuri"]},{"location":"olimpiada/solutii/OJI/2025/XI-XII-aventura/#subtask-1","title":"Subtask 1","text":"<p>Se genereaz\u0103 toate permut\u0103rile \u0219irului \\(1, 2, \\dots, N\\), iar pentru fiecare \u0219ir se \u00eencearc\u0103 completarea nivelelor \u00een ordinea generat\u0103.</p> <p>Complexitate \\(O(N! \\cdot \\sum K)\\).</p>","tags":["OJI","clasa XI-XII","grafuri"]},{"location":"olimpiada/solutii/OJI/2025/XI-XII-aventura/#subtask-2","title":"Subtask 2","text":"<p>O dependen\u021b\u0103 circular\u0103 de dimensiune exact \\(2\\) reprezint\u0103, \u00een graful format de restric\u021biile jocului, un ciclu de lungime \\(2\\). Mai precis, dac\u0103 fix\u0103m dou\u0103 nivele \\(i\\) \u0219i \\(j\\) din graf \u0219i exist\u0103 muchii \u00een ambele sensuri, atunci este clar c\u0103 ambele nivele nu vor putea fi completate vreodat\u0103. Acest lucru se poate verifica u\u0219or dac\u0103 muchiile din graf sunt re\u021binute \u00eentr-o matrice de adiacen\u021b\u0103.</p> <p>Putem porni din unul dintre cele dou\u0103 nivele o parcurgere DFS, deoarece orice nivel care anterior era condi\u021bionat de unul dintre aceste nivele clar nu va fi parcurs niciodat\u0103.</p> <p>\u00cen final, restul nivelelor nemarcate vor putea fi completate \u00een joc.</p> <p>Complexitate \\(O(N^2)\\).</p>","tags":["OJI","clasa XI-XII","grafuri"]},{"location":"olimpiada/solutii/OJI/2025/XI-XII-aventura/#subtask-3","title":"Subtask 3","text":"<p>Pentru fiecare nivel, vom \u021bine minte \\(grad[x]\\) \u2013 num\u0103rul de nivele de care este condi\u021bionat nivelul \\(x\\). La fiecare pas, vom c\u0103uta un nivel \\(i\\) care are \\(grad[i] = 0\\) \u0219i vom sc\u0103dea gradul fiec\u0103rui nivel condi\u021bionat de nivelul \\(i\\).</p> <p>Complexitate \\(O(N^2 + \\sum K)\\).</p>","tags":["OJI","clasa XI-XII","grafuri"]},{"location":"olimpiada/solutii/OJI/2025/XI-XII-aventura/#subtask-4","title":"Subtask 4","text":"<p>Vom folosi construc\u021bia de la subtaskul precedent, \u00eens\u0103, \u00een loc s\u0103 c\u0103ut\u0103m manual nivelele cu gradul \\(0\\), vom utiliza o coad\u0103. Mai \u00eent\u00e2i, vom ad\u0103uga \u00een coad\u0103 toate nivelele care au gradul ini\u021bial egal cu \\(0\\).</p> <p>Apoi, vom parcurge coada, iar \u00een momentul \u00een care sc\u0103dem gradele vecinilor nivelului curent, dac\u0103 unul dintre vecini ajunge la gradul \\(0\\), \u00eel vom ad\u0103uga \u00een coad\u0103.</p> <p>Complexitate \\(O(N + \\sum K)\\).</p>","tags":["OJI","clasa XI-XII","grafuri"]},{"location":"olimpiada/solutii/OJI/2025/XI-XII-aventura/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie care ia punctajul maxim.</p> <pre><code>// OJI 2025 11-12 Ivan Andrei\n// Aventura ASSERT 1+2+3+4\n#include &lt;bits/stdc++.h&gt;\n\nusing namespace std;\n\nconst int max_size = 5e5 + 5;\n\nvector&lt;int&gt; nxt[max_size];\nint deg[max_size], sumall;\nqueue&lt;int&gt; q;\n\nvoid solve() {\n    int n;\n    cin &gt;&gt; n;\n    assert(n &lt;= 500000);\n    for (int i = 1; i &lt;= n; i++) {\n        nxt[i].clear();\n    }\n    int sumk = 0;\n    for (int i = 1; i &lt;= n; i++) {\n        int k;\n        cin &gt;&gt; k;\n        sumk += k;\n        if (k == 0) {\n            q.push(i);\n        }\n        deg[i] = k;\n        assert(deg[i] &gt;= 0);\n        while (k--) {\n            int x;\n            cin &gt;&gt; x;\n            nxt[x].push_back(i);\n            assert(x != i);\n        }\n    }\n    assert(sumk &lt;= 4 * n);\n    int ans = 0;\n    sumall += sumk;\n    while (!q.empty()) {\n        int nod = q.front();\n        q.pop();\n        ans++;\n        for (auto f : nxt[nod]) {\n            deg[f]--;\n            if (deg[f] == 0) {\n                q.push(f);\n            }\n        }\n    }\n    cout &lt;&lt; ans;\n    cout &lt;&lt; '\\n';\n}\n\nint main() {\n#ifdef LOCAL\n    freopen(\"test.in\", \"r\", stdin);\n    freopen(\"test.out\", \"w\", stdout);\n#else\n    freopen(\"aventura.in\", \"r\", stdin);\n    freopen(\"aventura.out\", \"w\", stdout);\n#endif\n    int t;\n    cin &gt;&gt; t;\n    assert(t &lt;= 5);\n    // t = 1;\n    while (t--) {\n        solve();\n    }\n    assert(sumall &lt;= 5000000);\n    return 0;\n}\n</code></pre>","tags":["OJI","clasa XI-XII","grafuri"]},{"location":"olimpiada/solutii/OJI/2025/XI-XII-cromatic/","title":"Solu\u021bia problemei Cromatic (OJI 2025, clasele XI-XII)","text":"<p>S\u0103 presupunem c\u0103 \u0219irul \\(a = (a_1, a_2, \\dots, a_n)\\) este cromatic. Condi\u021bia ca \u0219irul de intervale \u00eenchise minmax:</p> \\[[min_1, max_1], [min_2, max_2], \\dots, [min_n, max_n]\\] <p>s\u0103 aib\u0103 toate elementele distincte implic\u0103 faptul c\u0103 orice element \\(a_k\\), dac\u0103 este comparat cu intervalul de pe pozi\u021bia anterioar\u0103 lui \\(k\\): \\([min_{k-1}, max_{k-1}]\\), atunci \\(a_k &lt; min_{k-1}\\) sau \\(a_k &gt; max_{k-1}\\).</p> <p>De aici putem deduce c\u0103, fa\u021b\u0103 de elementul \\(a_1\\), elementele urm\u0103toare din \u0219ir formeaz\u0103 dou\u0103 sub\u0219iruri strict monotone. Elementele mai mari dec\u00e2t \\(a_1\\) formeaz\u0103 un \u0219ir strict cresc\u0103tor, iar elementele mai mici dec\u00e2t \\(a_1\\) formeaz\u0103 un \u0219ir strict descresc\u0103tor. Dac\u0103 aceste dou\u0103 sub\u0219iruri le interclas\u0103m \u00een toate modurile posibile, fiecare \u0219ir nou ob\u021binut va fi un \u0219ir cromatic.</p> <p>Consider\u00e2nd c\u0103 avem un \u0219ir \\(a = (a_1, a_2, \\dots, a_n)\\), nu neap\u0103rat cromatic, pentru a ob\u021bine prin rearanjarea elementelor toate permut\u0103rile cromatice, vom rearanja elementele \u0219irului \u00een ordine cresc\u0103toare.</p> <p>\u00cen continuare vom considera c\u0103 elementele \u0219irului \\(a\\) sunt ordonate cresc\u0103tor.</p> <p>Se poate demonstra u\u0219or c\u0103 dac\u0103 \u00een \u0219ir exist\u0103 dou\u0103 elemente egale, atunci \u0219irul nu este cromatic \u0219i nu exist\u0103 nicio alt\u0103 permutare cromatic\u0103, deci NSC = 0.</p> <p>Pentru a calcula num\u0103rul \u0219irurilor cromatice NSC, \u00een continuare vom accepta c\u0103 \u0219irul \\(a\\) este strict cresc\u0103tor: \\(a_1 &lt; a_2 &lt; \\dots &lt; a_n\\).</p> <p>Acest \u0219ir este cromatic \u0219i \u00een lista \u0219irurilor cromatice este primul \u00een ordine lexicografic\u0103.</p> <p>Observ\u0103m c\u0103 \u00een lista ordonat\u0103 lexicografic a tuturor \u0219irurilor cromatice elementele respect\u0103 urm\u0103toarele propriet\u0103\u021bi:</p> <ul> <li>(Grupa 1) \\(a_1, a_2, a_3, \\dots, a_n\\)</li> <li>(Grupa 2) \\(a_2\\) urmat de \\((a_3, a_4, \\dots, a_n)\\) \u0219i \\((a_1)\\) interclasate \u00een toate modurile posibile</li> <li>(Grupa 3) \\(a_3\\) urmat de \\((a_4, a_5, \\dots, a_n)\\) \u0219i \\((a_2, a_1)\\) interclasate \u00een toate modurile posibile</li> <li>\\(\\dots\\)</li> <li>(Grupa \\(k\\)) \\(a_k\\) urmat de \\((a_{k+1}, a_{k+2}, \\dots, a_n)\\) \u0219i \\((a_{k-1}, a_{k-2}, \\dots, a_1)\\) interclasate \u00een toate modurile posibile</li> <li>\\(\\dots\\)</li> <li>(Grupa \\(n\\)) \\(a_n, a_{n-1}, \\dots, a_1\\)</li> </ul> <p>Observ\u0103m c\u0103 \u00een fiecare grup\u0103 \\(k\\) \\((1 \\leq k \\leq n)\\), num\u0103rul \u0219irurilor cromatice distincte este egal cu \\(C_{n-1}^{k-1}\\).</p> <p>De aici deducem c\u0103:</p> \\[NSC = C_{n-1}^{0} + C_{n-1}^{1} + \\dots + C_{n-1}^{n-1} = 2^{n-1}\\] <p>\u00cen cadrul unei grupe \\(k\\), ordinea lexicografic\u0103 a \u0219irurilor este determinat\u0103 de elementele sub\u0219irului descresc\u0103tor \\((a_{k-1}, a_{k-2}, \\dots, a_1)\\). Num\u0103rul de modalit\u0103\u021bi de aranjare a celor \\(k - 1\\) elemente pe cele \\(n - 1\\) pozi\u021bii este egal cu \\(C_{n-1}^{k-1}\\). Folosind aceast\u0103 proprietate vom putea calcula pozi\u021bia \\(p\\) a unui \u0219ir \u00een lista permut\u0103rilor cromatice, sau pentru un \u0219ir cromatic dat, pozi\u021bia lui \\(q\\) \u00een ordine lexicografic\u0103, folosind suma de combin\u0103ri de ordin tot mai mic.</p>","tags":["OJI","clasa XI-XII","combinatorica"]},{"location":"olimpiada/solutii/OJI/2025/XI-XII-cromatic/#subtaskurile-1-si-2","title":"Subtaskurile 1 \u0219i 2","text":"<p>Cazul \\(c = 1\\), num\u0103rul \u0219irurilor cromatice va fi egal cu \\(NSC = 0\\), dac\u0103 avem elemente egale \u00een \u0219ir, respectiv \\(NSC = 2^{n\u22121}\\) modulo \\(1 \\ 000 \\ 000 \\ 007\\).</p>","tags":["OJI","clasa XI-XII","combinatorica"]},{"location":"olimpiada/solutii/OJI/2025/XI-XII-cromatic/#subtaskurile-3-4-5-6","title":"Subtaskurile 3, 4, 5, 6","text":"<p>Cazul \\(c = 2\\). \u00cen subtaskul 3 este vorba despre o pozi\u021bie \\(p\\) dintre primele \\(n\\) solu\u021bii \u00een ordine lexicografic\u0103. Aceast\u0103 cerin\u021b\u0103 se poate rezolva cu un ciclu simplu \u00een complexitate \\(O(n)\\).</p> <p>\u00cen subtaskul 4 este vorba despre o pozi\u021bie \\(p\\) dintre ultimele \\(n\\) solu\u021bii \u00een ordine lexicografic\u0103. \u0218i aceast\u0103 cerin\u021b\u0103 se poate rezolva cu un ciclu simplu \u00een complexitate O(n).</p> <p>Urm\u0103toarele subtaskuri trateaz\u0103 cazuri generale:</p> <ul> <li>Subtaskul 5, av\u00e2nd cazul \\(n \\leq 20\\), se poate rezolva cu un algoritm backtracking cu complexitate \\(O(2^{n-1})\\).</li> <li>Subtaskul 6 se rezolv\u0103 \u00een complexitate \\(O(n)\\) cu ajutorul sumelor de combin\u0103ri.</li> </ul>","tags":["OJI","clasa XI-XII","combinatorica"]},{"location":"olimpiada/solutii/OJI/2025/XI-XII-cromatic/#subtaskurile-7-8-9-10","title":"Subtaskurile 7, 8, 9, 10","text":"<p>Cazul \\(c = 3\\). Similar cu subtaskurile 3, 4, 5 \u0219i 6, observ\u0103m c\u0103:</p> <ul> <li>Subtaskul 7, fiind caz particular, se rezolv\u0103 \u00een complexitate \\(O(n)\\).</li> <li>Subtaskul 8, fiind caz particular, se rezolv\u0103 \u00een complexitate \\(O(n)\\).</li> <li>Subtaskul 9 se poate rezolva cu un algoritm backtracking cu complexitate \\(O(2^{n-1})\\).</li> <li>Subtaskul 10 se rezolv\u0103 \u00een complexitate \\(O(n)\\) cu ajutorul sumelor de combin\u0103ri.</li> </ul>","tags":["OJI","clasa XI-XII","combinatorica"]},{"location":"olimpiada/solutii/OJI/2025/XI-XII-cromatic/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie care ia punctajul maxim.</p> <pre><code>// Zoltan Szabo ISJ Mures\n#include &lt;algorithm&gt;\n#include &lt;fstream&gt;\nusing namespace std;\nifstream fin(\"cromatic.in\");\nofstream fout(\"cromatic.out\");\nlong long comb(int n, int k) {\n    long long p = 1;\n    for (int i = 1; i &lt;= k; i++) {\n        p = p * n / i;\n        n--;\n    }\n    return p;\n}\nint main() {\n    long long p, nr, nrsol = 0;\n    int c, n, v[300005];\n    fin &gt;&gt; c &gt;&gt; n;\n    if (c == 3) {\n        fin &gt;&gt; p;\n    }\n    for (int i = 1; i &lt;= n; i++) {\n        fin &gt;&gt; v[i];\n    }\n    if (c == 1) {\n        sort(v + 1, v + n + 1);\n        for (int i = 1; i &lt; n; i++) {\n            if (v[i] == v[i + 1]) {\n                fout &lt;&lt; 0;\n                return 0;\n            }\n        }\n        p = 1;\n        for (int i = 1; i &lt;= n - 1; i++) {\n            p = (p * 2) % 1000000007;\n        }\n        fout &lt;&lt; p;\n        return 0;\n    } else if (c == 2) {\n        nr = 0;\n        for (int i = 2; i &lt;= n; i++) {\n            if (v[1] &gt; v[i]) {\n                nr++;\n            }\n        }\n        if (nr == 0) {\n            fout &lt;&lt; 1;\n            return 0;\n        }\n        nrsol = 0;\n        int N = n - 1;\n        for (int i = 0; i &lt;= nr - 1; i++) {\n            nrsol = nrsol + comb(N, i);\n        }\n        for (int i = 2; i &lt;= n; i++) {\n            if (v[i - 1] &gt; v[i]) {\n                nr--;\n                N--;\n                if (nr == 0) {\n                    nrsol++;\n                    break;\n                }\n            } else {\n                nrsol = nrsol + comb(N - 1, nr - 1);\n                N--;\n            }\n        }\n        fout &lt;&lt; nrsol;\n    } else if (c == 3) {\n        sort(v + 1, v + n + 1);\n        nr = 0;\n        long long C = comb(n - 1, nr);\n        while (p &gt; C) {\n            p = p - C;\n            nr++;\n            C = comb(n - 1, nr);\n        }\n        fout &lt;&lt; v[nr + 1];\n        int mare = nr + 2;\n        for (int i = 2; i &lt;= n; i++) {\n            long long C = comb(n - i, nr - 1);\n            if (p &lt;= C) {\n                fout &lt;&lt; \" \" &lt;&lt; v[nr--];\n                if (nr == 0) {\n                    break;\n                }\n            } else {\n                fout &lt;&lt; \" \" &lt;&lt; v[mare++];\n                p = p - C;\n            }\n        }\n        while (mare &lt;= n) {\n            fout &lt;&lt; \" \" &lt;&lt; v[mare++];\n        }\n    }\n    return 0;\n}\n</code></pre>","tags":["OJI","clasa XI-XII","combinatorica"]},{"location":"olimpiada/solutii/OJI/2025/XI-XII-experimente/","title":"Solu\u021bia problemei Experimente (OJI 2025, clasele XI-XII)","text":"<p>Observa\u021bie ini\u021bial\u0103: Problema poate fi reformulat\u0103 astfel: d\u00e2ndu-se un \u0219ir circular \u0219i update-uri sub forma unor intervale continue, s\u0103 se calculeze dup\u0103 fiecare update cardinalul intersec\u021biei tuturor intervalelor de p\u00e2n\u0103 atunci.</p>","tags":["OJI","clasa XI-XII","structuri de date","stl"]},{"location":"olimpiada/solutii/OJI/2025/XI-XII-experimente/#subtask-1","title":"Subtask 1","text":"<p>Restric\u021biile pentru acest subtask implic\u0103 faptul c\u0103 putem considera \u0219irul ca fiind necircular. \u00cen acest caz intersectia unor intervale va fi tot timpul un singur interval continuu.</p> <p>Este de ajuns s\u0103 re\u021binem cel mai mare cap\u0103t de start \u0219i cel mai mic cap\u0103t de final al intevalelor de update pentru a afla r\u0103spunsul.</p>","tags":["OJI","clasa XI-XII","structuri de date","stl"]},{"location":"olimpiada/solutii/OJI/2025/XI-XII-experimente/#subtaskurile-2-3-4-5","title":"Subtaskurile 2, 3, 4, 5","text":"<p>Pentru celelalte subtaskuri, intersec\u021bia update-urilor va fi reprezentat\u0103 de o mul\u021bime \\(M\\) format\u0103 din mai multe intervale, nu doar unul singur (ini\u021bial consider\u0103m \\(M\\) format\u0103 dintr-un singur interval \\([1, N]\\)).</p> <p>\u00cen momentul \u00een care avem un update nou \\(U\\), pentru fiecare interval \\(I\\) din \\(M\\) exist\u0103 \\(3\\) scenarii posibile:</p> <ol> <li>\\(I\\) este inclus complet in \\(U\\), trebuie p\u0103strat \u00een \\(M\\);</li> <li>\\(I\\) nu se intersecseaz\u0103 cu \\(U\\), trebuie scos din M;</li> <li>\\(I\\) \u0219i \\(U\\) se intersecteaz\u0103 f\u0103r\u0103 ca \\(I\\) s\u0103 fie complet inclus \u00een    \\(U\\), \\(I\\) trebuie \u00eenlocuit.</li> </ol> <p>Pentru scenariul 3, facem urm\u0103toarele observa\u021bii:</p> <ul> <li>exist\u0103 maxim \\(2\\) intervale \\(I\\) care se pot afla \u00een aceast\u0103 situa\u021bie;</li> <li>I trebuie \u00eenlocuit fie cu un alt interval, fie cu alte dou\u0103 intervale.</li> </ul> <p>\u00een func\u021bie de structura de date aleas\u0103, se pot rezolva diferite subtaskuri. Solu\u021bia oficial\u0103 folose\u0219te un set pentru o complexitate de \\(O(M \\log M)\\).</p>","tags":["OJI","clasa XI-XII","structuri de date","stl"]},{"location":"olimpiada/solutii/OJI/2025/XI-XII-experimente/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie care ia punctajul maxim.</p> <pre><code>// Andrei Grigorean CS Academy\n#include &lt;cassert&gt;\n#include &lt;iostream&gt;\n#include &lt;limits&gt;\n#include &lt;set&gt;\nusing namespace std;\n\nconst int MAX_N = (int)1e9;\nconst int MAX_M = (int)1e5;\n\nint n, m;\nint ans;\nset&lt;pair&lt;int, int&gt;&gt; s;\n\nvoid addInterval(int left, int right) {\n    ans += right - left + 1;\n    s.insert({left, right});\n}\n\nvoid removeInterval(set&lt;pair&lt;int, int&gt;&gt;::iterator it) {\n    ans -= it-&gt;second - it-&gt;first + 1;\n    s.erase(it);\n}\n\nvoid splitIntersections(int pos) {\n    auto entry = s.lower_bound({pos + 1, numeric_limits&lt;int&gt;::min()});\n    if (entry != s.begin()) {\n        entry = prev(entry);\n    }\n    if (entry == s.end()) {\n        return;\n    }\n\n    int left = entry-&gt;first, right = entry-&gt;second;\n    if (pos &gt; left &amp;&amp; pos &lt;= right) {\n        removeInterval(entry);\n        addInterval(left, pos - 1);\n        addInterval(pos, right);\n    }\n}\n\nint main() {\n    assert(freopen(\"experimente.in\", \"r\", stdin));\n    assert(freopen(\"experimente.out\", \"w\", stdout));\n\n    cin &gt;&gt; n &gt;&gt; m;\n    assert(1 &lt;= n &amp;&amp; n &lt;= MAX_N);\n    assert(1 &lt;= m &amp;&amp; m &lt;= MAX_M);\n    addInterval(0, n - 1);\n\n    for (int i = 1; i &lt;= m; ++i) {\n        int left, right;\n        cin &gt;&gt; left &gt;&gt; right;\n        assert(0 &lt;= left &amp;&amp; left &lt; n);\n        assert(0 &lt;= right &amp;&amp; right &lt; n);\n        if (i &gt; 1) {\n            left = (left + ans) % n;\n            right = (right + ans) % n;\n        }\n\n        splitIntersections(left);\n        splitIntersections(right + 1);\n\n        if (left &lt;= right) {\n            while (!s.empty() &amp;&amp; s.begin()-&gt;second &lt; left) {\n                removeInterval(s.begin());\n            }\n            while (!s.empty() &amp;&amp; prev(s.end())-&gt;first &gt; right) {\n                removeInterval(prev(s.end()));\n            }\n            cout &lt;&lt; ans &lt;&lt; \"\\n\";\n        } else {\n            auto startIt =\n                s.lower_bound({right + 1, numeric_limits&lt;int&gt;::min()});\n            auto endIt = startIt;\n            while (endIt != s.end() &amp;&amp; endIt-&gt;second &lt; left) {\n                ans -= endIt-&gt;second - endIt-&gt;first + 1;\n                endIt = next(endIt);\n            }\n            s.erase(startIt, endIt);\n            cout &lt;&lt; ans &lt;&lt; \"\\n\";\n        }\n    }\n    return 0;\n}\n</code></pre>","tags":["OJI","clasa XI-XII","structuri de date","stl"]},{"location":"olimpiada/solutii/ONI/2002/IX-becuri/","title":"Solu\u021bia problemei becuri (ONI 2002, clasa a IX-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa IX"]},{"location":"olimpiada/solutii/ONI/2002/IX-becuri/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa IX"]},{"location":"olimpiada/solutii/ONI/2002/IX-cod/","title":"Solu\u021bia problemei cod (ONI 2002, clasa a IX-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa IX"]},{"location":"olimpiada/solutii/ONI/2002/IX-cod/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa IX"]},{"location":"olimpiada/solutii/ONI/2002/IX-discuri/","title":"Solu\u021bia problemei discuri (ONI 2002, clasa a IX-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa IX"]},{"location":"olimpiada/solutii/ONI/2002/IX-discuri/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa IX"]},{"location":"olimpiada/solutii/ONI/2002/IX-pentagon/","title":"Solu\u021bia problemei pentagon (ONI 2002, clasa a IX-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa IX"]},{"location":"olimpiada/solutii/ONI/2002/IX-pentagon/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa IX"]},{"location":"olimpiada/solutii/ONI/2002/IX-pod/","title":"Solu\u021bia problemei pod (ONI 2002, clasa a IX-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa IX"]},{"location":"olimpiada/solutii/ONI/2002/IX-pod/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa IX"]},{"location":"olimpiada/solutii/ONI/2002/IX-suma/","title":"Solu\u021bia problemei suma (ONI 2002, clasa a IX-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa IX"]},{"location":"olimpiada/solutii/ONI/2002/IX-suma/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa IX"]},{"location":"olimpiada/solutii/ONI/2002/X-aliniere/","title":"Solu\u021bia problemei aliniere (ONI 2002, clasa a X-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa X"]},{"location":"olimpiada/solutii/ONI/2002/X-aliniere/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa X"]},{"location":"olimpiada/solutii/ONI/2002/X-balanta/","title":"Solu\u021bia problemei balanta (ONI 2002, clasa a X-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa X"]},{"location":"olimpiada/solutii/ONI/2002/X-balanta/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa X"]},{"location":"olimpiada/solutii/ONI/2002/X-foto/","title":"Solu\u021bia problemei foto (ONI 2002, clasa a X-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa X"]},{"location":"olimpiada/solutii/ONI/2002/X-foto/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa X"]},{"location":"olimpiada/solutii/ONI/2002/X-hotel/","title":"Solu\u021bia problemei hotel (ONI 2002, clasa a X-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa X"]},{"location":"olimpiada/solutii/ONI/2002/X-hotel/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa X"]},{"location":"olimpiada/solutii/ONI/2002/X-lac/","title":"Solu\u021bia problemei lac (ONI 2002, clasa a X-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa X"]},{"location":"olimpiada/solutii/ONI/2002/X-lac/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa X"]},{"location":"olimpiada/solutii/ONI/2002/X-logic/","title":"Solu\u021bia problemei logic (ONI 2002, clasa a X-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa X"]},{"location":"olimpiada/solutii/ONI/2002/X-logic/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa X"]},{"location":"olimpiada/solutii/ONI/2002/XI-XII-arbore/","title":"Solu\u021bia problemei arbore (ONI 2002, clasele XI-XII)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa XI-XII"]},{"location":"olimpiada/solutii/ONI/2002/XI-XII-arbore/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa XI-XII"]},{"location":"olimpiada/solutii/ONI/2002/XI-XII-comitat/","title":"Solu\u021bia problemei comitat (ONI 2002, clasele XI-XII)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa XI-XII"]},{"location":"olimpiada/solutii/ONI/2002/XI-XII-comitat/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa XI-XII"]},{"location":"olimpiada/solutii/ONI/2002/XI-XII-decod/","title":"Solu\u021bia problemei decod (ONI 2002, clasele XI-XII)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa XI-XII"]},{"location":"olimpiada/solutii/ONI/2002/XI-XII-decod/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa XI-XII"]},{"location":"olimpiada/solutii/ONI/2002/XI-XII-seti/","title":"Solu\u021bia problemei seti (ONI 2002, clasele XI-XII)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa XI-XII"]},{"location":"olimpiada/solutii/ONI/2002/XI-XII-seti/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa XI-XII"]},{"location":"olimpiada/solutii/ONI/2002/XI-XII-sistem/","title":"Solu\u021bia problemei sistem (ONI 2002, clasele XI-XII)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa XI-XII"]},{"location":"olimpiada/solutii/ONI/2002/XI-XII-sistem/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa XI-XII"]},{"location":"olimpiada/solutii/ONI/2002/XI-XII-sumdiv/","title":"Solu\u021bia problemei Sumdiv (ONI 2002, clasele XI-XII)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa XI-XII"]},{"location":"olimpiada/solutii/ONI/2002/XI-XII-sumdiv/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa XI-XII"]},{"location":"olimpiada/solutii/ONI/2003/IX-criptare/","title":"Solu\u021bia problemei criptare (ONI 2003, clasa a IX-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa IX"]},{"location":"olimpiada/solutii/ONI/2003/IX-criptare/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa IX"]},{"location":"olimpiada/solutii/ONI/2003/IX-masina/","title":"Solu\u021bia problemei masina (ONI 2003, clasa a IX-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa IX"]},{"location":"olimpiada/solutii/ONI/2003/IX-masina/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa IX"]},{"location":"olimpiada/solutii/ONI/2003/V-numereprime/","title":"Solu\u021bia problemei Numere Prime (ONI 2003, clasa a V-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa V"]},{"location":"olimpiada/solutii/ONI/2003/V-numereprime/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa V"]},{"location":"olimpiada/solutii/ONI/2003/V-poartaorintiei/","title":"Solu\u021bia problemei Poarta Orintiei (ONI 2003, clasa a V-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa V"]},{"location":"olimpiada/solutii/ONI/2003/V-poartaorintiei/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa V"]},{"location":"olimpiada/solutii/ONI/2003/V-sarituracangurului/","title":"Solu\u021bia problemei S\u0103ritura Cangurului (ONI 2003, clasa a V-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa V"]},{"location":"olimpiada/solutii/ONI/2003/V-sarituracangurului/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa V"]},{"location":"olimpiada/solutii/ONI/2003/VI-numar/","title":"Solu\u021bia problemei numar (ONI 2003, clasa a VI-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa VI"]},{"location":"olimpiada/solutii/ONI/2003/VI-numar/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa VI"]},{"location":"olimpiada/solutii/ONI/2003/VI-oradesport/","title":"Solu\u021bia problemei Ora de Sport (ONI 2003, clasa a VI-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa VI"]},{"location":"olimpiada/solutii/ONI/2003/VI-oradesport/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa VI"]},{"location":"olimpiada/solutii/ONI/2003/VI-reorganizare/","title":"Solu\u021bia problemei reorganizare (ONI 2003, clasa a VI-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa VI"]},{"location":"olimpiada/solutii/ONI/2003/VI-reorganizare/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa VI"]},{"location":"olimpiada/solutii/ONI/2003/VII-debarcare/","title":"Solu\u021bia problemei Debarcare (ONI 2003, clasa a VII-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa VII"]},{"location":"olimpiada/solutii/ONI/2003/VII-debarcare/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa VII"]},{"location":"olimpiada/solutii/ONI/2003/VII-domino/","title":"Solu\u021bia problemei Domino (ONI 2003, clasa a VII-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa VII"]},{"location":"olimpiada/solutii/ONI/2003/VII-domino/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa VII"]},{"location":"olimpiada/solutii/ONI/2003/VII-portocal/","title":"Solu\u021bia problemei Portocal (ONI 2003, clasa a VII-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa VII"]},{"location":"olimpiada/solutii/ONI/2003/VII-portocal/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa VII"]},{"location":"olimpiada/solutii/ONI/2003/VIII-cuburi/","title":"Solu\u021bia problemei cuburi (ONI 2003, clasa a VIII-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa VIII"]},{"location":"olimpiada/solutii/ONI/2003/VIII-cuburi/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa VIII"]},{"location":"olimpiada/solutii/ONI/2003/VIII-cutiidebomboane/","title":"Solu\u021bia problemei Cutii de Bomboane (ONI 2003, clasa a VIII-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa VIII"]},{"location":"olimpiada/solutii/ONI/2003/VIII-cutiidebomboane/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa VIII"]},{"location":"olimpiada/solutii/ONI/2003/VIII-matricemonotonmaximala/","title":"Solu\u021bia problemei Matrice Monoton Maximal\u0103 (ONI 2003, clasa a VIII-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa VIII"]},{"location":"olimpiada/solutii/ONI/2003/VIII-matricemonotonmaximala/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa VIII"]},{"location":"olimpiada/solutii/ONI/2003/X-asediu/","title":"Solu\u021bia problemei asediu (ONI 2003, clasa a X-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa X"]},{"location":"olimpiada/solutii/ONI/2003/X-asediu/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa X"]},{"location":"olimpiada/solutii/ONI/2003/X-munte/","title":"Solu\u021bia problemei munte (ONI 2003, clasa a X-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa X"]},{"location":"olimpiada/solutii/ONI/2003/X-munte/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa X"]},{"location":"olimpiada/solutii/ONI/2003/X-muzeu/","title":"Solu\u021bia problemei muzeu (ONI 2003, clasa a X-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa X"]},{"location":"olimpiada/solutii/ONI/2003/X-muzeu/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa X"]},{"location":"olimpiada/solutii/ONI/2003/X-partitie/","title":"Solu\u021bia problemei partitie (ONI 2003, clasa a X-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa X"]},{"location":"olimpiada/solutii/ONI/2003/X-partitie/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa X"]},{"location":"olimpiada/solutii/ONI/2003/X-rubine/","title":"Solu\u021bia problemei rubine (ONI 2003, clasa a X-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa X"]},{"location":"olimpiada/solutii/ONI/2003/X-rubine/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa X"]},{"location":"olimpiada/solutii/ONI/2003/X-scufita/","title":"Solu\u021bia problemei scufita (ONI 2003, clasa a X-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa X"]},{"location":"olimpiada/solutii/ONI/2003/X-scufita/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa X"]},{"location":"olimpiada/solutii/ONI/2003/XI-XII-a007/","title":"Solu\u021bia problemei a007 (ONI 2003, clasele XI-XII)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa XI-XII"]},{"location":"olimpiada/solutii/ONI/2003/XI-XII-a007/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa XI-XII"]},{"location":"olimpiada/solutii/ONI/2003/XI-XII-asmin/","title":"Solu\u021bia problemei asmin (ONI 2003, clasele XI-XII)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa XI-XII"]},{"location":"olimpiada/solutii/ONI/2003/XI-XII-asmin/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa XI-XII"]},{"location":"olimpiada/solutii/ONI/2003/XI-XII-cautare/","title":"Solu\u021bia problemei cautare (ONI 2003, clasele XI-XII)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa XI-XII"]},{"location":"olimpiada/solutii/ONI/2003/XI-XII-cautare/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa XI-XII"]},{"location":"olimpiada/solutii/ONI/2003/XI-XII-inter/","title":"Solu\u021bia problemei inter (ONI 2003, clasele XI-XII)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa XI-XII"]},{"location":"olimpiada/solutii/ONI/2003/XI-XII-inter/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa XI-XII"]},{"location":"olimpiada/solutii/ONI/2003/XI-XII-nr/","title":"Solu\u021bia problemei nr (ONI 2003, clasele XI-XII)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa XI-XII"]},{"location":"olimpiada/solutii/ONI/2003/XI-XII-nr/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa XI-XII"]},{"location":"olimpiada/solutii/ONI/2003/XI-XII-proc/","title":"Solu\u021bia problemei proc (ONI 2003, clasele XI-XII)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa XI-XII"]},{"location":"olimpiada/solutii/ONI/2003/XI-XII-proc/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa XI-XII"]},{"location":"olimpiada/solutii/ONI/2004/IX-sablon/","title":"Solu\u021bia problemei sablon (ONI 2004, clasa a IX-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa IX"]},{"location":"olimpiada/solutii/ONI/2004/IX-sablon/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa IX"]},{"location":"olimpiada/solutii/ONI/2004/IX-sir/","title":"Solu\u021bia problemei sir (ONI 2004, clasa a IX-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa IX"]},{"location":"olimpiada/solutii/ONI/2004/IX-sir/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa IX"]},{"location":"olimpiada/solutii/ONI/2004/IX-snipers/","title":"Solu\u021bia problemei snipers (ONI 2004, clasa a IX-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa IX"]},{"location":"olimpiada/solutii/ONI/2004/IX-snipers/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa IX"]},{"location":"olimpiada/solutii/ONI/2004/V-nota/","title":"Solu\u021bia problemei nota (ONI 2004, clasa a V-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa V"]},{"location":"olimpiada/solutii/ONI/2004/V-nota/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa V"]},{"location":"olimpiada/solutii/ONI/2004/V-printesa/","title":"Solu\u021bia problemei printesa (ONI 2004, clasa a V-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa V"]},{"location":"olimpiada/solutii/ONI/2004/V-printesa/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa V"]},{"location":"olimpiada/solutii/ONI/2004/V-produs/","title":"Solu\u021bia problemei produs (ONI 2004, clasa a V-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa V"]},{"location":"olimpiada/solutii/ONI/2004/V-produs/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa V"]},{"location":"olimpiada/solutii/ONI/2004/VI-palindrom/","title":"Solu\u021bia problemei Palindrom (ONI 2004, clasa a VI-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa VI"]},{"location":"olimpiada/solutii/ONI/2004/VI-palindrom/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa VI"]},{"location":"olimpiada/solutii/ONI/2004/VI-primeapropiate/","title":"Solu\u021bia problemei Prime Apropiate (ONI 2004, clasa a VI-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa VI"]},{"location":"olimpiada/solutii/ONI/2004/VI-primeapropiate/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim. <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre></p>","tags":["ONI","clasa VI"]},{"location":"olimpiada/solutii/ONI/2004/VI-spider/","title":"Solu\u021bia problemei Spider (ONI 2004, clasa a VI-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa VI"]},{"location":"olimpiada/solutii/ONI/2004/VI-spider/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa VI"]},{"location":"olimpiada/solutii/ONI/2004/VII-jetoane/","title":"Solu\u021bia problemei jetoane (ONI 2004, clasa a VII-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa VII"]},{"location":"olimpiada/solutii/ONI/2004/VII-jetoane/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa VII"]},{"location":"olimpiada/solutii/ONI/2004/VII-vuri/","title":"Solu\u021bia problemei V-uri (ONI 2004, clasa a VII-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa VII"]},{"location":"olimpiada/solutii/ONI/2004/VII-vuri/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa VII"]},{"location":"olimpiada/solutii/ONI/2004/VIII-meteor/","title":"Solu\u021bia problemei meteor (ONI 2004, clasa a VIII-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa VIII"]},{"location":"olimpiada/solutii/ONI/2004/VIII-meteor/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim. <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre></p>","tags":["ONI","clasa VIII"]},{"location":"olimpiada/solutii/ONI/2004/VIII-sume/","title":"Solu\u021bia problemei sume (ONI 2004, clasa a VIII-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa VIII"]},{"location":"olimpiada/solutii/ONI/2004/VIII-sume/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa VIII"]},{"location":"olimpiada/solutii/ONI/2004/VIII-zar/","title":"Solu\u021bia problemei zar (ONI 2004, clasa a VIII-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa VIII"]},{"location":"olimpiada/solutii/ONI/2004/VIII-zar/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa VIII"]},{"location":"olimpiada/solutii/ONI/2004/X-cuvinte/","title":"Solu\u021bia problemei cuvinte (ONI 2004, clasa a X-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa X"]},{"location":"olimpiada/solutii/ONI/2004/X-cuvinte/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa X"]},{"location":"olimpiada/solutii/ONI/2004/X-gaina/","title":"Solu\u021bia problemei gaina (ONI 2004, clasa a X-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa X"]},{"location":"olimpiada/solutii/ONI/2004/X-gaina/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa X"]},{"location":"olimpiada/solutii/ONI/2004/X-materom/","title":"Solu\u021bia problemei materom (ONI 2004, clasa a X-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa X"]},{"location":"olimpiada/solutii/ONI/2004/X-materom/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa X"]},{"location":"olimpiada/solutii/ONI/2004/X-puncte/","title":"Solu\u021bia problemei puncte (ONI 2004, clasa a X-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa X"]},{"location":"olimpiada/solutii/ONI/2004/X-puncte/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa X"]},{"location":"olimpiada/solutii/ONI/2004/X-rez/","title":"Solu\u021bia problemei rez (ONI 2004, clasa a X-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa X"]},{"location":"olimpiada/solutii/ONI/2004/X-rez/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa X"]},{"location":"olimpiada/solutii/ONI/2004/X-sortari/","title":"Solu\u021bia problemei sortari (ONI 2004, clasa a X-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa X"]},{"location":"olimpiada/solutii/ONI/2004/X-sortari/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa X"]},{"location":"olimpiada/solutii/ONI/2004/XI-XII-base3/","title":"Solu\u021bia problemei base3 (ONI 2004, clasele XI-XII)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa XI-XII"]},{"location":"olimpiada/solutii/ONI/2004/XI-XII-base3/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa XI-XII"]},{"location":"olimpiada/solutii/ONI/2004/XI-XII-coach/","title":"Solu\u021bia problemei coach (ONI 2004, clasele XI-XII)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa XI-XII"]},{"location":"olimpiada/solutii/ONI/2004/XI-XII-coach/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa XI-XII"]},{"location":"olimpiada/solutii/ONI/2004/XI-XII-color/","title":"Solu\u021bia problemei color (ONI 2004, clasele XI-XII)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa XI-XII"]},{"location":"olimpiada/solutii/ONI/2004/XI-XII-color/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa XI-XII"]},{"location":"olimpiada/solutii/ONI/2004/XI-XII-magic/","title":"Solu\u021bia problemei magic (ONI 2004, clasele XI-XII)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa XI-XII"]},{"location":"olimpiada/solutii/ONI/2004/XI-XII-magic/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa XI-XII"]},{"location":"olimpiada/solutii/ONI/2004/XI-XII-patrate/","title":"Solu\u021bia problemei patrate (ONI 2004, clasele XI-XII)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa XI-XII"]},{"location":"olimpiada/solutii/ONI/2004/XI-XII-patrate/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa XI-XII"]},{"location":"olimpiada/solutii/ONI/2004/XI-XII-turnuri/","title":"Solu\u021bia problemei turnuri (ONI 2004, clasele XI-XII)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa XI-XII"]},{"location":"olimpiada/solutii/ONI/2004/XI-XII-turnuri/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa XI-XII"]},{"location":"olimpiada/solutii/ONI/2005/IX-biblos/","title":"Solu\u021bia problemei biblos (ONI 2005, clasa a IX-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa IX"]},{"location":"olimpiada/solutii/ONI/2005/IX-biblos/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa IX"]},{"location":"olimpiada/solutii/ONI/2005/IX-bifo/","title":"Solu\u021bia problemei bifo (ONI 2005, clasa a IX-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa IX"]},{"location":"olimpiada/solutii/ONI/2005/IX-bifo/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa IX"]},{"location":"olimpiada/solutii/ONI/2005/IX-joc/","title":"Solu\u021bia problemei joc (ONI 2005, clasa a IX-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa IX"]},{"location":"olimpiada/solutii/ONI/2005/IX-joc/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa IX"]},{"location":"olimpiada/solutii/ONI/2005/IX-pal/","title":"Solu\u021bia problemei pal (ONI 2005, clasa a IX-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa IX"]},{"location":"olimpiada/solutii/ONI/2005/IX-pal/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa IX"]},{"location":"olimpiada/solutii/ONI/2005/IX-romeo/","title":"Solu\u021bia problemei romeo (ONI 2005, clasa a IX-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa IX"]},{"location":"olimpiada/solutii/ONI/2005/IX-romeo/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa IX"]},{"location":"olimpiada/solutii/ONI/2005/IX-seceta/","title":"Solu\u021bia problemei seceta (ONI 2005, clasa a IX-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa IX"]},{"location":"olimpiada/solutii/ONI/2005/IX-seceta/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa IX"]},{"location":"olimpiada/solutii/ONI/2005/VII-cezar/","title":"Solu\u021bia problemei cezar (ONI 2005, clasa a VII-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa VII"]},{"location":"olimpiada/solutii/ONI/2005/VII-cezar/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa VII"]},{"location":"olimpiada/solutii/ONI/2005/VII-joc/","title":"Solu\u021bia problemei joc (ONI 2005, clasa a VII-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa VII"]},{"location":"olimpiada/solutii/ONI/2005/VII-joc/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa VII"]},{"location":"olimpiada/solutii/ONI/2005/VII-plinie/","title":"Solu\u021bia problemei plinie (ONI 2005, clasa a VII-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa VII"]},{"location":"olimpiada/solutii/ONI/2005/VII-plinie/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa VII"]},{"location":"olimpiada/solutii/ONI/2005/VIII-aritma/","title":"Solu\u021bia problemei aritma (ONI 2005, clasa a VIII-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa VIII"]},{"location":"olimpiada/solutii/ONI/2005/VIII-aritma/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa VIII"]},{"location":"olimpiada/solutii/ONI/2005/VIII-bete/","title":"Solu\u021bia problemei bete (ONI 2005, clasa a VIII-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa VIII"]},{"location":"olimpiada/solutii/ONI/2005/VIII-bete/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa VIII"]},{"location":"olimpiada/solutii/ONI/2005/VIII-cuburi/","title":"Solu\u021bia problemei cuburi (ONI 2005, clasa a VIII-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa VIII"]},{"location":"olimpiada/solutii/ONI/2005/VIII-cuburi/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa VIII"]},{"location":"olimpiada/solutii/ONI/2005/X-antena/","title":"Solu\u021bia problemei antena (ONI 2005, clasa a X-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa X"]},{"location":"olimpiada/solutii/ONI/2005/X-antena/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa X"]},{"location":"olimpiada/solutii/ONI/2005/X-avere/","title":"Solu\u021bia problemei avere (ONI 2005, clasa a X-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa X"]},{"location":"olimpiada/solutii/ONI/2005/X-avere/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa X"]},{"location":"olimpiada/solutii/ONI/2005/X-joc/","title":"Solu\u021bia problemei joc (ONI 2005, clasa a X-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa X"]},{"location":"olimpiada/solutii/ONI/2005/X-joc/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa X"]},{"location":"olimpiada/solutii/ONI/2005/X-paianjen/","title":"Solu\u021bia problemei paianjen (ONI 2005, clasa a X-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa X"]},{"location":"olimpiada/solutii/ONI/2005/X-paianjen/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa X"]},{"location":"olimpiada/solutii/ONI/2005/X-suma/","title":"Solu\u021bia problemei suma (ONI 2005, clasa a X-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa X"]},{"location":"olimpiada/solutii/ONI/2005/X-suma/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa X"]},{"location":"olimpiada/solutii/ONI/2005/X-vizibil/","title":"Solu\u021bia problemei vizibil (ONI 2005, clasa a X-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa X"]},{"location":"olimpiada/solutii/ONI/2005/X-vizibil/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa X"]},{"location":"olimpiada/solutii/ONI/2005/XI-XII-csir/","title":"Solu\u021bia problemei csir (ONI 2005, clasele XI-XII)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa XI-XII"]},{"location":"olimpiada/solutii/ONI/2005/XI-XII-csir/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa XI-XII"]},{"location":"olimpiada/solutii/ONI/2005/XI-XII-lsort/","title":"Solu\u021bia problemei lsort (ONI 2005, clasele XI-XII)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa XI-XII"]},{"location":"olimpiada/solutii/ONI/2005/XI-XII-lsort/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa XI-XII"]},{"location":"olimpiada/solutii/ONI/2005/XI-XII-masina/","title":"Solu\u021bia problemei masina (ONI 2005, clasele XI-XII)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa XI-XII"]},{"location":"olimpiada/solutii/ONI/2005/XI-XII-masina/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa XI-XII"]},{"location":"olimpiada/solutii/ONI/2005/XI-XII-matrice/","title":"Solu\u021bia problemei matrice (ONI 2005, clasele XI-XII)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa XI-XII"]},{"location":"olimpiada/solutii/ONI/2005/XI-XII-matrice/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa XI-XII"]},{"location":"olimpiada/solutii/ONI/2005/XI-XII-patrat/","title":"Solu\u021bia problemei patrat (ONI 2005, clasele XI-XII)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa XI-XII"]},{"location":"olimpiada/solutii/ONI/2005/XI-XII-patrat/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa XI-XII"]},{"location":"olimpiada/solutii/ONI/2005/XI-XII-ziduri/","title":"Solu\u021bia problemei ziduri (ONI 2005, clasele XI-XII)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa XI-XII"]},{"location":"olimpiada/solutii/ONI/2005/XI-XII-ziduri/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa XI-XII"]},{"location":"olimpiada/solutii/ONI/2006/IX-fact/","title":"Solu\u021bia problemei fact (ONI 2006, clasa a IX-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa IX"]},{"location":"olimpiada/solutii/ONI/2006/IX-fact/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa IX"]},{"location":"olimpiada/solutii/ONI/2006/IX-limbaj/","title":"Solu\u021bia problemei limbaj (ONI 2006, clasa a IX-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa IX"]},{"location":"olimpiada/solutii/ONI/2006/IX-limbaj/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa IX"]},{"location":"olimpiada/solutii/ONI/2006/IX-panouri/","title":"Solu\u021bia problemei panouri (ONI 2006, clasa a IX-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa IX"]},{"location":"olimpiada/solutii/ONI/2006/IX-panouri/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa IX"]},{"location":"olimpiada/solutii/ONI/2006/IX-pereti/","title":"Solu\u021bia problemei pere\u021bi (ONI 2006, clasa a IX-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa IX"]},{"location":"olimpiada/solutii/ONI/2006/IX-pereti/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa IX"]},{"location":"olimpiada/solutii/ONI/2006/IX-sant/","title":"Solu\u021bia problemei \u0218an\u021b (ONI 2006, clasa a IX-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa IX"]},{"location":"olimpiada/solutii/ONI/2006/IX-sant/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa IX"]},{"location":"olimpiada/solutii/ONI/2006/IX-zumzi/","title":"Solu\u021bia problemei zumzi (ONI 2006, clasa a IX-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa IX"]},{"location":"olimpiada/solutii/ONI/2006/IX-zumzi/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa IX"]},{"location":"olimpiada/solutii/ONI/2006/V-concurs/","title":"Solu\u021bia problemei concurs (ONI 2006, clasa a V-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa V"]},{"location":"olimpiada/solutii/ONI/2006/V-concurs/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa V"]},{"location":"olimpiada/solutii/ONI/2006/V-powerpuff/","title":"Solu\u021bia problemei powerpuff (ONI 2006, clasa a V-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa V"]},{"location":"olimpiada/solutii/ONI/2006/V-powerpuff/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa V"]},{"location":"olimpiada/solutii/ONI/2006/VI-roboti/","title":"Solu\u021bia problemei roboti (ONI 2006, clasa a VI-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa VI"]},{"location":"olimpiada/solutii/ONI/2006/VI-roboti/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa VI"]},{"location":"olimpiada/solutii/ONI/2006/VI-suma/","title":"Solu\u021bia problemei suma (ONI 2006, clasa a VI-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa VI"]},{"location":"olimpiada/solutii/ONI/2006/VI-suma/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa VI"]},{"location":"olimpiada/solutii/ONI/2006/VI-tzigla/","title":"Solu\u021bia problemei tzigla (ONI 2006, clasa a VI-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa VI"]},{"location":"olimpiada/solutii/ONI/2006/VI-tzigla/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa VI"]},{"location":"olimpiada/solutii/ONI/2006/VII-baschet/","title":"Solu\u021bia problemei baschet (ONI 2006, clasa a VII-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa VII"]},{"location":"olimpiada/solutii/ONI/2006/VII-baschet/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa VII"]},{"location":"olimpiada/solutii/ONI/2006/VII-joc/","title":"Solu\u021bia problemei joc (ONI 2006, clasa a VII-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa VII"]},{"location":"olimpiada/solutii/ONI/2006/VII-joc/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa VII"]},{"location":"olimpiada/solutii/ONI/2006/VII-mere/","title":"Solu\u021bia problemei mere (ONI 2006, clasa a VII-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa VII"]},{"location":"olimpiada/solutii/ONI/2006/VII-mere/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa VII"]},{"location":"olimpiada/solutii/ONI/2006/VIII-adun/","title":"Solu\u021bia problemei adun (ONI 2006, clasa a VIII-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa VIII"]},{"location":"olimpiada/solutii/ONI/2006/VIII-adun/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa VIII"]},{"location":"olimpiada/solutii/ONI/2006/VIII-sport/","title":"Solu\u021bia problemei sport (ONI 2006, clasa a VIII-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa VIII"]},{"location":"olimpiada/solutii/ONI/2006/VIII-sport/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa VIII"]},{"location":"olimpiada/solutii/ONI/2006/VIII-suma/","title":"Solu\u021bia problemei suma (ONI 2006, clasa a VIII-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa VIII"]},{"location":"olimpiada/solutii/ONI/2006/VIII-suma/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa VIII"]},{"location":"olimpiada/solutii/ONI/2006/X-bombo/","title":"Solu\u021bia problemei Bombo (ONI 2006, clasa a X-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa X"]},{"location":"olimpiada/solutii/ONI/2006/X-bombo/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa X"]},{"location":"olimpiada/solutii/ONI/2006/X-cub/","title":"Solu\u021bia problemei Cub (ONI 2006, clasa a X-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa X"]},{"location":"olimpiada/solutii/ONI/2006/X-cub/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa X"]},{"location":"olimpiada/solutii/ONI/2006/X-logic/","title":"Solu\u021bia problemei Logic (ONI 2006, clasa a X-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa X"]},{"location":"olimpiada/solutii/ONI/2006/X-logic/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa X"]},{"location":"olimpiada/solutii/ONI/2006/X-medie/","title":"Solu\u021bia problemei Medie (ONI 2006, clasa a X-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa X"]},{"location":"olimpiada/solutii/ONI/2006/X-medie/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa X"]},{"location":"olimpiada/solutii/ONI/2006/X-prieteni/","title":"Solu\u021bia problemei Prieteni (ONI 2006, clasa a X-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa X"]},{"location":"olimpiada/solutii/ONI/2006/X-prieteni/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa X"]},{"location":"olimpiada/solutii/ONI/2006/X-sg1/","title":"Solu\u021bia problemei SG1 (ONI 2006, clasa a X-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa X"]},{"location":"olimpiada/solutii/ONI/2006/X-sg1/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa X"]},{"location":"olimpiada/solutii/ONI/2006/XI-XII-borg/","title":"Solu\u021bia problemei borg (ONI 2006, clasele XI-XII)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa XI-XII"]},{"location":"olimpiada/solutii/ONI/2006/XI-XII-borg/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa XI-XII"]},{"location":"olimpiada/solutii/ONI/2006/XI-XII-diamant/","title":"Solu\u021bia problemei diamant (ONI 2006, clasele XI-XII)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa XI-XII"]},{"location":"olimpiada/solutii/ONI/2006/XI-XII-diamant/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa XI-XII"]},{"location":"olimpiada/solutii/ONI/2006/XI-XII-matrice/","title":"Solu\u021bia problemei matrice (ONI 2006, clasele XI-XII)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa XI-XII"]},{"location":"olimpiada/solutii/ONI/2006/XI-XII-matrice/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa XI-XII"]},{"location":"olimpiada/solutii/ONI/2006/XI-XII-petrom/","title":"Solu\u021bia problemei petrom (ONI 2006, clasele XI-XII)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa XI-XII"]},{"location":"olimpiada/solutii/ONI/2006/XI-XII-petrom/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa XI-XII"]},{"location":"olimpiada/solutii/ONI/2006/XI-XII-ratina/","title":"Solu\u021bia problemei ratina (ONI 2006, clasele XI-XII)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa XI-XII"]},{"location":"olimpiada/solutii/ONI/2006/XI-XII-ratina/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa XI-XII"]},{"location":"olimpiada/solutii/ONI/2006/XI-XII-vitale/","title":"Solu\u021bia problemei vitale (ONI 2006, clasele XI-XII)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa XI-XII"]},{"location":"olimpiada/solutii/ONI/2006/XI-XII-vitale/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa XI-XII"]},{"location":"olimpiada/solutii/ONI/2007/IX-agitatie/","title":"Solu\u021bia problemei agitatie (ONI 2007, clasa a IX-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa IX"]},{"location":"olimpiada/solutii/ONI/2007/IX-agitatie/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa IX"]},{"location":"olimpiada/solutii/ONI/2007/IX-coduri/","title":"Solu\u021bia problemei coduri (ONI 2007, clasa a IX-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa IX"]},{"location":"olimpiada/solutii/ONI/2007/IX-coduri/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa IX"]},{"location":"olimpiada/solutii/ONI/2007/IX-lacuri/","title":"Solu\u021bia problemei lacuri (ONI 2007, clasa a IX-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa IX"]},{"location":"olimpiada/solutii/ONI/2007/IX-lacuri/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa IX"]},{"location":"olimpiada/solutii/ONI/2007/IX-secv/","title":"Solu\u021bia problemei secv (ONI 2007, clasa a IX-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa IX"]},{"location":"olimpiada/solutii/ONI/2007/IX-secv/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa IX"]},{"location":"olimpiada/solutii/ONI/2007/IX-sotron/","title":"Solu\u021bia problemei sotron (ONI 2007, clasa a IX-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa IX"]},{"location":"olimpiada/solutii/ONI/2007/IX-sotron/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa IX"]},{"location":"olimpiada/solutii/ONI/2007/IX-triunghi/","title":"Solu\u021bia problemei triunghi (ONI 2007, clasa a IX-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa IX"]},{"location":"olimpiada/solutii/ONI/2007/IX-triunghi/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa IX"]},{"location":"olimpiada/solutii/ONI/2007/V-ceas/","title":"Solu\u021bia problemei ceas (ONI 2007, clasa a V-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa V"]},{"location":"olimpiada/solutii/ONI/2007/V-ceas/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa V"]},{"location":"olimpiada/solutii/ONI/2007/V-maxim/","title":"Solu\u021bia problemei maxim (ONI 2007, clasa a V-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa V"]},{"location":"olimpiada/solutii/ONI/2007/V-maxim/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa V"]},{"location":"olimpiada/solutii/ONI/2007/V-numere/","title":"Solu\u021bia problemei numere (ONI 2007, clasa a V-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa V"]},{"location":"olimpiada/solutii/ONI/2007/V-numere/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa V"]},{"location":"olimpiada/solutii/ONI/2007/VI-cifru/","title":"Solu\u021bia problemei cifru (ONI 2007, clasa a VI-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa VI"]},{"location":"olimpiada/solutii/ONI/2007/VI-cifru/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa VI"]},{"location":"olimpiada/solutii/ONI/2007/VI-oua/","title":"Solu\u021bia problemei oua (ONI 2007, clasa a VI-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa VI"]},{"location":"olimpiada/solutii/ONI/2007/VI-oua/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa VI"]},{"location":"olimpiada/solutii/ONI/2007/VI-turn/","title":"Solu\u021bia problemei turn (ONI 2007, clasa a VI-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa VI"]},{"location":"olimpiada/solutii/ONI/2007/VI-turn/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa VI"]},{"location":"olimpiada/solutii/ONI/2007/VII-excel/","title":"Solu\u021bia problemei excel (ONI 2007, clasa a VII-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa VII"]},{"location":"olimpiada/solutii/ONI/2007/VII-excel/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa VII"]},{"location":"olimpiada/solutii/ONI/2007/VII-jetoane/","title":"Solu\u021bia problemei jetoane (ONI 2007, clasa a VII-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa VII"]},{"location":"olimpiada/solutii/ONI/2007/VII-jetoane/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa VII"]},{"location":"olimpiada/solutii/ONI/2007/VII-politic/","title":"Solu\u021bia problemei politic (ONI 2007, clasa a VII-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa VII"]},{"location":"olimpiada/solutii/ONI/2007/VII-politic/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa VII"]},{"location":"olimpiada/solutii/ONI/2007/VIII-div3/","title":"Solu\u021bia problemei div3 (ONI 2007, clasa a VIII-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa VIII"]},{"location":"olimpiada/solutii/ONI/2007/VIII-div3/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa VIII"]},{"location":"olimpiada/solutii/ONI/2007/VIII-sort/","title":"Solu\u021bia problemei sort (ONI 2007, clasa a VIII-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa VIII"]},{"location":"olimpiada/solutii/ONI/2007/VIII-sort/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa VIII"]},{"location":"olimpiada/solutii/ONI/2007/VIII-trecere/","title":"Solu\u021bia problemei trecere (ONI 2007, clasa a VIII-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa VIII"]},{"location":"olimpiada/solutii/ONI/2007/VIII-trecere/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa VIII"]},{"location":"olimpiada/solutii/ONI/2007/X-apel/","title":"Solu\u021bia problemei apel (ONI 2007, clasa a X-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa X"]},{"location":"olimpiada/solutii/ONI/2007/X-apel/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa X"]},{"location":"olimpiada/solutii/ONI/2007/X-castel/","title":"Solu\u021bia problemei castel (ONI 2007, clasa a X-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa X"]},{"location":"olimpiada/solutii/ONI/2007/X-castel/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa X"]},{"location":"olimpiada/solutii/ONI/2007/X-excursie/","title":"Solu\u021bia problemei excursie (ONI 2007, clasa a X-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa X"]},{"location":"olimpiada/solutii/ONI/2007/X-excursie/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa X"]},{"location":"olimpiada/solutii/ONI/2007/X-matrice/","title":"Solu\u021bia problemei matrice (ONI 2007, clasa a X-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa X"]},{"location":"olimpiada/solutii/ONI/2007/X-matrice/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa X"]},{"location":"olimpiada/solutii/ONI/2007/X-randuri/","title":"Solu\u021bia problemei randuri (ONI 2007, clasa a X-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa X"]},{"location":"olimpiada/solutii/ONI/2007/X-randuri/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa X"]},{"location":"olimpiada/solutii/ONI/2007/X-zidar/","title":"Solu\u021bia problemei zidar (ONI 2007, clasa a X-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa X"]},{"location":"olimpiada/solutii/ONI/2007/X-zidar/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa X"]},{"location":"olimpiada/solutii/ONI/2007/XI-XII-desc/","title":"Solu\u021bia problemei desc (ONI 2007, clasele XI-XII)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa XI-XII"]},{"location":"olimpiada/solutii/ONI/2007/XI-XII-desc/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim. <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre></p>","tags":["ONI","clasa XI-XII"]},{"location":"olimpiada/solutii/ONI/2007/XI-XII-felinare/","title":"Solu\u021bia problemei felinare (ONI 2007, clasele XI-XII)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa XI-XII"]},{"location":"olimpiada/solutii/ONI/2007/XI-XII-felinare/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa XI-XII"]},{"location":"olimpiada/solutii/ONI/2007/XI-XII-joc/","title":"Solu\u021bia problemei joc (ONI 2007, clasele XI-XII)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa XI-XII"]},{"location":"olimpiada/solutii/ONI/2007/XI-XII-joc/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa XI-XII"]},{"location":"olimpiada/solutii/ONI/2007/XI-XII-log/","title":"Solu\u021bia problemei log (ONI 2007, clasele XI-XII)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa XI-XII"]},{"location":"olimpiada/solutii/ONI/2007/XI-XII-log/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa XI-XII"]},{"location":"olimpiada/solutii/ONI/2007/XI-XII-maxq/","title":"Solu\u021bia problemei maxq (ONI 2007, clasele XI-XII)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa XI-XII"]},{"location":"olimpiada/solutii/ONI/2007/XI-XII-maxq/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa XI-XII"]},{"location":"olimpiada/solutii/ONI/2007/XI-XII-tric/","title":"Solu\u021bia problemei tric (ONI 2007, clasele XI-XII)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa XI-XII"]},{"location":"olimpiada/solutii/ONI/2007/XI-XII-tric/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa XI-XII"]},{"location":"olimpiada/solutii/ONI/2008/IX-ab/","title":"Solu\u021bia problemei ab (ONI 2008, clasa a IX-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa IX"]},{"location":"olimpiada/solutii/ONI/2008/IX-ab/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa IX"]},{"location":"olimpiada/solutii/ONI/2008/IX-auto/","title":"Solu\u021bia problemei auto (ONI 2008, clasa a IX-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa IX"]},{"location":"olimpiada/solutii/ONI/2008/IX-auto/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa IX"]},{"location":"olimpiada/solutii/ONI/2008/IX-div/","title":"Solu\u021bia problemei div (ONI 2008, clasa a IX-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa IX"]},{"location":"olimpiada/solutii/ONI/2008/IX-div/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa IX"]},{"location":"olimpiada/solutii/ONI/2008/IX-iepuras/","title":"Solu\u021bia problemei iepuras (ONI 2008, clasa a IX-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa IX"]},{"location":"olimpiada/solutii/ONI/2008/IX-iepuras/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa IX"]},{"location":"olimpiada/solutii/ONI/2008/IX-palind/","title":"Solu\u021bia problemei palind (ONI 2008, clasa a IX-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa IX"]},{"location":"olimpiada/solutii/ONI/2008/IX-palind/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa IX"]},{"location":"olimpiada/solutii/ONI/2008/IX-teatru/","title":"Solu\u021bia problemei teatru (ONI 2008, clasa a IX-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa IX"]},{"location":"olimpiada/solutii/ONI/2008/IX-teatru/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa IX"]},{"location":"olimpiada/solutii/ONI/2008/V-felinare/","title":"Solu\u021bia problemei felinare (ONI 2008, clasa a V-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa V"]},{"location":"olimpiada/solutii/ONI/2008/V-felinare/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa V"]},{"location":"olimpiada/solutii/ONI/2008/V-mere/","title":"Solu\u021bia problemei mere (ONI 2008, clasa a V-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa V"]},{"location":"olimpiada/solutii/ONI/2008/V-mere/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa V"]},{"location":"olimpiada/solutii/ONI/2008/VI-creioane/","title":"Solu\u021bia problemei creioane (ONI 2008, clasa a VI-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa VI"]},{"location":"olimpiada/solutii/ONI/2008/VI-creioane/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa VI"]},{"location":"olimpiada/solutii/ONI/2008/VI-melci/","title":"Solu\u021bia problemei melci (ONI 2008, clasa a VI-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa VI"]},{"location":"olimpiada/solutii/ONI/2008/VI-melci/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa VI"]},{"location":"olimpiada/solutii/ONI/2008/VI-tablou/","title":"Solu\u021bia problemei tablou (ONI 2008, clasa a VI-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa VI"]},{"location":"olimpiada/solutii/ONI/2008/VI-tablou/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa VI"]},{"location":"olimpiada/solutii/ONI/2008/VII-fisicri/","title":"Solu\u021bia problemei Fi si Cri (ONI 2008, clasa a VII-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa VII"]},{"location":"olimpiada/solutii/ONI/2008/VII-fisicri/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa VII"]},{"location":"olimpiada/solutii/ONI/2008/VII-rezervatienaturala/","title":"Solu\u021bia problemei Rezervatie naturala (ONI 2008, clasa a VII-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa VII"]},{"location":"olimpiada/solutii/ONI/2008/VII-rezervatienaturala/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa VII"]},{"location":"olimpiada/solutii/ONI/2008/VIII-pm/","title":"Solu\u021bia problemei pm (ONI 2008, clasa a VIII-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa VIII"]},{"location":"olimpiada/solutii/ONI/2008/VIII-pm/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa VIII"]},{"location":"olimpiada/solutii/ONI/2008/VIII-reteta/","title":"Solu\u021bia problemei reteta (ONI 2008, clasa a VIII-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa VIII"]},{"location":"olimpiada/solutii/ONI/2008/VIII-reteta/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa VIII"]},{"location":"olimpiada/solutii/ONI/2008/VIII-submat/","title":"Solu\u021bia problemei submat (ONI 2008, clasa a VIII-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa VIII"]},{"location":"olimpiada/solutii/ONI/2008/VIII-submat/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa VIII"]},{"location":"olimpiada/solutii/ONI/2008/X-aranjare/","title":"Solu\u021bia problemei aranjare (ONI 2008, clasa a X-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa X"]},{"location":"olimpiada/solutii/ONI/2008/X-aranjare/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa X"]},{"location":"olimpiada/solutii/ONI/2008/X-banda/","title":"Solu\u021bia problemei banda (ONI 2008, clasa a X-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa X"]},{"location":"olimpiada/solutii/ONI/2008/X-banda/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa X"]},{"location":"olimpiada/solutii/ONI/2008/X-bile/","title":"Solu\u021bia problemei bile (ONI 2008, clasa a X-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa X"]},{"location":"olimpiada/solutii/ONI/2008/X-bile/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa X"]},{"location":"olimpiada/solutii/ONI/2008/X-pavare/","title":"Solu\u021bia problemei pavare (ONI 2008, clasa a X-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa X"]},{"location":"olimpiada/solutii/ONI/2008/X-pavare/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa X"]},{"location":"olimpiada/solutii/ONI/2008/X-poarta/","title":"Solu\u021bia problemei poarta (ONI 2008, clasa a X-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa X"]},{"location":"olimpiada/solutii/ONI/2008/X-poarta/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa X"]},{"location":"olimpiada/solutii/ONI/2008/X-subgeom/","title":"Solu\u021bia problemei subgeom (ONI 2008, clasa a X-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa X"]},{"location":"olimpiada/solutii/ONI/2008/X-subgeom/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa X"]},{"location":"olimpiada/solutii/ONI/2008/XI-XII-albinuta/","title":"Solu\u021bia problemei albinuta (ONI 2008, clasele XI-XII)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa XI-XII"]},{"location":"olimpiada/solutii/ONI/2008/XI-XII-albinuta/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa XI-XII"]},{"location":"olimpiada/solutii/ONI/2008/XI-XII-atac/","title":"Solu\u021bia problemei atac (ONI 2008, clasele XI-XII)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa XI-XII"]},{"location":"olimpiada/solutii/ONI/2008/XI-XII-atac/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa XI-XII"]},{"location":"olimpiada/solutii/ONI/2008/XI-XII-curent/","title":"Solu\u021bia problemei curent (ONI 2008, clasele XI-XII)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa XI-XII"]},{"location":"olimpiada/solutii/ONI/2008/XI-XII-curent/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa XI-XII"]},{"location":"olimpiada/solutii/ONI/2008/XI-XII-drum/","title":"Solu\u021bia problemei drum (ONI 2008, clasele XI-XII)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa XI-XII"]},{"location":"olimpiada/solutii/ONI/2008/XI-XII-drum/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa XI-XII"]},{"location":"olimpiada/solutii/ONI/2008/XI-XII-pviz/","title":"Solu\u021bia problemei pviz (ONI 2008, clasele XI-XII)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa XI-XII"]},{"location":"olimpiada/solutii/ONI/2008/XI-XII-pviz/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa XI-XII"]},{"location":"olimpiada/solutii/ONI/2008/XI-XII-virus/","title":"Solu\u021bia problemei virus (ONI 2008, clasele XI-XII)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa XI-XII"]},{"location":"olimpiada/solutii/ONI/2008/XI-XII-virus/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa XI-XII"]},{"location":"olimpiada/solutii/ONI/2009/IX-br/","title":"Solu\u021bia problemei br (ONI 2009, clasa a IX-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa IX"]},{"location":"olimpiada/solutii/ONI/2009/IX-br/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa IX"]},{"location":"olimpiada/solutii/ONI/2009/IX-joc/","title":"Solu\u021bia problemei joc (ONI 2009, clasa a IX-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa IX"]},{"location":"olimpiada/solutii/ONI/2009/IX-joc/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa IX"]},{"location":"olimpiada/solutii/ONI/2009/IX-origami/","title":"Solu\u021bia problemei origami (ONI 2009, clasa a IX-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa IX"]},{"location":"olimpiada/solutii/ONI/2009/IX-origami/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa IX"]},{"location":"olimpiada/solutii/ONI/2009/IX-patrate/","title":"Solu\u021bia problemei patrate (ONI 2009, clasa a IX-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa IX"]},{"location":"olimpiada/solutii/ONI/2009/IX-patrate/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa IX"]},{"location":"olimpiada/solutii/ONI/2009/IX-perspic/","title":"Solu\u021bia problemei perspic (ONI 2009, clasa a IX-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa IX"]},{"location":"olimpiada/solutii/ONI/2009/IX-perspic/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa IX"]},{"location":"olimpiada/solutii/ONI/2009/IX-rafturi/","title":"Solu\u021bia problemei rafturi (ONI 2009, clasa a IX-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa IX"]},{"location":"olimpiada/solutii/ONI/2009/IX-rafturi/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa IX"]},{"location":"olimpiada/solutii/ONI/2009/V-cartonas/","title":"Solu\u021bia problemei cartonas (ONI 2009, clasa a V-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa V"]},{"location":"olimpiada/solutii/ONI/2009/V-cartonas/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa V"]},{"location":"olimpiada/solutii/ONI/2009/V-case/","title":"Solu\u021bia problemei case (ONI 2009, clasa a V-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa V"]},{"location":"olimpiada/solutii/ONI/2009/V-case/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa V"]},{"location":"olimpiada/solutii/ONI/2009/V-desen/","title":"Solu\u021bia problemei desen (ONI 2009, clasa a V-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa V"]},{"location":"olimpiada/solutii/ONI/2009/V-desen/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa V"]},{"location":"olimpiada/solutii/ONI/2009/VI-alarma/","title":"Solu\u021bia problemei alarma (ONI 2009, clasa a VI-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa VI"]},{"location":"olimpiada/solutii/ONI/2009/VI-alarma/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa VI"]},{"location":"olimpiada/solutii/ONI/2009/VI-nr/","title":"Solu\u021bia problemei nr (ONI 2009, clasa a VI-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa VI"]},{"location":"olimpiada/solutii/ONI/2009/VI-nr/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa VI"]},{"location":"olimpiada/solutii/ONI/2009/VI-tetris/","title":"Solu\u021bia problemei tetris (ONI 2009, clasa a VI-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa VI"]},{"location":"olimpiada/solutii/ONI/2009/VI-tetris/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa VI"]},{"location":"olimpiada/solutii/ONI/2009/VII-patrate/","title":"Solu\u021bia problemei patrate (ONI 2009, clasa a VII-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa VII"]},{"location":"olimpiada/solutii/ONI/2009/VII-patrate/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa VII"]},{"location":"olimpiada/solutii/ONI/2009/VII-taxe/","title":"Solu\u021bia problemei taxe (ONI 2009, clasa a VII-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa VII"]},{"location":"olimpiada/solutii/ONI/2009/VII-taxe/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa VII"]},{"location":"olimpiada/solutii/ONI/2009/VII-tir/","title":"Solu\u021bia problemei tir (ONI 2009, clasa a VII-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa VII"]},{"location":"olimpiada/solutii/ONI/2009/VII-tir/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa VII"]},{"location":"olimpiada/solutii/ONI/2009/VIII-dunarea/","title":"Solu\u021bia problemei dunarea (ONI 2009, clasa a VIII-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa VIII"]},{"location":"olimpiada/solutii/ONI/2009/VIII-dunarea/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim. <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre></p>","tags":["ONI","clasa VIII"]},{"location":"olimpiada/solutii/ONI/2009/VIII-paralelogram/","title":"Solu\u021bia problemei paralelogram (ONI 2009, clasa a VIII-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa VIII"]},{"location":"olimpiada/solutii/ONI/2009/VIII-paralelogram/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa VIII"]},{"location":"olimpiada/solutii/ONI/2009/VIII-parcele/","title":"Solu\u021bia problemei parcele (ONI 2009, clasa a VIII-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa VIII"]},{"location":"olimpiada/solutii/ONI/2009/VIII-parcele/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa VIII"]},{"location":"olimpiada/solutii/ONI/2009/X-bile/","title":"Solu\u021bia problemei bile (ONI 2009, clasa a X-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa X"]},{"location":"olimpiada/solutii/ONI/2009/X-bile/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa X"]},{"location":"olimpiada/solutii/ONI/2009/X-checkin/","title":"Solu\u021bia problemei check-in (ONI 2009, clasa a X-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa X"]},{"location":"olimpiada/solutii/ONI/2009/X-checkin/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa X"]},{"location":"olimpiada/solutii/ONI/2009/X-magic/","title":"Solu\u021bia problemei magic (ONI 2009, clasa a X-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa X"]},{"location":"olimpiada/solutii/ONI/2009/X-magic/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa X"]},{"location":"olimpiada/solutii/ONI/2009/X-reactii/","title":"Solu\u021bia problemei reactii (ONI 2009, clasa a X-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa X"]},{"location":"olimpiada/solutii/ONI/2009/X-reactii/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa X"]},{"location":"olimpiada/solutii/ONI/2009/X-text/","title":"Solu\u021bia problemei text (ONI 2009, clasa a X-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa X"]},{"location":"olimpiada/solutii/ONI/2009/X-text/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa X"]},{"location":"olimpiada/solutii/ONI/2009/X-volei/","title":"Solu\u021bia problemei volei (ONI 2009, clasa a X-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa X"]},{"location":"olimpiada/solutii/ONI/2009/X-volei/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa X"]},{"location":"olimpiada/solutii/ONI/2009/XI-XII-matrice/","title":"Solu\u021bia problemei matrice (ONI 2009, clasele XI-XII)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa XI-XII"]},{"location":"olimpiada/solutii/ONI/2009/XI-XII-matrice/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa XI-XII"]},{"location":"olimpiada/solutii/ONI/2009/XI-XII-numere/","title":"Solu\u021bia problemei numere (ONI 2009, clasele XI-XII)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa XI-XII"]},{"location":"olimpiada/solutii/ONI/2009/XI-XII-numere/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa XI-XII"]},{"location":"olimpiada/solutii/ONI/2009/XI-XII-pikachu/","title":"Solu\u021bia problemei pikachu (ONI 2009, clasele XI-XII)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa XI-XII"]},{"location":"olimpiada/solutii/ONI/2009/XI-XII-pikachu/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa XI-XII"]},{"location":"olimpiada/solutii/ONI/2009/XI-XII-reinvent/","title":"Solu\u021bia problemei reinvent (ONI 2009, clasele XI-XII)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa XI-XII"]},{"location":"olimpiada/solutii/ONI/2009/XI-XII-reinvent/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa XI-XII"]},{"location":"olimpiada/solutii/ONI/2009/XI-XII-revolutie/","title":"Solu\u021bia problemei revolutie (ONI 2009, clasele XI-XII)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa XI-XII"]},{"location":"olimpiada/solutii/ONI/2009/XI-XII-revolutie/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim. <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre></p>","tags":["ONI","clasa XI-XII"]},{"location":"olimpiada/solutii/ONI/2009/XI-XII-sirag/","title":"Solu\u021bia problemei sirag (ONI 2009, clasele XI-XII)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa XI-XII"]},{"location":"olimpiada/solutii/ONI/2009/XI-XII-sirag/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa XI-XII"]},{"location":"olimpiada/solutii/ONI/2010/IX-cern/","title":"Solu\u021bia problemei CERN (ONI 2010, clasa a IX-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa IX"]},{"location":"olimpiada/solutii/ONI/2010/IX-cern/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa IX"]},{"location":"olimpiada/solutii/ONI/2010/IX-cmmmc/","title":"Solu\u021bia problemei cmmmc (ONI 2010, clasa a IX-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa IX"]},{"location":"olimpiada/solutii/ONI/2010/IX-cmmmc/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa IX"]},{"location":"olimpiada/solutii/ONI/2010/IX-pesti/","title":"Solu\u021bia problemei pesti (ONI 2010, clasa a IX-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa IX"]},{"location":"olimpiada/solutii/ONI/2010/IX-pesti/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa IX"]},{"location":"olimpiada/solutii/ONI/2010/IX-plaja/","title":"Solu\u021bia problemei plaja (ONI 2010, clasa a IX-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa IX"]},{"location":"olimpiada/solutii/ONI/2010/IX-plaja/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa IX"]},{"location":"olimpiada/solutii/ONI/2010/IX-simetric/","title":"Solu\u021bia problemei simetric (ONI 2010, clasa a IX-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa IX"]},{"location":"olimpiada/solutii/ONI/2010/IX-simetric/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa IX"]},{"location":"olimpiada/solutii/ONI/2010/IX-tango/","title":"Solu\u021bia problemei tango (ONI 2010, clasa a IX-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa IX"]},{"location":"olimpiada/solutii/ONI/2010/IX-tango/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa IX"]},{"location":"olimpiada/solutii/ONI/2010/V-cluburi/","title":"Solu\u021bia problemei cluburi (ONI 2010, clasa a V-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa V"]},{"location":"olimpiada/solutii/ONI/2010/V-cluburi/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa V"]},{"location":"olimpiada/solutii/ONI/2010/V-domino/","title":"Solu\u021bia problemei domino (ONI 2010, clasa a V-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa V"]},{"location":"olimpiada/solutii/ONI/2010/V-domino/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa V"]},{"location":"olimpiada/solutii/ONI/2010/V-max/","title":"Solu\u021bia problemei max (ONI 2010, clasa a V-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa V"]},{"location":"olimpiada/solutii/ONI/2010/V-max/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa V"]},{"location":"olimpiada/solutii/ONI/2010/VI-control/","title":"Solu\u021bia problemei control (ONI 2010, clasa a VI-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa VI"]},{"location":"olimpiada/solutii/ONI/2010/VI-control/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa VI"]},{"location":"olimpiada/solutii/ONI/2010/VI-figura/","title":"Solu\u021bia problemei figura (ONI 2010, clasa a VI-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa VI"]},{"location":"olimpiada/solutii/ONI/2010/VI-figura/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa VI"]},{"location":"olimpiada/solutii/ONI/2010/VI-joc/","title":"Solu\u021bia problemei joc (ONI 2010, clasa a VI-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa VI"]},{"location":"olimpiada/solutii/ONI/2010/VI-joc/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa VI"]},{"location":"olimpiada/solutii/ONI/2010/VII-char/","title":"Solu\u021bia problemei char (ONI 2010, clasa a VII-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa VII"]},{"location":"olimpiada/solutii/ONI/2010/VII-char/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa VII"]},{"location":"olimpiada/solutii/ONI/2010/VII-maraton/","title":"Solu\u021bia problemei maraton (ONI 2010, clasa a VII-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa VII"]},{"location":"olimpiada/solutii/ONI/2010/VII-maraton/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa VII"]},{"location":"olimpiada/solutii/ONI/2010/VII-roboti/","title":"Solu\u021bia problemei roboti (ONI 2010, clasa a VII-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa VII"]},{"location":"olimpiada/solutii/ONI/2010/VII-roboti/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa VII"]},{"location":"olimpiada/solutii/ONI/2010/VIII-fractie/","title":"Solu\u021bia problemei fractie (ONI 2010, clasa a VIII-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa VIII"]},{"location":"olimpiada/solutii/ONI/2010/VIII-fractie/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa VIII"]},{"location":"olimpiada/solutii/ONI/2010/VIII-neuroni/","title":"Solu\u021bia problemei neuroni (ONI 2010, clasa a VIII-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa VIII"]},{"location":"olimpiada/solutii/ONI/2010/VIII-neuroni/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa VIII"]},{"location":"olimpiada/solutii/ONI/2010/VIII-raze/","title":"Solu\u021bia problemei raze (ONI 2010, clasa a VIII-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa VIII"]},{"location":"olimpiada/solutii/ONI/2010/VIII-raze/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa VIII"]},{"location":"olimpiada/solutii/ONI/2010/X-dreptunghiuri/","title":"Solu\u021bia problemei dreptunghiuri (ONI 2010, clasa a X-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa X"]},{"location":"olimpiada/solutii/ONI/2010/X-dreptunghiuri/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa X"]},{"location":"olimpiada/solutii/ONI/2010/X-gaz/","title":"Solu\u021bia problemei gaz (ONI 2010, clasa a X-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa X"]},{"location":"olimpiada/solutii/ONI/2010/X-gaz/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa X"]},{"location":"olimpiada/solutii/ONI/2010/X-mesaje/","title":"Solu\u021bia problemei mesaje (ONI 2010, clasa a X-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa X"]},{"location":"olimpiada/solutii/ONI/2010/X-mesaje/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa X"]},{"location":"olimpiada/solutii/ONI/2010/X-petrecere/","title":"Solu\u021bia problemei petrecere (ONI 2010, clasa a X-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa X"]},{"location":"olimpiada/solutii/ONI/2010/X-petrecere/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa X"]},{"location":"olimpiada/solutii/ONI/2010/X-triunghi/","title":"Solu\u021bia problemei triunghi (ONI 2010, clasa a X-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa X"]},{"location":"olimpiada/solutii/ONI/2010/X-triunghi/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa X"]},{"location":"olimpiada/solutii/ONI/2010/X-xp/","title":"Solu\u021bia problemei xp (ONI 2010, clasa a X-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa X"]},{"location":"olimpiada/solutii/ONI/2010/X-xp/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa X"]},{"location":"olimpiada/solutii/ONI/2010/XI-XII-conex/","title":"Solu\u021bia problemei conex (ONI 2010, clasele XI-XII)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa XI-XII"]},{"location":"olimpiada/solutii/ONI/2010/XI-XII-conex/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa XI-XII"]},{"location":"olimpiada/solutii/ONI/2010/XI-XII-diff/","title":"Solu\u021bia problemei diff (ONI 2010, clasele XI-XII)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa XI-XII"]},{"location":"olimpiada/solutii/ONI/2010/XI-XII-diff/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa XI-XII"]},{"location":"olimpiada/solutii/ONI/2010/XI-XII-kmax/","title":"Solu\u021bia problemei kmax (ONI 2010, clasele XI-XII)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa XI-XII"]},{"location":"olimpiada/solutii/ONI/2010/XI-XII-kmax/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa XI-XII"]},{"location":"olimpiada/solutii/ONI/2010/XI-XII-minuni/","title":"Solu\u021bia problemei minuni (ONI 2010, clasele XI-XII)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa XI-XII"]},{"location":"olimpiada/solutii/ONI/2010/XI-XII-minuni/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa XI-XII"]},{"location":"olimpiada/solutii/ONI/2010/XI-XII-stalpi/","title":"Solu\u021bia problemei stalpi (ONI 2010, clasele XI-XII)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa XI-XII"]},{"location":"olimpiada/solutii/ONI/2010/XI-XII-stalpi/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa XI-XII"]},{"location":"olimpiada/solutii/ONI/2010/XI-XII-submatrix/","title":"Solu\u021bia problemei submatrix (ONI 2010, clasele XI-XII)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa XI-XII"]},{"location":"olimpiada/solutii/ONI/2010/XI-XII-submatrix/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa XI-XII"]},{"location":"olimpiada/solutii/ONI/2011/IX-ape/","title":"Solu\u021bia problemei ape (ONI 2011, clasa a IX-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa IX"]},{"location":"olimpiada/solutii/ONI/2011/IX-ape/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa IX"]},{"location":"olimpiada/solutii/ONI/2011/IX-ec/","title":"Solu\u021bia problemei ec (ONI 2011, clasa a IX-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa IX"]},{"location":"olimpiada/solutii/ONI/2011/IX-ec/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa IX"]},{"location":"olimpiada/solutii/ONI/2011/IX-furnici/","title":"Solu\u021bia problemei furnici (ONI 2011, clasa a IX-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa IX"]},{"location":"olimpiada/solutii/ONI/2011/IX-furnici/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa IX"]},{"location":"olimpiada/solutii/ONI/2011/IX-poligon/","title":"Solu\u021bia problemei poligon (ONI 2011, clasa a IX-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa IX"]},{"location":"olimpiada/solutii/ONI/2011/IX-poligon/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa IX"]},{"location":"olimpiada/solutii/ONI/2011/IX-stalpi/","title":"Solu\u021bia problemei stalpi (ONI 2011, clasa a IX-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa IX"]},{"location":"olimpiada/solutii/ONI/2011/IX-stalpi/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa IX"]},{"location":"olimpiada/solutii/ONI/2011/IX-tort/","title":"Solu\u021bia problemei tort (ONI 2011, clasa a IX-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa IX"]},{"location":"olimpiada/solutii/ONI/2011/IX-tort/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa IX"]},{"location":"olimpiada/solutii/ONI/2011/V-fagure/","title":"Solu\u021bia problemei fagure (ONI 2011, clasa a V-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa V"]},{"location":"olimpiada/solutii/ONI/2011/V-fagure/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa V"]},{"location":"olimpiada/solutii/ONI/2011/V-goe/","title":"Solu\u021bia problemei goe (ONI 2011, clasa a V-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa V"]},{"location":"olimpiada/solutii/ONI/2011/V-goe/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa V"]},{"location":"olimpiada/solutii/ONI/2011/V-papusa/","title":"Solu\u021bia problemei papusa (ONI 2011, clasa a V-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa V"]},{"location":"olimpiada/solutii/ONI/2011/V-papusa/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa V"]},{"location":"olimpiada/solutii/ONI/2011/VI-joc/","title":"Solu\u021bia problemei joc (ONI 2011, clasa a VI-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa VI"]},{"location":"olimpiada/solutii/ONI/2011/VI-joc/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa VI"]},{"location":"olimpiada/solutii/ONI/2011/VI-talent/","title":"Solu\u021bia problemei talent (ONI 2011, clasa a VI-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa VI"]},{"location":"olimpiada/solutii/ONI/2011/VI-talent/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa VI"]},{"location":"olimpiada/solutii/ONI/2011/VI-xy/","title":"Solu\u021bia problemei xy (ONI 2011, clasa a VI-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa VI"]},{"location":"olimpiada/solutii/ONI/2011/VI-xy/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa VI"]},{"location":"olimpiada/solutii/ONI/2011/VII-joc/","title":"Solu\u021bia problemei joc (ONI 2011, clasa a VII-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa VII"]},{"location":"olimpiada/solutii/ONI/2011/VII-joc/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa VII"]},{"location":"olimpiada/solutii/ONI/2011/VII-mesaj/","title":"Solu\u021bia problemei mesaj (ONI 2011, clasa a VII-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa VII"]},{"location":"olimpiada/solutii/ONI/2011/VII-mesaj/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa VII"]},{"location":"olimpiada/solutii/ONI/2011/VII-zar/","title":"Solu\u021bia problemei zar (ONI 2011, clasa a VII-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa VII"]},{"location":"olimpiada/solutii/ONI/2011/VII-zar/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa VII"]},{"location":"olimpiada/solutii/ONI/2011/VIII-butoane/","title":"Solu\u021bia problemei butoane (ONI 2011, clasa a VIII-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa VIII"]},{"location":"olimpiada/solutii/ONI/2011/VIII-butoane/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa VIII"]},{"location":"olimpiada/solutii/ONI/2011/VIII-macheta/","title":"Solu\u021bia problemei macheta (ONI 2011, clasa a VIII-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa VIII"]},{"location":"olimpiada/solutii/ONI/2011/VIII-macheta/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa VIII"]},{"location":"olimpiada/solutii/ONI/2011/VIII-sport/","title":"Solu\u021bia problemei sport (ONI 2011, clasa a VIII-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa VIII"]},{"location":"olimpiada/solutii/ONI/2011/VIII-sport/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa VIII"]},{"location":"olimpiada/solutii/ONI/2011/X-acces/","title":"Solu\u021bia problemei Acces (ONI 2011, clasa a X-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa X"]},{"location":"olimpiada/solutii/ONI/2011/X-acces/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa X"]},{"location":"olimpiada/solutii/ONI/2011/X-expresie/","title":"Solu\u021bia problemei Expresie (ONI 2011, clasa a X-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa X"]},{"location":"olimpiada/solutii/ONI/2011/X-expresie/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa X"]},{"location":"olimpiada/solutii/ONI/2011/X-mxl/","title":"Solu\u021bia problemei MXL (ONI 2011, clasa a X-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa X"]},{"location":"olimpiada/solutii/ONI/2011/X-mxl/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa X"]},{"location":"olimpiada/solutii/ONI/2011/X-segmente/","title":"Solu\u021bia problemei Segmente (ONI 2011, clasa a X-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa X"]},{"location":"olimpiada/solutii/ONI/2011/X-segmente/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa X"]},{"location":"olimpiada/solutii/ONI/2011/X-telecab/","title":"Solu\u021bia problemei Telecab (ONI 2011, clasa a X-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa X"]},{"location":"olimpiada/solutii/ONI/2011/X-telecab/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa X"]},{"location":"olimpiada/solutii/ONI/2011/X-tsunami/","title":"Solu\u021bia problemei Tsunami (ONI 2011, clasa a X-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa X"]},{"location":"olimpiada/solutii/ONI/2011/X-tsunami/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa X"]},{"location":"olimpiada/solutii/ONI/2011/XI-XII-fotbal/","title":"Solu\u021bia problemei fotbal (ONI 2011, clasele XI-XII)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa XI-XII"]},{"location":"olimpiada/solutii/ONI/2011/XI-XII-fotbal/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa XI-XII"]},{"location":"olimpiada/solutii/ONI/2011/XI-XII-ikebana/","title":"Solu\u021bia problemei ikebana (ONI 2011, clasele XI-XII)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa XI-XII"]},{"location":"olimpiada/solutii/ONI/2011/XI-XII-ikebana/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa XI-XII"]},{"location":"olimpiada/solutii/ONI/2011/XI-XII-pamant/","title":"Solu\u021bia problemei pamant (ONI 2011, clasele XI-XII)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa XI-XII"]},{"location":"olimpiada/solutii/ONI/2011/XI-XII-pamant/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa XI-XII"]},{"location":"olimpiada/solutii/ONI/2011/XI-XII-posta/","title":"Solu\u021bia problemei posta (ONI 2011, clasele XI-XII)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa XI-XII"]},{"location":"olimpiada/solutii/ONI/2011/XI-XII-posta/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa XI-XII"]},{"location":"olimpiada/solutii/ONI/2011/XI-XII-radare/","title":"Solu\u021bia problemei radare (ONI 2011, clasele XI-XII)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa XI-XII"]},{"location":"olimpiada/solutii/ONI/2011/XI-XII-radare/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa XI-XII"]},{"location":"olimpiada/solutii/ONI/2011/XI-XII-xmoto/","title":"Solu\u021bia problemei xmoto (ONI 2011, clasele XI-XII)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa XI-XII"]},{"location":"olimpiada/solutii/ONI/2011/XI-XII-xmoto/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa XI-XII"]},{"location":"olimpiada/solutii/ONI/2012/IX-7segmente/","title":"Solu\u021bia problemei 7segmente (ONI 2012, clasa a IX-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa IX"]},{"location":"olimpiada/solutii/ONI/2012/IX-7segmente/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa IX"]},{"location":"olimpiada/solutii/ONI/2012/IX-copaci/","title":"Solu\u021bia problemei copaci (ONI 2012, clasa a IX-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa IX"]},{"location":"olimpiada/solutii/ONI/2012/IX-copaci/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa IX"]},{"location":"olimpiada/solutii/ONI/2012/IX-intersectii/","title":"Solu\u021bia problemei intersectii (ONI 2012, clasa a IX-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa IX"]},{"location":"olimpiada/solutii/ONI/2012/IX-intersectii/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa IX"]},{"location":"olimpiada/solutii/ONI/2012/IX-palindrom/","title":"Solu\u021bia problemei palindrom (ONI 2012, clasa a IX-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa IX"]},{"location":"olimpiada/solutii/ONI/2012/IX-palindrom/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa IX"]},{"location":"olimpiada/solutii/ONI/2012/IX-sstabil/","title":"Solu\u021bia problemei sstabil (ONI 2012, clasa a IX-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa IX"]},{"location":"olimpiada/solutii/ONI/2012/IX-sstabil/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa IX"]},{"location":"olimpiada/solutii/ONI/2012/IX-unuzero/","title":"Solu\u021bia problemei unuzero (ONI 2012, clasa a IX-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa IX"]},{"location":"olimpiada/solutii/ONI/2012/IX-unuzero/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa IX"]},{"location":"olimpiada/solutii/ONI/2012/V-culegere/","title":"Solu\u021bia problemei culegere (ONI 2012, clasa a V-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa V"]},{"location":"olimpiada/solutii/ONI/2012/V-culegere/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa V"]},{"location":"olimpiada/solutii/ONI/2012/V-culori/","title":"Solu\u021bia problemei culori (ONI 2012, clasa a V-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa V"]},{"location":"olimpiada/solutii/ONI/2012/V-culori/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa V"]},{"location":"olimpiada/solutii/ONI/2012/V-stele/","title":"Solu\u021bia problemei stele (ONI 2012, clasa a V-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa V"]},{"location":"olimpiada/solutii/ONI/2012/V-stele/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa V"]},{"location":"olimpiada/solutii/ONI/2012/VI-cartier/","title":"Solu\u021bia problemei cartier (ONI 2012, clasa a VI-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa VI"]},{"location":"olimpiada/solutii/ONI/2012/VI-cartier/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa VI"]},{"location":"olimpiada/solutii/ONI/2012/VI-medalion/","title":"Solu\u021bia problemei medalion (ONI 2012, clasa a VI-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa VI"]},{"location":"olimpiada/solutii/ONI/2012/VI-medalion/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa VI"]},{"location":"olimpiada/solutii/ONI/2012/VI-numar/","title":"Solu\u021bia problemei numar (ONI 2012, clasa a VI-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa VI"]},{"location":"olimpiada/solutii/ONI/2012/VI-numar/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa VI"]},{"location":"olimpiada/solutii/ONI/2012/VII-bile/","title":"Solu\u021bia problemei bile (ONI 2012, clasa a VII-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa VII"]},{"location":"olimpiada/solutii/ONI/2012/VII-bile/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa VII"]},{"location":"olimpiada/solutii/ONI/2012/VII-proiecte/","title":"Solu\u021bia problemei proiecte (ONI 2012, clasa a VII-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa VII"]},{"location":"olimpiada/solutii/ONI/2012/VII-proiecte/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa VII"]},{"location":"olimpiada/solutii/ONI/2012/VII-zigzag/","title":"Solu\u021bia problemei zigzag (ONI 2012, clasa a VII-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa VII"]},{"location":"olimpiada/solutii/ONI/2012/VII-zigzag/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa VII"]},{"location":"olimpiada/solutii/ONI/2012/VIII-alune/","title":"Solu\u021bia problemei alune (ONI 2012, clasa a VIII-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa VIII"]},{"location":"olimpiada/solutii/ONI/2012/VIII-alune/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa VIII"]},{"location":"olimpiada/solutii/ONI/2012/VIII-cuburi/","title":"Solu\u021bia problemei cuburi (ONI 2012, clasa a VIII-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa VIII"]},{"location":"olimpiada/solutii/ONI/2012/VIII-cuburi/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa VIII"]},{"location":"olimpiada/solutii/ONI/2012/VIII-optim/","title":"Solu\u021bia problemei optim (ONI 2012, clasa a VIII-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa VIII"]},{"location":"olimpiada/solutii/ONI/2012/VIII-optim/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa VIII"]},{"location":"olimpiada/solutii/ONI/2012/X-amedie/","title":"Solu\u021bia problemei amedie (ONI 2012, clasa a X-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa X"]},{"location":"olimpiada/solutii/ONI/2012/X-amedie/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim. <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre></p>","tags":["ONI","clasa X"]},{"location":"olimpiada/solutii/ONI/2012/X-cutie/","title":"Solu\u021bia problemei cutie (ONI 2012, clasa a X-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa X"]},{"location":"olimpiada/solutii/ONI/2012/X-cutie/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa X"]},{"location":"olimpiada/solutii/ONI/2012/X-drept/","title":"Solu\u021bia problemei drept (ONI 2012, clasa a X-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa X"]},{"location":"olimpiada/solutii/ONI/2012/X-drept/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa X"]},{"location":"olimpiada/solutii/ONI/2012/X-gheizere/","title":"Solu\u021bia problemei gheizere (ONI 2012, clasa a X-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa X"]},{"location":"olimpiada/solutii/ONI/2012/X-gheizere/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa X"]},{"location":"olimpiada/solutii/ONI/2012/X-plus/","title":"Solu\u021bia problemei plus (ONI 2012, clasa a X-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa X"]},{"location":"olimpiada/solutii/ONI/2012/X-plus/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa X"]},{"location":"olimpiada/solutii/ONI/2012/X-poly/","title":"Solu\u021bia problemei poly (ONI 2012, clasa a X-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa X"]},{"location":"olimpiada/solutii/ONI/2012/X-poly/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa X"]},{"location":"olimpiada/solutii/ONI/2012/XI-XII-drumuri/","title":"Solu\u021bia problemei drumuri (ONI 2012, clasele XI-XII)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa XI-XII"]},{"location":"olimpiada/solutii/ONI/2012/XI-XII-drumuri/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa XI-XII"]},{"location":"olimpiada/solutii/ONI/2012/XI-XII-minerale/","title":"Solu\u021bia problemei minerale (ONI 2012, clasele XI-XII)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa XI-XII"]},{"location":"olimpiada/solutii/ONI/2012/XI-XII-minerale/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa XI-XII"]},{"location":"olimpiada/solutii/ONI/2012/XI-XII-search/","title":"Solu\u021bia problemei search (ONI 2012, clasele XI-XII)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa XI-XII"]},{"location":"olimpiada/solutii/ONI/2012/XI-XII-search/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa XI-XII"]},{"location":"olimpiada/solutii/ONI/2012/XI-XII-tarabe/","title":"Solu\u021bia problemei tarabe (ONI 2012, clasele XI-XII)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa XI-XII"]},{"location":"olimpiada/solutii/ONI/2012/XI-XII-tarabe/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa XI-XII"]},{"location":"olimpiada/solutii/ONI/2012/XI-XII-urat/","title":"Solu\u021bia problemei urat (ONI 2012, clasele XI-XII)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa XI-XII"]},{"location":"olimpiada/solutii/ONI/2012/XI-XII-urat/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa XI-XII"]},{"location":"olimpiada/solutii/ONI/2012/XI-XII-zlego/","title":"Solu\u021bia problemei zlego (ONI 2012, clasele XI-XII)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa XI-XII"]},{"location":"olimpiada/solutii/ONI/2012/XI-XII-zlego/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa XI-XII"]},{"location":"olimpiada/solutii/ONI/2013/IX-aranjare/","title":"Solu\u021bia problemei aranjare (ONI 2013, clasa a IX-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa IX"]},{"location":"olimpiada/solutii/ONI/2013/IX-aranjare/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa IX"]},{"location":"olimpiada/solutii/ONI/2013/IX-gradina/","title":"Solu\u021bia problemei gradina (ONI 2013, clasa a IX-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa IX"]},{"location":"olimpiada/solutii/ONI/2013/IX-gradina/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa IX"]},{"location":"olimpiada/solutii/ONI/2013/IX-momente/","title":"Solu\u021bia problemei momente (ONI 2013, clasa a IX-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa IX"]},{"location":"olimpiada/solutii/ONI/2013/IX-momente/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa IX"]},{"location":"olimpiada/solutii/ONI/2013/IX-secvente/","title":"Solu\u021bia problemei secvente (ONI 2013, clasa a IX-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa IX"]},{"location":"olimpiada/solutii/ONI/2013/IX-secvente/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa IX"]},{"location":"olimpiada/solutii/ONI/2013/IX-spider/","title":"Solu\u021bia problemei spider (ONI 2013, clasa a IX-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa IX"]},{"location":"olimpiada/solutii/ONI/2013/IX-spider/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa IX"]},{"location":"olimpiada/solutii/ONI/2013/IX-split/","title":"Solu\u021bia problemei split (ONI 2013, clasa a IX-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa IX"]},{"location":"olimpiada/solutii/ONI/2013/IX-split/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa IX"]},{"location":"olimpiada/solutii/ONI/2013/V-extraprime/","title":"Solu\u021bia problemei extraprime (ONI 2013, clasa a V-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa V"]},{"location":"olimpiada/solutii/ONI/2013/V-extraprime/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa V"]},{"location":"olimpiada/solutii/ONI/2013/V-greieri/","title":"Solu\u021bia problemei greieri (ONI 2013, clasa a V-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa V"]},{"location":"olimpiada/solutii/ONI/2013/V-greieri/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa V"]},{"location":"olimpiada/solutii/ONI/2013/V-onigim/","title":"Solu\u021bia problemei onigim (ONI 2013, clasa a V-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa V"]},{"location":"olimpiada/solutii/ONI/2013/V-onigim/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa V"]},{"location":"olimpiada/solutii/ONI/2013/VI-divizori/","title":"Solu\u021bia problemei divizori (ONI 2013, clasa a VI-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa VI"]},{"location":"olimpiada/solutii/ONI/2013/VI-divizori/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa VI"]},{"location":"olimpiada/solutii/ONI/2013/VI-remi/","title":"Solu\u021bia problemei remi (ONI 2013, clasa a VI-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa VI"]},{"location":"olimpiada/solutii/ONI/2013/VI-remi/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa VI"]},{"location":"olimpiada/solutii/ONI/2013/VI-tetris/","title":"Solu\u021bia problemei tetris (ONI 2013, clasa a VI-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa VI"]},{"location":"olimpiada/solutii/ONI/2013/VI-tetris/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa VI"]},{"location":"olimpiada/solutii/ONI/2013/VII-cursa/","title":"Solu\u021bia problemei cursa (ONI 2013, clasa a VII-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa VII"]},{"location":"olimpiada/solutii/ONI/2013/VII-cursa/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa VII"]},{"location":"olimpiada/solutii/ONI/2013/VII-patrate/","title":"Solu\u021bia problemei patrate (ONI 2013, clasa a VII-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa VII"]},{"location":"olimpiada/solutii/ONI/2013/VII-patrate/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa VII"]},{"location":"olimpiada/solutii/ONI/2013/VII-secvp/","title":"Solu\u021bia problemei secvp (ONI 2013, clasa a VII-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa VII"]},{"location":"olimpiada/solutii/ONI/2013/VII-secvp/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa VII"]},{"location":"olimpiada/solutii/ONI/2013/VIII-amestec/","title":"Solu\u021bia problemei amestec (ONI 2013, clasa a VIII-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa VIII"]},{"location":"olimpiada/solutii/ONI/2013/VIII-amestec/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa VIII"]},{"location":"olimpiada/solutii/ONI/2013/VIII-eoliene/","title":"Solu\u021bia problemei eoliene (ONI 2013, clasa a VIII-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa VIII"]},{"location":"olimpiada/solutii/ONI/2013/VIII-eoliene/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa VIII"]},{"location":"olimpiada/solutii/ONI/2013/VIII-sudoku/","title":"Solu\u021bia problemei sudoku (ONI 2013, clasa a VIII-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa VIII"]},{"location":"olimpiada/solutii/ONI/2013/VIII-sudoku/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa VIII"]},{"location":"olimpiada/solutii/ONI/2013/X-cumpanit/","title":"Solu\u021bia problemei cumpanit (ONI 2013, clasa a X-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa X"]},{"location":"olimpiada/solutii/ONI/2013/X-cumpanit/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa X"]},{"location":"olimpiada/solutii/ONI/2013/X-flori/","title":"Solu\u021bia problemei flori (ONI 2013, clasa a X-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa X"]},{"location":"olimpiada/solutii/ONI/2013/X-flori/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa X"]},{"location":"olimpiada/solutii/ONI/2013/X-romb/","title":"Solu\u021bia problemei romb (ONI 2013, clasa a X-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa X"]},{"location":"olimpiada/solutii/ONI/2013/X-romb/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa X"]},{"location":"olimpiada/solutii/ONI/2013/X-showroom/","title":"Solu\u021bia problemei Showroom (ONI 2013, clasa a X-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa X"]},{"location":"olimpiada/solutii/ONI/2013/X-showroom/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa X"]},{"location":"olimpiada/solutii/ONI/2013/X-taxa/","title":"Solu\u021bia problemei taxa (ONI 2013, clasa a X-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa X"]},{"location":"olimpiada/solutii/ONI/2013/X-taxa/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa X"]},{"location":"olimpiada/solutii/ONI/2013/X-zone/","title":"Solu\u021bia problemei zone (ONI 2013, clasa a X-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa X"]},{"location":"olimpiada/solutii/ONI/2013/X-zone/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa X"]},{"location":"olimpiada/solutii/ONI/2013/XI-XII-amici/","title":"Solu\u021bia problemei amici (ONI 2013, clasele XI-XII)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa XI-XII"]},{"location":"olimpiada/solutii/ONI/2013/XI-XII-amici/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa XI-XII"]},{"location":"olimpiada/solutii/ONI/2013/XI-XII-ausoara/","title":"Solu\u021bia problemei ausoara (ONI 2013, clasele XI-XII)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa XI-XII"]},{"location":"olimpiada/solutii/ONI/2013/XI-XII-ausoara/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa XI-XII"]},{"location":"olimpiada/solutii/ONI/2013/XI-XII-bemo/","title":"Solu\u021bia problemei bemo (ONI 2013, clasele XI-XII)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa XI-XII"]},{"location":"olimpiada/solutii/ONI/2013/XI-XII-bemo/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa XI-XII"]},{"location":"olimpiada/solutii/ONI/2013/XI-XII-confuzie/","title":"Solu\u021bia problemei confuzie (ONI 2013, clasele XI-XII)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa XI-XII"]},{"location":"olimpiada/solutii/ONI/2013/XI-XII-confuzie/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa XI-XII"]},{"location":"olimpiada/solutii/ONI/2013/XI-XII-drumuri/","title":"Solu\u021bia problemei drumuri (ONI 2013, clasele XI-XII)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa XI-XII"]},{"location":"olimpiada/solutii/ONI/2013/XI-XII-drumuri/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa XI-XII"]},{"location":"olimpiada/solutii/ONI/2013/XI-XII-xnumere/","title":"Solu\u021bia problemei xnumere (ONI 2013, clasele XI-XII)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa XI-XII"]},{"location":"olimpiada/solutii/ONI/2013/XI-XII-xnumere/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa XI-XII"]},{"location":"olimpiada/solutii/ONI/2014/IX-harta/","title":"Solu\u021bia problemei harta (ONI 2014, clasa a IX-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa IX"]},{"location":"olimpiada/solutii/ONI/2014/IX-harta/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa IX"]},{"location":"olimpiada/solutii/ONI/2014/IX-progresie/","title":"Solu\u021bia problemei progresie (ONI 2014, clasa a IX-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa IX"]},{"location":"olimpiada/solutii/ONI/2014/IX-progresie/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa IX"]},{"location":"olimpiada/solutii/ONI/2014/IX-qvect/","title":"Solu\u021bia problemei qvect (ONI 2014, clasa a IX-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa IX"]},{"location":"olimpiada/solutii/ONI/2014/IX-qvect/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa IX"]},{"location":"olimpiada/solutii/ONI/2014/IX-reflex/","title":"Solu\u021bia problemei reflex (ONI 2014, clasa a IX-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa IX"]},{"location":"olimpiada/solutii/ONI/2014/IX-reflex/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa IX"]},{"location":"olimpiada/solutii/ONI/2014/IX-tg/","title":"Solu\u021bia problemei tg (ONI 2014, clasa a IX-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa IX"]},{"location":"olimpiada/solutii/ONI/2014/IX-tg/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa IX"]},{"location":"olimpiada/solutii/ONI/2014/IX-traseu/","title":"Solu\u021bia problemei traseu (ONI 2014, clasa a IX-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa IX"]},{"location":"olimpiada/solutii/ONI/2014/IX-traseu/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa IX"]},{"location":"olimpiada/solutii/ONI/2014/V-2048/","title":"Solu\u021bia problemei 2048 (ONI 2014, clasa a V-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa V"]},{"location":"olimpiada/solutii/ONI/2014/V-2048/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa V"]},{"location":"olimpiada/solutii/ONI/2014/V-babilon/","title":"Solu\u021bia problemei babilon (ONI 2014, clasa a V-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa V"]},{"location":"olimpiada/solutii/ONI/2014/V-babilon/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa V"]},{"location":"olimpiada/solutii/ONI/2014/V-iepurasi/","title":"Solu\u021bia problemei iepurasi (ONI 2014, clasa a V-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa V"]},{"location":"olimpiada/solutii/ONI/2014/V-iepurasi/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa V"]},{"location":"olimpiada/solutii/ONI/2014/VI-betisoare/","title":"Solu\u021bia problemei betisoare (ONI 2014, clasa a VI-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa VI"]},{"location":"olimpiada/solutii/ONI/2014/VI-betisoare/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa VI"]},{"location":"olimpiada/solutii/ONI/2014/VI-praslea/","title":"Solu\u021bia problemei praslea (ONI 2014, clasa a VI-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa VI"]},{"location":"olimpiada/solutii/ONI/2014/VI-praslea/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa VI"]},{"location":"olimpiada/solutii/ONI/2014/VI-tinta/","title":"Solu\u021bia problemei tinta (ONI 2014, clasa a VI-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa VI"]},{"location":"olimpiada/solutii/ONI/2014/VI-tinta/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa VI"]},{"location":"olimpiada/solutii/ONI/2014/VII-codat/","title":"Solu\u021bia problemei codat (ONI 2014, clasa a VII-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa VII"]},{"location":"olimpiada/solutii/ONI/2014/VII-codat/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa VII"]},{"location":"olimpiada/solutii/ONI/2014/VII-nod/","title":"Solu\u021bia problemei nod (ONI 2014, clasa a VII-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa VII"]},{"location":"olimpiada/solutii/ONI/2014/VII-nod/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa VII"]},{"location":"olimpiada/solutii/ONI/2014/VII-placa/","title":"Solu\u021bia problemei placa (ONI 2014, clasa a VII-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa VII"]},{"location":"olimpiada/solutii/ONI/2014/VII-placa/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa VII"]},{"location":"olimpiada/solutii/ONI/2014/VIII-cifre/","title":"Solu\u021bia problemei cifre (ONI 2014, clasa a VIII-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa VIII"]},{"location":"olimpiada/solutii/ONI/2014/VIII-cifre/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa VIII"]},{"location":"olimpiada/solutii/ONI/2014/VIII-solitar/","title":"Solu\u021bia problemei solitar (ONI 2014, clasa a VIII-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa VIII"]},{"location":"olimpiada/solutii/ONI/2014/VIII-solitar/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa VIII"]},{"location":"olimpiada/solutii/ONI/2014/VIII-tdrept/","title":"Solu\u021bia problemei tdrept (ONI 2014, clasa a VIII-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa VIII"]},{"location":"olimpiada/solutii/ONI/2014/VIII-tdrept/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa VIII"]},{"location":"olimpiada/solutii/ONI/2014/X-joc/","title":"Solu\u021bia problemei joc (ONI 2014, clasa a X-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa X"]},{"location":"olimpiada/solutii/ONI/2014/X-joc/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa X"]},{"location":"olimpiada/solutii/ONI/2014/X-puteri/","title":"Solu\u021bia problemei Puteri (ONI 2014, clasa a X-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa X"]},{"location":"olimpiada/solutii/ONI/2014/X-puteri/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa X"]},{"location":"olimpiada/solutii/ONI/2014/X-rascoala/","title":"Solu\u021bia problemei R\u0103scoala (ONI 2014, clasa a X-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa X"]},{"location":"olimpiada/solutii/ONI/2014/X-rascoala/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa X"]},{"location":"olimpiada/solutii/ONI/2014/X-spion/","title":"Solu\u021bia problemei spion (ONI 2014, clasa a X-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa X"]},{"location":"olimpiada/solutii/ONI/2014/X-spion/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa X"]},{"location":"olimpiada/solutii/ONI/2014/X-stiva/","title":"Solu\u021bia problemei Stiva (ONI 2014, clasa a X-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa X"]},{"location":"olimpiada/solutii/ONI/2014/X-stiva/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa X"]},{"location":"olimpiada/solutii/ONI/2014/X-zimeria/","title":"Solu\u021bia problemei zimeria (ONI 2014, clasa a X-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa X"]},{"location":"olimpiada/solutii/ONI/2014/X-zimeria/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa X"]},{"location":"olimpiada/solutii/ONI/2014/XI-XII-avarcolaci/","title":"Solu\u021bia problemei avarcolaci (ONI 2014, clasele XI-XII)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa XI-XII"]},{"location":"olimpiada/solutii/ONI/2014/XI-XII-avarcolaci/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa XI-XII"]},{"location":"olimpiada/solutii/ONI/2014/XI-XII-clepsidra/","title":"Solu\u021bia problemei clepsidra (ONI 2014, clasele XI-XII)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa XI-XII"]},{"location":"olimpiada/solutii/ONI/2014/XI-XII-clepsidra/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa XI-XII"]},{"location":"olimpiada/solutii/ONI/2014/XI-XII-karb/","title":"Solu\u021bia problemei karb (ONI 2014, clasele XI-XII)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa XI-XII"]},{"location":"olimpiada/solutii/ONI/2014/XI-XII-karb/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa XI-XII"]},{"location":"olimpiada/solutii/ONI/2014/XI-XII-permutare/","title":"Solu\u021bia problemei permutare (ONI 2014, clasele XI-XII)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa XI-XII"]},{"location":"olimpiada/solutii/ONI/2014/XI-XII-permutare/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa XI-XII"]},{"location":"olimpiada/solutii/ONI/2014/XI-XII-volum/","title":"Solu\u021bia problemei volum (ONI 2014, clasele XI-XII)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa XI-XII"]},{"location":"olimpiada/solutii/ONI/2014/XI-XII-volum/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa XI-XII"]},{"location":"olimpiada/solutii/ONI/2014/XI-XII-xcmmdc/","title":"Solu\u021bia problemei xcmmdc (ONI 2014, clasele XI-XII)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa XI-XII"]},{"location":"olimpiada/solutii/ONI/2014/XI-XII-xcmmdc/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa XI-XII"]},{"location":"olimpiada/solutii/ONI/2015/IX-casa/","title":"Solu\u021bia problemei casa (ONI 2015, clasa a IX-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa IX"]},{"location":"olimpiada/solutii/ONI/2015/IX-casa/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa IX"]},{"location":"olimpiada/solutii/ONI/2015/IX-cub/","title":"Solu\u021bia problemei cub (ONI 2015, clasa a IX-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa IX"]},{"location":"olimpiada/solutii/ONI/2015/IX-cub/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa IX"]},{"location":"olimpiada/solutii/ONI/2015/IX-lenes/","title":"Solu\u021bia problemei lene\u0219 (ONI 2015, clasa a IX-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa IX"]},{"location":"olimpiada/solutii/ONI/2015/IX-lenes/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa IX"]},{"location":"olimpiada/solutii/ONI/2015/IX-risc/","title":"Solu\u021bia problemei risc (ONI 2015, clasa a IX-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa IX"]},{"location":"olimpiada/solutii/ONI/2015/IX-risc/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa IX"]},{"location":"olimpiada/solutii/ONI/2015/IX-roboti/","title":"Solu\u021bia problemei roboti (ONI 2015, clasa a IX-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa IX"]},{"location":"olimpiada/solutii/ONI/2015/IX-roboti/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa IX"]},{"location":"olimpiada/solutii/ONI/2015/IX-sipet/","title":"Solu\u021bia problemei sipet (ONI 2015, clasa a IX-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa IX"]},{"location":"olimpiada/solutii/ONI/2015/IX-sipet/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa IX"]},{"location":"olimpiada/solutii/ONI/2015/V-iepuras/","title":"Solu\u021bia problemei iepuras (ONI 2015, clasa a V-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa V"]},{"location":"olimpiada/solutii/ONI/2015/V-iepuras/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa V"]},{"location":"olimpiada/solutii/ONI/2015/V-inventie/","title":"Solu\u021bia problemei inventie (ONI 2015, clasa a V-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa V"]},{"location":"olimpiada/solutii/ONI/2015/V-inventie/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa V"]},{"location":"olimpiada/solutii/ONI/2015/V-mesaj/","title":"Solu\u021bia problemei mesaj (ONI 2015, clasa a V-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa V"]},{"location":"olimpiada/solutii/ONI/2015/V-mesaj/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa V"]},{"location":"olimpiada/solutii/ONI/2015/VI-echer/","title":"Solu\u021bia problemei echer (ONI 2015, clasa a VI-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa VI"]},{"location":"olimpiada/solutii/ONI/2015/VI-echer/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa VI"]},{"location":"olimpiada/solutii/ONI/2015/VI-lightbot/","title":"Solu\u021bia problemei lightbot (ONI 2015, clasa a VI-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa VI"]},{"location":"olimpiada/solutii/ONI/2015/VI-lightbot/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa VI"]},{"location":"olimpiada/solutii/ONI/2015/VI-teren/","title":"Solu\u021bia problemei teren (ONI 2015, clasa a VI-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa VI"]},{"location":"olimpiada/solutii/ONI/2015/VI-teren/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa VI"]},{"location":"olimpiada/solutii/ONI/2015/VII-cript/","title":"Solu\u021bia problemei cript (ONI 2015, clasa a VII-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa VII"]},{"location":"olimpiada/solutii/ONI/2015/VII-cript/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa VII"]},{"location":"olimpiada/solutii/ONI/2015/VII-scadere/","title":"Solu\u021bia problemei scadere (ONI 2015, clasa a VII-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa VII"]},{"location":"olimpiada/solutii/ONI/2015/VII-scadere/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa VII"]},{"location":"olimpiada/solutii/ONI/2015/VII-tv/","title":"Solu\u021bia problemei tv (ONI 2015, clasa a VII-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa VII"]},{"location":"olimpiada/solutii/ONI/2015/VII-tv/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa VII"]},{"location":"olimpiada/solutii/ONI/2015/VIII-magic/","title":"Solu\u021bia problemei magic (ONI 2015, clasa a VIII-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa VIII"]},{"location":"olimpiada/solutii/ONI/2015/VIII-magic/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa VIII"]},{"location":"olimpiada/solutii/ONI/2015/VIII-restaurare/","title":"Solu\u021bia problemei restaurare (ONI 2015, clasa a VIII-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa VIII"]},{"location":"olimpiada/solutii/ONI/2015/VIII-restaurare/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa VIII"]},{"location":"olimpiada/solutii/ONI/2015/VIII-sort2dist/","title":"Solu\u021bia problemei sort2dist (ONI 2015, clasa a VIII-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa VIII"]},{"location":"olimpiada/solutii/ONI/2015/VIII-sort2dist/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa VIII"]},{"location":"olimpiada/solutii/ONI/2015/X-cabana/","title":"Solu\u021bia problemei cabana (ONI 2015, clasa a X-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa X"]},{"location":"olimpiada/solutii/ONI/2015/X-cabana/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim. <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre></p>","tags":["ONI","clasa X"]},{"location":"olimpiada/solutii/ONI/2015/X-fence/","title":"Solu\u021bia problemei fence (ONI 2015, clasa a X-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa X"]},{"location":"olimpiada/solutii/ONI/2015/X-fence/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa X"]},{"location":"olimpiada/solutii/ONI/2015/X-nmult/","title":"Solu\u021bia problemei Nmult (ONI 2015, clasa a X-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa X"]},{"location":"olimpiada/solutii/ONI/2015/X-nmult/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa X"]},{"location":"olimpiada/solutii/ONI/2015/X-procente/","title":"Solu\u021bia problemei Procente (ONI 2015, clasa a X-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa X"]},{"location":"olimpiada/solutii/ONI/2015/X-procente/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa X"]},{"location":"olimpiada/solutii/ONI/2015/X-robotics/","title":"Solu\u021bia problemei Robotics (ONI 2015, clasa a X-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa X"]},{"location":"olimpiada/solutii/ONI/2015/X-robotics/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa X"]},{"location":"olimpiada/solutii/ONI/2015/X-sablon/","title":"Solu\u021bia problemei \u0218ablon (ONI 2015, clasa a X-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa X"]},{"location":"olimpiada/solutii/ONI/2015/X-sablon/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa X"]},{"location":"olimpiada/solutii/ONI/2015/XI-XII-arbvalmax/","title":"Solu\u021bia problemei arbvalmax (ONI 2015, clasele XI-XII)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa XI-XII"]},{"location":"olimpiada/solutii/ONI/2015/XI-XII-arbvalmax/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa XI-XII"]},{"location":"olimpiada/solutii/ONI/2015/XI-XII-ksecv/","title":"Solu\u021bia problemei ksecv (ONI 2015, clasele XI-XII)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa XI-XII"]},{"location":"olimpiada/solutii/ONI/2015/XI-XII-ksecv/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa XI-XII"]},{"location":"olimpiada/solutii/ONI/2015/XI-XII-metrou/","title":"Solu\u021bia problemei metrou (ONI 2015, clasele XI-XII)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa XI-XII"]},{"location":"olimpiada/solutii/ONI/2015/XI-XII-metrou/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim. <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre></p>","tags":["ONI","clasa XI-XII"]},{"location":"olimpiada/solutii/ONI/2015/XI-XII-spiridusi/","title":"Solu\u021bia problemei spiridusi (ONI 2015, clasele XI-XII)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa XI-XII"]},{"location":"olimpiada/solutii/ONI/2015/XI-XII-spiridusi/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa XI-XII"]},{"location":"olimpiada/solutii/ONI/2015/XI-XII-text/","title":"Solu\u021bia problemei text (ONI 2015, clasele XI-XII)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa XI-XII"]},{"location":"olimpiada/solutii/ONI/2015/XI-XII-text/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa XI-XII"]},{"location":"olimpiada/solutii/ONI/2015/XI-XII-trenuri/","title":"Solu\u021bia problemei trenuri (ONI 2015, clasele XI-XII)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa XI-XII"]},{"location":"olimpiada/solutii/ONI/2015/XI-XII-trenuri/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa XI-XII"]},{"location":"olimpiada/solutii/ONI/2016/IX-civilizatie/","title":"Solu\u021bia problemei civilizatie (ONI 2016, clasa a IX-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa IX"]},{"location":"olimpiada/solutii/ONI/2016/IX-civilizatie/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa IX"]},{"location":"olimpiada/solutii/ONI/2016/IX-cmmdc/","title":"Solu\u021bia problemei cmmdc (ONI 2016, clasa a IX-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa IX"]},{"location":"olimpiada/solutii/ONI/2016/IX-cmmdc/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa IX"]},{"location":"olimpiada/solutii/ONI/2016/IX-dif2/","title":"Solu\u021bia problemei dif2 (ONI 2016, clasa a IX-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa IX"]},{"location":"olimpiada/solutii/ONI/2016/IX-dif2/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa IX"]},{"location":"olimpiada/solutii/ONI/2016/IX-leduri/","title":"Solu\u021bia problemei leduri (ONI 2016, clasa a IX-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa IX"]},{"location":"olimpiada/solutii/ONI/2016/IX-leduri/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa IX"]},{"location":"olimpiada/solutii/ONI/2016/IX-livada/","title":"Solu\u021bia problemei livada (ONI 2016, clasa a IX-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa IX"]},{"location":"olimpiada/solutii/ONI/2016/IX-livada/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa IX"]},{"location":"olimpiada/solutii/ONI/2016/IX-omogene/","title":"Solu\u021bia problemei omogene (ONI 2016, clasa a IX-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa IX"]},{"location":"olimpiada/solutii/ONI/2016/IX-omogene/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa IX"]},{"location":"olimpiada/solutii/ONI/2016/V-norocos/","title":"Solu\u021bia problemei norocos (ONI 2016, clasa a V-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa V"]},{"location":"olimpiada/solutii/ONI/2016/V-norocos/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa V"]},{"location":"olimpiada/solutii/ONI/2016/V-oglinda/","title":"Solu\u021bia problemei oglinda (ONI 2016, clasa a V-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa V"]},{"location":"olimpiada/solutii/ONI/2016/V-oglinda/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa V"]},{"location":"olimpiada/solutii/ONI/2016/V-perechi/","title":"Solu\u021bia problemei perechi (ONI 2016, clasa a V-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa V"]},{"location":"olimpiada/solutii/ONI/2016/V-perechi/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa V"]},{"location":"olimpiada/solutii/ONI/2016/VI-cod/","title":"Solu\u021bia problemei cod (ONI 2016, clasa a VI-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa VI"]},{"location":"olimpiada/solutii/ONI/2016/VI-cod/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa VI"]},{"location":"olimpiada/solutii/ONI/2016/VI-perm/","title":"Solu\u021bia problemei perm (ONI 2016, clasa a VI-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa VI"]},{"location":"olimpiada/solutii/ONI/2016/VI-perm/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa VI"]},{"location":"olimpiada/solutii/ONI/2016/VI-robotel/","title":"Solu\u021bia problemei robotel (ONI 2016, clasa a VI-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa VI"]},{"location":"olimpiada/solutii/ONI/2016/VI-robotel/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa VI"]},{"location":"olimpiada/solutii/ONI/2016/VII-birouri/","title":"Solu\u021bia problemei birouri (ONI 2016, clasa a VII-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa VII"]},{"location":"olimpiada/solutii/ONI/2016/VII-birouri/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa VII"]},{"location":"olimpiada/solutii/ONI/2016/VII-cristale/","title":"Solu\u021bia problemei cristale (ONI 2016, clasa a VII-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa VII"]},{"location":"olimpiada/solutii/ONI/2016/VII-cristale/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa VII"]},{"location":"olimpiada/solutii/ONI/2016/VII-parchet/","title":"Solu\u021bia problemei parchet (ONI 2016, clasa a VII-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa VII"]},{"location":"olimpiada/solutii/ONI/2016/VII-parchet/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa VII"]},{"location":"olimpiada/solutii/ONI/2016/VIII-cercetasi/","title":"Solu\u021bia problemei Cercetasi (ONI 2016, clasa a VIII-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa VIII"]},{"location":"olimpiada/solutii/ONI/2016/VIII-cercetasi/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa VIII"]},{"location":"olimpiada/solutii/ONI/2016/VIII-farma/","title":"Solu\u021bia problemei farma (ONI 2016, clasa a VIII-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa VIII"]},{"location":"olimpiada/solutii/ONI/2016/VIII-farma/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa VIII"]},{"location":"olimpiada/solutii/ONI/2016/VIII-stele/","title":"Solu\u021bia problemei stele (ONI 2016, clasa a VIII-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa VIII"]},{"location":"olimpiada/solutii/ONI/2016/VIII-stele/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa VIII"]},{"location":"olimpiada/solutii/ONI/2016/X-calc/","title":"Solu\u021bia problemei Calc (ONI 2016, clasa a X-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa X"]},{"location":"olimpiada/solutii/ONI/2016/X-calc/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa X"]},{"location":"olimpiada/solutii/ONI/2016/X-elmer/","title":"Solu\u021bia problemei Elmer (ONI 2016, clasa a X-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa X"]},{"location":"olimpiada/solutii/ONI/2016/X-elmer/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa X"]},{"location":"olimpiada/solutii/ONI/2016/X-intrus/","title":"Solu\u021bia problemei Intrus (ONI 2016, clasa a X-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa X"]},{"location":"olimpiada/solutii/ONI/2016/X-intrus/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa X"]},{"location":"olimpiada/solutii/ONI/2016/X-movedel/","title":"Solu\u021bia problemei Movedel (ONI 2016, clasa a X-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa X"]},{"location":"olimpiada/solutii/ONI/2016/X-movedel/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa X"]},{"location":"olimpiada/solutii/ONI/2016/X-tort/","title":"Solu\u021bia problemei Tort (ONI 2016, clasa a X-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa X"]},{"location":"olimpiada/solutii/ONI/2016/X-tort/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa X"]},{"location":"olimpiada/solutii/ONI/2016/X-undo/","title":"Solu\u021bia problemei Undo (ONI 2016, clasa a X-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa X"]},{"location":"olimpiada/solutii/ONI/2016/X-undo/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa X"]},{"location":"olimpiada/solutii/ONI/2016/XI-XII-arbore/","title":"Solu\u021bia problemei arbore (ONI 2016, clasele XI-XII)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa XI-XII"]},{"location":"olimpiada/solutii/ONI/2016/XI-XII-arbore/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa XI-XII"]},{"location":"olimpiada/solutii/ONI/2016/XI-XII-calafat/","title":"Solu\u021bia problemei calafat (ONI 2016, clasele XI-XII)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa XI-XII"]},{"location":"olimpiada/solutii/ONI/2016/XI-XII-calafat/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa XI-XII"]},{"location":"olimpiada/solutii/ONI/2016/XI-XII-euro/","title":"Solu\u021bia problemei euro (ONI 2016, clasele XI-XII)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa XI-XII"]},{"location":"olimpiada/solutii/ONI/2016/XI-XII-euro/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa XI-XII"]},{"location":"olimpiada/solutii/ONI/2016/XI-XII-sushi/","title":"Solu\u021bia problemei sushi (ONI 2016, clasele XI-XII)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa XI-XII"]},{"location":"olimpiada/solutii/ONI/2016/XI-XII-sushi/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa XI-XII"]},{"location":"olimpiada/solutii/ONI/2016/XI-XII-transform/","title":"Solu\u021bia problemei transform (ONI 2016, clasele XI-XII)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa XI-XII"]},{"location":"olimpiada/solutii/ONI/2016/XI-XII-transform/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa XI-XII"]},{"location":"olimpiada/solutii/ONI/2016/XI-XII-xor/","title":"Solu\u021bia problemei xor (ONI 2016, clasele XI-XII)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa XI-XII"]},{"location":"olimpiada/solutii/ONI/2016/XI-XII-xor/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa XI-XII"]},{"location":"olimpiada/solutii/ONI/2017/IX-adlic/","title":"Solu\u021bia problemei adlic (ONI 2017, clasa a IX-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa IX"]},{"location":"olimpiada/solutii/ONI/2017/IX-adlic/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa IX"]},{"location":"olimpiada/solutii/ONI/2017/IX-arhipelag/","title":"Solu\u021bia problemei arhipelag (ONI 2017, clasa a IX-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa IX"]},{"location":"olimpiada/solutii/ONI/2017/IX-arhipelag/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa IX"]},{"location":"olimpiada/solutii/ONI/2017/IX-bomboane/","title":"Solu\u021bia problemei bomboane (ONI 2017, clasa a IX-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa IX"]},{"location":"olimpiada/solutii/ONI/2017/IX-bomboane/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa IX"]},{"location":"olimpiada/solutii/ONI/2017/IX-mirror/","title":"Solu\u021bia problemei mirror (ONI 2017, clasa a IX-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa IX"]},{"location":"olimpiada/solutii/ONI/2017/IX-mirror/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa IX"]},{"location":"olimpiada/solutii/ONI/2017/IX-okcpp/","title":"Solu\u021bia problemei okcpp (ONI 2017, clasa a IX-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa IX"]},{"location":"olimpiada/solutii/ONI/2017/IX-okcpp/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa IX"]},{"location":"olimpiada/solutii/ONI/2017/IX-orase/","title":"Solu\u021bia problemei orase (ONI 2017, clasa a IX-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa IX"]},{"location":"olimpiada/solutii/ONI/2017/IX-orase/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa IX"]},{"location":"olimpiada/solutii/ONI/2017/V-prime/","title":"Solu\u021bia problemei prime (ONI 2017, clasa a V-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa V"]},{"location":"olimpiada/solutii/ONI/2017/V-prime/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa V"]},{"location":"olimpiada/solutii/ONI/2017/V-robot/","title":"Solu\u021bia problemei robot (ONI 2017, clasa a V-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa V"]},{"location":"olimpiada/solutii/ONI/2017/V-robot/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa V"]},{"location":"olimpiada/solutii/ONI/2017/V-roua/","title":"Solu\u021bia problemei roua (ONI 2017, clasa a V-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa V"]},{"location":"olimpiada/solutii/ONI/2017/V-roua/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa V"]},{"location":"olimpiada/solutii/ONI/2017/VI-faleza/","title":"Solu\u021bia problemei faleza (ONI 2017, clasa a VI-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa VI"]},{"location":"olimpiada/solutii/ONI/2017/VI-faleza/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa VI"]},{"location":"olimpiada/solutii/ONI/2017/VI-peste/","title":"Solu\u021bia problemei peste (ONI 2017, clasa a VI-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa VI"]},{"location":"olimpiada/solutii/ONI/2017/VI-peste/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa VI"]},{"location":"olimpiada/solutii/ONI/2017/VI-soricel/","title":"Solu\u021bia problemei soricel (ONI 2017, clasa a VI-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa VI"]},{"location":"olimpiada/solutii/ONI/2017/VI-soricel/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa VI"]},{"location":"olimpiada/solutii/ONI/2017/VII-carte/","title":"Solu\u021bia problemei carte (ONI 2017, clasa a VII-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa VII"]},{"location":"olimpiada/solutii/ONI/2017/VII-carte/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa VII"]},{"location":"olimpiada/solutii/ONI/2017/VII-ghinde/","title":"Solu\u021bia problemei ghinde (ONI 2017, clasa a VII-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa VII"]},{"location":"olimpiada/solutii/ONI/2017/VII-ghinde/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa VII"]},{"location":"olimpiada/solutii/ONI/2017/VII-submat/","title":"Solu\u021bia problemei submat (ONI 2017, clasa a VII-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa VII"]},{"location":"olimpiada/solutii/ONI/2017/VII-submat/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa VII"]},{"location":"olimpiada/solutii/ONI/2017/VIII-boats/","title":"Solu\u021bia problemei boats (ONI 2017, clasa a VIII-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa VIII"]},{"location":"olimpiada/solutii/ONI/2017/VIII-boats/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa VIII"]},{"location":"olimpiada/solutii/ONI/2017/VIII-doilan/","title":"Solu\u021bia problemei doilan (ONI 2017, clasa a VIII-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa VIII"]},{"location":"olimpiada/solutii/ONI/2017/VIII-doilan/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa VIII"]},{"location":"olimpiada/solutii/ONI/2017/VIII-z/","title":"Solu\u021bia problemei Z (ONI 2017, clasa a VIII-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa VIII"]},{"location":"olimpiada/solutii/ONI/2017/VIII-z/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa VIII"]},{"location":"olimpiada/solutii/ONI/2017/X-100m/","title":"Solu\u021bia problemei 100m (ONI 2017, clasa a X-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa X"]},{"location":"olimpiada/solutii/ONI/2017/X-100m/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa X"]},{"location":"olimpiada/solutii/ONI/2017/X-camp/","title":"Solu\u021bia problemei camp (ONI 2017, clasa a X-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa X"]},{"location":"olimpiada/solutii/ONI/2017/X-camp/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa X"]},{"location":"olimpiada/solutii/ONI/2017/X-identice/","title":"Solu\u021bia problemei identice (ONI 2017, clasa a X-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa X"]},{"location":"olimpiada/solutii/ONI/2017/X-identice/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa X"]},{"location":"olimpiada/solutii/ONI/2017/X-multisum/","title":"Solu\u021bia problemei multisum (ONI 2017, clasa a X-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa X"]},{"location":"olimpiada/solutii/ONI/2017/X-multisum/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa X"]},{"location":"olimpiada/solutii/ONI/2017/X-puzzle/","title":"Solu\u021bia problemei puzzle (ONI 2017, clasa a X-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa X"]},{"location":"olimpiada/solutii/ONI/2017/X-puzzle/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa X"]},{"location":"olimpiada/solutii/ONI/2017/X-taietura/","title":"Solu\u021bia problemei taietura (ONI 2017, clasa a X-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa X"]},{"location":"olimpiada/solutii/ONI/2017/X-taietura/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa X"]},{"location":"olimpiada/solutii/ONI/2017/XI-XII-bvarcolaci/","title":"Solu\u021bia problemei bvarcolaci (ONI 2017, clasele XI-XII)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa XI-XII"]},{"location":"olimpiada/solutii/ONI/2017/XI-XII-bvarcolaci/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa XI-XII"]},{"location":"olimpiada/solutii/ONI/2017/XI-XII-incurcatura/","title":"Solu\u021bia problemei incurcatura (ONI 2017, clasele XI-XII)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa XI-XII"]},{"location":"olimpiada/solutii/ONI/2017/XI-XII-incurcatura/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa XI-XII"]},{"location":"olimpiada/solutii/ONI/2017/XI-XII-minarea/","title":"Solu\u021bia problemei minarea (ONI 2017, clasele XI-XII)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa XI-XII"]},{"location":"olimpiada/solutii/ONI/2017/XI-XII-minarea/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa XI-XII"]},{"location":"olimpiada/solutii/ONI/2017/XI-XII-order/","title":"Solu\u021bia problemei order (ONI 2017, clasele XI-XII)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa XI-XII"]},{"location":"olimpiada/solutii/ONI/2017/XI-XII-order/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa XI-XII"]},{"location":"olimpiada/solutii/ONI/2017/XI-XII-startrek/","title":"Solu\u021bia problemei startrek (ONI 2017, clasele XI-XII)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa XI-XII"]},{"location":"olimpiada/solutii/ONI/2017/XI-XII-startrek/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa XI-XII"]},{"location":"olimpiada/solutii/ONI/2017/XI-XII-tris/","title":"Solu\u021bia problemei tris (ONI 2017, clasele XI-XII)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa XI-XII"]},{"location":"olimpiada/solutii/ONI/2017/XI-XII-tris/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa XI-XII"]},{"location":"olimpiada/solutii/ONI/2018/IX-bazaf/","title":"Solu\u021bia problemei bazaf (ONI 2018, clasa a IX-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa IX"]},{"location":"olimpiada/solutii/ONI/2018/IX-bazaf/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa IX"]},{"location":"olimpiada/solutii/ONI/2018/IX-bsrec/","title":"Solu\u021bia problemei bsrec (ONI 2018, clasa a IX-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa IX"]},{"location":"olimpiada/solutii/ONI/2018/IX-bsrec/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa IX"]},{"location":"olimpiada/solutii/ONI/2018/IX-mexitate/","title":"Solu\u021bia problemei mexitate (ONI 2018, clasa a IX-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa IX"]},{"location":"olimpiada/solutii/ONI/2018/IX-mexitate/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa IX"]},{"location":"olimpiada/solutii/ONI/2018/IX-numinum/","title":"Solu\u021bia problemei numinum (ONI 2018, clasa a IX-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa IX"]},{"location":"olimpiada/solutii/ONI/2018/IX-numinum/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa IX"]},{"location":"olimpiada/solutii/ONI/2018/IX-plaja/","title":"Solu\u021bia problemei plaja (ONI 2018, clasa a IX-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa IX"]},{"location":"olimpiada/solutii/ONI/2018/IX-plaja/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa IX"]},{"location":"olimpiada/solutii/ONI/2018/IX-rosiimici/","title":"Solu\u021bia problemei ro\u0219ii mici (ONI 2018, clasa a IX-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa IX"]},{"location":"olimpiada/solutii/ONI/2018/IX-rosiimici/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa IX"]},{"location":"olimpiada/solutii/ONI/2018/V-desen/","title":"Solu\u021bia problemei desen (ONI 2018, clasa a V-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa V"]},{"location":"olimpiada/solutii/ONI/2018/V-desen/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa V"]},{"location":"olimpiada/solutii/ONI/2018/V-mostenire/","title":"Solu\u021bia problemei mostenire (ONI 2018, clasa a V-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa V"]},{"location":"olimpiada/solutii/ONI/2018/V-mostenire/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa V"]},{"location":"olimpiada/solutii/ONI/2018/V-pyk/","title":"Solu\u021bia problemei pyk (ONI 2018, clasa a V-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa V"]},{"location":"olimpiada/solutii/ONI/2018/V-pyk/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa V"]},{"location":"olimpiada/solutii/ONI/2018/VI-descmult/","title":"Solu\u021bia problemei descmult (ONI 2018, clasa a VI-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa VI"]},{"location":"olimpiada/solutii/ONI/2018/VI-descmult/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa VI"]},{"location":"olimpiada/solutii/ONI/2018/VI-gazon/","title":"Solu\u021bia problemei gazon (ONI 2018, clasa a VI-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa VI"]},{"location":"olimpiada/solutii/ONI/2018/VI-gazon/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa VI"]},{"location":"olimpiada/solutii/ONI/2018/VI-pietre/","title":"Solu\u021bia problemei pietre (ONI 2018, clasa a VI-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa VI"]},{"location":"olimpiada/solutii/ONI/2018/VI-pietre/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa VI"]},{"location":"olimpiada/solutii/ONI/2018/VII-evip/","title":"Solu\u021bia problemei evip (ONI 2018, clasa a VII-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa VII"]},{"location":"olimpiada/solutii/ONI/2018/VII-evip/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa VII"]},{"location":"olimpiada/solutii/ONI/2018/VII-nxy/","title":"Solu\u021bia problemei nxy (ONI 2018, clasa a VII-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa VII"]},{"location":"olimpiada/solutii/ONI/2018/VII-nxy/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa VII"]},{"location":"olimpiada/solutii/ONI/2018/VII-viitor/","title":"Solu\u021bia problemei viitor (ONI 2018, clasa a VII-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa VII"]},{"location":"olimpiada/solutii/ONI/2018/VII-viitor/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa VII"]},{"location":"olimpiada/solutii/ONI/2018/VIII-gene/","title":"Solu\u021bia problemei gene (ONI 2018, clasa a VIII-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa VIII"]},{"location":"olimpiada/solutii/ONI/2018/VIII-gene/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa VIII"]},{"location":"olimpiada/solutii/ONI/2018/VIII-jocxzero/","title":"Solu\u021bia problemei jocxzero (ONI 2018, clasa a VIII-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa VIII"]},{"location":"olimpiada/solutii/ONI/2018/VIII-jocxzero/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa VIII"]},{"location":"olimpiada/solutii/ONI/2018/VIII-laser/","title":"Solu\u021bia problemei laser (ONI 2018, clasa a VIII-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa VIII"]},{"location":"olimpiada/solutii/ONI/2018/VIII-laser/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa VIII"]},{"location":"olimpiada/solutii/ONI/2018/X-agora/","title":"Solu\u021bia problemei agora (ONI 2018, clasa a X-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa X"]},{"location":"olimpiada/solutii/ONI/2018/X-agora/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa X"]},{"location":"olimpiada/solutii/ONI/2018/X-anagrame/","title":"Solu\u021bia problemei anagrame (ONI 2018, clasa a X-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa X"]},{"location":"olimpiada/solutii/ONI/2018/X-anagrame/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa X"]},{"location":"olimpiada/solutii/ONI/2018/X-grup/","title":"Solu\u021bia problemei grup (ONI 2018, clasa a X-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa X"]},{"location":"olimpiada/solutii/ONI/2018/X-grup/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa X"]},{"location":"olimpiada/solutii/ONI/2018/X-multimi/","title":"Solu\u021bia problemei multimi (ONI 2018, clasa a X-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa X"]},{"location":"olimpiada/solutii/ONI/2018/X-multimi/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa X"]},{"location":"olimpiada/solutii/ONI/2018/X-proiectoare/","title":"Solu\u021bia problemei Proiectoare (ONI 2018, clasa a X-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa X"]},{"location":"olimpiada/solutii/ONI/2018/X-proiectoare/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa X"]},{"location":"olimpiada/solutii/ONI/2018/X-siruri/","title":"Solu\u021bia problemei \u0218iruri (ONI 2018, clasa a X-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa X"]},{"location":"olimpiada/solutii/ONI/2018/X-siruri/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa X"]},{"location":"olimpiada/solutii/ONI/2018/XI-XII-antivirus/","title":"Solu\u021bia problemei antivirus (ONI 2018, clasele XI-XII)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa XI-XII"]},{"location":"olimpiada/solutii/ONI/2018/XI-XII-antivirus/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa XI-XII"]},{"location":"olimpiada/solutii/ONI/2018/XI-XII-aranjare/","title":"Solu\u021bia problemei aranjare (ONI 2018, clasele XI-XII)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa XI-XII"]},{"location":"olimpiada/solutii/ONI/2018/XI-XII-aranjare/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa XI-XII"]},{"location":"olimpiada/solutii/ONI/2018/XI-XII-dungeon/","title":"Solu\u021bia problemei dungeon (ONI 2018, clasele XI-XII)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa XI-XII"]},{"location":"olimpiada/solutii/ONI/2018/XI-XII-dungeon/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa XI-XII"]},{"location":"olimpiada/solutii/ONI/2018/XI-XII-poligon/","title":"Solu\u021bia problemei poligon (ONI 2018, clasele XI-XII)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa XI-XII"]},{"location":"olimpiada/solutii/ONI/2018/XI-XII-poligon/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa XI-XII"]},{"location":"olimpiada/solutii/ONI/2018/XI-XII-tricolor/","title":"Solu\u021bia problemei tricolor (ONI 2018, clasele XI-XII)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa XI-XII"]},{"location":"olimpiada/solutii/ONI/2018/XI-XII-tricolor/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa XI-XII"]},{"location":"olimpiada/solutii/ONI/2018/XI-XII-zuma/","title":"Solu\u021bia problemei zuma (ONI 2018, clasele XI-XII)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa XI-XII"]},{"location":"olimpiada/solutii/ONI/2018/XI-XII-zuma/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa XI-XII"]},{"location":"olimpiada/solutii/ONI/2019/IX-amat/","title":"Solu\u021bia problemei amat (ONI 2019, clasa a IX-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa IX"]},{"location":"olimpiada/solutii/ONI/2019/IX-amat/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa IX"]},{"location":"olimpiada/solutii/ONI/2019/IX-comun/","title":"Solu\u021bia problemei comun (ONI 2019, clasa a IX-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa IX"]},{"location":"olimpiada/solutii/ONI/2019/IX-comun/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa IX"]},{"location":"olimpiada/solutii/ONI/2019/IX-cub/","title":"Solu\u021bia problemei cub (ONI 2019, clasa a IX-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa IX"]},{"location":"olimpiada/solutii/ONI/2019/IX-cub/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa IX"]},{"location":"olimpiada/solutii/ONI/2019/IX-fibofrac/","title":"Solu\u021bia problemei fibofrac (ONI 2019, clasa a IX-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa IX"]},{"location":"olimpiada/solutii/ONI/2019/IX-fibofrac/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa IX"]},{"location":"olimpiada/solutii/ONI/2019/IX-pro3/","title":"Solu\u021bia problemei pro3 (ONI 2019, clasa a IX-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa IX"]},{"location":"olimpiada/solutii/ONI/2019/IX-pro3/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa IX"]},{"location":"olimpiada/solutii/ONI/2019/IX-telefon/","title":"Solu\u021bia problemei telefon (ONI 2019, clasa a IX-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa IX"]},{"location":"olimpiada/solutii/ONI/2019/IX-telefon/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa IX"]},{"location":"olimpiada/solutii/ONI/2019/V-copii/","title":"Solu\u021bia problemei copii (ONI 2019, clasa a V-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa V"]},{"location":"olimpiada/solutii/ONI/2019/V-copii/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa V"]},{"location":"olimpiada/solutii/ONI/2019/V-numere/","title":"Solu\u021bia problemei numere (ONI 2019, clasa a V-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa V"]},{"location":"olimpiada/solutii/ONI/2019/V-numere/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa V"]},{"location":"olimpiada/solutii/ONI/2019/V-trio/","title":"Solu\u021bia problemei trio (ONI 2019, clasa a V-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa V"]},{"location":"olimpiada/solutii/ONI/2019/V-trio/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa V"]},{"location":"olimpiada/solutii/ONI/2019/VI-maya/","title":"Solu\u021bia problemei maya (ONI 2019, clasa a VI-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa VI"]},{"location":"olimpiada/solutii/ONI/2019/VI-maya/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa VI"]},{"location":"olimpiada/solutii/ONI/2019/VI-optime/","title":"Solu\u021bia problemei optime (ONI 2019, clasa a VI-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa VI"]},{"location":"olimpiada/solutii/ONI/2019/VI-optime/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa VI"]},{"location":"olimpiada/solutii/ONI/2019/VI-roata/","title":"Solu\u021bia problemei roata (ONI 2019, clasa a VI-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa VI"]},{"location":"olimpiada/solutii/ONI/2019/VI-roata/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa VI"]},{"location":"olimpiada/solutii/ONI/2019/VII-domino/","title":"Solu\u021bia problemei domino (ONI 2019, clasa a VII-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa VII"]},{"location":"olimpiada/solutii/ONI/2019/VII-domino/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa VII"]},{"location":"olimpiada/solutii/ONI/2019/VII-tuburi/","title":"Solu\u021bia problemei tuburi (ONI 2019, clasa a VII-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa VII"]},{"location":"olimpiada/solutii/ONI/2019/VII-tuburi/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa VII"]},{"location":"olimpiada/solutii/ONI/2019/VII-venus/","title":"Solu\u021bia problemei venus (ONI 2019, clasa a VII-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa VII"]},{"location":"olimpiada/solutii/ONI/2019/VII-venus/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa VII"]},{"location":"olimpiada/solutii/ONI/2019/VIII-criptografie/","title":"Solu\u021bia problemei criptografie (ONI 2019, clasa a VIII-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa VIII"]},{"location":"olimpiada/solutii/ONI/2019/VIII-criptografie/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa VIII"]},{"location":"olimpiada/solutii/ONI/2019/VIII-drept/","title":"Solu\u021bia problemei drept (ONI 2019, clasa a VIII-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa VIII"]},{"location":"olimpiada/solutii/ONI/2019/VIII-drept/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa VIII"]},{"location":"olimpiada/solutii/ONI/2019/VIII-lumini/","title":"Solu\u021bia problemei lumini (ONI 2019, clasa a VIII-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa VIII"]},{"location":"olimpiada/solutii/ONI/2019/VIII-lumini/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa VIII"]},{"location":"olimpiada/solutii/ONI/2019/X-artifact/","title":"Solu\u021bia problemei artifact (ONI 2019, clasa a X-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa X"]},{"location":"olimpiada/solutii/ONI/2019/X-artifact/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa X"]},{"location":"olimpiada/solutii/ONI/2019/X-nozero/","title":"Solu\u021bia problemei nozero (ONI 2019, clasa a X-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa X"]},{"location":"olimpiada/solutii/ONI/2019/X-nozero/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa X"]},{"location":"olimpiada/solutii/ONI/2019/X-pericol/","title":"Solu\u021bia problemei pericol (ONI 2019, clasa a X-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa X"]},{"location":"olimpiada/solutii/ONI/2019/X-pericol/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa X"]},{"location":"olimpiada/solutii/ONI/2019/X-scara/","title":"Solu\u021bia problemei scara (ONI 2019, clasa a X-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa X"]},{"location":"olimpiada/solutii/ONI/2019/X-scara/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa X"]},{"location":"olimpiada/solutii/ONI/2019/X-vip/","title":"Solu\u021bia problemei vip (ONI 2019, clasa a X-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa X"]},{"location":"olimpiada/solutii/ONI/2019/X-vip/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa X"]},{"location":"olimpiada/solutii/ONI/2019/X-walle/","title":"Solu\u021bia problemei walle (ONI 2019, clasa a X-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa X"]},{"location":"olimpiada/solutii/ONI/2019/X-walle/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa X"]},{"location":"olimpiada/solutii/ONI/2019/XI-XII-compact/","title":"Solu\u021bia problemei compact (ONI 2019, clasele XI-XII)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa XI-XII"]},{"location":"olimpiada/solutii/ONI/2019/XI-XII-compact/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa XI-XII"]},{"location":"olimpiada/solutii/ONI/2019/XI-XII-hipersimetrie/","title":"Solu\u021bia problemei hipersimetrie (ONI 2019, clasele XI-XII)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa XI-XII"]},{"location":"olimpiada/solutii/ONI/2019/XI-XII-hipersimetrie/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa XI-XII"]},{"location":"olimpiada/solutii/ONI/2019/XI-XII-lexicografic/","title":"Solu\u021bia problemei lexicografic (ONI 2019, clasele XI-XII)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa XI-XII"]},{"location":"olimpiada/solutii/ONI/2019/XI-XII-lexicografic/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa XI-XII"]},{"location":"olimpiada/solutii/ONI/2019/XI-XII-linegraph/","title":"Solu\u021bia problemei linegraph (ONI 2019, clasele XI-XII)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa XI-XII"]},{"location":"olimpiada/solutii/ONI/2019/XI-XII-linegraph/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa XI-XII"]},{"location":"olimpiada/solutii/ONI/2019/XI-XII-oracol/","title":"Solu\u021bia problemei oracol (ONI 2019, clasele XI-XII)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa XI-XII"]},{"location":"olimpiada/solutii/ONI/2019/XI-XII-oracol/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa XI-XII"]},{"location":"olimpiada/solutii/ONI/2019/XI-XII-treegcd/","title":"Solu\u021bia problemei TreeGCD (ONI 2019, clasele XI-XII)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa XI-XII"]},{"location":"olimpiada/solutii/ONI/2019/XI-XII-treegcd/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa XI-XII"]},{"location":"olimpiada/solutii/ONI/2021/IX-elhc/","title":"Solu\u021bia problemei ELHC (ONI 2021, clasa a IX-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa IX"]},{"location":"olimpiada/solutii/ONI/2021/IX-elhc/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa IX"]},{"location":"olimpiada/solutii/ONI/2021/IX-lemans/","title":"Solu\u021bia problemei lemans (ONI 2021, clasa a IX-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa IX"]},{"location":"olimpiada/solutii/ONI/2021/IX-lemans/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa IX"]},{"location":"olimpiada/solutii/ONI/2021/IX-oposumi/","title":"Solu\u021bia problemei oposumi (ONI 2021, clasa a IX-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa IX"]},{"location":"olimpiada/solutii/ONI/2021/IX-oposumi/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa IX"]},{"location":"olimpiada/solutii/ONI/2021/V-iepuras/","title":"Solu\u021bia problemei iepuras (ONI 2021, clasa a V-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa V"]},{"location":"olimpiada/solutii/ONI/2021/V-iepuras/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa V"]},{"location":"olimpiada/solutii/ONI/2021/V-ktlon/","title":"Solu\u021bia problemei ktlon (ONI 2021, clasa a V-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa V"]},{"location":"olimpiada/solutii/ONI/2021/V-ktlon/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa V"]},{"location":"olimpiada/solutii/ONI/2021/V-taieri/","title":"Solu\u021bia problemei taieri (ONI 2021, clasa a V-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa V"]},{"location":"olimpiada/solutii/ONI/2021/V-taieri/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa V"]},{"location":"olimpiada/solutii/ONI/2021/VI-butoi/","title":"Solu\u021bia problemei butoi (ONI 2021, clasa a VI-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa VI"]},{"location":"olimpiada/solutii/ONI/2021/VI-butoi/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa VI"]},{"location":"olimpiada/solutii/ONI/2021/VI-pasari/","title":"Solu\u021bia problemei pasari (ONI 2021, clasa a VI-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa VI"]},{"location":"olimpiada/solutii/ONI/2021/VI-pasari/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa VI"]},{"location":"olimpiada/solutii/ONI/2021/VI-puternic/","title":"Solu\u021bia problemei puternic (ONI 2021, clasa a VI-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa VI"]},{"location":"olimpiada/solutii/ONI/2021/VI-puternic/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa VI"]},{"location":"olimpiada/solutii/ONI/2021/VII-cat2pal/","title":"Solu\u021bia problemei cat2pal (ONI 2021, clasa a VII-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa VII"]},{"location":"olimpiada/solutii/ONI/2021/VII-cat2pal/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa VII"]},{"location":"olimpiada/solutii/ONI/2021/VII-virus/","title":"Solu\u021bia problemei virus (ONI 2021, clasa a VII-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa VII"]},{"location":"olimpiada/solutii/ONI/2021/VII-virus/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa VII"]},{"location":"olimpiada/solutii/ONI/2021/VII-zid/","title":"Solu\u021bia problemei Zid (ONI 2021, clasa a VII-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa VII"]},{"location":"olimpiada/solutii/ONI/2021/VII-zid/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa VII"]},{"location":"olimpiada/solutii/ONI/2021/VIII-bile/","title":"Solu\u021bia problemei bile (ONI 2021, clasa a VIII-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa VIII"]},{"location":"olimpiada/solutii/ONI/2021/VIII-bile/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa VIII"]},{"location":"olimpiada/solutii/ONI/2021/VIII-secvente/","title":"Solu\u021bia problemei secvente (ONI 2021, clasa a VIII-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa VIII"]},{"location":"olimpiada/solutii/ONI/2021/VIII-secvente/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa VIII"]},{"location":"olimpiada/solutii/ONI/2021/VIII-valoare/","title":"Solu\u021bia problemei valoare (ONI 2021, clasa a VIII-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa VIII"]},{"location":"olimpiada/solutii/ONI/2021/VIII-valoare/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa VIII"]},{"location":"olimpiada/solutii/ONI/2021/X-cvintete/","title":"Solu\u021bia problemei cvintete (ONI 2021, clasa a X-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa X"]},{"location":"olimpiada/solutii/ONI/2021/X-cvintete/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa X"]},{"location":"olimpiada/solutii/ONI/2021/X-expresii/","title":"Solu\u021bia problemei expresii (ONI 2021, clasa a X-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa X"]},{"location":"olimpiada/solutii/ONI/2021/X-expresii/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa X"]},{"location":"olimpiada/solutii/ONI/2021/X-primar/","title":"Solu\u021bia problemei primar (ONI 2021, clasa a X-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa X"]},{"location":"olimpiada/solutii/ONI/2021/X-primar/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa X"]},{"location":"olimpiada/solutii/ONI/2021/XI-XII-bisortare/","title":"Solu\u021bia problemei bisortare (ONI 2021, clasele XI-XII)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa XI-XII"]},{"location":"olimpiada/solutii/ONI/2021/XI-XII-bisortare/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa XI-XII"]},{"location":"olimpiada/solutii/ONI/2021/XI-XII-cuvinte/","title":"Solu\u021bia problemei cuvinte (ONI 2021, clasele XI-XII)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa XI-XII"]},{"location":"olimpiada/solutii/ONI/2021/XI-XII-cuvinte/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa XI-XII"]},{"location":"olimpiada/solutii/ONI/2021/XI-XII-saseg/","title":"Solu\u021bia problemei SaseG (ONI 2021, clasele XI-XII)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa XI-XII"]},{"location":"olimpiada/solutii/ONI/2021/XI-XII-saseg/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa XI-XII"]},{"location":"olimpiada/solutii/ONI/2022/IX-colibri/","title":"Solu\u021bia problemei colibri (ONI 2022, clasa a IX-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa IX"]},{"location":"olimpiada/solutii/ONI/2022/IX-colibri/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa IX"]},{"location":"olimpiada/solutii/ONI/2022/IX-geogra/","title":"Solu\u021bia problemei geogra (ONI 2022, clasa a IX-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa IX"]},{"location":"olimpiada/solutii/ONI/2022/IX-geogra/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa IX"]},{"location":"olimpiada/solutii/ONI/2022/IX-schi/","title":"Solu\u021bia problemei schi (ONI 2022, clasa a IX-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa IX"]},{"location":"olimpiada/solutii/ONI/2022/IX-schi/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa IX"]},{"location":"olimpiada/solutii/ONI/2022/V-culori/","title":"Solu\u021bia problemei culori (ONI 2022, clasa a V-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa V"]},{"location":"olimpiada/solutii/ONI/2022/V-culori/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa V"]},{"location":"olimpiada/solutii/ONI/2022/V-joc/","title":"Solu\u021bia problemei joc (ONI 2022, clasa a V-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa V"]},{"location":"olimpiada/solutii/ONI/2022/V-joc/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa V"]},{"location":"olimpiada/solutii/ONI/2022/V-rotire25/","title":"Solu\u021bia problemei rotire25 (ONI 2022, clasa a V-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa V"]},{"location":"olimpiada/solutii/ONI/2022/V-rotire25/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa V"]},{"location":"olimpiada/solutii/ONI/2022/VI-iluminat/","title":"Solu\u021bia problemei iluminat (ONI 2022, clasa a VI-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa VI"]},{"location":"olimpiada/solutii/ONI/2022/VI-iluminat/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa VI"]},{"location":"olimpiada/solutii/ONI/2022/VI-inundatie/","title":"Solu\u021bia problemei inundatie (ONI 2022, clasa a VI-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa VI"]},{"location":"olimpiada/solutii/ONI/2022/VI-inundatie/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa VI"]},{"location":"olimpiada/solutii/ONI/2022/VI-siruri/","title":"Solu\u021bia problemei siruri (ONI 2022, clasa a VI-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa VI"]},{"location":"olimpiada/solutii/ONI/2022/VI-siruri/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa VI"]},{"location":"olimpiada/solutii/ONI/2022/VII-microbuz/","title":"Solu\u021bia problemei microbuz (ONI 2022, clasa a VII-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa VII"]},{"location":"olimpiada/solutii/ONI/2022/VII-microbuz/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa VII"]},{"location":"olimpiada/solutii/ONI/2022/VII-raza/","title":"Solu\u021bia problemei raza (ONI 2022, clasa a VII-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa VII"]},{"location":"olimpiada/solutii/ONI/2022/VII-raza/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa VII"]},{"location":"olimpiada/solutii/ONI/2022/VII-text/","title":"Solu\u021bia problemei text (ONI 2022, clasa a VII-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa VII"]},{"location":"olimpiada/solutii/ONI/2022/VII-text/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa VII"]},{"location":"olimpiada/solutii/ONI/2022/VIII-proeminenta/","title":"Solu\u021bia problemei proeminenta (ONI 2022, clasa a VIII-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa VIII"]},{"location":"olimpiada/solutii/ONI/2022/VIII-proeminenta/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa VIII"]},{"location":"olimpiada/solutii/ONI/2022/VIII-rgb/","title":"Solu\u021bia problemei rgb (ONI 2022, clasa a VIII-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa VIII"]},{"location":"olimpiada/solutii/ONI/2022/VIII-rgb/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa VIII"]},{"location":"olimpiada/solutii/ONI/2022/VIII-subsir/","title":"Solu\u021bia problemei subsir (ONI 2022, clasa a VIII-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa VIII"]},{"location":"olimpiada/solutii/ONI/2022/VIII-subsir/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa VIII"]},{"location":"olimpiada/solutii/ONI/2022/X-changemin/","title":"Solu\u021bia problemei changemin (ONI 2022, clasa a X-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa X"]},{"location":"olimpiada/solutii/ONI/2022/X-changemin/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa X"]},{"location":"olimpiada/solutii/ONI/2022/X-dragonfruit/","title":"Solu\u021bia problemei dragonfruit (ONI 2022, clasa a X-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa X"]},{"location":"olimpiada/solutii/ONI/2022/X-dragonfruit/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa X"]},{"location":"olimpiada/solutii/ONI/2022/X-munte/","title":"Solu\u021bia problemei munte (ONI 2022, clasa a X-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa X"]},{"location":"olimpiada/solutii/ONI/2022/X-munte/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa X"]},{"location":"olimpiada/solutii/ONI/2022/XI-XII-lupusor/","title":"Solu\u021bia problemei lupusor (ONI 2022, clasele XI-XII)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa XI-XII"]},{"location":"olimpiada/solutii/ONI/2022/XI-XII-lupusor/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa XI-XII"]},{"location":"olimpiada/solutii/ONI/2022/XI-XII-regate/","title":"Solu\u021bia problemei regate (ONI 2022, clasele XI-XII)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa XI-XII"]},{"location":"olimpiada/solutii/ONI/2022/XI-XII-regate/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa XI-XII"]},{"location":"olimpiada/solutii/ONI/2022/XI-XII-schema/","title":"Solu\u021bia problemei schema (ONI 2022, clasele XI-XII)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa XI-XII"]},{"location":"olimpiada/solutii/ONI/2022/XI-XII-schema/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa XI-XII"]},{"location":"olimpiada/solutii/ONI/2023/IX-bolovani/","title":"Solu\u021bia problemei bolovani (ONI 2023, clasa a IX-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa IX"]},{"location":"olimpiada/solutii/ONI/2023/IX-bolovani/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa IX"]},{"location":"olimpiada/solutii/ONI/2023/IX-nisip/","title":"Solu\u021bia problemei nisip (ONI 2023, clasa a IX-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa IX"]},{"location":"olimpiada/solutii/ONI/2023/IX-nisip/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa IX"]},{"location":"olimpiada/solutii/ONI/2023/IX-pietricele/","title":"Solu\u021bia problemei pietricele (ONI 2023, clasa a IX-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa IX"]},{"location":"olimpiada/solutii/ONI/2023/IX-pietricele/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa IX"]},{"location":"olimpiada/solutii/ONI/2023/V-cadouri/","title":"Solu\u021bia problemei cadouri (ONI 2023, clasa a V-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa V"]},{"location":"olimpiada/solutii/ONI/2023/V-cadouri/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa V"]},{"location":"olimpiada/solutii/ONI/2023/V-legos/","title":"Solu\u021bia problemei legos (ONI 2023, clasa a V-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa V"]},{"location":"olimpiada/solutii/ONI/2023/V-legos/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa V"]},{"location":"olimpiada/solutii/ONI/2023/V-patinaj/","title":"Solu\u021bia problemei patinaj (ONI 2023, clasa a V-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa V"]},{"location":"olimpiada/solutii/ONI/2023/V-patinaj/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa V"]},{"location":"olimpiada/solutii/ONI/2023/VI-balon/","title":"Solu\u021bia problemei balon (ONI 2023, clasa a VI-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa VI"]},{"location":"olimpiada/solutii/ONI/2023/VI-balon/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa VI"]},{"location":"olimpiada/solutii/ONI/2023/VI-magictrick/","title":"Solu\u021bia problemei magictrick (ONI 2023, clasa a VI-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa VI"]},{"location":"olimpiada/solutii/ONI/2023/VI-magictrick/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa VI"]},{"location":"olimpiada/solutii/ONI/2023/VI-puteri3/","title":"Solu\u021bia problemei puteri3 (ONI 2023, clasa a VI-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa VI"]},{"location":"olimpiada/solutii/ONI/2023/VI-puteri3/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa VI"]},{"location":"olimpiada/solutii/ONI/2023/VII-dominew/","title":"Solu\u021bia problemei dominew (ONI 2023, clasa a VII-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa VII"]},{"location":"olimpiada/solutii/ONI/2023/VII-dominew/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa VII"]},{"location":"olimpiada/solutii/ONI/2023/VII-pix/","title":"Solu\u021bia problemei pix (ONI 2023, clasa a VII-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa VII"]},{"location":"olimpiada/solutii/ONI/2023/VII-pix/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa VII"]},{"location":"olimpiada/solutii/ONI/2023/VII-secvmin/","title":"Solu\u021bia problemei secvmin (ONI 2023, clasa a VII-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa VII"]},{"location":"olimpiada/solutii/ONI/2023/VII-secvmin/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa VII"]},{"location":"olimpiada/solutii/ONI/2023/VIII-castel/","title":"Solu\u021bia problemei castel (ONI 2023, clasa a VIII-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa VIII"]},{"location":"olimpiada/solutii/ONI/2023/VIII-castel/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa VIII"]},{"location":"olimpiada/solutii/ONI/2023/VIII-kth/","title":"Solu\u021bia problemei kth (ONI 2023, clasa a VIII-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa VIII"]},{"location":"olimpiada/solutii/ONI/2023/VIII-kth/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa VIII"]},{"location":"olimpiada/solutii/ONI/2023/VIII-struguri/","title":"Solu\u021bia problemei struguri (ONI 2023, clasa a VIII-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa VIII"]},{"location":"olimpiada/solutii/ONI/2023/VIII-struguri/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa VIII"]},{"location":"olimpiada/solutii/ONI/2023/X-arcade/","title":"Solu\u021bia problemei arcade (ONI 2023, clasa a X-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa X"]},{"location":"olimpiada/solutii/ONI/2023/X-arcade/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa X"]},{"location":"olimpiada/solutii/ONI/2023/X-comun/","title":"Solu\u021bia problemei comun (ONI 2023, clasa a X-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa X"]},{"location":"olimpiada/solutii/ONI/2023/X-comun/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa X"]},{"location":"olimpiada/solutii/ONI/2023/X-matrice/","title":"Solu\u021bia problemei matrice (ONI 2023, clasa a X-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa X"]},{"location":"olimpiada/solutii/ONI/2023/X-matrice/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa X"]},{"location":"olimpiada/solutii/ONI/2023/XI-XII-biom/","title":"Solu\u021bia problemei biom (ONI 2023, clasele XI-XII)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa XI-XII"]},{"location":"olimpiada/solutii/ONI/2023/XI-XII-biom/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa XI-XII"]},{"location":"olimpiada/solutii/ONI/2023/XI-XII-keidei/","title":"Solu\u021bia problemei keidei (ONI 2023, clasele XI-XII)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa XI-XII"]},{"location":"olimpiada/solutii/ONI/2023/XI-XII-keidei/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa XI-XII"]},{"location":"olimpiada/solutii/ONI/2023/XI-XII-xidartros/","title":"Solu\u021bia problemei xidartros (ONI 2023, clasele XI-XII)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa XI-XII"]},{"location":"olimpiada/solutii/ONI/2023/XI-XII-xidartros/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa XI-XII"]},{"location":"olimpiada/solutii/ONI/2024/IX-apgreid/","title":"Solu\u021bia problemei Apgreid (ONI 2024, clasa a IX-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa IX"]},{"location":"olimpiada/solutii/ONI/2024/IX-apgreid/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa IX"]},{"location":"olimpiada/solutii/ONI/2024/IX-eras/","title":"Solu\u021bia problemei Eras (ONI 2024, clasa a IX-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa IX"]},{"location":"olimpiada/solutii/ONI/2024/IX-eras/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa IX"]},{"location":"olimpiada/solutii/ONI/2024/IX-spirala/","title":"Solu\u021bia problemei Spirala (ONI 2024, clasa a IX-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa IX"]},{"location":"olimpiada/solutii/ONI/2024/IX-spirala/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa IX"]},{"location":"olimpiada/solutii/ONI/2024/V-p13/","title":"Solu\u021bia problemei p13 (ONI 2024, clasa a V-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa V"]},{"location":"olimpiada/solutii/ONI/2024/V-p13/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa V"]},{"location":"olimpiada/solutii/ONI/2024/V-puzzle/","title":"Solu\u021bia problemei puzzle (ONI 2024, clasa a V-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa V"]},{"location":"olimpiada/solutii/ONI/2024/V-puzzle/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa V"]},{"location":"olimpiada/solutii/ONI/2024/V-robinhood/","title":"Solu\u021bia problemei robinhood (ONI 2024, clasa a V-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa V"]},{"location":"olimpiada/solutii/ONI/2024/V-robinhood/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa V"]},{"location":"olimpiada/solutii/ONI/2024/VI-codificare/","title":"Solu\u021bia problemei codificare (ONI 2024, clasa a VI-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa VI"]},{"location":"olimpiada/solutii/ONI/2024/VI-codificare/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa VI"]},{"location":"olimpiada/solutii/ONI/2024/VI-esm/","title":"Solu\u021bia problemei esm (ONI 2024, clasa a VI-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa VI"]},{"location":"olimpiada/solutii/ONI/2024/VI-esm/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa VI"]},{"location":"olimpiada/solutii/ONI/2024/VI-sim/","title":"Solu\u021bia problemei sim (ONI 2024, clasa a VI-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa VI"]},{"location":"olimpiada/solutii/ONI/2024/VI-sim/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa VI"]},{"location":"olimpiada/solutii/ONI/2024/VII-expresie/","title":"Solu\u021bia problemei expresie (ONI 2024, clasa a VII-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa VII"]},{"location":"olimpiada/solutii/ONI/2024/VII-expresie/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa VII"]},{"location":"olimpiada/solutii/ONI/2024/VII-pictura/","title":"Solu\u021bia problemei pictura (ONI 2024, clasa a VII-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa VII"]},{"location":"olimpiada/solutii/ONI/2024/VII-pictura/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa VII"]},{"location":"olimpiada/solutii/ONI/2024/VII-secv9/","title":"Solu\u021bia problemei secv9 (ONI 2024, clasa a VII-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa VII"]},{"location":"olimpiada/solutii/ONI/2024/VII-secv9/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa VII"]},{"location":"olimpiada/solutii/ONI/2024/VIII-geologie/","title":"Solu\u021bia problemei geologie (ONI 2024, clasa a VIII-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa VIII"]},{"location":"olimpiada/solutii/ONI/2024/VIII-geologie/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa VIII"]},{"location":"olimpiada/solutii/ONI/2024/VIII-kmajo/","title":"Solu\u021bia problemei kmajo (ONI 2024, clasa a VIII-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa VIII"]},{"location":"olimpiada/solutii/ONI/2024/VIII-kmajo/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa VIII"]},{"location":"olimpiada/solutii/ONI/2024/VIII-mandms/","title":"Solu\u021bia problemei M and Ms (ONI 2024, clasa a VIII-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa VIII"]},{"location":"olimpiada/solutii/ONI/2024/VIII-mandms/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa VIII"]},{"location":"olimpiada/solutii/ONI/2024/X-dominoes/","title":"Solu\u021bia problemei Dominoes (ONI 2024, clasa a X-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa X"]},{"location":"olimpiada/solutii/ONI/2024/X-dominoes/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa X"]},{"location":"olimpiada/solutii/ONI/2024/X-seqstr/","title":"Solu\u021bia problemei Seqstr (ONI 2024, clasa a X-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa X"]},{"location":"olimpiada/solutii/ONI/2024/X-seqstr/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa X"]},{"location":"olimpiada/solutii/ONI/2024/X-teze/","title":"Solu\u021bia problemei Teze (ONI 2024, clasa a X-a)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa X"]},{"location":"olimpiada/solutii/ONI/2024/X-teze/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa X"]},{"location":"olimpiada/solutii/ONI/2024/XI-XII-arbore/","title":"Solu\u021bia problemei Arbore (ONI 2024, clasele XI-XII)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa XI-XII"]},{"location":"olimpiada/solutii/ONI/2024/XI-XII-arbore/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa XI-XII"]},{"location":"olimpiada/solutii/ONI/2024/XI-XII-detonator/","title":"Solu\u021bia problemei Detonator (ONI 2024, clasele XI-XII)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa XI-XII"]},{"location":"olimpiada/solutii/ONI/2024/XI-XII-detonator/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa XI-XII"]},{"location":"olimpiada/solutii/ONI/2024/XI-XII-zid/","title":"Solu\u021bia problemei Zid (ONI 2024, clasele XI-XII)","text":"<p>Articolul va fi disponibil cur\u00e2nd \u00een arhiv\u0103.</p> <p>P\u00e2n\u0103 atunci, editorialul poate fi accesat \u00een repo-ul nostru de GitHub, linkul fiind acesta.</p>","tags":["ONI","clasa XI-XII"]},{"location":"olimpiada/solutii/ONI/2024/XI-XII-zid/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie neoficial\u0103 care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    cout &lt;&lt; a + b &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["ONI","clasa XI-XII"]},{"location":"olimpiada/solutii/roalgo/roalgo-weekly/weekly-0/","title":"Descrierea solu\u021biilor RoAlgo Weekly Contest 0","text":"<p>V\u0103 mul\u021bumim c\u0103 a\u021bi luat parte la concursul RoAlgo Weekly Contest #0. Acest concurs nu ar fi putut avea loc f\u0103r\u0103 sprijinul vostru \u0219i f\u0103r\u0103 ajutorul testerilor concursului, care sunt prezen\u021bi \u00een lista de editori a concursului de pe Kilonova.</p> <p>Aceast\u0103 serie de concursuri va continua \u00een fiecare s\u0103pt\u0103m\u00e2n\u0103, scopul fiind acela de a deveni un concurs similar \u00een popularitate cu rundele de pe LeetCode \u0219i nu numai.</p>","tags":["clasa","bacalaureat","clasa IX"]},{"location":"olimpiada/solutii/roalgo/roalgo-weekly/weekly-0/#problema-parimpar","title":"Problema parimpar","text":"<p>Pentru a rezolva aceast\u0103 problem\u0103, trebuie s\u0103 simul\u0103m opera\u021biile din enun\u021b conform algoritmului descris. Pentru a interschimba caracterele, vom folosi metoda celor trei pahare, av\u00e2nd o variabil\u0103 auxiliar\u0103 \u00een care vom p\u0103stra unul dintre caractere.</p>","tags":["clasa","bacalaureat","clasa IX"]},{"location":"olimpiada/solutii/roalgo/roalgo-weekly/weekly-0/#rezolvare","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\n#include &lt;cstring&gt;\nusing namespace std;\n\nint main() {\n    char S[101];\n    cin &gt;&gt; S;\n\n    for(int i = 0; i &lt; strlen(S); i = i + 2) {\n        char auxiliar = S[i];\n        S[i] = S[i+1];\n        S[i+1] = auxiliar;\n    }\n\n    cout &lt;&lt; S;\n    return 0;\n}\n</code></pre>","tags":["clasa","bacalaureat","clasa IX"]},{"location":"olimpiada/solutii/roalgo/roalgo-weekly/weekly-0/#problema-sumsecv","title":"Problema sumsecv","text":"<p>Pentru a rezolva aceast\u0103 problem\u0103, trebuie doar s\u0103 parcurgem subsecven\u021ba delimitat\u0103 de pozi\u021biile \\(L\\) \u0219i \\(R\\) de la fiecare interogare \u0219i s\u0103 p\u0103str\u0103m suma total\u0103 \u00eentr-o variabil\u0103 numit\u0103 \\(sum\\).</p>","tags":["clasa","bacalaureat","clasa IX"]},{"location":"olimpiada/solutii/roalgo/roalgo-weekly/weekly-0/#rezolvare_1","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main(){\n\n    int n, m, a[101];\n    cin &gt;&gt; n &gt;&gt; m;\n    for (int i = 1; i &lt;= n; i++){\n        cin &gt;&gt; a[i];\n    }\n\n    for (int q = 1; q &lt;= m; q++){\n        int l, r;\n        cin &gt;&gt; l &gt;&gt; r;\n        int sum = 0;\n        for (int i = l; i &lt;= r; i++){\n            sum += a[i];\n        }\n        cout &lt;&lt; sum &lt;&lt; '\\n';\n    }\n\n    return 0;\n}\n</code></pre>","tags":["clasa","bacalaureat","clasa IX"]},{"location":"olimpiada/solutii/roalgo/roalgo-weekly/weekly-0/#problema-gcdness","title":"Problema GCDness","text":"<p>Pentru a rezolva aceast\u0103 problem\u0103, putem observa faptul c\u0103 r\u0103spunsul pe care \u00eel c\u0103ut\u0103m va fi mereu \u00een intervalul \\([2, 1000]\\). Deoarece avem foarte pu\u021bine valori \u00een \u0219ir, este \u00eendeajuns s\u0103 verific\u0103m toate valorile \u0219i s\u0103 vedem care ar fi valoarea cu cel mai mare GCDness.</p>","tags":["clasa","bacalaureat","clasa IX"]},{"location":"olimpiada/solutii/roalgo/roalgo-weekly/weekly-0/#rezolvare_2","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int n, v[101];\n    cin &gt;&gt; n;\n\n    for (int i = 1; i &lt;= n; i++){\n         cin &gt;&gt; v[i];\n    }\n\n    int bestK = 2, bestCount = 0;\n    for (int k = 2; k &lt;= 1000; k++){\n        int cnt = 0;\n        for (int i = 1; i &lt;= n; i++) {\n            if (v[i] % k == 0) {\n                cnt++;\n            }\n        }\n        if(cnt &gt; bestCount){\n            bestCount = cnt;\n            bestK = k;\n        }\n    }\n    cout &lt;&lt; bestK;\n    return 0;\n}\n</code></pre>","tags":["clasa","bacalaureat","clasa IX"]},{"location":"olimpiada/solutii/roalgo/roalgo-weekly/weekly-0/#problema-identice","title":"Problema identice","text":"<p>Rezolvarea acestei probleme presupune p\u0103strarea pentru fiecare cifr\u0103 a pozi\u021biei celei mai din st\u00e2nga \u0219i celei mai din dreapta apari\u021bii a valorii \u00een \u0219ir, iar pentru fiecare cifr\u0103 de la \\(0\\) la \\(9\\), vom verifica dac\u0103 lungimea acelei secven\u021be este mai mare dec\u00e2t lungimea maxim\u0103 aflat\u0103. Trebuie avut grij\u0103 \u0219i la criteriul de departajare.</p>","tags":["clasa","bacalaureat","clasa IX"]},{"location":"olimpiada/solutii/roalgo/roalgo-weekly/weekly-0/#rezolvare_3","title":"Rezolvare","text":"<p>Mai jos pute\u021bi g\u0103si o solu\u021bie care ia punctajul maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int V[100001], St[10] = {0}, Dr[10] = {0}, n, i, maxim = 0, st = 1, dr = 1;\n\n    cin &gt;&gt; n;\n\n    for(i = 1; i &lt;= n; i++)\n        cin &gt;&gt; V[i];\n\n    for(i = 1; i &lt;= n; i++) {\n        if(St[V[i]] == 0)\n            St[V[i]] = i;\n        Dr[V[i]] = i;\n    }\n\n    for(i = 0; i &lt;= 9; i++)\n        if(Dr[i] != 0 &amp;&amp; St[i] != 0)\n            if(Dr[i] - St[i] + 1 &gt; maxim) {\n                maxim = Dr[i] - St[i] + 1;\n                st = St[i];\n                dr = Dr[i];\n            }\n            else if(Dr[i] - St[i] + 1 &gt;= maxim &amp;&amp; St[i] &lt; st) {\n                st = St[i];\n                dr = Dr[i];\n            }\n\n    cout &lt;&lt; st &lt;&lt; \" \" &lt;&lt; dr;\n\n    return 0;\n}\n</code></pre>","tags":["clasa","bacalaureat","clasa IX"]},{"location":"usor/bac-admitere/","title":"Cum s\u0103 te preg\u0103te\u0219ti pentru bacalaureat \u0219i admitere?","text":"","tags":["meta","sfaturi"]},{"location":"usor/bac-admitere/#introducere","title":"Introducere","text":"<p>E\u0219ti la liceu \u0219i \u021bi-ai propus s\u0103 dai examenul de bacalaureat la informatic\u0103 \u0219i de ce nu, s\u0103 urmezi studii universitare de profil. \u00centrebarea care se pune acum natural este cum s\u0103 te preg\u0103te\u0219ti pentru aceste examene pentru a putea ob\u021bine note c\u00e2t mai bune, care s\u0103 \u00ee\u021bi permit\u0103 s\u0103 intri la facultatea dorit\u0103 f\u0103r\u0103 probleme.</p> <p>\u00cen acest articol vom discuta c\u00e2teva sfaturi practice care te vor ajuta s\u0103 ajungi la aceste obiective \u00eentr-un mod c\u00e2t mai simplu \u0219i eficient.</p>","tags":["meta","sfaturi"]},{"location":"usor/bac-admitere/#examenul-de-bacalaureat","title":"Examenul de bacalaureat","text":"<p>Indiferent de nivelul vostru, fie c\u0103 sunte\u021bi olimpici sau sunte\u021bi familiariza\u021bi doar cu nivelul de la clas\u0103, trebuie s\u0103 da\u021bi aceast\u0103 prob\u0103 de examen (singura excep\u021bie este cazul \u00een care ave\u021bi o medalie la un concurs interna\u021bional), iar \u00een mod particular, cu c\u00e2t ave\u021bi mai multe cuno\u0219tin\u021be de algoritmic\u0103 peste nivelul examenului, cu at\u00e2t v\u0103 poate \u00eencurca mai mult dac\u0103 nu sunte\u021bi aten\u021bi la detalii.</p> <p>Examenul are \u00een prezent trei subiecte diferite \u0219i se d\u0103 pe durata a trei ore. Subiectele combin\u0103 probleme cu variante multiple de r\u0103spuns (grile), o problem\u0103 \u00een pseudocod care are mai multe cerin\u021be specifice precum \u0219i c\u00e2teva exerci\u021bii \u0219i probleme unde trebuie s\u0103 scrie\u021bi programe, fie \u00een pseudocod, fie \u00een C/C++.</p> <p>Chiar dac\u0103 aceste exerci\u021bii nu sunt dificile dup\u0103 ce v\u0103 familiariza\u021bi cu stilul lor, trebuie s\u0103 ave\u021bi grij\u0103, la fel ca la orice examen scris, la modul cum redacta\u021bi solu\u021biile precum \u0219i la citirea cu aten\u021bie a cerin\u021belor problemelor.</p>","tags":["meta","sfaturi"]},{"location":"usor/bac-admitere/#cum-te-pregatesti-pentru-examenul-de-bacalaureat","title":"Cum te preg\u0103te\u0219ti pentru examenul de bacalaureat?","text":"<p>\u00cen general, pe l\u00e2ng\u0103 parcurgerea sec\u021biunilor U\u0219or \u0219i Mediu (nu toate capitolele sunt necesare) din arhiva noastr\u0103, trebuie s\u0103 fi\u021bi la curent cu programa \u0219i cu tipurile de subiecte care se dau la examen. Recomand\u0103m lucrarea a c\u00e2tor mai multe variante, fie c\u0103 este vorba de subiecte din anii trecu\u021bi, modele de examen, c\u0103r\u021bi de variante sau alte simul\u0103ri pe care le da\u021bi \u00een aceast\u0103 perioad\u0103 de timp.</p> <p>Pe l\u00e2ng\u0103 recapitularea materiei \u0219i a problemelor care se dau frecvent la aceste tipuri de subiecte, trebuie s\u0103 v\u0103 obi\u0219nui\u021bi s\u0103 scrie\u021bi rezolv\u0103rile c\u00e2t mai detaliat, astfel \u00eenc\u00e2t orice corector s\u0103 v\u0103 \u00een\u021beleag\u0103 abord\u0103rile.</p>","tags":["meta","sfaturi"]},{"location":"usor/bac-admitere/#abordarea-examenului-in-sine","title":"Abordarea examenului \u00een sine","text":"<p>De regul\u0103, este bine s\u0103 aborda\u021bi problemele \u00een ordinea \u00een care se dau, deoarece v\u0103 ajut\u0103 s\u0103 v\u0103 p\u0103stra\u021bi ritmul \u0219i ajut\u0103 \u0219i corectorul \u00een procesul de corectare al examenului.</p> <p>Scrierea codurilor</p> <p>Atunci c\u00e2nd scrie\u021bi coduri pentru rezolvarea problemelor, limita\u021bi-v\u0103 cuno\u0219tin\u021bele de C++ la urm\u0103toarele biblioteci:</p> <ul> <li>iostream</li> <li>fstream</li> <li>cstring</li> <li>(op\u021bional) cmath</li> </ul> <p>Toate problemele date la examen se pot rezolva folosind aceste biblioteci. Evita\u021bi sub orice form\u0103 folosirea urm\u0103toarelor facilit\u0103\u021bi C++:</p> <ul> <li>STL</li> <li>facilit\u0103\u021bile std::string</li> <li>biblioteci precum algorithm</li> <li>alte facilit\u0103\u021bi avansate C++</li> </ul> <p>Pe scurt, presupune\u021bi c\u0103 corectorul vrea s\u0103 vad\u0103 o rezolvare c\u00e2t mai simpl\u0103 \u0219i la obiect, care s\u0103 demonstreze abilit\u0103\u021bile voastre de rezolvare a problemelor.</p> <p>Este important s\u0103 ave\u021bi o sticl\u0103 cu ap\u0103 la voi (fiind var\u0103, poate fi foarte cald \u00een sal\u0103 \u0219i este bine s\u0103 v\u0103 doza\u021bi timpul, iar dac\u0103 sunt exerci\u021bii mai dificile \u0219i nu sunte\u021bi siguri pe voi, folosi\u021bi mai \u00eent\u00e2i ciorna, iar mai apoi scrie\u021bi pe foaia de examen.</p>","tags":["meta","sfaturi"]},{"location":"usor/bac-admitere/#admiterea","title":"Admiterea","text":"<p>Majoritatea facult\u0103\u021bilor de informatic\u0103 din Rom\u00e2nia au un examen de admitere care trebuie dat pentru a putea studia la acea facultate. Totu\u0219i, dac\u0103 ave\u021bi rezultate la olimpiad\u0103 sau la alte concursuri de informatic\u0103 (de regul\u0103, men\u021biune la ONI este suficient pentru a putea fi admis, iar o medalie v\u0103 poate da un bonus \u00een vederea punctajului de admitere).</p> <p>\u00cen cazul cel mai general \u00een care nu ave\u021bi asemenea distinc\u021bii, trebuie s\u0103 v\u0103 preg\u0103ti\u021bi pentru acest examen, care spre deosebire de proba de bacalaureat, are exclusiv \u00eentreb\u0103ri gril\u0103, de o dificultate mai mare dec\u00e2t cea de la bac. Fiecare facultate are formatul ei, dar \u00een general, se dau \u00eentre 10 \u0219i 30 de \u00eentreb\u0103ri, pe o durat\u0103 de 2-3 ore, iar r\u0103spunsul corect poate fi simplu sau multiplu.</p> <p>Pentru aceste tipuri de examene, este bine s\u0103 ave\u021bi \u00een vedere subiectele date \u00een anii trecu\u021bi la admiterile de la facultatea \u00een cauz\u0103, precum \u0219i subiectele de la celelalte facult\u0103\u021bi de profil. Un alt sfat util este acela de a avea bine pus\u0103 la punct materia de bacalaureat, \u00eempreun\u0103 cu capitole suplimentare (\u00een arhiva noastr\u0103, trebuie s\u0103 \u0219ti\u021bi toat\u0103 materia de la sec\u021biunile u\u0219or \u0219i mediu, sau dac\u0103 v-a\u021bi uitat la roadmap, primele 5 capitole).</p>","tags":["meta","sfaturi"]},{"location":"usor/bac-admitere/#concluzii","title":"Concluzii","text":"<p>Aceste examene, fiind un pas important spre des\u0103v\u00e2r\u0219irea muncii voastre de p\u00e2n\u0103 acum, trebuie tratate foarte serios pentru ob\u021binerea unor rezultate foarte bune, deoarece v\u0103 obi\u0219nuiesc cu efortul intens pe care va trebui s\u0103-l depune\u021bi de-a lungul facult\u0103\u021bii, precum \u0219i ulterior pe parcursul vie\u021bii indiferent de ce ve\u021bi face.</p> <p>V\u0103 a\u0219tept\u0103m pe serverul nostru sau \u00een articolele noastre pentru a v\u0103 preg\u0103ti pentru a ob\u021bine nota 10 la aceste examene \u0219i nu numai.</p>","tags":["meta","sfaturi"]},{"location":"usor/bases/","title":"Baze de numera\u021bie","text":"","tags":["matematica","baze de numeratie"]},{"location":"usor/bases/#sisteme-de-numeratie","title":"Sisteme de numera\u021bie","text":"<p>Defini\u021bie</p> <p>Un sistem de numera\u021bie este alc\u0103tuit dintr-o mul\u021bime finit\u0103 de simboluri (denumite conven\u021bional \u201ecifre\u201d) \u0219i un set de reguli de reprezentare a numerelor cu ajutorul simbolurilor respective. Num\u0103rul de simboluri constituie baza sistemului de numera\u021bie.</p> <p>\u00cen general, folosim sisteme de numera\u021bie pozi\u021bionale, pentru care pozi\u021biile simbolurilor corespund puterilor bazei sistemului de numera\u021bie. Un exemplu de sistem de numera\u021bie nepozi\u021bional este cel roman.</p> <p>Sistemul de numera\u021bie pe care \u00eel folosim \u00een via\u021ba de zi cu zi este cel zecimal, pentru c\u0103 are zece simboluri: 0, 1, 2, 3, 4, 5, 6, 7, 8, 9. \u00cen sistemul binar, se folosesc doar dou\u0103 simboluri: 0 \u0219i 1. \u00cen sistemul hexazecimal avem 16 simboluri: 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F, unde A reprezint\u0103 10, B reprezint\u0103 11 \u0219.a.m.d. p\u00e2n\u0103 la F care este 15.</p> <p>Putem generaliza discu\u021bia dac\u0103 vom nota cu \\(b\\) (\\(b \\in \\mathbb{N}\\), \\(b &gt; 1\\)) baza de numera\u021bie (sau \u201ebaza\u201d de acum \u00eencolo). Motivul pentru care alegem \\(b &gt; 1\\) este c\u0103 baza 1 este trivial\u0103: este num\u0103ratul cu be\u021bi\u0219oare pe care \u00eel facem c\u00e2nd suntem mici.</p> <p>Fiecare cifr\u0103 dintr-un num\u0103r valoreaz\u0103 de \\(b\\) ori mai mult dec\u00e2t cifra din dreapta sa. Vom considera cifrele numerotate de la dreapta (de la cifra unit\u0103\u021bilor, aceasta consider\u00e2ndu-se pe pozi\u021bia 0). Cifrele num\u0103rului a\u0219adar corespund pozi\u021bional puterilor bazei sistemului de numera\u021bie.</p> <p>Dac\u0103 avem num\u0103rul \\(\\overline{c_k c_{k-1} \\dots c_{1} c_0}_{(b)}\\) \u00een baza \\(b\\), atunci \u00een baza 10 num\u0103rul va fi scris ca: \\(c_k b^k + c_{k-1} b^{k-1} + \\dots + c_1 b^1 + c_0 b^0\\).</p> <p>S\u0103 vedem ni\u0219te exemple:</p> Num\u0103rul dat Baza Formula Valoarea \u00een baza 10 100101 2 \\(1 \\cdot 2^5 + 0 \\cdot 2^4 + 0 \\cdot 2^3 + 1 \\cdot 2^2 + 0 \\cdot 2^1 + 1 \\cdot 2^0\\) 37 21012 3 \\(2 \\cdot 3^4 + 1 \\cdot 3^3 + 0 \\cdot 3^2 + 1 \\cdot 3^1 + 2 \\cdot 3^0\\) 194 4AF 16 \\(4 \\cdot 16^2 + 10 \\cdot 16^1 + 15 \\cdot 16^0\\) 1199 10321 4 \\(1 \\cdot 4^4 + 0 \\cdot 4^3 + 3 \\cdot 4^2 + 2 \\cdot 4^1 + 1 \\cdot 4^0\\) 313 763 8 \\(7 \\cdot 8^2 + 6 \\cdot 8^1 + 3 \\cdot 8^0\\) 499 43210 5 \\(4 \\cdot 5^4 + 3 \\cdot 5^3 + 2 \\cdot 5^2 + 1 \\cdot 5^1 + 0 \\cdot 5^0\\) 2930 <p>Ne putem imagina c\u0103 procesul de a trece un num\u0103r din baza 10 \u00een baza \\(b\\) ar fi invers. S\u0103 zicem c\u0103 avem num\u0103rul 1199 \u00een baza 10 \u0219i vrem s\u0103-l convertim \u00een baza 16. Nu are o valoare de la 0 la 15, a\u0219a c\u0103 nu este doar o singur\u0103 cifr\u0103. Dac\u0103 \u00eemp\u0103r\u021bim 1199 la 16, vedem c\u0103 1199 / 16 = 74 \u0219i 1199 % 16 = 15. Cu alte cuvinte, 1199 = 74 \u22c5 16 + 15. Din p\u0103cate, nu avem o cifr\u0103 pentru 74, a\u0219a c\u0103 repet\u0103m procesul. Putem vedea c\u0103 74 = 4 \u22c5 16 + 10. Dac\u0103 ducem asta \u00een formula noastr\u0103, asta \u00eenseamn\u0103 c\u0103 1199 = (4 \u22c5 16 + 10) \u22c5 16 + 15, sau \\(1199 = 4 \\cdot 16^2 + 10 \\cdot 16 + 15\\), de unde putem scrie ca \\(4AF_{(16)}\\).</p> <p>Ca s\u0103 ilustrez procesul mai bine:</p> \\[ \\begin{align*} 1199 &amp;= 16 \\cdot 74 + 15\\\\ 74 &amp;= 16 \\cdot 4 + 10 \\\\ 4 &amp;= 16 \\cdot 0 + 4 \\end{align*} \\] <p>Algoritmul este urm\u0103torul:</p> <p>Algoritmul de conversie din baza 10 \u00een baza \\(b\\)</p> <p>Pentru a converti un num\u0103r natural din baza 10 \u00eentr-o baz\u0103 \\(b\\) (\\(b \\in \\mathbb{N}\\), \\(b &gt; 1\\)), vom face \u00eemp\u0103r\u021biri succesive la \\(b\\) p\u00e2n\u0103 c\u00e2nd ob\u021binem c\u00e2tul 0. La primul pas, de\u00eemp\u0103r\u021bitul este num\u0103rul care se converte\u0219te, iar la ceilal\u021bi pa\u0219i, c\u00e2tul de la \u00eemp\u0103r\u021birea precedent\u0103 devine de\u00eemp\u0103r\u021bit. Reprezentarea num\u0103rului \u00een baza \\(b\\) se ob\u021bine consider\u00e2nd resturile \u00een ordinea invers\u0103 ob\u021binerii lor.</p> <p>Acest proces se poate extinde \u0219i pentru numerele cu virgul\u0103. Lu\u0103m num\u0103rul 420.69. \u0218tim deja cum s\u0103 convertim 420. Pentru partea frac\u021bional\u0103, este mai u\u0219or dac\u0103 descompunem num\u0103rul astfel:</p> \\[ \\begin{align*} 420.69 &amp;= 420 + \\frac{69}{100}\\\\ &amp;= 4 \\cdot 10^2 + 2 \\cdot 10^1 + 0 \\cdot 10^0 + \\frac{6 \\cdot 10^1 + 9 \\cdot 10^0}{10^2}\\\\ &amp;= 4 \\cdot 10^2 + 2 \\cdot 10^1 + 0 \\cdot 10^0 + 6 \\cdot 10^{-1} + 9 \\cdot 10^{-2} \\end{align*} \\] <p>Algoritmul de mai sus este la fel, doar c\u0103 pentru partea frac\u021bionar\u0103 trebuie s\u0103 \u00eenmul\u021bim, nu s\u0103 \u00eemp\u0103r\u021bim. Vrem s\u0103 ajungem la c\u00e2tul zero, \u0219i nu putem face asta dac\u0103 \u00eemp\u0103r\u021bim un num\u0103r sub 1 la baz\u0103 pentru c\u0103 vom ob\u021bine numere din ce \u00een ce mai mici.</p> <p>S\u0103 \u00eencerc\u0103m acest lucru pentru 959.53, convertindu-l \u00een baza 7. Pentru partea \u00eentreag\u0103, \u0219tim ce avem de f\u0103cut:</p> \\[ \\begin{align*} 959 &amp;= 7 \\cdot 137 + 0\\\\ 137 &amp;= 7 \\cdot 19 + 4 \\\\ 19 &amp;= 7 \\cdot 2 + 5\\\\ 2 &amp;= 7 \\cdot 0 + 2 \\end{align*} \\] <p>Adic\u0103 \\(959_{(10)} = 2540_{(7)}\\). Pentru partea frac\u021bionar\u0103, proced\u0103m \u00een felul urm\u0103tor:</p> \\[ \\begin{align*} 0.53 \\cdot 7 &amp;= 3.71 \\\\&amp;= 7 \\cdot 0 + 3.71\\\\ 3.71 \\cdot 7 &amp;= 25.97 \\\\&amp;= 7 \\cdot 3 + 4.97\\\\ 4.97 \\cdot 7 &amp;= 34.79 \\\\&amp;= 7 \\cdot 4 + 6.79\\\\ 6.79 \\cdot 7 &amp;= 47.53 \\\\&amp;= 7 \\cdot 6 + 5.53\\\\ 5.53 \\cdot 7 &amp;= 38.71 \\\\&amp;= 7 \\cdot 5 + 3.71\\\\ \\end{align*} \\] <p>Am ajuns la 3.71 din nou, deci cifrele se repet\u0103. A\u0219adar, \\(959.53_{(10)} = 2540.(3465)_{(7)}\\) (unde parantezele reprezint\u0103 perioada).</p> <p>\u00cen informatic\u0103 este foarte util urm\u0103torul rezultat:</p> <p>Conversia \u00eentre baze puteri ale lui 2</p> <p>Trecerea din baza doi \u00eentr-o baz\u0103 putere a lui 2 (\\(2^k\\)) se face astfel: se grupeaz\u0103 cifrele num\u0103rului \u00een baza 2 \u00eencep\u00e2nd din dreapta, c\u00e2te \\(k\\), \u0219i se scrie \u00een baza 10 valoarea ob\u021binut\u0103 cu fiecare acest grup, acestea fiind cifrele num\u0103rului \u00een baza \\(2^k\\). Dac\u0103 un grup are mai pu\u021bin de \\(k\\) cifre, vom completa \u00een fa\u021b\u0103 cu cifre 0.</p> <p>De pild\u0103, s\u0103 lu\u0103m num\u0103rul 110010010111110011 \u0219i s\u0103-l convertim \u00een baza 16. Dac\u0103 grup\u0103m c\u00e2te 4 (\\(16 = 2^4\\)), vom avea \"(00)11 0010 0101 1111 0011\" \u0219i putem converti fiecare grup ca atare (vom avea \"3 4 5 15 3\", care se traduce \u00een \\(345F3_{(16)}\\)). Asta este motivul principal pentru care baza 16 este a\u0219a des folosit\u0103 \u00een informatic\u0103: este o reprezentare mai compact\u0103 pentru \u0219iruri binare. Mai sunt folosite \u0219i baza 32 \u0219i baza 64 pentru acest scop.</p>","tags":["matematica","baze de numeratie"]},{"location":"usor/bases/#problema-1-bazab-pbinfo","title":"Problema 1 - bazab (pbinfo)","text":"<p>Aceast\u0103 problem\u0103 ne cere s\u0103 afl\u0103m cea mai mare cifr\u0103 a reprezent\u0103rii lui n \u00een baza b. \u0218tim c\u0103 aceasta este dat\u0103 de restul la \u00eemp\u0103r\u021birea lui \\(n\\) cu \\(b\\), a\u0219adar este de ajuns s\u0103 \u021binem minte acest rest \u0219i s\u0103-l compar\u0103m cu restul precedent pentru a vedea dac\u0103 este mai mare.</p> <pre><code>#include &lt;iostream&gt;\n\nint main() {\n    int numar, baza;\n    std::cin &gt;&gt; numar &gt;&gt; baza;\n\n    int cifra_maxima = 0;\n\n    while (numar &gt; 0) {\n        int cifra = numar % baza;\n\n        cifra_maxima = std::max(cifra, cifra_maxima);\n\n        numar /= baza;\n    }\n\n    std::cout &lt;&lt; cifra_maxima &lt;&lt; \"\\n\";\n\n    return 0;\n}\n</code></pre>","tags":["matematica","baze de numeratie"]},{"location":"usor/bases/#problema-2-baze-pbinfo","title":"Problema 2 - baze (pbinfo)","text":"<p>Aici trebuie s\u0103 transform\u0103m un num\u0103r din baza \\(b\\) \u00een baza \\(c\\) (unde \\(2 \\leq b, c \\leq 10\\)). Dac\u0103 ne imagin\u0103m procesul, \u0219tim cum s\u0103 convertim din baza \\(b\\) \u00een baza 10, \u0219i din baza 10 \u00een baza \\(c\\), deci dac\u0103 aplic\u0103m aceste proceduri secven\u021bial, rezolv\u0103m problema. \u0218tim c\u0103 baza 2 va avea cea mai lung\u0103 reprezentare, deci putem estima num\u0103rul cifrelor ca fiind \\(\\log_2(2^32) = 32\\) (din moment ce are cel mult 10 cifre, putem presupune c\u0103 poate fi stocat \u00eentr-un <code>unsigned int</code>).</p> <pre><code>#include &lt;iostream&gt;\n\nint main() {\n    int numar, b, c;\n    std::cin &gt;&gt; numar &gt;&gt; b &gt;&gt; c;\n\n    int valoare_zecimala = 0, putere = 1;\n\n    while (numar &gt; 0) {\n        int cifra = numar % 10;\n        valoare_zecimala += cifra * putere;\n        putere *= b;\n        numar /= 10;\n    }\n\n    int cifre_c[32];\n    int numar_cifre = 0;\n\n    while (valoare_zecimala &gt; 0) {\n        int cifra = valoare_zecimala % c;\n        cifre_c[numar_cifre++] = cifra;\n        valoare_zecimala /= c;\n    }\n\n    for (int i = numar_cifre - 1; i &gt;= 0; i--) {\n        std::cout &lt;&lt; cifre_c[i];\n    }\n    std::cout &lt;&lt; \"\\n\";\n\n    return 0;\n}\n</code></pre>","tags":["matematica","baze de numeratie"]},{"location":"usor/bases/#problema-3-cifbin-pbinfo","title":"Problema 3 - CifBin (pbinfo)","text":"<p>Aici situa\u021bia este simpl\u0103: fie avem 0, fie avem 1, deci este u\u0219or s\u0103 num\u0103r\u0103m num\u0103rul de cifre 0 \u0219i num\u0103rul de cifre 1 bazat pe paritatea num\u0103rului. Dac\u0103 un num\u0103r este impar, va avea 1 ca ultima cifr\u0103. Dac\u0103 ne aducem aminte de reprezentarea unui num\u0103r, un num\u0103r impar va avea un \\(2^0\\), adic\u0103 un 1 pe prima pozi\u021bie, \u00een timp ce un num\u0103r par va avea 0. Exist\u0103 moduri alternative prin care s-ar putea rescrie solu\u021bia folosind opera\u021biile pe bi\u021bi, dar asta este un subiect mai avansat.</p> <pre><code>#include &lt;iostream&gt;\n\nint main() {\n    int numar;\n    std::cin &gt;&gt; numar;\n\n    int numar_0 = 0, numar_1 = 0;\n\n    while (numar &gt; 0) {\n        if (numar % 2 == 0) {\n            numar_0++;\n        } else {\n            numar_1++;\n        }\n\n        numar /= 2;\n    }\n\n    std::cout &lt;&lt; numar_0 &lt;&lt; \" \" &lt;&lt; numar_1 &lt;&lt; \"\\n\";\n\n    return 0;\n}\n</code></pre>","tags":["matematica","baze de numeratie"]},{"location":"usor/bases/#problema-4-transfb-pbinfo","title":"Problema 4 - transfb (pbinfo)","text":"<p>Aici ni se d\u0103 cifrele \u00een baza \\(b\\) \u0219i trebuie s\u0103 transform\u0103m acest num\u0103r \u00een baza 10. Aceast\u0103 problem\u0103 este o aplica\u021bie trivial\u0103 a algoritmului de conversie discutat \u00eenainte. De notat c\u0103, din moment ce avem cifrele de la st\u00e2nga la dreapta \u0219i nu invers, trebuie s\u0103 precalcul\u0103m cea mai mare putere a bazei (\\(b^n\\)) \u00eenainte de a putea continua.</p> <pre><code>#include &lt;iostream&gt;\n\nint main() {\n    int numar_cifre, baza;\n    std::cin &gt;&gt; baza &gt;&gt; numar_cifre;\n\n    int putere = 1;\n    for (int i = 0; i &lt; numar_cifre - 1; ++i) {\n        putere *= baza;\n    }\n\n    int numar_convertit = 0;\n    while (numar_cifre--) {\n        int cifra;\n        std::cin &gt;&gt; cifra;\n\n        numar_convertit += cifra * putere;\n        putere /= baza;\n    }\n\n    std::cout &lt;&lt; numar_convertit &lt;&lt; \"\\n\";\n}\n</code></pre>","tags":["matematica","baze de numeratie"]},{"location":"usor/bases/#problema-5-pretios-pbinfo","title":"Problema 5 - pretios (pbinfo)","text":"<p>Cuno\u0219tin\u021be necesare</p> <ul> <li>Divizibilitate</li> <li>Ciurul lui Eratostene</li> </ul> <p>Aceast\u0103 problem\u0103 este ceva mai dificil\u0103. Trebuie s\u0103 determin\u0103m dac\u0103 lungimea unui num\u0103r (num\u0103rul de bi\u021bi) este prim\u0103. Deoarece numerele din intervalul \\([a,b]\\) sunt foarte mari (p\u00e2n\u0103 la \\(10^{18}\\)), este imposibil s\u0103 verific\u0103m fiecare num\u0103r din acest interval. Totu\u0219i, observ\u0103m c\u0103 num\u0103rul de bi\u021bi pentru orice num\u0103r din acest interval este \u00eentotdeauna \u00eentre 1 \u0219i 64, deoarece \\(2^{64}&gt; 10^{18}\\).</p> <p>Astfel, trebuie doar s\u0103 verific\u0103m dac\u0103 num\u0103rul de bi\u021bi al unui num\u0103r este prim, ceea ce este mult mai eficient. A\u0219adar, este mai eficient s\u0103 precalcul\u0103m numerele prime \u00eentre 1 \u0219i 64. Dac\u0103 \\(a\\) \u0219i \\(b\\) au un num\u0103r prim de bi\u021bi, \u00eencepem s\u0103 num\u0103r\u0103m numerele pre\u021bioase, pentru c\u0103 avem \\(p - a\\), respectiv \\(b - p + 1\\) numere. Dup\u0103 aceea, verific\u0103m toate numerele de la <code>start</code> la <code>stop</code> \u0219i dac\u0103 \\(i\\) este prim, \u00eenseamn\u0103 c\u0103 numerele din intervalul \\([2^{i}, 2^{i + 1} - 1]\\) au o lungime prim\u0103, deci asta va contribui la num\u0103rul de numere pre\u021bioase. Aici este solu\u021bia:</p> <pre><code>#include &lt;cmath&gt;\n#include &lt;iostream&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\nstd::vector&lt;bool&gt; primes(65, true);\n\nint main() {\n    primes[0] = primes[1] = false;\n    for (int i = 2; i &lt;= 64; ++i) {\n        if (primes[i]) {\n            for (int j = i * i; j &lt;= 64; j += i) {\n                primes[j] = false;\n            }\n        }\n    }\n\n    unsigned long long a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    int start = (int)log2(a) + 1;\n    int stop = (int)log2(b);\n\n    unsigned long long p = 1;\n    for (int i = 1; i &lt;= start; i++) {\n        p = p * 2;\n    }\n\n    unsigned long long nr = 0;\n\n    if (primes[start]) {\n        nr += p - a;\n    }\n\n    for (int i = start; i &lt; stop; ++i) {\n        if (primes[i + 1]) {\n            nr += p;\n        }\n        p *= 2;\n    }\n\n    if (primes[stop + 1]) {\n        nr += b - p + 1;\n    }\n\n    cout &lt;&lt; nr &lt;&lt; \" \";\n    return 0;\n}\n</code></pre>","tags":["matematica","baze de numeratie"]},{"location":"usor/bases/#probleme-suplimentare","title":"Probleme suplimentare","text":"<ul> <li>bazaminima pbinfo</li> <li>ascunsa nerdarena</li> <li>douabaze pbinfo</li> <li>criptic nerdarena</li> <li>ONI 2014 zimeria</li> <li>suc1 nerdarena</li> <li>psychtraining infoarena</li> <li>sticle infoarena</li> <li>Lot 2010 Juniori puteri35</li> <li>OJI 2019 cate3cifre</li> <li>ONI 2011 Baraj Seniori copii</li> <li>nop infoarena</li> <li>ONI 2023 xidartros</li> </ul>","tags":["matematica","baze de numeratie"]},{"location":"usor/bases/#lectura-suplimentara","title":"Lectur\u0103 suplimentar\u0103","text":"<ul> <li>Articolul de baze de numera\u021bie de pe     CPPI</li> <li>Articolul de baze de numera\u021bie de pe     PBInfo</li> <li>Lec\u021bia 5, clasa a VI-a, 18 octombrie 2018 de pe     Algopedia</li> <li>Lec\u021bia 6, clasa a VI-a, 18 octombrie 2018 de pe     Algopedia</li> </ul>","tags":["matematica","baze de numeratie"]},{"location":"usor/binary-search/","title":"C\u0103utarea binar\u0103","text":"<p>S\u0103 presupunem c\u0103 avem un \u0219ir de \\(N\\) numere \u0219i memorie astfel \u00eenc\u00e2t s\u0103 putem re\u021bine doar \u0219irul (plus evident alte variabile, dar nu foarte multe). Noi primim mai multe \u00eentreb\u0103ri, de forma: Exist\u0103 valoarea \\(X\\) \u00een \u0219ir?</p> <p>\u00cen mod evident, o solu\u021bie foarte trivial\u0103 este s\u0103 parcurgem manual \u0219irul pentru fiecare \u00eentrebare, \u0219i s\u0103 vedem dac\u0103 elementul cerut apare sau nu \u00een \u0219ir, astfel ob\u021bin\u00e2nd complexitate total\u0103 de \\(\\mathcal{O}(N \\cdot Q)\\). Singura noastr\u0103 problem\u0103 este c\u0103 noi o s\u0103 avem \\(N\\) \u0219i \\(Q\\) undeva \u00een jur de \\(10^6\\), ceea ce va face ca aceast\u0103 abordare s\u0103 pice clar \u00een timp, deci va trebui g\u0103sit\u0103 o solu\u021bie mult mai eficient\u0103. Aici intervine algoritmul de c\u0103utare binar\u0103.</p>","tags":["vectori","sortare","cautare","optimizare"]},{"location":"usor/binary-search/#prezentarea-algoritmului","title":"Prezentarea algoritmului","text":"<p>Not\u0103</p> <p>De acum \u00eencolo, se va presupune c\u0103 \u0219irul nostru este sortat cresc\u0103tor. C\u0103utarea binar\u0103 pe un \u0219ir nesortat va da mereu r\u0103spunsuri eronate.</p> <p>\u00cen algoritmul de c\u0103utare binar\u0103 se va pleca de la analiza \u0219irului pe \u00eentreaga sa lungime, \u0219i se va fixa punctul de mijloc din sir. Dac\u0103 valoarea pozi\u021biei din mijloc este mai mic\u0103 dec\u00e2t valoarea c\u0103utat\u0103, atunci sigur valoarea c\u0103utat\u0103 se poate (c\u0103 nu \u0219tim sigur dac\u0103 exist\u0103!) afla \u00een a doua jum\u0103tate, altfel, se poate afla \u00een prima jum\u0103tate. Mai departe, nu va mai fi necesar sa analiz\u0103m tot \u0219irul, ci doar jum\u0103tatea relevant\u0103 (cea \u00een care consider\u0103m noi c\u0103 exist\u0103 o \u0219ans\u0103 s\u0103 g\u0103sim valoarea noastr\u0103), \u0219i algoritmul se va repeta p\u00e2n\u0103 c\u00e2nd lungimea devine 1 \u0219i putem determina r\u0103spunsul. Dat fiind faptul c\u0103 noi la fiecare pas \u00eemp\u0103r\u021bim la 2 lungimea \u0219irului, acest lucru ne va da complexitate logaritmic\u0103 la determinarea r\u0103spunsului, deci vom avea complexitate \\(\\mathcal{O}(Q \\log N)\\) (dac\u0103 \u0219irul nostru nu este sortat din input, se mai adaug\u0103 \u0219i un \\(\\mathcal{O}(N \\log N)\\) la complexitate), cu memorie \\(\\mathcal{O}(N)\\).</p> <p>Pentru o \u00een\u021belegere mai clar\u0103 a algoritmului, s\u0103 presupunem urm\u0103torul exemplu: se d\u0103 un \u0219ir sortat cresc\u0103tor unde apar toate numerele de la 1 la 100, \u0219i se cere s\u0103 determin\u0103m dac\u0103 exist\u0103 \u00een \u0219ir valoarea 72.</p> <p> </p> <p>O \u00eentrebare la care trebuie totu\u0219i dat r\u0103spuns este: De ce \u00eemp\u0103r\u021bim \u00een dou\u0103 jum\u0103t\u0103\u021bi \u0219i de ce nu \u00een 3 treimi? Da, \\(\\log_3 N &lt; \\log_2 N\\), dar num\u0103rul de verific\u0103ri efectuate va fi mai mare la \u00eemp\u0103r\u021birea \u00een 3 treimi, deci \u00een continuare este mai eficient s\u0103 \u00eemp\u0103r\u021bim \u00een dou\u0103 jum\u0103t\u0103\u021bi. \u00cen mod inductiv se va demonstra pentru orice \u00eemp\u0103r\u021bire posibil\u0103.</p>","tags":["vectori","sortare","cautare","optimizare"]},{"location":"usor/binary-search/#o-implementare-banala","title":"O implementare banal\u0103","text":"<p>Cea mai des \u00eent\u00e2lnit\u0103 implementare a c\u0103ut\u0103rii binare este urm\u0103toarea:</p> <pre><code>int cb_naiv(int n) {\n    int l = 1;\n    int r = n;\n    int ans = -1;\n\n    while (l &lt;= r) {\n        int mij = (l + r) / 2;\n        if (conditie) {\n            ans = mij;\n            l = mij + 1;\n        } else {\n            r = mij - 1;\n        }\n    }\n\n    return ans;\n}\n</code></pre> <p>Implementarea de mai sus este una corect\u0103, dar se pot \u00eent\u00e2lni urm\u0103toarele bug-uri:</p> <ul> <li> <p>Schimbarea \u00een \\(l = mij\\) \u0219i \\(r = mij\\) va face ca programul nostru s\u0103 ruleze   \u00eentr-o bucl\u0103 infinit\u0103 (deoarece ambele valori vor atinge la un moment dat   valoarea \\(mij\\), \u0219i deci va fi respectat\u0103 mereu condi\u021bia \\(l \\leq r\\))</p> </li> <li> <p>\u00cen timp ce-l calcul\u0103m pe \\(mij\\), ne putem lua overflow (dac\u0103 prin absurd   ajungem s\u0103 c\u0103utam fix pe la valorile maxime pe care le poate re\u021bine tipul   nostru de date, este inevitabil un overflow generat de \\(l + r\\)). De aceea,   urm\u0103toarea variant\u0103 prezentat\u0103 se va axa fix pe rezolvarea acestui bug.</p> </li> </ul>","tags":["vectori","sortare","cautare","optimizare"]},{"location":"usor/binary-search/#o-implementare-corecta","title":"O implementare corect\u0103","text":"<pre><code>int cb_corect(int n) {\n    int l = 1;\n    int r = n;\n    int ans = -1;\n\n    while (l &lt;= r) {\n        int mij = l + (r - l) / 2;\n\n        if (conditie) {\n            ans = mij;\n            l = mij + 1;\n        } else {\n            r = mij - 1;\n        }\n    }\n\n    return ans;\n}\n</code></pre> <p>Aceast\u0103 c\u0103utare binar\u0103 se bazeaz\u0103 pe principiul men\u021bionat mai sus: noi \u00eenjum\u0103t\u0103\u021bim de fiecare dat\u0103 lungimea \u0219irului pe care \u00eencerc\u0103m s\u0103 c\u0103ut\u0103m ceea ce ne intereseaz\u0103. Formula de mai sus pentru calcularea mijlocului este echivalent\u0103 cu cea din prima c\u0103utare, dar mai mult, nu are cum s\u0103 ne dea overflow.</p> <p>De fiecare dat\u0103 c\u00e2nd mijlocul nostru verific\u0103 condi\u021bie, noi facem un \u201esalt\u201d de la o pozi\u021bie \\(l\\) la alta. La finalul c\u0103ut\u0103rii, indicele \\(l\\) final va fi defapt o sum\u0103 a salturilor, iar ca pe orice num\u0103r \u00eentreg, noi acest num\u0103r \u00eel putem descompune \u00eentr-o alt\u0103 baz\u0103 numeric\u0103. Hai s\u0103 vedem cum putem rafina aceast\u0103 idee cu o alt\u0103 implementare mai jos.</p>","tags":["vectori","sortare","cautare","optimizare"]},{"location":"usor/binary-search/#cautarea-binara-a-lui-mihai-patrascu","title":"C\u0103utarea binar\u0103 a lui Mihai P\u0103tra\u0219cu","text":"<pre><code>void cb3_patrascu(int n) {\n    int l = 0;\n\n    for (int bit = 30; bit &gt;= 0; --bit) {\n        int putere = (1 &lt;&lt; bit);\n        if ((l | putere) &lt;= n &amp;&amp; conditie) {\n            l |= putere;\n        }\n    }\n}\n</code></pre> <p>Baza \u00een care noi vom descompune suma va fi baza 2, pentru a men\u021bine \u00een continuare complexitatea \\(\\log_2 N\\). Ini\u021bial, vom pleca cu un exponent \\(e\\), unde \\(2^e\\) va reprezenta lungimea secven\u021bei pe care o analiz\u0103m (aten\u021bie s\u0103 nu ie\u0219im din vector!). Chiar dac\u0103 noi vom analiza ini\u021bial o lungime care este putere de 2, care foarte probabil s\u0103 fie diferit\u0103 de \\(N\\), se poate demonstra foarte u\u0219or c\u0103 noi (dac\u0103 o s\u0103 fie necesar), vom putea c\u0103uta valori \u0219i \u00een acea secven\u021b\u0103 neacoperit\u0103 ini\u021bial. L\u0103s\u0103m aceast\u0103 demonstra\u021bie ca tem\u0103 pentru cititor.</p> <p>C\u0103utarea de mai sus poart\u0103 \u0219i numele de C\u0103utarea binar\u0103 a lui Mihai P\u0103tra\u0219cu, sau c\u0103utarea pe bi\u021bi.</p> <p>\u00cen mare parte, aceste c\u0103ut\u0103ri binare ne vor da aceea\u0219i complexitate peste tot, \u00een schimb, c\u00e2nd vrem s\u0103 implement\u0103m algoritmul de Lowest Common Ancestor (LCA) cu Binary Lifting, c\u0103utarea binar\u0103 pe bi\u021bi reduce algoritmul de la \\(\\mathcal{O}(\\log^2{H})\\) la \\(\\mathcal{O}(\\log{H})\\), unde \\(H\\) reprezint\u0103 ad\u00e2ncimea maxim\u0103 a arborelui.</p>","tags":["vectori","sortare","cautare","optimizare"]},{"location":"usor/binary-search/#cautarea-binara-pe-raspuns","title":"C\u0103utarea binar\u0103 pe r\u0103spuns","text":"<p>S\u0103 presupunem c\u0103 avem de-a face cu o problem\u0103 \u00een care trebuie s\u0103 afl\u0103m punctul \u00een care o func\u021bie monoton\u0103 atinge un anumit punct. Chiar dac\u0103 aici nu mai avem de-a face cu un vector, putem folosi acelea\u0219i principii ale c\u0103ut\u0103rii binare \u0219i s\u0103 afl\u0103m \u00een mod precis punctul \u00een care func\u021bia noastr\u0103 \\(f\\) dep\u0103\u0219e\u0219te o valoare dat\u0103, \\(n\\).</p> <p>Codul nostru nu va fi modificat \u00eentr-un mod semnificativ, singurul lucru ce se va modifica va fi ad\u0103ugarea func\u021biei men\u021bionate anterior. Totu\u0219i, trebuie remarcat c\u0103 spre deosebire de c\u0103ut\u0103rile binare pe \u0219iruri de lungime fix\u0103, aici capetele pentru \\(l\\) \u0219i \\(r\\) trebuie determinate \u00een func\u021bie de cerin\u021ba problemei.</p> <pre><code>int f(int x) {\n    // codul functiei\n}\n\nint cb_raspuns() {\n    int l = 1;\n    int r = 1000000000;\n    int ans = -1;\n\n    while (l &lt;= r) {\n        int mij = l + (r - l) / 2;\n\n        if (f(mij) &gt;= x) {\n            ans = mij;\n            r = mij - 1;\n        } else {\n            l = mij + 1;\n        }\n    }\n\n    return ans;\n}\n</code></pre>","tags":["vectori","sortare","cautare","optimizare"]},{"location":"usor/binary-search/#problema-factory-machines-de-pe-cses","title":"Problema Factory Machines de pe CSES","text":"<p>Pentru aceast\u0103 problem\u0103, se poate observa rapid faptul c\u0103 este foarte greu, dac\u0103 nu imposibil s\u0103 reducem aceast\u0103 problem\u0103 la una sau mai multe ecua\u021bii care dac\u0103 rezolvate, ne-ar da r\u0103spunsul exact. Deoarece num\u0103rul de produse pe care ma\u0219inile \u00eel produc cre\u0219te pe m\u0103sur\u0103 ce cre\u0219te timpul alocat, ne putem g\u00e2ndi la o c\u0103utare binar\u0103 pe r\u0103spuns.</p> <p>Astfel, la un pas al c\u0103ut\u0103rii binare putem evalua dac\u0103 \\(f(x) \\geq t\\), unde \\(f(x)\\) este num\u0103rul de produse pe care fabrica le poate produce \u00een \\(x\\) unit\u0103\u021bi de timp. Dup\u0103 ce avem grij\u0103 la evaluarea func\u021biei pentru a evita overflow-ul, solu\u021bia nu este complicat\u0103.</p> <pre><code>#include &lt;iostream&gt;\n#include &lt;vector&gt;\n\nusing namespace std;\n\nint n, k;\nvector&lt;int&gt; v;\n\n// aici calculam f(x)\n\nlong long f(long long x) {\n    long long cnt = 0;\n\n    for (int i = 0; i &lt; n; i++) {\n        cnt += x / v[i];\n        if (cnt &gt;= k) {  // pentru a evita overflow-ul\n            return cnt;\n        }\n    }\n    return cnt;\n}\n\nint main() {\n    cin &gt;&gt; n &gt;&gt; k;\n    v.resize(n);\n\n    for (int i = 0; i &lt; n; i++) {\n        cin &gt;&gt; v[i];\n    }\n\n    long long L = 0;\n    long long R = 1e18;\n    long long ans = R;\n\n    while (L &lt;= R) {\n        long long mid = (L + R) / 2;\n\n        if (f(mid) &gt;= k) {\n            ans = mid;\n            R = mid - 1;\n        } else {\n            L = mid + 1;\n        }\n    }\n\n    cout &lt;&lt; ans;\n    return 0;\n}\n</code></pre>","tags":["vectori","sortare","cautare","optimizare"]},{"location":"usor/binary-search/#cautarea-binara-pe-numere-reale","title":"C\u0103utarea binar\u0103 pe numere reale","text":"<p>Pentru a c\u0103uta binar pe numere reale, trebuie s\u0103 avem grij\u0103 la un detaliu foarte important. Deoarece avem nevoie de o precizie de c\u00e2teva zecimale (de regul\u0103, un num\u0103r mai mare, cel pu\u021bin 6), trebuie s\u0103 evit\u0103m situa\u021biile \u00een care r\u0103m\u00e2nem bloca\u021bi \u00eentr-un loop infinit, pericol \u00een care ne-am putea afla folosind abordarea existent\u0103.</p> <p>Astfel, solu\u021bia care se impune este folosirea unui for pentru a fixa num\u0103rul de itera\u021bii (de regul\u0103, nu mai mare de 100, \u00een cele mai multe cazuri 50 de itera\u021bii ale func\u021biei sunt \u00eendeajuns).</p> <pre><code>int f(int x) {\n    // codul functiei\n}\n\ndouble cb_double() {\n    double l = 0;\n    double r = 1e9;\n    double ans = r;\n\n    for (int i = 1; i &lt;= 100; i++) {\n        if (f(mij)) {\n            ans = mij;\n            r = mij;\n        } else {\n            l = mij;\n        }\n    }\n    return ans;\n}\n</code></pre>","tags":["vectori","sortare","cautare","optimizare"]},{"location":"usor/binary-search/#problema-equation-de-pe-codeforces-edu","title":"Problema Equation de pe Codeforces Edu","text":"<p>Observa\u021bie</p> <p>Pentru a accesa aceast\u0103 problem\u0103, trebuie s\u0103 v\u0103 \u00eenregistra\u021bi \u00een prealabil la aceste cursuri, intr\u00e2nd \u00een sec\u021biunea ITMO Academy - Pilot Course, pe care o g\u0103si\u021bi aici</p> <p>De\u0219i aceast\u0103 problem\u0103 poate fi rezolvat\u0103 \u0219i folosind ecua\u021bii matematice, c\u0103utarea binar\u0103 a r\u0103spunsului devine o solu\u021bie elegant\u0103 care evit\u0103 complica\u021bii f\u0103r\u0103 rost. Fix\u00e2nd un num\u0103r de 100 de itera\u021bii, se ajunge la r\u0103spuns foarte simplu \u0219i eficient.</p> <pre><code>#include &lt;cmath&gt;\n#include &lt;iomanip&gt;  // pentru afisarea cu precizie fixa\n#include &lt;iostream&gt;\n\nusing namespace std;\n\nconst double eps = 1e-6;  // pentru compararea raspunsului\n\nint main() {\n    double val;\n    cin &gt;&gt; val;\n\n    double L = 0;\n    double R = 200000;\n    double ans;\n\n    for (int iter = 1; iter &lt;= 100; iter++) {\n        double mid = (L + R) * 0.5000;\n        double expr = mid * mid + sqrt(mid);\n        if (expr - val &gt;= eps) {\n            ans = mid;\n            R = mid;\n        } else {\n            L = mid;\n        }\n    }\n\n    cout &lt;&lt; fixed &lt;&lt; setprecision(10) &lt;&lt; ans &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["vectori","sortare","cautare","optimizare"]},{"location":"usor/binary-search/#functii-de-sistem-pentru-cautarea-binara","title":"Func\u021bii de sistem pentru c\u0103utarea binar\u0103","text":"<p>De\u0219i multe structuri de date din STL au c\u0103utarea binar\u0103 drept o parte esen\u021bial\u0103 a func\u021bionalit\u0103\u021bii lor, ne vom concentra strict pe cele care opereaz\u0103 pe un vector ordonat cresc\u0103tor, toate aceste func\u021bii plec\u00e2nd de la aceast\u0103 presupunere.</p> <p>Func\u021biile de sistem care se bazeaz\u0103 pe c\u0103utarea binar\u0103 sunt urm\u0103toarele:</p> <ul> <li><code>std::binary_search</code>: Verific\u0103 dac\u0103 o valoare dat\u0103 se afl\u0103 \u00een intervalul   men\u021bionat.</li> <li><code>std::lower_bound</code>: G\u0103se\u0219te prima pozi\u021bie unde valoarea dat\u0103 poate fi   inserat\u0103 f\u0103r\u0103 a strica ordinea elementelor deja existente.</li> <li><code>std::upper_bound</code>: G\u0103se\u0219te prima pozi\u021bie cu proprietatea c\u0103 elementele de   la acea pozi\u021bie \u00eencolo sunt strict mai mari dec\u00e2t valoarea dat\u0103.</li> <li><code>std::equal_range</code>: G\u0103se\u0219te intervalul de pozi\u021bii care au valori egale cu   valoarea dat\u0103 (echivalentul aplic\u0103rii lower_bound \u0219i upper_bound).</li> </ul> <pre><code>#include &lt;algorithm&gt;\n#include &lt;iostream&gt;\n#include &lt;vector&gt;\n\nusing namespace std;\n\nint main() {\n    vector&lt;int&gt; vec = {1, 3, 5, 7, 9};\n    if (binary_search(vec.begin(), vec.end(), 5)) {\n        cout &lt;&lt; \"5 a fost gasit\" &lt;&lt; '\\n';\n    } else {\n        cout &lt;&lt; \"5 nu a fost gasit\" &lt;&lt; '\\n';\n    }\n\n    // aceste functii afla pozitiile din vector corespunzatoare acestor operatii\n    auto it = (std::lower_bound(vec.begin(), vec.end(), 5) - vec.begin());\n    cout &lt;&lt; it &lt;&lt; \" \";\n\n    it = (std::upper_bound(vec.begin(), vec.end(), 5) - vec.begin());\n    cout &lt;&lt; it &lt;&lt; \" \";\n    return 0;\n}\n</code></pre>","tags":["vectori","sortare","cautare","optimizare"]},{"location":"usor/binary-search/#concluzii","title":"Concluzii","text":"<p>C\u0103utarea binar\u0103 este unul dintre cele mai fundamentale metode ale algoritmicii, fiind absolut necesar pentru a optimiza probleme unde ni se cere s\u0103 determin\u0103m existen\u021ba unei valori \u00eentr-un \u0219ir, sau determinarea unui num\u0103r maxim/minim care s\u0103 respecte o condi\u021bie impus\u0103 de problem\u0103 etc.</p> <p>Acest algoritm este unul din cele mai populari algoritmi dat at\u00e2t la olimpiade, c\u00e2t \u0219i la rundele de Codeforces, reg\u0103sindu-se frecvent drept subproblem\u0103 \u00een multe probleme foarte celebre, precum \u0219i fiind la baza multor implement\u0103ri ale unor algoritmi mai complica\u021bi.</p>","tags":["vectori","sortare","cautare","optimizare"]},{"location":"usor/binary-search/#probleme-suplimentare","title":"Probleme suplimentare","text":"<ul> <li>Problema cautbin - Infoarena</li> <li>bete2 infoarena</li> <li>cb2 pbinfo</li> <li>Problemele din pasul 1 de la EDU</li> <li>nrtri infoarena</li> <li>Codeforces Cellular Network</li> <li>USACO Bronze Social Distancing I</li> <li>OJI 2016 pic</li> <li>ONI 2016 dif2</li> <li>USACO Silver Convention</li> <li>OJI 2019 mostenire</li> <li>ONI 2017 orase</li> <li>ONI 2017 orase</li> <li>zone infoarena</li> <li>Problemele din pasul 2 de la EDU</li> <li>cb3 pbinfo</li> <li>Baraj Juniori 2021 intergalactic</li> <li>ONI 2018 plaja</li> <li>USACO Silver Loan Repayment</li> <li>Problemele cu cautare binara de pe kilonova</li> <li>Problemele cu cautare binara de pe codeforces</li> <li>Problemele cu cautare binara de pe infoarena</li> </ul>","tags":["vectori","sortare","cautare","optimizare"]},{"location":"usor/binary-search/#resurse-suplimentare","title":"Resurse suplimentare","text":"<ul> <li>Binary Search - USACO Guide</li> <li>Cursurile Edu de pe Codeforces, este necesar\u0103 \u00eenregistrarea anterioar\u0103</li> <li>Cautare binara - CPPI Sync</li> <li>Cautare binara - pbinfo</li> </ul>","tags":["vectori","sortare","cautare","optimizare"]},{"location":"usor/complexity/","title":"Complexit\u0103\u021bi","text":"","tags":["notiuni de baza","memorie","timp"]},{"location":"usor/complexity/#introducere","title":"Introducere","text":"<p>Atunci c\u00e2nd elabor\u0103m un algoritm, vrem s\u0103 \u0219tim c\u00e2t de rapid va fi, pentru a putea decide dac\u0103 are sens s\u0103 trecem la implementarea lui propriu-zis\u0103. Un mod de a m\u0103sura calitatea unui algoritm este dat de complexitatea pe care \u00eel are. \u00cen cele ce urmeaz\u0103 vom discuta acest concept \u0219i modul \u00een care \u00eel putem aplica \u00een probleme.</p> <p>Complexitatea unui algoritm reprezint\u0103 o m\u0103sur\u0103 a eficien\u021bei acestuia \u00een func\u021bie de dimensiunea intr\u0103rii. O bun\u0103 \u00een\u021belegere a complexit\u0103\u021bii este esen\u021bial\u0103 pentru a putea alege cel mai potrivit algoritm pentru o problem\u0103 dat\u0103.</p> <p>Imagina\u021bi-v\u0103 c\u0103 trebuie s\u0103 c\u0103uta\u021bi un cuv\u00e2nt \u00eentr-un dic\u021bionar. Dac\u0103 \u00eel c\u0103uta\u021bi pagin\u0103 cu pagin\u0103, procesul este lent. Dac\u0103 folosi\u021bi metoda c\u0103ut\u0103rii binare (deschiz\u00e2nd cartea pe la mijloc \u0219i elimin\u00e2nd jum\u0103tate din pagini la fiecare pas), ve\u021bi ajunge mult mai repede la rezultat.</p>","tags":["notiuni de baza","memorie","timp"]},{"location":"usor/complexity/#complexitatea-de-timp","title":"Complexitatea de timp","text":"<p>Pentru a calcula complexitatea de timp a unui algoritm, trebuie s\u0103 avem \u00een vedere c\u0103 \u00een practic\u0103, procesoarele moderne pot procesa aproximativ \\(3 \\cdot 10^8\\) opera\u021bii simple pe secund\u0103, acest num\u0103r depinz\u00e2nd \u00een func\u021bie de contextul unde trebuie rezolvat\u0103 problema (anumite site-uri sunt mai rapide dec\u00e2t altele \u0219i anumite evaluatoare de la concursurile oficiale sunt mai rapide dec\u00e2t altele).</p> <p>Observa\u021bie</p> <p>\u00cen concursuri, folosirea valorii de \\(10^8\\) opera\u021bii pe secund\u0103 este o estimare precis\u0103, care este folosit\u0103 de regul\u0103 \u0219i de propun\u0103torii de probleme atunci c\u00e2nd se decid limitele de timp.</p> <p>Prin opera\u021bie \u201esimpl\u0103\u201d \u00een\u021belegem concret o opera\u021bie care dureaz\u0103 un timp constant, indiferent de m\u0103rimea intr\u0103rii. Exemple de opera\u021bii simple includ opera\u021biile aritmetice simple, increment\u0103rile, opera\u021biile pe bi\u021bi etc., iar exemple care nu sunt simple includ aflarea radicalului, aflarea restului \u00eemp\u0103r\u021birii etc.</p> <p>\u00cen general, constantele mici pot fi ignorate \u00een calculul complexitatilor. De exemplu, \\(\\mathcal{O}(N)\\) este echivalent cu \\(\\mathcal{O}(c \\cdot N)\\) pentru un \\(c &gt; 0\\). Mai jos pute\u021bi g\u0103si exemple de cod, \u00eempreun\u0103 cu complexit\u0103\u021bile lor.</p> <p>Acest cod are complexitatea \\(\\mathcal{O}(1)\\), opera\u021biile fiind constante.</p> <pre><code>int a = 5;\nint b = 7;\nint c = 4;\nint d = a + b + c + 153;\n</code></pre> <p>Aceste coduri au complexitatea \\(\\mathcal{O}(n)\\), num\u0103rul de opera\u021bii fiind cel f\u0103cut \u00een structura repetitiv\u0103.</p> <pre><code>for (int i = 1; i &lt;= n; i++) {\n    // Cod \u00een timp constant\n}\n</code></pre> <pre><code>int i = 0;\n\nwhile (i &lt; n) {\n    // Cod \u00een timp constant\n    i++;\n}\n</code></pre> <p>\u00cen ciuda constantelor care apar, codurile au din nou complexitatea \\(\\mathcal{O}(n)\\). Aceste coduri au complexitatea \\(\\mathcal{O}(n)\\), num\u0103rul de opera\u021bii fiind cel f\u0103cut \u00een structura repetitiv\u0103.</p> <pre><code>for (int i = 1; i &lt;= 5 * n + 17; i++) {\n    // Cod \u00een timp constant\n}\n</code></pre> <pre><code>for (int i = 1; i &lt;= n + 758458; i++) {\n    // Cod \u00een timp constant\n}\n</code></pre> <p>Dac\u0103 avem de-a face cu mai multe structuri repetitive imbricate, complexitatea se va \u00eenmul\u021bi, complexitatea codului de mai jos este \\(\\mathcal{O}(n \\cdot m)\\).</p> <pre><code>for (int i = 1; i &lt;= n; i++) {\n    for (int j = 1; j &lt;= m; j++) {\n        // Cod \u00een timp constant\n    }\n}\n</code></pre> <p>Dac\u0103 avem de-a face cu diverse repetitive imbricate \u00een diferite blocuri de cod, complexitatea va deveni egal\u0103 cu cea mai costisitoare structur\u0103 de acest gen, complexitatea se va \u00eenmul\u021bi, complexitatea codului de mai jos este \\(\\mathcal{O}(n \\cdot m)\\), \u00een ciuda buc\u0103\u021bii care are complexitate \\(\\mathcal{O}(n)\\).</p> <pre><code>for (int i = 1; i &lt;= n; i++) {\n    for (int j = 1; j &lt;= n; j++) {\n        // Cod \u00een timp constant\n    }\n}\n\nfor (int i = 1; i &lt;= m; i++) {\n    // Cod \u00een timp constant\n}\n</code></pre> <p>Aten\u021bie</p> <p>O gre\u0219eal\u0103 care se face deseori este s\u0103 presupunem c\u0103 o complexitate \\(\\mathcal{O}(f(n))\\) se men\u021bine pentru valori mici. C\u00e2nd calcul\u0103m complexit\u0103\u021bile, ignor\u0103m constantele pentru c\u0103 vrem s\u0103 analiz\u0103m algoritmul c\u00e2nd \\(n\\) devine din ce \u00een ce mai mare. Ne intereseaz\u0103 deci rata \u00een care cre\u0219te timpul de execu\u021bie, dar asta nu ne zice nimic legat de timpul concret. Pentru valori mici, nu avem voie s\u0103 ignor\u0103m constantele \u0219i al\u021bi termeni, deoarece constantele conteaz\u0103 enorm. Din acest punct de vedere, putem vedea \\(\\mathcal{O}\\) ca fiind cazul cel mai r\u0103u al unui algoritm. Nota\u021bia nu ne zice nimic de cum ruleaz\u0103 algoritmul \u00een medie sau \u00een cel mai bun caz.</p> <p>De pild\u0103, dac\u0103 avem un algoritm \\(\\mathcal{O}(n)\\) pentru care fiecare opera\u021bie dureaz\u0103 50ms (am putea reprezenta asta ca \\(\\mathcal{O}(50n)\\)), acesta va fi mai \u00eencet dec\u00e2t un algoritm \\(\\mathcal{O}(5n^2)\\), unde fiecare opera\u021bie dureaz\u0103 5ms pentru \\(n &lt; 10\\). Fiecare opera\u021bie are un cost \u0219i exist\u0103 foarte mul\u021bi factori care pot influen\u021ba cum ruleaz\u0103 un algoritm (performan\u021ba procesorului, memoria disponibil\u0103, cum acceseaz\u0103 programul memoria, ce opera\u021bii au loc etc.). Un algoritm \\(\\mathcal{O}(2n)\\) va fi de 2 ori mai rapid dec\u00e2t unul \\(\\mathcal{O}(4n)\\), de\u0219i ele cresc \u00een acela\u0219i fel. Deci nu v\u0103 baza\u021bi pe complexit\u0103\u021bi dac\u0103 vre\u021bi s\u0103 compara\u021bi concret doi algoritmi sau dou\u0103 structuri de date; face\u021bi teste.</p>","tags":["notiuni de baza","memorie","timp"]},{"location":"usor/complexity/#exemple-de-complexitati-de-timp","title":"Exemple de complexit\u0103\u021bi de timp","text":"<p>Aici prezent\u0103m c\u00e2teva exemple de complexit\u0103\u021bi, care vor fi utile pe parcurs. Nu este nevoie s\u0103 \u0219ti\u021bi algoritmii de aici \u00eenc\u0103, ei vor fi prezenta\u021bi \u0219i \u00eenv\u0103\u021ba\u021bi de-a lungul parcursului vostru \u00een lumea algoritmicii.</p> <ul> <li>Formule matematice care calculeaz\u0103 un r\u0103spuns: \\(\\mathcal{O}(1)\\)</li> <li>C\u0103utarea binar\u0103: \\(\\mathcal{O}(\\log n)\\)</li> <li>Folosirea unor structuri de date precum set, map: \\(\\mathcal{O}(\\log n)\\) per opera\u021bie</li> <li>Aflarea divizorilor unui num\u0103r: \\(\\mathcal{O}(\\sqrt{n})\\)</li> <li>Citirea sau parcurgerea a \\(n\\) valori: \\(\\mathcal{O}(n)\\)</li> <li>Sortarea unui vector cu \\(n\\) valori: de obicei \\(\\mathcal{O}(n \\log n)\\)</li> <li>Parcurgerea tuturor submul\u021bimilor de lungime 2: \\(\\mathcal{O}(n^2)\\).</li> <li>Parcurgerea tuturor submul\u021bimilor: \\(\\mathcal{O}(2^n)\\)</li> <li>Parcurgerea tuturor permut\u0103rilor: \\(\\mathcal{O}(n!)\\)</li> </ul>","tags":["notiuni de baza","memorie","timp"]},{"location":"usor/complexity/#complexitatea-de-memorie","title":"Complexitatea de memorie","text":"<p>\u00cen cazul complexit\u0103\u021bii de memorie, trebuie s\u0103 avem \u00een vedere \u0219i tipul de date folosit.</p> <p>Dintre cele mai frecvente tipuri de date, putem enumera urm\u0103toarele:</p> <ul> <li>tipul <code>int</code>: 4 octe\u021bi, limite \u00eentre \\(-2^{31}\\) si \\(2^{31} - 1\\) (\\(-2 \\ 147   \\ 483 \\ 648\\) si \\(2 \\ 147 \\ 483 \\ 647\\)).</li> <li>tipul <code>short</code>: 2 octe\u021bi, limite \u00eentre \\(-2^{15}\\) si \\(2^{15} - 1\\) (\\(-32 \\   768\\) si \\(32 \\ 767\\)).</li> <li>tipul <code>char</code>: 1 octet, limite \u00eentre \\(-128\\) si 127.</li> <li>tipul <code>bool</code>: 1 octet, accepta doar 0 sau 1.</li> <li>tipul <code>long long</code>: 8 octe\u021bi, limite \u00eentre \\(-2^{63}\\) si \\(2^{63} - 1\\) (\\(-9   \\ 223 \\ 372 \\ 036 \\ 854 \\ 775 \\ 808\\) si \\(9 \\ 223 \\ 372 \\ 036 \\ 854 \\ 775 \\   807\\)) \u2014 numere de maxim 19 cifre.</li> </ul> <p>\u00cen privin\u021ba tipurilor reale, putem enumera urm\u0103toarele:</p> <ul> <li>tipul <code>float</code>: 4 octe\u021bi, limite \u00eentre aproximativ \\(-10^{38}\\) \u0219i \\(10^{38}\\).</li> <li>tipul <code>double</code>: 8 octe\u021bi, limite \u00eentre aproximativ \\(-10^{208}\\) \u0219i   \\(10^{208}\\).</li> <li>tipul <code>long double</code>: \u00een func\u021bie de standardul de compilare, cel pu\u021bin 8   octe\u021bi, limite mai mari dec\u00e2t cele de la <code>double</code>.</li> </ul> <p>De exemplu, dac\u0103 avem un vector de \\(10^6\\) elemente de tipul <code>int</code> \u0219i altul de \\(10^5\\) elemente de tipul <code>long long</code>, vom folosi \\(4 \\cdot 10^6 + 8 \\cdot 10^5 = 4.8 \\cdot 10^6\\) octe\u021bi = 4.8 MB.</p> <p>Este foarte important \u00een cazul complexit\u0103\u021bilor de memorie s\u0103 ave\u021bi \u00een vedere faptul c\u0103 \u00een general la concursuri, se ia \u00een considerare memoria a\u0219a cum e declarat\u0103 la \u00eenceput, \u0219i nu ce folose\u0219ti pe parcurs. Astfel, este foarte important pe c\u00e2t posibil s\u0103 nu declara\u021bi mai mult\u0103 memorie dec\u00e2t folosi\u021bi \u0219i s\u0103 ave\u021bi grij\u0103 la c\u00e2t\u0103 memorie aloca\u021bi, pentru a evita \u0219i situa\u021bia \u00een care aloca\u021bi mai pu\u021bin dec\u00e2t trebuie.</p> <p>Pe scurt, e important s\u0103 citi\u021bi cu aten\u021bie restric\u021biile din enun\u021burile problemelor.</p>","tags":["notiuni de baza","memorie","timp"]},{"location":"usor/complexity/#complexitati-acceptabile-pentru-diverse-restrictii","title":"Complexit\u0103\u021bi acceptabile pentru diverse restric\u021bii","text":"<p>Acestea sunt aproxim\u0103ri pentru diverse clase de complexit\u0103\u021bi, trebuie s\u0103 ave\u021bi \u00een vedere limita de timp \u0219i sfaturile date anterior, \u00eempreun\u0103 cu particularit\u0103\u021bile problemei.</p> \\(n\\) Complexit\u0103\u021bi posibile \\(n \\leq 10\\) \\(\\mathcal{O}(n!)\\), \\(\\mathcal{O}(n^7)\\), \\(\\mathcal{O}(n^6)\\) \\(n \\leq 20\\) \\(\\mathcal{O}(2^n \\cdot n)\\), \\(\\mathcal{O}(n^5)\\) \\(n \\leq 100\\) \\(\\mathcal{O}(n^4)\\) \\(n \\leq 500\\) \\(\\mathcal{O}(n^3)\\) \\(n \\leq 10 \\ 000\\) \\(\\mathcal{O}(n^2)\\) \\(n \\leq 10^5\\) \\(\\mathcal{O}(n \\sqrt n)\\) \\(n \\leq 5 \\cdot 10^5\\) \\(\\mathcal{O}(n \\log n)\\) \\(n \\leq 10^7\\) \\(\\mathcal{O}(n)\\) \\(n \\leq 10^{18}\\) \\(\\mathcal{O}(\\log^2 n)\\), \\(\\mathcal{O}(\\log n)\\), \\(\\mathcal{O}(1)\\)","tags":["notiuni de baza","memorie","timp"]},{"location":"usor/complexity/#concluzii","title":"Concluzii","text":"<p>Complexit\u0103\u021bile reprezint\u0103 o parte fundamental\u0103 din rezolvarea fiec\u0103rei probleme \u0219i \u00een\u021belegerea principiilor din spatele modului \u00een care se calculeaz\u0103 este necesar\u0103 pentru oricine dore\u0219te s\u0103 aprofundeze studiul algoritmicii. Aceste informa\u021bii prezentate aici vor fi esen\u021biale pentru rezolvarea tuturor problemelor de algoritmic\u0103.</p>","tags":["notiuni de baza","memorie","timp"]},{"location":"usor/complexity/#lectura-suplimentara","title":"Lectur\u0103 suplimentar\u0103","text":"<ul> <li>Complexitati - USACO Guide</li> <li>Time complexity - Wikipedia</li> <li>A Time Complexity Guide - Codeforces</li> <li>How to determine the solution of a problem by looking at its constraints? - Codeforces</li> </ul>","tags":["notiuni de baza","memorie","timp"]},{"location":"usor/digits-manipulation/","title":"Prelucrarea cifrelor","text":"<p>Observa\u021bie</p> <p>Multe probleme de OJI clasa a 5-a necesit\u0103 lucrul cu cifrele unui num\u0103r, o astfel de problem\u0103 g\u0103sindu-se aproape \u00een fiecare an.</p>","tags":["cifre","matematica","structura repetitiva"]},{"location":"usor/digits-manipulation/#numerele-de-cel-mult-trei-cifre","title":"Numerele de cel mult trei cifre","text":"<p>Pentru a introduce conceptul, vom pleca de la cazurile cele mai simple, \u0219i anume numerele cu cel mult trei cifre. Ele apar \u00een multe probleme, iar de\u0219i metodele pe care le vom explica aici le putem folosi \u0219i pentru numere cu mai multe cifre, nu este practic s\u0103 le folosim deoarece putem folosi structurile repetitive \u00eentr-un mod mai simplu \u0219i eficient.</p> <p>Dac\u0103 vrem s\u0103 afl\u0103m cifrele unui num\u0103r cu cel mult 3 cifre, putem s\u0103 ne folosim de diverse rela\u021bii matematice pentru a le afla, \u00eencep\u00e2nd de la ultima la prima.</p> <p>Ultima cifr\u0103</p> <p>Definim ultima cifr\u0103 a unui num\u0103r natural \\(x\\) ca fiind cea mai nesemnificativ\u0103 cifr\u0103 a acestuia. De exemplu, dac\u0103 \\(x = 491\\), ultima cifr\u0103 a acestui num\u0103r este 1.</p> <p>Pentru a afla aceast\u0103 cifr\u0103, ne vom folosi de proprietatea c\u0103 aceasta este egal\u0103 cu restul \u00eemp\u0103r\u021birii num\u0103rului la 10, ceea ce ne va da rezultatul dorit.</p> <p>Pentru a afla urm\u0103toarele cifre, avem mai multe variante. Fie \u00eemp\u0103r\u021bim num\u0103rul la 10 \u0219i afl\u0103m de fiecare dat\u0103 noua cifr\u0103 a unit\u0103\u021bilor la fel ca la pasul precedent, fie vom folosi o formul\u0103 modificat\u0103 pe care o vom prezenta aici:</p> <p>A \\(k\\)-a cifr\u0103 de la coad\u0103</p> <p>Pentru a afla cea de-a \\(k\\)-a cifr\u0103 de la coad\u0103 a unui num\u0103r natural \\(x\\), vom folosi formula $$ \\frac{x}{10^{k-1}} \\% \\ 10 $$ sau, cum am scrie \u00een limbajul C/C++, <code>(x/p) % 10</code>.</p> <p>Observa\u021bie</p> <p>\u00cen formula anterioar\u0103, \\(p\\) este egal cu \\(10^{k-1}\\). De\u0219i se poate folosi formula <code>pow(10, k-1)</code> din <code>&lt;cmath&gt;</code>, nu recomand\u0103m folosirea acestei instruc\u021biuni din cauza erorilor de precizie ce apar \u00een cazul numerelor mai mari. Recomand\u0103m calcularea expresiei \\(10^x\\) folosind o instruc\u021biune repetitiv\u0103 de tip for.</p> <p>Mai jos pute\u021bi vedea o secven\u021b\u0103 de cod \u00een care prezent\u0103m ambele metode, care func\u021bioneaz\u0103 pentru numerele de cel mult trei cifre.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int n;  // numar natural cel mult egal cu 999\n    cin &gt;&gt; n;\n\n    // cifrele luate una dupa alta, fara impartiri\n\n    int ultima = n % 10;\n    int penultima = (n / 10) % 10;\n    int antepenultima = (n / 100) % 10;\n\n    cout &lt;&lt; antepenultima &lt;&lt; \" \" &lt;&lt; penultima &lt;&lt; \" \" &lt;&lt; ultima &lt;&lt; '\\n';\n\n    // cifrele luate una dupa alta, cu impartiri\n\n    ultima = n % 10;\n    n = n / 10;\n    penultima = n % 10;\n    n = n / 10;\n    antepenultima = n % 10;\n    n = n / 10;\n\n    cout &lt;&lt; antepenultima &lt;&lt; \" \" &lt;&lt; penultima &lt;&lt; \" \" &lt;&lt; ultima &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["cifre","matematica","structura repetitiva"]},{"location":"usor/digits-manipulation/#numerele-de-lungime-oarecare","title":"Numerele de lungime oarecare","text":"<p>Acum c\u0103 am \u00eenv\u0103\u021bat cum s\u0103 afl\u0103m cifrele unui num\u0103r, vom generaliza modul de aflare a cifrelor unui num\u0103r \u00een general.</p> <p>Deoarece nu putem depinde la nesf\u00e2r\u0219it de metodele de mai sus din lipsa de practicabilitate ale acestora, trebuie s\u0103 ne g\u00e2ndim la o metod\u0103 ce folose\u0219te o structur\u0103 repetitiv\u0103 pentru a afla cifrele unui num\u0103r \\(n\\).</p> <p>De obicei, deoarece nu \u0219tim c\u00e2te cifre va avea \\(n\\), vom folosi instruc\u021biunea <code>while</code> deoarece aceasta ne d\u0103 flexibilitatea s\u0103 ne oprim atunci c\u00e2nd num\u0103rul nostru nu mai are cifre.</p> <p>Observa\u021bie</p> <p>\u00cen multe probleme, se poate \u00eent\u00e2mpla ca \\(n\\) s\u0103 fie egal cu 0 \u00eenc\u0103 de la \u00eenceput. \u00cen codurile cu <code>while</code>, vom pune de regul\u0103 un <code>if</code> adi\u021bional care se ocup\u0103 de acest caz particular. O alternativ\u0103 este folosirea instruc\u021biunii <code>do-while</code></p> <p>Un cod tipic pentru aflarea cifrelor unui num\u0103r de la ultima la prima va ar\u0103ta a\u0219a:</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int n;\n    cin &gt;&gt; n;\n\n    if (n == 0) {\n        // caz particular daca n = 0\n    }\n\n    while (n &gt; 0) {\n        int c = n % 10;\n        n = n / 10;\n    }\n    return 0;\n}\n</code></pre> <p>De regul\u0103, opera\u021biile ce \u021bin de cifrele g\u0103site se vor efectua \u00een while, indiferent c\u0103 e vorba de g\u0103sirea unor valori auxiliare, num\u0103rarea cifrelor care respect\u0103 o anumit\u0103 proprietate sau calcularea unor sume, maxime etc.</p>","tags":["cifre","matematica","structura repetitiva"]},{"location":"usor/digits-manipulation/#problema-suma-cifrelor-unui-numar","title":"Problema Suma cifrelor unui num\u0103r","text":"<p>Pentru a afla suma cifrelor unui num\u0103r, vom folosi algoritmul prezentat anterior \u0219i vom aduna la r\u0103spuns valoarea cifrei curente.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int n;\n    cin &gt;&gt; n;\n\n    int s = 0;\n    while (n &gt; 0) {\n        s = s + n % 10;\n        n = n / 10;\n    }\n\n    cout &lt;&lt; s;\n    return 0;\n}\n</code></pre>","tags":["cifre","matematica","structura repetitiva"]},{"location":"usor/digits-manipulation/#problema-control","title":"Problema Control","text":"<p>Cifra de control este un concept ce se reg\u0103se\u0219te frecvent \u00een problemele de algoritmic\u0103 rom\u00e2ne\u0219ti, mai ales la problemele din examene sau problemele mai u\u0219oare de olimpiad\u0103.</p> <p>Cifra de control</p> <p>Cifra de control a unui num\u0103r \\(x\\) reprezint\u0103 valoarea pe care o ob\u021binem dac\u0103 at\u00e2ta timp c\u00e2t \\(x &gt; 9\\), adun\u0103m cifrele din care este compus \\(x\\), iar \\(x\\) va deveni egal cu suma rezultat\u0103. \u00centr-un final, num\u0103rul de o cifr\u0103 ob\u021binut este cifra de control a lui \\(x\\).</p> <p>Exemplu</p> <p>De exemplu, s\u0103 analiz\u0103m num\u0103rul 1954.</p> <ul> <li>\\(x = 1954\\), suma cifrelor este \\(1 + 9 + 5 + 4 = 19\\).</li> <li>\\(x = 19\\), suma cifrelor este \\(1 + 9 = 10\\).</li> <li>\\(x = 10\\), suma cifrelor este \\(1 + 0 = 1\\).</li> <li>\\(x = 1\\), num\u0103rul are o cifr\u0103, deci cifra de control este 1.</li> </ul> <p>Criteriul de divizibilitate cu 9 (\u00eenv\u0103\u021bat la matematic\u0103 \u00een clasa a 5-a) spune c\u0103 \\(x\\) \u0219i suma cifrelor lui \\(x\\) dau acela\u0219i rest la \u00eemp\u0103r\u021birea cu 9. \u00cen particular, se poate observa faptul c\u0103 cifra de control este fix rezultatul opera\u021biei \\(x \\% 9\\), cu dou\u0103 particularit\u0103\u021bi pe care trebuie s\u0103 le avem \u00een vedere:</p> <ul> <li>Dac\u0103 \\(x = 0\\), cifra de control a lui \\(x\\) este 0</li> <li>Dac\u0103 \\(x\\% 9 = 0\\), cifra de control a lui \\(x\\) este 9.</li> </ul> <p>Mai jos pute\u021bi g\u0103si implement\u0103ri folosind at\u00e2t formula simplificat\u0103, c\u00e2t \u0219i simularea r\u0103spunsului.</p> Simularea r\u0103spunsuluiFormula simplificat\u0103 <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int n;\n    cin &gt;&gt; n;\n\n    // cat timp n &gt; 9, aflam suma cifrelor si modificam n\n    while (n &gt; 9) {\n        int n2 = n;\n        n = 0;\n        while (n2) {\n            n += n2 % 10;\n            n2 /= 10;\n        }\n    }\n\n    cout &lt;&lt; n &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int n;\n    cin &gt;&gt; n;\n\n    if (n == 0) {\n        cout &lt;&lt; 0 &lt;&lt; '\\n';\n    } else {\n        if (n % 9 == 0) {\n            cout &lt;&lt; 9 &lt;&lt; '\\n';\n        } else {\n            cout &lt;&lt; n % 9 &lt;&lt; '\\n';\n        }\n    }\n\n    return 0;\n}\n</code></pre>","tags":["cifre","matematica","structura repetitiva"]},{"location":"usor/digits-manipulation/#problema-oglinditul-unui-numar","title":"Problema Oglinditul unui num\u0103r","text":"<p>Oglinditul unui num\u0103r</p> <p>Oglinditul unui num\u0103r \\(n\\) reprezint\u0103 num\u0103rul scris de la dreapta la st\u00e2nga. De exemplu, dac\u0103 \\(x = 491301\\), oglinditul lui \\(x\\) este 103194. Dac\u0103 num\u0103rul con\u021bine cifre de 0 la sf\u00e2r\u0219itul num\u0103rului, acestea vor fi ignorate \u00een oglindit.</p> <p>Numere palindrom</p> <p>Dac\u0103 \\(x\\) \u0219i oglinditul lui \\(x\\) sunt egali, atunci putem spune c\u0103 \\(x\\) este un num\u0103r palindrom. De exemplu, 33133 \u0219i 49594 sunt numere palindrom. Cu alte cuvinte, un num\u0103r palindrom este un num\u0103r care se scrie la fel de la st\u00e2nga la dreapta \u0219i invers.</p> <p>Pentru a afla oglinditul unui num\u0103r, vom folosi algoritmul prezentat anterior, \u00eempreun\u0103 cu \u021binerea unei variabile care s\u0103 ne \u021bin\u0103 num\u0103rul inversat.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main () {\n    int n; \n    cin &gt;&gt; n;\n\n    int og = 0;\n    while (n &gt; 0) {\n        og = og * 10 + n % 10;\n        n = n / 10;\n    }\n\n    cout &lt;&lt; og;\n    return 0;\n}\n</code></pre>","tags":["cifre","matematica","structura repetitiva"]},{"location":"usor/digits-manipulation/#problema-aparitii2","title":"Problema Aparitii2","text":"<p>Pentru a afla de c\u00e2te ori apare prima cifr\u0103 a num\u0103rului dat, mai \u00eent\u00e2i va trebui s\u0103 afl\u0103m care este prima cifr\u0103, iar mai apoi, vom parcurge num\u0103rul din nou pentru a num\u0103ra apari\u021biile primei cifre.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int n;\n    cin &gt;&gt; n;\n\n    int n2 = n;\n    while (n2 &gt;= 10) {\n        n2 /= 10;\n    }\n\n    int aparitii = 1;  // prima cifra, evitam tratarea separata a cazului n = 0\n    while (n &gt;= 10) {\n        if (n % 10 == n2) {\n            aparitii++;\n        }\n        n = n / 10;\n    }\n\n    cout &lt;&lt; aparitii;\n    return 0;\n}\n</code></pre>","tags":["cifre","matematica","structura repetitiva"]},{"location":"usor/digits-manipulation/#probleme-suplimentare","title":"Probleme suplimentare","text":"<ul> <li>NumarulDeCifre pbinfo</li> <li>UltimaCifraPara pbinfo</li> <li>ProdusCifreImpare pbinfo</li> <li>prod_k pbinfo</li> <li>aparitii pbinfo</li> <li>OMI Iasi 2020 codjoc</li> <li>alternant1 pbinfo</li> <li>Alte probleme cu aflarea cifrelor unui num\u0103r de pe pbinfo</li> <li>OJI 2019 aur</li> </ul>","tags":["cifre","matematica","structura repetitiva"]},{"location":"usor/digits-manipulation/#resurse-suplimentare","title":"Resurse suplimentare","text":"<ul> <li>Parcurgerea cifrelor unui num\u0103r - CPPI Sync</li> <li>Prelucrarea cifrelor unui numar - Algopedia</li> <li>Cifrele unui num\u0103r - pbinfo</li> </ul>","tags":["cifre","matematica","structura repetitiva"]},{"location":"usor/dirichlet/","title":"Principiul lui Dirichlet (principiul cutiei)","text":"","tags":["matematica","perioada","optimizare"]},{"location":"usor/dirichlet/#introducere","title":"Introducere","text":"<p>Dup\u0103 cum \u0219ti\u021bi, foarte multe principii \u00eent\u00e2lnite \u00een matematic\u0103 ajung s\u0103 fie aplicate \u0219i \u00een informatic\u0103 sub diverse forme. Unul dintre aceste principii, frecvent \u00eent\u00e2lnit \u00een problemele de matematic\u0103 de gimnaziu \u0219i nu numai este principiul lui Dirichlet, de asemenea cunoscut sub numele de principiul cutiei sau sub denumirea sa din englez\u0103, pigeonhole principle.</p> <p>Defini\u021bie</p> <p>Dac\u0103 avem \\(n+1\\) obiecte \u0219i \\(n\\) cutii, indiferent cum vom aranja obiectele \u00een cutii, vom avea cu siguran\u021b\u0103 o cutie care va avea cel pu\u021bin dou\u0103 obiecte.</p> <p>Exist\u0103 foarte multe moduri de a demonstra acest lucru, dar un mod foarte simplu de a face acest lucru este acela de a pleca de la un caz simplu (2 obiecte \u0219i 1 cutie), caz care este evident, adev\u0103rat. Apoi, fiecare obiect ad\u0103ugat va fi \u00een cutia lui, deci vom avea cu siguran\u021b\u0103 o cutie cu cel pu\u021bin dou\u0103 obiecte.</p> <p>\u00cen informatic\u0103, de cele mai multe ori, acest principiu este aplicat atunci c\u00e2nd avem de ales dou\u0103 obiecte cu aceea\u0219i valoare dintr-o mul\u021bime care are mai multe obiecte dec\u00e2t valori posibile.</p> <p>\u00cen cele ce urmeaz\u0103, vom prezenta diverse exemple de probleme care pot fi rezolvate folosind acest principiu.</p>","tags":["matematica","perioada","optimizare"]},{"location":"usor/dirichlet/#problema-exemplu-binary-number","title":"Problema exemplu - Binary Number","text":"<p>Pentru a rezolva aceast\u0103 problem\u0103, trebuie s\u0103 g\u0103sim o observa\u021bie care s\u0103 ne ajute s\u0103 afl\u0103m cu u\u0219urin\u021b\u0103 un num\u0103r valid. Deoarece exist\u0103 \\(2^n\\) numere valide, nu putem s\u0103 le \u00eencerc\u0103m pe toate. Totu\u0219i, ne putem g\u00e2ndi la o form\u0103 particular\u0103 a numerelor care s\u0103 ne ajute s\u0103 afl\u0103m r\u0103spunsul mai u\u0219or.</p> <p>Dac\u0103 ne g\u00e2ndim la numerele de forma \\(1111\\dots1\\) cu \\(1, 2, 3, \\dots, n\\) cifre, avem \\(n\\) asemenea numere. De aici, avem dou\u0103 cazuri. Fie unul din aceste numere este multiplu de \\(n\\) \u0219i putem ad\u0103uga zerouri la finalul num\u0103rului, fie g\u0103sim dou\u0103 numere care s\u0103 aib\u0103 acela\u0219i rest (lucru ce este adev\u0103rat deoarece avem \\(n-1\\) resturi posibile). Datorit\u0103 acestui fapt, putem g\u0103si mereu o solu\u021bie la aceast\u0103 problem\u0103.</p> <p>Pentru a afla aceste resturi, putem construi un vector de resturi par\u021biale \u0219i dac\u0103 avem un multiplu de \\(n\\), afi\u0219\u0103m acea valoare \u00eempreun\u0103 cu valorile de 0, iar dac\u0103 g\u0103sim dou\u0103 resturi par\u021biale egale, vom afi\u0219a diferen\u021ba \u00eentre cele dou\u0103 numere, iar mai apoi \u00eendeajuns de mult zerouri p\u00e2n\u0103 ce avem \\(n\\) cifre.</p> <p>Mai jos g\u0103si\u021bi implementarea solu\u021biei \u00een limbajul C++.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint sp[1000001], prv[1000001];\n\nint main() {\n    int n;\n    cin &gt;&gt; n;\n\n    for (int i = 1; i &lt;= n; i++) {\n        sp[i] = (sp[i - 1] * 10 + 1) % n;\n        if (sp[i] == 0) {\n            for (int j = 1; j &lt;= i; j++) {\n                cout &lt;&lt; 1;\n            }\n            for (int j = i + 1; j &lt;= n; j++) {\n                cout &lt;&lt; 0;\n            }\n            return 0;\n        } else {\n            if (prv[sp[i]] != 0) {\n                int tot = i - prv[sp[i]];\n                for (int x = prv[sp[i]] + 1; x &lt;= i; x++) {\n                    cout &lt;&lt; 1;\n                }\n                for (int x = 1; x &lt;= n - tot; x++) {\n                    cout &lt;&lt; 0;\n                }\n                cout &lt;&lt; '\\n';\n                return 0;\n            }\n        }\n        prv[sp[i]] = i;\n    }\n    return 0;\n}\n</code></pre>","tags":["matematica","perioada","optimizare"]},{"location":"usor/dirichlet/#problema-2-subsecv-pbinfo","title":"Problema 2 - Subsecv pbinfo","text":"<p>\u00cen mod similar cu problema anterioar\u0103, vom putea p\u0103stra resturile sumelor valorilor din toate prefixele c\u00e2nd \u00eemp\u0103r\u021bim la \\(n\\), iar atunci c\u00e2nd avem un prefix care se repet\u0103, vom afi\u0219a cea mai de la st\u00e2nga subsecven\u021b\u0103.</p> <pre><code>#include &lt;fstream&gt;\nusing namespace std;\n\nint n, v, remainders[10002], minL = 10001, minR = 10001;\nint main() {\n    ifstream cin(\"subsecv.in\");\n    ofstream cout(\"subsecv.out\");\n\n    cin &gt;&gt; n;\n    remainders[0] = 0;\n    for (int i = 1; i &lt; n; i++) {\n        remainders[i] = -1;\n    }\n    int sm = 0;\n    for (int i = 1; i &lt;= n; i++) {\n        cin &gt;&gt; v;\n        sm = (sm + v) % n;\n        if (remainders[sm] != -1 &amp;&amp; remainders[sm] + 1 &lt; minL) {\n            minL = remainders[sm] + 1;\n            minR = i;\n        }\n        if (remainders[sm] == -1) {\n            remainders[sm] = i;\n        }\n    }\n    cout &lt;&lt; minL &lt;&lt; \" \" &lt;&lt; minR &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["matematica","perioada","optimizare"]},{"location":"usor/dirichlet/#concluzii","title":"Concluzii","text":"<p>Acest principiu este unul foarte important, iar cuno\u0219tin\u021bele de la matematic\u0103 devin foarte utile \u00een contextul problemelor de algoritmic\u0103, \u00een special unele din cele tradi\u021bional \u00eencadrate \u00een categoria problemelor ad-hoc.</p> <p>Recomand\u0103m de asemenea urm\u0103rirea materialelor din resursele suplimentare, chiar dac\u0103 unele dintre acestea sunt mai degrab\u0103 orientate spre olimpiada de matematic\u0103, deoarece fac unele aplica\u021bii mai dificile mai u\u0219or de rezolvat.</p>","tags":["matematica","perioada","optimizare"]},{"location":"usor/dirichlet/#probleme-suplimentare","title":"Probleme suplimentare","text":"<ul> <li>Kuroni and Impossible Calculation - Codeforces</li> <li>Porumbei - pbinfo</li> <li>Prinzessin der Verurteilung - Codeforces</li> <li>Razboi2 - infoarena</li> <li>Lot Juniori 2013 Numere</li> <li>ONI 2023 Struguri</li> <li>OMI Iasi 2013 moretime</li> <li>ONI 2016 Leduri</li> <li>Going Home - Codeforces</li> <li>Koxia and Number Theory - Codeforces</li> <li>Funny Game - Codeforces</li> </ul>","tags":["matematica","perioada","optimizare"]},{"location":"usor/dirichlet/#resurse-suplimentare","title":"Resurse suplimentare","text":"<ul> <li>Principiul lui Dirichlet - pbinfo</li> <li>Pigeonhole principle - Wikipedia</li> <li>Principiul lui Dirichlet (cutiei) - Infobits Academy</li> <li>Principiul cutiei - Gabriel Popa</li> <li>Principiul Dirichlet - Math.MD</li> <li>Pigeonhole principle - Art of Problem Solving</li> <li>Principiul lui Dirichlet - CPPI Sync</li> </ul>","tags":["matematica","perioada","optimizare"]},{"location":"usor/divisibility/","title":"Divizibilitatea","text":"<p>De-a lungul parcursului vostru \u00een domeniul algoritmicii, precum \u0219i de multe ori \u00een diferite olimpiade \u0219i concursuri de informatic\u0103, va trebui s\u0103 rezolva\u021bi multe probleme care se bazeaz\u0103 pe un fundament matematic, studiul teoriei din spatele divizibilit\u0103\u021bii numerelor naturale precum \u0219i a algoritmilor de aflare a numerelor prime, num\u0103rului de divizori, lucrului eficient cu numerele prime devenind toate foarte importante pentru asimilarea \u00een cel mai bun mod posibil a acestui capitol. Totu\u0219i, acest document reprezint\u0103 doar un punct de plecare \u00een ceea ce prive\u0219te aplica\u021biile teoriei numerelor \u00een algoritmic\u0103, alte concepte fiind discutate \u00een documentele ulterioare. Aceste no\u021biuni se vor g\u0103si foarte des \u00een problemele de informatic\u0103 pentru clasele de gimnaziu \u0219i clasa a IX-a.</p>","tags":["matematica","divizori","numere prime"]},{"location":"usor/divisibility/#notiuni-introductive","title":"No\u021biuni introductive","text":"<p>Defini\u021bie</p> <p>Un num\u0103r \\(x\\) este numit divizor al altui num\u0103r \\(y\\), dac\u0103 \\(y\\) se poate scrie ca produsul dintre \\(x\\) \u0219i un alt num\u0103r \u00eentreg \\(t\\).</p> <p>Observa\u021bie</p> <p>Orice num\u0103r \\(n\\) se \u00eemparte la 1 \u0219i la el \u00eensu\u0219i.</p> <p>Defini\u021bie</p> <p>Definim un divizor comun al unei perechi de numere \\((a, b)\\) ca fiind un num\u0103r \\(c\\) care este un divizor at\u00e2t al lui \\(a\\), c\u00e2t \u0219i al lui \\(b\\).</p> <p>CMMDC \u0219i CMMMC</p> <p>Definim cel mai mare divizor comun (cmmdc) al unei perechi de numere \\((a, b)\\) ca fiind cel mai mare num\u0103r care este un divizor at\u00e2t al lui \\(a\\), c\u00e2t \u0219i al lui \\(b\\). Vom nota \\(x = (a, b)\\). Definim cel mai mic multiplu comun (cmmmc) al unei perechi de numere \\([a, b]\\) ca fiind cel mai mic num\u0103r care este un multiplu at\u00e2t al lui \\(a\\), c\u00e2t \u0219i al lui \\(b\\). Vom nota \\(x = [a, b]\\).</p> <p>Observa\u021bie</p> <p>\\(a \\cdot b = (a, b) \\cdot [a, b]\\). Drept concluzie:</p> <p>$$ (a, b) = \\frac{a \\cdot b}{[a, b]} $$.</p> <p>Pentru aflarea celui mai mare divizor comun a dou\u0103 numere, exist\u0103 doi algoritmi principali. Primul dintre ei se bazeaz\u0103 pe sc\u0103deri repetate, la fiecare pas sc\u0103z\u00e2ndu-se din num\u0103rul mai mare, num\u0103rul mai mic p\u00e2n\u0103 c\u00e2nd cele dou\u0103 valori devin egale. De\u0219i pentru multe perechi de numere acest algoritm este destul de eficient, atunci c\u00e2nd diferen\u021ba dintre numere este foarte mare, algoritmul va rula \u00een timp cvasi-liniar (de exemplu, pentru numerele 3 \u0219i \\(10^9\\), un calculator are nevoie de c\u00e2teva secunde s\u0103 afle cmmdc-ul folosind acest algoritm).</p> <p>De aceea vom folosi algoritmul lui Euclid prin \u00eemp\u0103r\u021biri repetate pentru a ajunge la r\u0103spuns. Acest algoritm pleac\u0103 de la ideea c\u0103 o sl\u0103biciune major\u0103 a algoritmului prin sc\u0103deri este dat\u0103 de situa\u021bia c\u00e2nd raportul dintre num\u0103rul mai mare \u0219i cel mai mic este foarte mare, c\u00e2nd practic efectu\u0103m aceea\u0219i opera\u021bie de foarte multe ori. De aceea, \u00een loc de sc\u0103deri, la fiecare pas vom afla restul \u00eemp\u0103r\u021birii num\u0103rului mai mare la cel mai mic, \u00eenlocuind posibilele opera\u021bii de sc\u0103dere cu o singur\u0103 \u00eemp\u0103r\u021bire, algoritmul devenind mult mai eficient.</p> <p>Exemplu</p> <p>De exemplu, s\u0103 analiz\u0103m numerele 40 \u0219i 18.</p> <ul> <li>\\(a = 40\\), \\(b = 18\\). \\(a \\% b = 4\\), noile valori fiind \\(a = 18\\), \\(b = 4\\);</li> <li>\\(a = 18\\), \\(b = 4\\). \\(a \\% b = 2\\), noile valori fiind \\(a = 4\\), \\(b = 2\\);</li> <li>\\(a = 4\\), \\(b = 2\\). \\(a \\% b = 0\\), noile valori fiind \\(a = 2\\), \\(b = 0\\);</li> <li>\\(a = 2\\), \\(b = 0\\). Deoarece \\(b = 0\\), continuarea algoritmului ne-ar duce la   \u00eemp\u0103r\u021biri la 0, opera\u021bie ce nu este valid\u0103.</li> </ul> <p>Mai jos pute\u021bi g\u0103si implementarea \u00een C++ a cmmdc-ului \u0219i a cmmmc-ului, program ce afl\u0103 cmmdc \u0219i cmmmc pentru \\(t\\) perechi de numere. Complexitatea algoritmului este \\(\\mathcal{O}(\\log n)\\) pentru fiecare test.</p> <p>Pentru calcularea CMMMC-ului, trebuie avut grij\u0103 s\u0103 \u00eemp\u0103r\u021bim mai \u00eent\u00e2i la \\(cmmdc(a, b)\\) \u0219i apoi s\u0103 \u00eenmul\u021bim cu \\(b\\), pentru a evita un poten\u021bial overflow.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint cmmdc(int a, int b) {\n    while (b &gt; 0) {\n        int c = a % b;\n        a = b;\n        b = c;\n    }\n    return a;\n}\n\nlong long cmmmc(int a, int b) { return 1LL * a / cmmdc(a, b) * b; }\n\nint main() {\n    int t;\n    cin &gt;&gt; t;\n\n    while (t--) {\n        int a, b;\n        cin &gt;&gt; a &gt;&gt; b;\n\n        int gcd = cmmdc(a, b);\n        long long lcm = cmmmc(a, b);\n        cout &lt;&lt; gcd &lt;&lt; \" \" &lt;&lt; lcm &lt;&lt; '\\n';\n    }\n    return 0;\n}\n</code></pre> <p>Not\u0103</p> <p>C++17 ofer\u0103 <code>std::gcd()</code> \u0219i <code>std::lcm()</code> \u00een <code>&lt;numeric&gt;</code>, deci nu este nevoie s\u0103 reimplementa\u021bi algoritmul dac\u0103 ave\u021bi acces la un asemenea compilator.</p>","tags":["matematica","divizori","numere prime"]},{"location":"usor/divisibility/#lucrul-cu-divizorii-unui-numar","title":"Lucrul cu divizorii unui num\u0103r","text":"<p>Numere prime \u0219i compuse</p> <p>Un num\u0103r \\(n \\geq 2\\) este num\u0103r prim dac\u0103 \u0219i numai dac\u0103 are doar 2 divizori: 1 \u0219i \\(n\\), \u00een caz contrar fiind num\u0103r compus.</p> <p>Observa\u021bii</p> <ol> <li>0 \u0219i 1 nu sunt nici numere prime, nici numere compuse.</li> <li>2 este singurul num\u0103r prim par, celelalte numere prime fiind impare.</li> </ol> <p>Descompunerea \u00een factori primi se bazeaz\u0103 pe Teorema fundamental\u0103 a aritmeticii, dat\u0103 mai jos:</p> <p>Teorema fundamental\u0103 a aritmeticii</p> <p>Orice num\u0103r natural \\(n &gt; 1\\) se poate scrie \u00een mod unic sub forma $$ n = \\prod_{i = 1}^k p_i^{e_i} $$ unde \\(p_1 &lt; p_2 &lt; \\dots &lt; p_k\\) sunt numere prime, iar \\(e_i \\in \\mathbb{N}^\\ast~\\forall 1 \\leq i \\leq k\\).</p> <p>Observa\u021bie</p> <p>Se poate observa c\u0103 num\u0103rul maxim de numere prime la care se \u00eemparte un num\u0103r \\(n\\) este foarte mic. De exemplu, pentru \\(n \\leq 10^{9}\\), sunt cel mult 9 numere prime \u00een reprezentarea ca produs de factori primi.</p> <p>Pentru a afla divizorii unui num\u0103r natural \\(n\\), cel mai simplu (dar \u0219i ineficient) algoritm const\u0103 \u00een a verifica pe r\u00e2nd fiecare num\u0103r 1 la \\(n\\) \u0219i s\u0103 verific\u0103m dac\u0103 \\(n\\) se \u00eemparte exact la acel num\u0103r. Pentru a optimiza acest algoritm, va trebui s\u0103 folosim o alt\u0103 observa\u021bie important\u0103.</p> <p>Observa\u021bie</p> <p>Dac\u0103 \\(n\\) se \u00eemparte exact la \\(x\\), se va \u00eemp\u0103r\u021bi exact \u0219i la \\(\\frac{n}{x}\\). A\u0219adar, \\(x^2 \\leq n\\) sau \\(x \\leq \\sqrt{n}\\). Asta ne duce la ideea s\u0103 verific\u0103m doar divizorii p\u00e2n\u0103 la \\(\\sqrt{n}\\), observa\u021bie ce se va dovedi fundamental\u0103 \u00een calculele \u0219i algoritmii pe care \u00ee\u00ee vom scrie pentru toate aceste probleme.</p> <p>Astfel, vom putea afla orice informa\u021bie legat\u0103 de divizorii unui num\u0103r \u00een \\(\\mathcal{O}(\\sqrt{n})\\), fie c\u0103 e vorba de num\u0103rul de divizori, divizorii primi, descompunerea \u00een factori primi \u0219i a\u0219a mai departe.</p> <p>Totu\u0219i, putem verifica cu u\u0219urin\u021b\u0103 pentru un num\u0103r \\(n\\) dac\u0103 \\(d\\) este divizor al acestuia, folosind o simpl\u0103 condi\u021bie aritmetic\u0103</p> <pre><code>if (n % d == 0) {\n    cout &lt;&lt; d &lt;&lt; \" este divizor al lui \" &lt;&lt; n &lt;&lt; '\\n';\n}\n</code></pre>","tags":["matematica","divizori","numere prime"]},{"location":"usor/divisibility/#problema-divizibilitate-de-pe-kilonova","title":"Problema divizibilitate de pe Kilonova","text":"<p>Cerin\u021b\u0103</p> <p>Se d\u0103 un num\u0103r \\(t\\) \u0219i \\(t\\) numere naturale. S\u0103 se afle pentru fiecare dintre ele r\u0103spunsul la una din urm\u0103toarele \u00eentreb\u0103ri:</p> <ul> <li> <p>\\(1\\ n\\): S\u0103 se afle dac\u0103 \\(n\\) este prim sau nu. \u00cen caz afirmativ se va afi\u0219a   <code>YES</code>, altfel se va afi\u0219a <code>NO</code>.</p> </li> <li> <p>\\(2\\ n\\): S\u0103 se afle c\u00e2\u021bi divizori are \\(n\\) \u2014 de exemplu, dac\u0103 \\(n = 12\\), se   va afi\u0219a 6 (1, 2, 3, 4, 6, 12 sunt divizorii lui 12).</p> </li> <li> <p>\\(3\\ n\\): S\u0103 se afle num\u0103rul divizorilor primi ai lui \\(n\\) \u2014 de exemplu, dac\u0103   \\(n = 21\\), se va afi\u0219a 2.</p> </li> <li> <p>\\(4\\ n\\): S\u0103 se afi\u0219eze descompunerea \u00een factori primi pe care o are un   num\u0103r, fiecare factor fiind scris pe o linie, \u00een ordine cresc\u0103toare a   numerelor prime \u2014 de exemplu, dac\u0103 \\(n = 60\\), se vor afi\u0219a pe 3 linii   separate:</p> <pre><code>2 2\n3 1\n5 1\n</code></pre> </li> </ul> <p>Fiecare tip de \u00eentrebare a fost implementat folosind o func\u021bie separat\u0103 pentru a ar\u0103ta diferen\u021bele ce pot ap\u0103rea de la un tip de \u00eentrebare la alta.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nbool este_prim(int numar) {\n    // n == 0 || n == 1\n    if (numar &lt;= 1) {\n        return false;\n    }\n\n    // n == 2 || n == 3\n    if (numar &lt;= 3) {\n        return true;\n    }\n\n    if (numar % 2 == 0 || numar % 3 == 0) {\n        return false;\n    }\n\n    // Iter\u0103m prin to\u021bi divizorii primi, care-s de forma 6k \u00b1 1\n    for (int divizor = 5; divizor * divizor &lt;= numar; divizor += 6) {\n        if (numar % divizor == 0 || numar % (divizor + 2) == 0) {\n            return false;\n        }\n    }\n\n    return true;\n}\n\nint numar_divizori(int numar) {\n    int numar_divizori = 0;\n\n    for (int divizor = 1; divizor * divizor &lt;= numar; ++divizor) {\n        if (numar % divizor == 0) {\n            // Dac\u0103 divizor = numar/divizor, atunci \u00eenseamn\u0103 c\u0103 avem\n            // un singur divizor distinct.\n            numar_divizori++;\n\n            if (divizor != numar / divizor) {\n                numar_divizori++;\n            }\n        }\n    }\n    return numar_divizori;\n}\n\nint numar_divizori_primi(int numar) {\n    int numar_divizori = 0;\n\n    for (int divizor = 2; divizor * divizor &lt;= numar; ++divizor) {\n        if (numar % divizor == 0) {\n            numar_divizori++;\n\n            // Elimin\u0103m to\u021bi multiplii divizorului, deoarece\n            // l-am contorizat deja.\n\n            while (numar % divizor == 0) {\n                numar /= divizor;\n            }\n        }\n    }\n\n    if (numar &gt; 1) {\n        numar_divizori++;\n    }\n\n    return numar_divizori;\n}\n\nvoid afiseaza_divizorii_primi(int numar) {\n    for (int divizor = 2; divizor * divizor &lt;= numar; ++divizor) {\n        if (numar % divizor == 0) {\n            int exponent = 0;\n\n            // Dac\u0103 am g\u0103sit un divizor, calcul\u0103m exponentul s\u0103u.\n            while (numar % divizor == 0) {\n                exponent++;\n                numar /= divizor;\n            }\n\n            cout &lt;&lt; divizor &lt;&lt; \" \" &lt;&lt; exponent &lt;&lt; '\\n';\n        }\n    }\n\n    if (numar &gt; 1) {\n        cout &lt;&lt; numar &lt;&lt; \" 1\\n\";\n    }\n}\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(nullptr);\n\n    int t;\n    cin &gt;&gt; t;\n\n    while (t--) {\n        int tip, numar;\n        cin &gt;&gt; tip &gt;&gt; numar;\n\n        switch (tip) {\n        case 1:\n            cout &lt;&lt; (este_prim(numar) ? \"YES\" : \"NO\") &lt;&lt; '\\n';\n            break;\n        case 2:\n            cout &lt;&lt; numar_divizori(numar) &lt;&lt; '\\n';\n            break;\n        case 3:\n            cout &lt;&lt; numar_divizori_primi(numar) &lt;&lt; '\\n';\n            break;\n        case 4:\n            afiseaza_divizorii_primi(numar);\n            break;\n        default:\n            break;\n        }\n    }\n\n    return 0;\n}\n</code></pre>","tags":["matematica","divizori","numere prime"]},{"location":"usor/divisibility/#probleme-suplimentare","title":"Probleme suplimentare","text":"<ul> <li>CSES Counting Divisors</li> <li>pbinfo difimin</li> <li>pbinfo zerouri</li> <li>CSES Trailing Zeroes</li> <li>Pbinfo divizori3</li> <li>pbinfo zerouri1</li> <li>Problemele cu divizibilitate de pe Pbinfo</li> <li>Infoarena divmul</li> <li>ONI 2006 Suma</li> <li>OJI 2003 Tort</li> <li>OLI 2024 Suceava Perechi</li> <li>OJI 2024 bomboane</li> <li>ONI 2019 copii</li> <li>Probleme cu divizibilitate de pe kilonova</li> </ul>","tags":["matematica","divizori","numere prime"]},{"location":"usor/divisibility/#lectura-suplimentara","title":"Lectur\u0103 suplimentar\u0103","text":"<ul> <li>CMMDC - CPPI Sync</li> <li>Obtinerea divizorilor unui numar - CPPI Sync</li> <li>Articolele despre divizibilitate de pe Pbinfo</li> <li>Number theory  \u2014  Storing information about multiples/divisors</li> <li>Some useful conclusions for some naive algorithms to solve number theory problems - Codeforces</li> <li>Articol de pe USACO Guide</li> <li>Counting Divisors of a Number in \\(N^\\frac{1}{3}\\)</li> </ul>","tags":["matematica","divizori","numere prime"]},{"location":"usor/frequency-arrays/","title":"Vectori de frecven\u021b\u0103","text":"","tags":["vectori","frecventa","implementare"]},{"location":"usor/frequency-arrays/#introducere","title":"Introducere","text":"<p>\u00cen multe probleme, suntem nevoi\u021bi s\u0103 lucr\u0103m cu foarte multe valori cuprinse \u00eentr-un interval relativ mic. Pentru a face lucrul cu ele mai u\u0219or, se impune num\u0103rarea lor \u0219i p\u0103strarea datelor \u00eentr-o structur\u0103 de date potrivit\u0103.</p> <p>Astfel, se impune folosirea unui vector de frecven\u021b\u0103.</p> <p>Defini\u021bie</p> <p>A\u0219a cum sugereaz\u0103 \u0219i numele, un vector de frecven\u021b\u0103 este o structur\u0103 de date de tip tablou pe care o folosim pentru a \u021bine \u00een memorie de c\u00e2te ori apare fiecare element \u00eentr-un \u0219ir de numere.</p> <p>Exemplu</p> <p>De exemplu, dac\u0103 \u0219irul nostru con\u021bine valorile \\(8, 1, 4, 1, 6, 3, 5, 2, 2, 4\\), vectorul de frecven\u021b\u0103 va avea urm\u0103toarea form\u0103: \\(0, 2, 2, 1, 1, 1, 1, 0, 1\\), cu semnifica\u021bia c\u0103 0 nu apare deloc, 1 apare de dou\u0103 ori, 2 apare de dou\u0103 ori, iar celelalte valori, cu excep\u021bia lui 7, apar o singur\u0103 dat\u0103.</p> <p>Aceast\u0103 structur\u0103 de date se folose\u0219te atunci c\u00e2nd numerele (sau \u00een general, datele cu care lucr\u0103m) pot lua pu\u021bine valori distincte sau se afl\u0103 \u00eentr-un interval mic.</p> <p>Observa\u021bie</p> <p>\u00cen general, vrem s\u0103 folosim vectorii de frecven\u021b\u0103 dac\u0103 stocarea informa\u021biilor legat de valorile pe care le folosim devine mult mai facil\u0103 din punct de vedere al memoriei sau timpului comparat cu stocarea lor \u00een vectorul deja existent. \u00cen probleme, acest lucru se remarc\u0103 mai ales dac\u0103 valorile nu sunt foarte mari (p\u00e2n\u0103 \u00een \\(10^6\\)) sau dac\u0103 diferen\u021ba dintre cel mai mare \u0219i cel mai mic element este mic\u0103.</p> <p>Pe parcursul acestui articol, voi prezenta c\u00e2teva probleme, pentru a explica diferitele varia\u021bii ale acestei metode precum \u0219i alte moduri \u00een care putem p\u0103stra acest vector \u00een memorie.</p> <p>Vector caracteristic</p> <p>\u00cen unele c\u0103r\u021bi \u0219i articole, dac\u0103 vectorul de frecven\u021b\u0103 este folosit doar pentru a verifica existen\u021ba unor valori, se mai folose\u0219te denumirea de vector caracteristic.</p>","tags":["vectori","frecventa","implementare"]},{"location":"usor/frequency-arrays/#problema-cifreord-de-pe-pbinfo","title":"Problema cifreord de pe pbinfo","text":"<p>O solu\u021bie posibil\u0103 pentru aceast\u0103 problem\u0103 este s\u0103 sort\u0103m valorile folosind unul din algoritmii de sortare explicat aici.</p> <p>Totu\u0219i, num\u0103rul de valori este prea mare \u0219i aceast\u0103 abordare ar dep\u0103\u0219i limita de timp alocat\u0103. \u00cen schimb, ne putem folosi de faptul c\u0103 lucr\u0103m doar cu cifre zecimale \u0219i le putem afi\u0219a pe acestea corespunz\u0103tor cu frecven\u021ba lor. Trebuie s\u0103 avem grij\u0103 \u0219i s\u0103 afi\u0219\u0103m o linie nou\u0103 de fiecare dat\u0103 c\u00e2nd afi\u0219\u0103m 20 de numere, conform cerin\u021bei din enun\u021b.</p> <pre><code>#include &lt;fstream&gt;\nusing namespace std;\n\nifstream fin(\"cifreord.in\");\nofstream fout(\"cifreord.out\");\n\nint main() {\n    int n;\n    fin &gt;&gt; n;\n\n    int frecventa[10] = {0};\n\n    for (int i = 1; i &lt;= n; i++) {\n        int cifra;\n        fin &gt;&gt; cifra;\n\n        frecventa[cifra]++;\n    }\n\n    int numere_afisate = 0;\n\n    for (int cifra = 0; cifra &lt;= 9; cifra++) {\n        while (frecventa[cifra] &gt; 0) {\n            fout &lt;&lt; cifra &lt;&lt; \" \";\n\n            numere_afisate++;\n\n            if (numere_afisate == 20) {\n                fout &lt;&lt; '\\n';\n                numere_afisate = 0;\n            }\n\n            frecventa[cifra]--;\n        }\n    }\n\n    return 0;\n}\n</code></pre>","tags":["vectori","frecventa","implementare"]},{"location":"usor/frequency-arrays/#problema-numere1-de-pe-pbinfo","title":"Problema numere1 de pe pbinfo","text":"<p>Pentru a rezolva aceast\u0103 problem\u0103, cea mai important\u0103 informa\u021bie pe care o primim din enun\u021b este aceea c\u0103 valorile care ne intereseaz\u0103 sunt strict cele care au trei cifre (cu alte cuvinte, cele \u00eentre 100 \u0219i 999). Astfel, se impune crearea unui vector de frecven\u021b\u0103 care s\u0103 poat\u0103 memora aceste valori \u0219i dup\u0103 ce citim valorile din \u0219ir, se pot afla cu u\u0219urin\u021b\u0103 cele mai mari dou\u0103 valori de trei cifre care nu se afl\u0103 \u00een \u0219ir.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int n;\n    cin &gt;&gt; n;\n\n    int frecventa[1000] = {0};\n\n    for (int i = 1; i &lt;= n; i++) {\n        int numar;\n        cin &gt;&gt; numar;\n\n        if (numar &gt;= 100 &amp;&amp; numar &lt;= 999) {\n            frecventa[numar]++;\n        }\n    }\n\n    int a = 0, b = 0;\n\n    for (int numar = 999; numar &gt;= 100; numar--) {\n        if (frecventa[numar] == 0) {\n            if (a == 0) {\n                a = numar;\n            } else if (b == 0) {\n                b = numar;\n            }\n        }\n    }\n\n    if (a == 0 || b == 0) {\n        cout &lt;&lt; \"NU EXISTA\";\n    } else {\n        cout &lt;&lt; b &lt;&lt; \" \" &lt;&lt; a &lt;&lt; '\\n';\n    }\n    return 0;\n}\n</code></pre>","tags":["vectori","frecventa","implementare"]},{"location":"usor/frequency-arrays/#problema-nrlipsa2-de-pe-pbinfo","title":"Problema nrlipsa2 de pe pbinfo","text":"<p>Pentru a citi acel num\u0103r necunoscut de valori, va trebui s\u0103 ne baz\u0103m pe o structur\u0103 repetitiv\u0103 de tip while. Apoi, pentru a lucra cu valorile din intervalul \\([-100, 100]\\), trebuie s\u0103 adapt\u0103m lucrurile la realitatea limbajului C++, \u0219i anume la faptul c\u0103 nu putem p\u0103stra indici negativi \u00een vector.</p> <p>Astfel, \u00een loc s\u0103 lucr\u0103m cu acel interval, vom vrea s\u0103 adun\u0103m o valoare (un offset) care s\u0103 ne asigure c\u0103 lucr\u0103m cu valori non-negative (astfel, intervalul devine \\([0, 200]\\)). Ulterior, atunci c\u00e2nd afi\u0219\u0103m valoarea care nu apare, vom sc\u0103dea 100 din r\u0103spuns pentru a \u00eentoarce rezultatul la cel real.</p> <pre><code>#include &lt;fstream&gt;\nusing namespace std;\n\nifstream fin(\"nrlipsa2.in\");\nofstream fout(\"nrlipsa2.out\");\n\nint main() {\n    // 201 = 100 - (-100) + 1\n    int frecventa[201] = {0};\n    int numar;\n\n    while (fin &gt;&gt; numar) {\n        if (numar &gt;= -100 &amp;&amp; numar &lt;= 100) {\n            frecventa[numar + 100]++;\n        }\n    }\n\n    bool gasit = false;\n    for (int numar = -100; numar &lt;= 100; numar++) {\n        if (frecventa[numar + 100] == 0) {\n            fout &lt;&lt; numar &lt;&lt; '\\n';\n            return 0;\n        }\n    }\n\n    fout &lt;&lt; \"nu exista\";\n\n    return 0;\n}\n</code></pre>","tags":["vectori","frecventa","implementare"]},{"location":"usor/frequency-arrays/#problema-mincifre-de-pe-pbinfo","title":"Problema mincifre de pe pbinfo","text":"<p>Pentru a rezolva aceast\u0103 problem\u0103, putem \u021bine cifrele \u00eentr-un vector de frecven\u021b\u0103 \u0219i s\u0103 le afi\u0219\u0103m cresc\u0103tor, singura diferen\u021b\u0103 fiind faptul c\u0103 deoarece nu vrem s\u0103 avem numere care \u00eencep cu 0, vom afi\u0219a cea mai mic\u0103 cifr\u0103 nenul\u0103 la \u00eenceput.</p> <pre><code>#include &lt;fstream&gt;\nusing namespace std;\n\nifstream fin(\"mincifre.in\");\nofstream fout(\"mincifre.out\");\n\nint main() {\n    char cifra;\n    int frecventa[10] = {0};\n\n    // Facem frecven\u021ba cifrelor din num\u0103r\n    while (fin &gt;&gt; cifra) {\n        frecventa[cifra - '0']++;\n    }\n\n    // Afl\u0103m cea mai mic\u0103 cifr\u0103 nenul\u0103\n    for (int cifra = 1; cifra &lt;= 9; cifra++) {\n        if (frecventa[cifra] &gt; 0) {\n            fout &lt;&lt; cifra;\n            frecventa[cifra]--;\n            break;\n        }\n    }\n\n    // Afi\u0219\u0103m cifrele \u00een ordine cresc\u0103toare\n    for (int cifra = 0; cifra &lt;= 9; cifra++) {\n        while (frecventa[cifra] &gt; 0) {\n            fout &lt;&lt; cifra;\n            frecventa[cifra]--;\n        }\n    }\n\n    return 0;\n}\n</code></pre>","tags":["vectori","frecventa","implementare"]},{"location":"usor/frequency-arrays/#problema-numere-oji-2005","title":"Problema numere OJI 2005","text":"<p>Pentru a rezolva aceast\u0103 problem\u0103, trebuie s\u0103 citim cele \\(n^2\\) valori \u0219i s\u0103 \u021binem \u00eentr-un vector de frecven\u021b\u0103 valorile pe care le-am ob\u021binut.</p> <p>Ulterior, problema se reduce la a afla cel mai mic \u0219i cel mai mare num\u0103r care nu apare \u00een \u0219ir.</p> <p>Observa\u021bie</p> <p>De\u0219i datele de intrare sunt date drept o matrice de dimensiune \\(n\\), nu trebuie s\u0103 folosim vreun tablou bidimensional pentru a rezolva aceast\u0103 problem\u0103.</p> <pre><code>#include &lt;fstream&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\nifstream fin(\"numere.in\");\nofstream fout(\"numere.out\");\n\nint main() {\n    int n;\n    fin &gt;&gt; n;\n\n    const int limita = n * n;\n\n    vector&lt;int&gt; frecventa(limita + 1);\n\n    for (int i = 1; i &lt;= limita; i++) {\n        int numar;\n        fin &gt;&gt; numar;\n        frecventa[numar] = 1;\n    }\n\n    int primul = 0, ultimul = 0;\n    for (int numar = 1; numar &lt;= limita; numar++) {\n        if (frecventa[numar] == 0) {\n            if (primul == 0) {\n                primul = numar;\n            }\n            ultimul = numar;\n        }\n    }\n\n    fout &lt;&lt; primul &lt;&lt; \" \" &lt;&lt; ultimul;\n    return 0;\n}\n</code></pre>","tags":["vectori","frecventa","implementare"]},{"location":"usor/frequency-arrays/#vectori-de-frecventa-dinamici-map-si-set","title":"Vectori de frecven\u021b\u0103 dinamici - map \u0219i set","text":"<p>Dup\u0103 cum a\u021bi observat, vectorii de frecven\u021b\u0103 au cel mai important rol atunci c\u00e2nd vrem s\u0103 p\u0103str\u0103m valori relativ mici. Dar ce facem atunci c\u00e2nd valorile sunt mari?</p> <p>\u00cen acest caz, se impune folosirea unor structuri de date mai avansate, cum ar fi <code>std::map</code> \u0219i <code>std::set</code>.</p> <p>\u00cen privin\u021ba <code>std::map</code>, acesta poate fi folosit \u00een acest context exact ca vectorii de frecven\u021b\u0103, av\u00e2nd posibilitatea s\u0103 stoc\u0103m dinamic frecven\u021ba valorilor care apar, f\u0103r\u0103 a avea nevoie de \\(\\mathcal{O}(valmax)\\) memorie. Totu\u0219i, aceast\u0103 metod\u0103 vine cu un cost, \u0219i anume faptul c\u0103 complexitatea opera\u021biilor este \\(\\mathcal{O}(\\log n)\\), spre deosebire de \\(\\mathcal{O}(1)\\) pentru metoda clasic\u0103.  </p> <p>\u00cen privin\u021ba <code>std::set</code>, acesta poate fi folosit \u00een acest context exact ca vectorii caracteristici (pentru frecven\u021be mai mari ca 1, <code>std::map</code> este o metod\u0103 strict superioar\u0103), av\u00e2nd posibilitatea s\u0103 stoc\u0103m dinamic valorile care apar, f\u0103r\u0103 a avea nevoie de \\(\\mathcal{O}(valmax)\\) memorie. La fel ca la structura de date precedent\u0103, aceast\u0103 metod\u0103 vine cu un cost, \u0219i anume faptul c\u0103 complexitatea opera\u021biilor este \\(\\mathcal{O}(\\log n)\\), spre deosebire de \\(\\mathcal{O}(1)\\) pentru metoda clasic\u0103.  </p>","tags":["vectori","frecventa","implementare"]},{"location":"usor/frequency-arrays/#problema-map-de-pe-pbinfo","title":"Problema map de pe pbinfo","text":"<pre><code>#include &lt;fstream&gt;\n#include &lt;iostream&gt;\n#include &lt;map&gt;\n\nusing namespace std;\n\nifstream fin(\"map.in\");\nofstream fout(\"map.out\");\n\nmap&lt;long long, int&gt; frecventa;\n\nint main() {\n    int n;\n    fin &gt;&gt; n;\n\n    for (int i = 1; i &lt;= n; ++i) {\n        long long valoare;\n        fin &gt;&gt; valoare;\n        frecventa[valoare]++;\n\n        fout &lt;&lt; frecventa[valoare] &lt;&lt; \" \";\n    }\n\n    return 0;\n}\n</code></pre>","tags":["vectori","frecventa","implementare"]},{"location":"usor/frequency-arrays/#concluzii","title":"Concluzii","text":"<p>Vectorii de frecven\u021b\u0103 sunt o metod\u0103 foarte popular\u0103, ce folose\u0219te aceast\u0103 structur\u0103 de date cu scopul de a \u021bine memorat num\u0103rul de valori egale cu o anumit\u0103 valoare. Ace\u0219tia sunt folositori pentru foarte multe tipuri de probleme \u0219i reprezint\u0103 parte esen\u021bial\u0103 a altor algoritmi, precum ciurul lui Eratostene.</p> <p>De asemenea, ace\u0219tia se reg\u0103sesc frecvent \u00een subiectele de bacalaureat \u0219i admitere, mai ales atunci c\u00e2nd problemele cer aflarea eficient\u0103 a unei solu\u021bii care implic\u0103 optimiz\u0103ri de timp \u0219i memorie.</p>","tags":["vectori","frecventa","implementare"]},{"location":"usor/frequency-arrays/#probleme-suplimentare","title":"Probleme suplimentare","text":"<ul> <li>unice pbinfo</li> <li>pareimpare pbinfo</li> <li>litere infoarena</li> <li>2lap pbinfo</li> <li>frecventa1 pbinfo</li> <li>RoAlgo Contest 11 Costmin</li> <li>OJI 2004 control</li> <li>ONI 2015 lightbot</li> <li>OMI Iasi 2024 cifre</li> <li>OJI 2023 primprim</li> <li>Probleme cu vectori de frecven\u021b\u0103 de pe pbinfo</li> <li>Probleme cu vectori de frecven\u021b\u0103 de pe kilonova</li> </ul>","tags":["vectori","frecventa","implementare"]},{"location":"usor/frequency-arrays/#resurse-suplimentare","title":"Resurse suplimentare","text":"<ul> <li>Vectori caracteristici \u0219i de frecven\u021b\u0103 - pbinfo</li> <li>Vectori de frecven\u021b\u0103 (probleme standard) - CPPI Sync</li> <li>Vectori de frecven\u021b\u0103 - Algopedia</li> </ul>","tags":["vectori","frecventa","implementare"]},{"location":"usor/generarea-sirurilor/","title":"Generarea \u0219irurilor de numere","text":"","tags":["vectori","siruri","fibonacci"]},{"location":"usor/generarea-sirurilor/#introducere","title":"Introducere","text":"<p>De multe ori \u00een problemele de informatic\u0103, apar \u0219iruri de numere naturale care trebuie fie \u0219tiute, cum va fi cazul unor \u0219iruri consacrate precum \u0219irul lui Fibonacci sau alte \u0219iruri matematice precum cel al p\u0103tratelor sau cuburilor perfecte.</p> <p>De\u0219i la acest nivel, cele mai frecvent \u00eent\u00e2lnite aplica\u021bii sunt cele \u00een care trebuie generate \u0219irurile sau descoperite diverse reguli, aceste tehnici sunt foarte importante \u0219i trebuie \u00eensu\u0219ite deoarece reprezint\u0103 un punct de plecare \u00een vederea multor tehnici ce apar ulterior, \u00een special c\u00e2nd ve\u021bi ajunge s\u0103 \u00eenv\u0103\u021ba\u021bi algoritmi mai avansa\u021bi care duc cuno\u0219tin\u021bele de aici la un alt nivel.</p>","tags":["vectori","siruri","fibonacci"]},{"location":"usor/generarea-sirurilor/#siruri-recurente","title":"\u0218iruri recurente","text":"<p>\u00cen general, c\u00e2nd vom vorbi de \u0219iruri de numere, ne vom concentra mai ales pe cele ai c\u0103ror termeni se leag\u0103 unii de al\u021bii prin intermediul unor formule sau rela\u021bii de recuren\u021b\u0103. Aceste \u0219iruri se numesc recurente.</p> <p>Ce este un \u0219ir de numere recurente?</p> <p>Un \u0219ir recurent este un \u0219ir de numere naturale ai c\u0103ror termeni sunt lega\u021bi prin intermediul unei rela\u021bii de recuren\u021b\u0103, sau \u00een alte cuvinte, fiecare termen are o valoare care depinde de valoarea unuia sau mai multor termeni anteriori.</p> <p>Exemplu</p> <p>Un exemplu foarte simplu reprezint\u0103 \u0219irul numerelor naturale pare, pentru care este binecunoscut faptul c\u0103 fiecare valoare este cu 2 mai mare dec\u00e2t valoarea anterioar\u0103 (\\(0, 2, 4, 6, 8, \\dots\\)).</p> <p>\u00cen general, ne va interesa s\u0103 putem genera aceste \u0219iruri \u0219i s\u0103 g\u0103sim regulile de generare pentru diverse \u0219iruri de numere naturale. Vom continua prin a prezenta unele \u0219iruri foarte \u00eent\u00e2lnite \u00een probleme.</p>","tags":["vectori","siruri","fibonacci"]},{"location":"usor/generarea-sirurilor/#progresii-aritmetice","title":"Progresii aritmetice","text":"<p>Progresie aritmetic\u0103</p> <p>O progresie aritmetic\u0103 este un \u0219ir de numere astfel \u00eenc\u00e2t diferen\u021ba dintre termenii consecutivi este constant\u0103. De exemplu \u0219irul \\(5, 7, 9, 11, 13, 15, \\dots\\) este o progresie aritmetic\u0103 cu o diferen\u021b\u0103 comun\u0103 de 2.</p> <p>\u00cen general, putem defini o progresie aritmetic\u0103 folosind primul termen \u0219i diferen\u021ba \u00eentre termeni consecutivi.</p> <p>Astfel, dac\u0103 primul termen este \\(x\\) \u0219i ra\u021bia este \\(r\\), termenii progresiei aritmetice sunt \\(x, x + r, x + 2 \\cdot r, \\dots\\)</p> <p>\u00cen general, pentru a afla suma primilor \\(n\\) termeni ai unei progresii aritmetice, putem folosi formula urm\u0103toare:</p> \\[ S = n \\cdot x + \\frac{(n-1) \\cdot n}{2} \\cdot r \\] <p>Fiecare dintre cei \\(n\\) termeni con\u021bine \\(x\\), iar apoi urm\u0103torii termeni au \u0219i \\(r, 2 \\cdot r, \\dots, (n-1) \\cdot r\\).</p>","tags":["vectori","siruri","fibonacci"]},{"location":"usor/generarea-sirurilor/#problema-exemplu-progresie3-pbinfo","title":"Problem\u0103 exemplu - progresie3 - pbinfo","text":"<p>Pentru a afla \u00een mod eficient dac\u0103 toate valorile apar\u021bin aceleia\u0219i progresii aritmetice, trebuie s\u0103 \u021binem un vector de frecven\u021b\u0103 \u00een care memor\u0103m aceste valori, iar mai apoi s\u0103 verific\u0103m dac\u0103 diferen\u021bele \u00eentre oricare dou\u0103 valori distincte consecutive sunt egale.</p> <pre><code>#include &lt;fstream&gt;\nusing namespace std;\n\nifstream fin(\"progresie3.in\");\nofstream fout(\"progresie3.out\");\n\nint main() {\n    int aparitii[1001] = {0};\n    int numar;\n    while (fin &gt;&gt; numar) {\n        aparitii[numar] = 1;\n    }\n\n    int ratie = -1;\n    int precedent = -1;\n\n    for (int numar = 0; numar &lt;= 1000; numar++) {\n        if (aparitii[numar] == 1) {\n            if (precedent == -1) {\n                precedent = numar;\n            } else {\n                int delta = numar - precedent;\n\n                if (ratie == -1) {\n                    ratie = delta;\n                } else if (delta != ratie) {\n                    fout &lt;&lt; \"NU\\n\";\n                    return 0;\n                }\n\n                precedent = numar;\n            }\n        }\n    }\n\n    fout &lt;&lt; ratie &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["vectori","siruri","fibonacci"]},{"location":"usor/generarea-sirurilor/#problema-rezolvata-sir1-pbinfo","title":"Problem\u0103 rezolvat\u0103 - sir1 pbinfo","text":"<p>Pentru a rezolva aceast\u0103 problem\u0103, ne folosim de propriet\u0103\u021bile sumei lui Gauss (progresie aritmetic\u0103 cu ra\u021bia 1). Astfel, afl\u0103m c\u00e2te grupe complete de valori exist\u0103 \u00een \u0219ir \u0219i apoi afl\u0103m valoarea corespunz\u0103toare ultimei grupe r\u0103mase.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int n;\n    cin &gt;&gt; n;\n\n    int total = 1;\n\n    // Sc\u0103dem grupele complete\n    while (n &gt; total) {\n        n -= total;\n        total++;\n    }\n\n    // Valoarea r\u0103mas\u0103\n    cout &lt;&lt; total - n + 1 &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["vectori","siruri","fibonacci"]},{"location":"usor/generarea-sirurilor/#progresii-geometrice","title":"Progresii geometrice","text":"<p>Progresie geometric\u0103</p> <p>O progresie geometric\u0103 este un \u0219ir de numere astfel \u00eenc\u00e2t raportul dintre termenii consecutivi este constant. De exemplu \u0219irul \\(2, 4, 8, 16, 32, 64, \\dots\\) este o progresie geometric\u0103 cu raportul 2.</p> <p>\u00cen general, putem defini o progresie geometric\u0103 folosind primul termen \u0219i raportul \u00eentre termeni consecutivi.</p> <p>Astfel, dac\u0103 primul termen este \\(x\\) \u0219i raportul este \\(r\\), termenii progresiei aritmetice sunt \\(x, x \\cdot r, x \\cdot r^2, \\dots\\)</p> <p>\u00cen general, pentru a afla suma primilor \\(n\\) termeni ai unei progresii geometrice, putem folosi formula urm\u0103toare:</p> \\[ S = x \\cdot \\frac{r^n - 1}{r - 1} \\] <p>\u00cen mod particular, dac\u0103 \\(r = 1\\), suma primilor \\(n\\) termeni este \\(n \\cdot x\\), deoarece to\u021bi termenii sunt constan\u021bi.</p> <p>Aceast\u0103 formul\u0103 se poate ob\u021bine u\u0219or d\u00e2nd factor comun pe \\(x\\) \u0219i demonstr\u00e2nd suma prin induc\u021bie.</p>","tags":["vectori","siruri","fibonacci"]},{"location":"usor/generarea-sirurilor/#sirul-factorialelor-numerelor-naturale","title":"\u0218irul factorialelor numerelor naturale","text":"<p>Factorialul unui num\u0103r natural</p> <p>\u00cen matematic\u0103, factorialul unui num\u0103r \u00eentreg pozitiv \\(n\\), notat cu \\(n!\\), este egal cu produsul numerelor naturale pozitive mai mici sau egale cu \\(n\\). Este o func\u021bie numeric\u0103 discret\u0103 \u0219i o opera\u021bie unar\u0103 (cu un singur operand).</p> <p>Cu alte cuvinte, \\(n! = 1 \\cdot 2 \\cdot 3 \\cdot \\ldots \\cdot n\\)</p> <p>Factorialul unui num\u0103r oarecare \\(n\\) indic\u0103 num\u0103rul de permut\u0103ri (num\u0103rul de posibilit\u0103\u021bi de rearanjare) ale unei mul\u021bimi finite av\u00e2nd \\(n\\) elemente.</p> <p>Primele c\u00e2teva valori ale lui \\(n!\\) sunt urm\u0103toarele:</p> <ul> <li>\\(0! = 1\\)</li> <li>\\(1! = 1\\)</li> <li>\\(2! = 2\\)</li> <li>\\(3! = 6\\)</li> <li>\\(4! = 24\\)</li> <li>\\(5! = 120\\)</li> <li>\\(6! = 720\\)</li> </ul> <p>Observa\u021bie</p> <p>Prin conven\u021bie, \\(0! = 1\\).</p> <p>Observa\u021bie</p> <p>Factorialul poate fi definit \u0219i \u00een func\u021bie de valorile anterioare, unde \\(n! = (n-1)! \\cdot n\\), iar \\(0! = 1\\).</p> <p>Se poate remarca faptul c\u0103 valorile factorialelor cresc foarte repede:</p> <ul> <li>\\(10! = 3 \\ 628 \\ 800\\)</li> <li>\\(13! = 6 \\ 227 \\ 020 \\ 800\\) (deja dep\u0103\u0219e\u0219te valoarea maxim\u0103 pe care o putem   stoca \u00eentr-o variabil\u0103 de tip int)</li> <li>\\(21! = 51 \\ 090 \\ 942 \\ 171 \\ 709 \\ 440 \\ 000\\) (deja dep\u0103\u0219e\u0219te valoarea maxim\u0103   pe care o putem stoca \u00eentr-o variabil\u0103 de tip long long)</li> </ul> <p>De asemenea, valorile factorialelor, \u00eencep\u00e2nd de la \\(5!\\) se termin\u0103 toate cu 0.</p> <p>\u00cen mod particular, putem afla num\u0103rul de zerouri de la sf\u00e2r\u0219itul lui \\(n!\\) \u021bin\u00e2nd cont de faptul c\u0103 pentru a ob\u021bine un zero, trebuie s\u0103 avem un factor de 2 \u0219i unul de 5 (\\(2 \\cdot 5 = 10\\)), iar factorii de 5 apar mult mai rar dec\u00e2t cei de 2.</p> <p>\u00cen general, pe l\u00e2ng\u0103 aplica\u021biile ce implic\u0103 no\u021biuni mai simple, factorialele se vor dovedi a fi esen\u021biale \u00een ceea ce prive\u0219te combinatorica, unde apar \u00een multe formule, \u00eencep\u00e2nd de la no\u021biunile legate de permut\u0103ri.</p>","tags":["vectori","siruri","fibonacci"]},{"location":"usor/generarea-sirurilor/#problema-exemplu-trailing-zeroes","title":"Problem\u0103 exemplu - Trailing Zeroes","text":"<p>Aceast\u0103 problem\u0103 ne cere fix cerin\u021ba de mai sus, aflarea num\u0103rului de 0 de la sf\u00e2r\u0219itul factorialului pentru un num\u0103r \\(n\\) dat. Deoarece \u0219tim c\u0103 avem un num\u0103r suficient de factori de 2 \u00een acest produs, trebuie s\u0103 analiz\u0103m de c\u00e2te ori apare 5 \u00een reprezentarea \u00een factori primi a factorialului.</p> <p>\u00cen primul r\u00e2nd, fiecare num\u0103r divizibil cu 5 adaug\u0103 un zero la acest produs. Dar acest lucru nu este suficient deoarece numerele multiplu de \\(25 = 5^2\\) adaug\u0103 \u00eenc\u0103 un zero, la fel \u0219i cele multiplu de \\(125 = 5^3\\) \u0219.a.m.d.</p> <p>Astfel, num\u0103rul de zerouri de la finalul scrierii lui \\(n!\\) este dat de formula</p> \\[ \\left\\lfloor \\frac{n}{5} \\right\\rfloor + \\left\\lfloor \\frac{n}{5^2} \\right\\rfloor + \\dots + \\left\\lfloor \\frac{n}{5^k} \\right\\rfloor \\] <p>unde \\(\\lfloor x \\rfloor\\) reprezint\u0103 partea \u00eentreag\u0103 a lui \\(x\\), iar \\(5^k\\) este cea mai mare putere a lui 5 mai mic\u0103 sau egal\u0103 cu \\(n\\).</p> <p>Formula lui Legendre</p> <p>\u00cen mod similar, putem defini pentru un num\u0103r prim oarecare \\(p\\) acest rezultat sub forma urm\u0103toare:</p> \\[ \\left\\lfloor \\frac{n}{p} \\right\\rfloor + \\left\\lfloor \\frac{n}{p^2} \\right\\rfloor + \\dots + \\left\\lfloor \\frac{n}{p^k} \\right\\rfloor \\] <p>Acest rezultat este cunoscut sub numele de formula lui Legendre.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    long long numar;\n    cin &gt;&gt; numar;\n\n    long long raspuns = 0;\n    long long puteri5 = 5;\n\n    while (numar &gt;= puteri5) {\n        raspuns += numar / puteri5;\n        puteri5 *= 5;\n    }\n\n    cout &lt;&lt; raspuns &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["vectori","siruri","fibonacci"]},{"location":"usor/generarea-sirurilor/#sirul-lui-fibonacci","title":"\u0218irul lui Fibonacci","text":"<p>\u0218irul lui Fibonacci</p> <p>\u0218irul \\(0, 1, 1, 2, 3, 5, 8, \\dots\\), unde fiecare termen se poate afla ca fiind suma a doi termeni preceden\u021bi se nume\u0219te \u0219irul lui Fibonacci, denumite dup\u0103 matematicianul italian cu acela\u0219i nume.</p> <p>A\u0219a cum s-a men\u021bionat \u0219i \u00een defini\u021bie, vom nota \\(F_n\\) ca fiind cel de-al \\(n\\)-lea num\u0103r Fibonacci, iar aceste numere pot fi definite astfel:</p> <ul> <li>\\(F_0 = 0\\)</li> <li>\\(F_1 = 1\\)</li> <li>\\(F_n = F_{n-1} + F_{n-2}\\)</li> </ul> <p>Aceste numere au numeroase propriet\u0103\u021bi remarcabile, care au fost studiate de matematicieni \u0219i diver\u0219i al\u021bi oameni de \u0219tiin\u021b\u0103, una dintre ele reprezint\u0103 faptul c\u0103 pe m\u0103sur\u0103 ce scriem numere fibonacci mai mari, raportul dintre dou\u0103 valori consecutive Fibonacci se apropie de num\u0103rul de aur.</p> <p>Datorit\u0103 acestui fapt, numerele Fibonacci cresc destul de repede, deja cel de-al 100-lea num\u0103r Fibonacci se apropie de limita maxim\u0103 a long long, aici put\u00e2nd fi g\u0103sit\u0103 o asemenea list\u0103.</p> <p>\u00cen informatic\u0103 ne vom concentra mai ales pe g\u0103sirea acestor termeni \u0219i generalizarea unor propriet\u0103\u021bi pe care le au numerele Fibonacci.</p> <p>Pentru a afla cel de-al \\(n\\)-lea num\u0103r Fibonacci, putem folosi un algoritm destul de simplu, care se bazeaz\u0103 pe un for sau un while.</p> <pre><code>int a = 0;\nint b = 1;\n\nfor (int i = 2; i &lt;= n; i++) {\n    int c = a + b;\n    a = b;\n    b = c;\n}\n\ncout &lt;&lt; b &lt;&lt; '\\n';\n</code></pre> <p>Algoritm mai rapid</p> <p>Exist\u0103 un algoritm mai rapid, care ruleaz\u0103 \u00een \\(\\mathcal{O}(\\log n)\\) care se bazeaz\u0103 pe cuno\u0219tin\u021be mai avansate de algebr\u0103 liniar\u0103 \u0219i lucru cu matrici. Pentru mai multe detalii, pute\u021bi citi aici.</p>","tags":["vectori","siruri","fibonacci"]},{"location":"usor/generarea-sirurilor/#problema-exemplu-fibosum-pbinfo","title":"Problema exemplu - fibosum pbinfo","text":"<p>Pentru a rezolva aceast\u0103 problem\u0103, trebuie s\u0103 afl\u0103m toate valorile Fibonacci mai mici sau egale cu \\(n\\), iar mai apoi s\u0103 construim suma folosind termeni \u00een ordine descresc\u0103toare.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint numar, fib[150];\n\nint main() {\n    cin &gt;&gt; numar;\n\n    fib[1] = 1;\n    fib[2] = 2;\n\n    int i = 2;\n    while (fib[i] &lt;= numar) {\n        ++i;\n        fib[i] = fib[i - 1] + fib[i - 2];\n    }\n\n    // Descompunem num\u0103rul n \u00een termeni din \u0219irul Fibonacci\n    while (numar &gt; 0) {\n        // C\u0103ut\u0103m cel mai mare termen mai mic sau egal cu num\u0103rul r\u0103mas\n        while (numar &gt;= fib[i]) {\n            cout &lt;&lt; fib[i] &lt;&lt; \" \";\n\n            // Am folosit termenul, \u00eel sc\u0103dem \u0219i mergem la urm\u0103torul\n            numar -= fib[i];\n        }\n\n        // Trecem la urm\u0103torul termen mai mic din Fibonacci\n        --i;\n    }\n    return 0;\n}\n</code></pre>","tags":["vectori","siruri","fibonacci"]},{"location":"usor/generarea-sirurilor/#concluzii","title":"Concluzii","text":"<p>\u0218irurile de numere naturale sunt foarte importante deoarece apar \u00een multe probleme algoritmice \u0219i leag\u0103 cuno\u0219tin\u021bele ob\u021binute la matematic\u0103 cu aplicarea lor algoritmic\u0103.</p> <p>Fie c\u0103 e vorba de \u0219iruri precum cel al lui Fibonacci sau diferitele \u0219iruri matematice discutate, cunoa\u0219terea acestor no\u021biuni va deveni foarte important\u0103 pentru orice programator \u00eencep\u0103tor \u0219i nu numai.</p>","tags":["vectori","siruri","fibonacci"]},{"location":"usor/generarea-sirurilor/#probleme-suplimentare","title":"Probleme suplimentare","text":"<ul> <li>Probleme \u00een care se genereaz\u0103 \u0219iruri de pe pbinfo</li> <li>pbinfo fiboverif</li> <li>pbinfo generare</li> <li>pbinfo sirk</li> <li>pbinfo sumapatrate</li> <li>pbinfo regula</li> <li>OJI 2006 factori</li> <li>ONI 2019 fibofrac</li> <li>Lot Juniori 2010 fibo</li> </ul>","tags":["vectori","siruri","fibonacci"]},{"location":"usor/generarea-sirurilor/#resurse-suplimentare","title":"Resurse suplimentare","text":"<ul> <li>Generarea sirurilor recurente - CPPI Sync</li> <li>Factorial - wikipedia</li> <li>Sirul lui Fibonacci - pbinfo</li> <li>Sirul lui Fibonacci - wikipedia</li> <li>Progresie aritmetica - wikipedia</li> <li>Progresie geometrica - wikipedia</li> <li>Factorial - pbinfo</li> </ul>","tags":["vectori","siruri","fibonacci"]},{"location":"usor/graphs/","title":"Introducere \u00een teoria grafurilor","text":"<p>\u00cen cele ce urmeaz\u0103 vom prezenta o structur\u0103 de date cu foarte multe aplica\u021bii at\u00e2t \u00een algoritmic\u0103, c\u00e2t \u0219i \u00een via\u021ba de zi cu zi, acestea fiind grafurile. Problema afl\u0103rii existen\u021bei unor conexiuni sau afl\u0103rii distan\u021bei minime \u00eentre dou\u0103 noduri reprezint\u0103 un punct de plecare pentru majoritatea algoritmilor pe grafuri, teoria folosit\u0103 \u00een algoritmic\u0103 fiind una vast\u0103 \u0219i plin\u0103 de abord\u0103ri ce se dovedesc a fi esen\u021biale \u00een foarte multe situa\u021bii, at\u00e2t competi\u021bionale, c\u00e2t \u0219i \u00een aplica\u021bii practice.</p>","tags":["grafuri","parcurgeri","DFS","BFS","drumuri"]},{"location":"usor/graphs/#notiuni-introductive","title":"No\u021biuni introductive","text":"","tags":["grafuri","parcurgeri","DFS","BFS","drumuri"]},{"location":"usor/graphs/#terminologie","title":"Terminologie","text":"<p>Un graf este o structur\u0103 care corespunde unui grup de obiecte, \u00een care unele perechi de obiecte sunt \u00eentr-un anumit sens \u201elegate\u201d reciproc. Obiectele corespund unor abstrac\u021bii matematice numite \u00eentr-un graf noduri/v\u00e2rfuri (numite \u0219i puncte) \u0219i fiecare leg\u0103tur\u0103 dintre perechile de obiecte asociate se nume\u0219te muchie (numit\u0103 \u0219i arc sau linie, prin care este \u0219i reprezentat\u0103).</p> <p>O defini\u021bie mai riguroas\u0103 ce se va dovedi util\u0103 este prezentat\u0103 aici:</p> <p>No\u021biunea de graf</p> <p>Un graf \\(G = (V, E)\\) este o structur\u0103 matematic\u0103 compus\u0103 din dou\u0103 mul\u021bimi:</p> <ul> <li> <p>\\(V\\) (mul\u021bimea v\u00e2rfurilor sau nodurilor), care reprezint\u0103 obiectele;</p> </li> <li> <p>\\(E \\subseteq V \\times V\\) (mul\u021bimea muchiilor sau arcelor), care reprezint\u0103   leg\u0103turile \u00eentre perechi de v\u00e2rfuri.</p> </li> </ul> <p>Fiecare element $ v \\in V$ este numit v\u00e2rf (sau nod), iar fiecare element $ e = (u, v) \\in E$ este numit muchie (sau arc). \u00cen mod obi\u0219nuit, grafurile sunt reprezentate grafic printr-un set de puncte (corespunz\u0103toare v\u00e2rfurilor) conectate prin linii sau curbe (corespunz\u0103toare muchiilor).</p> <p>Voi continua prin a defini termeni ce se dovedesc a fi esen\u021biali pentru \u00een\u021belegerea grafurilor.</p> <p>Graf orientat \u0219i neorientat</p> <p>Un graf neorientat \\(G = (V, E)\\) este un graf \u00een care perechile de v\u00e2rfuri \\((u, v) \\in E\\) sunt neordonate. Aceasta \u00eenseamn\u0103 c\u0103, dac\u0103 \\((u, v) \\in E\\) este o muchie de la \\(u\\) la \\(v\\), atunci \u0219i \\((v, u) \\in E\\).</p> <p>Prin compara\u021bie, un graf orientat este un graf \u00een care perechile de v\u00e2rfuri \\((u, v) \\in E\\) sunt ordonate. Aceasta \u00eenseamn\u0103 c\u0103, dac\u0103 \\((u, v) \\in E\\), atunci \\((v, u) \\not\\in E\\).</p> <p>Noduri adiacente</p> <p>Dou\u0103 noduri \\(u\\) \u0219i \\(v\\) sunt adiacente \u00een graful \\(G = (V, E)\\) dac\u0103 exist\u0103 o muchie $ (u, v) \\in E $. Adic\u0103, exist\u0103 o leg\u0103tur\u0103 direct\u0103 \u00eentre \\(u\\) \u0219i \\(v\\).</p> <p>Formal:</p> \\[ u \\text{ \u0219i } v \\text{ sunt adiacente} \\iff (u, v) \\in E \\text{ sau } (v, u) \\in E \\text{ (\u00een cazul grafurilor neorientate)} \\] <p>Inciden\u021b\u0103</p> <p>Folosim no\u021biunea de inciden\u021b\u0103 pentru a descrie rela\u021bia dintre noduri \u0219i muchii. O muchie \\((u, v) \\in E\\) este incident\u0103 cu nodurile \\(u\\) \u0219i \\(v\\).</p> <p>Gradul unui nod</p> <p>Definim gradul unui nod \\(v\\) dintr-un graf \\(G = (V, E)\\) ca fiind num\u0103rul de muchii incidente cu \\(v\\).</p> <p>\u00centr-un graf neorientat, gradul nodului \\(v\\), notat \\(\\deg(v)\\), este num\u0103rul de muchii care au \\(v\\) ca una dintre extremit\u0103\u021bi.</p> \\[ \\deg(v) = |\\{(u, v) \\in E \\text{ sau } (v, u) \\in E \\mid u \\in V\\}| \\] <p>\u00centr-un graf orientat, se pot defini dou\u0103 tipuri de grad:</p> <ul> <li> <p>Gradul intern (num\u0103rul de muchii care intr\u0103 \u00een nodul \\(v\\)), notat   \\(\\deg^-(v)\\): $ \\deg^-(v) = |{(u, v) \\in E \\mid u \\in V}|$</p> </li> <li> <p>Gradul extern (num\u0103rul de muchii care ies din nodul \\(v\\)), notat   \\(\\deg^+(v)\\): $ \\deg^+(v) = |{(v, u) \\in E \\mid u \\in V}|$</p> </li> </ul> <p>Observa\u021bie</p> <p>\u00centr-un graf neorientat \\(G = (V, E)\\):</p> \\[ \\sum_{v \\in V} \\deg(v) = 2k,\\,k \\in \\mathbb{N} \\] <p>Explica\u021bia este dat\u0103 de faptul c\u0103 pentru fiecare muchie ad\u0103ugat\u0103, gradul a dou\u0103 noduri cre\u0219te cu 1.</p> <p>Lan\u021b</p> <p>Numim lan\u021b o secven\u021b\u0103 de noduri \\((v_1, v_2, ..., v_k)\\) cu proprietatea c\u0103 \\((v_i, v_{i + 1}) \\in E\\) oricare ar fi \\(1 \\leq i \\leq k\\). Un lan\u021b este -elementar dac\u0103 \\(v_i \\neq v_j\\) oricare ar fi \\(1 \\leq i &lt; j \\leq k\\). Un lan\u021b este simplu* dac\u0103 \\((v_i, v_{i + 1}) \\neq (v_j, v_{j+1})\\) oricare ar fi \\(1 \\leq i &lt; j \\leq k\\).</p> <p>Altfel spus, un lan\u021b elementar este un lan\u021b cu nodurile distincte, iar un lan\u021b simplu este un lan\u021b cu muchii distincte.</p> <p>Ciclu</p> <p>O secven\u021b\u0103 de muchii \\((v_1, v_2, ..., v_k, v_1)\\) formeaz\u0103 un ciclu dac\u0103 \\((v_i, v_{i + 1}) \\in E\\) pentru orice \\(1 \\leq i &lt; k\\) \u0219i \\((v_k, v_1) \\in E\\). Un ciclu este simplu dac\u0103 \\(v_i \\neq v_j\\) pentru orice \\(1 \\leq i &lt; j &lt; k\\).</p> <p>Altfel spus, un ciclu reprezint\u0103 o secven\u021b\u0103 de muchii ce nu se repet\u0103, pleac\u0103 de la un nod \\(v_1\\) \u0219i parcurg\u00e2nd \u00een ordine acele muchii, se ajunge tot la nodul \\(v_1\\). Un ciclu simplu este un ciclu \u00een care nu se repet\u0103 noduri.</p> <p>Lungimea unui lan\u021b</p> <p>Lungimea unui lan\u021b \\((v_1, v_2, ..., v_k)\\) este \\(k-1\\) (num\u0103rul de muchii). Uneori, aceasta se define\u0219te ca fiind num\u0103rul de noduri, a\u0219adar lungimea acestui lan\u021b este \\(k\\).</p> <p>Graf par\u021bial \u0219i subgraf</p> <p>Definim graf par\u021bial al unui graf dat ca fiind ceea ce r\u0103m\u00e2ne din graful dat p\u0103str\u00e2nd toate nodurile \u0219i elimin\u00e2nd eventual unele muchii, f\u0103r\u0103 a ad\u0103uga muchii noi.</p> <p>Formal spus, un graf par\u021bial \\(G' = (V, E')\\) a grafului \\(G = (V, E)\\) este un graf unde \\(E' \\subseteq E\\).</p> <p>Definim subgraf al unui graf dat ca fiind ceea ce r\u0103m\u00e2ne din graful dat elimin\u00e2nd unele noduri \u0219i doar muchiile incidente lor, deci nu \u0219i alte muchii \u0219i f\u0103r\u0103 s\u0103 ad\u0103ug\u0103m alte muchii.</p> <p>Formal spus, un subgraf \\(G' = (V', E')\\) al unui graf \\(G = (V, E)\\) este un graf unde \\(V' \\subseteq V\\) \u0219i \\(E' \\subseteq \\{(u, v) \\in E \\mid u, v \\in V'\\}\\).</p> <p>Observa\u021bie</p> <p>Num\u0103rul de subgrafuri ale unui graf \\(G = (V, E)\\) este \\(2^{|V|}\\), iar num\u0103rul de grafuri par\u021biale este \\(2^{|E|}\\), unde \\(|V| = n\\) este num\u0103rul de noduri, iar \\(|E| = m\\) este num\u0103rul de muchii al grafului.</p>","tags":["grafuri","parcurgeri","DFS","BFS","drumuri"]},{"location":"usor/graphs/#cateva-tipuri-speciale-de-grafuri","title":"C\u00e2teva tipuri speciale de grafuri","text":"<p>Se remarc\u0103 faptul c\u0103 \u00een func\u021bie de tipul grafului, mai putem defini urm\u0103toarele tipuri de grafuri, care se vor folosi \u00een diferite aplica\u021bii. De notat ca pentru unele din aceste tipuri, vom avea probleme unde vom explica \u00een detaliu no\u021biunile \u0219i aplica\u021biile unde folosim aceste concepte.</p> <p>Graf complet \\(K_n\\)</p> <p>Definim un graf complet \\(K_n = (V, E)\\) cu \\(|V| = n\\) ca fiind un graf unde \\((v_i, v_j) \\in E\\ \\forall 1 \\leq i &lt; j \\leq n\\). Altfel spus, fiecare nod este conectat cu toate celelalte noduri.</p> <p>Num\u0103rul de muchii ale unui graf complet \\(K_n\\) este \\(|E| = \\frac{n(n-1)}{2}\\).</p> <p>Graf bipartit</p> <p>Definim un graf bipartit \\(G = (A, B, E)\\) ca fiind un graf care poate fi \u00eemp\u0103r\u021bit \u00een dou\u0103 submul\u021bimi \\(V = A \\cup B\\) cu \\(A \\cap B = \\emptyset\\), astfel \u00eenc\u00e2t, dac\u0103 \\(a \\in A\\), atunci acesta se poate conecta doar cu \\(b \\in B\\) \u0219i viceversa.</p> <p>Observa\u021bie</p> <p>Are loc urm\u0103toarea rela\u021bie pentru un graf bipartit \\(G = (A, B, E)\\): [     \\sum_{a \\in a} \\deg(a) = \\sum_{b \\in B} \\deg(b) = |E| ]</p> <p>Observa\u021bie</p> <p>Un graf este bipartit dac\u0103 \u0219i numai dac\u0103 acesta nu con\u021bine un ciclu de lungime impar\u0103.</p> <p>Graf planar</p> <p>Definim un graf planar ca fiind un graf care are proprietatea c\u0103 poate fi reprezentat grafic f\u0103r\u0103 ca dou\u0103 muchii s\u0103 se intersecteze.</p> <p>Graf regulat</p> <p>Un graf regulat \\(G = (V, E)\\) este un graf \u00een care \\(\\deg(v) = k\\ \\forall v \\in V\\). Adic\u0103, fiecare nod din graf are acela\u0219i num\u0103r de muchii incidente.</p> <p>Un graf regulat cu nodurile de gradul \\(k\\) se nume\u0219te graf \\(k\\)-regulat.</p> <p>Observa\u021bie</p> <p>Condi\u021bia necesar\u0103 \u0219i suficient\u0103 pentru ca un graf \\(k\\)-regulat de ordin \\(n\\) s\u0103 existe este ca \\(n \\geq k + 1\\) \u0219i c\u0103 \\(nk\\) este par.</p> <p>Num\u0103rul de muchii este maxim \u00eentr-un graf complet \\(K_n\\), acesta fiind \\(\\frac{n(n - 1)}{2}\\) cu fiecare nod de gradul \\(n - 1\\). A\u0219adar, \\(k = n - 1\\), sau \\(n = k + 1\\) este \\(n\\) minim pentru un \\(k\\) anume. De asemenea, dup\u0103 rela\u021bia de mai sus, avem \\(\\frac{nk}{2}\\) muchii, deci \\(nk\\) trebuie s\u0103 fie par.</p>","tags":["grafuri","parcurgeri","DFS","BFS","drumuri"]},{"location":"usor/graphs/#lucrul-cu-grafuri-moduri-de-reprezentare-in-memorie","title":"Lucrul cu grafuri. Moduri de reprezentare \u00een memorie","text":"<p>Un concept foarte important \u00een teoria grafurilor reprezint\u0103 modul \u00een care parcurgem aceste structuri de date \u0219i cum putem verifica propriet\u0103\u021bile de care avem nevoie, de la o problem\u0103 la alta.</p> <p>S\u0103 consider\u0103m graful neorientat din figura urm\u0103toare:</p> <p>Acest graf are 13 noduri \u0219i 12 muchii, acestea fiind \\((1, 4)\\), \\((1, 3)\\), \\((4, 9)\\), \\((9, 3)\\), \\((4, 2)\\), \\((4, 6)\\), \\((2, 6)\\), \\((2, 5)\\), \\((8, 12)\\), \\((8, 11)\\), \\((8, 10)\\), \\((8, 7)\\).</p> <p>Pentru a reprezenta un graf \u00een memorie, exist\u0103 trei moduri principale de a o face, cu distinc\u021bia c\u0103 \u00een practic\u0103 se va folosi doar reprezentarea prin liste de vecini.</p> <p>Matrice de adiacen\u021b\u0103</p> <p>Definim matricea de adiacen\u021b\u0103 a unui graf ca fiind o matrice binar\u0103 pentru care \\(a_{ij} = 1\\) dac\u0103 \u0219i numai dac\u0103 avem muchie de la nodul \\(i\\) la nodul \\(j\\) \u0219i \\(a_{ij} = 0\\) \u00een caz contrar.</p> <p>Observa\u021bie</p> <p>Pentru un graf neorientat, matricea este mereu simetric\u0103, adic\u0103 \\(a_{ij} = a_{ji}\\ \\forall i, j\\).</p> <p>Pentru graful nostru de mai sus, aceasta este matricea de adiacen\u021b\u0103 la care ajungem.</p> <p>List\u0103 de vecini</p> <p>Definim o list\u0103 de vecini ca fiind o list\u0103 (de regul\u0103, alocat\u0103 dinamic) pe care o folosim pentru a \u021bine \u00een memorie pentru fiecare nod doar nodurile adiacente cu acesta, aceast\u0103 metod\u0103 fiind cea mai eficient\u0103 din punct de vedere practic pentru a parcurge grafurile.</p> <p>Exemplu</p> <p>Pentru graful de mai sus, aceasta este lista de vecini:</p> Nod Vecini 1 \\(\\{3,4\\}\\) 2 \\(\\{4,5,6\\}\\) 3 \\(\\{1,9\\}\\) 4 \\(\\{1,2,9\\}\\) 5 \\(\\{2\\}\\) 6 \\(\\{2, 4\\}\\) 7 \\(\\{8\\}\\) 8 \\(\\{7,10,11,12\\}\\) 9 \\(\\{3,4\\}\\) 10 \\(\\{8\\}\\) 11 \\(\\{8\\}\\) 12 \\(\\{8\\}\\) 13 \\(\\emptyset\\) <p>List\u0103 de muchii</p> <p>Definim o list\u0103 de muchii ca fiind o list\u0103 pe care o folosim pentru a \u021bine toate muchiile \u00een memorie. De\u0219i nu este o variant\u0103 prea practic\u0103 de a efectua parcurgerile, aceast\u0103 metod\u0103 poate fi util\u0103 pentru anumi\u021bi algoritmi ce se bazeaz\u0103 \u00een principal pe prelucrarea muchiilor, un astfel de exemplu fiind arborele par\u021bial de cost minim.</p> <p>Exemplu</p> <p>\u00cen cazul nostru, lista de muchii este: \\(\\{1, 4\\}\\), \\(\\{1, 3\\}\\), \\(\\{4,9\\}\\), \\(\\{9,3\\}\\), \\(\\{4,2\\}\\), \\(\\{4,6\\}\\), \\(\\{2,6\\}\\), \\(\\{2,5\\}\\), \\(\\{8,12\\}\\), \\(\\{8,11\\}\\), \\(\\{8,10\\}\\), \\(\\{8,7\\}\\).</p>","tags":["grafuri","parcurgeri","DFS","BFS","drumuri"]},{"location":"usor/graphs/#conexitate-parcurgerea-dfs","title":"Conexitate. Parcurgerea DFS","text":"<p>Problema afl\u0103rii conexit\u0103\u021bii unui graf este una din problemele fundamentale ale teoriei grafurilor, fiind adesea folosit\u0103 drept un exemplu esen\u021bial \u00een explicarea \u0219i \u00een\u021belegerea grafurilor.</p> <p>Graf conex</p> <p>Un graf conex este un graf neorientat \u00een care exist\u0103 o cale \u00eentre oricare dou\u0103 noduri. Cu alte cuvinte, oricare dou\u0103 noduri din graf sunt conectate direct sau indirect printr-o serie de muchii.</p> <p>Componenta conex\u0103</p> <p>O component\u0103 conex\u0103 a unui graf este un subgraf conex maximal, adic\u0103 un subgraf \u00een care oricare dou\u0103 noduri sunt conectate printr-o serie de muchii, iar acest subgraf nu poate fi extins ad\u0103ug\u00e2nd vreun alt nod sau vreo alt\u0103 muchie f\u0103r\u0103 a pierde proprietatea de conexitate.</p> <p>Pentru a rezolva problema afl\u0103rii conexit\u0103\u021bii unui graf, va trebui s\u0103 parcurgem graful folosind unul din algoritmii consacra\u021bi pentru aceast\u0103 problem\u0103. \u00cen cazul de fa\u021b\u0103, vom continua prin a explica parcurgerea \u00een ad\u00e2ncime a grafului (DFS sau depth-first search), una din parcurgerile optime pentru aceast\u0103 problem\u0103.</p> <p>Parcurgerea \u00een ad\u00e2ncime (DFS)</p> <p>Parcurgerea \u00een ad\u00e2ncime (DFS) este un algoritm de explorare a grafului care \u00eencepe de la un nod ales \u0219i viziteaz\u0103 c\u00e2t mai mult posibil din vecinii acestuia \u00eenainte de a se \u00eentoarce \u00eenapoi. Aceasta se realizeaz\u0103 printr-o strategie de backtracking recursiv\u0103 sau prin utilizarea unei stive (stack).</p> <p>DFS \u00eencepe de la un nod \u0219i viziteaz\u0103 toate nodurile pe care le poate atinge \u00een ad\u00e2ncime \u00eenainte de a reveni la nodurile anterioare \u0219i verific\u0103 dac\u0103 un nod a fost deja vizitat pentru a evita bucle infinite.</p> <p>Observa\u021bie</p> <p>Complexitatea parcurgerii \u00een ad\u00e2ncime (DFS) este \\(\\mathcal{O}(\\lvert V \\rvert + \\lvert E \\lvert)\\), unde \\(\\lvert V \\rvert\\) reprezint\u0103 num\u0103rul de noduri sau v\u00e2rfuri \u0219i \\(\\lvert E \\rvert\\) reprezint\u0103 num\u0103rul de muchii.</p> <p>Observa\u021bie</p> <p>\u00cen probleme se noteaz\u0103 conven\u021bional \\(\\lvert V \\rvert\\) cu \\(N\\) de la noduri, respectiv \\(\\lvert E \\rvert\\) cu \\(M\\) de la muchii.</p> <p>Observa\u021bie</p> <p>Se remarc\u0103 faptul c\u0103 un nod va fi vizitat la un moment dat doar o singur\u0103 dat\u0103, deci dac\u0103 avem muchiile \\((1, 2)\\), \\((1, 3)\\) \u0219i \\((2, 3)\\), iar DFS-ul pleac\u0103 din 1, 2 va fi accesat din 1, iar 3 va fi accesat din 2.</p> <p>Observa\u021bie</p> <p>Se poate remarca faptul c\u0103 ordinea \u00een care vizit\u0103m nodurile \u00een graf depinde de ordinea \u00een care sunt ad\u0103ugate muchiile \u00een graf, acest lucru \u00eenseamn\u0103 c\u0103 nu putem folosi DFS pentru anumite probleme, de exemplu cele la care trebuie aflat\u0103 distan\u021ba minim\u0103 \u00een graf.</p> <p>Ca o recapitulare (sau de fapt compara\u021bie) \u00eentre BFS \u0219i DFS, s\u0103 compar\u0103m fiecare abordare \u00eempreun\u0103 cu o func\u021bie:</p> DFSBFS <pre><code>vector&lt;vector&lt;int&gt;&gt; graf;\n\nvoid dfs(int nod, vector&lt;bool&gt;&amp; vizitat) {\n    vizitat[nod] = true;\n\n    // Ca exemplu\n    cout &lt;&lt; nod &lt;&lt; ' ';\n\n    for (auto vecin : graf[nod]) {\n        if (!vizitat[vecin]) {\n            dfs(vecin, vizitat);\n        }\n    }\n}\n</code></pre> <pre><code>vector&lt;vector&lt;int&gt;&gt; graf;\nvector&lt;int&gt; distanta;\nqueue&lt;int&gt; q;\n\nvoid bfs(int nod_start) {\n    q.push(nod_start);\n    distanta[nod_start] = 0;\n\n    while (!q.empty()) {\n        int nod = q.front();\n        q.pop();\n\n        for (auto vecin : graf[nod]) {\n            if (distanta[vecin] == -1) {\n                distanta[vecin] = distanta[nod] + 1;\n                q.push(vecin);\n            }\n        }\n    }\n}\n</code></pre>","tags":["grafuri","parcurgeri","DFS","BFS","drumuri"]},{"location":"usor/graphs/#problema-connected-components-de-pe-kilonova","title":"Problema Connected components de pe kilonova","text":"<p>Se d\u0103 un graf neorientat \\(G\\) cu \\(N\\) noduri \u0219i \\(M\\) muchii. S\u0103 se afle c\u00e2te componente conexe are graful dat.</p> <p>Pentru a afla num\u0103rul de componente conexe ale unui graf, putem folosi parcurgerea DFS pentru a afla toate nodurile din care apel\u0103m DFS din func\u021bia <code>main</code>, acesta fiind \u0219i r\u0103spunsul la problema noastr\u0103.</p> <pre><code>#include &lt;iostream&gt;\n#include &lt;vector&gt;\n\nusing namespace std;\n\nvector&lt;vector&lt;int&gt;&gt; graf;\nvector&lt;bool&gt; vizitat;\n\nvoid dfs(int nod) {\n    vizitat[nod] = true;\n\n    for (int vecin : graf[nod]) {\n        if (!vizitat[vecin]) {\n            dfs(vecin);\n        }\n    }\n}\n\nint main() {\n    int noduri, muchii;\n    cin &gt;&gt; noduri &gt;&gt; muchii;\n\n    graf.resize(noduri + 1);\n    vizitat.resize(noduri + 1, false);\n\n    for (int i = 0; i &lt; muchii; ++i) {\n        int a, b;\n        cin &gt;&gt; a &gt;&gt; b;\n\n        graf[a].push_back(b);\n        graf[b].push_back(a);\n    }\n\n    int componente_conexe = 0;\n    for (int nod = 1; nod &lt;= noduri; ++nod) {\n        if (!vizitat[nod]) {\n            ++componente_conexe;\n            dfs(nod);\n        }\n    }\n\n    cout &lt;&lt; componente_conexe &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["grafuri","parcurgeri","DFS","BFS","drumuri"]},{"location":"usor/graphs/#drumuri-minime-parcurgerea-bfs","title":"Drumuri minime. Parcurgerea BFS","text":"<p>Dac\u0103 \u00een cazul parcurgerii DFS putem s\u0103 o aplic\u0103m f\u0103r\u0103 mari probleme pentru o varietate destul de larg\u0103 de probleme cu grafuri, totu\u0219i nu este suficient\u0103 pentru problemele ce \u021bin de distan\u021be. Un exemplu fundamental este acela al afl\u0103rii drumului minim \u00eentre dou\u0103 sau mai multe noduri \u00eentr-un graf dat.</p> <p>Drum minim</p> <p>Un drum minim este lungimea minim\u0103 a unui lan\u021b care leag\u0103 dou\u0103 noduri din graf.</p> <p>Motivul pentru care nu putem afla drumul minim \u00eentre dou\u0103 noduri folosind DFS este acela c\u0103 ordinea \u00een care nodurile sunt parcurse \u00een DFS depinde de ordinea \u00een care sunt date muchiile de la intrare, parcurgerea recursiv\u0103 f\u0103c\u00e2nd aflarea distan\u021belor minime imposibil\u0103. Astfel, vom introduce un alt mod de a parcurge graful nostru.</p> <p>Parcurgerea \u00een l\u0103\u021bime (BFS)</p> <p>Parcurgerea \u00een l\u0103\u021bime** (BFS, engl. breadth-first search) a unui graf ca fiind o parcurgere iterativ\u0103 ce pleac\u0103 de la unul sau mai multe noduri, iar la fiecare pas, dac\u0103 ne afl\u0103m la un nod \\(x\\), vom vizita vecinii nevizita\u021bi ai nodului \\(x\\), ad\u0103ug\u00e2ndu-i \u00eentr-o coad\u0103, nodurile fiind parcurse \u00een ordinea \u00een care au fost ad\u0103ugate \u00een coad\u0103.</p> <p>Observa\u021bie</p> <p>Complexitatea parcurgerii \u00een l\u0103\u021bime (BFS) este \\(\\mathcal{O}(\\lvert V \\rvert + \\lvert E \\lvert)\\), unde \\(\\lvert V \\rvert\\) reprezint\u0103 num\u0103rul de noduri sau v\u00e2rfuri \u0219i \\(\\lvert E \\rvert\\) reprezint\u0103 num\u0103rul de muchii.</p> <p>Observa\u021bie</p> <p>Se poate remarca faptul c\u0103 ordinea \u00een care vizit\u0103m nodurile \u00een graf va fi aceea\u0219i cu ordinea cresc\u0103toare a distan\u021bei minime fa\u021b\u0103 de nodul sau nodurile ini\u021biale, datorit\u0103 faptului c\u0103 ele vor fi inserate \u00een coad\u0103 \u00een ordinea \u00een care acestea au fost ad\u0103ugate.</p>","tags":["grafuri","parcurgeri","DFS","BFS","drumuri"]},{"location":"usor/graphs/#problema-simple-shortest-path-de-pe-kilonova","title":"Problema Simple Shortest Path de pe kilonova","text":"<p>Se d\u0103 un graf neorientat \\(G\\) cu \\(N\\) noduri \u0219i \\(M\\) muchii, precum \u0219i un nod \\(S\\). S\u0103 se afle lungimea drumului minim dintre \\(S\\) \u0219i fiecare nod din graf, inclusiv \\(S\\).</p> <p>Pentru a rezolva aceast\u0103 problem\u0103, vom pleca cu un BFS din nodul \\(S\\) \u0219i vom afla pe parcurs, distan\u021bele minime fa\u021b\u0103 de toate celelalte noduri.</p> <pre><code>#include &lt;iostream&gt;\n#include &lt;queue&gt;\n#include &lt;vector&gt;\n\nusing namespace std;\n\nint main() {\n    int noduri, muchii, nod_start;\n    cin &gt;&gt; noduri &gt;&gt; muchii &gt;&gt; nod_start;\n\n    vector&lt;vector&lt;int&gt;&gt; graf(noduri);\n    vector&lt;int&gt; distante(noduri, -1);\n    queue&lt;int&gt; q;\n\n    for (int i = 0; i &lt; muchii; i++) {\n        int a, b;\n        cin &gt;&gt; a &gt;&gt; b;\n        graf[a].push_back(b);\n        graf[b].push_back(a);\n    }\n\n    distante[nod_start] = 0;\n    q.push(nod_start);\n\n    while (!q.empty()) {\n        int nod_curent = q.front();\n        q.pop();\n\n        for (auto vecin : graf[nod_curent]) {\n            if (distante[vecin] == -1) {\n                distante[vecin] = distante[nod_curent] + 1;\n                q.push(vecin);\n            }\n        }\n    }\n\n    for (const auto&amp; distanta : distante) {\n        cout &lt;&lt; distanta &lt;&lt; \" \";\n    }\n\n    cout &lt;&lt; '\\n';\n\n    return 0;\n}\n</code></pre>","tags":["grafuri","parcurgeri","DFS","BFS","drumuri"]},{"location":"usor/graphs/#problema-grarb-de-pe-infoarena","title":"Problema grarb de pe infoarena","text":"<p>Se d\u0103 un graf \\(G\\) neorientat cu \\(N\\) noduri numerotate de la 1 la \\(N\\) \u0219i \\(M\\) muchii. Determina\u021bi num\u0103rul minim de muchii care trebuie eliminate \u0219i num\u0103rul minim de muchii care trebuie ad\u0103ugate \u00een graful \\(G\\) astfel \u00eenc\u00e2t acesta sa devina arbore.</p> <p>Aceast\u0103 problem\u0103 se \u00eemparte \u00een dou\u0103 subprobleme relativ u\u0219or de identificat - aflarea componentelor conexe ale grafului (dac\u0103 avem \\(C\\) componente conexe, va fi nevoie de \\(C - 1\\) muchii pentru a transforma graful \u00eentr-unul conex), precum \u0219i aflarea num\u0103rului de muchii care trebuie scoase pentru a transforma graful \u00een arbore (la final, trebuie s\u0103 ne r\u0103m\u00e2n\u0103 \\(N-1\\) muchii). Astfel, vom avea nevoie de \\(C - 1\\) muchii noi \u0219i va trebui s\u0103 scoatem \\(M + C - 1 - (N - 1)\\) = \\(M + C - N\\) muchii pentru a avea un arbore.</p> <pre><code>#include &lt;fstream&gt;\n#include &lt;vector&gt;\n\nusing namespace std;\n\nvector&lt;vector&lt;int&gt;&gt; graf;\nvector&lt;bool&gt; vizitat;\n\nvoid dfs(int nod) {\n    vizitat[nod] = true;\n    for (auto vecin : graf[nod]) {\n        if (!vizitat[vecin]) {\n            dfs(vecin);\n        }\n    }\n}\n\nint main() {\n    ifstream fin(\"grarb.in\");\n    ofstream fout(\"grarb.out\");\n\n    int noduri, muchii;\n    fin &gt;&gt; noduri &gt;&gt; muchii;\n\n    graf.resize(noduri + 1);\n    vizitat.resize(noduri + 1, false);\n\n    for (int i = 0; i &lt; muchii; i++) {\n        int a, b;\n        fin &gt;&gt; a &gt;&gt; b;\n        graf[a].push_back(b);\n        graf[b].push_back(a);\n    }\n\n    int componente_conexe = 0;\n    for (int i = 1; i &lt;= noduri; i++) {\n        if (!vizitat[i]) {\n            dfs(i);\n            componente_conexe++;\n        }\n    }\n\n    int muchii_de_eliminat = muchii - noduri + componente_conexe;\n    int muchii_de_adaugat = componente_conexe - 1;\n\n    fout &lt;&lt; muchii_de_eliminat &lt;&lt; '\\n' &lt;&lt; muchii_de_adaugat &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["grafuri","parcurgeri","DFS","BFS","drumuri"]},{"location":"usor/graphs/#problema-graf-oji-2006-de-pe-kilonova","title":"Problema Graf (OJI 2006) de pe kilonova","text":"<p>Se d\u0103 un graf neorientat conex cu \\(N\\) noduri \u0219i dou\u0103 noduri \\(X\\) \u0219i \\(Y\\), s\u0103 se afle nodurile ce apar\u021bin tuturor lan\u021burilor optime \u00eentre \\(X\\) \u0219i \\(Y\\).</p> <p>Pentru a rezolva aceast\u0103 problem\u0103, va trebui mai \u00eent\u00e2i s\u0103 afl\u0103m folosind o parcurgere de tip BFS distan\u021bele minime de la \\(X\\) \u0219i \\(Y\\) spre toate celelalte noduri. Apoi, pentru fiecare distan\u021b\u0103 \\(d\\) de la 0 la \\(\\operatorname{dist}(X, Y)\\), vrem s\u0103 afl\u0103m c\u00e2te noduri se afl\u0103 pe unul din drumurile optime de la \\(X\\) la \\(Y\\) la o distan\u021b\u0103 \\(d\\) fa\u021b\u0103 de \\(X\\). \u00cen cele din urm\u0103, vrem s\u0103 afi\u0219\u0103m nodurile situate la distan\u021bele care apar o singur\u0103 dat\u0103 \u00een mul\u021bimea nodurilor ce fac parte din cel pu\u021bin un drum optim de la \\(X\\) la \\(Y\\).</p> <p>Codul surs\u0103 se poate viziona mai jos.</p> <pre><code>#include &lt;fstream&gt;\n#include &lt;queue&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\nconstexpr int MAX_NODURI = 7500;\n\nvector&lt;vector&lt;int&gt;&gt; graf(MAX_NODURI + 1);\nvector&lt;int&gt; noduri_comune;\nvector&lt;int&gt; distanta_x, distanta_y, frecventa;\n\nvoid bfs(int nod_start, vector&lt;int&gt;&amp; distanta) {\n    queue&lt;int&gt; q;\n    q.push(nod_start);\n    distanta[nod_start] = 0;\n\n    while (!q.empty()) {\n        int nod = q.front();\n        q.pop();\n\n        for (auto vecin : graf[nod]) {\n            if (distanta[vecin] == -1) {\n                distanta[vecin] = distanta[nod] + 1;\n                q.push(vecin);\n            }\n        }\n    }\n}\n\nint main() {\n    distanta_x.reserve(MAX_NODURI + 1);\n    distanta_y.reserve(MAX_NODURI + 1);\n    frecventa.reserve(MAX_NODURI + 1);\n\n    ifstream fin(\"graf.in\");\n    ofstream fout(\"graf.out\");\n\n    int noduri, muchii, nod_x, nod_y;\n    fin &gt;&gt; noduri &gt;&gt; muchii &gt;&gt; nod_x &gt;&gt; nod_y;\n\n    while (muchii--) {\n        int a, b;\n        fin &gt;&gt; a &gt;&gt; b;\n        graf[a].push_back(b);\n        graf[b].push_back(a);\n    }\n\n    distanta_x.resize(noduri + 1, -1);\n    distanta_y.resize(noduri + 1, -1);\n\n    bfs(nod_x, distanta_x);\n    bfs(nod_y, distanta_y);\n\n    int distanta_totala = distanta_x[nod_y];\n\n    // Lungimea total\u0103 a drumului va fi egal\u0103 cu distanta_x[nod_y].\n    for (int nod = 1; nod &lt;= noduri; nod++) {\n        if (distanta_x[nod] == -1 || distanta_y[nod] == -1) {\n            continue;\n        }\n\n        if (distanta_x[nod] + distanta_y[nod] == distanta_totala) {\n            frecventa[distanta_x[nod]]++;\n        }\n    }\n\n    for (int nod = 1; nod &lt;= noduri; nod++) {\n        if (distanta_x[nod] == -1 || distanta_y[nod] == -1) {\n            continue;\n        }\n\n        if (distanta_x[nod] + distanta_y[nod] == distanta_totala\n            &amp;&amp; frecventa[distanta_x[nod]] == 1) {\n            noduri_comune.push_back(nod);\n        }\n    }\n\n    fout &lt;&lt; noduri_comune.size() &lt;&lt; '\\n';\n    for (const auto&amp; nod : noduri_comune) {\n        fout &lt;&lt; nod &lt;&lt; ' ';\n    }\n\n    return 0;\n}\n</code></pre>","tags":["grafuri","parcurgeri","DFS","BFS","drumuri"]},{"location":"usor/graphs/#detectarea-unui-ciclu-simplu-round-trip-cses","title":"Detectarea unui ciclu simplu - Round Trip CSES","text":"<p>\u00cen aceast\u0103 problem\u0103, trebuie s\u0103 g\u0103sim un ciclu simplu \u00eentr-un graf neorientat. Exist\u0103 foarte mul\u021bi algoritmi care rezolv\u0103 aceast\u0103 problem\u0103 corect, dar un algoritm care este foarte simplu \u0219i u\u0219or de \u00een\u021beles const\u0103 \u00een urm\u0103torii pa\u0219i:</p> <ul> <li>Pentru fiecare component\u0103 conex\u0103, vom rula un DFS din unul din noduri \u0219i vom   afla un arbore DFS (pentru fiecare nod din component\u0103, vom \u021bine \\(prv[i]\\) drept   nodul de unde am ajuns s\u0103 vizit\u0103m nodul \\(i\\), \u00eentr-un mod similar cu modul \u00een   care \u021binem p\u0103rin\u021bii unui nod \u00een arbore).</li> <li>Dac\u0103 la un pas d\u0103m de un nod care a fost deja vizitat \u0219i nu este p\u0103rintele   nodului curent, \u00eenseamn\u0103 c\u0103 avem un ciclu \u00eentre cele dou\u0103 noduri \u00een cauz\u0103.</li> <li>Pentru cele dou\u0103 noduri g\u0103site, vom folosi vectorul prv creat anterior pentru   a merge \u00eenapoi prin nodurile g\u0103site, iar acest drum va fi ciclul pe care \u00eel   vom ob\u021bine.</li> </ul> <p>Mai jos g\u0103si\u021bi implementarea C++ a solu\u021biei descrise mai sus.</p> <pre><code>#include &lt;iostream&gt;\n#include &lt;vector&gt;\n\nusing namespace std;\n\nvector&lt;vector&lt;int&gt;&gt; graf;\nvector&lt;int&gt; vizitat, parinte;\n\nint nod_inceput, nod_sfarsit;\n\nvoid dfs(int parinte_nod, int nod_curent) {\n    vizitat[nod_curent] = 1;\n    for (int vecin : graf[nod_curent]) {\n        if (vecin == parinte_nod) {\n            continue;\n        }\n        if (vizitat[vecin]) {\n            nod_inceput = nod_curent;\n            nod_sfarsit = vecin;\n        } else {\n            parinte[vecin] = nod_curent;\n            dfs(nod_curent, vecin);\n        }\n    }\n}\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(nullptr);\n\n    int noduri, muchii;\n    cin &gt;&gt; noduri &gt;&gt; muchii;\n\n    graf.resize(noduri + 1);\n    parinte.resize(noduri + 1);\n    vizitat.resize(noduri + 1);\n\n    for (int i = 1; i &lt;= muchii; i++) {\n        int a, b;\n        cin &gt;&gt; a &gt;&gt; b;\n        graf[a].push_back(b);\n        graf[b].push_back(a);\n    }\n\n    for (int nod = 1; nod &lt;= noduri; nod++) {\n        if (!vizitat[nod]) {\n            dfs(0, nod);\n        }\n    }\n\n    if (nod_inceput == 0) {\n        cout &lt;&lt; \"IMPOSSIBLE\";\n        return 0;\n    }\n\n    vector&lt;int&gt; ciclu;\n    ciclu.push_back(nod_inceput);\n\n    while (nod_sfarsit != nod_inceput) {\n        ciclu.push_back(nod_sfarsit);\n        nod_sfarsit = parinte[nod_sfarsit];\n    }\n\n    ciclu.push_back(nod_inceput);\n\n    cout &lt;&lt; ciclu.size() &lt;&lt; '\\n';\n\n    for (auto nod : ciclu) {\n        cout &lt;&lt; nod &lt;&lt; \" \";\n    }\n    return 0;\n}\n</code></pre>","tags":["grafuri","parcurgeri","DFS","BFS","drumuri"]},{"location":"usor/graphs/#probleme-suplimentare","title":"Probleme suplimentare","text":"<ul> <li>Kilonova unire</li> <li>GasesteCiclu pbinfo</li> <li>CSES Message Route</li> <li>CSES Building Teams</li> <li>CSES Round Trip</li> <li>USACO Bronze Milk Factory</li> <li>USACO Bronze The Great Revegetation</li> <li>USACO Silver Closing the Farm</li> <li>USACO Silver Moocast</li> <li>infoarena multiplu</li> <li>ONI 2004 base3</li> <li>Probleme cu grafuri de pe kilonova</li> <li>Probleme cu grafuri de pe codeforces, ordonate dup\u0103 dificultate</li> </ul>","tags":["grafuri","parcurgeri","DFS","BFS","drumuri"]},{"location":"usor/graphs/#lectura-suplimentara","title":"Lectur\u0103 suplimentar\u0103","text":"<ul> <li>Grafuri - no\u021biuni teoretice de baz\u0103</li> <li>Articol introductiv de pe USACO Guide</li> <li>Articol despre parcurgeri de pe USACO Guide</li> <li>Find a cycle in O(m) - cp-algorithms</li> </ul>","tags":["grafuri","parcurgeri","DFS","BFS","drumuri"]},{"location":"usor/greedy/","title":"Introducere \u00een Metoda Greedy","text":"<p>De multe ori atunci c\u00e2nd trebuie s\u0103 rezolv\u0103m probleme algoritmice (\u0219i nu numai), suntem nevoi\u021bi s\u0103 g\u00e2ndim lacom, aleg\u00e2nd cea mai bun\u0103 variant\u0103 la un moment dat. \u00cen algoritmic\u0103, aceast\u0103 abordare este numit\u0103 metoda Greedy \u0219i este una din cele mai importante metode pentru rezolvarea problemelor, fiind \u00eent\u00e2lnit\u0103 at\u00e2t \u00een probleme foarte simple, c\u00e2t \u0219i \u00een unele din cele mai complicate probleme posibile.</p> <p>Chiar dac\u0103 conform manualelor de informatic\u0103 din \u021bara noastr\u0103, metoda Greedy este ceva ce se pred\u0103 abia \u00een clasele mai mari de liceu (mai exact, \u00een clasa a XI-a), o s\u0103 vede\u021bi c\u0103 probleme de acest fel apar \u00eenc\u0103 de la \u00eenceputul studiului algoritmicii.</p> <p>Voi \u00eencepe cu un exemplu de o asemenea problem\u0103, pentru a v\u0103 familiariza cu stilul pe care \u00eel vor avea problemele de acest fel.</p> <p>Exemplu</p> <p>\u0218tefan merge la magazin \u0219i are un buget de \\(L\\) lei. La magazinul unde \u00ee\u0219i face cump\u0103r\u0103turile, se g\u0103sesc \\(n\\) produse alimentare, fiecare dintre ele av\u00e2nd un pre\u021b cunoscut. Deoarece este foarte generos, ast\u0103zi el vrea s\u0103 poat\u0103 oferi c\u00e2te un produs alimentar unui num\u0103r c\u00e2t mai mare de persoane \u00een limita bugetului s\u0103u ini\u021bial. Care este num\u0103rul maxim de produse pe care \u0218tefan \u00eel poate cump\u0103ra?</p> <p>Pentru a rezolva aceast\u0103 problem\u0103, vom vrea s\u0103 alegem cele mai ieftine produse (cele cu pre\u021bul cel mai mic), acest lucru se poate fie afl\u00e2nd la fiecare pas valoarea minim\u0103 din \u0219ir, scaz\u00e2nd-o din buget p\u00e2n\u0103 c\u00e2nd nu mai putem alege obiecte, fie ordon\u00e2nd obiectele cresc\u0103tor dup\u0103 pre\u021b, iar mai apoi sc\u0103z\u00e2nd produsele cu cel mai mic pre\u021b p\u00e2n\u0103 c\u00e2nd nu mai este posibil.</p> <p>O prim\u0103 concluzie pe care o putem trage este aceea c\u0103 \u00een cazul multor probleme ce folosesc aceast\u0103 metod\u0103, vom avea nevoie s\u0103 ordon\u0103m valorile dup\u0103 un anumit criteriu, iar la fiecare pas, vom alege optimul local (fie c\u0103 e vorba de maxim, minim sau alt criteriu pe care \u00eel decidem).</p> <p>\u00cen cele ce urmeaz\u0103, voi prezenta c\u00e2teva probleme mai simple \u0219i cunoscute pentru a prezenta diverse abord\u0103ri.</p>","tags":["sortare","greedy"]},{"location":"usor/greedy/#problema-prodmax1-de-pe-pbinfo","title":"Problema prodmax1 de pe pbinfo","text":"<p>Pentru a avea un produs c\u00e2t mai mare, este logic c\u0103 vrem s\u0103 avem valori c\u00e2t mai mari pe care s\u0103 le \u00eenmul\u021bim. Oare este totu\u0219i suficient s\u0103 ne uit\u0103m doar la cele mai mari dou\u0103 valori?</p> <p>Deoarece \u00eenmul\u021birea a dou\u0103 valori negative duce \u0219i ea la un produs pozitiv, nu este suficient, deci trebuie s\u0103 verific\u0103m \u0219i cele mai mici dou\u0103 valori pentru a acoperi toate cazurile ce pot ap\u0103rea. Mai jos pute\u021bi g\u0103si solu\u021bia problemei.</p> <pre><code>#include &lt;algorithm&gt;\n#include &lt;iostream&gt;\n#include &lt;vector&gt;\n\nusing namespace std;\n\nint main() {\n    int n;\n    cin &gt;&gt; n;\n\n    vector&lt;int&gt; numere(n + 1);\n    for (int i = 0; i &lt; n; i++) {\n        cin &gt;&gt; numere[i];\n    }\n\n    sort(numere.begin(), numere.end());\n\n    long long produs_maxim =\n        max(1LL * numere[n - 1] * numere[n - 2], 1LL * numere[0] * numere[1]);\n\n    cout &lt;&lt; produs_maxim &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["sortare","greedy"]},{"location":"usor/greedy/#problema-movie-festival-problema-spectacolelor-de-pe-cses","title":"Problema Movie Festival - Problema spectacolelor de pe cses","text":"<p>Pentru a afla num\u0103rul maxim de filme pe care le putem urm\u0103ri, trebuie s\u0103 ne g\u00e2ndim la o strategie prin care s\u0103 ordon\u0103m filmele dup\u0103 un anumit criteriu, iar mai apoi s\u0103 alegem filmele conform ordinii alese.</p> <p>Unele din strategiile care ar putea fi folosite pentru aceast\u0103 problem\u0103 sunt ordonarea filmelor dup\u0103 momentul de start, ordonarea dup\u0103 lungimea lor \u0219i ordonarea dup\u0103 momentul de final.</p> <p>Prima strategie este gre\u0219it\u0103 deoarece dac\u0103 avem un film foarte lung la \u00eenceput, ne-ar putea acoperi mai multe filme mai scurte care \u00eencep un pic mai t\u00e2rziu.</p> <p>Strategia de a sorta dup\u0103 lungimea filmelor va da r\u0103spunsuri gre\u0219ite c\u00e2nd avem filme scurte care acoper\u0103 dou\u0103 filme mai lungi care nu se intersecteaz\u0103.</p> <p>\u00cen schimb, ordonarea filmelor dup\u0103 timpul final al acestora este optim\u0103 deoarece vom avea mereu un num\u0103r maxim de oportunit\u0103\u021bi din care alegem.</p> <p>Observa\u021bie</p> <p>Pentru mai multe explica\u021bii \u0219i desene, pute\u021bi accesa articolul de pe usaco.guide care prezint\u0103 aceast\u0103 problem\u0103.</p> <p>Solu\u021bia va consta \u00een sortarea intervalelor dup\u0103 timpul final, iar la fiecare pas vom alege primul film care are un timp ini\u021bial mai mare dec\u00e2t timpul de final precedent.</p> <pre><code>#include &lt;algorithm&gt;\n#include &lt;iostream&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\nint main() {\n    int numar_evenimente;\n    cin &gt;&gt; numar_evenimente;\n\n    vector&lt;pair&lt;int, int&gt;&gt; evenimente(numar_evenimente);\n\n    for (auto&amp; eveniment : evenimente) {\n        cin &gt;&gt; eveniment.second &gt;&gt; eveniment.first;\n    }\n\n    sort(evenimente.begin(), evenimente.end());\n\n    int numar_maxim_evenimente = 0;\n    int timp_ultim_eveniment = 0;\n\n    for (const auto&amp; eveniment : evenimente) {\n        if (eveniment.second &gt;= timp_ultim_eveniment) {\n            ++numar_maxim_evenimente;\n            timp_ultim_eveniment = eveniment.first;\n        }\n    }\n\n    cout &lt;&lt; numar_maxim_evenimente &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["sortare","greedy"]},{"location":"usor/greedy/#problema-moscraciun2-de-pe-pbinfo","title":"Problema moscraciun2 de pe pbinfo","text":"<p>Pentru a rezolva aceast\u0103 problem\u0103, ne folosim de faptul c\u0103 costurile sunt mici, iar mai apoi parcurgem cadourile \u00een ordine cresc\u0103toare a costurilor, lu\u00e2nd cadourile cu costul cel mai mic, optimiz\u00e2nd la fiecare pas aceast\u0103 parte a r\u0103spunsului, fiind lacomi \u00een privin\u021ba alegerii cadourilor cu pre\u021bul cel mai mic.</p> <pre><code>#include &lt;iostream&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\nint main() {\n    int numar_copii, numar_magazine;\n    cin &gt;&gt; numar_copii &gt;&gt; numar_magazine;\n\n    vector&lt;int&gt; stoc_cadouri(101, 0);\n\n    for (int i = 1; i &lt;= numar_magazine; i++) {\n        int pret, cantitate;\n        cin &gt;&gt; pret &gt;&gt; cantitate;\n        stoc_cadouri[pret] += cantitate;\n    }\n\n    int cost_total = 0;\n    for (int pret = 0; pret &lt;= 100; pret++) {\n        int cadouri_cumparate = min(numar_copii, stoc_cadouri[pret]);\n\n        cost_total += cadouri_cumparate * pret;\n        numar_copii -= cadouri_cumparate;\n\n        if (numar_copii == 0) {\n            cout &lt;&lt; cost_total &lt;&lt; '\\n';\n            return 0;\n        }\n    }\n\n    cout &lt;&lt; \"imposibil\" &lt;&lt; '\\n';\n\n    return 0;\n}\n</code></pre>","tags":["sortare","greedy"]},{"location":"usor/greedy/#concluzii-preliminare","title":"Concluzii preliminare","text":"<p>\u00cen articolul pe care tocmai l-a\u021bi citit, am prezentat c\u00e2teva dintre cele mai cunoscute probleme \u0219i strategii ce folosesc metoda Greedy. Plec\u00e2nd de la aceste exemple care sunt mai simple, am explicat diverse strategii pentru a aborda problemele care folosesc aceast\u0103 metod\u0103.</p> <p>\u00cen articolele viitoare, vom explica principii mai avansate, precum Exchange Argument, Simulated Annealing, precum \u0219i diverse tehnici folosite \u00een algoritmii euristici \u0219i randomiza\u021bi ce folosesc strategii Greedy.</p>","tags":["sortare","greedy"]},{"location":"usor/greedy/#probleme-suplimentare","title":"Probleme suplimentare","text":"<ul> <li>USACO Bronze Watching Mooloo</li> <li>USACO Bronze Cow Tipping</li> <li>pbinfo kmax</li> <li>pbinfo eureni</li> <li>Probleme cu greedy de pe pbinfo</li> <li>USACO Bronze Out of Place</li> <li>Leetcode Minimum Cost to Move Chips to The Same Position</li> <li>OJI 2012 Arme</li> <li>OJI 2024 Santinele</li> <li>ONI 2024 Soldati</li> <li>CSES Tasks and Deadlines</li> <li>USACO Gold High Card Low Card</li> <li>RoAlgo Contest #10 Paranteze</li> <li>USACO Silver Berry Picking</li> <li>Codeforces Ciel and Duel</li> <li>Probleme cu greedy pe Kilonova</li> <li>Probleme cu greedy pe Infoarena</li> </ul>","tags":["sortare","greedy"]},{"location":"usor/greedy/#lectura-suplimentara","title":"Lectur\u0103 suplimentar\u0103","text":"<ul> <li>Metoda greedy - pbinfo</li> <li>Greedy Algorithms - Wikipedia</li> <li>Metoda Greedy si problema fractionara a rucsacului</li> <li>Introduction to Greedy Algorithms - USACO Guide</li> <li>Greedy Algorithms with Sorting - USACO Guide</li> </ul>","tags":["sortare","greedy"]},{"location":"usor/how-to-start/","title":"De unde \u00eencepi?","text":"","tags":["meta","roadmap","sfaturi","olimpiada","bacalaureat","interviuri"]},{"location":"usor/how-to-start/#introducere","title":"Introducere","text":"<p>Fie c\u0103 vrei s\u0103 \u00eenve\u021bi pentru a fi mai bun la clas\u0103, pentru a ob\u021bine un job mai bun sau pentru a ajunge olimpic, toat\u0103 lumea pleac\u0103 de undeva \u0219i p\u00e2n\u0103 \u0219i cei mai buni programatori au plecat de la zero.</p> <p>\u00cen acest articol, vom prezenta c\u00e2teva lucruri pe care s\u0103 le faci la \u00eenceput pentru a putea avea o funda\u021bie c\u00e2t mai solid\u0103 \u0219i pentru a putea pleca \u00eentr-o direc\u021bie bun\u0103 spre a putea ajunge s\u0103 \u00eenve\u021bi c\u00e2t mai mul\u021bi algoritmi \u0219i a putea fi tot mai bun la rezolvarea problemelor de informatic\u0103 \u0219i nu numai.</p>","tags":["meta","roadmap","sfaturi","olimpiada","bacalaureat","interviuri"]},{"location":"usor/how-to-start/#fundamente","title":"Fundamente","text":"<p>\u00cen primul r\u00e2nd, pentru a putea fi un bun programator, trebuie s\u0103 ai cuno\u0219tin\u021be decente de matematic\u0103. Nu trebuie s\u0103 fii olimpic sau s\u0103 ai alte cuno\u0219tin\u021be avansate, dar un nivel decent este important. Mai formal, drept un minim, trebuie s\u0103 fii familiarizat cu no\u021biunile de matematic\u0103 din clasele primare \u0219i ideal, \u0219i cele din clasele V-VIII (dac\u0103 e\u0219ti \u00een gimnaziu \u0219i cite\u0219ti asta, trebuie s\u0103 fii la zi cu materia de la clas\u0103, iar pe parcurs, pe m\u0103sur\u0103 ce ve\u021bi \u00eenv\u0103\u021ba mai multe, vei putea fi \u00eenaintea materiei).</p> <p>De asemenea, trebuie s\u0103 ai cuno\u0219tin\u021be de baz\u0103 despre un limbaj de programare. \u00cen conformitate cu materia predat\u0103 \u00een \u0219colile din Rom\u00e2nia, aceast\u0103 arhiv\u0103 este centrat\u0103 pe limbajul C++, deci \u00een\u021belegerea de baz\u0103 a acestui limbaj va fi esen\u021bial\u0103.</p>","tags":["meta","roadmap","sfaturi","olimpiada","bacalaureat","interviuri"]},{"location":"usor/how-to-start/#notiuni-cu-care-sa-incepi","title":"No\u021biuni cu care s\u0103 \u00eencepi","text":"<p>Pentru a \u00eencepe studiul algoritmicii, recomand\u0103m \u00eenv\u0103\u021barea bazelor limbajului. Dintre cele mai importante no\u021biuni ini\u021biale, vom aminti urm\u0103toarele capitole, precum \u0219i unde le g\u0103si\u021bi la noi \u00een arhiv\u0103. Pentru fiecare sec\u021biune, recomand\u0103m \u00een mod strict citirea no\u021biunilor \u00een ordinea dat\u0103 aici.</p> <p>Observa\u021bie</p> <p>Pentru cei familiariza\u021bi cu programa pentru olimpiad\u0103, aceast\u0103 list\u0103 este foarte similar\u0103 cu programa clasei a cincea de la olimpiad\u0103. Chiar dac\u0103 multe alte roadmap-uri online sugereaz\u0103 prioritizarea structurilor de date mai avansate, tehnicile de rezolvare a problemelor sunt mult mai importante pentru \u00eenceput.</p>","tags":["meta","roadmap","sfaturi","olimpiada","bacalaureat","interviuri"]},{"location":"usor/how-to-start/#elemente-de-limbaj","title":"Elemente de limbaj","text":"<ul> <li>Instalarea primului editor/IDE C++</li> <li>Primul program \u00een C++</li> <li>Variabile \u0219i tipuri de date simple</li> <li>Operatori \u0219i expresii. Cuno\u0219tin\u021be matematice de   baz\u0103</li> <li>Citirea \u0219i afi\u0219area datelor</li> <li>Structura alternativ\u0103</li> <li>Structura repetitiv\u0103</li> <li>Coding Style</li> <li>Vectori (tablouri unidimensionale)</li> </ul>","tags":["meta","roadmap","sfaturi","olimpiada","bacalaureat","interviuri"]},{"location":"usor/how-to-start/#algoritmi-si-tehnici-introductive","title":"Algoritmi \u0219i tehnici introductive","text":"<ul> <li>Prelucrarea cifrelor unui   num\u0103r</li> <li>Maxime \u0219i minime</li> <li>Generarea \u0219irurilor de   numere</li> <li>Divizibilitatea</li> <li>Abordarea problemelor cu secven\u021be</li> <li>Principiul lui Dirichlet (principiul   cutiei)</li> <li>Algoritmi de sortare - Doar algoritmii   \u00een \\(\\mathcal{O}(n^2)\\) \u0219i func\u021bia <code>std::sort</code></li> </ul>","tags":["meta","roadmap","sfaturi","olimpiada","bacalaureat","interviuri"]},{"location":"usor/how-to-start/#sfaturi-practice","title":"Sfaturi practice","text":"<p>Pentru a putea st\u0103p\u00e2ni c\u00e2t mai bine tehnicile prezentate \u00een articolele recomandate, va trebui s\u0103 lucra\u021bi probleme c\u00e2t mai variate \u0219i dac\u0103 ave\u021bi nel\u0103muriri, recomand\u0103m s\u0103 ne \u00eentreba\u021bi pe serverul nostru.</p> <p>De asemenea, dup\u0103 ce sunte\u021bi siguri pe voi, pute\u021bi participa la competi\u021bii online, cele mai potrivite concursuri fiind fie competi\u021biile rom\u00e2ne\u0219ti, fie rundele Div. 4 \u0219i Div. 3 de pe Codeforces. Evident, dac\u0103 sunte\u021bi mai buni \u0219i vre\u021bi o provocare \u00een plus, pute\u021bi participa oric\u00e2nd la olimpiad\u0103, dar cerin\u021bele sunt mai mari acolo.</p>","tags":["meta","roadmap","sfaturi","olimpiada","bacalaureat","interviuri"]},{"location":"usor/how-to-start/#concluzii","title":"Concluzii","text":"<p>Pentru a deveni bun la algoritmic\u0103, trebuie s\u0103 \u00eencepem cu no\u021biunile de baz\u0103, care dac\u0103 sunt \u00een\u021belese cum trebuie, v\u0103 vor ajuta s\u0103 deveni\u021bi tot mai buni. Chiar dac\u0103 sunt multe alte capitole care trebuie \u00eenv\u0103\u021bate, ne-am concentrat doar pe esen\u021bial pentru a face procesul de \u00eenv\u0103\u021bare c\u00e2t mai u\u0219or. Fiecare dintre articolele recomandate are o serie de resurse suplimentare pe care le recomand\u0103m, pe l\u00e2ng\u0103 cele prezentate \u00een articole.</p>","tags":["meta","roadmap","sfaturi","olimpiada","bacalaureat","interviuri"]},{"location":"usor/intro-dp/","title":"Introducere \u00een programarea dinamic\u0103","text":"","tags":["programare dinamica","DP"]},{"location":"usor/intro-dp/#introducere","title":"Introducere","text":"<p>Programarea dinamic\u0103 (abrev. DP) este un mod de g\u00e2ndire care poate fi folosit pentru rezolvarea problemelor la care trebuie s\u0103 afl\u0103m fie num\u0103rul de solu\u021bii corecte pentru un anumit set de date, fie solu\u021bia optim\u0103 (minim, maxim, etc.).</p> <p>Pentru a realiza acest lucru, vom descompune problema \u00een mai multe subprobleme, care, luate \u00eempreun\u0103, s\u0103 ne ob\u021bin\u0103 r\u0103spunsul dorit.</p>","tags":["programare dinamica","DP"]},{"location":"usor/intro-dp/#de-ce-trebuie-sa-stim-programare-dinamica","title":"De ce trebuie s\u0103 \u0219tim programare dinamic\u0103?","text":"<p>De\u0219i tipurile de probleme men\u021bionate anterior se pot rezolva \u0219i cu alte tehnici, cum ar fi backtracking, greedy, formul\u0103 matematic\u0103 etc., programarea dinamic\u0103 vine drept o nou\u0103 perspectiv\u0103 asupra problemelor care ne permite s\u0103 g\u0103sim solu\u021bii pentru o mul\u021bime de probleme, p\u0103str\u00e2nd avantajele care ne sunt oferite at\u00e2t de greedy c\u00e2t \u0219i de backtracking, iar \u00een multe cazuri, devenind abordarea cea mai potrivit\u0103, ceea ce face programarea dinamic\u0103 s\u0103 devin\u0103 una dintre cele mai populare tehnici date la concursurile de algoritmic\u0103.</p> <p>Observa\u021bie</p> <p>Aproape \u00een fiecare an la OJI \u0219i ONI clasele XI-XII se d\u0103 o problem\u0103 care necesit\u0103 o solu\u021bie bazat\u0103 pe metoda program\u0103rii dinamice, problemele de acest tip reg\u0103sindu-se \u0219i \u00een foarte multe concursuri mai dificile.</p>","tags":["programare dinamica","DP"]},{"location":"usor/intro-dp/#termenii-specifici-ai-programarii-dinamice","title":"Termenii specifici ai program\u0103rii dinamice","text":"<p>Pentru a explica p\u0103r\u021bile componente ale oric\u0103rei solu\u021bii care se bazeaz\u0103 pe metoda program\u0103rii dinamice, vom explica un exemplu foarte simplu, folosindu-ne de \u0219irul lui Fibonacci.</p> <p>Vom defini \u0219irul lui Fibonacci ca fiind \\(F_0 = 1\\), \\(F_1 = 1\\) \u0219i \\(F_i = F_{i-1} + F_{i-2}\\).</p> <p>Dup\u0103 cum se poate observa, avem \\(F_i\\) care reprezint\u0103 cel de-al \\(i\\)-lea num\u0103r Fibonacci, acesta fiind starea pe care o vom calcula, st\u0103ri pe care le vom g\u0103si \u00een toate problemele ce necesit\u0103 programare dinamic\u0103. St\u0103rile vor avea una sau mai multe dimensiuni.</p> <p>\\(F_i = F_{i-1} + F_{i-2}\\) reprezint\u0103 rela\u021bia de recuren\u021b\u0103 dintre \\(F_i\\) \u0219i valorile precedente. Pasul de la \\(F_{i-1}\\) sau \\(F_{i-2}\\) la \\(F_{i}\\) reprezint\u0103 tranzi\u021biile de la o stare la alta.</p> <p>\u00cen cele din urm\u0103, \\(F_0 = 1\\), \\(F_1 = 1\\) reprezint\u0103 cazurile de baz\u0103, cazuri care nu pot fi definite folosind rela\u021bia de recuren\u021b\u0103 men\u021bionat\u0103 mai sus.</p> <p>\u00cen concluzie, pentru a putea avea o solu\u021bie care folose\u0219te programarea dinamic\u0103, trebuie s\u0103 ne asigur\u0103m c\u0103 avem urm\u0103toarele p\u0103r\u021bi:</p> <ul> <li>Cazuri de baz\u0103</li> <li>Stare pe care o calcul\u0103m</li> <li>Rela\u021bie de recuren\u021b\u0103</li> <li>Tranzitii</li> </ul> <p>Aceste aspecte pot fi \u0219i optimizate \u00een func\u021bie de problem\u0103, aceste optimiz\u0103ri fiind realizabile fie calcul\u00e2nd tranzi\u021biile mai rapid, fie reduc\u00e2nd num\u0103rul de st\u0103ri, a\u0219a cum se va vedea de-a lungul capitolelor ulterioare care abordeaz\u0103 tehnica program\u0103rii dinamice.</p>","tags":["programare dinamica","DP"]},{"location":"usor/intro-dp/#clasificare","title":"Clasificare","text":"<p>\u00cen elaborarea unui algoritm care folose\u0219te metoda program\u0103rii dinamice, putem utiliza mai multe abord\u0103ri.</p>","tags":["programare dinamica","DP"]},{"location":"usor/intro-dp/#tipuri-de-scriere","title":"Tipuri de scriere","text":"<ul> <li> <p>Recursiv</p> </li> <li> <p>Iterativ</p> </li> </ul> Recursiv Iterativ Mai lent Mai rapid Mai u\u0219or de elaborat Mai dificil de elaborat Memoizare Tabulare Top-Down DP Bottom-Up DP","tags":["programare dinamica","DP"]},{"location":"usor/intro-dp/#modalitati-de-abordare","title":"Modalit\u0103\u021bi de abordare","text":"<ol> <li> <p>Top-Down DP:</p> <ul> <li>Aceast\u0103 form\u0103 de DP pleac\u0103 de la starea final\u0103 a problemei, ea utiliz\u00e2nd   st\u0103rile anterioare, p\u00e2n\u0103 la starea ini\u021bial\u0103 pe care o cunoa\u0219tem, pentru   a-\u0219i construi parametrii ei.</li> <li>De obicei aceast\u0103 form\u0103 de DP este scris\u0103 utiliz\u00e2nd recursivitatea</li> </ul> </li> <li> <p>Bottom-Up DP:</p> <ul> <li>Aceast\u0103 form\u0103 de DP pleac\u0103 de la starea ini\u021bial\u0103 a problemei, ea   construind parametrii st\u0103rilor urm\u0103toare care la r\u00e2ndul lor vor face asta   p\u00e2n\u0103 ce ajungem la construirea parametrilor st\u0103rii finale.</li> <li>De obicei aceast\u0103 form\u0103 de DP este scris\u0103 utiliz\u00e2nd Complete Search-ul</li> </ul> </li> </ol>","tags":["programare dinamica","DP"]},{"location":"usor/intro-dp/#modalitati-de-tranzitie","title":"Modalit\u0103\u021bi de tranzi\u021bie","text":"<ul> <li>Pull-DP: Informa\u021bia din starea curent\u0103 se formeaz\u0103 baz\u00e2ndu-se pe una sau mai   multe st\u0103ri anterioare.</li> <li>Push-DP: Informa\u021bia din starea curent\u0103 se utilizeaz\u0103 pentru calcularea unei   st\u0103rii viitoare.</li> </ul>","tags":["programare dinamica","DP"]},{"location":"usor/intro-dp/#probleme-clasice","title":"Probleme clasice","text":"<p>Pentru a ne dezvolta intui\u021bia \u00een ceea ce prive\u0219te aceast\u0103 tehnic\u0103, este necesar s\u0103 \u00een\u021belegem mecanismul pe care se bazeaz\u0103 problemele clasice.</p> <p>Este esen\u021bial s\u0103 rezolv\u0103m c\u00e2t mai multe probleme de DP pentru a deveni fluen\u021bi \u00een elaborarea solu\u021biilor.</p>","tags":["programare dinamica","DP"]},{"location":"usor/intro-dp/#problema-frog-1","title":"Problema Frog 1","text":"<p>Aceast\u0103 problem\u0103 ne cere s\u0103 afl\u0103m costul minim de care are nevoie o broasc\u0103 pentru a ajunge de pe prima piatr\u0103 pe ultima, dac\u0103 se poate deplasa doar pe piatra din fa\u021b\u0103 sau pe piatra cu dou\u0103 pozi\u021bii mai \u00een fa\u021b\u0103.</p> <p>Deoarece restric\u021biile sunt foarte mari, aplicarea unei solu\u021bii care verific\u0103 toate variantele posibile folosind Backtracking este imposibil\u0103, iar diverse abord\u0103ri de tip Greedy, precum saltul spre cea mai apropiat\u0103 piatr\u0103 sau spre piatra cu o diferen\u021b\u0103 de \u00een\u0103l\u021bime minim\u0103 sunt gre\u0219ite.</p> <p>Astfel, se impune folosirea unei solu\u021bii care folose\u0219te metoda program\u0103rii dinamice, unde putem stoca \\(dp[i]\\) care va reprezenta suma minim\u0103 a diferen\u021belor salturilor necesare pentru a ajunge la pozi\u021bia \\(i\\), motivul pentru care vrem s\u0103 facem asta este acela c\u0103 este important s\u0103 avem un r\u0103spuns optim stocat pentru fiecare pozi\u021bie \u00een parte.</p> <p>Pentru a calcula \\(dp[i]\\), ne vom folosi de informa\u021biile din enun\u021b, \u0219i anume faptul c\u0103 avem voie s\u0103 s\u0103rim pe o pozi\u021bie aflat\u0103 la cel mult dou\u0103 unit\u0103\u021bi de pozi\u021bia curent\u0103, astfel \\(dp[i]\\) va fi egal cu urm\u0103toarea formul\u0103:</p> \\[     {dp}_{i} = \\min(dp_{i-1} + |v_i - v_{i-1}|, dp_{i-2} + |v_i - v_{i-2}|) \\] <p>unde \\(|x| = \\operatorname{abs}(x)\\) este valoarea absolut\u0103. Cazul de baz\u0103 const\u0103 \u00een faptul c\u0103 \\(dp_1 = 0\\) \u0219i \\(dp_2 = |v_1 - v_2|\\), iar complexitatea acestei solu\u021bii este \\(\\mathcal{O}(n)\\).</p> <p>Mai jos pute\u021bi g\u0103si abordarea recursiv\u0103 \u0219i cea iterativ\u0103 a problemei.</p> RecursivIterativ <pre><code>#include &lt;iostream&gt;\n#include &lt;vector&gt;\n\nusing namespace std;\n\nint solve(int poz, const vector&lt;int&gt; &amp;v, vector&lt;int&gt; &amp;dp) {\n    // Cazuri de baza\n    if (poz == 1) {\n        return 0;\n    }\n\n    if (poz == 2) {\n        return abs(v[2] - v[1]);\n    }\n\n    // Evitarea calculelor redundante\n    if (dp[poz] != -1) {\n        return dp[poz];\n    }\n\n    dp[poz] = min(solve(poz - 1, v, dp) + abs(v[poz - 1] - v[poz]),\n                  solve(poz - 2, v, dp) + abs(v[poz - 2] - v[poz]));\n    return dp[poz];\n}\n\nint main() {\n    int n;\n    cin &gt;&gt; n;\n\n    vector&lt;int&gt; v(n + 1);\n    vector&lt;int&gt; dp(n + 1, -1);\n\n    for (int i = 1; i &lt;= n; i++) {\n        cin &gt;&gt; v[i];\n    }\n\n    cout &lt;&lt; solve(n, v, dp) &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre> <pre><code>#include &lt;iostream&gt;\n#include &lt;vector&gt;\n\nusing namespace std;\n\nint main() {\n    int n;\n    cin &gt;&gt; n;\n\n    vector&lt;int&gt; v(n + 1);\n    vector&lt;int&gt; dp(n + 1);\n\n    for (int i = 1; i &lt;= n; i++) {\n        cin &gt;&gt; v[i];\n    }\n\n    for (int i = 2; i &lt;= n; i++) {\n        if (i == 2) {\n            dp[i] = abs(v[i] - v[i - 1]);\n        } else {\n            dp[i] = min(dp[i - 1] + abs(v[i] - v[i - 1]),\n                        dp[i - 2] + abs(v[i] - v[i - 2]));\n        }\n    }\n\n    cout &lt;&lt; dp[n] &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["programare dinamica","DP"]},{"location":"usor/intro-dp/#problema-frog-2","title":"Problema Frog 2","text":"<p>La fel ca la problema precedent\u0103, trebuie s\u0103 afl\u0103m costul minim de care are nevoie o broasc\u0103 pentru a ajunge de pe prima piatr\u0103 pe ultima, dac\u0103 se poate deplasa cu cel mult \\(k\\) pa\u0219i la un moment dat.</p> <p>Spre deosebire de problema precedent\u0103, pentru a calcula \\(dp[i]\\), ne vom folosi de informa\u021biile din enun\u021b, recuren\u021ba de la Frog 1 va fi extins\u0103 pentru a acoperi \\(k\\) pozi\u021bii.</p> \\[ dp_i = \\min (dp_{i-x} + |v_i - v_{i-x}|),\\,\\forall x \\leq k \\] <p>Cazul de baz\u0103 const\u0103 \u00een faptul c\u0103 \\(dp_1 = 0\\) \u0219i \\(dp_2 = |v_1 - v_2|\\), iar complexitatea acestei solu\u021bii este \\(\\mathcal{O}(n \\cdot k)\\).</p> RecursivIterativ <pre><code>#include &lt;iostream&gt;\n#include &lt;vector&gt;\n\nusing namespace std;\n\nint solve(int poz, int diff, const vector&lt;int&gt; &amp;v, vector&lt;int&gt; &amp;dp) {\n    if (poz == 1) {\n        return 0;\n    }\n\n    if (dp[poz] != -1) {\n        return dp[poz];\n    }\n\n    dp[poz] = (1 &lt;&lt; 30);  // 2^30\n    for (int i = 1; i &lt;= diff; i++) {\n        if (poz - i &gt;= 1) {\n            dp[poz] = min(dp[poz], solve(poz - i, diff, v, dp)\n                                       + abs(v[poz] - v[poz - i]));\n        }\n    }\n    return dp[poz];\n}\n\nint main() {\n    int n, k;\n    cin &gt;&gt; n &gt;&gt; k;\n\n    vector&lt;int&gt; v(n + 1);\n    vector&lt;int&gt; dp(n + 1, -1);\n\n    for (int i = 1; i &lt;= n; i++) {\n        cin &gt;&gt; v[i];\n    }\n\n    cout &lt;&lt; solve(n, k, v, dp) &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre> <pre><code>#include &lt;iostream&gt;\n#include &lt;vector&gt;\n\nusing namespace std;\n\nint main() {\n    int n, k;\n    cin &gt;&gt; n &gt;&gt; k;\n\n    vector&lt;int&gt; v(n + 1);\n    vector&lt;int&gt; dp(n + 1, 1 &lt;&lt; 30);  // 2 ^ 30\n\n    for (int i = 1; i &lt;= n; i++) {\n        cin &gt;&gt; v[i];\n    }\n\n    for (int i = 2; i &lt;= n; i++) {\n        for (int j = 1; j &lt;= k; j++) {\n            if (i - j &gt;= 1) {\n                dp[i] = min(dp[i], dp[i - j] + abs(v[i] - v[i - j]));\n            }\n        }\n    }\n\n    cout &lt;&lt; dp[n] &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["programare dinamica","DP"]},{"location":"usor/intro-dp/#problema-moneda","title":"Problema Moneda","text":"<p>Cerin\u021b\u0103</p> <p>Ast\u0103zi, la ora domnului profesor Tetris, \u021bi s-a pus urm\u0103toarea \u00eentrebare: \u201eDac\u0103 eu \u00ee\u021bi dau \\(N\\) tipuri de monede, av\u00e2nd acces la o infinitate de monede \\(C\\) de acele tipuri, afl\u0103 modalitatea optim\u0103 de a ob\u021bine suma \\(S\\)\u201d. Pe momentul orei tu nu ai \u0219tiut cum s\u0103 r\u0103spunzi, \u00cens\u0103 acum, mai determinat ca niciodat\u0103, vrei s\u0103 rezolvi aceast\u0103 problem, av\u00e2nd \u00een fa\u021b\u0103 un document educational de 5 stele Micheline. Rezolv\u0103 problema!</p> <p>Vom defini modalitatea optim\u0103 de a ob\u021bine suma \\(S\\) ca fiind modalitatea prin care utilizezi c\u00e2t mai pu\u021bine monede per total!</p> <p>Restric\u021bii:</p> <ul> <li>$ 1 \\leq N \\leq 500 $</li> <li>$ 1 \\leq S \\leq 100000 $</li> <li>$ 1 \\leq C_i \\leq 2500 $</li> </ul> <p>La \u00eenceput, c\u00e2nd a\u021bi citit aceast\u0103 problem\u0103, probabil v-a\u021bi g\u00e2ndit la o rezolvare Greedy (care mai \u00eencolo o s\u0103 vede\u021bi c\u0103 este Greedy Euristic), prin care a\u021bi fi sortat descresc\u0103tor \u0219irul de monede \u0219i a\u021bi fi \u00eencercat s\u0103 utiliza\u021bi denomina\u021bia cea mai mare, care este mai mic\u0103 ca S, c\u00e2t timp putea\u021bi. Dup\u0103 a\u021bi fi continuat cu urm\u0103toarea denomina\u021bie cea mai mare care respect\u0103 condi\u021bia aceasta pentru suma r\u0103mas\u0103 \u0219.a.m.d. Ca s\u0103 v\u0103 dovedesc c\u0103 nu func\u021bioneaz\u0103 aceast\u0103 modalitate, \u00eencerca\u021bi s\u0103 rezolva\u021bi aceast\u0103 problem\u0103, utiliz\u00e2nd modalitatea anterior prezentat\u0103, av\u00e2nd aceste date de intrare (\\(N\\) num\u0103rul de monede, apoi \\(S\\) suma \u0219i apoi cele \\(N\\) monede):</p> <pre><code>3\n31\n7 2 15\n</code></pre> <p>Acum c\u0103 a\u021bi \u00eencercat s\u0103 rezolva\u021bi problema \u00eentr-un mod cunoscut vou\u0103, \u0219i a\u021bi v\u0103zut c\u0103 nu \u00ee\u021bi garanteaz\u0103 un r\u0103spuns, haide\u021bi s\u0103 v\u0103 prezint o solu\u021bie corect\u0103!</p> <p>Pentru aceast\u0103 problem, o s\u0103 v\u0103 prezint solu\u021biile utiliz\u00e2nd ambele modalit\u0103\u021bi de abordare \u0219i scriere a sursei \u0219i modalit\u0103\u021bi de tranzi\u021bie.</p> RecursivIterativ <p>Explica\u021bie</p> <p>Pentru a g\u0103si solu\u021bia optim\u0103, noi vom avea vectorul dp care se utilizeaz\u0103 pentru memoizare, el av\u00e2nd forma urm\u0103toare: dp[suma de bani r\u0103mas\u0103 de acoperit] = num\u0103rul de bacnote necesare pentru a ajunge la suma de bani r\u0103mas\u0103 de acoperit curent\u0103.</p> <p>Pentru asta ne vom utiliza de o recursie care are ca parametri de stare suma de bani care a r\u0103mas de pl\u0103tit, num\u0103rul de monede pe care l-am utilizat p\u00e2n\u0103 acum \u0219i vectorul de denomina\u021bii accesibile.</p> <pre><code>#include &lt;iostream&gt;\n#include &lt;vector&gt;\n\nusing namespace std;\n\nconst int MAXIM_SUMA_MONEDE = 100000;\n\nint N, S;\nvector&lt;int&gt; dp(MAXIM_SUMA_MONEDE + 1);\n\nvoid solve(const int suma, const int nr_monede, const vector&lt;int&gt;&amp; monede) {\n    if (suma == 0) {\n        return;\n    }\n\n    for (const auto moneda : monede) {\n        if (suma &gt;= moneda) {\n            if (dp[suma - moneda] &gt; nr_monede + 1) {\n                dp[suma - moneda] = nr_monede + 1;\n                solve(suma - moneda, nr_monede + 1, monede);\n            }\n        }\n    }\n}\n\nint main() {\n    cin &gt;&gt; N &gt;&gt; S;\n\n    vector&lt;int&gt; monede(N, 0);\n\n    for (auto&amp; moneda : monede) {\n        cin &gt;&gt; moneda;\n    }\n\n    solve(S, 0, monede);\n\n    cout &lt;&lt; dp[0];\n    return 0;\n}\n</code></pre> <p>Explica\u021bie</p> <p>Pentru a g\u0103si solu\u021bia optim\u0103, noi vom trece prin fiecare sum\u0103 de bani care este mai mic\u0103 dec\u00e2t \\(S\\), \u00eencerc\u00e2nd, dac\u0103 putem, s\u0103 continu\u0103m s\u0103 ad\u0103ug\u0103m bacnote astfel \u00eenc\u00e2t s\u0103 ajungem la suma de bani dorit\u0103. Pentru acest lucru vom \u021bine un vector dp de forma urm\u0103toare: dp[sum\u0103 de bani total\u0103] = num\u0103rul de bacnote necesare pentru a ajunge la aceast\u0103 sum\u0103 de bani.</p> <pre><code>#include &lt;algorithm&gt;\n#include &lt;iostream&gt;\n#include &lt;vector&gt;\n\nusing namespace std;\n\nconst int MAXIM_SUMA_MONEDE = 100000;\n\nint N, S;\nvector&lt;int&gt; dp(MAXIM_SUMA_MONEDE + 1);\n\nint main() {\n    cin &gt;&gt; N &gt;&gt; S;\n    vector&lt;int&gt; coins(N);\n    for (int i = 0; i &lt; N; i++) {\n        cin &gt;&gt; coins[i];\n    }\n    for (int i : coins) {\n        dp[i] = 1;\n    }\n\n    for (int i = 1; i &lt; S; i++) {\n        if (dp[i] != 0) {\n            for (int coin : coins) {\n                if (i + coin &lt;= S) {\n                    if (dp[i + coin] == 0) {\n                        dp[i + coin] = dp[i] + 1;\n                    } else {\n                        dp[i + coin] = min(dp[i + coin], dp[i] + 1);\n                    }\n                }\n            }\n        }\n    }\n\n    cout &lt;&lt; dp[S];\n    return 0;\n}\n</code></pre>","tags":["programare dinamica","DP"]},{"location":"usor/intro-dp/#problema-vacation","title":"Problema Vacation","text":"<p>Pentru aceast\u0103 problem\u0103, trebuie s\u0103 afl\u0103m satisfac\u021bia maxim\u0103 pe care o poate ob\u021bine Taro \u00een \\(n\\) zile, dac\u0103 nu are voie s\u0103 repete o activitate de dou\u0103 ori la r\u00e2nd.</p> <p>Din nou, se poate demonstra cu u\u0219urin\u021b\u0103 c\u0103 o solu\u021bie de tip Greedy nu va merge, deoarece ne putem bloca alegeri mai bune ulterior cu alegerile curente.</p> <p>Totodat\u0103, mai apare un element nou \u00een rezolvarea acestor probleme, \u0219i anume faptul c\u0103 vom avea nevoie de o nou\u0103 dimensiune pentru a p\u0103stra informa\u021bii cu privire la ultima activitate efectuat\u0103 de el, pentru a evita o situa\u021bie \u00een care alegem de dou\u0103 ori aceea\u0219i activitate.</p> <p>Astfel, vom defini \\(dp_{i,j}\\) ca fiind suma maxim\u0103 a satisfac\u021biei dac\u0103 am parcurs primele \\(i\\) zile, iar ultima activitate a fost de tipul \\(j\\), \\(j\\) fiind 0, 1 sau 2, \u00een func\u021bie de activitatea aleas\u0103.</p> <p>Pentru a calcula \\(dp_{i,j}\\), va trebui s\u0103 ne raport\u0103m la sumele din ziua precedent\u0103, corespunz\u0103toare celorlalte dou\u0103 activit\u0103\u021bi deoarece nu avem voie s\u0103 alegem aceea\u0219i activitate iar.</p> \\[ dp_{i,j} = \\max(dp_{i-1,x} + v_j),\\,\\forall x \\neq j \\] <p>Din nou ca la celelalte probleme, pute\u021bi g\u0103si mai jos abordarea recursiv\u0103 \u0219i cea iterativ\u0103 a problemei.</p> <p>Observa\u021bie</p> <p>Deoarece avem nevoie doar de valorile din ziua precedent\u0103, nu este necesar s\u0103 p\u0103str\u0103m \u00een memorie toat\u0103 matricea, ci doar ultimele dou\u0103 linii, optimizare pe care o vom prezenta \u00een detaliu mai jos.</p> RecursivIterativIterativ optimizat <pre><code>#include &lt;algorithm&gt;\n#include &lt;iostream&gt;\n#include &lt;vector&gt;\n\nusing namespace std;\n\nint solve(const int poz, const vector&lt;vector&lt;int&gt;&gt; &amp;v, vector&lt;vector&lt;int&gt;&gt; &amp;dp,\n          const int activ) {\n    if (poz == 1) {\n        return v[poz][activ];\n    }\n    if (dp[poz][activ] != -1) {\n        return dp[poz][activ];\n    }\n\n    dp[poz][activ] = 0;\n    for (int i = 0; i &lt; 3; i++) {\n        if (i != activ) {\n            dp[poz][activ] = max(dp[poz][activ], solve(poz - 1, v, dp, i));\n        }\n    }\n\n    dp[poz][activ] += v[poz][activ];\n    return dp[poz][activ];\n}\n\nint main() {\n    int n;\n    cin &gt;&gt; n;\n\n    vector&lt;vector&lt;int&gt;&gt; v(n + 1, vector&lt;int&gt;(3));\n    vector&lt;vector&lt;int&gt;&gt; dp(n + 1, vector&lt;int&gt;(3, -1));\n\n    for (int i = 1; i &lt;= n; i++) {\n        cin &gt;&gt; v[i][0] &gt;&gt; v[i][1] &gt;&gt; v[i][2];\n    }\n\n    cout &lt;&lt; max({solve(n, v, dp, 0), solve(n, v, dp, 1), solve(n, v, dp, 2)})\n         &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre> <pre><code>#include &lt;algorithm&gt;\n#include &lt;iostream&gt;\n#include &lt;vector&gt;\n\nusing namespace std;\n\nint main() {\n    int n;\n    cin &gt;&gt; n;\n\n    vector&lt;vector&lt;int&gt;&gt; dp(n + 1, vector&lt;int&gt;(3));\n\n    for (int i = 1; i &lt;= n; i++) {\n        int a, b, c;\n        cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;\n\n        if (i == 1) {\n            dp[1][0] = a;\n            dp[1][1] = b;\n            dp[1][2] = c;\n        } else {\n            dp[i][0] = max(dp[i - 1][1], dp[i - 1][2]) + a;\n            dp[i][1] = max(dp[i - 1][0], dp[i - 1][2]) + b;\n            dp[i][2] = max(dp[i - 1][0], dp[i - 1][1]) + c;\n        }\n    }\n\n    cout &lt;&lt; max({dp[n][0], dp[n][1], dp[n][2]}) &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre> <pre><code>#include &lt;algorithm&gt;\n#include &lt;iostream&gt;\n#include &lt;vector&gt;\n\nusing namespace std;\n\nint main() {\n    int n;\n    cin &gt;&gt; n;\n\n    vector&lt;vector&lt;int&gt;&gt; dp(2, vector&lt;int&gt;(3));\n\n    for (int i = 1; i &lt;= n; i++) {\n        int a, b, c;\n        cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;\n\n        if (i == 1) {\n            dp[0][0] = a;\n            dp[0][1] = b;\n            dp[0][2] = c;\n        } else {\n            dp[1][0] = max(dp[0][1], dp[0][2]) + a;\n            dp[1][1] = max(dp[0][0], dp[0][2]) + b;\n            dp[1][2] = max(dp[0][0], dp[0][1]) + c;\n\n            swap(dp[0], dp[1]);\n            fill(dp[1].begin(), dp[1].end(), 0);\n        }\n    }\n\n    cout &lt;&lt; max({dp[0][0], dp[0][1], dp[0][2]}) &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre> <p>Explica\u021bie</p> <p>Deoarece avem nevoie doar de ultimele dou\u0103 linii, nu vom \u021bine toat\u0103 matricea, mut\u00e2nd mereu valorile calculate pe prima linie pentru a p\u0103stra corectitudinea recuren\u021bei.</p>","tags":["programare dinamica","DP"]},{"location":"usor/intro-dp/#problema-array-description","title":"Problema Array Description","text":"<p>Pentru aceast\u0103 problem\u0103, trebuie s\u0103 afl\u0103m num\u0103rul de \u0219iruri pe care le putem construi astfel \u00eenc\u00e2t s\u0103 respecte condi\u021biile din enun\u021b cu privire la valorile deja setate \u0219i la diferen\u021ba dintre ele.</p> <p>Astfel, vom defini \\(dp_{i,j}\\) ca fiind num\u0103rul de moduri de a crea un \u0219ir cu \\(i\\) numere, dac\u0103 valoarea de pe pozi\u021bia \\(i\\) este \\(j\\).</p> <p>Pentru a afla \\(dp_{i,j}\\), va trebui s\u0103 ne raport\u0103m la valorile de pe pozi\u021bia precedent\u0103, aflate la o distan\u021b\u0103 de cel mult 1, cu condi\u021bia s\u0103 putem pune \\(j\\) pe pozi\u021bia \\(i\\).</p> <p>Observatie</p> <p>Pentru a calcula num\u0103rul de solu\u021bii modulo \\(x\\), vom folosi operatorul \\(\\%\\) (mod). Dar deoarece aici avem nevoie doar de opera\u021bii de adunare, putem pur \u0219i simplu s\u0103 efectu\u0103m opera\u021biile de adunare \u0219i s\u0103 folosim sc\u0103deri \u00een mod convenabil, reu\u0219ind astfel s\u0103 optimiz\u0103m solu\u021bia.</p> <pre><code>#include &lt;iostream&gt;\n#include &lt;vector&gt;\n\nusing namespace std;\n\nconst int MOD = 1000000007;\n\nint main() {\n    int n, m;\n    cin &gt;&gt; n &gt;&gt; m;\n\n    vector&lt;int&gt; vals(n + 1);\n    for (int i = 1; i &lt;= n; i++) {\n        cin &gt;&gt; vals[i];\n    }\n\n    vector&lt;vector&lt;int&gt;&gt; dp(n + 1, vector&lt;int&gt;(m + 1));\n\n    for (int i = 1; i &lt;= m; i++) {\n        if (vals[1] == 0 || vals[1] == i) {\n            dp[1][i] = 1;\n        }\n    }\n\n    for (int i = 2; i &lt;= n; i++) {\n        for (int j = 1; j &lt;= m; j++) {\n            if (vals[i] &amp;&amp; vals[i] != j) {\n                continue;\n            }\n            for (int dif = -1; dif &lt;= 1; dif++) {\n                if (j + dif &gt; 0 &amp;&amp; j + dif &lt;= m) {\n                    dp[i][j] += dp[i - 1][j + dif];\n                    if (dp[i][j] &gt;= MOD) {\n                        dp[i][j] -= MOD;\n                    }\n                }\n            }\n        }\n    }\n\n    int ans = 0;\n    for (int i = 1; i &lt;= m; i++) {\n        ans += dp[n][i];\n        if (ans &gt;= MOD) {\n            ans -= MOD;\n        }\n    }\n\n    cout &lt;&lt; ans &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["programare dinamica","DP"]},{"location":"usor/intro-dp/#problema-grid-1","title":"Problema Grid 1","text":"<p>Pentru aceast\u0103 problem\u0103, trebuie s\u0103 afl\u0103m num\u0103rul de moduri de a parcurge matricea din col\u021bul st\u00e2nga-sus \u00een col\u021bul dreapta-jos prin mi\u0219c\u0103ri \u00een jos \u0219i la dreapta, f\u0103r\u0103 s\u0103 parcurgem p\u0103trate acoperite de ziduri.</p> <p>Deoarece avem de-a face cu o matrice, putem \u021bine \\(dp_{i,j}\\) ca fiind num\u0103rul de moduri de a parcurge matricea dac\u0103 am ajuns la p\u0103tratul \\((i, j)\\). Deoarece putem ajunge la \\((i, j)\\) din p\u0103tratele de sus \u0219i st\u00e2nga, acestea vor fi cele dou\u0103 rezultate care contribuie la r\u0103spunsul dat.</p> <p>Astfel, \\(dp_{i,j} = dp_{i-1,j} + dp_{i,j-1}\\).</p>","tags":["programare dinamica","DP"]},{"location":"usor/intro-dp/#solutie","title":"Solu\u021bie","text":"<pre><code>#include &lt;iostream&gt;\n#include &lt;vector&gt;\n\nusing namespace std;\n\nconst int MOD = 1000000007;\n\nint main() {\n    int n, m;\n    cin &gt;&gt; n &gt;&gt; m;\n\n    vector&lt;vector&lt;char&gt;&gt; grid(n + 1, vector&lt;char&gt;(m + 1));\n    vector&lt;vector&lt;int&gt;&gt; dp(n + 1, vector&lt;int&gt;(m + 1));\n    for (int i = 1; i &lt;= n; i++) {\n        for (int j = 1; j &lt;= m; j++) {\n            cin &gt;&gt; grid[i][j];\n        }\n    }\n\n    dp[1][1] = 1;\n    for (int i = 1; i &lt;= n; i++) {\n        for (int j = 1; j &lt;= m; j++) {\n            if (grid[i][j] != '#') {\n                dp[i][j] += dp[i - 1][j] + dp[i][j - 1];\n                if (dp[i][j] &gt;= MOD) {\n                    dp[i][j] -= MOD;\n                }\n            }\n        }\n    }\n\n    cout &lt;&lt; dp[n][m] &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["programare dinamica","DP"]},{"location":"usor/intro-dp/#problema-sumtri1","title":"Problema Sumtri1","text":"RecursivIterativ <pre><code>#include &lt;fstream&gt;\n\nusing namespace std;\nifstream fin(\"sumtri1.in\");\nofstream fout(\"sumtri1.out\");\n\nconst int MAX_N = 101;\n\nusing matrixB = bool[MAX_N][MAX_N];\nusing matrixI = int[MAX_N][MAX_N];\n\nmatrixB change;\nmatrixI triunghi, dp;\n\nint n;\nint ans;\n\nint solve(const int lin, const int col) {\n    if (dp[lin][col] != 0) {\n        return dp[lin][col];\n    }\n    if (lin &gt; n) {\n        return 0;\n    }\n\n    const int left = solve(lin + 1, col);\n    const int right = solve(lin + 1, col + 1);\n\n    if (left &lt; right) {\n        dp[lin][col] = triunghi[lin][col] + left;\n        change[lin][col] = false;\n    } else {\n        dp[lin][col] = triunghi[lin][col] + right;\n        change[lin][col] = true;\n    }\n    return dp[lin][col];\n}\n\nint main() {\n    fin &gt;&gt; n;\n    for (int i = 1; i &lt;= n; i++) {\n        for (int j = 1; j &lt;= i; j++) {\n            fin &gt;&gt; triunghi[i][j];\n        }\n    }\n\n    fout &lt;&lt; solve(1, 1) &lt;&lt; '\\n';\n\n    for (int l = 1, c = 1; l &lt;= n; l++) {\n        fout &lt;&lt; triunghi[l][c] &lt;&lt; ' ';\n        if (change[l][c]) {\n            c++;\n        }\n    }\n    return 0;\n}\n</code></pre> <pre><code>#include &lt;fstream&gt;\n\nusing namespace std;\nifstream fin(\"sumtri1.in\");\nofstream fout(\"sumtri1.out\");\n\nconst int MAX_N = 101;\n\nusing matrix = int[MAX_N][MAX_N];\n\nint n;\nmatrix triunghi, dp, cale;\n\nint main() {\n    fin &gt;&gt; n;\n\n    for (int i = 1; i &lt;= n; ++i) {\n        for (int j = 1; j &lt;= i; ++j) {\n            fin &gt;&gt; triunghi[i][j];\n\n            if (i == n) {\n                dp[n][j] = triunghi[n][j];\n            }\n        }\n    }\n\n    for (int i = n - 1; i &gt; 0; --i) {\n        for (int j = 1; j &lt;= i; ++j) {\n            dp[i][j] = triunghi[i][j];\n\n            if (dp[i + 1][j + 1] &lt; dp[i + 1][j]) {\n                dp[i][j] += dp[i + 1][j + 1];\n                cale[i][j] = j + 1;\n            } else {\n                dp[i][j] += dp[i + 1][j];\n                cale[i][j] = j;\n            }\n            i don't \n        }\n    }\n\n    fout &lt;&lt; dp[1][1] &lt;&lt; '\\n';\n\n    int j = 1;\n    for (int i = 1; i &lt;= n; ++i) {\n        fout &lt;&lt; triunghi[i][j] &lt;&lt; \" \";\n        j = cale[i][j];\n    }\n\n    return 0;\n}\n</code></pre>","tags":["programare dinamica","DP"]},{"location":"usor/intro-dp/#probleme-suplimentare","title":"Probleme suplimentare","text":"<ul> <li>Infoarena custi</li> <li>Codeforces Boredom</li> <li>AtCoder Weak Takahashi</li> <li>IIOT 2023-24 PingPong</li> <li>AtCoder 1111gal password</li> <li>AtCoder Flip Cards</li> <li>IIOT Police</li> <li>Counting Towers</li> <li>AtCoder Index \u00d7 A(Not Continuous   ver.)</li> <li>AtCoder Between Two   Arrays</li> <li>Lot Juniori Minusk</li> <li>AtCoder Count Bracket   Sequences</li> <li>AtCoder I hate Non Integer   Number</li> <li>Not Escaping Codeforces</li> <li>Problemele cu DP de pe Kilonova</li> <li>Problemele intre rating 500 si 1400 de   aici</li> <li>Problemele cu DP de pe   infoarena</li> </ul>","tags":["programare dinamica","DP"]},{"location":"usor/intro-dp/#resurse-suplimentare","title":"Resurse suplimentare","text":"<ul> <li>DP Book</li> <li>Programare dinamica - CPPI   Sync</li> <li>Introduction to DP - USACO Guide</li> <li>Dynamic Programming Prologue - Codeforces</li> <li>Simple DP Optimizations - Codeforces</li> <li>DP Tutorial and Problem List</li> </ul>","tags":["programare dinamica","DP"]},{"location":"usor/maxime-minime/","title":"Maxime \u0219i minime","text":"","tags":["structura repetitiva","maxim","minim","vector"]},{"location":"usor/maxime-minime/#introducere","title":"Introducere","text":"<p>\u00cen multe probleme, suntem nevoi\u021bi s\u0103 afl\u0103m valoarea maxim\u0103 sau minim\u0103 dintre dou\u0103 sau mai multe numere, iar fie c\u0103 e vorba de dou\u0103, trei sau un num\u0103r oarecare de valori, algoritmul folosit, precum \u0219i tehnicile auxiliare sunt foarte importante de \u0219tiut.</p> <p>Vom prezenta cazurile cele mai simple, urmate de implement\u0103ri mai generalizate \u0219i \u00een final, diverse probleme clasice care implic\u0103 maxime \u0219i minime.</p> <p>Detalii de implementare</p> <p>\u00cen general, pentru a afla valoarea minim\u0103 \u00een loc de cea maxim\u0103, vom vrea s\u0103 schimb\u0103m semnul (<code>&lt;</code> \u00een loc de <code>&gt;</code>). Acest lucru va fi adev\u0103rat \u0219i \u00een cazul \u00een care permitem egalit\u0103\u021bi, care fac implement\u0103rile mai u\u0219oare.</p>","tags":["structura repetitiva","maxim","minim","vector"]},{"location":"usor/maxime-minime/#maximul-si-minimul-dintre-doua-numere","title":"Maximul \u0219i minimul dintre dou\u0103 numere","text":"<p>Pentru a afla valoarea mai mare dintre dou\u0103 numere date, este \u00eendeajuns s\u0103 folosim un if pentru a decide care dintre valorile date este mai mare. \u00cen mod similar, proced\u0103m \u0219i pentru valoarea minim\u0103.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    // maxim\n    if (a &gt;= b) {  // a este mai mare sau egal ca b\n        cout &lt;&lt; a &lt;&lt; '\\n';\n    } else {  // b este mai mare sau egal ca a\n        cout &lt;&lt; b &lt;&lt; '\\n';\n    }\n\n    // minim\n    if (a &lt;= b) {  // a este mai mic sau egal ca b\n        cout &lt;&lt; a &lt;&lt; '\\n';\n    } else {  // b este mai mic sau egal ca a\n        cout &lt;&lt; b &lt;&lt; '\\n';\n    }\n    return 0;\n}\n</code></pre>","tags":["structura repetitiva","maxim","minim","vector"]},{"location":"usor/maxime-minime/#maximul-si-minimul-dintre-trei-numere","title":"Maximul \u0219i minimul dintre trei numere","text":"<p>Pentru a afla cea mai mare valoare dintre trei numere, avem dou\u0103 variante de a rezolva aceast\u0103 problem\u0103.</p> <p>O prim\u0103 variant\u0103 const\u0103 \u00een a verifica pentru fiecare dintre cele trei numere dac\u0103 este mai mare sau egal (pentru minim, mai mic sau egal) cu celelalte dou\u0103 numere.</p> <p>Cea de-a doua variant\u0103 const\u0103 \u00een aflarea maximului sau minimului dintre primele dou\u0103 numere, iar mai apoi verificarea cu cel de-al treilea num\u0103r.</p> <p>Mai jos implement\u0103m ambele variante.</p> Varianta 1Varianta 2 <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b, c;\n    cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;\n\n    // maxim\n\n    if (a &gt;= b &amp;&amp; a &gt;= c) {  // a este mai mare sau egal ca b si c\n        cout &lt;&lt; a &lt;&lt; '\\n';\n    } else {\n        if (b &gt;= a &amp;&amp; b &gt;= c) {  // b este mai mare sau egal ca a si c\n            cout &lt;&lt; b &lt;&lt; '\\n';\n        } else {  // c este mai mare sau egal ca a si b\n            cout &lt;&lt; c &lt;&lt; '\\n';\n        }\n    }\n    return 0;\n}\n</code></pre> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b, c;\n    cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;\n\n    int maxim = a;\n    if (b &gt;= maxim) {\n        maxim = b;\n    }\n    if (c &gt;= maxim) {\n        maxim = c;\n    }\n\n    cout &lt;&lt; maxim &lt;&lt; '\\n';\n\n    int minim = a;\n    if (b &lt;= minim) {\n        minim = b;\n    }\n    if (c &lt;= minim) {\n        minim = c;\n    }\n\n    cout &lt;&lt; minim &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre> <p>De\u0219i ambele variante sunt corecte, se poate observa c\u0103 varianta 2 este mai simpl\u0103 \u0219i mai u\u0219or de utilizat \u00een practic\u0103, aceasta fiind \u0219i varianta pe care o vom folosi atunci c\u00e2nd vrem s\u0103 generaliz\u0103m aflarea maximului sau minimului unui \u0219ir de valori.</p>","tags":["structura repetitiva","maxim","minim","vector"]},{"location":"usor/maxime-minime/#maximul-si-minimul-dintre-n-numere","title":"Maximul \u0219i minimul dintre \\(n\\) numere","text":"<p>Pentru a afla valoarea maxim\u0103 (sau minim\u0103) a unui \u0219ir de \\(n\\) numere, vom putea pleca de la cazul de baz\u0103 cu 2 numere, iar pentru fiecare num\u0103r nou ad\u0103ugat, vom verifica dac\u0103 valoarea nou ad\u0103ugat\u0103 este mai mare dec\u00e2t maximul de p\u00e2n\u0103 acum (sau mai mic\u0103 dec\u00e2t minimul, dup\u0103 caz).</p> <p>Pentru a afla acest r\u0103spuns, putem fie s\u0103 plec\u0103m cu r\u0103spunsul egal cu prima valoare din \u0219ir, fie s\u0103 ini\u021bializ\u0103m r\u0103spunsul cu o valoare care s\u0103 ne asigure c\u0103 indiferent ce valori avem, r\u0103spunsul va fi una din valorile din \u0219ir.</p> <p>Astfel, dac\u0103 vrem s\u0103 afl\u0103m valoarea maxim\u0103 din \u0219ir, vrem s\u0103 ini\u021bializ\u0103m maximul cu o valoare foarte mic\u0103($ -10^9$ sau chiar mai mic\u0103), iar \u00een caz contrar, cu o valoare foarte mare(\\(10^9\\) sau chiar mai mare). \u00cen general, se prefer\u0103 varianta \u00een care ini\u021bializ\u0103m r\u0103spunsul cu o valoare suficient de mare/mic\u0103 pentru scopurile noastre, solu\u021bie implementat\u0103 mai jos pentru maxim.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n\n    int n;\n    cin &gt;&gt; n;\n\n    int maxim = -1000000000;\n    for (int i = 1; i &lt;= n; i++) {\n        int x;\n        cin &gt;&gt; x;\n\n        if (x &gt; maxim) {\n            maxim = x;\n        }\n    }\n\n    cout &lt;&lt; maxim &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["structura repetitiva","maxim","minim","vector"]},{"location":"usor/maxime-minime/#aflarea-celor-mai-marimici-doua-valori","title":"Aflarea celor mai mari/mici dou\u0103 valori","text":"<p>Pentru aflarea celor mai mari/mici dou\u0103 valori, vom putea proceda similar ca la algoritmul precedent, singura diferen\u021b\u0103 fiind faptul c\u0103 efortul de implementare va cre\u0219te deoarece pentru fiecare valoare nou ad\u0103ugat\u0103, exist\u0103 dou\u0103 cazuri:</p> <ul> <li>Fie este cea mai mare/mic\u0103 valoare, iar atunci, cel de-al doilea maxim/minim   devine maximul/minimul precedent, iar noua valoare este cea maxim\u0103/minim\u0103.</li> <li>Fie nu este maxim/minim, dar este mai mare/mic\u0103 dec\u00e2t cel de-al doilea   maxim/minim, iar atunci, schimb\u0103m valoarea celui de-al doilea maxim/minim.</li> </ul> <p>Mai jos, ve\u021bi g\u0103si o implementare care afl\u0103 cele mai mici dou\u0103 valori dintr-un \u0219ir.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int n;\n    cin &gt;&gt; n;\n\n    int minim = 1000000000;\n    int minim2 = 1000000000;\n    for (int i = 1; i &lt;= n; i++) {\n        int x;\n        cin &gt;&gt; x;\n\n        if (x &lt; minim) {\n            minim2 = minim;\n            minim = x;\n        } else {\n            if (x &lt; minim2) {\n                minim2 = x;\n            }\n        }\n    }\n\n    cout &lt;&lt; minim &lt;&lt; \" \" &lt;&lt; minim2 &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["structura repetitiva","maxim","minim","vector"]},{"location":"usor/maxime-minime/#aflarea-celor-mai-marimici-k-valori","title":"Aflarea celor mai mari/mici \\(k\\) valori","text":"<p>Pentru a extinde problema la \\(k\\) valori, va fi necesar\u0103 cunoa\u0219terea vectorilor, ceea ce face aceast\u0103 aplica\u021bie mai dificil\u0103. Astfel, vom proceda la fel ca la cazul precedent, dar vom \u021bine cele mai mari/mici \\(k\\) valori \u00eentr-un vector \u0219i vom efectua modific\u0103rile \u00een mod corespunz\u0103tor.</p> <p>Mai jos, ve\u021bi g\u0103si o implementare care afl\u0103 cele mai mici \\(k\\) valori dintr-un \u0219ir.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int n, k;\n    cin &gt;&gt; n &gt;&gt; k;\n\n    int mini[k + 1];\n    for (int i = 1; i &lt;= k; i++) {\n        mini[i] = 1000000000;\n    }\n\n    for (int i = 1; i &lt;= n; i++) {\n        int x;\n        cin &gt;&gt; x;\n\n        for (int j = 1; j &lt;= k; j++) {\n            if (x &lt;= mini[j]) {  // daca x este mai mic decat al j-lea minim\n                for (int poz = k; poz &gt; j;\n                     poz--) {  // mutam minimele la dreapta\n                    mini[poz] = mini[poz - 1];\n                }\n                mini[j] = x;  // schimbam al j-lea minim\n                break;\n            }\n        }\n    }\n\n    for (int i = 1; i &lt;= k; i++) {\n        cout &lt;&lt; mini[i] &lt;&lt; \" \";\n    }\n    return 0;\n}\n</code></pre>","tags":["structura repetitiva","maxim","minim","vector"]},{"location":"usor/maxime-minime/#concluzii","title":"Concluzii","text":"<p>Cunoa\u0219terea tipurilor de implement\u0103ri care se folosesc de conceptul de maxim \u0219i minim este esen\u021bial\u0103 pentru orice programator \u00eencep\u0103tor \u0219i nu numai, aceste tehnici fiind \u00eent\u00e2lnite \u0219i drept subprobleme pentru aplica\u021bii mai avansate.</p>","tags":["structura repetitiva","maxim","minim","vector"]},{"location":"usor/maxime-minime/#probleme-suplimentare","title":"Probleme suplimentare","text":"<ul> <li>summaxmin pbinfo</li> <li>maxandap pbinfo</li> <li>rafaelo pbinfo</li> <li>existaprime pbinfo</li> <li>memory002 pbinfo</li> <li>Probleme cu maxime si minime de pe   pbinfo</li> </ul>","tags":["structura repetitiva","maxim","minim","vector"]},{"location":"usor/maxime-minime/#resurse-suplimentare","title":"Resurse suplimentare","text":"<ul> <li>Maxime si minime -   pbinfo</li> <li>Maxime si minime - CPPI   Sync</li> </ul>","tags":["structura repetitiva","maxim","minim","vector"]},{"location":"usor/partial-sums/","title":"Sume par\u021biale. \u0218menul lui Mars","text":"","tags":["sume partiale","implementare","optimizare","difference arrays","mars"]},{"location":"usor/partial-sums/#problema-initiala","title":"Problema ini\u021bial\u0103","text":"<p>S\u0103 presupunem c\u0103 avem un \u0219ir \\(V\\) de \\(N\\) numere indexat de la 1, iar asupra \u0219irului primim mai multe \u00eentreb\u0103ri de forma: care este suma valorilor cuprinse \u00eentre pozi\u021biile \\(st\\) \u0219i \\(dr\\) (inclusiv) \u00een \u0219ir?</p> <p>R\u0103spunsul pentru aceast\u0103 \u00eentrebare se poate calcula foarte u\u0219or dac\u0103 realiz\u0103m parcurgerea efectiv\u0103 a \u0219irului de la pozi\u021bia \\(st\\) la pozi\u021bia \\(dr\\) \u0219i ne-ar lua \\(\\mathcal{O}(N)\\) pa\u0219i \u00een cel mai r\u0103u caz ca s\u0103 r\u0103spundem la o \u00eentrebare, complexitatea final\u0103 a programului ajung\u00e2nd la \\(\\mathcal{O}(N \\cdot Q)\\), ceea ce pentru valori mai mari de \\(10^4\\) pentru \\(N\\) \u0219i \\(Q\\) ar dep\u0103\u0219i limitele de timp la majoritatea problemelor de algoritmic\u0103. A\u0219adar, este nevoie de o optimizare, care se nume\u0219te \u201eSume par\u021biale\u201d.</p>","tags":["sume partiale","implementare","optimizare","difference arrays","mars"]},{"location":"usor/partial-sums/#prezentarea-conceptului","title":"Prezentarea conceptului","text":"<p>Sumele par\u021biale reprezint\u0103 o optimizare pentru algoritmii care trebuie s\u0103 afle o sum\u0103 pe un interval, iar pe acel interval nu se produc modific\u0103ri.</p> <p>Consider\u0103m:</p> \\[ \\textrm{sp}_i = \\sum_{k = 1}^{i} v_k \\] <p>unde \\(sp_i\\) suma valorilor de pe prefixul \\(1, 2, \\dots, i\\).</p> <p>Tabloul se calculeaz\u0103 \u00een felul urm\u0103tor:</p> <pre><code>for (int i = 1; i &lt;= n; i++) {\n    sp[i] = sp[i - 1] + v[i];\n}\n</code></pre> <p>Dup\u0103 calculare, putem \u00eencepe s\u0103 r\u0103spunem la \u00eentreb\u0103ri. R\u0103spunsul nostru pentru un interval \\([st, dr]\\), unde \\(1 \\leq st \\leq dr \\leq n\\) va fi: \\(suma = sp[dr] - sp[st - 1]\\)</p> <p>Faptul c\u0103 r\u0103spunsul nostru este dat de o formul\u0103, va face ca timpul nostru efectuat pentru rezolvarea unei \u00eentreb\u0103ri s\u0103 fie constant \\(\\mathcal{O}(1)\\), ceea ce va duce ca programul nostru s\u0103 aib\u0103 o complexitate final\u0103 \\(\\mathcal{O}(N + Q)\\), pentru calcularea tabloului \\(sp\\) \u0219i pentru citirea \u0219i r\u0103spunderea la \u00eentreb\u0103ri. Totu\u0219i, hai s\u0103 vedem de ce formula men\u021bionat\u0103 mai sus func\u021bioneaz\u0103.</p> <p>Pentru demonstra\u021bie, vom \u00eencerca o abordare grafic\u0103 a formulei. Primul pas const\u0103 \u00een adunarea sumei prefixului \\(1, 2, \\dots, dr\\).</p> <p> </p> <p>Apoi, va trebui s\u0103 sc\u0103dem prefixul \\(1, 2, \\dots, st - 1\\).  </p> <p>\u00cen final, subsecven\u021ba \\(st, st + 1, \\dots, dr - 1, dr\\) va fi alc\u0103tuit\u0103 din acele pozi\u021bii care se afl\u0103 \u00een segmentul mov, dar nu \u00een segmentul ro\u0219iatic (\\(1, 2, ..., st-1\\)). A\u0219adar, \u00een urma acestei delimit\u0103ri o s\u0103 ob\u021binem suma cerut\u0103 pe intervalul nostru.</p>","tags":["sume partiale","implementare","optimizare","difference arrays","mars"]},{"location":"usor/partial-sums/#extinderea-sumelor-partiale-pe-matrice","title":"Extinderea sumelor par\u021biale pe matrice","text":"<p>De asemenea, sumele par\u021biale se pot extinde \u0219i pe tablouri bidimensionale. S\u0103 presupunem c\u0103 lucr\u0103m cu matricea \\(A\\) care are \\(N\\) linii \u0219i \\(M\\) coloane. Vom defini matricea \\(sp\\) \u00een felul urm\u0103tor: \\(sp[i][j]\\) reprezint\u0103 suma valorilor aflate \u00een submatricea care are col\u021bul st\u00e2nga-sus de coordonate \\((1, 1)\\) \u0219i col\u021bul dreapta-jos de coordonate \\((i, j)\\).</p> <p>Astfel, putem scrie:</p> \\[ sp[i][j] = \\sum_{x=1}^{i} \\sum_{y=1}^{j} a[x][y] \\] <p>unde \\(a[x][y]\\) reprezint\u0103 elementele matricei originale.</p> <p>Fa\u021b\u0103 de cazul \\(1D\\), aici vom \u00eencepe cu demonstra\u021bia formulei de calcul a unei sume pe o submatrice, apoi vom \u0219i ar\u0103ta cum se va calcula matricea \\(sp\\). Vom analiza ni\u0219te cazuri particulare de submatrice, apoi vom enun\u021ba o formul\u0103 final\u0103.</p> <p>Pentru \u00eenceput, datorit\u0103 modului \u00een care am definit matricea \\(sp\\), primul caz particular pe care \u00eel vom analiza va fi calcularea sumei de pe o submatrice care are col\u021bul st\u00e2nga-sus de coordonate \\((1, 1)\\) \u0219i col\u021bul dreapta-jos de coordonate \\((x, y)\\). R\u0103spunsul \u00een acest caz va fi \\(sp[x][y]\\), deoarece fix acest lucru ne este calculat de c\u0103tre matricea \\(sp\\).</p> <p> </p> <p>\\(suma = sp[x][y]\\)</p> <p>Acum, s\u0103 analiz\u0103m urm\u0103torul caz: ni se cere s\u0103 afl\u0103m suma valorilor dintr-o submatrice care are col\u021bul st\u00e2nga-sus de coordonate \\((1, z)\\) \u0219i col\u021bul dreapta-jos de coordonate \\((x, y)\\). Formula men\u021bionat\u0103 mai sus nu este corect\u0103, dar este un punct de plecare. Noi vom con\u021bine o submatrice \u00een plus \u00een cea determinat\u0103 de col\u021burile de coordonate \\((1, 1)\\) \u0219i \\((x, y)\\), anume cea determinat\u0103 de col\u021burile \\((1, 1)\\) \u0219i \\((x, z - 1)\\). A\u0219adar, dup\u0103 adunarea sumei date de \\(sp[x][y]\\) va fi nevoie s\u0103 sc\u0103dem \\(sp[x][z - 1]\\).</p> <p> </p> <p>\\(suma = sp[x][y] - sp[x][z - 1]\\)</p> <p>Asemenea cazului precedent este si cazul \u00een care noi dorim s\u0103 afl\u0103m suma unei submatrice care are col\u021burile \\((z, 1)\\) \u0219i \\((x, y)\\). Similar, \\(sp[x][y]\\) nu este suficient, dar este un punct de plecare. Fa\u021b\u0103 de cazul precedent, submatricea \u00een plus este cea determinat\u0103 de col\u021burile \\((1, 1)\\) \u0219i \\((z - 1, y)\\). \u00cen final, formula pentru acest caz va fi \\(sp[x][y] - sp[z - 1][y]\\).</p> <p> </p> <p>\\(suma = sp[x][y] - sp[z - 1][y]\\)</p> <p>Acum, putem \u00eencerca s\u0103 deducem o formul\u0103 pentru orice submatrice. S\u0103 consider\u0103m submatricea determinat\u0103 de col\u021burile st\u00e2nga-sus de coordonate \\((x, y)\\) \u0219i dreapta-jos de coordonate \\((z, t)\\). Dac\u0103 ar fi s\u0103 adun\u0103m formulele demonstrate \u00een ultimele dou\u0103 cazuri \\((sp[z][t] - sp[x - 1][t] - sp[z][y - 1])\\), noi o s\u0103 sc\u0103dem de dou\u0103 ori suma din submatricea determinat\u0103 de col\u021burile \\((1, 1)\\) \u0219i \\((x - 1, y - 1)\\), \u00een timp ce noi o adun\u0103m doar o dat\u0103. A\u0219adar, la formul\u0103 se va aduna \u0219i suma din submatricea respectiv\u0103, pentru a compensa deficitul.</p> <p> </p> <p>\\(suma = sp[z][t] - sp[z][y - 1] - sp[x - 1][t] + sp[x - 1][y - 1]\\)</p> <p>Cu un ra\u021bionament asem\u0103n\u0103tor celui pentru determinarea formulei pentru cazul general, vom determina \u0219i cum se calculeaz\u0103 matricea \\(sp\\). S\u0103 presupunem c\u0103 vrem s\u0103 afl\u0103m \\(sp[i][j]\\). Mai \u00eent\u00e2i vom porni de la a scrie formula pentru a afla suma valorii de pe pozi\u021bia \\((i, j)\\) \u00een matrice (valoare pe care noi o \u0219i stim!):</p> <p>\\(sp[i][j] - sp[i - 1][j] - sp[i][j - 1] + sp[i - 1][j - 1] = A[i][j]\\)</p> <p>Trecem to\u021bi termenii, cu excep\u021bia lui \\(sp[i][j]\\), \u00een dreapta \u0219i ob\u021binem:</p> <p>\\(sp[i][j] = sp[i - 1][j] + sp[i][j - 1] - sp[i - 1][j - 1] + A[i][j]\\)</p> <p>Deci, tabloul \\(sp\\) se poate calcula destul de u\u0219or \u00een timp \\(\\mathcal{O}(N \\cdot M)\\). Ata\u0219\u0103m, mai jos, o secven\u021b\u0103 de cod \u00een care se calculeaz\u0103 matricea \\(sp\\).</p> <pre><code>for (int i = 1; i &lt;= n; i++) {\n    for (int j = 1; j &lt;= m; j++) {\n        sp[i][j] = sp[i - 1][j] + sp[i][j - 1] - sp[i - 1][j - 1] + a[i][j];\n    }\n}\n</code></pre>","tags":["sume partiale","implementare","optimizare","difference arrays","mars"]},{"location":"usor/partial-sums/#smenul-lui-mars","title":"\u0218menul lui Mars","text":"<p>S\u0103 consider\u0103m urm\u0103toarea problem\u0103: se d\u0103 o ax\u0103 \u0219i \\(K\\) intervale de forma \\([st, dr]\\). Ni se dau dup\u0103 \\(Q\\) \u00eentreb\u0103ri de forma: c\u00e2te intervale con\u021bin \u00een interiorul lor punctul \\(x\\) de pe ax\u0103?</p> <p>O solu\u021bie foarte ineficient\u0103 ar fi pentru fiecare \u00eentrebare s\u0103 lu\u0103m fiecare interval \u00een parte \u0219i s\u0103 verific\u0103m dac\u0103 punctul nostru este inclus sau nu \u00een interval. Solu\u021bia este u\u0219or de intuit \u0219i de implementat, dar programul nostru ar avea complexitate \\((Q \\cdot K)\\). \u0218menul lui Marius Andrei (Mars) ne poate rezolva aceast\u0103 problem\u0103 \u00een timp constant, chiar \u0219i dac\u0103 o extindem pe mai multe dimensiuni (dou\u0103 axe, 3 axe etc.).</p> <p>Observa\u021bie</p> <p>De\u0219i \u00een algoritmica rom\u00e2neasc\u0103, aceast\u0103 tehnic\u0103 este cunoscut\u0103 sub numele de \u0218menul lui Mars, numele ei standard este difference arrays.</p> <p>\u0218menul lui Mars permite efectuarea opera\u021biilor de ad\u0103ugare a unei valori la toate elementele dintr-un interval (sau o submatrice, pentru cazul \u00een care lucr\u0103m cu o matrice), f\u0103r\u0103 posibilitatea de a primi \u00eentreb\u0103ri \u00eentre opera\u021biile de ad\u0103ugare (pentru acest tip de problem\u0103 se vor utiliza arborii de intervale, o tehnic\u0103 care va fi prezentat\u0103 ulterior).</p> <p>C\u00e2nd primim actualiz\u0103rile, noi vom efectua ni\u0219te adun\u0103ri \u0219i ni\u0219te sc\u0103deri pentru a delimita bucata din \u0219ir / matrice pe care se efectueaz\u0103 opera\u021bia. Apoi, valorile efective din structura noastr\u0103 de date se vor calcula asem\u0103n\u0103tor sumelor par\u021biale, fapt ce ne poate intui \u00eentr-o modalitate cum vom efectua aceste opera\u021bii.</p>","tags":["sume partiale","implementare","optimizare","difference arrays","mars"]},{"location":"usor/partial-sums/#smenul-lui-mars-1d","title":"\u0218menul lui Mars 1D","text":"<p>Primul pas c\u00e2nd aplic\u0103m \u0218menul lui Mars unui \u0219ir, va trebui s\u0103 lu\u0103m fiecare interval \u00een parte \u0219i s\u0103 delimit\u0103m bucata din \u0219ir pe care efectu\u0103m opera\u021bia. Pentru intervalul de pozi\u021bii \\([x, y]\\), vom actualiza \u00een \u0219men cu \\(+1\\) la pozi\u021bia \\(x\\), ca s\u0103 ilustr\u0103m c\u0103 a \u00eenceput un nou interval, \u0219i cu \\(-1\\) la pozi\u021bia \\(y + 1\\) pentru a ar\u0103ta faptul c\u0103 intervalul nostru nu cuprinde \u0219i pozi\u021bia \\(y + 1\\). Astfel, vom avea:</p> <pre><code>mars[x]++;\nmars[y + 1]--;\n</code></pre> <p>unde vectorul \\(\\mathrm{mars}[]\\) reprezint\u0103 adun\u0103rile/sc\u0103derile din \u0219men. A\u0219a cum am zis \u0219i mai sus, noi calcul\u0103m valorile noastre din \u0219ir ca la sumele par\u021biale, deci, se poate afirma c\u0103: \\(v[i] = \\mathrm{mars}[1] + \\mathrm{mars}[2] + \\dots + \\mathrm{mars}[i]\\)</p> <p>Dupa efectuarea tuturor opera\u021biilor de ad\u0103ugare pe interval, noi vom calcula printr-o parcurgere simpl\u0103 valorile din \u0219irul \\(V\\):</p> <pre><code>for (int i = 1; i &lt;= n; i++) {\n    mars[i] += mars[i - 1];\n    v[i] = mars[i];\n}\n</code></pre> <p>Aten\u021bie la faptul c\u0103 suma pe prefixul \\(1, 2, \\dots, i\\) va fi \u021binut\u0103 \u00een \\(\\mathrm{mars}[i]\\). Revenind la problema noastr\u0103 ini\u021bial\u0103, r\u0103spunsul la fiecare \u00eentrebare va fi \u00een \\(\\mathrm{mars}[x]\\), astfel ob\u021bin\u00e2nd \\(\\mathcal{O}(1)\\) pe query. Evident, dac\u0103 vrem s\u0103 ad\u0103ug\u0103m o valoare \\(z\\) \u00een loc de 1 pe interval, acest lucru se poate realiza foarte u\u0219or:</p> <pre><code>mars[x] += z;\nmars[y + 1] -= z;\n/// cod din program\nfor (int i = 1; i &lt;= n; i++) {\n    mars[i] += mars[i - 1];\n    v[i] += mars[i];\n}\n</code></pre> <p>Codul de mai sus poate s\u0103 sus\u021bin\u0103 \u0219i updateuri pe un \u0219ir ini\u021bial nevid. Dac\u0103 problema noastr\u0103 nu are suficient\u0103 memorie pentru men\u021binerea \u0219irului, aceste plusuri \u0219i minusuri se pot re\u021bine ca evenimente, care se pot sorta dup\u0103 pozi\u021bie pentru efectuarea lor. Nu o s\u0103 intr\u0103m \u00een profunzime momentan cu aceast\u0103 tehnic\u0103, dar o l\u0103s\u0103m ca tem\u0103 pentru studiu cititorului.</p>","tags":["sume partiale","implementare","optimizare","difference arrays","mars"]},{"location":"usor/partial-sums/#smenul-lui-mars-2d","title":"\u0218menul lui Mars 2D","text":"<p>\u0218menul lui Mars aplicat pe o matrice presupune \u00een\u021belegerea mai profund\u0103 a cum se propag\u0103 sumele par\u021biale pe matrice. S\u0103 presupunem c\u0103 avem submatricea delimitat\u0103 de col\u021burile \\((x, y)\\) \u0219i \\((z, t)\\). Dac\u0103 o s\u0103 facem doar o adunare \u0219i o sc\u0103dere ca la cazul liniar din \u0219menul lui Mars, propag\u0103rile noastre vor fi foarte eronate. S\u0103 privim \u00een desen de ce:</p> <p> </p> <p>O s\u0103 avem, \u00een plus, multe elemente care sunt actualizate. De aceea, se va proceda \u00een felul urm\u0103tor: se va p\u0103stra adunarea de la \\(\\mathrm{mars}[x][y]\\) \u0219i se va sc\u0103dea la \\(\\mathrm{mars}[z + 1][y]\\) \u0219i \\(\\mathrm{mars}[x][t + 1]\\). \u00cenc\u0103 nu este complet, fiindc\u0103 pe submatricea \\((z + 1, t + 1), (N, M)\\) vor fi o adunare \u0219i dou\u0103 sc\u0103deri, deci acum sc\u0103dem mai mult dec\u00e2t ar trebui, deci va trebui s\u0103 adun\u0103m \u0219i la \\(\\mathrm{mars}[z + 1][t + 1]\\).</p> <p> </p> <p>\u00cen cod, ar ar\u0103ta \u00een felul urm\u0103tor:</p> <pre><code>mars[x][y] += k;\nmars[z + 1][y] -= k;\nmars[x][t + 1] -= k;\nmars[z + 1][t + 1] += k;\n/// cod din program\nfor (int i = 1; i &lt;= n; i++) {\n    for (int j = 1; j &lt;= m; j++) {\n        mars[i][j] += mars[i - 1][j] + mars[i][j - 1] - mars[i - 1][j - 1];\n        a[i][j] += mars[i][j];\n    }\n}\n</code></pre> <p>\u00cen final, \u00een urma opera\u021biilor de ad\u0103ugare, dac\u0103 vrem s\u0103 \u0219tim ce valoare se afl\u0103 pe pozi\u021bia \\((i, j)\\), r\u0103spunsul va fi dat de \\(A_{i, j}\\).</p> <p>\u0218menul lui Mars poate fi extins \u0219i pe 3 dimensiuni sau chiar mai multe, iar abordarea pe mai multe dimensiuni se va realiza identic, dar o s\u0103 fie rar \u00eent\u00e2lnit \u00een problemele de algoritmic\u0103 cazuri \u00een care s\u0103 se cear\u0103 \u0219menul lui Mars pe mai mult de dou\u0103 dimensiuni.</p>","tags":["sume partiale","implementare","optimizare","difference arrays","mars"]},{"location":"usor/partial-sums/#concluzii","title":"Concluzii","text":"<p>Sumele par\u021biale sunt o optimizare cheie \u00een algoritmic\u0103, ajut\u00e2ndu-ne s\u0103 transform\u0103m lucruri precum aflarea unei sume pe un interval dintr-o \u00eentreag\u0103 parcurgere \u00eentr-o simpl\u0103 formul\u0103, cu timp constant de r\u0103spuns.</p> <p>Tehnici precum \u0219menul lui Mars reprezint\u0103 un pas \u00eenainte pentru procesarea diverselor probleme care implic\u0103 lucrul cu queryuri de diverse feluri, fiind o metod\u0103 auxiliar\u0103 util\u0103 c\u00e2nd vine vorba de alte tehnici.</p>","tags":["sume partiale","implementare","optimizare","difference arrays","mars"]},{"location":"usor/partial-sums/#probleme-de-la-olimpiade","title":"Probleme de la olimpiade","text":"<ul> <li>Prefix Sums 1D</li> <li>plaja ONI 2010</li> <li>gradina ONI 2013</li> <li>Breed Counting USACO     Silver</li> <li>flip01 RoAlgo PreOJI 2024</li> <li>sirpal RoAlgo PreOJI 2024</li> <li>cdcq RoAlgo Contest #1</li> <li>infoarena mostenire2</li> <li>infoarena bmatrix</li> <li>tnia OJI 2018</li> <li>balon ONI 2023</li> <li>poseidon RoAlgo Contest #4</li> <li>investi\u021bie OJI 2023</li> <li>Probleme cu sume par\u021biale</li> <li>Probleme cu \u0219menul lui Mars</li> <li>Subsequences Summing to Sevens USACO     Silver</li> <li>Haybale Stacking USACO Bronze</li> <li>ONI 2024 Eras</li> <li>Painting the Barn USACO     Gold</li> </ul>","tags":["sume partiale","implementare","optimizare","difference arrays","mars"]},{"location":"usor/partial-sums/#probleme-de-pe-codeforces","title":"Probleme de pe Codeforces","text":"<ul> <li>Good Subarrays</li> <li>Robert Hood and Mrs Hood</li> <li>Running Miles</li> <li>Irreductible Anagrams</li> <li>Attribute Checks</li> <li>Tea Tasting</li> <li>Nusret Gokce</li> <li>Constant Palindrome Sum</li> <li>Two Pointers Step 3 - Codeforces     EDU</li> </ul>","tags":["sume partiale","implementare","optimizare","difference arrays","mars"]},{"location":"usor/partial-sums/#bibliografie-si-lectura-suplimentara","title":"Bibliografie \u0219i lectur\u0103 suplimentar\u0103","text":"<ul> <li>Sume par\u021biale - CPPI</li> <li>Trucul lui Mars - CPPI</li> <li>Prefix Sums - USACO Guide</li> <li>More on Prefix Sums</li> <li>An Introduction to Difference     Arrays</li> </ul>","tags":["sume partiale","implementare","optimizare","difference arrays","mars"]},{"location":"usor/roadmap/","title":"Ordinea \u00eenv\u0103\u021b\u0103rii con\u021binuturilor (roadmap)","text":"","tags":["meta","sfaturi","pas cu pas"]},{"location":"usor/roadmap/#introducere","title":"Introducere","text":"<p>\u00cen ultimii ani, au ap\u0103rut foarte multe resurse care permit \u00eenv\u0103\u021barea algoritmilor \u0219i structurilor de date \u00eentr-un mod complet f\u0103r\u0103 prea multe probleme. Totu\u0219i, o mare problem\u0103 care \u00eenc\u0103 exist\u0103 \u00een prezent este lipsa unei structuri clare care s\u0103 permit\u0103 \u00een\u021belegerea acestor no\u021biuni, adaptat\u0103 la cerin\u021bele sistemului educa\u021bional din Rom\u00e2nia \u0219i a diverselor niveluri, mai ales c\u00e2nd vine vorba de olimpiad\u0103 \u0219i de concursurile de informatic\u0103.</p> <p>Chiar dac\u0103 programele \u0219colare, fie c\u0103 e vorba de programele cadru sau programele claselor de la olimpiad\u0103 sunt un pas important f\u0103cut \u00een special \u00een ultimii ani, totu\u0219i \u00eenc\u0103 nu exist\u0103 o ordine clar\u0103 \u00een care aceste no\u021biuni sunt discutate, ci doar o list\u0103 a no\u021biunilor care trebuie parcurse la un anumit nivel, f\u0103r\u0103 a \u021bine cont de dificultatea relativ\u0103 a acestora.</p> <p>\u00cen acest articol, vom prezenta ordinea pe care o propunem pentru \u00eenv\u0103\u021barea acestor no\u021biuni, acesta fiind un roadmap pe care \u00eel recomand\u0103m tuturor pasiona\u021bilor de algoritmi \u0219i structuri de date, \u0219i nu numai.</p> <p>Cu alte cuvinte, vom putea spune c\u0103 sunte\u021bi la 10 capitole distan\u021b\u0103 de a putea ajunge la olimpiada interna\u021bional\u0103 de informatic\u0103. Totu\u0219i, aceste capitole necesit\u0103 foarte mult\u0103 munc\u0103, timp \u0219i efort pentru a fi studiate \u0219i \u00een\u021belese temeinic.</p>","tags":["meta","sfaturi","pas cu pas"]},{"location":"usor/roadmap/#clarificari-si-precizari","title":"Clarific\u0103ri \u0219i preciz\u0103ri","text":"<p>\u00cen arhiv\u0103, avem sec\u021biunile U\u0219or, Mediu, Dificil \u0219i Avansat care au drept scop crearea unei \u00eemp\u0103r\u021biri aproximative a con\u021binuturilor pe niveluri de dificultate. De asemenea, fiecare articol va avea la \u00eenceput o list\u0103 de articole pe care le recomand\u0103m s\u0103 le citi\u021bi \u00eenainte s\u0103 citi\u021bi articolul curent, pentru a \u00een\u021belege mai bine con\u021binutul (de exemplu, pentru a citi articolul despre aflarea cifrelor unui num\u0103r, trebuie s\u0103 \u0219ti\u021bi s\u0103 lucra\u021bi cu operatori \u0219i expresii).</p> <p>\u00cen cele ce urmeaz\u0103, vom prezenta o ordine \u00een care recomand\u0103m \u00eenv\u0103\u021barea no\u021biunilor \u0219i parcurgerea arhivei, de la cele mai u\u0219oare p\u00e2n\u0103 la cele mai dificile dintre cele prezente aici \u0219i nu numai, ordinea fiind una \u00eentr-o ordine relativ cresc\u0103toare a dificult\u0103\u021bii.</p>","tags":["meta","sfaturi","pas cu pas"]},{"location":"usor/roadmap/#capitolul-0-articole-generale","title":"Capitolul 0 - Articole generale","text":"<p>Chiar dac\u0103 acesta este capitolul 0, se recomand\u0103 \u00eentoarcerea la el de fiecare dat\u0103 c\u00e2nd concura\u021bi sau vre\u021bi s\u0103 afla\u021bi mai multe despre ce v\u0103 a\u0219teapt\u0103.</p>","tags":["meta","sfaturi","pas cu pas"]},{"location":"usor/roadmap/#informatii-generale-si-programa-olimpiadelor","title":"Informa\u021bii generale \u0219i programa olimpiadelor","text":"<ul> <li>Informa\u021bii despre olimpiada de informatic\u0103</li> <li>List\u0103 de concursuri relevante</li> <li>Programa pentru gimnaziu</li> <li>Programa pentru liceu</li> </ul>","tags":["meta","sfaturi","pas cu pas"]},{"location":"usor/roadmap/#strategie-sfaturi-utile-pentru-olimpiade-si-concursuri","title":"Strategie, sfaturi utile pentru olimpiade \u0219i concursuri","text":"<ul> <li>Cum te preg\u0103te\u0219ti pentru olimpiad\u0103?</li> <li>Abordarea concursurilor de pe Codeforces/AtCoder</li> <li>Cum ajungi tot mai bun la concursuri?</li> <li>Cum abordezi proba de concurs la   olimpiad\u0103?</li> <li>Cum ajungi s\u0103 iei rezultate tot mai bune la   olimpiad\u0103?</li> <li>Cum gestionezi presiunea concursurilor?</li> </ul>","tags":["meta","sfaturi","pas cu pas"]},{"location":"usor/roadmap/#capitolul-1-notiuni-elementare-de-limbaj-algoritmi-elementari","title":"Capitolul 1 - No\u021biuni elementare de limbaj, algoritmi elementari","text":"<p>Aceast\u0103 sec\u021biune \u00ee\u0219i propune s\u0103 v\u0103 duc\u0103 de la baze \u0219i s\u0103 pute\u021bi ajunge s\u0103 rezolva\u021bi probleme u\u0219oare, precum \u0219i s\u0103 v\u0103 familiariza\u021bi cu algoritmica, limbajul C++ \u0219i \u00een general, tehnici de baz\u0103 de rezolvare a problemelor.</p> <p>Sec\u021biune special\u0103</p> <p>Aceste no\u021biuni de baz\u0103 sunt discutate \u0219i aici, dar vom relua discu\u021bia \u0219i mai jos.</p>","tags":["meta","sfaturi","pas cu pas"]},{"location":"usor/roadmap/#cum-inveti-materia","title":"Cum \u00eenve\u021bi materia?","text":"<ul> <li>De unde \u00eencepi?</li> <li>Cum ajungi s\u0103 st\u0103p\u00e2ne\u0219ti materia de la clas\u0103?</li> <li>Cum s\u0103 te preg\u0103te\u0219ti pentru bacalaureat \u0219i   admitere?</li> </ul>","tags":["meta","sfaturi","pas cu pas"]},{"location":"usor/roadmap/#fundamentele-limbajului-c","title":"Fundamentele limbajului C++","text":"<ul> <li>Instalarea primului editor/IDE</li> <li>Primul program \u00een C++</li> <li>Variabile \u0219i tipuri de date simple</li> <li>Operatori \u0219i expresii. Cuno\u0219tin\u021be matematice de   baz\u0103</li> <li>Citirea \u0219i afi\u0219area datelor</li> <li>Coding Style</li> </ul>","tags":["meta","sfaturi","pas cu pas"]},{"location":"usor/roadmap/#structuri-alternative-si-repetitive","title":"Structuri alternative \u0219i repetitive","text":"<ul> <li>Structura alternativ\u0103</li> <li>Structura repetitiv\u0103</li> <li>Prelucrarea cifrelor unui num\u0103r</li> <li>Maxime \u0219i minime</li> <li>Generarea \u0219irurilor de numere</li> </ul>","tags":["meta","sfaturi","pas cu pas"]},{"location":"usor/roadmap/#algoritmi-elementari","title":"Algoritmi elementari","text":"<ul> <li>Divizibilitatea (CMMDC, CMMMC, aflarea divizorilor)</li> <li>Abordarea problemelor cu secven\u021be</li> </ul>","tags":["meta","sfaturi","pas cu pas"]},{"location":"usor/roadmap/#capitolul-2-tablouri-tehnici-introductive","title":"Capitolul 2 - Tablouri, tehnici introductive","text":"<p>Aici trecem la ni\u0219te con\u021binuturi mai avansate, cunoa\u0219terea tablourilor \u0219i a unor metode de baz\u0103 inspirate din aritmetic\u0103 \u0219i algebr\u0103 devine necesar\u0103 pentru a putea trece la no\u021biuni mai specifice.</p>","tags":["meta","sfaturi","pas cu pas"]},{"location":"usor/roadmap/#lucrul-cu-tablouri","title":"Lucrul cu tablouri","text":"<ul> <li>Vectori (tablouri unidimensionale)</li> <li>Vectori de frecven\u021b\u0103</li> <li>Matrici (tablouri bidimensionale)</li> </ul>","tags":["meta","sfaturi","pas cu pas"]},{"location":"usor/roadmap/#algoritmi-si-tehnici-introductive","title":"Algoritmi \u0219i tehnici introductive","text":"<ul> <li>Complexit\u0103\u021bi</li> <li>Simularea solu\u021biei</li> <li>Algoritmi de sortare - Doar algoritmii \u00een \\(\\mathcal{O}(n^2)\\) \u0219i   func\u021bia std::sort</li> <li>Ciurul lui Eratostene</li> <li>Sume par\u021biale - Doar sumele par\u021biale</li> <li>Cum repari o solu\u021bie gre\u0219it\u0103? - sfaturile ini\u021biale</li> </ul>","tags":["meta","sfaturi","pas cu pas"]},{"location":"usor/roadmap/#capitolul-3-sortare-cautare-tehnici-mai-avansate-de-limbaj","title":"Capitolul 3 - Sortare, c\u0103utare, tehnici mai avansate de limbaj","text":"<p>Dac\u0103 a\u021bi ajuns aici, \u00eenseamn\u0103 c\u0103 ave\u021bi o baz\u0103 relativ solid\u0103 \u0219i pute\u021bi s\u0103 \u00eenv\u0103\u021ba\u021bi \u0219i alte metode care ajung s\u0103 fie un fundament pentru multe concursuri de algoritmic\u0103. Fie c\u0103 este vorba de algoritmi deprin\u0219i din cei pentru sort\u0103ri \u0219i c\u0103ut\u0103ri sau chiar de no\u021biuni matematice mai avansate, aici sunt algoritmii pe care \u00eei ve\u021bi folosi \u00een multe situa\u021bii \u0219i drept pa\u0219i mai mici pentru alte metode mai avansate.</p>","tags":["meta","sfaturi","pas cu pas"]},{"location":"usor/roadmap/#tehnici-de-limbaj","title":"Tehnici de limbaj","text":"<ul> <li>Subprograme</li> <li>Introducere \u00een STL</li> <li>\u0218iruri de caractere</li> <li>Opera\u021bii pe bi\u021bi</li> </ul>","tags":["meta","sfaturi","pas cu pas"]},{"location":"usor/roadmap/#algoritmi-si-metode-de-rezolvare-a-problemelor","title":"Algoritmi \u0219i metode de rezolvare a problemelor","text":"<ul> <li>Introducere \u00een Metoda Greedy</li> <li>C\u0103utarea binar\u0103</li> <li>\u0218menul lui Mars</li> <li>Two Pointers</li> <li>Sliding Window</li> </ul>","tags":["meta","sfaturi","pas cu pas"]},{"location":"usor/roadmap/#notiuni-de-algebra","title":"No\u021biuni de algebr\u0103","text":"<ul> <li>Principiul lui Dirichlet (principiul cutiei)</li> <li>Baze de numera\u021bie</li> <li>Indicatorul lui Euler</li> <li>Aritmetic\u0103 modular\u0103. Ridicare la putere \u00een timp   logaritmic</li> </ul>","tags":["meta","sfaturi","pas cu pas"]},{"location":"usor/roadmap/#capitolul-4-structuri-de-date-liniare-fundamentele-tehnicilor-avansate","title":"Capitolul 4 - Structuri de date liniare, fundamentele tehnicilor avansate","text":"<p>\u00cen aceast\u0103 sec\u021biune vom \u00eencepe s\u0103 rafin\u0103m lucrurile folosind structuri de date liniare, precum coada, stiva \u0219i deque-ul, dar \u0219i s\u0103 introducem tehnici mai avansate, precum teoria grafurilor \u0219i programarea dinamic\u0103. Continu\u0103m \u0219i parcurgerea no\u021biunilor matematice.</p>","tags":["meta","sfaturi","pas cu pas"]},{"location":"usor/roadmap/#elemente-de-implementare","title":"Elemente de implementare","text":"<ul> <li>Cum repari o solu\u021bie gre\u0219it\u0103? - generarea testelor</li> <li>Tehnica divide et impera</li> <li>C\u0103utare complet\u0103. Tehnica Backtracking</li> <li>Algoritmi de sortare - Restul algoritmilor de sortare</li> <li>Numere mari</li> <li>Normalizarea datelor</li> </ul>","tags":["meta","sfaturi","pas cu pas"]},{"location":"usor/roadmap/#matematica","title":"Matematic\u0103","text":"<ul> <li>Principiul includerii \u0219i excluderii</li> <li>Invers modular</li> </ul>","tags":["meta","sfaturi","pas cu pas"]},{"location":"usor/roadmap/#structuri-de-date","title":"Structuri de date","text":"<ul> <li>Coada</li> <li>Stiva</li> <li>Analiza amortizat\u0103</li> <li>Algoritmul lui Lee. Flood Fill</li> <li>Evaluarea unei expresii</li> <li>Deque</li> </ul>","tags":["meta","sfaturi","pas cu pas"]},{"location":"usor/roadmap/#abordarea-anumitor-tipuri-de-probleme-mai-speciale","title":"Abordarea anumitor tipuri de probleme mai speciale","text":"<ul> <li>Abordarea problemelor ad-hoc</li> <li>Abordarea problemelor constructive</li> </ul>","tags":["meta","sfaturi","pas cu pas"]},{"location":"usor/roadmap/#introducere-in-tehnici-mai-avansate","title":"Introducere \u00een tehnici mai avansate","text":"<ul> <li>Introducere \u00een teoria grafurilor</li> <li>Introducere \u00een arbori. Diametrul unui arbore</li> <li>Introducere \u00een programarea dinamic\u0103</li> </ul>","tags":["meta","sfaturi","pas cu pas"]},{"location":"usor/roadmap/#capitolul-5-programarea-dinamica-i-teoria-grafurilor-i-combinatorica-si-geometrie","title":"Capitolul 5 - Programarea dinamic\u0103 (I), teoria grafurilor (I), combinatoric\u0103 \u0219i geometrie","text":"<p>Aici intr\u0103m \u00eencet-\u00eencet \u00een complexitatea a dou\u0103 dintre cele mai importante tehnici din algoritmic\u0103, programarea dinamic\u0103 \u0219i teoria grafurilor. De asemenea, combinatorica \u0219i geometria sunt \u0219i ele abordate, exist\u00e2nd multe probleme care folosesc aceste tehnici.</p>","tags":["meta","sfaturi","pas cu pas"]},{"location":"usor/roadmap/#programarea-dinamica","title":"Programarea dinamic\u0103","text":"<ul> <li>Problema rucsacului</li> <li>Sub\u0219ir comun maximal</li> <li>Sub\u0219ir cresc\u0103tor maximal</li> <li>Dinamic\u0103 pe st\u0103ri exponen\u021biale (bitmask DP)</li> </ul>","tags":["meta","sfaturi","pas cu pas"]},{"location":"usor/roadmap/#teoria-grafurilor","title":"Teoria grafurilor","text":"<ul> <li>Sortare topologic\u0103</li> <li>Cicluri \u00een grafuri. Grafuri func\u021bionale</li> <li>P\u0103duri de mul\u021bimi disjuncte (DSU)</li> <li>Arbore par\u021bial de cost minim (Kruskal, Prim, Boruvka)</li> <li>Algoritmi pentru drumuri minime (Dijkstra, Bellman-Ford,   Floyd-Warshall)</li> <li>Tehnica celor 2 DFS-uri (rerooting)</li> </ul>","tags":["meta","sfaturi","pas cu pas"]},{"location":"usor/roadmap/#matematica_1","title":"Matematic\u0103","text":"<ul> <li>Combinatoric\u0103</li> <li>Concepte fundamentale de geometrie</li> </ul>","tags":["meta","sfaturi","pas cu pas"]},{"location":"usor/roadmap/#alte-notiuni","title":"Alte no\u021biuni","text":"<ul> <li>Hashing</li> <li>Meet in the Middle</li> </ul>","tags":["meta","sfaturi","pas cu pas"]},{"location":"usor/roadmap/#capitolul-6-structuri-de-date-lucrul-cu-arbori-probleme-speciale","title":"Capitolul 6 - Structuri de date, lucrul cu arbori, probleme speciale","text":"<p>Aici \u00eencepem s\u0103 lucr\u0103m cu structurile de date care ne ajut\u0103 s\u0103 r\u0103spundem la \u00eentreb\u0103ri \u0219i s\u0103 efectu\u0103m actualiz\u0103ri \u00eentr-un timp rapid. De asemenea, lucr\u0103m \u00een moduri mai detaliate cu arbori \u0219i grafuri, dar \u0219i cu alte tipuri de probleme pe care le \u00eent\u00e2lni\u021bi la concursuri.</p>","tags":["meta","sfaturi","pas cu pas"]},{"location":"usor/roadmap/#structuri-de-date_1","title":"Structuri de date","text":"<ul> <li>Descompuneri \u00een buc\u0103\u021bi de radical (Square Root   Decomposition)</li> <li>Arbori de intervale</li> <li>Arbori indexa\u021bi binar</li> <li>Range Minimum Query (RMQ)</li> <li>Trie</li> <li>Dinamici pe structuri de date</li> <li>Baleiere (sweep line)</li> </ul>","tags":["meta","sfaturi","pas cu pas"]},{"location":"usor/roadmap/#lucrul-cu-arbori","title":"Lucrul cu arbori","text":"<ul> <li>Binary lifting. Lowest common ancestor   (LCA)</li> <li>Euler Tour</li> <li>Dinamici pe arbori</li> <li>Small to large</li> <li>Heavy Light Decomposition</li> <li>Centroid Decomposition</li> </ul>","tags":["meta","sfaturi","pas cu pas"]},{"location":"usor/roadmap/#abordarea-anumitor-tipuri-de-probleme-mai-speciale_1","title":"Abordarea anumitor tipuri de probleme mai speciale","text":"<ul> <li>Abordarea problemelor interactive</li> <li>Abordarea problemelor output-only</li> </ul>","tags":["meta","sfaturi","pas cu pas"]},{"location":"usor/roadmap/#alte-tehnici","title":"Alte tehnici","text":"<ul> <li>Bitsets</li> <li>C\u0103utare ternar\u0103</li> <li>Algoritmi randomizati</li> <li>Func\u021bia M\u00f6bius</li> </ul>","tags":["meta","sfaturi","pas cu pas"]},{"location":"usor/roadmap/#capitolul-7-programare-dinamica-ii-teoria-grafurilor-ii-matematica","title":"Capitolul 7 - Programare dinamic\u0103 (II), Teoria grafurilor (II), Matematic\u0103","text":"<p>Continu\u0103m munca de la capitolul 5 cu adapt\u0103ri mai avansate ale metodelor men\u021bionate acolo, experien\u021ba devenind tot mai important\u0103.</p>","tags":["meta","sfaturi","pas cu pas"]},{"location":"usor/roadmap/#programarea-dinamica_1","title":"Programarea dinamic\u0103","text":"<ul> <li>Programare dinamic\u0103 pe intervale (range DP)</li> <li>Programare dinamic\u0103 pe cifre (digit DP)</li> <li>Programare dinamic\u0103 pe grafuri</li> <li>Programare dinamic\u0103 pe permut\u0103ri</li> </ul>","tags":["meta","sfaturi","pas cu pas"]},{"location":"usor/roadmap/#teoria-grafurilor_1","title":"Teoria grafurilor","text":"<ul> <li>Componente tare conexe</li> <li>Componente biconexe</li> <li>Cuplaj maxim pe graf bipartit</li> </ul>","tags":["meta","sfaturi","pas cu pas"]},{"location":"usor/roadmap/#algebra","title":"Algebr\u0103","text":"<ul> <li>Introducere \u00een probabilit\u0103\u021bi</li> <li>Introducere \u00een algebr\u0103 liniar\u0103</li> <li>Ridicare la putere a unei matrici</li> <li>Algoritmul lui Gauss</li> </ul>","tags":["meta","sfaturi","pas cu pas"]},{"location":"usor/roadmap/#geometrie","title":"Geometrie","text":"<ul> <li>Baleiere (sweep line)</li> <li>\u00cenf\u0103\u0219ur\u0103toare convex\u0103</li> </ul>","tags":["meta","sfaturi","pas cu pas"]},{"location":"usor/roadmap/#capitolul-8-matematica-avansata-algoritmi-pe-stringuri","title":"Capitolul 8 - Matematic\u0103 avansat\u0103, algoritmi pe stringuri","text":"<p>Aici intr\u0103m deja \u00een algoritmi \u0219i tehnici de o complexitate foarte ridicat\u0103, ace\u0219tia trebuie s\u0103 fie \u0219tiu\u021bi de cei care vor s\u0103 ajung\u0103 la cel mai \u00eenalt nivel.</p>","tags":["meta","sfaturi","pas cu pas"]},{"location":"usor/roadmap/#matematica-avansata","title":"Matematic\u0103 avansat\u0103","text":"<ul> <li>Coduri Gray</li> <li>Codarea Huffman</li> <li>Teoria jocurilor</li> </ul>","tags":["meta","sfaturi","pas cu pas"]},{"location":"usor/roadmap/#algoritmi-pe-stringuri","title":"Algoritmi pe stringuri","text":"<ul> <li>Rota\u021bie lexicografic\u0103 minim\u0103</li> <li>Hashing</li> <li>Knuth-Morris-Pratt (KMP)</li> <li>Z Function</li> <li>Algoritmul lui Manacher</li> <li>Suffix array/tree</li> </ul>","tags":["meta","sfaturi","pas cu pas"]},{"location":"usor/roadmap/#capitolul-9-structuri-de-date-avansate-dp-optimizations-algoritmi-avansati-pe-grafuri-matematica","title":"Capitolul 9 - Structuri de date avansate, DP Optimizations, Algoritmi avansa\u021bi pe grafuri, matematic\u0103","text":"<p>Acest capitol este unul open-ended, put\u00e2nd fi denumit mai informal drept restul algoritmicii, deoarece aici, pe l\u00e2ng\u0103 con\u021binuturile men\u021bionate, orice alt con\u021binut pe care \u00eel considera\u021bi c\u0103 trebuie abordat, \u00eel pute\u021bi aborda.</p> <p>Pe l\u00e2ng\u0103 aceste con\u021binuturi men\u021bionate aici, orice altceva ce vre\u021bi s\u0103 \u00eenv\u0103\u021ba\u021bi ar trebui \u00eenv\u0103\u021bat dup\u0103 ce v\u0103 asigura\u021bi c\u0103 st\u0103p\u00e2ni\u021bi algoritmii men\u021biona\u021bi anterior. \u00cen mod evident, exist\u0103 anumite excep\u021bii, dar dac\u0103 a\u021bi ajuns la acest nivel, probabil c\u0103 \u0219ti\u021bi \u0219i voi cum s\u0103 ajusta\u021bi anumite lucruri \u00een func\u021bie de ce observa\u021bi \u00een studiul vostru individual.</p>","tags":["meta","sfaturi","pas cu pas"]},{"location":"usor/roadmap/#structuri-de-date_2","title":"Structuri de date","text":"<ul> <li>Virtual Tree</li> <li>Persistent Segment   Tree</li> <li>Li Chao Tree</li> <li>Aho-Corasick</li> <li>Treapuri</li> </ul>","tags":["meta","sfaturi","pas cu pas"]},{"location":"usor/roadmap/#optimizari-specifice-programarii-dinamice","title":"Optimiz\u0103ri specifice program\u0103rii dinamice","text":"<ul> <li>Convex Hull Trick</li> <li>Divide and Conquer DP</li> <li>Aliens DP</li> <li>Knuth DP</li> <li>Connected Component DP</li> </ul>","tags":["meta","sfaturi","pas cu pas"]},{"location":"usor/roadmap/#algoritmica-avansata-pe-grafuri","title":"Algoritmic\u0103 avansat\u0103 pe grafuri","text":"<ul> <li>Fluxuri maxime</li> <li>Dynamic connectivity</li> <li>2-SAT</li> </ul>","tags":["meta","sfaturi","pas cu pas"]},{"location":"usor/roadmap/#matematica_2","title":"Matematic\u0103","text":"<ul> <li>Run-length encoding</li> <li>Teorema chinez\u0103 a resturilor (CRT)</li> <li>Recuren\u021be liniare</li> <li>Func\u021bii generatoare</li> <li>FFT, NTT</li> <li>Matematic\u0103 avansat\u0103</li> </ul>","tags":["meta","sfaturi","pas cu pas"]},{"location":"usor/roadmap/#concluzii","title":"Concluzii","text":"<p>St\u0103p\u00e2nirea no\u021biunilor \u00eentr-o ordine clar\u0103 care s\u0103 permit\u0103 \u00een\u021belegerea tuturor capitolelor cu u\u0219urin\u021b\u0103 este esen\u021bial\u0103 pentru orice competitor care vrea s\u0103 ajung\u0103 c\u00e2t mai bun, iar odat\u0103 cu aceast\u0103 resurs\u0103, avem prima structur\u0103 complet\u0103 \u00een limba rom\u00e2n\u0103 a unui asemenea roadmap care face \u00eenv\u0103\u021barea algoritmilor \u0219i structurilor de date mult mai u\u0219oar\u0103 chiar \u0219i dac\u0103 nu ave\u021bi un profesor \u00eendrum\u0103tor sau altcineva care s\u0103 v\u0103 ajute s\u0103 ave\u021bi o ordine logic\u0103 \u00een \u00eenv\u0103\u021bare.</p> <p>Ca \u00eentotdeauna, v\u0103 st\u0103m la dispozi\u021bie pe serverul nostru \u00een cazul \u00een care ave\u021bi sugestii de orice fel \u0219i/sau considera\u021bi c\u0103 anumite no\u021biuni merit\u0103 ajustate.</p>","tags":["meta","sfaturi","pas cu pas"]},{"location":"usor/roadmap/#resurse-suplimentare","title":"Resurse suplimentare","text":"<ul> <li>Competitive programming roadmap -   Codeforces</li> <li>Competitive programming roadmap -   Codechef</li> <li>Structura USACO Guide</li> </ul>","tags":["meta","sfaturi","pas cu pas"]},{"location":"usor/schoolwork/","title":"Cum ajungi s\u0103 st\u0103p\u00e2ne\u0219ti materia de la clas\u0103?","text":"","tags":["meta","sfaturi"]},{"location":"usor/schoolwork/#introducere","title":"Introducere","text":"<p>Pentru a putea ajunge s\u0103 fii c\u00e2t mai bun la informatic\u0103, trebuie s\u0103 \u00eencepi mai \u00eent\u00e2i cu con\u021binuturile cele mai u\u0219oare, iar pentru cei mai mul\u021bi dintre voi, primul contact cu algoritmica este prin intermediul orelor de informatic\u0103 de la \u0219coal\u0103 sau de la alte cluburi de acest fel.</p> <p>Deoarece \u00eenceputul este foarte important, aici vom prezenta c\u00e2teva dintre cele mai importante lucruri pe care s\u0103 le ai \u00een vedere pentru a putea avea un start c\u00e2t mai bun \u00een parcursul t\u0103u.</p> <p>Acest articol se adreseaz\u0103 \u0219i celor dintre voi care poate s-au apucat mai t\u00e2rziu de studiul serios al informaticii \u0219i vor s\u0103 recupereze materia, iar mai apoi s\u0103 \u00eenve\u021be con\u021binuturi \u00een plus pentru examene \u0219i admiteri (sau de ce nu, olimpiad\u0103).</p>","tags":["meta","sfaturi"]},{"location":"usor/schoolwork/#cunostinte-matematice","title":"Cuno\u0219tin\u021be matematice","text":"<p>Pentru a fi un programator bun, este necesar s\u0103 ai o baz\u0103 de cuno\u0219tin\u021be matematice care s\u0103 te ajute s\u0103 \u00een\u021belegi anumite rela\u021bii \u0219i concepte algoritmice. A\u0219a cum s-a mai men\u021bionat \u0219i \u00een alte articole, nu este necesar s\u0103 fii expert \u00een matematic\u0103, dar cuno\u0219tin\u021bele de la clas\u0103 trebuie st\u0103p\u00e2nite foarte bine, mai ales aritmetica \u0219i algebra.</p> <p>Dac\u0103 acest lucru a reprezentat pentru tine o problem\u0103, recomand\u0103m s\u0103 recapitulezi no\u021biunile matematice, cele mai importante pentru scopul acestei arhive \u0219i a materiei de la informatic\u0103 le po\u021bi g\u0103si \u00een articolele noastre despre no\u021biuni introductive, precum \u0219i cel despre divizibilitate.</p>","tags":["meta","sfaturi"]},{"location":"usor/schoolwork/#intelegerea-primelor-lectii","title":"\u00cen\u021belegerea primelor lec\u021bii","text":"<p>Din experien\u021ba urm\u0103ririi elevilor pe care i-am \u00eent\u00e2lnit de-a lungul timpului, am observat faptul c\u0103 elevii care sunt aten\u021bi \u0219i exerseaz\u0103 \u00een timpul primelor c\u00e2teva lec\u021bii vor ajunge s\u0103 st\u0103p\u00e2neasc\u0103 celelalte no\u021biuni cu o mai mare u\u0219urin\u021b\u0103.</p> <p>\u00cen general, este important s\u0103 face\u021bi teme \u0219i eventual s\u0103 lucra\u021bi suplimentar mai ales atunci c\u00e2nd \u00eencepe\u021bi s\u0103 \u00een\u021belege\u021bi programarea, \u0219i mai ales s\u0103 accesa\u021bi resursele pe care le punem la dispozi\u021bie, urm\u0103rind primele niveluri ale roadmapului nostru.</p>","tags":["meta","sfaturi"]},{"location":"usor/schoolwork/#pune-cat-mai-multe-intrebari","title":"Pune c\u00e2t mai multe \u00eentreb\u0103ri","text":"<p>Fie c\u0103 e\u0219ti la \u00eenceput sau vrei s\u0103 devii mai bun la informatic\u0103, oric\u00e2nd exist\u0103 un motiv bun pentru a pune c\u00e2t mai multe \u00eentreb\u0103ri. Fie c\u0103 \u00ee\u021bi \u00eentrebi colegii, profesorii sau pe cei de pe serverul nostru, nu ezita s\u0103 o faci, deoarece a\u0219a vei afla mai multe \u0219i \u021bi se va st\u00e2rni curiozitatea s\u0103 ajungi s\u0103 cuno\u0219ti mai multe \u0219i s\u0103 devii astfel tot mai bun.</p>","tags":["meta","sfaturi"]},{"location":"usor/schoolwork/#de-unde-sa-lucrezi","title":"De unde s\u0103 lucrezi?","text":"<p>\u00cen primul r\u00e2nd, recomand\u0103m pbinfo drept o resurs\u0103 foarte bun\u0103 pentru lucratul de probleme u\u0219oare, fiind o baz\u0103 foarte bun\u0103 pentru acest scop. De asemenea, urm\u0103rind articolele noastre, pute\u021bi g\u0103si multe alte probleme u\u0219oare pe care s\u0103 le pute\u021bi rezolva, \u00eembun\u0103t\u0103\u021bindu-v\u0103 nivelul treptat.</p> <p>Cu to\u021bii am fost \u00eencep\u0103tori la un moment dat, a\u0219a c\u0103 pentru a atinge un nivel foarte bun, trebuie s\u0103 munci\u021bi treptat \u0219i constant, iar \u00een timp, acest lucru se va realiza.</p> <p>Dup\u0103 ce deveni\u021bi ceva mai buni, pute\u021bi \u00eencerca s\u0103 lucra\u021bi \u0219i de pe Kilonova problemele mai u\u0219oare de acolo, iar treptat s\u0103 aborda\u021bi subiecte tot mai grele, chiar \u0219i peste nivelul clasei.</p>","tags":["meta","sfaturi"]},{"location":"usor/schoolwork/#concluzii","title":"Concluzii","text":"<p>Chiar dac\u0103 aceasta este o etap\u0103 de \u00eenceput, trebuie luat\u0103 foarte \u00een serios deoarece secretul succesului este acela de a \u00eencepe cu pa\u0219i m\u0103run\u021bi, dar siguri, iar problemele introductive \u0219i articolele de aici v\u0103 vor ajuta, fie c\u0103 este vorba de prima voastr\u0103 \u00eent\u00e2lnire cu un limbaj de programare sau vre\u021bi s\u0103 recupera\u021bi materia pe care nu a\u021bi \u00eenv\u0103\u021bat-o la timp.</p>","tags":["meta","sfaturi"]},{"location":"usor/sequences/","title":"Abordarea problemelor cu secven\u021be","text":"<p>\u00cen algoritmic\u0103, dar \u0219i \u00een alte domenii, suntem nevoi\u021bi de multe ori s\u0103 lucr\u0103m cu secven\u021be de valori \u0219i se impune folosirea unor abord\u0103ri specifice pentru a rezolva aceste probleme. Fie c\u0103 este vorba de probleme ce apar \u00een examenele na\u021bionale sau la concursurile de informatic\u0103, algoritmii ce prelucreaz\u0103 secven\u021be de valori se dovedesc a fi foarte importan\u021bi \u0219i cunoa\u0219terea lor, precum \u0219i a tehnicilor de rezolvare a acestor probleme devine esen\u021bial\u0103.</p>","tags":["secvente","sortare","ad-hoc"]},{"location":"usor/sequences/#notiuni-introductive","title":"No\u021biuni introductive","text":"<p>Defini\u021bie</p> <p>O secven\u021b\u0103 reprezint\u0103 un \u0219ir de valori, de regul\u0103 dispuse consecutiv \u00eentr-un \u0219ir mai mare sau poate reprezenta chiar un \u0219ir de sine st\u0103t\u0103tor.</p> <p>Exemplu</p> <p>\u00cen vectorul 30, 32, 19, 8, 11, 6, putem spune urm\u0103toarele lucruri:</p> <ul> <li>\\(19, 8, 11\\) este o secven\u021b\u0103 care \u00eencepe de la pozi\u021bia 3 \u0219i se termin\u0103 la   pozi\u021bia 5 a \u0219irului ini\u021bial</li> <li>\\(30, 19, 11\\) nu este o secven\u021b\u0103 a \u0219irului de mai sus (\u00een schimb, este un   sub\u0219ir, no\u021biune pe care o vom discuta \u00een articolele ulterioare)</li> </ul> <p>Observa\u021bie</p> <p>\u00cen diverse contexte, secven\u021be precum \\(19, 8, 11\\) sunt numite \u0219i subsecven\u021be, deoarece sunt ob\u021binute prin eliminarea de valori de la \u00eenceputul \u0219i sf\u00e2r\u0219itul secven\u021bei de mai sus.</p> <p>Pentru a prelucra aceste secven\u021be \u0219i subsecven\u021be, o prim\u0103 solu\u021bie const\u0103 \u00een p\u0103strarea valorilor \u00een memorie folosind vectori, iar mai apoi, \u00een func\u021bie de ce cere problema, s\u0103 parcurgem toate variantele de a crea subsecven\u021be \u00een \u0219irul dat, sau eventual s\u0103 verific\u0103m diverse propriet\u0103\u021bi, parcurg\u00e2nd valorile una c\u00e2te una.</p> <p>Observa\u021bie</p> <p>Num\u0103rul de subsecven\u021be ale unui \u0219ir cu lungimea \\(n\\) este \\(\\frac{n \\cdot (n+1)}{2}\\).</p> <p>Pentru a demonstra acest fapt, putem fixa pozi\u021bia de \u00eenceput a unei subsecven\u021be (s\u0103 zicem, \\(i\\)), iar pentru aceast\u0103 pozi\u021bie ini\u021bial\u0103, avem \\((n - i + 1)\\) variante pentru pozi\u021bia final\u0103 - toate pozi\u021biile \\(j\\) astfel \u00eenc\u00e2t \\(i \\leq j \\leq n\\). Astfel, avem \\(n + (n-1) + \\dots + 1 = \\frac{n \\cdot (n+1)}{2}\\).</p> <p>\u00cen cele ce urmeaz\u0103, vom ar\u0103ta diverse tehnici de rezolvare a unor probleme introductive care cuprind secven\u021be, iar mai apoi, vom prezenta \u0219i unul din algoritmii pentru subsecven\u021ba de sum\u0103 maxim\u0103.</p>","tags":["secvente","sortare","ad-hoc"]},{"location":"usor/sequences/#probleme-in-care-trebuie-sa-aflam-o-secventa-de-lungime-maxima","title":"Probleme \u00een care trebuie s\u0103 afl\u0103m o secven\u021b\u0103 de lungime maxim\u0103","text":"<p>O problem\u0103 care apare frecvent este urm\u0103toarea:</p> <p>Fie \\(X\\) un vector cu elemente de un anumit tip. S\u0103 se determine cea mai lung\u0103 secven\u021b\u0103 din vector \u00een care toate elementele au o anumit\u0103 proprietate (sunt pare, impare, prime, nule, ordonate cresc\u0103tor, egale etc.).</p> <p>Problema are mai multe solu\u021bii, cu complexit\u0103\u021bi diverse. \u00cen toate solu\u021biile vom determina \\(lenmax, stmax\\) \u0219i \\(drmax\\), \\(lenmax\\) fiind lungimea maxim\u0103 a secven\u021bei g\u0103site, \\(stmax\\) fiind cap\u0103tul din st\u00e2nga al \u0219irului g\u0103sit, \\(drmax\\) fiind cap\u0103tul din dreapta al \u0219irului g\u0103sit. Ini\u021bial, putem ini\u021bializa \\(lenmax\\) cu 0, \\(stmax\\) \u0219i \\(drmax\\) cu \\(-1\\) pentru a marca faptul c\u0103 nu am g\u0103sit \u00eenc\u0103 nicio secven\u021b\u0103 cu condi\u021biile cerute.</p> <p>Pentru exemplele de mai jos, vom afla lungimea celei mai lungi secven\u021be \u00een care toate valorile sunt pare. Dac\u0103 exist\u0103 mai multe asemenea secven\u021be, o vom afla pe cea mai din st\u00e2nga.</p>","tags":["secvente","sortare","ad-hoc"]},{"location":"usor/sequences/#solutie-in-mathcalon3","title":"Solu\u021bie \u00een \\(\\mathcal{O}(n^3)\\)","text":"<p>Cea mai simpl\u0103 solu\u021bie la acest tip de probleme este aceea \u00een care fix\u0103m capetele secven\u021bei pe care o verific\u0103m, iar pentru fiecare secven\u021b\u0103, verific\u0103m fiecare valoare \u0219i asta ne va ajuta s\u0103 decidem dac\u0103 proprietatea este respectat\u0103.</p> <pre><code>int lenmax = 0, stmax = -1, drmax = -1;\nfor (int i = 1; i &lt;= n; i++) {\n    for (int j = i; j &lt;= n; j++) {\n        int ok = 1;  // daca secventa este buna\n        for (int poz = i; poz &lt;= j; poz++) {\n            if (v[poz] % 2 != 0) {\n                ok = 0;  // avem numar impar, deci secventa nu este buna\n            }\n        }\n        if (ok == 1 &amp;&amp; j - i + 1 &gt; lenmax) {\n            lenmax = j - i + 1;\n            stmax = i;\n            drmax = j;\n        }\n    }\n}\ncout &lt;&lt; lenmax &lt;&lt; \" \" &lt;&lt; stmax &lt;&lt; \" \" &lt;&lt; drmax &lt;&lt; '\\n';\n</code></pre> <p>Chiar dac\u0103 aceast\u0103 solu\u021bie este tot \\(\\mathcal{O}(n^3)\\), \u00een multe cazuri se va dovedi mai rapid\u0103 \u00een practic\u0103, deoarece iter\u00e2nd \u00een ordine descresc\u0103toare dup\u0103 lungime, dac\u0103 g\u0103sim o secven\u021b\u0103 cu proprietatea dorit\u0103, atunci ne putem opri.</p> <pre><code>int lenmax = 0, stmax = -1, drmax = -1;\nfor (int len = n; len &gt;= 1; len--) {\n    for (int i = 1; i + len - 1 &lt;= n; i++) {\n        int j = i + len - 1;\n        int ok = 1;  // daca secventa este buna\n        for (int poz = i; poz &lt;= j; poz++) {\n            if (v[poz] % 2 != 0) {\n                ok = 0;  // avem numar impar, deci secventa nu este buna\n            }\n        }\n        if (ok == 1 &amp;&amp; j - i + 1 &gt; lenmax) {\n            lenmax = j - i + 1;\n            stmax = i;\n            drmax = j;\n            // aceste linii de mai jos opresc toate structurile repetitive,\n            // break oprind doar cea mai apropiata structura repetitiva\n            i = n;\n            len = 0;\n        }\n    }\n}\ncout &lt;&lt; lenmax &lt;&lt; \" \" &lt;&lt; stmax \" \" &lt;&lt; drmax &lt;&lt; '\\n';\n</code></pre>","tags":["secvente","sortare","ad-hoc"]},{"location":"usor/sequences/#solutie-in-mathcalon2","title":"Solu\u021bie \u00een \\(\\mathcal{O}(n^2)\\)","text":"<p>O \u00eembun\u0103t\u0103\u021bire pe care o putem face la algoritmul precedent este aceea c\u0103 dac\u0103 am verificat deja secven\u021ba \\([i, j]\\), pentru a trece la secven\u021ba \\([i, j+1]\\) trebuie doar s\u0103 verific\u0103m pozi\u021bia \\(j-1\\), f\u0103r\u0103 a mai fi necesar\u0103 verificarea din nou a tuturor pozi\u021biilor \u00een intervalul \\([i, j]\\). Deoarece acum va fi nevoie de doar dou\u0103 foruri pentru a verifica toate secven\u021bele, complexitatea va deveni \\(\\mathcal{O}(n^2)\\).</p> <pre><code>int lenmax = 0, stmax = -1, drmax = -1;\nfor (int i = 1; i &lt;= n; i++) {\n    int ok = 1;  // daca secventa este buna\n    for (int j = i; j &lt;= n; j++) {\n        if (v[j] % 2 != 0) {\n            ok = 0;  // avem numar impar, deci secventa nu este buna\n        }\n        if (ok == 1 &amp;&amp; j - i + 1 &gt; lenmax) {\n            lenmax = j - i + 1;\n            stmax = i;\n            drmax = j;\n        }\n    }\n}\ncout &lt;&lt; lenmax &lt;&lt; \" \" &lt;&lt; stmax \" \" &lt;&lt; drmax &lt;&lt; '\\n';\n</code></pre>","tags":["secvente","sortare","ad-hoc"]},{"location":"usor/sequences/#solutie-in-mathcalon","title":"Solu\u021bie \u00een \\(\\mathcal{O}(n)\\)","text":"<p>Totu\u0219i, putem rezolva aceast\u0103 problem\u0103 \u0219i mai eficient, deoarece dat fiind faptul c\u0103 valorile pe care le avem vor avea mereu acelea\u0219i propriet\u0103\u021bi, putem extinde secven\u021ba curent\u0103 at\u00e2ta timp c\u00e2t valorile respect\u0103 proprietatea cerut\u0103 (\u00een acest caz, paritatea), actualiz\u00e2nd r\u0103spunsul maxim la fiecare pas.</p> <pre><code>int lenmax = 0, stmax = -1, drmax = -1;\nint len = 0;\nfor (int i = 1; i &lt;= n; i++) {\n    if (v[i] % 2 == 0) {\n        len++;\n    } else {\n        len = 0;\n    }\n    if (len &gt; lenmax) {\n        lenmax = len;\n        drmax = i;\n        stmax = i - len + 1;\n    }\n}\ncout &lt;&lt; lenmax &lt;&lt; \" \" &lt;&lt; stmax \" \" &lt;&lt; drmax &lt;&lt; '\\n';\n</code></pre>","tags":["secvente","sortare","ad-hoc"]},{"location":"usor/sequences/#solutie-in-mathcalon-fara-vectori","title":"Solu\u021bie \u00een \\(\\mathcal{O}(n)\\) f\u0103r\u0103 vectori","text":"<p>\u00cen cazul unor probleme, \u00een special cele care se dau la examenul de bacalaureat, se cere g\u0103sirea unor solu\u021bii eficiente at\u00e2t din punct de vedere al timpului de execu\u021bie, c\u00e2t \u0219i al memoriei folosite. Deoarece am redus solu\u021bia la una liniar\u0103, \u00een care verific\u0103m o singur\u0103 dat\u0103 fiecare valoare, nu mai are niciun sens s\u0103 \u021binem \u00een memorie un vector \u00een care s\u0103 stoc\u0103m valorile, acestea put\u00e2nd fi citite la fiecare pas.</p> <pre><code>int lenmax = 0, stmax = -1, drmax = -1;\nint len = 0;\nfor (int i = 1; i &lt;= n; i++) {\n    int x;\n    cin &gt;&gt; x;\n    if (x % 2 == 0) {\n        len++;\n    } else {\n        len = 0;\n    }\n    if (len &gt; lenmax) {\n        lenmax = len;\n        drmax = i;\n        stmax = i - len + 1;\n    }\n}\ncout &lt;&lt; lenmax &lt;&lt; \" \" &lt;&lt; stmax \" \" &lt;&lt; drmax &lt;&lt; '\\n';\n</code></pre>","tags":["secvente","sortare","ad-hoc"]},{"location":"usor/sequences/#subsecventa-de-suma-maxima","title":"Subsecven\u021ba de sum\u0103 maxim\u0103","text":"<p>\u00cen unele probleme, trebuie s\u0103 afl\u0103m subsecven\u021ba de sum\u0103 maxim\u0103 a unui \u0219ir. Pentru a face acest lucru, vom putea modifica algoritmul prezentat mai sus, \u021bin\u00e2nd cont de o observa\u021bie foarte important\u0103, \u0219i anume faptul c\u0103 dac\u0103 avem de-a face cu o sum\u0103 negativ\u0103 la un moment dat, o putem ignora \u0219i reseta calculele, pentru a maximiza r\u0103spunsul. Acest algoritm este numit \u0219i algoritmul lui Kadane.</p> <pre><code>int summax = 0, stmax = -1, drmax = -1;\nint sum = 0, st = 0;\nfor (int i = 1; i &lt;= n; i++) {\n    int x;\n    cin &gt;&gt; x;\n    if (sum &lt; 0) {\n        sum = x;\n        st = i;\n    } else {\n        sum += x;\n    }\n    if (sum &gt; summax) {\n        summax = sum;\n        drmax = i;\n        stmax = st;\n    }\n}\ncout &lt;&lt; summax &lt;&lt; \" \" &lt;&lt; stmax \" \" &lt;&lt; drmax &lt;&lt; '\\n';\n</code></pre>","tags":["secvente","sortare","ad-hoc"]},{"location":"usor/sequences/#subsecventa-de-suma-maxima-pe-matrice","title":"Subsecven\u021ba de sum\u0103 maxim\u0103 pe matrice","text":"<p>Acest algoritm poate fi extins \u0219i pe matrice, observa\u021bia de baz\u0103 fiind aceea c\u0103 putem fixa linia de \u00eenceput \u0219i linia de final, iar mai apoi folosind sume par\u021biale, s\u0103 aplic\u0103m algoritmul de mai sus.</p> <p>Mai jos pute\u021bi g\u0103si solu\u021bia de la problema Submatrix SumMax de pe pbinfo.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\nint n, a[302][302], sp[302][302];\nint sum(int xa, int ya, int xb, int yb) {\n    return sp[xb][yb] - sp[xa - 1][yb] - sp[xb][ya - 1] + sp[xa - 1][ya - 1];\n}\nint main() {\n    cin &gt;&gt; n;\n    for (int i = 1; i &lt;= n; ++i) {\n        for (int j = 1; j &lt;= n; ++j) {\n            cin &gt;&gt; a[i][j];\n            sp[i][j] = sp[i - 1][j] + sp[i][j - 1] - sp[i - 1][j - 1] + a[i][j];\n        }\n    }\n    int ans = -1001;\n    for (int i = 1; i &lt;= n; ++i) {\n        for (int j = i; j &lt;= n; ++j) {\n            int ssm = 0;\n            for (int poz = 1; poz &lt;= n; ++poz) {\n                int sumCol = sum(i, poz, j, poz);\n                ssm = max(ssm + sumCol, sumCol);\n                if (ssm &gt; ans) {\n                    ans = ssm;\n                }\n            }\n        }\n    }\n    cout &lt;&lt; ans;\n    return 0;\n}\n</code></pre>","tags":["secvente","sortare","ad-hoc"]},{"location":"usor/sequences/#concluzii","title":"Concluzii","text":"<p>Dup\u0103 cum se poate observa, secven\u021bele \u0219i prelucrarea lor sunt o parte fundamental\u0103 \u0219i necesar\u0103 pentru abordarea unei plaje foarte largi de probleme, a\u0219a cum ve\u021bi putea vedea \u00een capitolele urm\u0103toare, \u00een special c\u00e2nd vine vorba de diverse cazuri particulare, algoritmi \u0219i metode de programare, aici putem enumera metoda celor doi pointeri, sliding window sau chiar \u0219i problemele \u00een care folosim metodele specifice structurilor de date. Implement\u0103rile precise \u0219i clare vor fi esen\u021biale pentru rezolvarea acestor probleme \u00een timp rapid \u0219i simplu.</p>","tags":["secvente","sortare","ad-hoc"]},{"location":"usor/sequences/#probleme-suplimentare","title":"Probleme suplimentare","text":"<ul> <li>Pbinfo - Verificarea unor   propriet\u0103\u021bi</li> <li>Pbinfo - Probleme cu   secven\u021be</li> <li>kilonova progres</li> <li>sss OJI 2022</li> <li>Trafalet OJI 2024</li> <li>Microbist OJI 2024</li> <li>Subsecven\u021b\u0103 de sum\u0103 maxim\u0103</li> <li>infoarena joctv</li> </ul>","tags":["secvente","sortare","ad-hoc"]},{"location":"usor/sequences/#lectura-suplimentara","title":"Lectur\u0103 suplimentar\u0103","text":"<ul> <li>Secven\u021be \u00een vectori</li> <li>Verificarea unor   propriet\u0103\u021bi</li> <li>Secven\u021be - CPPI Sync</li> <li>Secven\u021be -   Algopedia</li> <li>Secven\u021be partea II-   Algopedia</li> <li>Secven\u021ba de sum\u0103   maxim\u0103</li> <li>Subsecventa de suma maxima - Sebastian Popa</li> </ul>","tags":["secvente","sortare","ad-hoc"]},{"location":"usor/sieve/","title":"Ciurul lui Eratostene","text":"","tags":["matematica","numere prime","divizori","precalculari"]},{"location":"usor/sieve/#ce-este-ciurul-lui-eratostene","title":"Ce este ciurul lui Eratostene?","text":"<p>Ciurul lui Eratostene este o metod\u0103 eficient\u0103 de afla toate numerele prime \u00eentre 1 \u0219i \\(n\\), folosindu-ne de propriet\u0103\u021bile corespunz\u0103toare numerelor naturale, precum \u0219i de rela\u021biile dintre divizori \u0219i multipli. Pe l\u00e2ng\u0103 aplica\u021bia sa principal\u0103, se va dovedi a fi un algoritm foarte util pentru foarte multe tipuri de precalcul\u0103ri care sunt centrate \u00een jurul afl\u0103rii divizorilor sau a altor valori ce se calculeaz\u0103 \u00een func\u021bie de divizorii numerelor de la 1 la \\(n\\).</p> <p>Pentru a afla numerele prime de la 1 la \\(n\\), vom avea un algoritm simplu, care va lua la r\u00e2nd numerele de la 2 la \\(n\\) \u0219i pentru fiecare num\u0103r nemarcat de la 2 la \\(n\\), se vor marca to\u021bi multiplii acestuia. Astfel, numerele nemarcate sunt numerele prime, acestea nefiind marcate anterior de momentul acces\u0103rii lor, iar numerele marcate sunt numerele compuse. Se remarc\u0103 faptul c\u0103 1, nefiind num\u0103r prim, nu este luat \u00een considerare.</p> <p>S\u0103 exemplific\u0103m algoritmul pentru numerele de la 2 la 30. Voi descrie doar pa\u0219ii ce exemplific\u0103 ce se \u00eent\u00e2mpl\u0103 c\u00e2nd avem de-a face cu numere prime.</p> <ul> <li>La pasul \\(i = 2\\), 2 este marcat drept num\u0103r prim, iar acesta va marca   numerele pare de la 4 la 30 drept compuse \\((4, 6, 8, 10, 12, 14, 16, 18,   20\\), \\(22, 24, 26, 28, 30)\\).</li> <li>La pasul \\(i = 3\\), 3 este marcat drept num\u0103r prim, iar acesta va marca   numerele multiplu de 3 de la 6 la 30 drept compuse \\((6, 9, 12, 15, 18,   21, 24, 27, 30)\\).</li> <li>La pasul \\(i = 5\\), 5 este marcat drept num\u0103r prim, iar acesta va marca   numerele multiplu de 5 de la 10 la 30 drept compuse \\((10, 15, 20, 25,   30)\\).</li> <li>La pasul \\(i = 7\\), 7 este marcat drept num\u0103r prim, iar acesta va marca   numerele multiplu de 7 de la 14 la 30 drept compuse \\((14, 21, 28)\\).</li> <li>La pasul \\(i = 11\\), 11 este marcat drept num\u0103r prim, iar acesta va marca   numerele multiplu de 11 de la 22 la 30 drept compuse \\((22)\\).</li> <li>La pasul \\(i = 13\\), 13 este marcat drept num\u0103r prim, iar acesta va marca   numerele multiplu de 13 de la 26 la 30 drept compuse \\((26)\\).</li> <li>La pa\u0219ii \\(i = 17\\), \\(i = 23\\), \\(i = 29\\), 17, 23 \u0219i 29 sunt marca\u021bi drept   numere prime, dar multiplii lor mai mari ca ei sunt mai mari ca 30,   nemaifiind marca\u021bi drept numere compuse, chiar dac\u0103 sunt, deoarece nu fac   parte din scopul rul\u0103rii algoritmului nostru pentru numerele p\u00e2n\u0103 la 30.</li> </ul> <p></p> <p>Un exemplu de vizualizare pentru numerele de la 1 la 16</p> <p>Algoritmul se dovede\u0219te a fi o optimizare fa\u021b\u0103 de metoda standard de aflare pentru toate numerele de la 1 la \\(n\\) a primalit\u0103\u021bii, complexitatea devenind \\(\\mathcal{O}(n \\log \\log n)\\) pentru aflarea primalit\u0103\u021bii pentru toate numerele, respectiv \\(\\mathcal{O}(n \\log n)\\) pentru majoritatea celorlalte tipuri de prelucr\u0103ri. De asemenea, \u0219i implementarea se dovede\u0219te a fi una foarte scurt\u0103, ciurul put\u00e2nd fi scris \u00een c\u00e2teva r\u00e2nduri.</p> <pre><code>int prim[100001];\nfor (int i = 2; i &lt;= n; i++) {\n    if (prim[i] == 0) {\n        for (int j = i + i; j &lt;= n; j += i) {\n            prim[j] = 1;\n        }\n    }\n}\n</code></pre> <p>Observa\u021bie</p> <p>E de remarcat c\u0103 numerele prime vor fi cele nemarcate, iar numerele compuse vor fi cele marcate cu 1.</p>","tags":["matematica","numere prime","divizori","precalculari"]},{"location":"usor/sieve/#optimizari-ale-implementarii","title":"Optimiz\u0103ri ale implement\u0103rii","text":"<p>De\u0219i algoritmul \u00een sine este deja foarte rapid, \u00een practic\u0103 concuren\u021bii tind s\u0103 aplice diverse optimiz\u0103ri de constant\u0103 inspirate din optimiz\u0103rile ce se pot aplica algoritmului de aflare a divizorilor unui num\u0103r \\(n\\). Printre altele, putem vorbi de \u00eenceperea celui de-al doilea for de la \\(i^2\\) (primul num\u0103r compus care nu a fost marcat anterior va fi mereu \\(i^2\\)) sau de procesarea lui 2, urmat\u0103 de procesarea numerelor impare din 2 \u00een 2.</p> <pre><code>int prim[100001];\nfor (int i = 4; i &lt;= n; i += 2) {\n    prim[i] = 1;\n}\nfor (int i = 3; i &lt;= n; i += 2) {\n    if (prim[i] == 0) {\n        for (int j = i * i; j &lt;= n; j += i * 2) {\n            prim[j] = 1;\n        }\n    }\n}\n</code></pre> <p>Observa\u021bie</p> <p>Trebuie avut grij\u0103 la cel de-al doilea for deoarece expresia <code>int j = i * i;</code> poate cauza overflow dac\u0103 implementarea nu este una corespunz\u0103toare. De aceea, concuren\u021bii pot folosi o optimizare similar\u0103 \u0219i pentru primul for.</p> <pre><code>int prim[100001];\nfor (int i = 4; i &lt;= n; i += 2) {\n    prim[i] = 1;\n}\nfor (int i = 3; i * i &lt;= n; i += 2) {\n    if (prim[i] == 0) {\n        for (int j = i * i; j &lt;= n; j += i * 2) {\n            prim[j] = 1;\n        }\n    }\n}\n\n// afisarea numerelor prime de la 1 la n\nfor (int i = 2; i &lt;= n; i++) {\n    if (prim[i] == 0) {\n        cout &lt;&lt; i &lt;&lt; \" \";\n    }\n}\n</code></pre> <p>Chiar dac\u0103 aceste implement\u0103ri nu \u00eembun\u0103t\u0103\u021besc semnificativ performan\u021ba ciurului lui Eratostene, ele pot fi utile \u00een contextul optimiz\u0103rilor ce ar putea fi folosite la rezolvarea problemelor.</p>","tags":["matematica","numere prime","divizori","precalculari"]},{"location":"usor/sieve/#alte-aplicatii-ale-ciurului-lui-eratostene","title":"Alte aplica\u021bii ale ciurului lui Eratostene","text":"<p>Dup\u0103 cum am men\u021bionat la \u00eenceputul articolului, ciurul lui Eratostene este un algoritm foarte versatil, put\u00e2nd fi folosit pentru aflarea multor propriet\u0103\u021bi ale numerelor, precum divizorii (primi sau to\u021bi) ai unui num\u0103r, pentru calcule de tipul celor folosite la pinex sau M\u00f6bius \u0219i a\u0219a mai departe. C\u00e2teva din implement\u0103rile acestor opera\u021bii vor fi prezentate mai jos, \u00een cadrul problemei educa\u021bionale descris\u0103 \u00een cele ce urmeaz\u0103.</p>","tags":["matematica","numere prime","divizori","precalculari"]},{"location":"usor/sieve/#problema-ciurul-lui-eratostene-de-pe-kilonova","title":"Problema Ciurul lui Eratostene de pe Kilonova","text":"<p>Se dau \\(q\\) opera\u021bii de forma \\(type \\ value\\). \u00cen func\u021bie de tipul opera\u021biei, va trebui s\u0103 face\u021bi urm\u0103toarele lucruri:</p> <ul> <li>\\(1\\ value\\): S\u0103 se afi\u0219eze <code>Prime</code> sau <code>Composite</code> dac\u0103 num\u0103rul este prim,   respectiv compus.</li> <li>\\(2\\ value\\): S\u0103 se afi\u0219eze divizorii primi ai lui \\(value\\), \u00een ordine   cresc\u0103toare. Dac\u0103 \\(value = 1\\), se va afi\u0219a o linie goal\u0103.</li> <li>\\(3\\ value\\): S\u0103 se afi\u0219eze divizorii lui \\(value\\), \u00een ordine cresc\u0103toare.</li> </ul> <p>Pentru a rezolva problema (\u0219i \u00een general pentru a rezolva problemele care implic\u0103 folosirea ciurului lui Eratostene), ne vom precalcula toate r\u0103spunsurile folosind varia\u021bii ale ciurului lui Eratostene, una pentru numerele prime \u0219i cealalt\u0103 pentru divizori \u00een general. Pentru a \u021bine \u00een memorie to\u021bi divizorii, vom folosi varianta din STL a vectorilor, deoarece face accesarea datelor mai u\u0219oar\u0103.</p> <pre><code>#include &lt;iostream&gt;\n#include &lt;vector&gt;\n\nusing namespace std;\n\nconst int NMAX = 1000000;\nint q, prime[NMAX + 1];\nvector&lt;vector&lt;int&gt; &gt; divisors, prime_divisors;\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n\n    divisors.resize(NMAX + 1);\n    prime_divisors.resize(NMAX + 1);\n\n    for (int i = 1; i &lt;= NMAX; i++) {\n        for (int j = i; j &lt;= NMAX; j += i) {\n            divisors[j].push_back(i);\n        }\n    }\n\n    prime[1] = 1;\n    for (int i = 2; i &lt;= NMAX; i++) {\n        if (prime[i] == 0) {\n            for (int j = i; j &lt;= NMAX; j += i) {\n                prime_divisors[j].push_back(i);\n                if (j != i) {\n                    prime[j] = 1;\n                }\n            }\n        }\n    }\n\n    cin &gt;&gt; q;\n\n    for (int i = 1; i &lt;= q; i++) {\n        int type, value;\n        cin &gt;&gt; type &gt;&gt; value;\n        if (type == 1) {\n            cout &lt;&lt; (prime[value] == 0 ? \"Prime\" : \"Composite\") &lt;&lt; '\\n';\n        }\n        if (type == 2) {\n            for (int j = 0; j &lt; (int)prime_divisors[value].size(); j++) {\n                cout &lt;&lt; prime_divisors[value][j] &lt;&lt; \" \";\n            }\n            cout &lt;&lt; '\\n';\n        }\n        if (type == 3) {\n            for (int j = 0; j &lt; (int)divisors[value].size(); j++) {\n                cout &lt;&lt; divisors[value][j] &lt;&lt; \" \";\n            }\n            cout &lt;&lt; '\\n';\n        }\n    }\n    return 0;\n}\n</code></pre>","tags":["matematica","numere prime","divizori","precalculari"]},{"location":"usor/sieve/#problema-cufar-oji-2018-de-pe-kilonova","title":"Problema Cuf\u0103r - OJI 2018 de pe Kilonova","text":"<p>Vr\u0103jitoarea cea bun\u0103 are un cuf\u0103r \u00een care este \u00eenchis\u0103 piatra magic\u0103 de c\u0103tre piticii l\u0103zii cu ajutorul unui cifru digital. Piticii i-au dat vr\u0103jitoarei o cutie \u00een care sunt \\(n\\) cartona\u0219e. Pe fiecare cartona\u0219 este scris un num\u0103r natural pe care vr\u0103jitoarea \u00eel va folosi s\u0103 deschid\u0103 lada. Valorile scrise pe cartona\u0219e sunt distincte \u00eentre ele.</p> <p>Pentru a afla cifrul trebuie s\u0103 procedeze astfel: extrage fiecare cartona\u0219 din cutie \u0219i apoi determin\u0103 valoarea magic\u0103 asociat\u0103 num\u0103rului natural scris pe cartona\u0219. Pentru fiecare cartona\u0219 valoarea magic\u0103 este dat\u0103 de al \\(k\\)-lea divizor prim al num\u0103rului \u00eenscris pe acesta. Vr\u0103jitoarea trebuie s\u0103 adune valorile magice ob\u021binute pentru cele \\(n\\) cartona\u0219e \u0219i apoi s\u0103 introduc\u0103 \u00een ordine cifrele valorii ob\u021binute, pentru a descuia lada.</p> <p>Pentru a rezolva problema vom afla folosind un ciur to\u021bi divizorii primi ai numerelor mai mici sau egale cu \\(10^6\\), ace\u0219tia fiind folosi\u021bi pentru a calcula r\u0103spunsul la query-uri. Aflarea r\u0103spunsului final devine u\u0219oar\u0103 ulterior efectu\u0103rii acestui pas.</p> <pre><code>#include &lt;fstream&gt;\nusing namespace std;\n\nifstream f(\"cufar.in\");\nofstream g(\"cufar.out\");\n\nint c, n, nr, k, prime[9][1000002];\nint cate[1000002];\nlong long sol;\nbool prim[1000002];\n\nvoid ciur() {\n    for (int i = 2; i &lt;= 1000000; i++) {\n        if (!prim[i]) {\n            for (int j = i; j &lt;= 1000000; j += i) {\n                prim[j] = 1;\n                ++cate[j];\n                prime[cate[j]][j] = i;\n            }\n        }\n    }\n}\n\nint main() {\n    ciur();\n    f &gt;&gt; c &gt;&gt; n;\n    if (c == 1) {\n        f &gt;&gt; nr &gt;&gt; k;\n        g &lt;&lt; prime[k][nr] &lt;&lt; '\\n';\n    } else {\n        long long sol = 0;\n        for (int i = 1; i &lt;= n; ++i) {\n            f &gt;&gt; nr &gt;&gt; k;\n            sol += 1LL * prime[k][nr];\n        }\n        g &lt;&lt; sol &lt;&lt; '\\n';\n    }\n    return 0;\n}\n</code></pre>","tags":["matematica","numere prime","divizori","precalculari"]},{"location":"usor/sieve/#problema-primprim-oji-2023-de-pe-kilonova","title":"Problema primprim - OJI 2023 de pe Kilonova","text":"<p>Pentru un numa\u0306r natural a definim costul ca fiind valoarea absoluta\u0306 (modulul) diferen\u021bei dintre a \u0219i numa\u0306rul prim cel mai apropiat de a. Asupra unui \u0219ir de \\(n\\) numere naturale, situate pe pozi\u021bii numerotate de la 1 la \\(n\\), se aplica\u0306, \u00een ordine, o succesiune de \\(q\\) opera\u021bii. O opera\u021bie consta\u0306 dintr-o \u00eenlocuire \u0219i o afi\u0219are \u0219i este descrisa\u0306 sub forma \\(i \\ x \\ p\\), cu semnifica\u021bia: mai \u00eenta\u0302i \u00eenlocuim cu \\(x\\) elementul din \u0219ir de pe pozi\u021bia \\(i\\); apoi afi\u0219a\u0306m suma minima\u0306 totala\u0306 a costurilor unor elemente convenabil selectate de pe \\(p\\) pozi\u021bii distincte din \u0219ir.</p> <p>Cunosca\u0302nd \\(n\\) \u0219i cele \\(n\\) elemente ale \u0219irului, scrie\u021bi un program care sa\u0306 determine:</p> <ul> <li>suma costurilor tuturor elementelor din \u0219irul dat;</li> <li>rezultatele afi\u0219ate \u00een urma aplica\u0306rii fieca\u0306reia dintre cele \\(q\\) opera\u021bii,   date \u00een forma precizata\u0306.</li> </ul> <p>Pentru a rezolva problema, vom precalcula pentru fiecare valoare r\u0103spunsul optim pentru fiecare num\u0103r de la 1 la \\(a\\) folosind ciurul lui Eratostene. Apoi, parcurgem valorile de la 1 la \\(a\\) pentru a afla r\u0103spunsul optim dup\u0103 ce am aflat numerele prime din \u0219ir.</p> <p>Pentru a rezolva query-urile, voi folosi un vector de frecventa pentru a tine aceste diferen\u021be, care de altfel sunt destul de mici. Apoi, pentru fiecare query, voi parcurge vectorul de frecven\u021b\u0103 pentru a afla suma celor mai mici \\(p\\) diferen\u021be.</p> <pre><code>#include &lt;cmath&gt;\n#include &lt;fstream&gt;\n\nusing namespace std;\n\nifstream fin(\"primprim.in\");\nofstream fout(\"primprim.out\");\n\nint vals[1000002], primes[200002], cnt, ans[1100002];\nbool pr[1100002];\n\nint fr[202];\n\nint main() {\n    int c;\n    fin &gt;&gt; c;\n\n    int n, a = 1100000, i, j;\n    fin &gt;&gt; n;\n\n    for (i = 1; i &lt;= n; i++) {\n        fin &gt;&gt; vals[i];\n    }\n\n    // precalculam raspunsul optim pentru fiecare numar de la 1 la a folosind\n    // ciurul lui Eratostene\n\n    for (i = 2; i &lt;= a; i++) {\n        if (pr[i] == 0) {\n            primes[cnt++] = i;\n            for (j = i + i; j &lt;= a; j += i) {\n                pr[j] = 1;\n            }\n        }\n    }\n\n    int poz = -1;\n\n    // parcurg valorile de la 1 la a pentru a afla raspunsul optim dupa ce am\n    // aflat numerele prime\n    ans[1] = 1;\n    for (i = 2; i &lt;= a; i++) {\n        if (pr[i] == 0) {\n            poz++;\n        }\n        ans[i] = abs(i - primes[poz]);\n        if (poz + 1 &lt; cnt) {\n            ans[i] = min(ans[i], abs(i - primes[poz + 1]));\n        }\n    }\n\n    // voi folosi vector de frecventa pentru a tine aceste diferente, care de\n    // altfel sunt destul de mici\n\n    for (i = 1; i &lt;= n; i++) {\n        fr[ans[vals[i]]]++;\n    }\n\n    if (c == 1) {\n        int total = 0;\n        for (i = 1; i &lt;= n; i++) {\n            total += ans[vals[i]];\n        }\n        fout &lt;&lt; total;\n        return 0;\n    }\n\n    int q;\n    fin &gt;&gt; q;\n\n    for (i = 1; i &lt;= q; i++) {\n        int a, b, p;\n        fin &gt;&gt; a &gt;&gt; b &gt;&gt; p;\n\n        fr[ans[vals[a]]]--;\n        vals[a] = b;\n        fr[ans[vals[a]]]++;\n\n        int dif = 0;\n        int sol = 0;\n\n        // la fiecare pas parcurg vectorul de frecventa pana cand dau de p\n        // diferente\n\n        while (p) {\n            sol += min(p, fr[dif]) * dif;\n            p -= min(p, fr[dif]);\n            dif++;\n        }\n\n        fout &lt;&lt; sol &lt;&lt; '\\n';\n    }\n    return 0;\n}\n</code></pre>","tags":["matematica","numere prime","divizori","precalculari"]},{"location":"usor/sieve/#concluzie","title":"Concluzie","text":"<p>Ciurul lui Eratostene este una dintre cele mai importante metode de a lucra cu numere prime, precalcul\u0103rile care se pot face pe stilul acestui algoritm ne pot ajuta \u00een multe contexte, \u00een special c\u00e2nd calcul\u0103m divizori, sume sau chiar num\u0103rul de solu\u021bii \u00een alte probleme.</p>","tags":["matematica","numere prime","divizori","precalculari"]},{"location":"usor/sieve/#probleme-suplimentare","title":"Probleme suplimentare","text":"<ul> <li>CSES Counting Divisors</li> <li>CSES Common Divisors</li> <li>RoAlgo PreOJI 2024 Factoria</li> <li>Moisil++ Sprime</li> <li>infoarena numereprime</li> <li>ONI 2013 divizori</li> <li>ONI 2019 comun</li> <li>OJI 2024 Macarie</li> <li>OJI 2024 avid</li> <li>OJI 2023 Primprim</li> <li>ONI 2024 Geologie</li> <li>ONI 2013 Extraprime</li> <li>ONI 2022 Baraj Juniori Triprime</li> <li>ONI 2021 Baraj Juniori Intergalactic</li> <li>Probleme cu ciurul lui Eratostene de pe   kilonova</li> </ul>","tags":["matematica","numere prime","divizori","precalculari"]},{"location":"usor/sieve/#lectura-suplimentara","title":"Lectur\u0103 suplimentar\u0103","text":"<ul> <li>Ciurul lui Eratostene -   Pbinfo</li> <li>Eratostene si alte ciururi -   Pbinfo</li> <li>Ciurul lui Eratostene - CPPI   Sync</li> <li>Wikipedia - Ciurul lui   Eratostene</li> <li>Articol de pe CP   Algorithms</li> </ul>","tags":["matematica","numere prime","divizori","precalculari"]},{"location":"usor/simulating-solution/","title":"Simularea solu\u021biei","text":"","tags":["C++","implementare","optimizare","simulare"]},{"location":"usor/simulating-solution/#introducere","title":"Introducere","text":"<p>Unele probleme nu ne cer doar rezultatul final, ci \u0219i unele rezultate pe care le ob\u021binem pe parcurs. O simulare necesit\u0103 3 lucruri:</p> <ol> <li>O stare care poate fi descris\u0103 \u00een mod unic, prin ni\u0219te variabile</li> <li>O m\u0103sur\u0103 de timp, un tact (care, de obicei, este definit de problem\u0103)</li> <li>O bucl\u0103 cu o condi\u021bie de oprire</li> </ol> <p>O simulare arat\u0103 astfel:</p> <pre><code>gata = 1;\nwhile (!gata) {\n    &lt;folosim starea ca sa facem ceva&gt;\n    &lt;avansam la urmatorul pas, trece un tact&gt; \n    if (&lt;conditie de oprire&gt;) {\n        gata = 1;\n    }\n}\n</code></pre> <p>Observa\u021bie</p> <p>Multe probleme de clasa a V-a \u0219i de clasa a VI-a (matrice) necesita simularea solu\u021biei.</p>","tags":["C++","implementare","optimizare","simulare"]},{"location":"usor/simulating-solution/#problema-exemplu-simulare","title":"Problema exemplu - simulare","text":"<p>\u00cen aceast\u0103 problem\u0103, cum cere \u0219i titlul, trebuie doar s\u0103 simul\u0103m procesul descris. De fiecare dat\u0103 c\u00e2nd citim o direc\u021bie, avans\u0103m \u00een acel mod, cre\u0219tem suma cu valoarea de la pozi\u021bia ob\u021binut\u0103 \u0219i o afi\u0219\u0103m.</p> <p>Mai jos g\u0103si\u021bi sursa de 100 de puncte, implementat\u0103 at\u00e2t cu func\u021bii, c\u00e2t \u0219i f\u0103r\u0103 ele:</p> F\u0103r\u0103 func\u021biiCu func\u021bii <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint mat[1000][1000], q, x, y;\n\nint main() {\n    ios_base::sync_with_stdio(0);\n    cin.tie(0);\n\n    int i, j, n, m;\n    cin &gt;&gt; n &gt;&gt; m &gt;&gt; q &gt;&gt; x &gt;&gt; y;\n    x--;  // noi indexam de la 0\n    y--;\n    for (i = 0; i &lt; n; i++) {\n        for (j = 0; j &lt; m; j++) {\n            cin &gt;&gt; mat[i][j];\n        }\n    }\n    int dir;\n    long long sum;\n    dir = cin.get();\n    while (!isalpha(dir)) {\n        dir = cin.get();  // gasim prima litera (prima directie)\n    }\n    sum = 0;\n    for (i = 0; i &lt; q; i++) {\n        if (dir == 'N') {\n            x--;\n        } else if (dir == 'E') {\n            y++;\n        } else if (dir == 'S') {\n            x++;\n        } else {  // 'V'\n            y--;\n        }\n\n        sum += mat[x][y];\n        cout &lt;&lt; sum &lt;&lt; \" \";\n\n        dir = cin.get();\n    }\n    cout &lt;&lt; \"\\n\";\n    return 0;\n}\n</code></pre> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint mat[1000][1000], q, x, y;\n\nvoid readMatrix() {\n    int i, j, n, m;\n    cin &gt;&gt; n &gt;&gt; m &gt;&gt; q &gt;&gt; x &gt;&gt; y;\n    x--;  // noi indexam de la 0\n    y--;\n    for (i = 0; i &lt; n; i++) {\n        for (j = 0; j &lt; m; j++) {\n            cin &gt;&gt; mat[i][j];\n        }\n    }\n}\n\nvoid simulateRoad() {\n    int i, dir;\n    long long sum;\n    dir = cin.get();\n    while (!isalpha(dir)) {\n        dir = cin.get();  // gasim prima litera (prima directie)\n    }\n    sum = 0;\n    for (i = 0; i &lt; q; i++) {\n        if (dir == 'N') {\n            x--;\n        } else if (dir == 'E') {\n            y++;\n        } else if (dir == 'S') {\n            x++;\n        } else {  // 'V'\n            y--;\n        }\n\n        sum += mat[x][y];\n        cout &lt;&lt; sum &lt;&lt; \" \";\n\n        dir = cin.get();\n    }\n    cout &lt;&lt; \"\\n\";\n}\n\nint main() {\n    ios_base::sync_with_stdio(0);\n    cin.tie(0);\n\n    readMatrix();\n    simulateRoad();\n    return 0;\n}\n</code></pre>","tags":["C++","implementare","optimizare","simulare"]},{"location":"usor/simulating-solution/#optimizarea-unei-simulari","title":"Optimizarea unei simul\u0103ri","text":"<p>La unele probleme, chiar dac\u0103 nu ne este cerut rezultatul pe parcursul simul\u0103rii, nu se poate g\u0103si o alt\u0103 solu\u021bie dec\u00e2t simularea. Majoritatea problemelor de acest fel, \u00een care simularea nu intr\u0103 \u00een timp, este necesar\u0103 optimizarea simul\u0103rii.</p>","tags":["C++","implementare","optimizare","simulare"]},{"location":"usor/simulating-solution/#optimizarea-prin-gasirea-unei-perioade","title":"Optimizarea prin g\u0103sirea unei perioade","text":"<p>Uneori, st\u0103rile unei simul\u0103ri se repet\u0103 periodic. La anumite probleme, o optimizare cerut\u0103 este alfarea acelei perioade \u0219i folosirea ei pentru aflarea tuturor elementelor</p>","tags":["C++","implementare","optimizare","simulare"]},{"location":"usor/simulating-solution/#problema-exemplu-galbeni-oji-2013-vi","title":"Problem\u0103 exemplu: galbeni - OJI 2013 VI","text":"<p>Fie \\(getNext(n) =\\) num\u0103rul care urmeaz\u0103 dup\u0103 \\(n\\).</p> <p>Cum toate numerele sunt de la 1 la 999, rezult\u0103, din principiul cutiei, c\u0103, dup\u0103 maxim 1000 de numere, vom g\u0103si dou\u0103 egale. Secven\u021ba dintre ele se va repeta la nesf\u00e2r\u0219it.</p> <p>Not\u0103m cu \\(start\\) pozi\u021bia de la care \u00eencepe ciclul \u0219i cu \\(len\\) lungimea ciclului. Al \\(n\\)-lea num\u0103r poate fi aflat \u00een func\u021bie de \\(start\\) \u0219i \\(len\\).</p> <p>Sursa de 100 de puncte:</p> <pre><code>#include &lt;fstream&gt;\nusing namespace std;\n\nifstream fin(\"galbeni.in\");\nofstream fout(\"galbeni.out\");\n\nint n, start_cycle, cycle_length, p10, poz[1000], v[1000];\n\nint getNext(int s) {\n    int i, p, new_s, cifra;\n\n    p = 1;\n    new_s = s;\n    while (s &gt; 0) {\n        cifra = s % 10;\n        if (cifra &gt; 0) {\n            new_s *= cifra;\n        }\n        s /= 10;\n    }\n\n    new_s = ((new_s * 8) / 9) % (p10 * 10);\n    while (new_s &lt; p10) { // cat timp are mai putin de k cifre\n        new_s = new_s * 10 + 9;\n    }\n\n    return new_s;\n}\n\nvoid findCycle() {\n    int s, k, cnt, i;\n    fin &gt;&gt; s &gt;&gt; k &gt;&gt; n;\n\n    p10 = 1; // p10 va reprezenta cel mai mic numar de k cifre\n    for (k--; k &gt; 0; k--) {\n        p10 *= 10;\n    }\n\n    poz[s] = cnt = 1;\n    v[1] = s;\n    while (poz[s = getNext(s)] == 0) { // cautam prima care se repeta\n        poz[s] = ++cnt;\n        v[cnt] = s;\n    }\n\n    start_cycle = poz[s];\n    cycle_length = cnt - poz[s] + 1;\n}\n\nvoid calcAnswer() {\n    if (n &lt; start_cycle) {\n        fout &lt;&lt; v[n] &lt;&lt; \"\\n\";\n    } else {\n        n -= start_cycle;\n        fout &lt;&lt; v[start_cycle + n % cycle_length] &lt;&lt; \"\\n\";\n    }\n}\n\nint main() {\n    findCycle();\n    calcAnswer();\n    return 0;\n}\n</code></pre>","tags":["C++","implementare","optimizare","simulare"]},{"location":"usor/simulating-solution/#optimizarea-prin-gasirea-unei-formule-care-genereaza-starile-urmatoare","title":"Optimizarea prin g\u0103sirea unei formule care genereaz\u0103 st\u0103rile urm\u0103toare","text":"<p>Anumite probleme se genereaz\u0103 \u00eentr-un mod care poate fi stabilit de o formul\u0103.</p>","tags":["C++","implementare","optimizare","simulare"]},{"location":"usor/simulating-solution/#problema-exemplu-asort-baraj-2016-juniori","title":"Problem\u0103 exemplu: asort - Baraj 2016 Juniori","text":"<p>Solu\u021bia problemei se poate deduce studiind transformarea \u0219irului p\u00e2n\u0103 c\u00e2nd acesta devine \u201cA sortat\u201d.</p> <p>De exemplu, pentru \\(N=8\\), aplic\u00e2nd de \\(N\\) ori regula \\(A\\) se ob\u021bin \u0219irurile: </p> <p>Observ\u0103m c\u0103 prin aplicarea de un num\u0103r impar de ori a regulii, \u0219irul rezultat are pe pozi\u021biile impare numerele pare. Numere pare au apari\u021bie periodic\u0103 \u00een \u0219irurile rezultate \u00een ordinea \\(2, 4, 6, 8, 2, 4, 6, ...\\) Analog, numerele impare apar pe pozi\u021bii impare \u00een ordinea \\(1, 3, 5, 7, 1, 3, 5, ...\\) Dac\u0103 se aplic\u0103 regula de un num\u0103r par de ori, pe pozi\u021biile pare apar numerele pare.</p> <p>Studiind exemplul, observ\u0103m c\u0103:</p> <ol> <li> <p>Dac\u0103 num\u0103rul de aplic\u0103ri ale regulii date \\(R\\) este impar, atunci dac\u0103 pozi\u021bia    \\(K\\) este impar\u0103 atunci num\u0103rul c\u0103utat este egal cu \\((R+K) \\% N\\) sau \\(N\\) dac\u0103    acest rest este 0. Dac\u0103 pozi\u021bia \\(K\\) este par\u0103, atunci numarul c\u0103utat este    egal cu \\((N+K-R) \\% N\\) sau \\(N\\) dac\u0103 acest rest este 0.</p> </li> <li> <p>Dac\u0103 num\u0103rul de aplic\u0103ri ale regulii \\(A\\) date \\(R\\) este par, atunci dac\u0103    pozi\u021bia \\(K\\) este impar\u0103 atunci num\u0103rul c\u0103utat este egal cu \\((N+K-R) \\% N\\) sau    \\(N\\) dac\u0103 acest rest este 0. Dac\u0103 pozi\u021bia \\(K\\) este par\u0103, atunci num\u0103rul    c\u0103utat este egal cu \\((K+R) \\% N\\) sau \\(N\\) dac\u0103 acest rest este 0.</p> </li> <li> <p>Dac\u0103 num\u0103rul \\(T\\) este par atunci pozi\u021bia acestui num\u0103r \u00een \u0219irul \u201c\\(A\\) sortat\u201d    este \\(poz = (N+T-R) \\% N\\). Altfel, \\(poz = (T+R) \\% N\\). \u00cen ambele situa\u021bii,    dac\u0103 \\(poz=0\\) atunci \\(poz=N\\). Cunosc\u00e2nd pozi\u021bia lui \\(T\\) \u00een \u0219irul \u201c\\(A\\) sortat\u201d,    determin\u0103m numerele situate pe pozi\u021bia \\(poz-1\\) (sau \\(N\\)) pentru predecesor,    respectiv \\(poz+1\\) (sau 1) pentru succesor folosindu-ne de rezultatele    men\u021bionate mai sus.</p> </li> </ol> <p>Detaliu de implementare: vom folosi faptul c\u0103 \\((x \\% n) == 0 ? n : x \\% n\\) este echivalent cu \\((x - 1) \\% n + 1\\), pentru \\(x &gt; 0\\). Demonstra\u021bie:</p> <ol> <li>\\(x \\% n = 0\\), atunci \\((x - 1) \\% n + 1 = n - 1 + 1 = n\\).</li> <li>\\(x \\% n &gt; 0\\), atunci \\((x - 1) \\% n + 1 = x \\% n - 1 + 1 = x \\% n\\)</li> </ol> <p>Sursa de 100 de puncte:</p> <pre><code>#include &lt;fstream&gt;\nusing namespace std;\n\nifstream fin(\"asort.in\");\nofstream fout(\"asort.out\");\n\nint r, n;\n\nint pozToNumber(int poz) {\n    if (((poz % 2 == 0) ^ (r % 2 == 0)) == 0) {  // ambele sau niciuna\n        return (r + poz - 1) % n + 1;\n    } else {\n        return (n + poz - r - 1) % n + 1;\n    }\n}\n\nint numberToPoz(int nr) {\n    if (nr % 2 == 0) {\n        return (n + nr - r - 1) % n + 1;\n    } else {\n        return (nr + r - 1) % n + 1;\n    }\n}\n\nvoid calcAnswer() {\n    int cer, t, k, poz, val, pred, succ;\n    fin &gt;&gt; cer &gt;&gt; n &gt;&gt; r &gt;&gt; k &gt;&gt; t;\n    r %= n;  // la n operatii se revine la sirul initial\n\n    if (cer == 1) {\n        fout &lt;&lt; pozToNumber(k) &lt;&lt; \"\\n\";\n    } else {\n        poz = numberToPoz(t);\n        pred = pozToNumber(poz == 1 ? n : poz - 1);  // predecesorul\n        succ = pozToNumber(poz == n ? 1 : poz + 1);  // succesorul\n        fout &lt;&lt; pred &lt;&lt; \" \" &lt;&lt; succ &lt;&lt; \"\\n\";\n    }\n}\n\nint main() {\n    calcAnswer();\n    return 0;\n}\n</code></pre>","tags":["C++","implementare","optimizare","simulare"]},{"location":"usor/simulating-solution/#probleme-rezolvate","title":"Probleme rezolvate","text":"","tags":["C++","implementare","optimizare","simulare"]},{"location":"usor/simulating-solution/#problema-robinson-oni-2005-vi","title":"Problema robinson - ONI 2005 VI","text":"<p>Mai intai, vom construi matricea in modul descris. Dupa aceea, va trebuie sa simulam drumul din problema. Pentru a afla usor urmatoarea pozitie, vom folosi vectori de directie. Dup\u0103 ce afl\u0103m direct\u021ba \u00een care mergem, vom marca pozi\u021bia ca vizitat\u0103 (adic\u0103 set\u0103m valoarea din matrice la \\(VISITED\\), o constant\u0103 care va fi egal\u0103 cu \\(-1\\) sau cu orice valoare care nu poate ap\u0103rea in matrice).</p> <p>De asemenea, pentru a determina u\u0219or dac\u0103 am ie\u0219it sau nu din matrice, vom borda matricea cu valoarea \\(VISITED\\).</p> <p>Sursa de 100 de puncte:</p> <pre><code>#include &lt;fstream&gt;\nusing namespace std;\n\nifstream fin(\"robinson.in\");\nofstream fout(\"robinson.out\");\n\nconst int MAXM = 100;\nconst int VISITED = -1;\nconst int N_DIR = 4;  // cate directii sunt\n\nint n, m, l, c, mat[MAXM + 2][MAXM + 2];\nint dx[N_DIR] = {-1, 0, 1, 0},\n    dy[N_DIR] = {0, 1, 0, -1};  // vectori de directie\n\nvoid calcMatrix() {\n    int i, j;\n    fin &gt;&gt; m &gt;&gt; n &gt;&gt; l &gt;&gt; c;\n    for (i = 1; i &lt;= m; i++) {\n        mat[1][i] = mat[i][1] = n + i - 1;\n    }\n    for (i = 2; i &lt;= m; i++) {\n        for (j = 2; j &lt;= m; j++) {\n            // pastram ultimele trei cifre\n            mat[i][j] = (mat[i - 1][j] + mat[i][j - 1]) % 1000;\n        }\n    }\n    fout &lt;&lt; mat[m][m] &lt;&lt; \"\\n\";\n}\n\nvoid borderMatrix() {\n    int i;\n    for (i = 0; i &lt;= m + 1; i++) {\n        mat[0][i] = mat[m + 1][i] = mat[i][0] = mat[i][m + 1] = VISITED;\n    }\n}\n\nvoid simulateProcess() {\n    int gata = 0, dir;\n    while (!gata) {\n        fout &lt;&lt; l &lt;&lt; \" \" &lt;&lt; c &lt;&lt; \"\\n\";\n        dir = mat[l][c] % N_DIR;\n        mat[l][c] = VISITED;\n\n        l += dx[dir];  // avansam catre urmatoarea pozitie\n        c += dy[dir];\n        if (mat[l][c] == VISITED) {  // conditia de oprire\n            gata = 1;\n        }\n    }\n}\n\nint main() {\n    calcMatrix();\n    borderMatrix();  // bordarea matricei\n    simulateProcess();\n    return 0;\n}\n</code></pre>","tags":["C++","implementare","optimizare","simulare"]},{"location":"usor/simulating-solution/#problema-furnica-oji-2007-vi","title":"Problema furnica - OJI 2007 VI","text":"<p>\u00cen aceast\u0103 problem\u0103 este destul de direct ce trebuie s\u0103 facem. Vom simula procesul descris, \u021bin\u00e2nd o matrice \\(fr_{i, j}\\) care va reprezenta de c\u00e2te ori am trecut printr-o anumit\u0103 pozi\u021bie \\((i, j)\\). De asemenea, \u0219i \u00een aceast\u0103 problem\u0103 vom folosi vectori de direc\u021bie pentru a afla u\u0219or urm\u0103toarea pozi\u021bie.</p> <pre><code>#include &lt;fstream&gt;\nusing namespace std;\n\nifstream fin(\"furnica.in\");\nofstream fout(\"furnica.out\");\n\nconst int MAXN = 100;\nconst int N_DIR = 8;\n\nint fr[MAXN][MAXN], n;\n\n// vectori de directie\nint dlin[N_DIR] = {-1, -1, 0, 1, 1, 1, 0, -1};\nint dcol[N_DIR] = {0, 1, 1, 1, 0, -1, -1, -1};\n\nvoid visitPositions() {\n    int k, l, c, dir;\n    fin &gt;&gt; n &gt;&gt; k;\n\n    l = c = 0;\n    fr[0][0] = 1;\n    for (; k &gt; 0; k--) {\n        fin &gt;&gt; dir;\n        l += dlin[dir - 1];\n        c += dcol[dir - 1];\n        fr[l][c]++;\n    }\n}\n\nvoid calcAnswer() {\n    int sum, i, j, maxim, cnt;\n    sum = maxim = cnt = 0;\n    for (i = 0; i &lt; n; i++) {\n        for (j = 0; j &lt; n; j++) {\n            if (fr[i][j] &gt; 0) {\n                sum += (i + j + 2) % 6;\n                if (fr[i][j] &gt; maxim) {\n                    maxim = fr[i][j];\n                    cnt = 1;\n                } else if (fr[i][j] == maxim) {\n                    cnt++;\n                }\n            }\n        }\n    }\n    fout &lt;&lt; sum &lt;&lt; \" \" &lt;&lt; cnt &lt;&lt; \"\\n\";\n}\n\nint main() {\n    visitPositions();\n    calcAnswer();\n    return 0;\n}\n</code></pre>","tags":["C++","implementare","optimizare","simulare"]},{"location":"usor/simulating-solution/#concluzii","title":"Concluzii","text":"<p>\u00cen problemele de simulare, de obicei, este destul de u\u0219or s\u0103 \u00ee\u021bi dai seama ce trebuie s\u0103 faci, dar implementarea, uneori, nu este a\u0219a de u\u0219oar\u0103 precum pare. Pentru ca implement\u0103rile a acestor probleme s\u0103 vi se par\u0103 mai u\u0219oare, recomand\u0103m s\u0103 rezolva\u021bi c\u00e2t mai multe probleme de implementare/simulare, eventual \u0219i unele la care este de scris mai mult.</p> <p>Problemele de optimizare sunt, \u00een mare parte, din categoriile prezentate. Dar, la unele probleme, sunt necesare alte observa\u021bii care duc la o optimizare mai pu\u021bin obi\u0219nuit\u0103. De aceea, trebuie s\u0103 fim mereu foarte aten\u021bi la detalii \u0219i s\u0103 facem toate observa\u021biile necesare.</p>","tags":["C++","implementare","optimizare","simulare"]},{"location":"usor/simulating-solution/#probleme-suplimentare","title":"Probleme suplimentare","text":"<ul> <li>joc - ONI 2011 VI</li> <li>furnica - OJI 2007 VI</li> <li>oua - ONI 2007 VI</li> <li>circular - OJI 2022 X</li> <li>gcl - Baraj 2018 Juniori (O problem\u0103 la   care este mult de scris, dar care v\u0103 ajut\u0103 s\u0103 v\u0103 organiza\u021bi codul mai bine \u0219i   v\u0103 \u00eembun\u0103t\u0103\u021be\u0219te abilit\u0103\u021bile de implementare)</li> <li>medalion - ONI 2012 VI (Trebuie s\u0103   simula\u021bi cum se construie\u0219te o spiral\u0103)</li> <li>tinta - ONI 2014 VI</li> <li>robinhood - ONI 2024 V</li> <li>numere - OJI 2008 V (necesit\u0103 cuno\u0219tin\u021ba   perioadei Pisano)</li> <li>cartofi - OJI 2021 VIII</li> <li>seif - Lot 2022 Juniori</li> <li>loopover - Lot 2022 Juniori</li> <li>Probleme de for\u021b\u0103 brut\u0103 de pe kilonova</li> <li>Probleme de periodicitate de pe kilonova</li> <li>Alte probleme de implementare de pe kilonova</li> </ul>","tags":["C++","implementare","optimizare","simulare"]},{"location":"usor/simulating-solution/#resurse-suplimentare","title":"Resurse suplimentare","text":"<ul> <li>Simulation - USACO Guide</li> <li>Verificarea unor proprietati -   pbinfo</li> <li>Simulare -   algopedia</li> <li>Simulare, partea 2 -   algopedia</li> </ul>","tags":["C++","implementare","optimizare","simulare"]},{"location":"usor/sorting/","title":"Algoritmi de sortare","text":"","tags":["sortare","optimizare"]},{"location":"usor/sorting/#fundamente-si-cunostinte-necesare","title":"Fundamente \u0219i cuno\u0219tin\u021be necesare","text":"<p>\u00cen foarte multe probleme de algoritmic\u0103, un pas important \u00een rezolvarea problemelor const\u0103 \u00een ordonarea datelor de intrare dup\u0103 un anumit criteriu, iar o \u00eentrebare care se pune este cum putem s\u0103 ordon\u0103m datele convenabil, c\u00e2t mai rapid posibil?</p> <p>Din fericire, de-a lungul timpului s-au inventat foarte mul\u021bi algoritmi de sortare pe care \u00eei putem folosi pentru a rezolva problema pus\u0103 mai sus. Pentru a face \u00een\u021belegerea lor u\u0219oar\u0103, voi explica algoritmii \u00een ordine cresc\u0103toare a dificult\u0103\u021bii lor de \u00een\u021belegere, precum \u0219i \u00een ordine cresc\u0103toare a performan\u021bei, men\u021bion\u00e2nd \u00een cazul fiec\u0103ruia din algoritmi cuno\u0219tin\u021bele necesare pentru a-i putea \u00een\u021belege \u0219i folosi cu succes.</p>","tags":["sortare","optimizare"]},{"location":"usor/sorting/#algoritmi-de-sortare-in-mathcalon2","title":"Algoritmi de sortare \u00een \\(\\mathcal{O}(n^2)\\)","text":"<p>Voi \u00eencepe prin a explica algoritmii de sortare \u00een \\(\\mathcal{O}(n^2)\\) deoarece ace\u0219tia sunt de o dificultate similar\u0103, singura cuno\u0219tin\u021b\u0103 necesar\u0103 pentru ei fiind lucrul cu tablouri unidimensionale. Performan\u021bele celor trei algoritmi pe care \u00eei voi men\u021biona sunt de asemenea foarte similare, dar fiecare din ace\u0219ti algoritmi are punctele lui tari \u0219i slabe. Pentru fiecare sec\u021biune am ata\u0219at un exemplu de ordonare cresc\u0103toare a valorilor folosind acest algoritm.</p>","tags":["sortare","optimizare"]},{"location":"usor/sorting/#selection-sort","title":"Selection sort","text":"<p>Sortarea prin selec\u021bie sau selection sort este un algoritm elementar de sortare care verific\u0103 fiecare pereche de valori din vector \u0219i dac\u0103 cele dou\u0103 valori sunt a\u0219ezate contrar ordinii folosite la ordonarea lor, le vom schimba \u00eentre ele.</p> <pre><code>int v[1001], n;\n\nfor (int i = 1; i &lt; n; i++) {\n    for (int j = i + 1; j &lt;= n; j++) {\n        if (v[i] &gt; v[j]) {\n            int aux = v[i];\n            v[i] = v[j];\n            v[j] = aux;\n        }\n    }\n}\n</code></pre>","tags":["sortare","optimizare"]},{"location":"usor/sorting/#bubble-sort","title":"Bubble sort","text":"<p>Sortarea prin metoda bulelor sau bubble sort este un algoritm elementar de sortare care itereaz\u0103 prin valorile din vector c\u00e2t timp nu sunt ordonate \u0219i la fiecare pas al itera\u021biei, dac\u0103 g\u0103se\u0219te dou\u0103 valori adiacente ordonate contrar ordinii cerute, schimb\u0103 \u00eentre ele valorile \u0219i reseteaz\u0103 contorul folosit pentru a decide dac\u0103 algoritmul va trebui continuat dup\u0103 sf\u00e2r\u0219itul itera\u021biei curente a structurii repetitive.</p> <p>Observa\u021bie</p> <p>Num\u0103rul de interschimb\u0103ri f\u0103cut de algoritmul bubble sort este egal cu num\u0103rul de inversiuni al vectorului dat, observa\u021bie ce se va dovedi a fi foarte util\u0103 pentru multe con\u021binuturi mai avansate.</p> <pre><code>int v[1001], n;\nbool ok = true;\n\nwhile (ok == true) {\n    ok = false;\n\n    for (int i = 1; i &lt; n; i++) {\n        if (v[i] &gt; v[i + 1]) {\n            int aux = v[i];\n            v[i] = v[i + 1];\n            v[i + 1] = aux;\n            ok = false;\n        }\n    }\n}\n</code></pre>","tags":["sortare","optimizare"]},{"location":"usor/sorting/#insertion-sort","title":"Insertion sort","text":"<p>Sortarea prin inser\u021bie sau insertion sort este un algoritm elementar de sortare care pune pe r\u00e2nd fiecare valoare \u00eentre pozi\u021biile 2 \u0219i \\(n\\) pe pozi\u021bia potrivit\u0103 \u00een ordinea sortat\u0103 a valorilor p\u00e2n\u0103 la acea pozi\u021bie inclusiv.</p> <pre><code>int v[1001], n;\n\nfor (int i = 2; i &lt;= n; i++) {\n    for (int j = i - 1; j &gt;= 1; j--) {\n        if (v[j] &gt; v[j + 1]) {\n            int aux = v[j];\n            v[j] = v[j + 1];\n            v[j + 1] = aux;\n        }\n    }\n}\n</code></pre> <p>Cuno\u0219tin\u021be necesare pentru urm\u0103toarele capitole</p> <ul> <li>Subprograme</li> <li>Introducere \u00een STL</li> </ul>","tags":["sortare","optimizare"]},{"location":"usor/sorting/#algoritmi-de-sortare-in-mathcalon-log-n","title":"Algoritmi de sortare \u00een \\(\\mathcal{O}(n \\log n)\\)","text":"<p>Dup\u0103 studiul algoritmilor de mai sus, o \u00eentrebare natural\u0103 se pune: putem sorta un \u0219ir mai repede de \\(\\mathcal{O}(n^2)\\)? R\u0103spunsul este unul afirmativ, exist\u00e2nd foarte mul\u021bi algoritmi de sortare mai rapizi, cei mai rapizi fiind cei \u00een \\(\\mathcal{O}(n \\log n)\\).</p> <p>De\u0219i \u00een practic\u0103 \u00een cadrul concursurilor, de regul\u0103 ajungem s\u0103 ne folosim de func\u021bia <code>std::sort</code>, propriet\u0103\u021bile celorlal\u021bi algoritmi pot fi utile pentru \u00een\u021belegerea anumitor concepte prezentate pe parcurs, iar pentru cititorii care se preg\u0103tesc pentru interviurile de angajare sau pentru admiterea la universit\u0103\u021bile de top din str\u0103inatate, pot ap\u0103rea \u00eentreb\u0103ri care s\u0103 con\u021bin\u0103 elemente ale \u00een\u021belegerii algoritmilor de sortare explica\u021bi mai jos.</p>","tags":["sortare","optimizare"]},{"location":"usor/sorting/#functia-stdsort","title":"Func\u021bia std::sort","text":"<p>Se poate spune c\u0103 de departe cea mai folosit\u0103 metod\u0103 de a ordona un \u0219ir \u00een timpul unei competi\u021bii este prin folosirea func\u021biei oferite de limbajul C++ pentru a sorta un \u0219ir, aceast\u0103 func\u021bie av\u00e2nd la spate algoritmul IntroSort, o combina\u021bie \u00eentre QuickSort, HeapSort \u0219i Insertion Sort care preia cele mai bune caracteristici ale celor trei algoritmi men\u021biona\u021bi. Aplicarea ei se va dovedi a fi banal\u0103, fiind nevoie de o singur\u0103 linie de cod. Se g\u0103se\u0219te \u00een biblioteca <code>algorithm</code>.</p> <p>Pentru a scrie func\u021bia, trebuie s\u0103 \u0219tim adresa de \u00eenceput (de regul\u0103, pozi\u021bia 0 sau 1 din \u0219ir) \u0219i adresa de final, cea de final fiind incrementat\u0103 cu 1 deoarece intervalul pe care \u00eel vom folosi pentru func\u021bia descris\u0103 este \u00eenchis la st\u00e2nga \u0219i deschis la dreapta. Dup\u0103 cum se va observa mai jos, vom putea ad\u0103uga func\u021bii de comparare pentru a folosi <code>std::sort</code> la valoarea sa adev\u0103rat\u0103. Mai jos am ata\u0219at dou\u0103 exemple de aplicare a func\u021biei, pe vector indexat de la 0, respectiv 1.</p> <pre><code>int v[1001], n;\n\nsort(v + 1, v + n + 1);\n\nvector&lt;int&gt; vx(1002);\nsort(vx.begin(), vx.begin() + 500);\n\nvector&lt;int&gt; vy(2001);\nsort(vx.begin() + 1, vx.end());\n</code></pre>","tags":["sortare","optimizare"]},{"location":"usor/sorting/#quick-sort","title":"Quick Sort","text":"<p>QuickSort sau Sortarea rapid\u0103 este o metod\u0103 eficient\u0103 de sortare a unui tablou, descoperit\u0103 de programatorul britanic Tony Hoare. Pentru un set de \\(n\\) valori oarecare algoritmul efectueaz\u0103 \\(\\mathcal{O}(n \\log n)\\) compara\u021bii, dar \u00een cazul cel mai nefavorabil se efectueaz\u0103 \\(\\mathcal{O}(n^2)\\) compara\u021bii. De regul\u0103, acest algoritm este mai rapid dec\u00e2t merge sort sau heap sort at\u00e2ta timp c\u00e2t pivotul este ales favorabil, cazul cel mai nefavorabil va efectua mereu \\(\\mathcal{O}(n \\log n)\\) compara\u021bii.</p> <p>Algoritmul este de tip divide et impera; el sorteaz\u0103 o secven\u021b\u0103 a tabloului (ini\u021bial \u00eentreg tabloul), astfel:</p> <ul> <li>se alege un element special al listei, numit pivot;</li> <li>se ordoneaz\u0103 elementele listei, astfel \u00eenc\u00e2t toate elementele din st\u00e2nga     pivotului s\u0103 fie mai mici sau egale cu acesta, \u0219i toate elementele din dreapta     pivotului s\u0103 fie mai mari sau egale cu acesta;</li> <li>se continu\u0103 recursiv cu secven\u021ba din st\u00e2nga pivotului \u0219i cu cea din dreapta     lui.</li> </ul> <p>Observa\u021bie</p> <p>Se recomand\u0103 alegerea pivotului \u00eentr-un mod aleator, deoarece alegerea pivotului \u00eentr-o pozi\u021bie previzibil\u0103 (la \u00eenceput, la mijloc sau la sf\u00e2r\u0219it duce la cazuri nefavorabile) poate duce la solu\u021bii care \u00een cel mai r\u0103u caz s\u0103 aib\u0103 o complexitate de \\(\\mathcal{O}(n^2)\\).</p> <pre><code>vector&lt;int&gt; quicksort(vector&lt;int&gt; v) {\n    if (v.size() == 0) {\n        return v;\n    }\n    ll pivot = 1LL * rand() * rand();\n    pivot %= (v.size());\n    vector&lt;int&gt; greater, smaller, a, b;\n    int same_value = 0;\n    for (int i = 0; i &lt; v.size(); ++i) {\n        if (v[i] &lt; v[pivot]) {\n            smaller.push_back(v[i]);\n        } else {\n            if (v[i] == v[pivot]) {\n                ++same_value;\n            } else {\n                greater.push_back(v[i]);\n            }\n        }\n    }\n    if (same_value == v.size()) {\n        return v;\n    }\n    a = quicksort(greater);\n    b = quicksort(smaller);\n    vector&lt;int&gt; answer;\n    for (int i = 0; i &lt; b.size(); ++i) {\n        answer.push_back(b[i]);\n    }\n    for (int i = 0; i &lt; same_value; ++i) {\n        answer.push_back(v[pivot]);\n    }\n    for (int i = 0; i &lt; a.size(); ++i) {\n        answer.push_back(a[i]);\n    }\n    return answer;\n}\n</code></pre>","tags":["sortare","optimizare"]},{"location":"usor/sorting/#merge-sort","title":"Merge Sort","text":"<p>MergeSort este o metod\u0103 eficient\u0103 de sortare a unui tablou, inventat\u0103 de programatorul John von Neumann. Pentru un set de \\(n\\) valori oarecare algoritmul efectueaz\u0103 \\(\\mathcal{O}(n \\log n)\\) compara\u021bii, algoritmul fiind acela\u0219i indiferent de modul \u00een care sunt a\u0219ezate valorile. Algoritmul func\u021bioneaz\u0103 \u00een felul urm\u0103tor.</p> <ul> <li>Avem lista curent\u0103, o \u00eemp\u0103r\u021bim \u00een dou\u0103 jum\u0103t\u0103\u021bi egale.</li> <li>Rul\u0103m algoritmul pe fiecare din cele dou\u0103 jum\u0103t\u0103\u021bi.</li> <li>Se interclaseaz\u0103 cele dou\u0103 \u0219iruri rezultate.</li> </ul> <p>Acest algoritm folose\u0219te principiul Divide et Impera, principiu despre care pute\u021bi studia mai multe \u00een acest articol.</p> <p>Observa\u021bie</p> <p>Este de remarcat c\u0103 acest algoritm poate fi folosit pentru a calcula num\u0103rul de inversiuni al unui \u0219ir.</p> <pre><code>void mergesort(vector&lt;int&gt; &amp;v, int L, int R) {\n    if (L == R) {\n        return;\n    }\n\n    int mid = (L + R) / 2;\n    mergesort(v, L, mid);\n    mergesort(v, mid + 1, R);\n\n    vector&lt;int&gt; sorted;\n    int Lx = L;\n    int Rx = mid + 1;\n    while (Lx &lt;= mid &amp;&amp; Rx &lt;= R) {\n        if (v[Lx] &lt;= v[Rx]) {\n            sorted.push_back(v[Lx]);\n            Lx++;\n        } else {\n            sorted.push_back(v[Rx]);\n            Rx++;\n        }\n    }\n\n    while (Lx &lt;= mid) {\n        sorted.push_back(v[Lx]);\n        Lx++;\n    }\n    while (Rx &lt;= R) {\n        sorted.push_back(v[Rx]);\n        Rx++;\n    }\n    for (int i = L; i &lt;= R; i++) {\n        v[i] = sorted[i - L];\n    }\n}\n</code></pre>","tags":["sortare","optimizare"]},{"location":"usor/sorting/#heap-sort","title":"Heap Sort","text":"<p>Heap sort este un algoritm de sortare care la fiecare pas selecteaz\u0103 valoarea minim\u0103 folosind structura de date potrivit\u0103 (un heap, un arbore de intervale, un set etc.) \u0219i de aceea poate fi descris \u0219i drept un selection sort cu structura de date potrivit\u0103. La fiecare pas se afl\u0103 valoarea minim\u0103 din \u0219ir \u0219i se interschimb\u0103 valorile de pe cea mai din st\u00e2nga pozi\u021bie nefixat\u0103 cu valoarea de pe pozi\u021bia minim\u0103 g\u0103sit\u0103.</p> <p>Func\u021bia <code>heapSort</code> este apelat\u0103 din main folosind metoda heapSort, functia heapify fiind o func\u021bie auxiliar\u0103 care are drept scop plasarea valorii curente astfel \u00eenc\u00e2t s\u0103 se p\u0103streze structura de heap.</p> <pre><code>void heapify(vector&lt;int&gt; &amp;v, int n, int pos) {\n    int largest = pos, l = 2 * pos + 1, r = 2 * pos + 2;\n    if (l &lt; n &amp;&amp; v[l] &gt; v[largest]) {\n        largest = l;\n    }\n    if (r &lt; n &amp;&amp; v[r] &gt; v[largest]) {\n        largest = r;\n    }\n    if (largest != pos) {\n        swap(v[pos], v[largest]);\n        heapify(v, n, largest);\n    }\n}\n\nvoid heapSort(vector&lt;int&gt; &amp;v, int n) {\n    for (int i = n / 2 - 1; i &gt;= 0; i--) {\n        heapify(v, n, i);\n    }\n    for (int i = n - 1; i &gt;= 0; i--) {\n        swap(v[0], v[i]);\n        heapify(v, i, 0);\n    }\n}\n</code></pre>","tags":["sortare","optimizare"]},{"location":"usor/sorting/#sortare-cu-comparator-special","title":"Sortare cu comparator special","text":"<p>Uneori, criteriul dup\u0103 care sort\u0103m un \u0219ir poate fi mai dificil de configurat de c\u0103tre <code>std::sort</code>, a\u0219a c\u0103 de multe ori suntem nevoi\u021bi s\u0103 implement\u0103m logica proprie de comparator. De cele mai multe ori, acesta va fi implementat drept o func\u021bie bool, care ia ca parametru dou\u0103 valori ale \u0219irului ce vrem s\u0103 \u00eel ordon\u0103m \u0219i le verific\u0103m folosind criteriul dorit. \u00cen secven\u021ba de mai jos, avem o structur\u0103 str \u0219i vom sorta datele de intrare din structur\u0103 folosind drept criteriu de comparare suma valorilor din pereche. Se poate observa faptul c\u0103 func\u021bia de comparare este apelat\u0103 de, \u00een acest caz, <code>std::sort</code>.</p> <pre><code>constexpr int N = 100;\n\nstruct Foo {\n    int a, b;\n};\n\nFoo v[N + 1];\n\nbool cmp(const Foo x, const Foo y) { return (x.a + x.b) &lt; (y.a + y.b); }\n\nsort(v + 1, v + N + 1, cmp);\n\n// Alternativ (vom elabora \u00eentr-o lec\u021bie viitoare):\nvector&lt;Foo&gt; foos(N + 1);\n\nsort(foos.begin(), foos.end(),\n     [](const Foo x, const Foo y) { return (x.a + x.b) &lt; (y.a + y.b); });\n</code></pre>","tags":["sortare","optimizare"]},{"location":"usor/sorting/#sortarea-folosind-structuri-din-stl","title":"Sortarea folosind structuri din STL","text":"<p>De\u0219i aceast\u0103 metod\u0103 este mai \u00eenceat\u0103 comparat cu alte metode men\u021bionate anterior, merit\u0103 men\u021bionat\u0103 drept o utilizare suplimentar\u0103 a structurilor din STL. Structuri de date precum <code>std::map</code>, <code>std::set</code>, <code>std::multiset</code> sau <code>std::priority_queue</code> pot fi folosite cu succes pentru a simula aceste sort\u0103ri \u00een aceea\u0219i complexitate cu cea optim\u0103, dar cu o constant\u0103 mai slab\u0103, ceea ce nu le face practice atunci c\u00e2nd avem nevoie s\u0103 sort\u0103m datele rapid.</p> <p>Mai jos g\u0103si\u021bi un exemplu de implementare cu <code>std::multiset</code>.</p> <pre><code>multiset&lt;int&gt; s;\nfor (int i = 0; i &lt; n; i++) {\n    s.insert(v[i]);\n}\n\nvector&lt;int&gt; sorted;\nfor (auto x : s) {\n    sorted.push_back(x);\n}\n</code></pre>","tags":["sortare","optimizare"]},{"location":"usor/sorting/#algoritmi-speciali-de-sortare","title":"Algoritmi speciali de sortare","text":"","tags":["sortare","optimizare"]},{"location":"usor/sorting/#counting-sort","title":"Counting Sort","text":"<p>Counting sort este un algoritm de sortare folosit atunci c\u00e2nd avem un num\u0103r mic de elemente distincte, care pot fi \u021binute \u00eentr-un vector de frecven\u021b\u0103. Acest algoritm se poate folosi \u0219i dac\u0103 intervalul \u00een care sunt a\u0219ezate valorile este unul mic, complexitatea fiind \u00een ambele cazuri \\(\\mathcal{O}(n + k)\\), unde \\(n\\) este num\u0103rul de valori din \u0219ir, iar \\(k\\) este diferen\u021ba dintre cea mai mare \u0219i cea mai mic\u0103 valoare din \u0219ir.</p> <p>Observa\u021bie</p> <p>Este de remarcat c\u0103 acest algoritm poate fi implementat \u0219i folosind <code>std::map</code>, complexitatea de timp fiind mai mare cu \\(\\log n\\) din cauza opera\u021biilor specifice acestei structuri de date.</p> <pre><code>int n;\ncin &gt;&gt; n;\n\nvector&lt;int&gt; v(n);\nvector&lt;int&gt; frq(MAXVAL);\nfor (int i = 0; i &lt; n; i++) {\n    cin &gt;&gt; v[i];\n    frq[v[i]]++;\n}\n\nint pos = 0;\nfor (int i = 0; i &lt; MAXVAL; i++) {\n    while (frq[i]) {\n        v[pos] = i;\n        frq[i]--;\n        pos++;\n    }\n}\n</code></pre>","tags":["sortare","optimizare"]},{"location":"usor/sorting/#radix-sort","title":"Radix Sort","text":"<p>Radix sort este un algoritm de sortare folosit atunci c\u00e2nd vrem s\u0103 grup\u0103m elementele \u00een func\u021bie de cifrele lor, de la cea mai semnificativ\u0103 la cea mai nesemnificativ\u0103, acest algoritm fiind util \u00eentr-o serie de probleme ce implic\u0103 prelucrarea cifrelor \u0219i numerelor \u00een diferite moduri.</p> <pre><code>void radix_sort(vector&lt;int&gt; v, int pwr) {\n    if (pwr == 0) {\n        for (int i = 0; i &lt; v.size(); ++i) {\n            v2[poz++] = v[i];\n        }\n        return;\n    }\n    vector&lt;int&gt; a[10];\n    for (int i = 0; i &lt; v.size(); ++i) {\n        int val = v[i] % pwr;\n        if (pwr != 1) {\n            val /= (pwr / 10);\n        }\n        a[val].push_back(v[i]);\n    }\n    for (int i = 0; i &lt; 10; ++i) {\n        if (!a[i].empty()) {\n            radix_sort(a[i], pwr / 10);\n        }\n    }\n}\n</code></pre>","tags":["sortare","optimizare"]},{"location":"usor/sorting/#concluzii-si-probleme-suplimentare","title":"Concluzii \u0219i probleme suplimentare","text":"<p>Algoritmii de sortare sunt foarte utili pentru a \u00een\u021belege bazele multor algoritmi, diversele metode folosite reg\u0103sindu-se \u00een foarte multe tipuri de probleme, dar \u0219i \u00een anumite optimiz\u0103ri care pot fi g\u0103site pentru a evita tratarea anumitor probleme \u00eentr-o manier\u0103 prea generic\u0103.</p> <p>Ace\u0219ti algoritmi ajung s\u0103 fie folosi\u021bi \u00een foarte multe tipuri de probleme, cele mai frecvente fiind aplica\u021biile tip greedy dar \u0219i alte probleme \u00een care sortarea poate consta un pas spre a procesa mai u\u0219or datele de intrare, precum c\u0103utarea binar\u0103, diverse probleme ce implic\u0103 structuri de date \u0219i a\u0219a mai departe.</p>","tags":["sortare","optimizare"]},{"location":"usor/sorting/#probleme-de-la-olimpiade","title":"Probleme de la olimpiade","text":"<ul> <li>perechi kilonova</li> <li>Probleme cu sortari de pe     pbinfo</li> <li>sir OJI 2005</li> <li>USACO Bronze Acowdemia     I</li> <li>Pergament OJI 2023</li> <li>pseudocmp OJI 2022</li> <li>yinyang OJI 2019</li> <li>JOI 2018 Stove</li> <li>JOI 2018 Art Exhibition</li> <li>InfoPro insertsort</li> <li>probleme cu sortare de pe Kilonova</li> <li>High Card Low Card USACO     Gold</li> </ul>","tags":["sortare","optimizare"]},{"location":"usor/sorting/#probleme-de-pe-alte-siteuri","title":"Probleme de pe alte siteuri","text":"<ul> <li>Distinct Numbers</li> <li>Movie Festival</li> <li>Towers</li> <li>Kayaking</li> <li>Movie Festival II</li> <li>Tasks and Deadlines</li> <li>Permutator</li> <li>Playing in a Casino</li> <li>The Party and Sweets</li> <li>USB vs. PS/2</li> </ul>","tags":["sortare","optimizare"]},{"location":"usor/sorting/#bibliografie-si-lectura-suplimentara","title":"Bibliografie \u0219i lectur\u0103 suplimentar\u0103","text":"<ul> <li>Introduction to Sorting - USACO     Guide</li> <li>Greedy Algorithms with     Sorting</li> <li>Sortarea prin     num\u0103rare</li> <li>Tutorial Video RoAlgo</li> </ul>","tags":["sortare","optimizare"]}]}
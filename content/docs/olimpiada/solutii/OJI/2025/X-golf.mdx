---
id: OJI-2025-X-golf
title: SoluÈ›ia problemei Golf (OJI 2025, clasa a X-a)
problem_id: 3632
authors: [onut]
prerequisites:
  - lee
  - partial-sums
tags:
  - OJI
  - clasa X
---

## Subtask 1

Pentru a determina numÄƒrul de celule din golf ce sunt umplute cu pÄƒmÃ¢nÈ›se pot citi caracterele (de 0 sau 1) ce reprezintÄƒ elementele matricei $A$, unul cÃ¢te unul. AÈ™adar, Ã®ntr-o variabilÄƒ $E$, se poate reÈ›ine rÄƒspunsul pentru prima cerinÈ›Äƒ: astfel, pentru fiecare caracter de 1 Ã®ntÃ¢lnit Ã®n $A$, se incrementeazÄƒ valoarea lui $E$. La final, dupÄƒ ce toate cele $n \times m$ elemente din matrice au fost citite, se afiÈ™eazÄƒ valoarea lui $E$. Complexitatea totalÄƒ de timp este de $\mathcal{O} (n \cdot m)$, iar spaÈ›iul utilizat se Ã®ncadreazÄƒ Ã®n $\mathcal{O}(1)$ (nu este nevoie sÄƒ stocÄƒm niciun tablou/vector â€” totul se efectueazÄƒ cu ajutorul unui numÄƒr mic, constant de variabile).

## Subtask 2

De vreme ce se garanteazÄƒ (prin tabelul cu RestricÈ›ii È™i precizÄƒri din enunÈ›) cÄƒ existÄƒ o singurÄƒ insulÄƒ Ã®n golf, Ã®nseamnÄƒ cÄƒ numÄƒrul de insule (din [Golful Biscayne](https://en.wikipedia.org/wiki/Biscayne_Bay)) ce conÈ›in un numÄƒr maxim de insule (adicÄƒ rÄƒspunsul la cerinÈ›a de rezolvat) este chiar 1.

## Subtask 3

Pentru a determina numÄƒrul de celule ce fac parte din fiecare insulÄƒ a golfului, se poate folosi un algoritm ce adaugÄƒ, Ã®n timpul descoperirii unei insule, fiecare element de 1 Ã®ntr-o structurÄƒ de date similarÄƒ cu o coadÄƒ exact o singurÄƒ datÄƒ (spre exemplu, folosind un tablou auxiliar Ã®n care se marcheazÄƒ vizitarea elementelor Ã®n cadrul unei iteraÈ›ii anterioare), cum ar fi Algoritmul lui Lee; dacÄƒ dorim sÄƒ folosim o metodÄƒ recursivÄƒ, recomandÄƒm È™i Algoritmul de tip Flood Fill. Pentru fiecare insulÄƒ $\alpha$, se poate stoca È™i o variabilÄƒ $\mathrm{num}_\alpha$ (de tip `int`) care reÈ›ine numÄƒrul de celule umplute cu pÄƒmÃ¢nt ce intrÄƒ Ã®n alcÄƒtuirea sa. Apoi, printr-o parcurgere a acestei structuri de date (de exemplu, `struct`, Ã®n C/C++) ce reÈ›ine informaÈ›ii despre insule (structura conÈ›ine, Ã®n total, cel mult $\mathcal{O}(n \times m)$ elemente, corespunzÄƒtoare insulelor), se calculeazÄƒ numÄƒrul elementelor $\mathrm{num}_\alpha$ maximale. Astfel, atÃ¢t complexitatea de timp, cÃ¢t È™i cea de spaÈ›iu, sunt de $\mathcal{O}(n \times m)$.

## Subtask 4

Pentru fiecare interogare dintre cele $Q$, se pot gÄƒsi insulele ce *influenÈ›eazÄƒ* (altfel spus, modificÄƒ) rezultatul, Ã®ntr-o manierÄƒ similarÄƒ cu cea pentru al treilea subtask. Astfel, sÄƒ presupunem cÄƒ avem de rezolvat o interogare de tipul $(C, p)$ (unde $1 â‰¤ p â‰¤ m$). Fie $I_\alpha = {(ğ‘¥_{\alpha,1}, ğ‘¦_{\alpha,1}), (ğ‘¥_{\alpha,2}, ğ‘¦_{\alpha,2}), . . . , (ğ‘¥_{\alpha,k_\alpha} , ğ‘¦_{\alpha,k_\alpha} )}$ mulÈ›imea ce conÈ›ine **toate** cele $k_\alpha$ celule (reprezentate prin perechi formate din linia $x_{\alpha,i}$, respectiv coloana $y_{\alpha,i}$ â€” coordonatele celulelor Ã®n matricea $A$) ce intrÄƒ Ã®n alcÄƒtuirea unei insule $\alpha$; spunem cÄƒ insula $\alpha$ are dimensiunea egalÄƒ cu $k_\alpha$.

DacÄƒ $\max(y_{\alpha,1}, y_{\alpha,2}, ..., y_{\alpha,k_\alpha}) < p$, Ã®nseamnÄƒ cÄƒ insula $\alpha$ este situatÄƒ la stÃ¢nga coloanei $p$, aÈ™a cÄƒ valoarea lui $b$ (adicÄƒ, conform enunÈ›ului, numÄƒrul de celule din toate insulele ce se aflÄƒ la stÃ¢nga coloanei $p$, Ã®n cadrul interogÄƒrii curente) creÈ™te cu $k_\alpha$; altfel, dacÄƒ $\min(y_{\alpha,1}, y_{\alpha,2}, ..., y_{\alpha,k_\alpha}) > p$, Ã®nseamnÄƒ cÄƒ insula $\alpha$ este situatÄƒ la dreapta coloanei $p$, aÈ™a cÄƒ valoarea lui $b$ (numÄƒrul de celule din toate insulele ce se aflÄƒ la dreapta coloanei $p$) creÈ™te cu $k_\alpha$. Ãn orice alt caz, valorile lui $a$ È™i $b$ nu se modificÄƒ (cu ocazia procesÄƒrii insulei curente $\alpha$).

Ãn mod similar, putem raÈ›iona pentru o interogare de tipul $(L, p)$ (unde $1 â‰¤ p â‰¤ n$) â€“ Ã®n loc sÄƒ folosim coordonatele de tip coloanÄƒ $y_{\alpha,i}$, le vom folosi pe cele de tip linie $x_{\alpha,i}$ .

Prin urmare, complexitatea totalÄƒ de timp este de $\mathcal{O}(Q \cdot n \cdotm)$, iar cea de spaÈ›iu este de $\mathcal{O}(n \cdot m)$.

## Subtask 5

De vreme ce interog Äƒrile de tip $(L, p)$ pot fi rezolvate Ã®ntr-un mod analog cu cele de tip $(C, p)$ (de exemplu, prin *Ã®nlocuirea* liniilor matricei cu coloanele acesteia È™i viceversa, sau prin folosirea unei structuri de date de forma `std::pair<int, int>`, Ã®n C++), putem sÄƒ presupunem, pentru simplicitate, cÄƒ avem de rÄƒspuns doar la interogÄƒri de tipul $(C, p)$.

Determinarea tuturor insulelor $\alpha$ (adicÄƒ a coordonatelor celulelor ce intrÄƒ Ã®n alcÄƒtuirea unei insule È™i a dimensiunii acesteia) se poate efectua Ã®n complexitatea (totalÄƒ) de timp $\mathcal{O}(n \cdot m)$, aÈ™a cum a fost descris anterior.

Ãn cadrul unei insule $\alpha$, sÄƒ introducem urmÄƒtoarele douÄƒ notaÈ›ii:

* $\mu_{y,\alpha} = \max(y_{\alpha,1}, y_{\alpha,2}, ..., y_{\alpha,k_\alpha})$
* $\omega_{y,\alpha} = \min(y_{\alpha,1}, y_{\alpha,2}, ..., y_{\alpha,k_\alpha})$

Mai mult, introducem È™i urmÄƒtoarele douÄƒ tablouri unidimensionale $l[1, ..., m]$ È™i $r [1, ..., m]$, definite astfel (pentru fiecare $1 â‰¤ i â‰¤ m$):

$$
l[i] = \sum_{\substack{\alpha \\ \mu_{y,\alpha} = i}} k_\alpha;
\qquad r[i] = \sum_{\substack{\alpha \\ \omega_{y,\alpha} = i}} k_\alpha
$$

Cu alte cuvinte, $l[i]$ reprezintÄƒ suma dimensiunilor insulelor din golf ce au valoarea maximalÄƒ a unei coloane (a unei celule din componenÈ›Äƒ) egalÄƒ cu $i$. Similar, $r[i]$ reprezintÄƒ suma dimensiunilor insulelor din golf ce au valoarea minimalÄƒ a unei coloane egalÄƒ cu $i$.

AÈ™adar, rÄƒspunsul pentru o interogare de tipul $(C, p)$ este dat de valoarea expresiei $a \cdot b$, unde:

$$
a
= \sum_{\substack{\alpha \\ \mu_{y,\alpha} < p}} k_\alpha
= \sum_{\substack{\alpha \\ \mu_{y,\alpha} \in \{1, ..., p-1\}}} k_\alpha
= \sum_{i = 1}^{p - 1} l[i]
$$

È™i

$$
b
= \sum_{\substack{\alpha \\ \omega_{y,\alpha} < p}} k_\alpha
= \sum_{\substack{\alpha \\ \omega_{y,\alpha} \in \{p + 1, ..., m\}}} k_\alpha
= \sum_{i = p + 1}^{m} r[i]
$$

AtÃ¢t $a$, cÃ¢t È™i $b$, pot fi calculate printr-o parcurgere (liniarÄƒ) a tablourilor $l[1, ..., m]$ È™i $r[1, ..., m]$. Ãn funcÈ›ie de elementul $i$ de analizat (dacÄƒ $i < p$ sau $i > p$), se actualizeazÄƒ valoarea lui $a$ sau valoarea lui $b$.

Astfel, complexitatea de timp necesarÄƒ pentru a rezolva o interogare de tipul $(C, p)$ este de $\mathcal{O}(m)$. Similar, complexitatea de timp necesarÄƒ pentru a rezolva o interogare de tipul $(L, p)$ este de $\mathcal{O}(n)$.

Prin urmare, complexitatea totalÄƒ a acestui subtask este de $\mathcal{O} (n
\cdot m + Q \cdot \max (n, m))$.

## SoluÈ›ie completÄƒ pentru $T = 3$

AplicÄƒm o metodÄƒ de rezolvare similarÄƒ cu cea pentru al cincilea subtask.

ObservÄƒm cÄƒ, Ã®n cadrul unei interogÄƒri, pentru a determina, de exemplu, valoarea lui $a$, putem utiliza o tehnicÄƒ de sume parÈ›iale, pe prefixele È™irului $l [1, ..., m]$; de asemenea, valoarea lui $b$ poate fi calculatÄƒ tot cu sume parÈ›iale, pe sufixele È™irului $r [1, ..., m]$. Procesarea sumelor parÈ›iale se poate efectua Ã®n complexitatea de timp (cÃ¢t È™i de spaÈ›iu) de $\mathcal{O}(m)$ (pentru coloane) sau de $\mathcal{O}(n)$ (pentru linii). Apoi, rezolvarea oricÄƒrei actualizÄƒri se poate efectua Ã®n $\mathcal{O}(1)$. Complexitatea de timp totalÄƒ a acestei soluÈ›ii este de $\mathcal{O}(n \cdot m + Q)$. SpaÈ›iul utilizat se Ã®ncadreazÄƒ Ã®n $\mathcal{O}(n \cdot m)$.

## Rezolvare

Mai jos puteÈ›i gÄƒsi o soluÈ›ie care ia punctajul maxim.

```cpp
/*
    Autor: Andrei Onut (Yale University)
    Problema: "Golf" (OJI 2025, clasa a X-a)
*/

#include <algorithm>
#include <fstream>
#include <queue>
#include <string>
#include <vector>

int my_min(const int a, const int b) { return ((a < b) ? a : b); }
int my_max(const int a, const int b) { return ((a > b) ? a : b); }

struct island {
    int first_line, first_column;
    int last_line, last_column;
    int size;

    island(const int x, const int y)
        : first_line(x),
          first_column(y),
          last_line(x),
          last_column(y),
          size(1) {}

    void update(const int x, const int y) {
        first_line = my_min(first_line, x),
        first_column = my_min(first_column, y);
        last_line = my_max(last_line, x), last_column = my_max(last_column, y);
        ++size;

        return;
    }
};

template <typename T>
std::string T_to_string(T x) {
    if (x == (T)0) {
        return "0";
    }

    std::string answer;
    while (x) {
        answer += ((char)((x % (T)10) + '0')), x /= (T)10;
    }

    reverse(answer.begin(), answer.end());
    return answer;
}

class golf_solver {
    const std::string problem_name = "golf", dot = ".", input_format = "in",
                      output_format = "out";

    const int dx[4] = {(-1), 0, (+1), 0}, dy[4] = {0, (+1), 0, (-1)};

    int T, n, m, q;

    std::vector<std::string> A;

    std::vector<std::pair<char, int>> queries;
    std::vector<long long> answer;

    std::vector<island> islands_arr;

    int answer_1, answer_2;

    island find_island(const int i, const int j,
                       std::vector<std::vector<bool>> &used) {
        island answer(i, j);

        std::queue<std::pair<int, int>> Q;

        used[i][j] = true, Q.push({i, j});
        while (!Q.empty()) {
            for (int dir = 0; dir < 4; ++dir) {
                int x(Q.front().first + dx[dir]), y(Q.front().second + dy[dir]);

                if ((x < 0) || (x >= n) || (y < 0) || (y >= m)) {
                    continue;
                }

                if (A[x][y] == '0') {
                    continue;
                }
                if (used[x][y] == true) {
                    continue;
                }

                used[x][y] = true, Q.push({x, y});
                answer.update(x, y);
            }

            Q.pop();
        }

        return answer;
    }

    void solve_T_1() {
        for (const island &it : islands_arr) {
            answer_1 += it.size;
        }

        return;
    }

    void solve_T_2() {
        if (islands_arr.empty()) {
            return;
        }

        int max_size(-1);
        for (const island &it : islands_arr) {
            if (it.size > max_size) {
                max_size = it.size, answer_2 = 1;
            } else if (it.size == max_size) {
                ++answer_2;
            }
        }

        return;
    }

    std::vector<std::pair<std::pair<int, int>, int>> extract_segments(
        const int axis) {
        std::vector<std::pair<std::pair<int, int>, int>> answer;

        for (const island &it : islands_arr) {
            if (axis == 0) {
                answer.push_back({
                    {it.first_column, it.last_column},
                    it.size
                });
            } else {
                answer.push_back({
                    {it.first_line, it.last_line},
                    it.size
                });
            }
        }

        return answer;
    }

    std::pair<std::vector<int>, std::vector<int>> get_sums(const int axis,
                                                           const int elements) {
        std::vector<int> prefix(elements, 0), suffix(elements, 0);

        std::vector<std::pair<std::pair<int, int>, int>> segments =
            extract_segments(axis);

        std::vector<int> end_num(elements, 0), start_num(elements, 0);
        for (const std::pair<std::pair<int, int>, int> &it : segments) {
            end_num[it.first.second] += it.second,
                start_num[it.first.first] += it.second;
        }

        prefix[0] = end_num[0],
        suffix[(elements - 1)] = start_num[(elements - 1)];
        for (int i = 1; i < elements; ++i) {
            prefix[i] = (prefix[(i - 1)] + end_num[i]),
            suffix[(elements - 1 - i)] =
                (suffix[(elements - i)] + start_num[(elements - 1 - i)]);
        }

        return {prefix, suffix};
    }

    long long evaluate(const int q_idx, const int elements,
                       const std::pair<std::vector<int>, std::vector<int>> &V) {
        if ((q_idx == 1) || (q_idx == elements)) {
            return 0LL;
        }
        return (1LL * V.first[(q_idx - 2)] * V.second[q_idx]);
    }

    void solve_T_3() {
        std::pair<std::vector<int>, std::vector<int>> columns = get_sums(0, m),
                                                      lines = get_sums(1, n);

        int i = 0;
        for (const std::pair<char, int> &it : queries) {
            answer[(i++)] = ((it.first == 'C') ? evaluate(it.second, m, columns)
                                               : evaluate(it.second, n, lines));
        }

        return;
    }

public:
    golf_solver() : T(0), n(0), m(0), q(0), answer_1(0), answer_2(0) {}

    void read() {
        std::ifstream f(problem_name + dot + input_format);

        f >> T >> n >> m;

        A = std::vector<std::string>(n, std::string(m, ' '));
        for (int i(0); i < n; ++i) {
            f >> A[i];
        }

        if (T == 3) {
            f >> q;

            queries = std::vector<std::pair<char, int>>(q),
            answer = std::vector<long long>(q);
            for (int i(0); i < q; ++i) {
                f >> queries[i].first >> queries[i].second;
            }
        }

        f.close();
        return;
    }

    void pre_compute() {
        std::vector<std::vector<bool>> used(n, std::vector<bool>(m, false));

        for (int i = 0; i < n; ++i) {
            for (int j = 0; j < m; ++j) {
                if ((A[i][j] == '1') && (used[i][j] == false)) {
                    islands_arr.push_back(find_island(i, j, used));
                }
            }
        }

        return;
    }

    void solve() {
        ((T == 1) ? solve_T_1() : ((T == 2) ? solve_T_2() : solve_T_3()));
        return;
    }

    void print() {
        std::ofstream g(problem_name + dot + output_format);

        std::vector<std::string> output_lines(((T <= 2) ? 1 : q));

        if (T == 1) {
            output_lines[0] = T_to_string<int>(answer_1);
        } else if (T == 2) {
            output_lines[0] = T_to_string<int>(answer_2);
        } else {
            for (int i = 0; i < q; ++i) {
                output_lines[i] = T_to_string<long long>(answer[i]);
            }
        }

        for (const std::string &line : output_lines) {
            g << line << '\n';
        }

        g.close();
        return;
    }
};

int main() {
    golf_solver S;

    S.read();
    S.pre_compute();
    S.solve();
    S.print();

    return 0;
}
```
